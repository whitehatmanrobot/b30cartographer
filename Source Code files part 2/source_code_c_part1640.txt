        "RegistrySaveConfig: open/create config key failed(%ld)", 
               lRes);

        return lRes;
    }

    // for speed we use a local buffer. If it is too small, alloc one
    pwszBuffer = wszBuffer;
    dwBufferLengthW = ARRAYSIZE(wszBuffer);

    // for each type
    for (dwModeCnt=0; dwModeCnt<NUM_NDP_MODES; dwModeCnt++)
    {   
        pAddress = pAddressListArray[dwModeCnt];

        // calculate the length needed for multistring
        dwTotalLengthW = 1;
        while (pAddress!=NULL)
        {
            dwTotalLengthW += pAddress->dwAddressLength + 1;
            pAddress = pAddress->pNext;
        }

        if (dwTotalLengthW > dwBufferLengthW)
        {
            // need a bigger buffer..
            if (pwszBuffer!=wszBuffer)
            {
                FREE(pwszBuffer);
            }

            pwszBuffer = MALLOC(dwTotalLengthW*sizeof(WCHAR));
            if (pwszBuffer == NULL)
            {
                TspLog(DL_ERROR, "RegistrySaveConfig: out of mem");
                RegCloseKey(hKey);
                return ERROR_OUTOFMEMORY;
            }
            dwBufferLengthW = dwTotalLengthW;
        }

        pAddress = pAddressListArray[dwModeCnt];
        pwszCrt = pwszBuffer;
        
        // linear search, hope not too many values...
        while (pAddress != NULL)
        {
            // Add the value to the multi string
            lstrcpyW(pwszCrt, pAddress->pwszAddress);
            // prepare for next string
            pwszCrt += pAddress->dwAddressLength + 1 ;
        
            pAddress = pAddress->pNext;
        }
        // final NULL
        *pwszCrt++ = L'\0';

        dwLengthW = (DWORD)(pwszCrt - pwszBuffer);
        lRes = RegSetValueExW(hKey,
                                 NdpModeArray[dwModeCnt].pwszRegString,
                                 0,
                                 REG_MULTI_SZ,
                                 (PVOID)pwszBuffer,
                                 dwLengthW*sizeof(WCHAR));
        if (lRes != ERROR_SUCCESS)
        {
            TspLog(DL_ERROR, "RegistrySaveConfig: failed(%ld) to save value",
                   lRes);
            break;
        }
    }

    // notify the server with a volatile key
    if (lRes==ERROR_SUCCESS)
    {
        lRes = RegCreateKeyExW(hKey,
                                  NDPTSP_NOTIFY_SUBKEY,
                                  0,
                                  NULL,
                                  REG_OPTION_VOLATILE,
                                  KEY_READ,
                                  NULL,
                                  &hNotifyKey,
                                  &dwDisp);

        if (lRes == ERROR_SUCCESS)
        {
            RegCloseKey(hNotifyKey);
        }
        else
        {
            TspLog(DL_ERROR, 
                   "RegistrySaveConfig: failed(%ld) to create notify key",
                   lRes);
        }
    }

    RegCloseKey(hKey);
    if (pwszBuffer != wszBuffer)
    {
        FREE(pwszBuffer);
    }

    return lRes;
}

LONG
RegistryLoadConfig(
    PADDRESS_MAP *pAddressListArray
    )
{
    HKEY            hKey;
    LONG            lRes;
    DWORD           dwDisp;
    DWORD           dwModeCnt;
    PADDRESS_MAP    pAddress;
    PADDRESS_MAP    pPrevCell;
    DWORD           dwLength;
    DWORD           dwLengthW;
    DWORD           dwBufferLength;
    DWORD           dwType;
    WCHAR           wszBuffer[0x100];
    PWSTR           pwszBuffer;
    PWSTR           pwszCrt;

    FreeAllAddressLists(pAddressListArray);
    
    // Open/create the key
    lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                              NDPTSP_REGKEY_ROOT,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ ,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lRes != ERROR_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "RegistryLoadConfig: open/create config key failed(%ld)",
               lRes);

        return lRes;
    }

    // for speed we use a local buffer. If it is too small, alloc one
    pwszBuffer = wszBuffer;
    dwBufferLength = sizeof(wszBuffer); // In bytes !!

    // for each type
    for (dwModeCnt=0; dwModeCnt<NUM_NDP_MODES; dwModeCnt++)
    {   
        pPrevCell = NULL;

        // try to load the value. If the space is a problem, grow the buffer
        while (TRUE)
        {
            dwLength = dwBufferLength;
            lRes = RegQueryValueExW(hKey,
                                       NdpModeArray[dwModeCnt].pwszRegString,
                                       NULL,
                                       &dwType,
                                       (PVOID)pwszBuffer,
                                       &dwLength
                                       );

            if (lRes == ERROR_MORE_DATA)
            {
                // need a bigger buffer..
                if (pwszBuffer!=wszBuffer)
                {
                    FREE(pwszBuffer);
                }

                pwszBuffer = MALLOC(dwLength);
                if (pwszBuffer == NULL)
                {
                    TspLog(DL_ERROR, "RegistryLoadConfig: out of mem");
                    RegCloseKey(hKey);
                    return ERROR_OUTOFMEMORY;
                }

                dwBufferLength = dwLength;
            }
            else
            {
                break;
            }
        }

        if (lRes != ERROR_SUCCESS || dwType != REG_MULTI_SZ)
        {
            // no values
            pwszBuffer[0] = L'\0';
            lRes = ERROR_SUCCESS;
        }
            
        // parse the multistring and create the list    
        pwszCrt = pwszBuffer;

        while (*pwszCrt != L'\0')
        {
            // Alloc a cell
            pAddress = (PADDRESS_MAP)MALLOC(sizeof(ADDRESS_MAP));
            if (pAddress!= NULL)
            {
                dwLengthW = lstrlenW(pwszCrt);
                pAddress->pwszAddress = MALLOC((dwLengthW + 1)*sizeof(WCHAR));
                if (pAddress->pwszAddress != NULL)
                {
                    lstrcpynW(pAddress->pwszAddress, pwszCrt, dwLengthW+1);
                    pAddress->dwAddressLength = dwLengthW;

                    // Insert in the list. Don't matter where, the lists are not sorted...
                    pAddress->pNext = NULL;
                    pAddress->pPrev = pPrevCell;
                    if (pPrevCell)
                        pPrevCell->pNext = pAddress;
                    else
                        pAddressListArray[dwModeCnt] = pAddress;
                                        
                    pPrevCell = pAddress;
                }
                else
                {
                    TspLog(DL_ERROR, "RegistryLoadConfig: out of mem");
                    lRes = ERROR_OUTOFMEMORY;
                    FREE(pAddress);
                    break;
                }
            }
            else
            {
                TspLog(DL_ERROR, "RegistryLoadConfig: out of mem");
                lRes = ERROR_OUTOFMEMORY;
                break;
            }

            // Next string
            pwszCrt += dwLengthW + 1;
        }
    }

    if (lRes!=ERROR_SUCCESS)
    {
        FreeAllAddressLists(pAddressListArray);
    }

    RegCloseKey(hKey);
    if (pwszBuffer != wszBuffer)
    {
        FREE(pwszBuffer);
    }

    return lRes;
}

LONG
GetMediaModeForAddress(
    PCWSTR  pwszAddress,
    DWORD * pdwMediaMode
    )
{

    LONG            lRes;
    DWORD           dwModeIndex;
    PADDRESS_MAP    pAddressEntry;

    EnterCriticalSection(&gAddressMapCritSec);

    // force a reload:
    // 1. at first call
    // 2. after a change notification
    if (gbAddressMapListLoaded)
    {
        lRes = RegDeleteKeyW(HKEY_LOCAL_MACHINE,
                                NDPTSP_NOTIFY_REGKEY_ROOT);

        gbAddressMapListLoaded = (lRes != ERROR_SUCCESS);
    }

    lRes = ERROR_SUCCESS;
    if (!gbAddressMapListLoaded)
    {
        TspLog(DL_TRACE, "GetMediaModeForAddress: reload the reg settings");

        lRes = RegistryLoadConfig(gpAddressMapListArray);
    }

    if (lRes == ERROR_SUCCESS)
    {
        if (FindAddressInLists(gpAddressMapListArray,
                              pwszAddress,
                              &dwModeIndex,
                              &pAddressEntry))
        {
            *pdwMediaMode = NdpModeArray[dwModeIndex].dwMediaMode;
        }
        else
        {
            *pdwMediaMode = LINEMEDIAMODE_UNKNOWN;
        }
    }

    LeaveCriticalSection(&gAddressMapCritSec);

    return lRes;
}

void
UpdateAddressListBox(
    PADDRESS_MAP    pAddress,
    HWND            hwndListBox
    )
{

    SendMessageW(hwndListBox, LB_RESETCONTENT, 0, 0);

    for (; pAddress!=NULL; pAddress = pAddress->pNext)
    {
         SendMessageW(hwndListBox, 
                      LB_ADDSTRING, 
                      0, 
                      (LPARAM)(pAddress->pwszAddress));
    }
}

INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LONG                    lStatus;
    CONFIG_UI_CTX           *UIContext;
    DWORD                   dwModeIndex;
    LONG                    lIndex;
    LONG                    lRes;
    WCHAR                   wszTmp[0x40];

    // decode
    switch (uMsg) {
    
    case WM_HELP:

        // F1 key or the "?" button is pressed
        (void) WinHelpW(((LPHELPINFO)lParam)->hItemHandle,
                        NDPTSP_HELP_FILE,
                        HELP_WM_HELP,
                        (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_MEDIA_MAP);

        break;

    case WM_CONTEXTMENU:

        // Right-mouse click on a dialog control
        (void) WinHelpW((HWND)wParam,
                        NDPTSP_HELP_FILE,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_MEDIA_MAP);

        break;

    case WM_INITDIALOG:

        SetWindowLongPtr(
                hDlg,
                DWLP_USER,
                lParam);

        UIContext = (CONFIG_UI_CTX *)lParam;
        
        // Get the registry values
        lRes = RegistryLoadConfig(UIContext->pAddressMapListArray);
        if (lRes != ERROR_SUCCESS)
        {
            WCHAR wszErrorMsg[0x100];

            TspLog(DL_ERROR, 
                   "ProviderConfigDlgProc: loading reg key failed(0x%08lx)", 
                   lRes);

            // load error string
            LoadStringW(ghInstance,
                        IDS_ERR_REGLOAD,
                        wszErrorMsg,
                        ARRAYSIZE(wszErrorMsg));

            // pop up error dialog
            MessageBoxW(hDlg, wszErrorMsg, NULL, MB_OK | MB_ICONSTOP);

            // stop dialog
            EndDialog(hDlg, 0);

            break;
        }

        
        // populate the combo box
        for (dwModeIndex = 0; dwModeIndex < NUM_NDP_MODES; dwModeIndex++)
        {
            LoadStringW(ghInstance,
                        NdpModeArray[dwModeIndex].dwResourceID,
                        wszTmp,
                        ARRAYSIZE(wszTmp));

        
            lIndex = (LONG)SendDlgItemMessageW(hDlg, 
                                               IDC_MEDIA_TYPE, 
                                               CB_ADDSTRING, 
                                               0, 
                                               (LPARAM)wszTmp);
            if (lIndex >= 0)
            {
                SendDlgItemMessage(hDlg, 
                                   IDC_MEDIA_TYPE, 
                                   CB_SETITEMDATA, 
                                   (WPARAM)lIndex, 
                                   (LPARAM)dwModeIndex);
            }
            else {
                TspLog(DL_ERROR, 
                       "ProviderConfigDlgProc: CB_ADDSTRING failed(%ld)", 
                       lIndex);
            }
        
        }

        // select the first
        SendDlgItemMessage(hDlg, IDC_MEDIA_TYPE, CB_SETCURSEL, (WPARAM)0, 0);
        dwModeIndex = (DWORD)SendDlgItemMessageW(hDlg, 
                                                 IDC_MEDIA_TYPE, 
                                                 CB_GETITEMDATA, 
                                                 (WPARAM)0, 
                                                 0);
        
        UIContext->hwndListBox = GetDlgItem(hDlg, IDC_ADDRESS_LIST);
        UIContext->dwCrtTypeIndex = dwModeIndex;

        // update the listbox
        UpdateAddressListBox(UIContext->pAddressMapListArray[dwModeIndex], 
                             UIContext->hwndListBox);

        // Disable the Delete button
        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), FALSE); 

        break;

    case WM_COMMAND:

        UIContext = (CONFIG_UI_CTX *)GetWindowLongPtr(hDlg, DWLP_USER);

        // decode command
        switch(LOWORD(wParam))
        {
        case IDC_ADD_ADDRESS:

            if (HIWORD(wParam)==BN_CLICKED)
            {
                DialogBoxParamW(ghInstance,
                                (LPWSTR)MAKEINTRESOURCE(IDD_MEDIA_ADD),
                                hDlg,
                                ProviderConfigDetailDlgProc,
                                (LPARAM)UIContext);
                }
            break;

        case IDC_DELETE_ADDRESS:

            if (HIWORD(wParam)==BN_CLICKED)
            {
                lIndex = (LONG)SendDlgItemMessageW(hDlg, 
                                                   IDC_ADDRESS_LIST, 
                                                   LB_GETCURSEL, 
                                                   0, 
                                                   0);
                if (lIndex>=0)
                {
                    PWSTR           pwszAddress = NULL;
                    DWORD           dwLengthW;
                    DWORD           dwMode;
                    PADDRESS_MAP    pAddress;

                    dwLengthW =1 + (DWORD)SendDlgItemMessageW(hDlg, 
                                                              IDC_ADDRESS_LIST, 
                                                              LB_GETTEXTLEN, 
                                                              (WPARAM)lIndex, 
                                                              0);
                    
                    pwszAddress = (dwLengthW <= ARRAYSIZE(wszTmp)) ? wszTmp : 
                        MALLOC(dwLengthW * sizeof(WCHAR));

                    if (pwszAddress)
                    {
                        SendDlgItemMessageW(hDlg, 
                                            IDC_ADDRESS_LIST, 
                                            LB_GETTEXT, 
                                            (WPARAM)lIndex, 
                                            (LPARAM)pwszAddress);

                        // Find the address in the lists
                        if (FindAddressInLists(UIContext->pAddressMapListArray,
                                              pwszAddress,
                                              &dwMode,
                                              &pAddress))
                        {
                            // delete from list
                            if (pAddress->pNext)
                            {
                                pAddress->pNext->pPrev = pAddress->pPrev;
                            }
                            if (pAddress->pPrev)
                            {
                                pAddress->pPrev->pNext = pAddress->pNext;
                            }
                            else
                            {
                                UIContext->pAddressMapListArray[dwMode] = 
                                    pAddress->pNext;
                            }

                            FREE(pAddress->pwszAddress);
                            FREE(pAddress);
                        }
                        else
                        {
                            TspLog(DL_ERROR, 
                                   "ProviderConfigDlgProc: "\
                                   "IDC_DELETE_ADDRESS - cannot find address");
                        }

                        // delete from list box
                        SendDlgItemMessageW(hDlg, 
                                            IDC_ADDRESS_LIST, 
                                            LB_DELETESTRING, 
                                            (WPARAM)lIndex, 
                                            0);

                        // Try to select the previous one
                        if (lIndex > 0)
                        {
                            lIndex--;
                        }

                        if (LB_ERR == SendDlgItemMessageW(hDlg, 
                                                          IDC_ADDRESS_LIST, 
                                                          LB_SETCURSEL, 
                                                          (WPARAM)lIndex, 
                                                          0))
                        {
                            // Disable the Delete button
                            EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), 
                                         FALSE); 
                        }
                            
                        
                        if (pwszAddress != wszTmp)
                        {
                            FREE(pwszAddress);
                        }
                    }
                    else
                    {
                        TspLog(DL_ERROR, 
                               "ProviderConfigDlgProc: "\
                               "IDC_DELETE_ADDRESS - out of memory");
                    }
                }
                else
                {
                    TspLog(DL_ERROR, "ProviderConfigDlgProc: "\
                           "IDC_DELETE_ADDRESS - no item selected");
                }
            }

            break;

        case IDOK:
            RegistrySaveConfig(UIContext->pAddressMapListArray);

            FreeAllAddressLists(UIContext->pAddressMapListArray);

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDCANCEL:

            FreeAllAddressLists(UIContext->pAddressMapListArray);

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDC_MEDIA_TYPE:    

            if (HIWORD(wParam)==CBN_SELCHANGE)
            {
                // Disable the Delete button
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), FALSE); 

                // refresh the list box
                lIndex = (LONG)SendDlgItemMessageW(hDlg, 
                                                   IDC_MEDIA_TYPE, 
                                                   CB_GETCURSEL, 
                                                   0, 
                                                   0);

                dwModeIndex = (DWORD)SendDlgItemMessageW(hDlg, 
                                                         IDC_MEDIA_TYPE, 
                                                         CB_GETITEMDATA, 
                                                         (WPARAM)lIndex, 
                                                         0);

                // Update the context structure
                UIContext->dwCrtTypeIndex = dwModeIndex;

                // update the listbox
                UpdateAddressListBox(
                    UIContext->pAddressMapListArray[dwModeIndex], 
                    GetDlgItem(hDlg, IDC_ADDRESS_LIST));
            }

            break;

        case IDC_ADDRESS_LIST:
            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                // Enable the Delete button
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), TRUE); 
            }
            break;

        }

        break;
    }

    // success
    return FALSE;
}

static char *pszOidNames[] =
{
    "Accept",
    "Answer",
    "Close",
    "CloseCall",
    "ConditionalMediaDetection",
    "ConfigDialog",
    "DevSpecific",
    "Dial",
    "Drop",
    "GetAddressCaps",
    "GetAddressID",
    "GetAddressStatus",
    "GetCallAddressID",
    "GetCallInfo",
    "GetCallStatus",
    "GetDevCaps",
    "GetDevConfig",
    "GetExtensionID",
    "GetID",
    "GetLineDevStatus",
    "MakeCall",
    "NegotiateExtVersion",
    "Open",
    "ProviderInitialize",
    "ProviderShutdown",
    "SecureCall",
    "SelectExtVersion",
    "SendUserUserInfo",
    "SetAppSpecific",
    "StCallParams",
    "StDefaultMediaDetection",
    "SetDevConfig",
    "SetMediaMode",
    "SetStatusMessages"
};

//
// translates NDIS TAPI status codes into LINEERR_XXX
//
LONG
WINAPI
TranslateDriverResult(
    ULONG   ulRes
    )
{
    typedef struct _RESULT_LOOKUP
    {
        ULONG   NdisTapiResult;
        LONG    TapiResult;

    } RESULT_LOOKUP, *PRESULT_LOOKUP;

    typedef ULONG NDIS_STATUS;
    #define NDIS_STATUS_SUCCESS     0x00000000L
    #define NDIS_STATUS_RESOURCES   0xC000009AL
    #define NDIS_STATUS_FAILURE     0xC0000001L
    #define NDIS_STATUS_INVALID_OID 0xC0010017L

    static RESULT_LOOKUP aResults[] =
    {

    //
    // Defined in NDIS.H
    //

    { NDIS_STATUS_SUCCESS                    ,0 },

    //
    // These errors are defined in NDISTAPI.H
    //

    { NDIS_STATUS_TAPI_ADDRESSBLOCKED        ,LINEERR_ADDRESSBLOCKED        },
    { NDIS_STATUS_TAPI_BEARERMODEUNAVAIL     ,LINEERR_BEARERMODEUNAVAIL     },
    { NDIS_STATUS_TAPI_CALLUNAVAIL           ,LINEERR_CALLUNAVAIL           },
    { NDIS_STATUS_TAPI_DIALBILLING           ,LINEERR_DIALBILLING           },
    { NDIS_STATUS_TAPI_DIALDIALTONE          ,LINEERR_DIALDIALTONE          },
    { NDIS_STATUS_TAPI_DIALPROMPT            ,LINEERR_DIALPROMPT            },
    { NDIS_STATUS_TAPI_DIALQUIET             ,LINEERR_DIALQUIET             },
    { NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION,LINEERR_INCOMPATIBLEEXTVERSION},
    { NDIS_STATUS_TAPI_INUSE                 ,LINEERR_INUSE                 },
    { NDIS_STATUS_TAPI_INVALADDRESS          ,LINEERR_INVALADDRESS          },
    { NDIS_STATUS_TAPI_INVALADDRESSID        ,LINEERR_INVALADDRESSID        },
    { NDIS_STATUS_TAPI_INVALADDRESSMODE      ,LINEERR_INVALADDRESSMODE      },
    { NDIS_STATUS_TAPI_INVALBEARERMODE       ,LINEERR_INVALBEARERMODE       },
    { NDIS_STATUS_TAPI_INVALCALLHANDLE       ,LINEERR_INVALCALLHANDLE       },
    { NDIS_STATUS_TAPI_INVALCALLPARAMS       ,LINEERR_INVALCALLPARAMS       },
    { NDIS_STATUS_TAPI_INVALCALLSTATE        ,LINEERR_INVALCALLSTATE        },
    { NDIS_STATUS_TAPI_INVALDEVICECLASS      ,LINEERR_INVALDEVICECLASS      },
    { NDIS_STATUS_TAPI_INVALLINEHANDLE       ,LINEERR_INVALLINEHANDLE       },
    { NDIS_STATUS_TAPI_INVALLINESTATE        ,LINEERR_INVALLINESTATE        },
    { NDIS_STATUS_TAPI_INVALMEDIAMODE        ,LINEERR_INVALMEDIAMODE        },
    { NDIS_STATUS_TAPI_INVALRATE             ,LINEERR_INVALRATE             },
    { NDIS_STATUS_TAPI_NODRIVER              ,LINEERR_NODRIVER              },
    { NDIS_STATUS_TAPI_OPERATIONUNAVAIL      ,LINEERR_OPERATIONUNAVAIL      },
    { NDIS_STATUS_TAPI_RATEUNAVAIL           ,LINEERR_RATEUNAVAIL           },
    { NDIS_STATUS_TAPI_RESOURCEUNAVAIL       ,LINEERR_RESOURCEUNAVAIL       },
    { NDIS_STATUS_TAPI_STRUCTURETOOSMALL     ,LINEERR_STRUCTURETOOSMALL     },
    { NDIS_STATUS_TAPI_USERUSERINFOTOOBIG    ,LINEERR_USERUSERINFOTOOBIG    },
    { NDIS_STATUS_TAPI_ALLOCATED             ,LINEERR_ALLOCATED             },
    { NDIS_STATUS_TAPI_INVALADDRESSSTATE     ,LINEERR_INVALADDRESSSTATE     },
    { NDIS_STATUS_TAPI_INVALPARAM            ,LINEERR_INVALPARAM            },
    { NDIS_STATUS_TAPI_NODEVICE              ,LINEERR_NODEVICE              },

    //
    // These errors are defined in NDIS.H
    //

    { NDIS_STATUS_RESOURCES                  ,LINEERR_NOMEM },
    { NDIS_STATUS_FAILURE                    ,LINEERR_OPERATIONFAILED },
    { NDIS_STATUS_INVALID_OID                ,LINEERR_OPERATIONFAILED },

    //
    //
    //

    { NDISTAPIERR_UNINITIALIZED              ,LINEERR_OPERATIONFAILED },
    { NDISTAPIERR_BADDEVICEID                ,LINEERR_OPERATIONFAILED },
    { NDISTAPIERR_DEVICEOFFLINE              ,LINEERR_OPERATIONFAILED },

    //
    // The terminating fields
    //

    { 0xffffffff, 0xffffffff }

    };

    int i;

    for (i = 0; aResults[i].NdisTapiResult != 0xffffffff; i++)
    {
        if (ulRes == aResults[i].NdisTapiResult)
        {
            return (aResults[i].TapiResult);
        }
    }

    TspLog(DL_WARNING, "TranslateDriverResult: unknown driver result(%x)",
           ulRes);

    return LINEERR_OPERATIONFAILED;
}

//
// NOTE: for functions that need to acquire (read, write) locks for both
//       a line and a call, we enforce the order to be line first, call
//       second to avoid potential DEADLOCK.
//

LONG
GetLineObjWithReadLock(
    IN HDRVLINE     hdLine,
    OUT PDRVLINE   *ppLine
    )
{
    LONG        lRes;
    PDRVLINE    pLine;

    lRes = GetObjWithReadLock((HANDLE)hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pLine != NULL);
    if (pLine->dwKey != LINE_KEY)
    {
        TspLog(DL_WARNING, "GetLineObjWithReadLock: obj(%p) has bad key(%x)",
               hdLine, pLine->dwKey);

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppLine = pLine;
    return lRes;
}

LONG
GetLineObjWithWriteLock(
    IN HDRVLINE     hdLine,
    OUT PDRVLINE   *ppLine
    )
{
    LONG        lRes;
    PDRVLINE    pLine;

    lRes = GetObjWithWriteLock((HANDLE)hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pLine != NULL);
    if (pLine->dwKey != LINE_KEY)
    {
        TspLog(DL_WARNING, "GetLineObjWithWriteLock: obj(%p) has bad key(%x)",
               hdLine, pLine->dwKey);

        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppLine = pLine;
    return lRes;
}

LONG
GetMSPLineObjWithReadLock(
    IN HDRVMSPLINE     hdMSPLine,
    OUT PDRVMSPLINE   *ppMSPLine
    )
{
    LONG        lRes;
    PDRVMSPLINE pMSPLine;

    lRes = GetObjWithReadLock((HANDLE)hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pMSPLine != NULL);
    if (pMSPLine->dwKey != MSP_KEY)
    {
        TspLog(DL_WARNING, "GetMSPLineObjWithReadLock: obj(%p) has bad key(%x)",
               hdMSPLine, pMSPLine->dwKey);

        ReleaseObjReadLock((HANDLE)hdMSPLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppMSPLine = pMSPLine;
    return lRes;
}

LONG
GetMSPLineObjWithWriteLock(
    IN HDRVMSPLINE     hdMSPLine,
    OUT PDRVMSPLINE   *ppMSPLine
    )
{
    LONG        lRes;
    PDRVMSPLINE pMSPLine;

    lRes = GetObjWithWriteLock((HANDLE)hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pMSPLine != NULL);
    if (pMSPLine->dwKey != MSP_KEY)
    {
        TspLog(DL_WARNING, 
               "GetMSPLineObjWithWriteLock: obj(%p) has bad key(%x)",
               hdMSPLine, pMSPLine->dwKey);

        ReleaseObjWriteLock((HANDLE)hdMSPLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppMSPLine = pMSPLine;
    return lRes;
}

LONG
GetLineHandleFromMSPLineHandle(
    IN HDRVMSPLINE     hdMSPLine,
    OUT HDRVLINE      *phdLine
    )
{
    LONG        lRes;
    PDRVMSPLINE pMSPLine;

    lRes = GetObjWithReadLock((HANDLE)hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pMSPLine != NULL);
    if (pMSPLine->dwKey != MSP_KEY)
    {
        TspLog(DL_WARNING, 
               "GetLineHandleFromMSPLineHandle: obj(%p) has bad key(%x)",
               hdMSPLine, pMSPLine->dwKey);

        ReleaseObjReadLock((HANDLE)hdMSPLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *phdLine = pMSPLine->hdLine;

    ReleaseObjReadLock((HANDLE)hdMSPLine);
    return lRes;
}

LONG
GetCallObjWithReadLock(
    IN HDRVCALL     hdCall,
    OUT PDRVCALL   *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithReadLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, "GetCallObjWithReadLock: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;
    return lRes;
}

LONG
GetCallObjWithWriteLock(
    IN HDRVCALL     hdCall,
    OUT PDRVCALL   *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithWriteLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, "GetCallObjWithWriteLock: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjWriteLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;
    return lRes;
}

LONG
GetLineHandleFromCallHandle(
    IN HDRVCALL     hdCall,
    OUT HDRVLINE   *phdLine
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithReadLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, 
               "GetLineHandleFromCallHandle: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *phdLine = pCall->hdLine;

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
GetLineAndCallObjWithReadLock(
    HTAPI_LINE ht_Line,
    HTAPI_CALL ht_Call,
    PDRVLINE  *ppLine,
    PDRVCALL  *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;
    PDRVLINE    pLine;

    lRes = GetLineObjWithReadLock((HDRVLINE)ht_Line, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    *ppLine = pLine;

    //
    // figure out whether this is an inbound call or
    // outbound call: for inbound calls, ht_Call is
    // generated by NDPROXY and bit 0 is 1;
    // for outbound calls, ht_Call is a TSP handle
    // and we make sure that bit 0 is 0
    //
    if (ht_Call & 0x1)
    {
        // inbound call: we need to walk the list
        // of inbound calls on this line and 
        // find the right one
        if ((pCall = pLine->pInboundCalls) != NULL)
        {
            while (pCall && (pCall->ht_Call != ht_Call))
            {
                pCall = pCall->pNext;
            }
        }

        if (NULL == pCall || pCall->dwKey != INBOUND_CALL_KEY)
        {
            TspLog(DL_WARNING, 
                   "GetLineAndCallObjWithReadLock: "\
                   "inbound ht_call(%p) closed already",
                   ht_Call);

            ReleaseObjReadLock((HANDLE)ht_Line);
            return LINEERR_INVALCALLHANDLE;
        }

        // call the following to increase the ref count
        lRes = AcquireObjReadLock((HANDLE)pCall->hdCall);
        if (lRes != TAPI_SUCCESS)
        {
            ReleaseObjReadLock((HANDLE)ht_Line);
            return lRes;
        }

        *ppCall = pCall;

        return TAPI_SUCCESS;
    }
    
    // ht_Call is a TSP handle and the call is OUTBOUND
    lRes = GetObjWithReadLock((HANDLE)ht_Call, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)ht_Line);
        return lRes;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, 
               "GetLineAndCallObjWithReadLock: bad call handle(%p, %x)",
               ht_Call, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)ht_Call);
        ReleaseObjReadLock((HANDLE)ht_Line);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;

    return TAPI_SUCCESS;
}

//
// allocates mem for a NDISTAPI_REQUEST plus some initialization
//
LONG
WINAPI
PrepareSyncRequest(
    ULONG               Oid,
    ULONG               ulDeviceID,
    DWORD               dwDataSize,
    PNDISTAPI_REQUEST  *ppNdisTapiRequest
    )
{
    PNDISTAPI_REQUEST   pNdisTapiRequest =
        (PNDISTAPI_REQUEST)AllocRequest(dwDataSize + sizeof(NDISTAPI_REQUEST));
    if (NULL == pNdisTapiRequest)
    {
        TspLog(DL_ERROR, 
               "PrepareSyncRequest: failed to alloc sync req for oid(%x)", 
               Oid);
        return LINEERR_NOMEM;
    }

    pNdisTapiRequest->Oid = Oid;
    pNdisTapiRequest->ulDeviceID = ulDeviceID;
    pNdisTapiRequest->ulDataSize = dwDataSize;

    EnterCriticalSection(&gRequestIDCritSec);

    // setting ulRequestId of NDIS_TAPI_xxxx
    if ((*((ULONG *)pNdisTapiRequest->Data) = ++gdwRequestID) >= 0x7fffffff)
    {
        gdwRequestID = 1;
    }

    LeaveCriticalSection(&gRequestIDCritSec);

    *ppNdisTapiRequest = pNdisTapiRequest;

    return TAPI_SUCCESS;
}

//
// allocates mem for a ASYNC_REQUEST_WRAPPER plus some initialization
//
LONG
WINAPI
PrepareAsyncRequest(
    ULONG                   Oid,
    ULONG                   ulDeviceID,
    DWORD                   dwRequestID,
    DWORD                   dwDataSize,
    PASYNC_REQUEST_WRAPPER *ppAsyncReqWrapper
    )
{
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;

    // alloc & init an async request wrapper
    pAsyncReqWrapper = (PASYNC_REQUEST_WRAPPER)
        AllocRequest(dwDataSize + sizeof(ASYNC_REQUEST_WRAPPER));
    if (NULL == pAsyncReqWrapper)
    {
        TspLog(DL_ERROR, 
               "PrepareAsyncRequest: failed to alloc async req for oid(%x)", 
               Oid);
        return LINEERR_NOMEM;
    }

    // don't need to create an event when using completion ports
    pAsyncReqWrapper->Overlapped.hEvent = (HANDLE)NULL;

    pAsyncReqWrapper->dwKey          = ASYNCREQWRAPPER_KEY;
    pAsyncReqWrapper->dwRequestID    = dwRequestID;
    pAsyncReqWrapper->pfnPostProcess = (POSTPROCESSPROC)NULL;

    // initialize the critical section, ref the request wrapper. 
    // NOTE: this crit sec will be deleted by the last deref. 
    InitializeCriticalSection(&pAsyncReqWrapper->CritSec); 
    pAsyncReqWrapper->RefCount = 1;

    // safely initialize the driver request
    pNdisTapiRequest = &(pAsyncReqWrapper->NdisTapiRequest);

    pNdisTapiRequest->Oid = Oid;
    pNdisTapiRequest->ulDeviceID = ulDeviceID;
    pNdisTapiRequest->ulDataSize = dwDataSize;

    EnterCriticalSection(&gRequestIDCritSec);

    if ((*((ULONG *)pNdisTapiRequest->Data) = ++gdwRequestID) >= 0x7fffffff)
    {
        gdwRequestID = 1;
    }

    LeaveCriticalSection(&gRequestIDCritSec);

    *ppAsyncReqWrapper = pAsyncReqWrapper;

    return TAPI_SUCCESS;
}

//
// makes a non-overlapped request to ndproxy.sys
// so it doesn't return until the req is completed
//
LONG
WINAPI
SyncDriverRequest(
    DWORD               dwIoControlCode,
    PNDISTAPI_REQUEST   pNdisTapiRequest
    )
{
    BOOL    bRes;
    DWORD   cbReturned;

    TspLog(DL_INFO, 
           "SyncDriverRequest: oid(%s), devID(%x), reqID(%x), hdCall(%x)",
           pszOidNames[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT],
           pNdisTapiRequest->ulDeviceID,
           *((ULONG *)pNdisTapiRequest->Data),
           *(((ULONG *)pNdisTapiRequest->Data) + 1));

    // mark the request as being processed by the driver
    MarkRequest(pNdisTapiRequest);

    bRes = DeviceIoControl(ghDriverSync,
                              dwIoControlCode,
                              pNdisTapiRequest,
                              (DWORD)(sizeof(NDISTAPI_REQUEST) +
                                      pNdisTapiRequest->ulDataSize),
                              pNdisTapiRequest,
                              (DWORD)(sizeof(NDISTAPI_REQUEST) +
                                      pNdisTapiRequest->ulDataSize),
                              &cbReturned,
                              0);

    // unmark the request now that the ioctl is completed
    UnmarkRequest(pNdisTapiRequest);

    if (bRes != TRUE)
    {
        TspLog(DL_ERROR, "SyncDriverRequest: IoCtl(Oid %x) failed(%d)",
               pNdisTapiRequest->Oid, GetLastError());

        return (LINEERR_OPERATIONFAILED);
    }
    else
    {
        // the errors returned by ndproxy.sys don't match the TAPI
        // LINEERR_'s, so return the translated values (but preserve
        // the original driver return val so it's possible to distinguish
        // between  NDISTAPIERR_DEVICEOFFLINE & LINEERR_OPERATIONUNAVAIL,
        // etc.)
        return (TranslateDriverResult(pNdisTapiRequest->ulReturnValue));
    }
}

//
// Routine Description:
//
// Sends a message to the MSP telling it the VC handle for a call and
// instructing it to begin streaming on that call.
//
// Arguments:
// hdLine   -   Handle to line device
// hdCall   -   Handle for call
//
// NOTES - must be called while holding the MSP mutex
//
VOID
StartMSPStream(
    HDRVLINE    hdLine,
    HDRVCALL    hdCall
    )
{
    LONG        lRes;
    DWORD       adwMSPMessage[2];
    PDRVLINE    pLine;
    PDRVCALL    pCall;
    PDRVMSPLINE pMSPLine;
    LPVARSTRING lpDeviceID;

    TspLog(DL_TRACE, "StartMSPStream: enter");

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return;
    }

    pMSPLine = pLine->pMSPLine;

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }

    //
    // allocate a VARSTRING structure with enough space for the DWORD line id.
    // @@@ shouldn't always assume that this will be the right size.
    //
    lpDeviceID = (LPVARSTRING)MALLOC(sizeof(VARSTRING) + sizeof(DWORD));
    if (NULL == lpDeviceID)
    {
        TspLog(DL_ERROR, "StartMSPStream: failed to alloc deviceID");

        ReleaseObjReadLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }
    lpDeviceID->dwTotalSize = sizeof(VARSTRING) + sizeof(DWORD);
    
    if ((lRes = TSPI_lineGetID(
                    hdLine,
                    0,  // @@@ the proxy always makes this 0, so we use 0. 
                        // Change this if the proxy changes.
                    hdCall,
                    LINECALLSELECT_CALL,
                    lpDeviceID,
                    RCA_SAP_STRING,
                    0   // @@@ we don't use this parameter, so I set it 0.
                    )) != TAPI_SUCCESS) 
    {
        TspLog(DL_ERROR, "StartMSPStream: failed to get the VC handle");

        FREE(lpDeviceID);

        ReleaseObjReadLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }

    //
    // pass the VC Handle to the MSP.
    //
    adwMSPMessage[0] = 0;   // command code for "Here's the VC Handle"
    adwMSPMessage[1] = *((DWORD *)(((PBYTE)lpDeviceID) + 
                                   lpDeviceID->dwStringOffset));

    TspLog(DL_INFO, 
           "StartMSPStream: sending VC handle(%x) to htline(%p), htcall(%p)",
           adwMSPMessage[1], pLine->htLine, pCall->htCall);

    (*gpfnLineEvent)(pLine->htLine,
                     pCall->htCall,
                     LINE_SENDMSPDATA,                          
                     (DWORD_PTR)0,
                     (DWORD_PTR)adwMSPMessage,
                     (DWORD_PTR)sizeof(DWORD) * 2);

    //
    // tell the MSP to start streaming.
    //
    adwMSPMessage[0] = 1; // command code for "Start Streaming"

    (*gpfnLineEvent)(pLine->htLine,
                     pCall->htCall,
                     LINE_SENDMSPDATA,
                     (DWORD_PTR)0,
                     (DWORD_PTR)adwMSPMessage,
                     (DWORD_PTR)sizeof(DWORD));

    pMSPLine->bStreamingStarted = TRUE;

    FREE(lpDeviceID);

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);
}


//
// Routine Description:
//
// Sends a message to the MSP telling it to stop streaming on a
// particular call.
//
// Arguments:
// hdLine   -   Handle to line device
// hdCall   -   Handle for call
//
// NOTES - must be called while holding the MSP mutex
//
VOID
StopMSPStream(
    HDRVLINE    hdLine,
    HDRVCALL    hdCall
    )
{
    LONG        lRes;
    DWORD       adwMSPMessage;
    PDRVLINE    pLine;
    PDRVCALL    pCall;
    PDRVMSPLINE pMSPLine;

    TspLog(DL_TRACE, "StopMSPStream: enter");

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return;
    }

    pMSPLine = pLine->pMSPLine;

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }

    //
    // tell the MSP to stop streaming.
    //
    adwMSPMessage = 2; // command code for "Stop Streaming"
        
    TspLog(DL_INFO, 
           "StopMSPStream: sending MSP stop cmd to htline(%p), htcall(%p)",
           pLine->htLine, pCall->htCall);

    (*gpfnLineEvent)(pLine->htLine,
                     pCall->htCall,
                     LINE_SENDMSPDATA,
                     (DWORD_PTR)0,
                     (DWORD_PTR)&adwMSPMessage,
                     (DWORD_PTR)sizeof(DWORD));

    pMSPLine->bStreamingStarted = FALSE;

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);
}

//
// make an overlapped call
//
LONG
WINAPI
AsyncDriverRequest(
    DWORD                   dwIoControlCode,
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper
    )
{
    BOOL    bRes;
    LONG    lRes;
    DWORD   dwRequestSize, cbReturned, dwLastError;

    TspLog(DL_INFO,
           "AsyncDriverRequest: oid(%s), devID(%x), ReqID(%x), "
           "reqID(%x), hdCall(%x)",
           pszOidNames[pAsyncReqWrapper->NdisTapiRequest.Oid -
                       OID_TAPI_ACCEPT],
           pAsyncReqWrapper->NdisTapiRequest.ulDeviceID,
           pAsyncReqWrapper->dwRequestID,
           *((ULONG *)pAsyncReqWrapper->NdisTapiRequest.Data),
           *(((ULONG *)pAsyncReqWrapper->NdisTapiRequest.Data) + 1));

    lRes = (LONG)pAsyncReqWrapper->dwRequestID;

    dwRequestSize = sizeof(NDISTAPI_REQUEST) +
        (pAsyncReqWrapper->NdisTapiRequest.ulDataSize - 1);

    REF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

    // mark the request as being processed by the driver
    MarkRequest(pAsyncReqWrapper);

    bRes = DeviceIoControl(
        ghDriverAsync,
        dwIoControlCode,
        &pAsyncReqWrapper->NdisTapiRequest,
        dwRequestSize,
        &pAsyncReqWrapper->NdisTapiRequest,
        dwRequestSize,
        &cbReturned,
        &pAsyncReqWrapper->Overlapped
        );

    DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

    if (bRes != TRUE) {

        dwLastError = GetLastError();

        if (dwLastError != ERROR_IO_PENDING) {

            TspLog(DL_ERROR, "AsyncDriverRequest: IoCtl(oid %x) failed(%d)",
                   pAsyncReqWrapper->NdisTapiRequest.Oid, dwLastError);

            // the ioctl failed and was not pended
            // this does not trigger the completion port
            // so we have to cleanup here.
            (*gpfnCompletionProc)(pAsyncReqWrapper->dwRequestID,
                                  LINEERR_OPERATIONFAILED);

            DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);
        }
    }

    return lRes;
}

//
// reports to TAPI events that occur on the line or on calls on the line
//
VOID
WINAPI
ProcessEvent(
    PNDIS_TAPI_EVENT    pEvent
    )
{
    LONG        lRes;
    ULONG       ulMsg = pEvent->ulMsg;
    HTAPI_LINE  ht_Line = (HTAPI_LINE)pEvent->htLine;
    HTAPI_CALL  ht_Call = (HTAPI_CALL)pEvent->htCall;

    TspLog(DL_INFO, 
           "ProcessEvent: event(%p), msg(%x), ht_line(%p), ht_call(%p), "\
           "p1(%p), p2(%p), p3(%p)",
           pEvent, ulMsg, ht_Line, ht_Call, 
           pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

    switch (ulMsg)
    {
    case LINE_ADDRESSSTATE:
    case LINE_CLOSE:
    case LINE_DEVSPECIFIC:
    case LINE_LINEDEVSTATE:
    {
        PDRVLINE    pLine;

        lRes = GetLineObjWithReadLock((HDRVLINE)ht_Line, &pLine);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        TspLog(DL_INFO, 
            "PE::fnLineEvent: msg(%x), htline(%p), p1(%p), p2(%p), p3(%p)",
            ulMsg, pLine->htLine, 
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         (HTAPICALL)NULL,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)ht_Line);

        break;
    }
    case LINE_CALLDEVSPECIFIC:
    case LINE_CALLINFO:
    {
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        TspLog(DL_INFO,
            "PE::fnLineEvent: msg(%x), htline(%p), htcall(%p), "\
            "p1(%p), p2(%p), p3(%p)",
            ulMsg, pLine->htLine, pCall->htCall, 
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        break;
    }
    case LINE_CALLSTATE:
    {
        DWORD       dwWaitStatus;
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        // we may still receive a few events
        // for calls that have been closed/dropped
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        //
        // for outbound calls there exists a race condition between
        // receiving the first call state msg(s) and receiving the
        // make call completion notification (if we pass a call state
        // msg on to tapi for a call that hasn't been completed yet
        // tapi will just discard the msg since the htCall really
        // isn't valid at that point).  So if htCall references a
        // valid outbound call which hasn't completed yet, we'll save
        // the call state params, and pass them on to tapi after we
        // get & indicate a (successful) completion notification.
        //

        if ((OUTBOUND_CALL_KEY == pCall->dwKey) &&
            (TRUE == pCall->bIncomplete))
        {
            TspLog(DL_INFO, 
                   "ProcessEvent: incomplete outbound call, saving state");

            pCall->dwPendingCallState     = (DWORD)pEvent->ulParam1;
            pCall->dwPendingCallStateMode = (DWORD)pEvent->ulParam2;
            pCall->dwPendingMediaMode     = (DWORD)pEvent->ulParam3;

            ReleaseObjReadLock((HANDLE)pCall->hdCall);
            ReleaseObjReadLock((HANDLE)hdLine);
            break;
        }

        //
        // Start or stop the MSP streaming as appropriate. The only states in
        // which this might happen are CONNECTED, DISCONNECTED, or IDLE.
        //
        if ((LINECALLSTATE_CONNECTED == pEvent->ulParam1) ||
            (LINECALLSTATE_DISCONNECTED == pEvent->ulParam1) ||
            (LINECALLSTATE_IDLE == pEvent->ulParam1)) {

            TspLog(DL_TRACE, "ProcessEvent: using MSP");

            if ((dwWaitStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE))
                == WAIT_OBJECT_0) 
            {
                TspLog(DL_TRACE, "ProcessEvent: acquired MSP Mutex");
            
                if (pLine->pMSPLine) 
                {
                    TspLog(DL_TRACE, "ProcessEvent: we have an MSP");

                    if ((LINECALLSTATE_CONNECTED == pEvent->ulParam1) &&
                        (FALSE == pLine->pMSPLine->bStreamingStarted)) 
                    {
                        DWORD   dwMessage = 3;  // Command code for 
                                                // "Are you there?"
                        (*gpfnLineEvent)(pLine->htLine,
                                         pCall->htCall,
                                         LINE_SENDMSPDATA,
                                         (DWORD_PTR)0, // Send to all MSPs
                                         (DWORD_PTR)&dwMessage,
                                         (DWORD_PTR)sizeof(DWORD));

                        TspLog(DL_TRACE, 
                               "ProcessEvent: sent 'are you there ?' "\
                               "message to MSP");
                            
                    } 
                    else if(((LINECALLSTATE_DISCONNECTED == pEvent->ulParam1) ||
                             (LINECALLSTATE_IDLE == pEvent->ulParam1)) && 
                            (pLine->pMSPLine->bStreamingStarted)) 
                    {
                        TspLog(DL_TRACE, 
                               "ProcessEvent: about to call StopMSPStream");
                        StopMSPStream(pCall->hdLine, pCall->hdCall);
                    }
                }
            
                ReleaseMutex(pLine->hMSPMutex);
                TspLog(DL_TRACE, "ProcessEvent: released MSP Mutex");
            } 
            else 
            {
                TspLog(DL_ERROR, 
                       "ProcessEvent: wait for MSP Mutex failed(%x)",
                       dwWaitStatus);
            }
        }

        if (LINECALLSTATE_OFFERING == pEvent->ulParam1)
        {
            LPLINECALLINFO lpLineCallInfo;
            //
            // We're about to indicate up an offering call. We need
            // to make sure the media mode we're indicating up is 
            // correct (we can't rely on what the proxy gave us). 
            // So, we call lineGetCallInfo, which will look up the
            // proper value in a table based on the called address.
            //
            lpLineCallInfo = (LPLINECALLINFO)MALLOC(sizeof(LINECALLINFO));

            if (lpLineCallInfo) 
            {
                lpLineCallInfo->dwTotalSize = sizeof(LINECALLINFO);

                if (TSPI_lineGetCallInfo(pCall->hdCall, lpLineCallInfo) 
                    == TAPI_SUCCESS) 
                {
                    if (lpLineCallInfo->dwNeededSize > 
                        lpLineCallInfo->dwTotalSize) 
                    {
                        DWORD   dwNeededSize = lpLineCallInfo->dwNeededSize;

                        FREE(lpLineCallInfo);
                        lpLineCallInfo = (LPLINECALLINFO)MALLOC(dwNeededSize);

                        if (lpLineCallInfo) 
                        {
                            lpLineCallInfo->dwTotalSize = dwNeededSize;

                            if (TSPI_lineGetCallInfo(pCall->hdCall, 
                                                     lpLineCallInfo) 
                                != TAPI_SUCCESS) 
                            {
                                TspLog(DL_ERROR, 
                                       "ProcessEvent: second call to "\
                                       "TSPI_lineGetCallInfo failed");
                                
                                FREE(lpLineCallInfo);
                                lpLineCallInfo = NULL;
                            }
                        } 
                        else 
                        {
                            TspLog(DL_ERROR, 
                                   "ProcessEvent: failed to allocate line "\
                                   "call info structure 2nd time");
                        }
                    }

                    if (lpLineCallInfo) {
                        pEvent->ulParam3 = lpLineCallInfo->dwMediaMode;
                        
                        TspLog(DL_TRACE, 
                               "ProcessEvent: just set media mode(%x)", 
                               pEvent->ulParam3);
                    }
                } 
                else 
                {
                    TspLog(DL_ERROR, 
                           "ProcessEvent: first call to "\
                           "TSPI_lineGetCallInfo failed");
                }
                
                if (lpLineCallInfo) 
                {
                    FREE(lpLineCallInfo);
                    lpLineCallInfo = NULL;
                }
            } 
            else 
            {
                TspLog(DL_ERROR, 
                       "ProcessEvent: couldn't allocate mem "\
                       "for line call info");
            }
        }

        TspLog(DL_INFO, 
               "PE::fnLineEvent(CALLSTATE): htline(%p), htcall(%p), "\
               "p1(%p), p2(%p), p3(%p)",
               pLine->htLine, pCall->htCall, 
               pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        //
        // As a perf tweak we want to indicate an IDLE
        // immediately following the disconnected.  The proxy
        // will never indicate a callstate_idle.
        //
        if(LINECALLSTATE_DISCONNECTED == pEvent->ulParam1)
        {
            TspLog(DL_INFO,
              "PE::fnLineEvent(CALLSTATE_IDLE): htline(%p), htcall(%p), p3(%p)",
               pLine->htLine, pCall->htCall, pEvent->ulParam3);

            (*gpfnLineEvent)(pLine->htLine,
                             pCall->htCall,
                             ulMsg,
                             (DWORD_PTR)LINECALLSTATE_IDLE,
                             (DWORD_PTR)0,
                             (DWORD_PTR)pEvent->ulParam3);
        }

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        break;
    }
    case LINE_NEWCALL:
    {
        HDRVCALL    hdCall;
        PDRVCALL    pCall;
        PDRVLINE    pLine;
        
        lRes = GetLineObjWithWriteLock((HDRVLINE)ht_Line, &pLine);

        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        // alloc & initialize a new DRVCALL object
        if (pCall = AllocCallObj(sizeof(DRVCALL)))
        {
            pCall->dwKey   = INBOUND_CALL_KEY;
            pCall->hd_Call = (HDRV_CALL)pEvent->ulParam1;
            pCall->ht_Call = (HTAPI_CALL)pEvent->ulParam2;
            pCall->hdLine   = (HDRVLINE)ht_Line;
            pCall->bIncomplete = FALSE;
        }

        //
        // if the new call object allocation failed above then we
        // want to tell the driver to drop & close the call,
        // then just break
        //

        if (NULL == pCall)
        {
            PNDISTAPI_REQUEST       pNdisTapiRequestDrop;
            PNDISTAPI_REQUEST       pNdisTapiRequestCloseCall;
            PNDIS_TAPI_DROP         pNdisTapiDrop;
            PNDIS_TAPI_CLOSE_CALL   pNdisTapiCloseCall;

            if ((lRes = PrepareSyncRequest(
                    OID_TAPI_DROP,                  // opcode
                    pLine->dwDeviceID,              // device id
                    sizeof(NDIS_TAPI_DROP),         // size of drve req data
                    &pNdisTapiRequestDrop           // ptr to ptr to request buf
                 )) != TAPI_SUCCESS)
            {
                ReleaseObjWriteLock((HANDLE)ht_Line);
                break;
            }

            pNdisTapiDrop = (PNDIS_TAPI_DROP)pNdisTapiRequestDrop->Data;

            pNdisTapiDrop->hdCall = (HDRV_CALL) pEvent->ulParam1;
            pNdisTapiDrop->ulUserUserInfoSize = 0;

            SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequestDrop);
            FreeRequest(pNdisTapiRequestDrop);

            if ((lRes = PrepareSyncRequest(
                    OID_TAPI_CLOSE_CALL,            // opcode
                    pLine->dwDeviceID,              // device id
                    sizeof(NDIS_TAPI_CLOSE_CALL),   // size of drve req data
                    &pNdisTapiRequestCloseCall      // ptr to ptr to request buf
                 )) != TAPI_SUCCESS)
            {
                ReleaseObjWriteLock((HANDLE)ht_Line);
                break;
            }

            pNdisTapiCloseCall =
                (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequestCloseCall->Data;

            pNdisTapiCloseCall->hdCall = (HDRV_CALL) pEvent->ulParam1;

            SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO,
                              pNdisTapiRequestCloseCall);

            FreeRequest(pNdisTapiRequestCloseCall);

            ReleaseObjWriteLock((HANDLE)ht_Line);
            break;
        }

        ASSERT(pCall != NULL);

        pCall->dwDeviceID = pLine->dwDeviceID;

        // make sure releasing write lock before calling OpenObjHandle()
        // to avoid deadlock on acquiring write lock for the global mapper
        ReleaseObjWriteLock((HANDLE)ht_Line);

        lRes = OpenObjHandle(pCall, FreeCallObj, (HANDLE *)&hdCall);
        if (lRes != TAPI_SUCCESS)
        {
            TspLog(DL_ERROR, 
                   "ProcessEvent: failed to map obj(%p) to handle",
                   pCall);

            FreeCallObj(pCall);
            break;
        }

        // reacquire the write lock
        lRes = AcquireObjWriteLock((HANDLE)ht_Line);
        if (lRes != TAPI_SUCCESS)
        {
            TspLog(DL_ERROR,
                   "ProcessEvent: failed to reacquire write lock for obj(%p)",
                   ht_Line);

            CloseObjHandle((HANDLE)hdCall);
            break;
        }

        // save the TSP handle
        pCall->hdCall = hdCall;

        // send the LINE_NEWCALL to TAPI, getting back the TAPI call handle
        TspLog(DL_INFO,
           "PE::fnLineEvent(NEWCALL): htline(%p), call(%p)",
           pLine->htLine, hdCall);

        (*gpfnLineEvent)(pLine->htLine,
                         (HTAPICALL)NULL,
                         LINE_NEWCALL,
                         (DWORD_PTR)hdCall,
                         (DWORD_PTR)&pCall->htCall,
                         0);

        //
        // insert the new call into the line's inbound calls list
        // regardless of the result of the LINE_NEWCALL
        // if it failed, we'll destroy the call next, and 
        // TSPI_lineCloseCall will expect the call to be
        // in the line's inbound call list
        //
        if ((pCall->pNext = pLine->pInboundCalls) != NULL)
        {
            pCall->pNext->pPrev = pCall;
        }
        pLine->pInboundCalls = pCall;

        ReleaseObjWriteLock((HANDLE)ht_Line);

        //
        // if TAPI didn't create it's own representation of this
        // cal (if pCall->htCall == NULL), then either:
        //
        //   1) the line is in the process of being closed, or
        //   2) TAPI was unable to allocate the necessary resources
        //
        // ...so we'll close the call
        //
        if (NULL == pCall->htCall)
        {
            TspLog(DL_WARNING, "ProcessEvent: TAPI failed to create "
                   "its own handle for the new call, so we close the call");
            TSPI_lineCloseCall(hdCall);
        }

        break;
    }

    case LINE_CREATE:

        TspLog(DL_INFO,
           "PE::fnLineEvent(CREATE): ghProvider(%p), p2(%p), p3(%p)",
           ghProvider, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)((HTAPILINE)NULL,
                         (HTAPICALL)NULL,
                         ulMsg,
                         (DWORD_PTR)ghProvider,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        break;

    case LINE_MONITORDIGITS:
    {
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        TspLog(DL_INFO,
            "PE::fnLineEvent(MONITORDIGITS): htline(%p), htcall(%p), "\
            "p1(%p), p2(%p), p3(%p)",
            pLine->htLine, pCall->htCall,
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        break;
    }
    default:

        TspLog(DL_ERROR, "ProcessEvent: unknown msg(%x)", ulMsg);

        break;

    } // switch
}

//
// thread proc that retrieves and processes completed requests 
// and async events
//
VOID
AsyncEventsThread(
    LPVOID  lpParams
    )
{
    OVERLAPPED  overlapped;
    DWORD       cbReturned;

    //
    // send an IOCTL to retrieve async events
    //
    overlapped.hEvent = NULL;   // don't need event when using completion ports

    gpAsyncEventsThreadInfo->pBuf->ulTotalSize = 
         gpAsyncEventsThreadInfo->dwBufSize - sizeof(NDISTAPI_EVENT_DATA);

    gpAsyncEventsThreadInfo->pBuf->ulUsedSize = 0;

    if (DeviceIoControl(
            ghDriverAsync,
            IOCTL_NDISTAPI_GET_LINE_EVENTS,
            gpAsyncEventsThreadInfo->pBuf,
            sizeof(NDISTAPI_EVENT_DATA),
            gpAsyncEventsThreadInfo->pBuf,
            gpAsyncEventsThreadInfo->dwBufSize,
            &cbReturned,
            &overlapped
            ) != TRUE)
    {
        DWORD dwLastError = GetLastError();
        if (dwLastError != ERROR_IO_PENDING)
        {
            TspLog(DL_ERROR,
                   "AsyncEventsThread: IoCtl(GetEvent) failed(%d)",
                   dwLastError);
        }
        ASSERT(ERROR_IO_PENDING == dwLastError);
    }

    // loop waiting for completed requests and retrieving async events
    while (1)
    {
        BOOL                bRes;
        LPOVERLAPPED        lpOverlapped;
        PNDIS_TAPI_EVENT    pEvent;

        // wait for a request to complete
        while (1) {
            DWORD       dwNumBytesTransferred;
            DWORD_PTR   dwCompletionKey;

            bRes = GetQueuedCompletionStatus(
                        ghCompletionPort,
                        &dwNumBytesTransferred,
                        &dwCompletionKey,
                        &lpOverlapped,
                        (DWORD)-1);              // infinite wait

            if (bRes) {
                //
                // GetQueuedCompletion returned success so if our
                // overlapped field is non-NULL then process the
                // event.  If the overlapped field is NULL try
                // to get another event.
                //
                if (lpOverlapped != NULL) {
                    break;
                }

                TspLog(DL_WARNING,
                      "AsyncEventsThread: GetQueuedCompletionStatus "\
                      "lpOverlapped == NULL!");

            } else {
                //
                // Error returned from GetQueuedCompletionStatus so
                // shutdown the thread.
                //
                TspLog(DL_ERROR, 
                      "AsyncEventsThread: GetQueuedCompletionStatus "\
                      "failed(%d)", GetLastError());

                TspLog(DL_WARNING, "AsyncEventsThread: exiting thread");

                ExitThread (0);
            }
        }

        ASSERT(lpOverlapped != NULL);

        //
        // check the returned overlapped struct to determine if
        // we have some events to process or a completed request
        //
        if (lpOverlapped == &overlapped)
        {
            DWORD   i;

            TspLog(DL_INFO, "AsyncEventsThread: got a line event");

            // handle the events
            pEvent = (PNDIS_TAPI_EVENT)gpAsyncEventsThreadInfo->pBuf->Data;

            for (i = 0;
                i < (gpAsyncEventsThreadInfo->pBuf->ulUsedSize / 
                     sizeof(NDIS_TAPI_EVENT));
                i++
                )
            {
                ProcessEvent(pEvent);
                pEvent++;
            }

            //
            // send another IOCTL to retrieve new async events
            //
            overlapped.hEvent = NULL;

            gpAsyncEventsThreadInfo->pBuf->ulTotalSize =
                 gpAsyncEventsThreadInfo->dwBufSize - 
                 sizeof(NDISTAPI_EVENT_DATA) + 1;

            gpAsyncEventsThreadInfo->pBuf->ulUsedSize = 0;

            if (DeviceIoControl(
                    ghDriverAsync,
                    IOCTL_NDISTAPI_GET_LINE_EVENTS,
                    gpAsyncEventsThreadInfo->pBuf,
                    sizeof(NDISTAPI_EVENT_DATA),
                    gpAsyncEventsThreadInfo->pBuf,
                    gpAsyncEventsThreadInfo->dwBufSize,
                    &cbReturned,
                    &overlapped
                    ) != TRUE)
            {
                DWORD dwLastError = GetLastError();
                if (dwLastError != ERROR_IO_PENDING) {
                    TspLog(DL_ERROR,
                           "AsyncEventsThread: IoCtl(GetEvent) failed(%d)",
                           dwLastError);

                    TspLog(DL_INFO, "AsyncEventsThread: exiting thread");

                    ExitThread (0);
                }
            }
        }
        else
        {
            LONG                    lRes;
            DWORD                   dwRequestID, callStateMsgParams[5];
            PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper = 
                                        (PASYNC_REQUEST_WRAPPER)lpOverlapped;

            TspLog(DL_INFO, "AsyncEventsThread: got a completed req");

            // verify that pointer is valid
            if (pAsyncReqWrapper->dwKey != ASYNCREQWRAPPER_KEY)
            {
                TspLog(DL_WARNING, "AsyncEventsThread: got a bogus req");
                continue;
            }

            dwRequestID = pAsyncReqWrapper->dwRequestID;

            // unmark the request now that the ioctl is completed
            UnmarkRequest(pAsyncReqWrapper);

            lRes = TranslateDriverResult(
                pAsyncReqWrapper->NdisTapiRequest.ulReturnValue
                );

            TspLog(DL_INFO, 
                  "AsyncEventsThread: req(%p) with reqID(%x) returned lRes(%x)",
                   pAsyncReqWrapper, dwRequestID, lRes);

            // call the post processing proc if appropriate
            callStateMsgParams[0] = 0;
            if (pAsyncReqWrapper->pfnPostProcess)
            {
                (*pAsyncReqWrapper->pfnPostProcess)(
                    pAsyncReqWrapper,
                    lRes,
                    callStateMsgParams
                    );
            }

            // call completion proc
            TspLog(DL_TRACE, 
                   "AsyncEventsThread: call compproc with ReqID(%x), lRes(%x)",
                   dwRequestID, lRes);

            // this is a bit ugly. LineGatherDigits is not actually
            // an asynchronous call though conceptually it seems as though it
            // is. The upshot of this is that we're not supposed to call the
            // completion proc for it. If there are more calls like this that
            // we have to support, we should come up with a better mechanism
            // than this "if" statement.
            if (pAsyncReqWrapper->NdisTapiRequest.Oid != 
                OID_TAPI_GATHER_DIGITS)
            {
                (*gpfnCompletionProc)(dwRequestID, lRes);
            }

            // free the async request wrapper
            DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

            // when outbounding call completes, we need to 
            // report back the saved call state
            if (callStateMsgParams[0])
            {
                TspLog(DL_INFO, 
                       "AsyncEventsThread: report back the saved call state");

                TspLog(DL_INFO, 
                       "AET::fnLineEvent(CALLSTATE): htline(%p), htcall(%p), "\
                       "p1(%p), p2(%p), p3(%p)",
                       callStateMsgParams[0], callStateMsgParams[1],
                       callStateMsgParams[2], callStateMsgParams[3],
                       callStateMsgParams[4]);

                (*gpfnLineEvent)((HTAPILINE)ULongToPtr(callStateMsgParams[0]),
                                 (HTAPICALL)ULongToPtr(callStateMsgParams[1]),
                                 LINE_CALLSTATE,
                                 (DWORD_PTR)callStateMsgParams[2],
                                 (DWORD_PTR)callStateMsgParams[3],
                                 (DWORD_PTR)callStateMsgParams[4]);
            }
        }
    } // while
}

HDRV_CALL
GetNdisTapiHandle(
    PDRVCALL pCall,
    LONG *plRes
    )
{
    HDRVCALL hdCall;
    PDRVCALL pCallLocal = pCall;
    LONG lRes;
    
    ASSERT(pCall != NULL);

    hdCall  = pCall->hdCall;

    if(plRes != NULL)
    {
        *plRes = TAPI_SUCCESS;
    }

    //
    // if the call is outbound, wait until the make call request
    // has completed so we don't send a bad NDPROXY handle down
    // to the driver
    //
    if (OUTBOUND_CALL_KEY == pCall->dwKey)
    {
        if (pCall->bIncomplete)
        {
            TspLog(DL_INFO, 
                "GetNdisTapiHandle: wait for the outbound call to complete...");

            do
            {
                ASSERT(plRes != NULL);
                
                //
                // Release lock before going to sleep, ow we
                // have a deadlock.
                //
                ReleaseObjReadLock((HANDLE) hdCall);
                Sleep(250);
                
                //
                // ReAcquire Read Lock. Break if we can't
                //
                lRes = GetCallObjWithReadLock(hdCall, &pCallLocal);
                if(lRes != TAPI_SUCCESS)
                {
                    *plRes = lRes;
                    break;
                }
            } while (pCall->bIncomplete);
        }
    }

    return pCall->hd_Call;
}

//
// TSPI_lineXXX functions
//
LONG
TSPIAPI
TSPI_lineAccept(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_ACCEPT       pNdisTapiAccept;

    TspLog(DL_TRACE, "lineAccept(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_ACCEPT,                   // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_ACCEPT) + dwSize, // size of drv request data
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiAccept =
        (PNDIS_TAPI_ACCEPT)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiAccept->hdCall = GetNdisTapiHandle(pCall, NULL);

    if ((pNdisTapiAccept->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiAccept->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_ANSWER       pNdisTapiAnswer;

    TspLog(DL_TRACE, "lineAnswer(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_ANSWER,                   // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_ANSWER) + dwSize, // size of drv request data
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiAnswer =
        (PNDIS_TAPI_ANSWER)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiAnswer->hdCall = GetNdisTapiHandle(pCall, NULL);

    if ((pNdisTapiAnswer->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiAnswer->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine;
    PNDISTAPI_REQUEST   pNdisTapiRequest;
    PNDIS_TAPI_CLOSE    pNdisTapiClose;

    TspLog(DL_TRACE, "lineClose(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithWriteLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_CLOSE,             // opcode
             pLine->dwDeviceID,          // device id
             sizeof(NDIS_TAPI_CLOSE),    // size of drve req data
             &pNdisTapiRequest           // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiClose = (PNDIS_TAPI_CLOSE)pNdisTapiRequest->Data;

    // mark line as invalid so any related events that show up
    // will be discarded.
    pLine->dwKey = INVALID_KEY;

    pNdisTapiClose->hdLine = pLine->hd_Line;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    FreeRequest(pNdisTapiRequest);

    CloseHandle(pLine->hMSPMutex);

    if (TAPI_SUCCESS == lRes)
    {
        lRes = DecommitNegotiatedTSPIVersion(pLine->dwDeviceID);
    }

    ReleaseObjWriteLock((HANDLE)hdLine);

    // release line resources
    CloseObjHandle((HANDLE)hdLine);

    return lRes;
}

LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    HDRVLINE                hdLine;
    PDRVLINE                pLine;
    PDRVCALL                pCall;
    PNDISTAPI_REQUEST       pNdisTapiRequestCloseCall;
    PNDIS_TAPI_CLOSE_CALL   pNdisTapiCloseCall;
    BOOL                    bInboundCall;
    HDRV_CALL               NdisTapiHandle;

    TspLog(DL_TRACE, "lineCloseCall(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    //
    // Initially we need to acquire the read lock for the objects.
    // We can't acquire the write lock immediately because we might 
    // have to spin-wait in the GetNdisTapiHandle call.
    //
    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    bInboundCall = (INBOUND_CALL_KEY == pCall->dwKey);

    NdisTapiHandle = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);

    //
    // Now acquire the write locks
    //
    lRes = AcquireObjWriteLock((HANDLE)hdLine);
    if (lRes != TAPI_SUCCESS) {
        return lRes;
    }

    lRes = AcquireObjWriteLock((HANDLE)hdCall);
    if (lRes != TAPI_SUCCESS) {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
            OID_TAPI_CLOSE_CALL,            // opcode
            pCall->dwDeviceID,              // device id
            sizeof(NDIS_TAPI_CLOSE_CALL),   // size of drve req data
            &pNdisTapiRequestCloseCall      // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }


    // mark the call as bad so any events get discarded
    pCall->dwKey = INVALID_KEY;

    // set up the params & call the driver
    pNdisTapiCloseCall = (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequestCloseCall->Data;
    pNdisTapiCloseCall->hdCall = NdisTapiHandle;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO,
                             pNdisTapiRequestCloseCall);
    FreeRequest(pNdisTapiRequestCloseCall);

    // if inbound call, remove it from the list
    if (bInboundCall)
    {
        if (pCall->pNext)
        {
            pCall->pNext->pPrev = pCall->pPrev;
        }
        if (pCall->pPrev)
        {
            pCall->pPrev->pNext = pCall->pNext;
        }
        else
        {
            pLine->pInboundCalls = pCall->pNext;
        }
    }

    ReleaseObjWriteLock((HANDLE)hdCall);
    ReleaseObjWriteLock((HANDLE)hdLine);

    // free the call struct now that the call is closed
    CloseObjHandle((HANDLE)hdCall);

    return lRes;
}

//
// Routine Description:
//
// Called when an instance of our MSP is closed. In this routine we
// just clean up our structures.
//
// Arguments:
// hdMSPLine    - Our MSP handle: we returned this in
//                TSPI_lineCreateMSPInstance()
//
// Return value:
// If the MSP handle is invalid, we return LINEERR_OPERATIONFAILED,
// otherwise we return NOERROR.
//
LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE   hdMSPLine
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    PDRVMSPLINE     pMSPLine;
    HDRVLINE        hdLine;
    PDRVLINE        pLine;
    DWORD           dwStatus;

    TspLog(DL_TRACE, "lineCloseMSPInstance(%d): MSPline(%p)", 
           ++dwSum, hdMSPLine);

    lRes = GetLineHandleFromMSPLineHandle(hdMSPLine, &hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetLineObjWithWriteLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetMSPLineObjWithWriteLock(hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    pMSPLine->dwKey = INVALID_KEY;

    if ((dwStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE)) 
        != WAIT_OBJECT_0) 
    {
        TspLog(DL_ERROR, "lineCloseMSPInstance: MSP mutex wait failed(%x)",
               dwStatus);

        ReleaseObjWriteLock((HANDLE)hdMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    pLine->pMSPLine = NULL;

    if (!ReleaseMutex(pLine->hMSPMutex)) 
    {
        TspLog(DL_ERROR, "lineCloseMSPInstance: MSP mutex release failed");

        ReleaseObjWriteLock((HANDLE)hdMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseObjWriteLock((HANDLE)hdMSPLine);
    ReleaseObjWriteLock((HANDLE)hdLine);

    CloseObjHandle((HANDLE)hdMSPLine);

    return lRes;
}

LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static DWORD                            dwSum = 0;
    LONG                                    lRes;
    PDRVLINE                                pLine;
    PNDISTAPI_REQUEST                       pNdisTapiRequest;
    PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION  pNdisTapiConditionalMediaDetection;

    TspLog(DL_TRACE, "lineConditionalMediaDetection(%d): line(%p), mode(%x)", 
           ++dwSum, hdLine, dwMediaModes);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_CONDITIONAL_MEDIA_DETECTION,      // opcode
             pLine->dwDeviceID,                         // device id
             sizeof(NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION) +
             (lpCallParams->dwTotalSize - sizeof(LINE_CALL_PARAMS)),
             &pNdisTapiRequest                          // ptr to ptr to 
                                                        // req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiConditionalMediaDetection =
        (PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION) pNdisTapiRequest->Data;

    pNdisTapiConditionalMediaDetection->hdLine = pLine->hd_Line;
    pNdisTapiConditionalMediaDetection->ulMediaModes = dwMediaModes;

    CopyMemory(
        &pNdisTapiConditionalMediaDetection->LineCallParams,
        lpCallParams,
        lpCallParams->dwTotalSize
        );

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

//
// Routine Description:
//
// Called when an instance of our MSP is created. In this routine we
// just set up our structures and save away the TAPI handle to this
// MSP instance.
//
// Arguments:
// hdLine   - Handle to the line on which the MSP is being created
// dwAddressID - An address on the given open line device
// htMSPLine    - The TAPI handle to the MSP call
// lphdMSPLine  - Pointer to location in which to return our handle
//                to the MSP instance.
//
// Return value:
// If things go well, NOERROR, otherwise LINEERR_NOMEM if we fail to
// allocate a DRVMSPLINE structure.
//
LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE         hdLine,
    DWORD            dwAddressID,
    HTAPIMSPLINE     htMSPLine,
    LPHDRVMSPLINE    lphdMSPLine
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    PDRVLINE        pLine;
    PDRVMSPLINE     pMSPLine;
    DWORD           dwStatus;

    TspLog(DL_TRACE, "lineCreateMSPInstance(%d): line(%p), addressID(%x)", 
           ++dwSum, hdLine, dwAddressID);

    lRes = GetLineObjWithWriteLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    // allocate and init a DRVMSPLINE struct
    if (!(pMSPLine = AllocMSPLineObj(sizeof(DRVMSPLINE))))
    {
        TspLog(DL_ERROR, 
               "lineCreateMSPInstance: failed to create MSP line obj");

        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_NOMEM;
    }
    pMSPLine->dwKey = MSP_KEY;
    pMSPLine->hdLine = hdLine;
    pMSPLine->dwAddressID = dwAddressID;
    pMSPLine->htMSPLine = htMSPLine;
    
    if ((dwStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE)) 
        != WAIT_OBJECT_0) 
    {
        TspLog(DL_ERROR, "lineCreateMSPInstance: MSP mutex wait failed(%x)",
               dwStatus);

        FreeMSPLineObj(pMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }
    
    pLine->pMSPLine = pMSPLine;

    if (!ReleaseMutex(pLine->hMSPMutex))
    {
        TspLog(DL_ERROR, "lineCreateMSPInstance: MSP mutex release failed");

        FreeMSPLineObj(pMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    // make sure release read lock before calling OpenObjHandle()
    // to avoid deadlock on acquiring write lock for the global mapper
    ReleaseObjWriteLock((HANDLE)hdLine);

    lRes = OpenObjHandle(pMSPLine, FreeMSPLineObj, (HANDLE *)lphdMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "lineCreateMSPInstance: failed to map obj(%p) to handle", 
               pMSPLine);

        FreeMSPLineObj(pMSPLine);
    }

    return lRes;
}

LONG
PASCAL
TSPI_lineDevSpecific_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    PDWORD_PTR              callStateMsgParams
    )
{
    TspLog(DL_TRACE, "lineDevSpecific_post: lRes(%x)", lRes);

    if (TAPI_SUCCESS == lRes)
    {
        PNDIS_TAPI_DEV_SPECIFIC pNdisTapiDevSpecific =
            (PNDIS_TAPI_DEV_SPECIFIC)pAsyncReqWrapper->NdisTapiRequest.Data;

        CopyMemory(
            (LPVOID) pAsyncReqWrapper->dwRequestSpecific,
            pNdisTapiDevSpecific->Params,
            pNdisTapiDevSpecific->ulParamsSize
            );
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HDRVCALL        hdCall,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVLINE                pLine;
    PDRVCALL                pCall = NULL;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DEV_SPECIFIC pNdisTapiDevSpecific;

    TspLog(DL_TRACE, 
           "lineDevSpecific(%d): reqID(%x), line(%p), addressID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdLine, dwAddressID, hdCall);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DEV_SPECIFIC,             // opcode
             pLine->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DEV_SPECIFIC) +   // size of drv request data
             (dwSize - 1),
             &pAsyncReqWrapper                  // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiDevSpecific = 
        (PNDIS_TAPI_DEV_SPECIFIC)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDevSpecific->hdLine = pLine->hd_Line;
    pNdisTapiDevSpecific->ulAddressID = dwAddressID;

    if (hdCall)
    {
        lRes = GetCallObjWithReadLock(hdCall, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            FreeRequest(pAsyncReqWrapper);
            ReleaseObjReadLock((HANDLE)hdLine);
            return lRes;
        }
        pNdisTapiDevSpecific->hdCall = GetNdisTapiHandle(pCall, &lRes);

        if(lRes != TAPI_SUCCESS)
        {
            FreeRequest(pAsyncReqWrapper);
            ReleaseObjReadLock((HANDLE)hdLine);
            return lRes;
        }
    }
    else
    {
        pNdisTapiDevSpecific->hdCall = (HDRV_CALL)NULL;
    }

    pNdisTapiDevSpecific->ulParamsSize = dwSize;
    CopyMemory(pNdisTapiDevSpecific->Params, lpParams, dwSize);

    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)lpParams;
    pAsyncReqWrapper->pfnPostProcess = TSPI_lineDevSpecific_postProcess;

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    if (pCall != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
    }
    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineDial(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    DWORD                   dwLength = lstrlenW (lpszDestAddress) + 1;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DIAL         pNdisTapiDial;

    TspLog(DL_TRACE, "lineDial(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DIAL,                     // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DIAL) + dwLength, // size of driver req buffer
             &pAsyncReqWrapper                  // ptr to ptr to req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiDial =
        (PNDIS_TAPI_DIAL)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDial->hdCall = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiDial->ulDestAddressSize = dwLength;

    WideCharToMultiByte(CP_ACP, 0, lpszDestAddress, 
                        -1, (LPSTR)pNdisTapiDial->szDestAddress,
                        dwLength, NULL, NULL);

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DROP         pNdisTapiDrop;
    HDRV_CALL               NdisTapiHandle;

    TspLog(DL_TRACE, "lineDrop(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    //
    // Initially we need to acquire the read lock for the object.
    // We can't acquire the write lock immediately because we
    // might have to spin-wait in the GetNdisTapiHandle call.
    //
    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    NdisTapiHandle = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    ReleaseObjReadLock((HANDLE)hdCall);

    //
    // Now acquire the write lock
    //
    lRes = AcquireObjWriteLock((HANDLE)hdCall);
    if (lRes) {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DROP,                     // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DROP) + dwSize,   // size of driver req buffer
             &pAsyncReqWrapper                  // ptr to ptr to req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiDrop =
        (PNDIS_TAPI_DROP)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDrop->hdCall = NdisTapiHandle;

    //
    // @@@: the following is for legacy NDISWAN ISDN miniports
    //
    // Safely mark the call as dropped so the CloseCall code
    // won't follow up with another "automatic" drop
    //
    pCall->bDropped = TRUE;

    if ((pNdisTapiDrop->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiDrop->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    ReleaseObjWriteLock((HANDLE)hdCall);

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    return lRes;
}

LONG
PASCAL
TSPI_lineGatherDigits_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    LPDWORD                 callStateMsgParams
    )
{
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    LPWSTR                      lpsDigitsBuffer;
    LONG                        lSuc;
    HDRVLINE                    hdLine;
    PDRVLINE                    pLine;
    HDRVCALL                    hdCall;
    PDRVCALL                    pCall;

    TspLog(DL_TRACE, "lineGatherDigits_post: lRes(%x)", lRes);

    hdCall = (HDRVCALL)(pAsyncReqWrapper->dwRequestSpecific);

    lSuc = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetLineObjWithReadLock(hdLine, &pLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetCallObjWithReadLock(hdCall, &pCall);
    if (lSuc != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lSuc;
    }

    if (TAPI_SUCCESS == lRes) 
    {
        pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pAsyncReqWrapper->NdisTapiRequest.Data;

        lpsDigitsBuffer = (LPWSTR)(((LPBYTE)pNdisTapiGatherDigits) +
                                   pNdisTapiGatherDigits->ulDigitsBufferOffset);

        wcscpy(pNdisTapiGatherDigits->lpsOrigDigitsBuffer, lpsDigitsBuffer);
        
        // send the LINE_GATHERDIGITS message to TAPI.
        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         LINE_GATHERDIGITS,
                         (DWORD_PTR)pNdisTapiGatherDigits->ulTerminationReason,
                         (DWORD_PTR)pNdisTapiGatherDigits->ulEndToEndID,
                         (DWORD_PTR)pNdisTapiGatherDigits->ulTickCount);
    }

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

// ++ DTMFDigitToOrdinal
//
// Turn a DTMF digit into a number between 0 and 15. The digits are assigned
// numbers in the following order: '0' - '9', 'A' - 'D', '*', '#'.
//
// Arguments:
// wcDigit  - The digit, expressed as a UNICODE character.
//
// Return value:
// A number between 0 and 15, or 16 if the digit passed in was not a valid 
// DTMF digit. 
// 
ULONG
DTMFDigitToOrdinal(
    WCHAR    wcDigit
    )
{
    if ((wcDigit >= L'0') && (wcDigit <= L'9'))
    {
        return (wcDigit - L'0');
    }
    if ((wcDigit >= L'A') && (wcDigit <= L'D'))
    {
        return (10 + (wcDigit - L'A'));
    }
    if (L'*' == wcDigit)
    {
        return 14;
    }
    if (L'#' == wcDigit)
    {
        return 15;
    }
    
    return 16;
}

LONG
TSPIAPI
TSPI_lineGatherDigits(
    HDRVCALL  hdCall,
    DWORD     dwEndToEndID,
    DWORD     dwDigitModes,
    LPWSTR    lpsDigits,
    DWORD     dwNumDigits,
    LPCWSTR   lpszTerminationDigits,
    DWORD     dwFirstDigitTimeout,
    DWORD     dwInterDigitTimeout
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwDigitsLength, dwTermDigitsLength;
    PASYNC_REQUEST_WRAPPER      pAsyncReqWrapper;
    PDRVCALL                    pCall;
    WCHAR                      *pwszTerminationDigit;
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    
    TspLog(DL_TRACE, "lineGatherDigits(%d): call(%p), EndToEndID(%x)",
           hdCall, dwEndToEndID);
    
    if (0 == dwNumDigits) 
    {
        TspLog(DL_ERROR, "lineGatherDigits: dwNumDigits is 0");
        return LINEERR_INVALPARAM;
    }

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    // calculate the length required to store the digits.
    if (lpsDigits) 
    {
        dwDigitsLength = dwNumDigits + 1;
    } 
    else 
    {
        dwDigitsLength = 0;
    }   

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_GATHER_DIGITS,
             pCall->dwDeviceID,
             dwEndToEndID,              // @@@: don't know what to pass in
             sizeof(NDIS_TAPI_GATHER_DIGITS) + (dwDigitsLength * 2),
             &pAsyncReqWrapper
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }
        
    pNdisTapiGatherDigits =
        (PNDIS_TAPI_GATHER_DIGITS) pAsyncReqWrapper->NdisTapiRequest.Data;

    // store the pointer to the pCall because we'll need it 
    // in our postprocess function.
    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)hdCall;
    
    //
    // Set up the parameters in our structure.
    //
    pNdisTapiGatherDigits->hdCall = GetNdisTapiHandle(pCall, &lRes);
    
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiGatherDigits->ulEndToEndID = dwEndToEndID;
    pNdisTapiGatherDigits->ulDigitModes = dwDigitModes;
    pNdisTapiGatherDigits->lpsOrigDigitsBuffer = lpsDigits;
    pNdisTapiGatherDigits->ulDigitsBufferOffset = 
        (lpsDigits ? sizeof(NDIS_TAPI_GATHER_DIGITS) : 0);
    pNdisTapiGatherDigits->ulNumDigitsNeeded = dwNumDigits;
    pNdisTapiGatherDigits->ulNumDigitsRead = 0;
    pNdisTapiGatherDigits->ulFirstDigitTimeout = dwFirstDigitTimeout;
    pNdisTapiGatherDigits->ulInterDigitTimeout = dwInterDigitTimeout;

    //
    // Turn the termination digits into a bit mask. There are 16 DTMF digits 
    // and I assign each one a bit in a word. If the digit is present in the 
    // termination digit string we were passed, we set the bit to 1 in the 
    // mask, otherwise it's set to zero. This makes it easier for the proxy 
    // to determine if it's read a termination digit: just turn the read digit 
    // into it's assigned bit number between 0 and 15 (I use the order '0' - 
    // '9', 'A' - 'D', '*', '#') and bitwise AND the mask with a word 
    // containing a 1 in the bit belonging to the digit. This makes it an O(1) 
    // operation. 
    //
    pNdisTapiGatherDigits->ulTerminationDigitsMask = 0;

    pwszTerminationDigit = (LPWSTR)lpszTerminationDigits;
    while (*pwszTerminationDigit != UNICODE_NULL) 
    {
        ULONG ulBitNum = DTMFDigitToOrdinal(*pwszTerminationDigit);         

        if (ulBitNum < 16) {
            pNdisTapiGatherDigits->ulTerminationDigitsMask |= (1 << ulBitNum);
        }

        pwszTerminationDigit++;
    }

    pAsyncReqWrapper->pfnPostProcess = TSPI_lineGatherDigits_postProcess;

    //
    // I'm not setting lRes to the return value from here. This is because 
    // TAPI requires this function to return zero in the success case. This 
    // is a bit of a hokey situation - will need further discussion.
    //
    AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_ADDRESS_CAPS          pCaps;
    PNDIS_TAPI_GET_ADDRESS_CAPS pNdisTapiGetAddressCaps;

    TspLog(DL_TRACE, 
           "lineGetAddressCaps(%d): deviceID(%x), addressID(%x), "\
           "TSPIV(%x), ExtV(%x)",
           ++dwSum, dwDeviceID, dwAddressID);


    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_CAPS,             // opcode
             dwDeviceID,                            // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_CAPS) +   // size of req data
             (lpAddressCaps->dwTotalSize - sizeof(LINE_ADDRESS_CAPS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetAddressCaps =
        (PNDIS_TAPI_GET_ADDRESS_CAPS)pNdisTapiRequest->Data;

    pNdisTapiGetAddressCaps->ulDeviceID = dwDeviceID;
    pNdisTapiGetAddressCaps->ulAddressID = dwAddressID;
    pNdisTapiGetAddressCaps->ulExtVersion = dwExtVersion;

    pCaps = &pNdisTapiGetAddressCaps->LineAddressCaps;
    pCaps->ulTotalSize  = lpAddressCaps->dwTotalSize;
    pCaps->ulNeededSize = pCaps->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);

    ZeroMemory(
        &pCaps->ulLineDeviceID, 
        sizeof(LINE_ADDRESS_CAPS) - 3 * sizeof(ULONG)
        );

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //

    lpAddressCaps->dwNeededSize =
        pCaps->ulNeededSize +
        (sizeof(LINEADDRESSCAPS) -         // v2.0 struct
            sizeof(LINE_ADDRESS_CAPS)) +   // v1.0 struct
        (pCaps->ulNeededSize - sizeof(LINE_ADDRESS_CAPS));


    //
    // Copy over the fixed fields that don't need changing, i.e.
    // everything from dwAddressSharing to dwCallCompletionModes
    //

    lpAddressCaps->dwLineDeviceID = dwDeviceID;

    CopyMemory(
        &lpAddressCaps->dwAddressSharing,
        &pCaps->ulAddressSharing,
        sizeof(LINE_ADDRESS_CAPS) - (12 * sizeof(DWORD))
        );

    if (lpAddressCaps->dwNeededSize > lpAddressCaps->dwTotalSize)
    {
        lpAddressCaps->dwUsedSize =
            (lpAddressCaps->dwTotalSize < sizeof(LINEADDRESSCAPS) ?
            lpAddressCaps->dwTotalSize : sizeof(LINEADDRESSCAPS));
    }
    else
    {
        lpAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS); // v2.0 struct

        //
        // Supported device classes
        //
        INSERTVARDATA(
            pCaps,
            &pCaps->ulDeviceClassesSize,
            lpAddressCaps,
            &lpAddressCaps->dwDeviceClassesSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.DeviceClasses"
            );

        INSERTVARDATA(
            pCaps,
            &pCaps->ulAddressSize,
            lpAddressCaps,
            &lpAddressCaps->dwAddressSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.Address"
            );

        INSERTVARDATA(
            pCaps,
            &pCaps->ulDevSpecificSize,
            lpAddressCaps,
            &lpAddressCaps->dwDevSpecificSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.DevSpecific"
            );

        if (pCaps->ulCompletionMsgTextSize != 0)
        {
            // @@@ convert ComplMsgText to unicode???
            INSERTVARDATA(
                pCaps,
                &pCaps->ulCompletionMsgTextSize,
                lpAddressCaps,
                &lpAddressCaps->dwCompletionMsgTextSize,
                sizeof(LINE_ADDRESS_CAPS),
                "LINE_ADDRESS_CAPS.CompletionMsgText"
                );

            lpAddressCaps->dwNumCompletionMessages =
                pCaps->ulNumCompletionMessages;
            lpAddressCaps->dwCompletionMsgTextEntrySize =
                pCaps->ulCompletionMsgTextEntrySize;
        }

        // make sure dwNeededSize == dwUsedSize
        lpAddressCaps->dwNeededSize = lpAddressCaps->dwUsedSize;
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE    hdLine,
    LPDWORD     lpdwAddressID,
    DWORD       dwAddressMode,
    LPCWSTR     lpsAddress,
    DWORD       dwSize
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVLINE                    pLine;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_GET_ADDRESS_ID   pNdisTapiGetAddressID;

    TspLog(DL_TRACE, "lineGetAddressID(%d): line(%p), addressMode(%x)", 
           ++dwSum, hdLine, dwAddressMode);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_ID,           // opcode
             pLine->dwDeviceID,                 // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_ID) + // size of req data
             dwSize / 2 - 1,
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetAddressID = (PNDIS_TAPI_GET_ADDRESS_ID)pNdisTapiRequest->Data;

    pNdisTapiGetAddressID->hdLine = pLine->hd_Line;
    pNdisTapiGetAddressID->ulAddressMode = dwAddressMode;
    pNdisTapiGetAddressID->ulAddressSize = dwSize / 2;

    WideCharToMultiByte(CP_ACP, 0, lpsAddress, dwSize,
            (LPSTR)pNdisTapiGetAddressID->szAddress, dwSize / 2, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwAddressID = pNdisTapiGetAddressID->ulAddressID;

        TspLog(DL_INFO, "lineGetAddressID: addressID(%x)", *lpdwAddressID);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PLINE_ADDRESS_STATUS            pStatus;
    PNDIS_TAPI_GET_ADDRESS_STATUS   pNdisTapiGetAddressStatus;

    TspLog(DL_TRACE, "lineGetAddressStatus(%d): line(%p), addressID(%x)", 
           ++dwSum, hdLine, dwAddressID);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_STATUS,           // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_STATUS) + // size of req data
             (lpAddressStatus->dwTotalSize - sizeof(LINE_ADDRESS_STATUS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetAddressStatus =
        (PNDIS_TAPI_GET_ADDRESS_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetAddressStatus->hdLine = pLine->hd_Line;
    pNdisTapiGetAddressStatus->ulAddressID = dwAddressID;

    pStatus = &pNdisTapiGetAddressStatus->LineAddressStatus;

    pStatus->ulTotalSize = lpAddressStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_ADDRESS_STATUS);

    ZeroMemory(&pStatus->ulNumInUse, 
               sizeof(LINE_ADDRESS_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpAddressStatus,
            &pNdisTapiGetAddressStatus->LineAddressStatus,
            pNdisTapiGetAddressStatus->LineAddressStatus.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVCALL                        pCall;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_GET_CALL_ADDRESS_ID  pNdisTapiGetCallAddressID;

    TspLog(DL_TRACE, "lineGetCallAddressID(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_ADDRESS_ID,          // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_ADDRESS_ID), // size of req data
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallAddressID =
        (PNDIS_TAPI_GET_CALL_ADDRESS_ID)pNdisTapiRequest->Data;

    pNdisTapiGetCallAddressID->hdCall = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwAddressID = pNdisTapiGetCallAddressID->ulAddressID;
        TspLog(DL_INFO, "lineGetCallAddressID: addressID(%x)", *lpdwAddressID);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_CALL_INFO             pInfo;
    PNDIS_TAPI_GET_CALL_INFO    pNdisTapiGetCallInfo;

    TspLog(DL_TRACE, "lineGetCallInfo(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_INFO,                // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_INFO) +      // size of req data
             (lpCallInfo->dwTotalSize - sizeof(LINE_CALL_INFO)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallInfo = (PNDIS_TAPI_GET_CALL_INFO)pNdisTapiRequest->Data;

    pNdisTapiGetCallInfo->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    pInfo = &pNdisTapiGetCallInfo->LineCallInfo;

    pInfo->ulTotalSize = lpCallInfo->dwTotalSize;
    pInfo->ulNeededSize = pInfo->ulUsedSize = sizeof(LINE_CALL_INFO);

    ZeroMemory(&pInfo->hLine, sizeof(LINE_CALL_INFO) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);

        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //

    lpCallInfo->dwNeededSize =
        pInfo->ulNeededSize +
        (sizeof(LINECALLINFO) -        // v2.0 struct
            sizeof(LINE_CALL_INFO)) +  // v1.0 struct
        (pInfo->ulNeededSize - sizeof(LINE_CALL_INFO));

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwLineDeviceID to dwTrunk
    //

    CopyMemory(
        &lpCallInfo->dwLineDeviceID,
        &pInfo->ulLineDeviceID,
        23 * sizeof(DWORD)
        );

    if (lpCallInfo->dwNeededSize > lpCallInfo->dwTotalSize)
    {
        lpCallInfo->dwUsedSize =
            (lpCallInfo->dwTotalSize < sizeof(LINECALLINFO) ?
            lpCallInfo->dwTotalSize : sizeof(LINECALLINFO));
    }
    else
    {
        PWSTR   pwszCalledAddress;
        DWORD   dwAlteredMediaModes;

        lpCallInfo->dwUsedSize = sizeof(LINECALLINFO); // v2.0 struct

        lpCallInfo->dwCallerIDFlags = pInfo->ulCallerIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCallerIDSize,
            lpCallInfo,
            &lpCallInfo->dwCallerIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CallerID"
            );

        lpCallInfo->dwCallerIDAddressType = pInfo->ulCallerIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCallerIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwCallerIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CallerIDName"
            );

        lpCallInfo->dwCalledIDFlags = pInfo->ulCalledIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCalledIDSize,
            lpCallInfo,
            &lpCallInfo->dwCalledIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CalledID"
            );

        lpCallInfo->dwCalledIDAddressType = pInfo->ulCalledIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCalledIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwCalledIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CalledIDName"
            );

        lpCallInfo->dwConnectedIDFlags = pInfo->ulConnectedIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulConnectedIDSize,
            lpCallInfo,
            &lpCallInfo->dwConnectedIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ConnectID"
            );

        lpCallInfo->dwConnectedIDAddressType = pInfo->ulConnectedIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulConnectedIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwConnectedIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ConnectIDName"
            );

        lpCallInfo->dwRedirectionIDFlags = pInfo->ulRedirectionIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectionIDSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectionIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectionID"
            );

        lpCallInfo->dwRedirectionIDAddressType = 
                                       pInfo->ulRedirectionIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectionIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectionIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectionIDName"
            );

        lpCallInfo->dwRedirectingIDFlags = pInfo->ulRedirectingIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectingIDSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectingIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectingID"
            );

        lpCallInfo->dwRedirectingIDAddressType = 
                                       pInfo->ulRedirectingIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectingIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectingIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectingIDName"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulDisplaySize,
            lpCallInfo,
            &lpCallInfo->dwDisplaySize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.Display"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulUserUserInfoSize,
            lpCallInfo,
            &lpCallInfo->dwUserUserInfoSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.UserUserInfo"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulHighLevelCompSize,
            lpCallInfo,
            &lpCallInfo->dwHighLevelCompSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.HighLevelComp"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulLowLevelCompSize,
            lpCallInfo,
            &lpCallInfo->dwLowLevelCompSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.LowLevelComp"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulChargingInfoSize,
            lpCallInfo,
            &lpCallInfo->dwChargingInfoSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ChargingInfo"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulTerminalModesSize,
            lpCallInfo,
            &lpCallInfo->dwTerminalModesSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.TerminalModes"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulDevSpecificSize,
            lpCallInfo,
            &lpCallInfo->dwDevSpecificSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.DevSpecific"
            );

        // make sure that dwNeededSize == dwUsedSize
        lpCallInfo->dwNeededSize = lpCallInfo->dwUsedSize;

        //
        // we now have the called address, look up the 
        // proper associated media mode in TAPI's table
        //
        if (lpCallInfo->dwCalledIDFlags & LINECALLPARTYID_UNAVAIL)
        {
            TspLog(DL_INFO, 
                   "lineGetCallInfo: dwCalledIDFlags contained "\
                   "LINECALLPARTYID_UNAVAIL");

            goto get_call_info_end;
        }
        if (lpCallInfo->dwCalledIDSize == 0)
        {
            TspLog(DL_INFO, "lineGetCallInfo: dwCalledIDSize was 0");

            goto get_call_info_end;
        }

        // we've got a called address that we need to look up.
        // we have to copy it and make it null-terminated.
        pwszCalledAddress = (PWSTR)MALLOC(lpCallInfo->dwCalledIDSize +
                                          sizeof(UNICODE_NULL));
        if (NULL == pwszCalledAddress)
        {
            TspLog(DL_ERROR, 
                   "lineGetCallInfo: failed to alloc mem for called address");

            lRes = LINEERR_NOMEM;
            goto get_call_info_end;
        }

        CopyMemory((PUCHAR)pwszCalledAddress,
                   (((PUCHAR)lpCallInfo) + lpCallInfo->dwCalledIDOffset),
                   lpCallInfo->dwCalledIDSize);

        *((PWSTR)(((PUCHAR)pwszCalledAddress) + lpCallInfo->dwCalledIDSize))
            = UNICODE_NULL;

        lRes = GetMediaModeForAddress(pwszCalledAddress,
                                      &dwAlteredMediaModes);

        FREE(pwszCalledAddress);
        pwszCalledAddress = NULL;

        if (lRes != TAPI_SUCCESS)
        {
            goto get_call_info_end;
        }

        if (dwAlteredMediaModes == LINEMEDIAMODE_UNKNOWN)
        {
            TspLog(DL_INFO, "lineGetCallInfo: got unknown media mode");

            goto get_call_info_end;
        }

        TspLog(DL_INFO, "lineGetCallInfo: got media mode(%x)", 
               dwAlteredMediaModes);

        lpCallInfo->dwMediaMode = dwAlteredMediaModes;
    }

get_call_info_end:
    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_CALL_STATUS           pStatus;
    PNDIS_TAPI_GET_CALL_STATUS  pNdisTapiGetCallStatus;

    TspLog(DL_TRACE, "lineGetCallStatus(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_STATUS,              // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_STATUS) +    // size of req data
             (lpCallStatus->dwTotalSize - sizeof(LINE_CALL_STATUS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallStatus = (PNDIS_TAPI_GET_CALL_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetCallStatus->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    pStatus = &pNdisTapiGetCallStatus->LineCallStatus;

    pStatus->ulTotalSize = lpCallStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_CALL_STATUS);
    
    ZeroMemory(&pStatus->ulCallState, 
               sizeof(LINE_CALL_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);

        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // (no embedded ascii strings to convert to unicode)
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields. (There are no embedded ascii strings to
    // convert to unicode, so no extra space needed for that.)
    //

    lpCallStatus->dwNeededSize =
        pStatus->ulNeededSize +
        (sizeof(LINECALLSTATUS) -      // v2.0 struct
            sizeof(LINE_CALL_STATUS)); // v1.0 struct

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwLineDeviceID to dwCallCompletionModes
    //

    CopyMemory(
        &lpCallStatus->dwCallState,
        &pStatus->ulCallState,
        4 * sizeof(DWORD)
        );

    if (lpCallStatus->dwNeededSize > lpCallStatus->dwTotalSize)
    {
        lpCallStatus->dwUsedSize =
            (lpCallStatus->dwTotalSize < sizeof(LINECALLSTATUS) ?
            lpCallStatus->dwTotalSize : sizeof(LINECALLSTATUS));
    }
    else
    {
        lpCallStatus->dwUsedSize = sizeof(LINECALLSTATUS);
                                                        // v2.0 struct
        INSERTVARDATA(
            pStatus,
            &pStatus->ulDevSpecificSize,
            lpCallStatus,
            &lpCallStatus->dwDevSpecificSize,
            sizeof(LINE_CALL_STATUS),
            "LINE_CALL_STATUS.DevSpecific"
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LINEDEVCAPS *
GetLineDevCaps(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    )
{
    LONG                    lRes;
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PLINE_DEV_CAPS          pCaps;
    PNDIS_TAPI_GET_DEV_CAPS pNdisTapiGetDevCaps;
    DWORD                   dwNeededSize;
    LINEDEVCAPS            *pLineDevCaps;
    DWORD                   dwTotalSize = sizeof(LINEDEVCAPS) + 0x80;

get_caps:
    pLineDevCaps = (LINEDEVCAPS *)MALLOC(dwTotalSize);
    if (NULL == pLineDevCaps)
    {
        TspLog(DL_ERROR, "GetLineDevCaps: failed to alloc mem of size(%x)",
               dwTotalSize);
        return NULL;
    }

    pLineDevCaps->dwTotalSize = dwTotalSize;

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_DEV_CAPS,             // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_DEV_CAPS) +   // size of req data
             (dwTotalSize - sizeof(LINE_DEV_CAPS)),
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return NULL;
    }

    pNdisTapiGetDevCaps = (PNDIS_TAPI_GET_DEV_CAPS)pNdisTapiRequest->Data;

    pNdisTapiGetDevCaps->ulDeviceID = dwDeviceID;
    pNdisTapiGetDevCaps->ulExtVersion = dwExtVersion;

    pCaps = &pNdisTapiGetDevCaps->LineDevCaps;

    pCaps->ulTotalSize = dwTotalSize;
    pCaps->ulNeededSize = pCaps->ulUsedSize = sizeof(LINE_DEV_CAPS);

    ZeroMemory(&pCaps->ulProviderInfoSize,
               sizeof(LINE_DEV_CAPS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return NULL;
    }

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //
    TspLog(DL_TRACE,
           "GetLineDevCaps: ulNeeded(%x), LINEDEVCAPS(%x), LINE_DEV_CAPS(%x)",
           pCaps->ulNeededSize, sizeof(LINEDEVCAPS), sizeof(LINE_DEV_CAPS));

    dwNeededSize = 
        pCaps->ulNeededSize +
        (sizeof(LINEDEVCAPS) -         // v2.0 struct
            sizeof(LINE_DEV_CAPS)) +   // v1.0 struct
        (pCaps->ulNeededSize - sizeof(LINE_DEV_CAPS));

    TspLog(DL_TRACE, "GetLineDevCaps: dwNeededSize(%x), dwTotalSize(%x)",
           dwNeededSize, dwTotalSize);

    if (dwNeededSize > dwTotalSize)
    {
        // free up the old req
        FreeRequest(pNdisTapiRequest);

        // free the old buffer
        FREE(pLineDevCaps);

        // try again with a larger buffer
        dwTotalSize = dwNeededSize;
        goto get_caps;
    }

    ASSERT(dwNeededSize <= dwTotalSize);

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwPermanentLineID to dwNumTerminals
    //
    CopyMemory(
        &pLineDevCaps->dwPermanentLineID,
        &pCaps->ulPermanentLineID,
        sizeof(LINE_DEV_CAPS) - (7 * sizeof(DWORD))
        );

    // @@@ not sure if this is the right place to do this
    pLineDevCaps->dwDevCapFlags |= LINEDEVCAPFLAGS_MSP;

    // set the local flag to indicate that
    // the line can't be used from remote machine
    pLineDevCaps->dwDevCapFlags |= LINEDEVCAPFLAGS_LOCAL;

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    pLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS); // v2.0 struct

    INSERTVARDATA(
        pCaps,
        &pCaps->ulDeviceClassesSize,
        pLineDevCaps,
        &pLineDevCaps->dwDeviceClassesSize,
        sizeof (LINE_DEV_CAPS),
        "LINE_DEV_CAPS.DeviceClasses"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulProviderInfoSize,
        pLineDevCaps,
        &pLineDevCaps->dwProviderInfoSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.ProviderInfo"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulSwitchInfoSize,
        pLineDevCaps,
        &pLineDevCaps->dwSwitchInfoSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.SwitchInfo"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulLineNameSize,
        pLineDevCaps,
        &pLineDevCaps->dwLineNameSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.LineName"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulTerminalCapsSize,
        pLineDevCaps,
        &pLineDevCaps->dwTerminalCapsSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.TerminalCaps"
        );

    // @@@ convert DevCaps.TermText to unicode???

    pLineDevCaps->dwTerminalTextEntrySize =
        pCaps->ulTerminalTextEntrySize;

    INSERTVARDATA(
        pCaps,
        &pCaps->ulTerminalTextSize,
        pLineDevCaps,
        &pLineDevCaps->dwTerminalTextSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.TerminalText"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulDevSpecificSize,
        pLineDevCaps,
        &pLineDevCaps->dwDevSpecificSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.DevSpecific"
        );

    // make sure dwNeededSize == dwUsedSize
    pLineDevCaps->dwNeededSize = pLineDevCaps->dwUsedSize;

    FreeRequest(pNdisTapiRequest);
    return pLineDevCaps;
}

LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;

    TspLog(DL_TRACE, "lineGetDevCaps(%d): deviceID(%x), TSPIV(%x), ExtV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion, dwExtVersion);

    lRes = GetDevCaps(dwDeviceID, dwTSPIVersion, dwExtVersion, lpLineDevCaps);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetDevConfig(
    DWORD       dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR     lpszDeviceClass
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwLength = lstrlenW (lpszDeviceClass) + 1;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PVAR_STRING                 pConfig;
    PNDIS_TAPI_GET_DEV_CONFIG   pNdisTapiGetDevConfig;

    TspLog(DL_TRACE, "lineGetDevConfig(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_DEV_CONFIG,           // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_DEV_CONFIG) + // size of req data
             (lpDeviceConfig->dwTotalSize - sizeof(VAR_STRING)) + dwLength,
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetDevConfig = (PNDIS_TAPI_GET_DEV_CONFIG)pNdisTapiRequest->Data;

    pNdisTapiGetDevConfig->ulDeviceID = dwDeviceID;
    pNdisTapiGetDevConfig->ulDeviceClassSize = dwLength;
    pNdisTapiGetDevConfig->ulDeviceClassOffset =
        sizeof(NDIS_TAPI_GET_DEV_CONFIG) + 
        (lpDeviceConfig->dwTotalSize - sizeof(VAR_STRING));

    pConfig = &pNdisTapiGetDevConfig->DeviceConfig;
    pConfig->ulTotalSize = lpDeviceConfig->dwTotalSize;
    pConfig->ulNeededSize = pConfig->ulUsedSize = sizeof(VAR_STRING);

    pConfig->ulStringFormat = 
    pConfig->ulStringSize = 
    pConfig->ulStringOffset = 0;
    
    // NOTE: old miniports expect strings to be ascii
    WideCharToMultiByte(CP_ACP, 0, lpszDeviceClass, -1,
        (LPSTR) (((LPBYTE) pNdisTapiGetDevConfig) +
            pNdisTapiGetDevConfig->ulDeviceClassOffset),
        dwLength, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpDeviceConfig,
            &pNdisTapiGetDevConfig->DeviceConfig,
            pNdisTapiGetDevConfig->DeviceConfig.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_GET_EXTENSION_ID pNdisTapiGetExtensionID;

    TspLog(DL_TRACE, "lineGetExtensionID(%d): deviceID(%x), TSPIV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_EXTENSION_ID,             // opcode
             dwDeviceID,                            // device id
             sizeof(NDIS_TAPI_GET_EXTENSION_ID),    // size of req data
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetExtensionID =
        (PNDIS_TAPI_GET_EXTENSION_ID)pNdisTapiRequest->Data;

    pNdisTapiGetExtensionID->ulDeviceID = dwDeviceID;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpExtensionID,
            &pNdisTapiGetExtensionID->LineExtensionID,
            sizeof(LINE_EXTENSION_ID)
            );
    }
    else
    {
        //
        // Rather than indicating a failure, we'll just zero out the
        // ext id (implying driver doesn't support extensions) and
        // return success to tapisrv so it'll complete the open ok
        //
        ZeroMemory(lpExtensionID, sizeof(LINE_EXTENSION_ID));

        lRes = TAPI_SUCCESS;
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine = NULL;
    PDRVCALL            pCall = NULL;
    PNDISTAPI_REQUEST   pNdisTapiRequest;
    DWORD               dwLength = lstrlenW(lpszDeviceClass) + 1;
    DWORD               dwDeviceID;
    PUCHAR              pchDest;
    PVAR_STRING         pID;
    PNDIS_TAPI_GET_ID   pNdisTapiGetID;

    TspLog(DL_TRACE, 
           "lineGetID(%d): line(%p), call(%p), addressID(%x), select(%x)", 
           ++dwSum, hdLine, hdCall, dwAddressID, dwSelect);

    ASSERT(LINECALLSELECT_LINE == dwSelect ||
           LINECALLSELECT_ADDRESS == dwSelect ||
           LINECALLSELECT_CALL == dwSelect);

    if (LINECALLSELECT_LINE == dwSelect ||
        LINECALLSELECT_ADDRESS == dwSelect)
    {
        lRes = GetLineObjWithReadLock(hdLine, &pLine);
        if (lRes != TAPI_SUCCESS)
        {
            return lRes;
        }
    }

    if (LINECALLSELECT_CALL == dwSelect)
    {
        lRes = GetCallObjWithReadLock(hdCall, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            return lRes;
        }
    }

    //
    // Ndptsp will field this specific call on behalf of the
    // wan miniports.  It returns the guid and media string
    // of the adapter that this line lives on
    //
    if (LINECALLSELECT_LINE == dwSelect &&
        !wcscmp(lpszDeviceClass, L"LineGuid"))
    {
        lpDeviceID->dwNeededSize =
            sizeof(VARSTRING) + sizeof(GUID) +
            sizeof(pLine->MediaType) + sizeof('\0');

        if (lpDeviceID->dwTotalSize < lpDeviceID->dwNeededSize)
        {
            if (pCall != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdCall);
            }
            if (pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdLine);
            }
            return LINEERR_STRUCTURETOOSMALL;
        }

        lpDeviceID->dwUsedSize = lpDeviceID->dwNeededSize;
        lpDeviceID->dwStringFormat = STRINGFORMAT_ASCII;
        pchDest = (PUCHAR)lpDeviceID + sizeof(*lpDeviceID);
        lpDeviceID->dwStringOffset = (DWORD)(pchDest - (PUCHAR)lpDeviceID);
        lpDeviceID->dwStringSize =
            sizeof(GUID) + sizeof(pLine->MediaType) +sizeof('\0');

        MoveMemory(
            pchDest,
            (PUCHAR)&pLine->Guid,
            sizeof(pLine->Guid)
            );

        pchDest += sizeof(pLine->Guid);

        MoveMemory(
            pchDest,
            &pLine->MediaType,
            sizeof(pLine->MediaType)
            );

        pchDest += sizeof(pLine->MediaType);
        *pchDest = '\0';

        TspLog(DL_INFO, "lineGetID: obj(%p)", hdLine);

        TspLog(
            DL_INFO,
            "Guid %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
            pLine->Guid.Data1, pLine->Guid.Data2,
            pLine->Guid.Data3, pLine->Guid.Data4[0],
            pLine->Guid.Data4[1], pLine->Guid.Data4[2],
            pLine->Guid.Data4[3], pLine->Guid.Data4[4],
            pLine->Guid.Data4[5], pLine->Guid.Data4[6],
            pLine->Guid.Data4[7]
            );

        TspLog(DL_INFO, "MediaType: %d", pLine->MediaType);

        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return TAPI_SUCCESS;
    }
    else if (LINECALLSELECT_CALL == dwSelect)
    {
        lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof(DWORD);
        if (lpDeviceID->dwTotalSize < lpDeviceID->dwNeededSize) 
        {
            if (pCall != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdCall);
            }
            if (pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdLine);
            }

            return LINEERR_STRUCTURETOOSMALL;
        }
    }
    else
    {
        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return LINEERR_OPERATIONUNAVAIL;
    }

    dwDeviceID = (LINECALLSELECT_CALL == dwSelect) ? 
                      pCall->dwDeviceID : pLine->dwDeviceID;

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ID,                   // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_ID) +         // size of req data
             (lpDeviceID->dwTotalSize - sizeof(VAR_STRING)) + 2 * dwLength + 4,
                                                // 4 for returned ID
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return lRes;
    }

    pNdisTapiGetID = (PNDIS_TAPI_GET_ID)pNdisTapiRequest->Data;

    if (LINECALLSELECT_LINE == dwSelect ||
        LINECALLSELECT_ADDRESS == dwSelect)
    {
        pNdisTapiGetID->hdLine = pLine->hd_Line;
    }

    pNdisTapiGetID->ulAddressID = dwAddressID;

    if (LINECALLSELECT_CALL == dwSelect)
    {
        pNdisTapiGetID->hdCall = GetNdisTapiHandle(pCall, &lRes);
        if(lRes != TAPI_SUCCESS)
        {
            if(pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdLine);
            }

            return lRes;
        }
    }

    pNdisTapiGetID->ulSelect = dwSelect;
    pNdisTapiGetID->ulDeviceClassSize = dwLength;
    pNdisTapiGetID->ulDeviceClassOffset = sizeof(NDIS_TAPI_GET_ID) +
        (lpDeviceID->dwTotalSize - sizeof(VAR_STRING));

    pID = &pNdisTapiGetID->DeviceID;

    pID->ulTotalSize = lpDeviceID->dwTotalSize;
    pID->ulNeededSize = pID->ulUsedSize = sizeof(VAR_STRING);
    pID->ulStringFormat = pID->ulStringSize = pID->ulStringOffset = 0;

    // we use wide strings in the proxy
    wcsncpy ((LPWSTR)(((LPBYTE)pNdisTapiGetID) + 
                      pNdisTapiGetID->ulDeviceClassOffset), 
             lpszDeviceClass, 
             dwLength);
    
    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpDeviceID,
            &pNdisTapiGetID->DeviceID,
            pNdisTapiGetID->DeviceID.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);

    if (pCall != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
    }
    if (pLine != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PLINE_DEV_STATUS                pStatus;
    PNDIS_TAPI_GET_LINE_DEV_STATUS  pNdisTapiGetLineDevStatus;

    TspLog(DL_TRACE, "lineGetLineDevStatus(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_LINE_DEV_STATUS,              // opcode
             pLine->dwDeviceID,                         // device id
             sizeof(NDIS_TAPI_GET_LINE_DEV_STATUS) +    // size of req data
             (lpLineDevStatus->dwTotalSize - sizeof(LINE_DEV_STATUS)),
             &pNdisTapiRequest                          // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetLineDevStatus =
        (PNDIS_TAPI_GET_LINE_DEV_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetLineDevStatus->hdLine = pLine->hd_Line;

    pStatus = &pNdisTapiGetLineDevStatus->LineDevStatus;

    pStatus->ulTotalSize = lpLineDevStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_DEV_STATUS);

    ZeroMemory(&pStatus->ulNumOpens,
               sizeof(LINE_DEV_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // (no embedded ascii strings to convert to unicode)
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields. (There are no embedded ascii strings to
    // convert to unicode, so no extra space needed for that.)
    //

    lpLineDevStatus->dwNeededSize =
        pStatus->ulNeededSize +
        (sizeof(LINEDEVSTATUS) -       // v2.0 struct
            sizeof(LINE_DEV_STATUS));  // v1.0 struct

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwNumActiveCalls to dwDevStatusFlags
    //

    CopyMemory(
        &lpLineDevStatus->dwNumActiveCalls,
        &pStatus->ulNumActiveCalls,
        sizeof(LINE_DEV_STATUS) - (9 * sizeof(DWORD))
        );

    if (lpLineDevStatus->dwNeededSize > lpLineDevStatus->dwTotalSize)
    {
        lpLineDevStatus->dwUsedSize =
            (lpLineDevStatus->dwTotalSize < sizeof(LINEDEVSTATUS) ?
            lpLineDevStatus->dwTotalSize : sizeof(LINEDEVSTATUS));
    }
    else
    {
        lpLineDevStatus->dwUsedSize = sizeof(LINEDEVSTATUS);
                                                        // v2.0 struct
        INSERTVARDATA(
            pStatus,
            &pStatus->ulTerminalModesSize,
            lpLineDevStatus,
            &lpLineDevStatus->dwTerminalModesSize,
            sizeof(LINE_DEV_STATUS),
            "LINE_DEV_STATUS.TerminalModes"
            );

        INSERTVARDATA(
            pStatus,
            &pStatus->ulDevSpecificSize,
            lpLineDevStatus,
            &lpLineDevStatus->dwDevSpecificSize,
            sizeof(LINE_DEV_STATUS),
            "LINE_DEV_STATUS.DevSpecific"
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    PDRVLINE        pLine;

    TspLog(DL_TRACE, "lineGetNumAddressIDs(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetNumAddressIDs(pLine->dwDeviceID, lpdwNumAddressIDs);

    if (TAPI_SUCCESS == lRes)
    {
        TspLog(DL_INFO, "lineGetNumAddressIDs: numAddressIDs(%x)",
               *lpdwNumAddressIDs);
    }

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
PASCAL
TSPI_lineMakeCall_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    PDWORD_PTR              callStateMsgParams
    )
{
    LONG        lSuc;
    HDRVLINE    hdLine;
    PDRVLINE    pLine;
    HDRVCALL    hdCall;
    PDRVCALL    pCall;

    TspLog(DL_TRACE, "lineMakeCall_post: lRes(%x)", lRes);

    hdCall = (HDRVCALL)(pAsyncReqWrapper->dwRequestSpecific);

    lSuc = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetLineObjWithReadLock(hdLine, &pLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetCallObjWithWriteLock(hdCall, &pCall);
    if (lSuc != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lSuc;
    }

    if (TAPI_SUCCESS == lRes)
    {
        PNDIS_TAPI_MAKE_CALL    pNdisTapiMakeCall = (PNDIS_TAPI_MAKE_CALL)
            pAsyncReqWrapper->NdisTapiRequest.Data;
          
        // check to see if a call state msg was received before we had
        // the chance to process the completion notification, & if so
        // fill in the msg params
        if (pCall->dwPendingCallState)
        {
            callStateMsgParams[0] = (DWORD_PTR)pLine->htLine;
            callStateMsgParams[1] = (DWORD_PTR)pCall->htCall;
            callStateMsgParams[2] = pCall->dwPendingCallState;
            callStateMsgParams[3] = pCall->dwPendingCallStateMode;
            callStateMsgParams[4] = pCall->dwPendingMediaMode;
        }
        pCall->hd_Call = pNdisTapiMakeCall->hdCall;
        pCall->bIncomplete = FALSE;

        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
    }
    else
    {
        pCall->dwKey = INVALID_KEY;

        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        CloseObjHandle((HANDLE)hdCall);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes; 
    PDRVLINE                pLine;
    PDRVCALL                pCall;
    HDRVCALL                hdCall;
    DWORD                   dwDALength, dwCPLength;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_MAKE_CALL    pNdisTapiMakeCall;

    TspLog(DL_TRACE, "lineMakeCall(%d): reqID(%x), line(%p)", 
           ++dwSum, dwRequestID, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    // alloc & init a DRVCALL
    if (!(pCall = AllocCallObj(sizeof(DRVCALL))))
    {
        TspLog(DL_ERROR, "lineMakeCall: failed to create call obj");
        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_NOMEM;
    }
    pCall->dwKey       = OUTBOUND_CALL_KEY;
    pCall->dwDeviceID  = pLine->dwDeviceID;
    pCall->htCall      = htCall;
    pCall->hdLine      = hdLine;
    pCall->bIncomplete = TRUE;

    // init the request
    dwDALength = (lpszDestAddress ? (lstrlenW (lpszDestAddress) + 1) : 0);
    dwCPLength = (lpCallParams ? 
                  (lpCallParams->dwTotalSize - sizeof(LINE_CALL_PARAMS)) : 0);

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_MAKE_CALL,            // opcode
             pLine->dwDeviceID,             // device id
             dwRequestID,                   // request id
             sizeof(NDIS_TAPI_MAKE_CALL) +
             2 * dwDALength + dwCPLength +
             sizeof(PVOID),                 // size
             &pAsyncReqWrapper              // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        FreeCallObj(pCall);
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiMakeCall = (PNDIS_TAPI_MAKE_CALL)
        pAsyncReqWrapper->NdisTapiRequest.Data;

    // make sure releasing read lock before calling OpenObjHandle()
    // to avoid deadlock on acquiring write lock for the global mapper
    ReleaseObjReadLock((HANDLE)hdLine);

    lRes = OpenObjHandle(pCall, FreeCallObj, (HANDLE *)&hdCall);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "lineMakeCall: failed to map obj(%p) to handle",
               pCall);

        FreeRequest(pAsyncReqWrapper);
        FreeCallObj(pCall);
        return lRes;
    }

    // reacquire the read lock
    lRes = AcquireObjReadLock((HANDLE)hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR,
               "lineMakeCall: failed to reacquire read lock for obj(%p)",
               hdLine);

        FreeRequest(pAsyncReqWrapper);
        CloseObjHandle((HANDLE)hdCall);
        return lRes;
    }

    // save the TSP handle
    pCall->hdCall = hdCall;

    pNdisTapiMakeCall->hdLine = pLine->hd_Line;
    pNdisTapiMakeCall->htCall = (HTAPI_CALL)hdCall;
    pNdisTapiMakeCall->ulDestAddressSize = dwDALength;

    if (lpszDestAddress)
    {
        UCHAR   *pDest;

        // end of pNdisTapiMakeCall
        pDest = (UCHAR *)(pNdisTapiMakeCall + 1);

        // add room for lpCallParams
        (ULONG_PTR)pDest += dwCPLength;

        // align
        (ULONG_PTR)pDest += sizeof(PVOID);
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        pNdisTapiMakeCall->ulDestAddressOffset =
            (ULONG)(pDest - (UCHAR*)pNdisTapiMakeCall);

        // use wide strings in NDPROXY
        wcsncpy ((LPWSTR)pDest, lpszDestAddress, dwDALength);
    }
    else
    {
        pNdisTapiMakeCall->ulDestAddressOffset = 0;
    }

    if (lpCallParams)
    {
        pNdisTapiMakeCall->bUseDefaultLineCallParams = FALSE;

        CopyMemory(
            &pNdisTapiMakeCall->LineCallParams,
            lpCallParams,
            lpCallParams->dwTotalSize
            );

        if (lpCallParams->dwOrigAddressSize != 0)
        {
            WideCharToMultiByte(
                CP_ACP,
                0,
                (LPCWSTR) (((LPBYTE) lpCallParams) +
                    lpCallParams->dwOrigAddressOffset),
                lpCallParams->dwOrigAddressSize / sizeof(WCHAR),
                (LPSTR) (((LPBYTE) &pNdisTapiMakeCall->LineCallParams) +
                    lpCallParams->dwOrigAddressOffset),
                lpCallParams->dwOrigAddressSize,
                NULL,
                NULL
                );

            pNdisTapiMakeCall->LineCallParams.ulOrigAddressSize /= 2;
        }
    }
    else
    {
        pNdisTapiMakeCall->bUseDefaultLineCallParams = TRUE;
    }

    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)hdCall;
    pAsyncReqWrapper->pfnPostProcess = TSPI_lineMakeCall_postProcess;

    *lphdCall = hdCall;

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL    hdCall,
    DWORD       dwDigitModes
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_MONITOR_DIGITS   pNdisTapiMonitorDigits;
    
    TspLog(DL_TRACE, "lineMonitorDigits(%d): call(%p), DigitModes(%x)", 
           ++dwSum, hdCall, dwDigitModes);
    
    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_MONITOR_DIGITS,           // opcode
             pCall->dwDeviceID,                 // device ID
             sizeof(NDIS_TAPI_MONITOR_DIGITS),  // size of req data
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiMonitorDigits = (PNDIS_TAPI_MONITOR_DIGITS)pNdisTapiRequest->Data;
    
    // set up the parameters in our structure.
    pNdisTapiMonitorDigits->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    
    pNdisTapiMonitorDigits->ulDigitModes = dwDigitModes;
            
    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

//
// Routine Description:
//
// Identifies the MSP to use for a particular line device. In our case,
// this is always the RCA MSP for all devices that support audio.
//
// Arguments:
// dwDeviceID - The line device whose MSP identifier is being requested
// pCLSID     - Pointer to location at which to store the MSP CLSID
//
// Return value:
// For devices that support TAPIMEDIAMODE_AUDIO, returns NOERROR, otherwise
// LINEERR_OPERATIONUNAVAIL.
//
LONG
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD   dwDeviceID,
    GUID   *pCLSID
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    LINEDEVCAPS     DevCaps;

    TspLog(DL_TRACE, "lineMSPIdentify(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    //
    // ugly, but we have to do it. We need to get the dev caps so we can see 
    // if the line supports audio. If it does, then we return the CLSID of 
    // the RCA MSP, otherwise return a null GUID 
    // (@@@ check if a null guid is the right thing to return)
    //      

    ZeroMemory(&DevCaps, sizeof(LINEDEVCAPS));

    DevCaps.dwTotalSize = sizeof(LINEDEVCAPS);
    
    if ((lRes = TSPI_lineGetDevCaps(dwDeviceID, 0, 0, &DevCaps)) 
        == TAPI_SUCCESS) {
        //
        // NOTE: LINEMEDIAMODE_AUTOMATEDVOICE == TAPIMEDIAMODE_AUDIO
        //
        if (DevCaps.dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) {
            //
            // The RCA MSP handles all lines that support AUDIO, 
            // so send this there. 
            //
            *pCLSID = CLSID_RCAMSP;
        }
    } 

    return lRes;
}

LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwTSPIVersion,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    static DWORD                        dwSum = 0;
    LONG                                lRes;
    PNDISTAPI_REQUEST                   pNdisTapiRequest;
    PNDIS_TAPI_NEGOTIATE_EXT_VERSION    pNdisTapiNegotiateExtVersion;

    TspLog(DL_TRACE, 
           "lineNegotiateExtVersion(%d): deviceID(%x), TSPIV(%x), "\
           "LowV(%x), HighV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion, dwLowVersion, dwHighVersion);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_NEGOTIATE_EXT_VERSION,            // opcode
             dwDeviceID,                                // device id
             sizeof(NDIS_TAPI_NEGOTIATE_EXT_VERSION),   // size of req data
             &pNdisTapiRequest                          // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiNegotiateExtVersion =
        (PNDIS_TAPI_NEGOTIATE_EXT_VERSION)pNdisTapiRequest->Data;
    
    pNdisTapiNegotiateExtVersion->ulDeviceID = dwDeviceID;
    pNdisTapiNegotiateExtVersion->ulLowVersion = dwLowVersion;
    pNdisTapiNegotiateExtVersion->ulHighVersion = dwHighVersion;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwExtVersion = pNdisTapiNegotiateExtVersion->ulExtVersion;

        // save version for future verification
        lRes = SetNegotiatedExtVersion(dwDeviceID, *lpdwExtVersion);
    }
    else
    {
        TspLog(DL_WARNING, "lineNegotiateExtVersion: syncRequest returned(%x)", 
               lRes);
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;

    TspLog(DL_TRACE, "lineNegotiateTSPIVersion(%d): deviceID(%x)", 
           ++dwSum, dwDeviceID);

    *lpdwTSPIVersion = 0x00030000;

    // save version for future verification
    lRes = SetNegotiatedTSPIVersion(dwDeviceID, 0x00030000);

    if (TAPI_SUCCESS == lRes)
    {
        TspLog(DL_INFO, "lineNegotiateTSPIVersion: TSPIVersion(%x)",
               *lpdwTSPIVersion);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVLINE                pLine;
    HDRVLINE                hdLine;
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PNDIS_TAPI_OPEN         pNdisTapiOpen;
    GUID                    Guid;
    NDIS_WAN_MEDIUM_SUBTYPE MediaType;
    PNDISTAPI_OPENDATA      OpenData;

    
    TspLog(DL_TRACE, "lineOpen(%d): deviceID(%x), htLine(%p)", 
           ++dwSum, dwDeviceID, htLine);

    // alloc & init a DRVLINE
    if (!(pLine = AllocLineObj(sizeof(DRVLINE))))
    {
        TspLog(DL_ERROR, "lineOpen: failed to create line obj");
        return LINEERR_NOMEM;
    }
    pLine->dwKey = LINE_KEY;
    pLine->dwDeviceID = dwDeviceID;
    pLine->htLine = htLine;

    pLine->hMSPMutex = CreateMutex(NULL, FALSE, "MSPMutex");
    if (NULL == pLine->hMSPMutex)
    {
        TspLog(DL_ERROR, "lineOpen: failed to create mutex");
        FreeLineObj(pLine);
        return LINEERR_NOMEM;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_OPEN,             // opcode
             dwDeviceID,                // device id
             sizeof(NDIS_TAPI_OPEN) + 
             sizeof(NDISTAPI_OPENDATA), // size
             &pNdisTapiRequest          // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        CloseHandle(pLine->hMSPMutex);
        FreeLineObj(pLine);
        return lRes;
    }

    pNdisTapiOpen = (PNDIS_TAPI_OPEN)pNdisTapiRequest->Data;

    pNdisTapiOpen->ulDeviceID = dwDeviceID;

    lRes = OpenObjHandle(pLine, FreeLineObj, (HANDLE *)&hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, "lineOpen: failed to map obj(%p) to handle", pLine);
        CloseHandle(pLine->hMSPMutex);
        FreeLineObj(pLine);
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    pNdisTapiOpen->htLine = (HTAPI_LINE)hdLine;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        CloseHandle(pLine->hMSPMutex);
        CloseObjHandle((HANDLE)hdLine);
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    OpenData = (PNDISTAPI_OPENDATA)
                    ((PUCHAR)pNdisTapiOpen + sizeof(NDIS_TAPI_OPEN));

    MoveMemory(&pLine->Guid,&OpenData->Guid, sizeof(pLine->Guid));
    pLine->MediaType = OpenData->MediaType;

    TspLog(DL_INFO, "lineOpen: obj(%p)", hdLine);
    TspLog(
        DL_INFO,
        "Guid: %4.4x-%4.4x-%2.2x%2.2x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
        pLine->Guid.Data1, pLine->Guid.Data2,
        pLine->Guid.Data3, pLine->Guid.Data4[0],
        pLine->Guid.Data4[1], pLine->Guid.Data4[2],
        pLine->Guid.Data4[3], pLine->Guid.Data4[4],
        pLine->Guid.Data4[5], pLine->Guid.Data4[6],
        pLine->Guid.Data4[7]
        );

    TspLog(DL_INFO, "MediaType(%ld)", pLine->MediaType);

    pLine->hd_Line = pNdisTapiOpen->hdLine;
    *lphdLine = hdLine;

    lRes = CommitNegotiatedTSPIVersion(dwDeviceID);

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

//
// Routine Description:
//
// Called when an MSP wants to send us data. Right now we have not
// defined any TSP / MSP communication, so this function does nothing.
//
// Arguments:
// hdLine   -   Handle to line device
// hdCall   -   Handle for call
// hdMSPLine -  MSP handle for the call
// pBuffer  -   Pointer to buffer containing MSP data
// dwSize   -   Size of MSP data buffer
//
// Return value:
// LINEERR_OPERATIONFAILED  - if data size is too small
// LINEERR_OPERATIONUNAVAIL - if the message contains an unrecognized command
// NOERROR                  - if everything went OK
//
LONG
TSPIAPI
TSPI_lineReceiveMSPData(
    HDRVLINE    hdLine,
    HDRVCALL    hdCall,
    HDRVMSPLINE hdMSPLine,
    LPVOID      pBuffer,
    DWORD       dwSize
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine;
    DWORD               dwMsg;
    DWORD               dwStatus;

    TspLog(DL_TRACE, "lineReceiveMSPData(%d): line(%p), call(%p), MSPline(%p)",
           ++dwSum, hdLine, hdCall, hdMSPLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if (dwSize < sizeof(DWORD))
    {
        TspLog(DL_ERROR, 
               "lineReceiveMSPData: data buf smaller than dword size");

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    dwMsg = *((DWORD *)pBuffer);

    if (dwMsg != 0)
    {
        TspLog(DL_ERROR, "lineReceiveMSPData: unrecognized msg(%x)", dwMsg);

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONUNAVAIL;
    }

    //
    // have to call StartMSPStream with the MSP mutex held
    //
    if ((dwStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE))
        != WAIT_OBJECT_0)
    {
        TspLog(DL_ERROR, "lineReceiveMSPData: MSP mutex wait failed(%x)",
               dwStatus);

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    StartMSPStream(hdLine, hdCall);

    if (!ReleaseMutex(pLine->hMSPMutex))
    {
        TspLog(DL_ERROR, "lineReceiveMSPData: MSP mutex release failed");

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSecureCall(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_SECURE_CALL  pNdisTapiSecureCall;

    TspLog(DL_TRACE, "lineSecureCall(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SECURE_CALL,          // opcode
             pCall->dwDeviceID,             // device id
             dwRequestID,                   // req id
             sizeof(NDIS_TAPI_SECURE_CALL), // size
             &pAsyncReqWrapper              // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSecureCall =
        (PNDIS_TAPI_SECURE_CALL)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSecureCall->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSelectExtVersion(
    HDRVLINE    hdLine,
    DWORD       dwExtVersion
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_SELECT_EXT_VERSION   pNdisTapiSelectExtVersion;

    TspLog(DL_TRACE, "lineSelectExtVersion(%d): line(%p), ExtV(%x)", 
           ++dwSum, hdLine, dwExtVersion);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SELECT_EXT_VERSION,           // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SELECT_EXT_VERSION),  // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSelectExtVersion =
        (PNDIS_TAPI_SELECT_EXT_VERSION)pNdisTapiRequest->Data;

    pNdisTapiSelectExtVersion->hdLine = pLine->hd_Line;
    pNdisTapiSelectExtVersion->ulExtVersion = dwExtVersion;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    
    if (TAPI_SUCCESS == lRes)
    {
        lRes = SetSelectedExtVersion(pLine->dwDeviceID, dwExtVersion);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVCALL                        pCall;
    PASYNC_REQUEST_WRAPPER          pAsyncReqWrapper;
    PNDIS_TAPI_SEND_USER_USER_INFO  pNdisTapiSendUserUserInfo;

    TspLog(DL_TRACE, "lineSendUserUserInfo(%d): reqID(%x), call(%p)",
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SEND_USER_USER_INFO,      // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_SEND_USER_USER_INFO) + dwSize,
             &pAsyncReqWrapper              // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSendUserUserInfo = (PNDIS_TAPI_SEND_USER_USER_INFO)
                                   pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSendUserUserInfo->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    if (pNdisTapiSendUserUserInfo->ulUserUserInfoSize = dwSize)
    {
        CopyMemory(
            pNdisTapiSendUserUserInfo->UserUserInfo,
            lpsUserUserInfo,
            dwSize
            );
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetAppSpecific(
    HDRVCALL    hdCall,
    DWORD       dwAppSpecific
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_APP_SPECIFIC pNdisTapiSetAppSpecific;

    TspLog(DL_TRACE, "lineSetAppSpecific(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_APP_SPECIFIC,             // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_APP_SPECIFIC),    // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetAppSpecific =
        (PNDIS_TAPI_SET_APP_SPECIFIC)pNdisTapiRequest->Data;

    pNdisTapiSetAppSpecific->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    pNdisTapiSetAppSpecific->ulAppSpecific = dwAppSpecific;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetCallParams(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PASYNC_REQUEST_WRAPPER      pAsyncReqWrapper;
    PNDIS_TAPI_SET_CALL_PARAMS  pNdisTapiSetCallParams;

    TspLog(DL_TRACE, "lineSetCallParams(%d): reqID(%x), call(%p)",
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SET_CALL_PARAMS,          // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_SET_CALL_PARAMS), // size
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetCallParams =
        (PNDIS_TAPI_SET_CALL_PARAMS)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSetCallParams->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiSetCallParams->ulBearerMode = dwBearerMode;
    pNdisTapiSetCallParams->ulMinRate = dwMinRate;
    pNdisTapiSetCallParams->ulMaxRate = dwMaxRate;

    if (lpDialParams)
    {
        pNdisTapiSetCallParams->bSetLineDialParams = TRUE;
        CopyMemory(
            &pNdisTapiSetCallParams->LineDialParams,
            lpDialParams,
            sizeof(LINE_DIAL_PARAMS)
            );
    }
    else
    {
        pNdisTapiSetCallParams->bSetLineDialParams = FALSE;
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
    static DWORD                            dwSum = 0;
    LONG                                    lRes;
    PDRVLINE                                pLine;
    PNDISTAPI_REQUEST                       pNdisTapiRequest;
    PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION  pNdisTapiSetDefaultMediaDetection;

    TspLog(DL_TRACE, "lineSetDefaultMediaDetection(%d): line(%p), mode(%x)", 
           ++dwSum, hdLine, dwMediaModes);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_DEFAULT_MEDIA_DETECTION,  // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION), // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSetDefaultMediaDetection =
        (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION) pNdisTapiRequest->Data;

    pNdisTapiSetDefaultMediaDetection->hdLine = pLine->hd_Line;
    pNdisTapiSetDefaultMediaDetection->ulMediaModes = dwMediaModes;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwLength = lstrlenW(lpszDeviceClass) + 1;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_DEV_CONFIG   pNdisTapiSetDevConfig;

    TspLog(DL_TRACE, "lineSetDevConfig(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_DEV_CONFIG,       // opcode
             dwDeviceID,                    // device id
             sizeof(NDIS_TAPI_SET_DEV_CONFIG) + dwLength + dwSize,
             &pNdisTapiRequest              // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiSetDevConfig = (PNDIS_TAPI_SET_DEV_CONFIG)pNdisTapiRequest->Data;

    pNdisTapiSetDevConfig->ulDeviceID = dwDeviceID;
    pNdisTapiSetDevConfig->ulDeviceClassSize = dwLength;
    pNdisTapiSetDevConfig->ulDeviceClassOffset =
        sizeof(NDIS_TAPI_SET_DEV_CONFIG) + dwSize - 1;
    pNdisTapiSetDevConfig->ulDeviceConfigSize = dwSize;

    CopyMemory(
        pNdisTapiSetDevConfig->DeviceConfig,
        lpDeviceConfig,
        dwSize
        );

    // NOTE: old miniports expect strings to be ascii
    WideCharToMultiByte(CP_ACP, 0, lpszDeviceClass, -1,
        (LPSTR) (((LPBYTE) pNdisTapiSetDevConfig) +
            pNdisTapiSetDevConfig->ulDeviceClassOffset),
        dwLength, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL    hdCall,
    DWORD       dwMediaMode
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_MEDIA_MODE   pNdisTapiSetMediaMode;

    TspLog(DL_TRACE, "lineSetMediaMode(%d): call(%p), mode(%x)", 
           ++dwSum, hdCall, dwMediaMode);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
            OID_TAPI_SET_MEDIA_MODE,            // opcode
            pCall->dwDeviceID,                  // device id
            sizeof(NDIS_TAPI_SET_MEDIA_MODE),   // size
            &pNdisTapiRequest                   // ptr to ptr to req buf
        )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetMediaMode = (PNDIS_TAPI_SET_MEDIA_MODE)pNdisTapiRequest->Data;

    pNdisTapiSetMediaMode->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    pNdisTapiSetMediaMode->ulMediaMode = dwMediaMode;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetStatusMessages(
    HDRVLINE    hdLine,
    DWORD       dwLineStates,
    DWORD       dwAddressStates
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_SET_STATUS_MESSAGES  pNdisTapiSetStatusMessages;

    TspLog(DL_TRACE, "lineSetStatusMessages(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_STATUS_MESSAGES,          // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_STATUS_MESSAGES), // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSetStatusMessages =
        (PNDIS_TAPI_SET_STATUS_MESSAGES)pNdisTapiRequest->Data;

    pNdisTapiSetStatusMessages->hdLine = pLine->hd_Line;
    pNdisTapiSetStatusMessages->ulLineStates = dwLineStates;
    pNdisTapiSetStatusMessages->ulAddressStates = dwAddressStates;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

//
// TAPI_providerXxx funcs
//
LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
    char    szDeviceName[] = "NDProxy";
    char    szTargetPath[] = "\\Device\\NDProxy";
    char    szCompleteDeviceName[] = "\\\\.\\NDProxy";
    DWORD   cbReturned, dwNumLines;
    DWORD   adwConnectInfo[2] = {1, 1};

    TspLog(DL_TRACE, "providerEnumDevices: permProvID(%x)",
           dwPermanentProviderID);

    gpfnLineEvent = lpfnLineCreateProc;
    ghProvider = hProvider;

    gInitResult= LINEERR_OPERATIONFAILED;

    // create symbolic link to the kernel-mode driver
    DefineDosDevice (DDD_RAW_TARGET_PATH, szDeviceName, szTargetPath);
    
    //
    // open driver handles
    //
    if ((ghDriverSync = CreateFileA(
                            szCompleteDeviceName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,       // no security attrs
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL        // no template file
                            )) == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CreateFile(%s, sync) failed(%ld)",
               szCompleteDeviceName, GetLastError());

        goto enumdevs_error0;
    }

    if ((ghDriverAsync = CreateFileA(
                             szCompleteDeviceName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,      // no security attrs
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL       // no template file
                             )) == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CreateFile(%s, async) failed(%ld)",
               szCompleteDeviceName, GetLastError());

        goto enumdevs_error1;
    }

    // create io completion port
    if ((ghCompletionPort = CreateIoCompletionPort(ghDriverAsync, NULL, 0, 0))
        == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CreateIoCompletionPort failed(%ld)",
               GetLastError());

        goto enumdevs_error2;
    }

    // connect to driver: sending a device ID base
    // and it will return the number of devices it supports
    if (!DeviceIoControl(ghDriverSync,
                         (DWORD) IOCTL_NDISTAPI_CONNECT,
                         adwConnectInfo,
                         2*sizeof(DWORD),
                         &dwNumLines,
                         sizeof(DWORD),
                         &cbReturned,
                         (LPOVERLAPPED) NULL
                         ) || (cbReturned < sizeof(DWORD)))
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CONNECT failed(%ld)", 
               GetLastError());

        goto enumdevs_error3;
    }

    // init the req id
    gdwRequestID = 1;

    // set the number of devices
    *((LPDWORD)lpdwNumLines) = dwNumLines;

    // if here, success
    gInitResult = TAPI_SUCCESS;
    goto enumdevs_return;

    // clean up resources if an error occurred
enumdevs_error3:
    CloseHandle (ghCompletionPort);

enumdevs_error2:
    CloseHandle (ghDriverAsync);

enumdevs_error1:
    CloseHandle (ghDriverSync);

enumdevs_error0:
    DefineDosDevice (DDD_REMOVE_DEFINITION, szDeviceName, NULL);

enumdevs_return:
    TspLog(DL_INFO, "providerEnumDevices:  gInitResult(%x)", gInitResult);
    return gInitResult;
}

LONG
TSPIAPI
TSPI_providerConfig(
    HWND  hwndOwner,
    DWORD dwPermanentProviderID
    )
{
    UNREFERENCED_PARAMETER(hwndOwner);              // no dialog here
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // not needed anymore

    // success
    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    LONG    lRes = LINEERR_OPERATIONFAILED;
    DWORD   cbReturned, dwThreadID;

    TspLog(DL_TRACE, "providerInit: perfProvID(%x), lineDevIDBase(%x)",
            dwPermanentProviderID, dwLineDeviceIDBase);

    gpfnCompletionProc = lpfnCompletionProc;

    // inform tapisrv that we support multiple simultaneous requests
    // (the WAN wrapper handles request serialization for miniports)
    *lpdwTSPIOptions = 0;

    // check for successful init in EnumDevs
    if (gInitResult != TAPI_SUCCESS)
    {
        goto providerInit_return;
    }

    // send the base ID to the proxy
    if (!DeviceIoControl(ghDriverSync,
                         (DWORD) IOCTL_NDISTAPI_SET_DEVICEID_BASE,
                         &dwLineDeviceIDBase,
                         sizeof(DWORD),
                         NULL,
                         0,
                         &cbReturned,
                         (LPOVERLAPPED)NULL))
    {
        TspLog(DL_ERROR, "providerInit: SET_DEVICEID_BASE failed(%ld)",
               GetLastError());

        goto providerInit_return;
    }

    //
    // init mapper and allocator
    //
    if (InitializeMapper() != TAPI_SUCCESS)
    {
        goto providerInit_return;
    }

    InitAllocator();

    //
    // alloc the resources needed by the AsyncEventThread, 
    // and then create the thread
    //
    if ((gpAsyncEventsThreadInfo = (PASYNC_EVENTS_THREAD_INFO)
            MALLOC(sizeof(ASYNC_EVENTS_THREAD_INFO))) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: failed to alloc thread info");
        goto providerInit_error4;
    }

    gpAsyncEventsThreadInfo->dwBufSize = EVENT_BUFFER_SIZE;

    if ((gpAsyncEventsThreadInfo->pBuf = (PNDISTAPI_EVENT_DATA)
            MALLOC(EVENT_BUFFER_SIZE)) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: failed to alloc event buf");
        goto providerInit_error5;
    }

    if ((gpAsyncEventsThreadInfo->hThread = CreateThread(
            (LPSECURITY_ATTRIBUTES)NULL,    // no security attrs
            0,                              // default stack size
            (LPTHREAD_START_ROUTINE)        // func addr
                AsyncEventsThread,
            (LPVOID)NULL,                   // thread param
            0,                              // create flags
            &dwThreadID                     // thread id
            )) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: CreateThread failed(%ld)",
               GetLastError());

        goto providerInit_error7;
    }

    //
    // If here success
    //
    lRes = TAPI_SUCCESS;
    goto providerInit_return;

    //
    // clean up resources if an error occured & then return
    //
providerInit_error7:

    FREE(gpAsyncEventsThreadInfo->pBuf);

providerInit_error5:

    FREE(gpAsyncEventsThreadInfo);

providerInit_error4:
    UninitAllocator();
    UninitializeMapper();

providerInit_return:

    TspLog(DL_INFO, "providerInit: lRes(%x)", lRes);
    return lRes;
}

LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    DWORD_PTR dwTempID,
    DWORD     dwDeviceID
    )
{
    DWORD                   cbReturned;
    NDISTAPI_CREATE_INFO    CreateInfo;

    CreateInfo.TempID = (DWORD)dwTempID;
    CreateInfo.DeviceID = dwDeviceID;

    TspLog(DL_TRACE, "providerCreateLineDevice: tempID(%x), deviceID(%x)",
           dwTempID, dwDeviceID);

    if (!DeviceIoControl(
            ghDriverSync,
            IOCTL_NDISTAPI_CREATE,
            &CreateInfo,
            sizeof(CreateInfo),
            &CreateInfo,
            sizeof(CreateInfo),
            &cbReturned,
            (LPOVERLAPPED)NULL
            ))
    {
        TspLog(DL_ERROR, "providerCreateLineDevice: failed(%ld) to create",
               GetLastError());
        return LINEERR_OPERATIONFAILED;
    }

    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    char                    deviceName[] = "NDPROXY";
    ASYNC_REQUEST_WRAPPER   asyncRequestWrapper;
    DWORD                   cbReturned;

    TspLog(DL_TRACE, "providerShutdown: perfProvID(%x)", dwPermanentProviderID);

    // disconnect with the driver
    if (!DeviceIoControl(ghDriverSync,
                         (DWORD) IOCTL_NDISTAPI_DISCONNECT,
                         NULL,
                         0,
                         NULL,
                         0,
                         &cbReturned,
                         (LPOVERLAPPED) NULL
                         )) 
    {
        TspLog(DL_ERROR, "providerShutdown: DISCONNECT failed(%ld)",
               GetLastError());
    }

    //
    // Close the driver & remove the symbolic link
    //
    CancelIo(ghDriverSync);
    CancelIo(ghDriverAsync);
    CloseHandle (ghDriverSync);
    CloseHandle (ghDriverAsync);
    CloseHandle (ghCompletionPort);
    DefineDosDevice (DDD_REMOVE_DEFINITION, deviceName, NULL);

    WaitForSingleObject(gpAsyncEventsThreadInfo->hThread, INFINITE);

    CloseHandle(gpAsyncEventsThreadInfo->hThread);
    FREE(gpAsyncEventsThreadInfo->pBuf);
    FREE(gpAsyncEventsThreadInfo);

    UninitAllocator();
    UninitializeMapper();

    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR pwszUIDLLName
   )
{
    // copy name of our dll as ui dll
    lstrcpyW(pwszUIDLLName, NDPTSP_UIDLL);

    // success
    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )
{
    INT_PTR         nResult;
    CONFIG_UI_CTX   Ctx;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    ZeroMemory(&Ctx, sizeof(Ctx));

    // invoke dialog box
    nResult = DialogBoxParamW(
                  ghInstance,
                  (LPWSTR)MAKEINTRESOURCE(IDD_MEDIA_MAP),
                  hwndOwner,
                  ProviderConfigDlgProc,
                  (LPARAM)&Ctx
                  );

    // status based on whether dialog executed properly
    return ((DWORD)nResult == 0) ? TAPI_SUCCESS : LINEERR_OPERATIONFAILED;
}

BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#if DBG
            {
                HKEY    hKey;
                DWORD   dwDataSize, dwDataType;
                TCHAR   szTelephonyKey[] =
                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony";
                TCHAR   szNdptspDebugLevel[] = "NdptspDebugLevel";

                RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szTelephonyKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

                dwDataSize = sizeof(DWORD);
                gdwDebugLevel = DL_WARNING;

                RegQueryValueEx(
                    hKey,
                    szNdptspDebugLevel,
                    0,
                    &dwDataType,
                    (LPBYTE)&gdwDebugLevel,
                    &dwDataSize
                    );

                RegCloseKey(hKey);
            }
#endif
            gdwTraceID = TraceRegisterA("NDPTSP");
            ASSERT(gdwTraceID != INVALID_TRACEID);

            TspLog(DL_TRACE, "DLL_PROCESS_ATTACH");

            // save the handle for the UI
            ghInstance = hDLL;

            ZeroMemory(&gpAddressMapListArray, sizeof(gpAddressMapListArray));
            gbAddressMapListLoaded = FALSE;

            //
            // Init global sync objects
            //
            InitializeCriticalSection(&gRequestIDCritSec);
            InitializeCriticalSection(&gAddressMapCritSec);

            InitLineDevList();

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            TspLog(DL_TRACE, "DLL_PROCESS_DETACH");

            UninitLineDevList();

            // free address list
            FreeAllAddressLists(gpAddressMapListArray);

            DeleteCriticalSection(&gRequestIDCritSec);
            DeleteCriticalSection(&gAddressMapCritSec);

            TraceDeregisterA(gdwTraceID);

            break;
        }
    } // switch

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\imperson.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    impersn.h

Abstract:

    Definitions for impersonation routines

Author:

    Anthony Discolo (adiscolo)  04-Aug-1995

Revision History:

--*/

#ifndef _IMPERSON_
#define _IMPERSON_

VOID
RevertImpersonation();

BOOLEAN
GetCurrentlyLoggedOnUser(
    HANDLE *phProcess
    );

BOOLEAN
SetProcessImpersonationToken(
    HANDLE hProcess
    );

VOID
ClearImpersonationToken();

#endif // _IMPERSON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\imperson.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    impersn.c

ABSTRACT
    Impersonation routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 04-Aug-1995

REVISION HISTORY

    mquinton 8/2/96 - stole this code to use in remotesp

--*/

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
//#include <npapi.h>

#include "utils.h"
#include "imperson.h"

// some constant stuff for registry
#define SHELL_REGKEY            L"\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHELL_REGVAL            L"shell"
#define DEFAULT_SHELL           L"explorer.exe"

// for remotesp dbgout
#if DBG
#define DBGOUT(arg) DbgPrt arg
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

#else
#define DBGOUT(arg)
#endif

//
// The static information we
// need to impersonate the currently
// logged-in user.
//

HANDLE              ghTokenImpersonation = NULL;

//
// Security attributes and descriptor
// necessary for creating shareable handles.
//

SECURITY_ATTRIBUTES SecurityAttributeG;
SECURITY_DESCRIPTOR SecurityDescriptorG;

PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo()

/*++

DESCRIPTION
    Return a block containing information about all processes
    currently running in the system.

ARGUMENTS
    None.

RETURN VALUE
    A pointer to the system process information or NULL if it could
    not be allocated or retrieved.

--*/

{
    NTSTATUS status;
    PUCHAR pLargeBuffer;
    ULONG ulcbLargeBuffer = 64 * 1024;

    //
    // Get the process list.
    //
    for (;;) {
        pLargeBuffer = VirtualAlloc(
                         NULL,
                         ulcbLargeBuffer, MEM_COMMIT, PAGE_READWRITE);
        if (pLargeBuffer == NULL) {
            LOG((TL_ERROR,
              "GetSystemProcessInfo: VirtualAlloc failed (status=0x%x)",
              status));
			return NULL;
        }

        status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   pLargeBuffer,
                   ulcbLargeBuffer,
                   NULL);
        if (status == STATUS_SUCCESS) break;
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(pLargeBuffer, 0, MEM_RELEASE);
            ulcbLargeBuffer += 8192;
            LOG((TL_INFO,
              "GetSystemProcesInfo: enlarging buffer to %d",
              ulcbLargeBuffer));
        }
    }

    return (PSYSTEM_PROCESS_INFORMATION)pLargeBuffer;
} // GetSystemProcessInfo



PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR lpExeName
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeName: a pointer to a Unicode string containing the
        process to be found.

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;

    //
    // Look in the process list for lpExeName.
    //

    for (;;)
    {
        if (pProcessInfo->ImageName.Buffer != NULL) {

            //DBGOUT((
            //    3,
            //    "FindProcessByName: process: %S (%d)",
            //    pProcessInfo->ImageName.Buffer,
            //    pProcessInfo->UniqueProcessId
            //    ));

            if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeName))
            {
                return pProcessInfo;
            }
        }

        //
        // Increment offset to next process information block.
        //

        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }

        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    return NULL;
} // FindProcessByName



VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    )

/*++

DESCRIPTION
    Free a buffer returned by GetSystemProcessInfo().

ARGUMENTS
    pProcessInfo: the pointer returned by GetSystemProcessInfo().

RETURN VALUE
    None.

--*/

{
    VirtualFree((PUCHAR)pProcessInfo, 0, MEM_RELEASE);
} // FreeSystemProcessInfo



BOOLEAN
SetProcessImpersonationToken(
    HANDLE hProcess
    )

{
    NTSTATUS status;
    BOOL fDuplicated = FALSE;
    HANDLE hThread, hToken;

    static lCookie = 0;


    //
    // Open the impersonation token for the
    // process we want to impersonate.
    //
    // Note: we use InterlockedExchange as an inexpensive mutex
    //

    while (InterlockedExchange (&lCookie, 1) != 0)
    {
        Sleep (50);
    }

    if (ghTokenImpersonation == NULL)
    {
        if (!OpenProcessToken(
              hProcess,
              TOKEN_ALL_ACCESS,
              &hToken))

        {
            InterlockedExchange (&lCookie, 0);

            LOG((
                TL_ERROR,
                "SetProcessImpersonationToken: OpenProcessToken " \
                    "failed, err=%d",
                GetLastError()
                ));

            return FALSE;
        }

        //
        // Duplicate the impersonation token.
        //

        fDuplicated = DuplicateToken(
                        hToken,
                        TokenImpersonation,
                        &ghTokenImpersonation);

        if (!fDuplicated)
        {
            InterlockedExchange (&lCookie, 0);

            LOG((
                TL_ERROR,
                "SetProcessImpersonationToken: NtSetInformationThread " \
                    "failed, err=%d",
                GetLastError()
                ));

            return FALSE;
        }
    }

    InterlockedExchange (&lCookie, 0);


    //
    // Set the impersonation token on the current
    // thread.  We are now running in the same
    // security context as the supplied process.
    //

    hThread = NtCurrentThread();

    status = NtSetInformationThread(
               hThread,
               ThreadImpersonationToken,
               (PVOID)&ghTokenImpersonation,
               sizeof (ghTokenImpersonation));

    if (status != STATUS_SUCCESS)
    {
        LOG((TL_ERROR,
          "SetProcessImpersonationToken: NtSetInformationThread failed (error=%d)",
          GetLastError()));
    }
    if (fDuplicated)
    {
        CloseHandle(hToken);
        CloseHandle(hThread);
    }

    return (status == STATUS_SUCCESS);

} // SetProcessImpersonationToken



VOID
ClearImpersonationToken()

{
    //
    // Clear the impersonation token on the current
    // thread.  We are now running in LocalSystem
    // security context.
    //
    if (!SetThreadToken(NULL, NULL))
    {
        LOG((TL_ERROR,
          "ClearImpersonationToken: SetThreadToken failed (error=%d)",
          GetLastError()));
    }
} // ClearImpersonationToken



BOOLEAN
GetCurrentlyLoggedOnUser(
    HANDLE *phProcess
    )
{
    BOOLEAN fSuccess = FALSE;
    HKEY hkey;
    DWORD dwType;
    DWORD dwDisp;
    WCHAR szShell[512];
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    PWCHAR psz;
    DWORD dwSize = sizeof (szShell);
    NTSTATUS status;
    HANDLE hProcess = NULL;


    //
    // Get the shell process name.  We will look for this
    // to find out who the currently logged-on user is.
    // Create a unicode string that describes this name.
    //

    wcscpy (szShell, DEFAULT_SHELL);

    if (RegCreateKeyEx(
          HKEY_LOCAL_MACHINE,
          SHELL_REGKEY,
          0,
          NULL,
          REG_OPTION_NON_VOLATILE,
          KEY_ALL_ACCESS,
          NULL,
          &hkey,
          &dwDisp) == ERROR_SUCCESS)

    {
        if (RegQueryValueEx(
              hkey,
              SHELL_REGVAL,
              NULL,
              &dwType,
              (PBYTE)&szShell,
              &dwSize) == ERROR_SUCCESS)

        {
            //
            // Remove parameters from command line.
            //
            psz = szShell;
            while (*psz != L' ' && *psz != L'\0')
                psz++;
            *psz = L'\0';
        }
        RegCloseKey(hkey);
    }
    LOG((TL_INFO,
      "ImpersonateCurrentlyLoggedInUser: shell is %S",
      &szShell));

    //
    // Get the process list.
    //

    pSystemInfo = GetSystemProcessInfo();


    //
    // See if szShell is running.
    //

    pProcessInfo = pSystemInfo ? 
        FindProcessByName(pSystemInfo, (LPTSTR)&szShell) : NULL;

    if (pProcessInfo != NULL)
    {
        HANDLE hToken;

        //
        // Open the process.
        //
        hProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            (DWORD) ((ULONG_PTR) pProcessInfo->UniqueProcessId)
            );

        if (hProcess == NULL)
        {
            LOG((TL_ERROR,
              "ImpersonateCurrentlyLoggedInUser: OpenProcess(x%x) failed (dwErr=%d)",
              pProcessInfo->UniqueProcessId,
              GetLastError()));
        }
        fSuccess = (hProcess != NULL);
    }

    //
    // Free resources.
    //

    if (pSystemInfo)
    {
        FreeSystemProcessInfo(pSystemInfo);
    }

    //
    // Return process handle.
    //

    *phProcess = hProcess;

    return fSuccess;

} // GetCurrentlyLoggedOnUser



VOID
RevertImpersonation()

/*++

DESCRIPTION
    Close all open handles associated with the
    logged-in user who has just logged out.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    CloseHandle (ghTokenImpersonation);
    ghTokenImpersonation = NULL;

} // RevertImpersonation

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\dslookup.h ===
#ifndef _DSLOOKUP_H
#define _DSLOOKUP_H

#include <ipexport.h>
#include <Winsock2.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DBG
LPVOID
RSPAlloc(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    );
#else
LPVOID
RSPAlloc(
    DWORD   dwSize
    );
#endif

void
DrvFree(
    LPVOID  p
    );

#if DBG

#define DrvAlloc(x)    RSPAlloc(x, __LINE__, __FILE__)

#else

#define DrvAlloc(x)    RSPAlloc(x)

#endif

#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

#else
#define DBGOUT(arg)
#endif

BOOL OpenServerLookup(HKEY hRegistry);
BOOL GetNextServer(LPSTR pszServerName, DWORD dwSize, BOOL * pbFromReg);
BOOL CloseLookup(void);

typedef int (WSAAPI * PFNWSASTARTUP)(
    WORD                    wVersionRequested,
    LPWSADATA               lpWSAData
    );
typedef int (WSAAPI * PFNWSACLEANUP)(
    VOID
    );
typedef HOSTENT FAR * (WSAAPI * PFNGETHOSTBYNAME)(
    const char FAR *name
    );


typedef HANDLE (WINAPI * PFNICMPCREATEFILE)(
    VOID
    );
typedef BOOL (WINAPI * PFNICMPCLOSEHANDLE)(
    HANDLE                  IcmpHandle
    );
typedef BOOL (WINAPI * PFNICMPSENDECHO)(
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    );

typedef struct rspsocket_tag
{
    HMODULE             hWS2;
    HMODULE             hICMP;
    HANDLE              IcmpHandle;

    PFNWSASTARTUP       pFnWSAStartup;
    PFNWSACLEANUP       pFnWSACleanup;
    PFNGETHOSTBYNAME    pFngethostbyname;
    PFNICMPCREATEFILE   pFnIcmpCreateFile;
    PFNICMPCLOSEHANDLE  pFnIcmpCloseHandle;
    PFNICMPSENDECHO     pFnIcmpSendEcho;
} RSPSOCKET, * PRSPSOCKET;

HRESULT SockStartup (
    RSPSOCKET       * pSocket
    );

HRESULT SockIsServerResponding(
    RSPSOCKET       * pSocket,
    char *          szServer
    );

HRESULT SockShutdown (
    RSPSOCKET       * pSocket
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\makefile.inc ===
$(O)\rmotsprpc.c: ..\..\idl\$(O)\rmotsp_s.c
    -copy /v $? $@

$(O)\tapsrvrpc.c: ..\..\idl\$(O)\tapsrv_c.c
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\tapiui\general.h ===
#define FLAG_AUTOLAUNCH               0x00000001
#define FLAG_AUTOLOCATIONID           0x00000002
#define FLAG_PROMPTAUTOLOCATIONID     0x00000004
#define FLAG_ANNOUNCEAUTOLOCATIONID   0x00000008
#define FLAG_UPDATEONSTARTUP          0x00000010

BOOL
CALLBACK
GeneralDlgProc(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );


#define MAX_CONFIGPROFILES 4

#define IDC_STATIC                      -1


#define IDD_GENERAL                     114



//WARNING GENERAL.C _ASSUMES_ that the defines for the profile comboboxes are
//sequential
#define IDCS_DL_PROFILETEXT              5017
#define IDCB_DL_PROFILE1                 5018
#define IDCB_DL_PROFILE2                 5019
#define IDCB_DL_PROFILE3                 5020
#define IDCB_DL_PROFILE4                 5021

//WARNING GENERAL.C _ASSUMES_ that the defines for the profile texts are
//sequential
#define IDCS_DL_PROFILE1                 5024
#define IDCS_DL_PROFILE2                 5025
#define IDCS_DL_PROFILE3                 5026
#define IDCS_DL_PROFILE4                 5027


#define IDCK_DL_LAUNCHTAPITNA               6012
#define IDCK_DL_AUTOLOCATIONID              6013
#define IDCK_DL_PROMPTAUTOLOCATIONID        6014
#define IDCK_DL_ANNOUNCEAUTOLOCATIONID      6015
#define IDCK_DL_UPDATEONSTARTUP             6018

#define IDCS_DL_PROMPTAUTOLOCATIONID        6016
#define IDCS_DL_ANNOUNCEAUTOLOCATIONID         6017
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\resource.h ===
#define IDD_REMOTESPCONFIG              100
#define IDI_ICON1                       101
#define IDI_ICON2                       102
#define IDI_ICON3                       103
#define IDC_EDIT1                       201
#define IDC_ADD                         202
#define IDC_REMOVE                      203
#define IDC_LIST1                       204
#define IDC_SERVERNAME                  205
#define IDC_STATIC                      0xFFFFFFFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\remotesp.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    remotesp.c

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    09-Aug-1995

Revision History:


Notes:

    In a nutshell, this service provider connects to tapisrv.exe on remote
    pc's via the same rpc interface used by tapi32, and sends the remote
    tapisrv's the same kinds of requests (as defined in \dev\server\line.h
    & phone.h).

    This service provider also acts as an rpc server, receiving async event
    notifications from the remote tapisrv's.  Remote tapisrv's call our
    RemoteSPAttach() function at init time (during our call to their
    ClientAttach() proc) to establish a binding instance, and then can call
    RemoteSPEventProc() to send async events. Since we don't want to block
    the servers for any length of time, we immediately queue the events they
    send us, and a dedicated thread (EventHandlerThread) services this
    queue.

    Now a brief note on handle resolution.  When we open a line or a phone,
    we alloc our own DRVXXX structure to represent this widget, and pass
    tapisrv a pointer to this widget in the open request (see the
    hRemoteLine field in LINEOPEN_PARAMS in line.h).  Then, when remote
    tapisrv's send us events on those lines/phones, they pass us the
    widget pointer we passed them (instead of the normal hLine/hPhone).
    This allows us to easily find and reference our data structure
    associated with this widget.  Dealing with calls is a little more
    problematic, since remote tapisrv's can present incoming calls, and
    there is no clean way to initially specify our own handle to the call
    as with lines or phones.  (A RemoteSPNewCall() function which would
    allow for this handle swapping was considered, but not implemented due
    to possible blocking problems on the remote server.)  The solution
    is to maintain a list of calls in each line structure, and when call
    events are parsed we resolve the hCall by walking the list of calls in
    the corresponding line (tapisrv is nice enough to indicate our line
    pointer in dwParam4 of the relevant messages).  Since we expect client
    machines using remotesp to have a relatively low call bandwidth, this
    look up method should be pretty fast.

--*/
#include <tchar.h>
#include "remotesp.h"
#include "imperson.h"
#include "rmotsp.h"
#include "dslookup.h"
#include "tapihndl.h"
#include "shlwapi.h"
#include "utils.h"

//  defined in server\private.h
#define TAPIERR_INVALRPCCONTEXT     0xF101

#if DBG

BOOL    gfBreakOnSeriousProblems = FALSE;

#define DrvAlloc(x)    RSPAlloc(x, __LINE__, __FILE__)

#else

#define DrvAlloc(x)    RSPAlloc(x)

#endif


#define MODULE_NAME "remotesp.tsp"


typedef struct _ASYNCEVENTMSGRSP
{
    DWORD                   TotalSize;
    DWORD                   InitContext;
    ULONG_PTR               fnPostProcessProcHandle;
    DWORD                   hDevice;

    DWORD                   Msg;
    DWORD                   OpenContext;

    union {

        ULONG_PTR       Param1;
    };

    union {

        ULONG_PTR       Param2;
    };

    union {

        ULONG_PTR       Param3;
    };

    union {

        ULONG_PTR       Param4;
    };

} ASYNCEVENTMSGRSP, *PASYNCEVENTMSGRSP;


HANDLE     ghRSPHeap, ghHandleTable;
LIST_ENTRY gTlsListHead;

#undef DWORD_CAST
#if DBG


#define DWORD_CAST(v,f,l) (((v)>MAXDWORD)?(DbgPrt(0,"DWORD_CAST: information will be lost during cast from %p in file %s, line %d",(v),(f),(l)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))
#define DWORD_CAST_HINT(v,f,l,h) (((v)>MAXDWORD)?(DbgPrt(0,"DWORD_CAST: information will be lost during cast from %p in file %s, line %d, hint %d",(v),(f),(l),(h)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))

#else

#define DWORD_CAST(v,f,l)           ((DWORD)(v))
#define DWORD_CAST_HINT(v,f,l,h)    ((DWORD)(v))
#endif


VOID
CALLBACK
FreeContextCallback(
    LPVOID      Context,
    LPVOID      Context2
    )
{
    if (Context2 == (LPVOID) 1)
    {
        //
        // Special case: don't free the Context
        //
    }
    else if (Context != (LPVOID) -1)
    {
        //
        // The general case, Context is the pointer to free
        //

        DrvFree (Context);
    }
}


BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        gpStaleInitContexts = NULL;
        gdwNumStaleInitContexts = 0;

#if DBG

    {
        HKEY    hTelephonyKey;
        DWORD   dwDataSize, dwDataType;
        TCHAR   szRemotespDebugLevel[] = "RemotespDebugLevel";


        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszTelephonyKey,
            0,
            KEY_ALL_ACCESS,
            &hTelephonyKey
            );

        dwDataSize = sizeof (DWORD);
        gdwDebugLevel=0;

        RegQueryValueEx(
            hTelephonyKey,
            szRemotespDebugLevel,
            0,
            &dwDataType,
            (LPBYTE) &gdwDebugLevel,
            &dwDataSize
            );

        RegCloseKey (hTelephonyKey);
    }

#endif

        //
        //
        //

        LOG((TL_INFO, "DLL_PROCESS_ATTACH"));

        ghInst = hDLL;


        //
        // Allocate a private heap (use process heap if that fails)
        //

        if (!(ghRSPHeap = HeapCreate(
                0,      // return NULL on failure, serialize access
                0x1000, // initial heap size
                0       // max heap size (0 == growable)
                )))
        {
            ghRSPHeap = GetProcessHeap();
        }


        //
        //
        //

        if (!(ghHandleTable = CreateHandleTable(
                ghRSPHeap,
                FreeContextCallback,
                0x10000000,
                0x7fffffff
                )))
        {
            LOG((TL_ERROR, "DLL_PROCESS_ATTACH, CreateHandleTable() failed"));

            return FALSE;
        }


        //
        // Alloc a Tls index
        //

        if ((gdwTlsIndex = TlsAlloc()) == 0xffffffff)
        {
            LOG((TL_ERROR, "DLL_PROCESS_ATTACH, TlsAlloc() failed"));

            return FALSE;
        }


        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);


        //
        // Init a couple of critical sections for serializing
        // access to resources
        //

        InitializeCriticalSection (&gEventBufferCriticalSection);
        InitializeCriticalSection (&gCallListCriticalSection);
        InitializeCriticalSection (&gcsTlsList);
        TapiInitializeCriticalSectionAndSpinCount (&gCriticalSection, 100);

        InitializeListHead (&gTlsListHead);


        //
        // Load the device icons
        //

        {
            HINSTANCE hUser;
            typedef HICON ( WINAPI PLOADICON(
                                               HINSTANCE hInstance,
                                               LPCTSTR   lpIconName
                                             ));
            PLOADICON *pLoadIcon;



            hUser = LoadLibrary( "USER32.DLL" );
            if ( NULL == hUser )
            {
                LOG((TL_ERROR, "Couldn't load USER32.DLL!!"));
                break;
            }

            pLoadIcon = (PLOADICON *)GetProcAddress( hUser, "LoadIconA");
            if ( NULL == pLoadIcon )
            {
                LOG((TL_ERROR, "Couldn't load LoadIconA()!!"));
                FreeLibrary( hUser );
                break;
            }

            ghLineIcon  = pLoadIcon( hDLL, MAKEINTRESOURCE(IDI_ICON3) );
            ghPhoneIcon = pLoadIcon( hDLL, MAKEINTRESOURCE(IDI_ICON2) );

            FreeLibrary( hUser );
        }

        break;
    }
    case DLL_PROCESS_DETACH:
    {
        PRSP_THREAD_INFO    pTls;


        LOG((TL_INFO, "DLL_PROCESS_DETACH"));


        //
        // Clean up any Tls (no need to enter crit sec since process detaching)
        //

        while (!IsListEmpty (&gTlsListHead))
        {
            LIST_ENTRY *pEntry = RemoveHeadList (&gTlsListHead);

            pTls = CONTAINING_RECORD (pEntry, RSP_THREAD_INFO, TlsList);

            DrvFree (pTls->pBuf);
            DrvFree (pTls);
        }

        TlsFree (gdwTlsIndex);


        //
        // Free the critical sections & icons
        //

        DeleteCriticalSection (&gEventBufferCriticalSection);
        DeleteCriticalSection (&gCallListCriticalSection);
        DeleteCriticalSection (&gcsTlsList);
        TapiDeleteCriticalSection (&gCriticalSection);

        {
            HINSTANCE hUser;
            typedef BOOL ( WINAPI PDESTROYICON(
                                               HICON hIcon
                                             ));
            PDESTROYICON *pDestroyIcon;



            hUser = LoadLibrary( "USER32.DLL" );
            if ( NULL == hUser )
            {
                LOG((TL_ERROR, "Couldn't load USER32.DLL!!d"));
                break;
            }

            pDestroyIcon = (PDESTROYICON *)GetProcAddress( hUser, "DestroyIcon");
            if ( NULL == pDestroyIcon )
            {
                LOG((TL_ERROR, "Couldn't load DestroyIcon()!!"));
                FreeLibrary( hUser );
                break;
            }

            pDestroyIcon (ghLineIcon);
            pDestroyIcon (ghPhoneIcon);


            FreeLibrary( hUser );
        }

        DeleteHandleTable (ghHandleTable);

        if (ghRSPHeap != GetProcessHeap())
        {
            HeapDestroy (ghRSPHeap);
        }

        break;
    }
    case DLL_THREAD_ATTACH:

        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);

        break;

    case DLL_THREAD_DETACH:
    {
        PRSP_THREAD_INFO    pTls;


        //
        // Clean up any Tls
        //

        if ((pTls = (PRSP_THREAD_INFO) TlsGetValue (gdwTlsIndex)))
        {
            EnterCriticalSection (&gcsTlsList);

            RemoveEntryList (&pTls->TlsList);

            LeaveCriticalSection (&gcsTlsList);

            if (pTls->pBuf)
            {
                DrvFree (pTls->pBuf);
            }

            DrvFree (pTls);
        }

        break;
    }
    } // switch

    return TRUE;
}


BOOL
PASCAL
IsValidObject(
    PVOID   pObject,
    DWORD   dwKey
    )
{
    BOOL fResult;

    try
    {
        fResult = (*((LPDWORD) pObject) == dwKey);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        fResult = FALSE;
    }

    return fResult;
}


void LogRemoteSPError(CHAR * szServer, DWORD dwErrorContext, 
                      DWORD dwErrorCode, DWORD dwErrorDet,
                      BOOL bNoKeyCreation)
{
    HKEY    hKeyServer = NULL;
    DWORD   dwDisposition;
    CHAR    szRegKeyServer[255];

    if (!szServer)
    {
        goto ExitHere;
    }
    wsprintf(szRegKeyServer, "%s\\Provider%d\\", 
            gszTelephonyKey, gdwPermanentProviderID);
    lstrcat(szRegKeyServer, szServer);
    if (bNoKeyCreation)
    {
        //  If the logging is requested from NetworkPollThread
        //  do not create ProviderN key if not exist already
        if (ERROR_SUCCESS != RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    szRegKeyServer,
                    0,
                    KEY_WRITE,
                    &hKeyServer
                    ))
        {
            goto ExitHere;
        }
    }
    else
    {
        if (ERROR_SUCCESS != RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szRegKeyServer,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKeyServer,
                    &dwDisposition))
        {
            goto ExitHere;
        }
    }
    RegSetValueExW (hKeyServer,
                    L"ErrorContext",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwErrorContext,
                    sizeof(dwErrorContext));
    RegSetValueExW (hKeyServer,
                    L"ErrorCode",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwErrorCode,
                    sizeof(dwErrorCode));
    RegSetValueExW (hKeyServer,
                    L"ErrorDetail",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwErrorDet,
                    sizeof(dwErrorCode));
    
ExitHere:
    if (hKeyServer)
    {
        RegCloseKey(hKeyServer);
    }
    return;
}

//
//  Function get called when the remotesp lost connection with the
//  remote server and the status is detected
//
LONG
OnServerDisconnected(PDRVSERVER pServer)
{
    LONG            lResult = 0;

    TapiEnterCriticalSection(&gCriticalSection);

    if ( gEventHandlerThreadParams.bExit )
    {
        goto ExitHere;
    }

    //
    //  It is possible we come here durning FinishEnumDevices
    //  in which case pServer is not in any double link list
    //
    if (pServer->ServerList.Flink == NULL || 
        pServer->ServerList.Blink == NULL)
    {
        goto ExitHere;
    }

    //
    //  Bail if not transiting from connected to disconnected state
    //  otherwise set the disconnection flag
    //
    if (pServer->dwFlags & SERVER_DISCONNECTED)
    {
        goto ExitHere;
    }
    pServer->dwFlags |= SERVER_DISCONNECTED;

    TapiLeaveCriticalSection (&gCriticalSection);

    //
    // Leave Shutdown() outside of the CS to avoid deadlock
    //
    Shutdown (pServer);
    
    TapiEnterCriticalSection(&gCriticalSection);

    if ( gEventHandlerThreadParams.bExit )
    {
        goto ExitHere;
    }

    //
    //  Put this server into the gNptListHead so that the 
    //  NetworkPollThread will try to re-establish the connection
    //
    RemoveEntryList (&pServer->ServerList);
    InsertTailList (&gNptListHead, &pServer->ServerList);

    //
    //  Start the NetworkPollThread if not started yet
    //
    if (ghNetworkPollThread == NULL)
    {
        DWORD       dwTID;
        
        ghNptShutdownEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

        if (!(ghNetworkPollThread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) NetworkPollThread,
                (LPVOID) gpszThingToPassToServer,
                0,
                &dwTID
                )))
        {
            LOG((TL_ERROR, "OnServerDisconnected: Unable to create poll thread! Argh!"));
            CloseHandle (ghNptShutdownEvent);

            while (!IsListEmpty (&gNptListHead))
            {
                LIST_ENTRY  *pEntry = RemoveHeadList (&gNptListHead);

                DrvFree(
                    CONTAINING_RECORD (pEntry, DRVSERVER, ServerList)
                    );
            }

        }
    }

ExitHere:

    TapiLeaveCriticalSection (&gCriticalSection);

    return lResult;
}

//
//  Function get called when remotesp is able to re-establis the
//  connection with the remote server after losing it
//
LONG
OnServerConnected(PDRVSERVER pServer)
{
    LONG        lResult = 0;
    
    //
    //  Clear the disconnection bit
    //
    TapiEnterCriticalSection(&gCriticalSection);
    pServer->dwFlags &= (~SERVER_DISCONNECTED);
    pServer->bShutdown = FALSE;
    TapiLeaveCriticalSection(&gCriticalSection);

    return lResult;
}

PASYNCEVENTMSG
GetEventFromQueue(
    )
{
    BOOL            bAllocFailed = FALSE;
    DWORD           dwMsgSize, dwUsedSize, dwMoveSize, dwMoveSizeReal,
                    dwMoveSizeWrapped, dwMoveSizeWrappedReal;
    PASYNCEVENTMSG  pMsg;


    //
    // Enter the critical section to serialize access to the event
    // queue, and grab an event from the queue.  Copy it to our local
    // event buf so that we can leave the critical section asap and
    // not block other threads writing to the queue.
    //

    EnterCriticalSection (&gEventBufferCriticalSection);


    //
    // If there are no events in the queue return NULL
    //

    if (gEventHandlerThreadParams.dwEventBufferUsedSize == 0)
    {

GetEventFromQueue_noEvents:

        pMsg = NULL;

        //
        // Take this opportunity to tidy up a bit.  The reasoning for doing
        // this is that we should be reducing the odds we'll have to wrap
        // at the end of the buffer, or at least, put off dealing with such
        // things until later (as the non-wrap code executes quickest)
        //

        gEventHandlerThreadParams.pDataOut =
        gEventHandlerThreadParams.pDataIn  =
            gEventHandlerThreadParams.pEventBuffer;

        ResetEvent (gEventHandlerThreadParams.hEvent);

        goto GetEventFromQueue_done;
    }


    //
    // Determine the size of this msg & the num bytes to the end of the
    // event buffer, then from these get the MoveSize & MoveSizeWrapped
    // values
    //

    dwMsgSize = (DWORD) ((PASYNCEVENTMSG)
        gEventHandlerThreadParams.pDataOut)->TotalSize;

    if ((dwMsgSize & 0x3)  ||
        (dwMsgSize > gEventHandlerThreadParams.dwEventBufferTotalSize))
    {
        //
        // Something is corrupt (the msg or our queue), so just nuke
        // everything in the queue and bail out
        //

        LOG((TL_ERROR, "GetEventFromQueue: ERROR! bad msgSize=x%x", dwMsgSize));

        gEventHandlerThreadParams.dwEventBufferUsedSize = 0;

        goto GetEventFromQueue_noEvents;
    }

    dwUsedSize = (DWORD) ((gEventHandlerThreadParams.pEventBuffer +
        gEventHandlerThreadParams.dwEventBufferTotalSize)  -
        gEventHandlerThreadParams.pDataOut);

    if (dwMsgSize <= dwUsedSize)
    {
        dwMoveSize        = dwMoveSizeReal = dwMsgSize;
        dwMoveSizeWrapped = 0;
    }
    else
    {
        dwMoveSize        = dwMoveSizeReal        = dwUsedSize;
        dwMoveSizeWrapped = dwMoveSizeWrappedReal = dwMsgSize - dwUsedSize;
    }


    //
    // See if we need to grow the msg buffer before we copy
    //

    if (dwMsgSize > gEventHandlerThreadParams.dwMsgBufferTotalSize)
    {
        if ((pMsg = DrvAlloc (dwMsgSize)))
        {
            DrvFree (gEventHandlerThreadParams.pMsgBuffer);

            gEventHandlerThreadParams.pMsgBuffer = (LPBYTE) pMsg;
            gEventHandlerThreadParams.dwMsgBufferTotalSize = dwMsgSize;
        }
        else
        {
            //
            // Couldn't alloc a bigger buf, so try to complete this
            // msg as gracefully as possible, i.e. set the XxxReal
            // vars so that we'll only actually copy over the fixed
            // size of the msg (but the event buf ptrs will still
            // get updated correctly) and set a flag to say that
            // we need to do some munging on the msg before returning
            //

            dwMoveSizeReal = (dwMoveSizeReal <= sizeof (ASYNCEVENTMSG) ?
                dwMoveSizeReal : sizeof (ASYNCEVENTMSG));

            dwMoveSizeWrappedReal = (dwMoveSizeReal < sizeof (ASYNCEVENTMSG) ?
                sizeof (ASYNCEVENTMSG) - dwMoveSizeReal : 0);

            bAllocFailed = TRUE;
        }
    }


    //
    // Copy the msg from the event buf to the msg buf, and update the
    // event buf pointers
    //

    pMsg = (PASYNCEVENTMSG) gEventHandlerThreadParams.pMsgBuffer;

    CopyMemory (pMsg, gEventHandlerThreadParams.pDataOut, dwMoveSizeReal);

    if (dwMoveSizeWrapped)
    {
        CopyMemory(
            ((LPBYTE) pMsg) + dwMoveSizeReal,
            gEventHandlerThreadParams.pEventBuffer,
            dwMoveSizeWrappedReal
            );

        gEventHandlerThreadParams.pDataOut =
            gEventHandlerThreadParams.pEventBuffer + dwMoveSizeWrapped;
    }
    else
    {
        gEventHandlerThreadParams.pDataOut += dwMoveSize;


        //
        // If msg ran to end of the event buffer then reset pDataOut
        //

        if (gEventHandlerThreadParams.pDataOut >=
            (gEventHandlerThreadParams.pEventBuffer +
                gEventHandlerThreadParams.dwEventBufferTotalSize))
        {
            gEventHandlerThreadParams.pDataOut =
                gEventHandlerThreadParams.pEventBuffer;
        }
    }

    gEventHandlerThreadParams.dwEventBufferUsedSize -= dwMsgSize;


    //
    // Special msg param munging in case an attempt to grow the
    // buffer size above failed
    //

    if (bAllocFailed)
    {
        switch (pMsg->Msg)
        {
        case LINE_REPLY:

            pMsg->Param2 = LINEERR_NOMEM;
            break;

        case PHONE_REPLY:

            pMsg->Param2 = PHONEERR_NOMEM;
            break;

        default:

            break;
        }
    }

GetEventFromQueue_done:

    LeaveCriticalSection (&gEventBufferCriticalSection);

    return pMsg;
}


BOOL
GetEventsFromServer(
    DWORD   dwInitContext
    )
{
    BOOL            bResult = FALSE;
    DWORD           dwUsedSize, dwRetryCount;
    PDRVSERVER      pServer;
    PTAPI32_MSG     pMsg;


    if (!(pServer = (PDRVSERVER) ReferenceObject(
            ghHandleTable,
            dwInitContext,
            gdwDrvServerKey
            )) ||
        pServer->bShutdown)
    {
        LOG((TL_ERROR, "GetEventsFromServer: bad InitContext=x%x", dwInitContext));

        if (pServer)
        {
            DereferenceObject (ghHandleTable, dwInitContext, 1);
        }

        return FALSE;
    }

getEvents:

    dwRetryCount = 0;
    pMsg = (PTAPI32_MSG) gEventHandlerThreadParams.pMsgBuffer;

    do
    {
        pMsg->u.Req_Func = xGetAsyncEvents;
        pMsg->Params[0]  = gEventHandlerThreadParams.dwMsgBufferTotalSize -
            sizeof (TAPI32_MSG);

        dwUsedSize = sizeof (TAPI32_MSG);

        RpcTryExcept
        {
            ClientRequest(
                pServer->phContext,
                (char *) pMsg,
                gEventHandlerThreadParams.dwMsgBufferTotalSize,
                &dwUsedSize
                );

            if (pMsg->u.Ack_ReturnValue == TAPIERR_INVALRPCCONTEXT)
            {
                OnServerDisconnected (pServer);
                pMsg->u.Ack_ReturnValue = LINEERR_OPERATIONFAILED;
            }
            dwRetryCount = gdwRetryCount;
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            LOG((TL_INFO,
                "GetEventsFromServer: rpc exception %d handled",
                RpcExceptionCode()
                ));

            dwRetryCount++;

            if (dwRetryCount < gdwRetryCount)
            {
                Sleep (gdwRetryTimeout);
            }
            else
            {
                unsigned long ulResult = RpcExceptionCode();

                if ((ulResult == RPC_S_SERVER_UNAVAILABLE)  ||
                    (ulResult == ERROR_INVALID_HANDLE))
                {
                    OnServerDisconnected (pServer);

                    LOG((TL_ERROR,
                        "GetEventsFromServer: server '%s' unavailable",
                        pServer->szServerName
                        ));
                }

                pMsg->u.Ack_ReturnValue = LINEERR_OPERATIONFAILED;
            }
        }
        RpcEndExcept

    } while (dwRetryCount < gdwRetryCount);

    if (pMsg->u.Ack_ReturnValue == 0)
    {
        DWORD   dwNeededSize = (DWORD) pMsg->Params[1],
                dwUsedSize = (DWORD) pMsg->Params[2];


        if (dwUsedSize)
        {
            RemoteSPEventProc(
                (PCONTEXT_HANDLE_TYPE2) IntToPtr(0xfeedface),
                (unsigned char *) (pMsg + 1),
                dwUsedSize
                );


            //
            // RemoteSPEventProc will set the byte pointed to by (pMsg+1)
            // to non-zero on success, or zero on error (indicating
            // bad data in the event buffer, which we'll discard)
            //

            if (*((unsigned char *) (pMsg + 1)) != 0)
            {
                bResult = TRUE;
            }
            else
            {
                bResult = FALSE;
                goto GetEventsFromServer_dereference;
            }
        }

        if (dwNeededSize > dwUsedSize)
        {
            //
            // There's still more data to retrieve on the server.
            // Grow the buffer so we can get it all next time.
            //

            DWORD   dwNewSize = dwNeededSize + 256;
            LPVOID  p;


            if ((p = DrvAlloc (dwNewSize)))
            {
                DrvFree (gEventHandlerThreadParams.pMsgBuffer);

                gEventHandlerThreadParams.pMsgBuffer = p;
                gEventHandlerThreadParams.dwMsgBufferTotalSize = dwNewSize;
            }
            else if (dwUsedSize == 0)
            {
            }

            goto getEvents;
        }
    }

GetEventsFromServer_dereference:

    DereferenceObject (ghHandleTable, dwInitContext, 1);

    return bResult;
}


void
EventHandlerThread(
    LPVOID  pParams
    )
{
    //
    // NOTES:
    //
    // 1. depending on server side implementation, we may experience race
    //    conditions where msgs that we expect to show up in a certain
    //    sequence show up out of sequence (i.e. call state msgs that show
    //    up before make call completion msgs), which could present problems.
    //
    //    one solution is to to queue call state/info msgs to incomplete
    //    calls (to be sent after call is completed).  another is not to send
    //    any call state msgs after the idle is received
    //

    DWORD           dwMsgSize, dwNumObjects, dwResult, dwData,
                    dwNumBytesRead, dwTimeout;
    HANDLE          ahObjects[2];
    OVERLAPPED      overlapped;
    PASYNCEVENTMSG  pMsg;

#if MEMPHIS
#else
    HANDLE            hProcess;
#endif


    LOG((TL_INFO, "EventHandlerThread: enter"));


#if MEMPHIS
#else

    //
    // This thread has no user context, which prevents it from rpc'ing
    // back to remote tapisrv when/if necessary.  So, find the user
    // that is logged on and impersonate them in this thread.
    //

    if (!GetCurrentlyLoggedOnUser (&hProcess))
    {
        LOG((TL_ERROR, "GetCurrentlyLoggedOnUser failed"));
    }
    else
    {
        if (!SetProcessImpersonationToken(hProcess))
        {
            LOG((TL_ERROR, "SetProcessImpersonationToken failed"));
        }
    }

#endif


    //
    // Bump up the thread priority a bit so we don't get starved by
    // ill-behaved apps
    //

    if (!SetThreadPriority(
            GetCurrentThread(),
            THREAD_PRIORITY_ABOVE_NORMAL
            ))
    {
        LOG((TL_ERROR,
            "EventHandlerThread: SetThreadPriority failed, err=%d",
            GetLastError()
            ));
    }

    ahObjects[0] = gEventHandlerThreadParams.hEvent;

    if (gEventHandlerThreadParams.hMailslot != INVALID_HANDLE_VALUE)
    {
        ZeroMemory (&overlapped, sizeof (overlapped));

        ahObjects[1] =
        overlapped.hEvent = gEventHandlerThreadParams.hMailslotEvent;

        dwNumObjects = 2;

        if (!ReadFile(
                gEventHandlerThreadParams.hMailslot,
                &dwData,
                sizeof (dwData),
                &dwNumBytesRead,
                &overlapped
                )

            &&  (GetLastError() != ERROR_IO_PENDING))
        {
            LOG((TL_ERROR,
                "EventHandlerThread: ReadFile failed, err=%d",
                GetLastError()
                ));
        }

        dwTimeout = MAX_MAILSLOT_TIMEOUT;
    }
    else
    {
        dwNumObjects = 1;

        dwTimeout = INFINITE;
    }

    while (1)
    {
        //
        // Wait for an event to show up in the queue or for a msg
        // to show up in the mailslot
        //

        dwResult = WaitForMultipleObjects(
            dwNumObjects,
            ahObjects,
            FALSE,
            dwTimeout
            );

        if (gEventHandlerThreadParams.bExit)
        {
            break;
        }

        switch (dwResult)
        {
        case WAIT_OBJECT_0:

            //
            // Simply break & process the events
            //

            break;

        case WAIT_OBJECT_0+1:

            //
            // Post another read, the retrieve & process the events
            //

            if (!ReadFile(
                    gEventHandlerThreadParams.hMailslot,
                    &dwData,
                    sizeof (dwData),
                    &dwNumBytesRead,
                    &overlapped
                    )

                &&  (GetLastError() != ERROR_IO_PENDING))
            {
                LOG((TL_ERROR,
                    "EventHandlerThread: ReadFile failed, err=%d",
                    GetLastError()
                    ));
            }

            if (GetEventsFromServer (dwData))
            {
                dwTimeout = MIN_MAILSLOT_TIMEOUT;
            }

            break;

        case WAIT_TIMEOUT:
        {

#define DWORD_ARRAY_BLOCK_SIZE    128

            //
            // Check to see if any of the mailslot servers have
            // events waiting for us
            //

            BOOL            bGotSomeEvents  = FALSE;
            PDRVSERVER      pServer;
            LIST_ENTRY *    pEntry;
            DWORD *         pArray          = NULL;
            DWORD *         pTempArray      = NULL;
            DWORD           dwEntriesCount  = 0;
            DWORD           dwEntriesUsed   = 0;
            DWORD           dwIdx;
            BOOL            bAddOK;

            pArray = (DWORD *) DrvAlloc ( sizeof(DWORD) * DWORD_ARRAY_BLOCK_SIZE );

            if ( pArray )
            {
                dwEntriesCount  = DWORD_ARRAY_BLOCK_SIZE;
            }

            TapiEnterCriticalSection(&gCriticalSection);
            
            for(
                pEntry = gpCurrentInitContext->ServerList.Flink;
                pEntry != &gpCurrentInitContext->ServerList;
                // null op
                )
            {
                PDRVSERVER pServer;


                pServer = CONTAINING_RECORD(
                    pEntry,
                    DRVSERVER,
                    ServerList
                    );
                pEntry = pEntry->Flink;
                
                if (!pServer->bConnectionOriented  &&
                    pServer->dwFlags == 0)
                {
                    //
                    // if possible, store the InitContext and postpone 
                    // the RPC call for after we leave the Crit. Sec. 
                    //

                    bAddOK = FALSE;
                    
                    if ( pArray )
                    {

                        if ( dwEntriesCount == dwEntriesUsed )
                        {
                            //
                            // need to increase the array size
                            //

                            pTempArray = (DWORD *) DrvAlloc (
                                    sizeof(DWORD) * (DWORD_ARRAY_BLOCK_SIZE + dwEntriesCount)
                                    );

                            if ( pTempArray )
                            {

                                bAddOK = TRUE;
                                CopyMemory(
                                    pTempArray,
                                    pArray,
                                    sizeof(DWORD) * dwEntriesCount
                                    );
                                dwEntriesCount += DWORD_ARRAY_BLOCK_SIZE;
                                DrvFree( pArray );
                                pArray = pTempArray;

                            }
                        }
                        else
                        {
                            bAddOK = TRUE;
                        }

                        if ( bAddOK )
                        {
                            pArray[ dwEntriesUsed++ ] = pServer->InitContext;
                        }
                    }

                    if ( !bAddOK )
                    {
                        if (GetEventsFromServer (pServer->InitContext))
                        {
                            bGotSomeEvents = TRUE;
                        }
                    }
                }
            }

            TapiLeaveCriticalSection(&gCriticalSection);

            if ( pArray )
            {
                for( dwIdx = 0; dwIdx < dwEntriesUsed; dwIdx++ )
                {
                    if (GetEventsFromServer (pArray[ dwIdx ]))
                    {
                        bGotSomeEvents = TRUE;
                    }
                }

                DrvFree( pArray );
            }

            if (bGotSomeEvents)
            {
                dwTimeout = MIN_MAILSLOT_TIMEOUT;
            }
            else if (dwTimeout < MAX_MAILSLOT_TIMEOUT)
            {
                dwTimeout += 500;
            }

            break;
        }
        default:

            //
            // Print a dbg msg & process any available events
            //

            LOG((TL_ERROR,
                "EventHandlerThread: WaitForMultObjs failed, result=%d/err=%d",
                dwResult,
                GetLastError()
                ));

            break;
        }


        //
        // Process the events in the queue
        //

        while ((pMsg = GetEventFromQueue()))
        {
            //
            // First validate the pDrvServer pointer in the msg
            //

            PDRVLINE    pLine;
            PDRVPHONE   pPhone;
            PDRVSERVER  pServer;


            if (!(pServer = ReferenceObject(
                    ghHandleTable,
                    pMsg->InitContext,
                    gdwDrvServerKey
                    )))
            {
                LOG((TL_ERROR,
                    "EventHandlerThread: bad InitContext=x%x in msg",
                    pMsg->InitContext
                    ));

                continue;
            }


            switch (pMsg->Msg)
            {
            case LINE_CREATEDIALOGINSTANCE:

                break;

            case LINE_PROXYREQUEST:

                break;

            case LINE_ADDRESSSTATE:
            case LINE_AGENTSTATUS:
            case LINE_AGENTSESSIONSTATUS:
            case LINE_QUEUESTATUS:
            case LINE_AGENTSTATUSEX:
            case LINE_GROUPSTATUS:
            case LINE_PROXYSTATUS:

                if ((pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVLINE_KEY
                        )))
                {
                    (*gpfnLineEventProc)(
                        pLine->htLine,
                        0,
                        pMsg->Msg,
                        pMsg->Param1,
                        pMsg->Param2,
                        pMsg->Param3
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case LINE_AGENTSPECIFIC:
            {
                DWORD       hDeviceCallback = (DWORD) (pMsg->Param4 ?
                                pMsg->Param4 : pMsg->hDevice);
                PDRVCALL    pCall;
                HTAPICALL   htCall;


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        hDeviceCallback,
                        DRVLINE_KEY
                        )))
                {
                    break;
                }

                if (pMsg->Param4)
                {
                    EnterCriticalSection (&gCallListCriticalSection);

                    pCall = (PDRVCALL) pLine->pCalls;

                    while (pCall && (pCall->hCall != (HCALL) pMsg->hDevice))
                    {
                        pCall = pCall->pNext;
                    }

                    if (!pCall  ||  pCall->dwKey != DRVCALL_KEY)
                    {
                        LeaveCriticalSection (&gCallListCriticalSection);
                        DereferenceObject (ghHandleTable, hDeviceCallback, 1);
                        break;
                    }

                    htCall = pCall->htCall;

                    LeaveCriticalSection (&gCallListCriticalSection);
                }
                else
                {
                    htCall = 0;
                }

                (*gpfnLineEventProc)(
                    pLine->htLine,
                    htCall,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

                DereferenceObject (ghHandleTable, hDeviceCallback, 1);

                break;
            }
            case LINE_CALLINFO:
            case LINE_CALLSTATE:
            case LINE_GENERATE:
            case LINE_MONITORDIGITS:
            case LINE_MONITORMEDIA:
            case LINE_MONITORTONE:
            {
                //
                // For all the msgs where hDevice refers to a call tapisrv
                // will pass us the pLine (hRemoteLine) for that call in
                // dwParam4 to make the lookup of the corresponding pCall
                // easier
                //

                HCALL       hCall = (HCALL) pMsg->hDevice;
                PDRVCALL    pCall;
                HTAPICALL   htCall;
                ASYNCEVENTMSGRSP MsgRsp;


                MsgRsp.TotalSize = pMsg->TotalSize;
                MsgRsp.InitContext = pMsg->InitContext;
                MsgRsp.fnPostProcessProcHandle = pMsg->fnPostProcessProcHandle;
                MsgRsp.hDevice = pMsg->hDevice;
                MsgRsp.Msg = pMsg->Msg;
                MsgRsp.OpenContext = pMsg->OpenContext;
                MsgRsp.Param1 = pMsg->Param1;
                MsgRsp.Param2 = pMsg->Param2;
                MsgRsp.Param3 = pMsg->Param3;
                MsgRsp.Param4 = pMsg->Param4;


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->Param4,
                        DRVLINE_KEY
                        )))
                {
                    break;
                }

                EnterCriticalSection (&gCallListCriticalSection);

                pCall = (PDRVCALL) pLine->pCalls;

                while (pCall && (pCall->hCall != hCall))
                {
                    pCall = pCall->pNext;
                }

                if (!pCall  ||  pCall->dwKey != DRVCALL_KEY)
                {
                    LeaveCriticalSection (&gCallListCriticalSection);
                    DereferenceObject (ghHandleTable, pMsg->Param4, 1);
                    LOG((TL_ERROR,"EventHandlerThread: Bad hCall(cs) x%lx",hCall));
                    break;
                }

                htCall = pCall->htCall;
#if DBG
                if ( 0 == htCall )
                {
                    LOG((TL_ERROR, "htCall is now NULL! pCall=x%lx", pCall));
                }
#endif
                if ( LINE_CALLINFO == MsgRsp.Msg )
                {
                    pCall->dwDirtyStructs |= STRUCTCHANGE_LINECALLINFO;

                    if (MsgRsp.Param1 & LINECALLINFOSTATE_DEVSPECIFIC)
                    {
                        pCall->dwDirtyStructs |= STRUCTCHANGE_LINECALLSTATUS;
                    }
#if MEMPHIS
#else
                    if (MsgRsp.Param1 & (LINECALLINFOSTATE_CALLID |
                            LINECALLINFOSTATE_RELATEDCALLID))
                    {
                        pCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;
                    }
#endif
                }
                else if (LINE_CALLSTATE == MsgRsp.Msg )
                {
                    pCall->dwDirtyStructs |= STRUCTCHANGE_LINECALLSTATUS;


                    //
                    // If the state == CONFERENCED then dwParam2 should
                    // contain the hConfCall.  Note that the real dwParam2
                    // actually lives in MsgRsp.pfnPostProcessProc (see note
                    // below), so we retrieve it from there and (if non-NULL)
                    // try to map it to an htCall, then write the htCall
                    // value back to MsgRsp.pfnPostProcessProc.
                    //

                    if (MsgRsp.Param1 == LINECALLSTATE_CONFERENCED  &&
                        MsgRsp.fnPostProcessProcHandle)
                    {
                        HCALL     hConfCall = (HCALL) DWORD_CAST(MsgRsp.fnPostProcessProcHandle,__FILE__,__LINE__);
                        PDRVCALL  pConfCall = (PDRVCALL) pLine->pCalls;


                        while (pConfCall && (pConfCall->hCall != hConfCall))
                        {
                            pConfCall = pConfCall->pNext;
                        }

                        if (!pConfCall  ||  pConfCall->dwKey != DRVCALL_KEY)
                        {
                            LOG((TL_ERROR,
                                "EventHandlerThread: Bad pConfCall(cs) x%lx",
                                pCall
                                ));

                            MsgRsp.fnPostProcessProcHandle = 0;
                        }
                        else
                        {
                            MsgRsp.fnPostProcessProcHandle = (ULONG_PTR)(pConfCall->htCall);
                        }
                    }


                    //
                    // HACK ALERT!
                    //
                    // The remote tapisrv will pass us the call privilege
                    // in MsgRsp.dwParam2, and the real dwParam2 (the call
                    // state mode) in MsgRsp.pfnPostProcess.  For the very
                    // 1st CALLSTATE msg for an incoming call we want to
                    // indicate the appropriate privilege to the local
                    // tapisrv so it knows whether or not it needs to find
                    // find a local owner for the call.  So, we save the
                    // privilege & real dwParam2 in the call struct and
                    // pass a pointer to these in dwParam2.
                    //
                    // For all other cases we set MsgRsp.dwParam2 to the
                    // real dwParam2 in MsgRsp.pfnPostProcess.
                    //

                    if (!pCall->dwInitialPrivilege)
                    {
                        pCall->dwInitialCallStateMode = MsgRsp.fnPostProcessProcHandle;

                        pCall->dwInitialPrivilege = MsgRsp.Param2;

                        MsgRsp.Param2 = (ULONG_PTR)
                            &pCall->dwInitialCallStateMode;
                    }
                    else
                    {
                        MsgRsp.Param2 = MsgRsp.fnPostProcessProcHandle;
                    }
                }

                LeaveCriticalSection (&gCallListCriticalSection);

                if (MsgRsp.Msg == LINE_MONITORTONE)
                {
                    MsgRsp.Param2 = 0;
                }

                (*gpfnLineEventProc)(
                    pLine->htLine,
                    htCall,
                    MsgRsp.Msg,
                    MsgRsp.Param1,
                    MsgRsp.Param2,
                    MsgRsp.Param3
                    );

                DereferenceObject (ghHandleTable, pMsg->Param4, 1);

                break;
            }
            case LINE_DEVSPECIFIC:
            case LINE_DEVSPECIFICFEATURE:
            {
                //
                // For all the msgs where hDevice refers to a call tapisrv
                // will pass us the pLine (hRemoteLine) for that call in
                // dwParam4 to make the lookup of the corresponding pCall
                // easier
                //

                HTAPICALL htCall;
                DWORD     hDeviceCallback = (DWORD) (pMsg->Param4 ?
                              pMsg->Param4 : pMsg->hDevice);


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        hDeviceCallback,
                        DRVLINE_KEY
                        )))
                {
                    break;
                }

                if (pMsg->Param4)
                {
                    HCALL       hCall = (HCALL) pMsg->hDevice;
                    PDRVCALL    pCall;


                    EnterCriticalSection (&gCallListCriticalSection);

                    pCall = (PDRVCALL) pLine->pCalls;

                    while (pCall && (pCall->hCall != hCall))
                    {
                        pCall = pCall->pNext;
                    }

                    if (pCall)
                    {
                        if (pCall->dwKey != DRVCALL_KEY)
                        {
                            LeaveCriticalSection (&gCallListCriticalSection);

                            LOG((TL_ERROR,
                                "EventHandlerThread: Bad pCall(ds) x%lx",
                                pCall
                                ));

                            goto LINE_DEVSPECIFIC_dereference;
                        }

                        htCall = pCall->htCall;

                        LeaveCriticalSection (&gCallListCriticalSection);

                        pMsg->Msg = (pMsg->Msg == LINE_DEVSPECIFIC ?
                            LINE_CALLDEVSPECIFIC :
                            LINE_CALLDEVSPECIFICFEATURE);
                    }
                    else
                    {
                        LeaveCriticalSection (&gCallListCriticalSection);
                        goto LINE_DEVSPECIFIC_dereference;
                    }
                }
                else
                {
                    htCall = 0;
                }

                (*gpfnLineEventProc)(
                    pLine->htLine,
                    htCall,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

LINE_DEVSPECIFIC_dereference:

                DereferenceObject (ghHandleTable, hDeviceCallback, 1);

                break;
            }
            case PHONE_BUTTON:
            case PHONE_DEVSPECIFIC:

                if ((pPhone = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVPHONE_KEY
                        )))
                {
                    (*gpfnPhoneEventProc)(
                        pPhone->htPhone,
                        pMsg->Msg,
                        pMsg->Param1,
                        pMsg->Param2,
                        pMsg->Param3
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case LINE_LINEDEVSTATE:

                if (pMsg->Param1 & LINEDEVSTATE_REINIT)
                {
                    //
                    // Be on our best behavior and immediately shutdown
                    // our init instances on the server
                    //
                    
                    if (pMsg->InitContext)
                    {
                        //
                        //  In the case of TAPISRV shutdown, server sends 
                        //  LINEDEVSTATE_REINIT, then waits for everybody to 
                        //  finish, we do not want to retry the connection until
                        //  it indeed stopped, so we insert a wait
                        //
                        Sleep (8000);
                        OnServerDisconnected(pServer);
                        break;
                    }

                    pMsg->hDevice = 0;

                    /*
                    if (pMsg->Param2 == RSP_MSG)
                    {
                        //
                        // This is a message from TAPISRV indicating that this
                        // client need to reinit.  RemoteSP doesn't need to do
                        // it's shut down, but should notify client tapisrv
                        // that it needs to reinit.
                    }
                    else
                    {
                        Shutdown (pServer);
                    }
                    */
                }

                if (pMsg->Param1 & LINEDEVSTATE_TRANSLATECHANGE)
                {
                    // we shouldn't send this up to tapisrv, since this
                    // means that the translatecaps have changed on the
                    // server.  just ignore this message

                    break;
                }

                if (pMsg->hDevice)
                {
                    if (!(pLine = ReferenceObject(
                            ghHandleTable,
                            pMsg->hDevice,
                            DRVLINE_KEY
                            )))
                    {
                        break;
                    }
                }

                (*gpfnLineEventProc)(
                    pMsg->hDevice ? pLine->htLine : 0,
                    0,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

                if (pMsg->hDevice)
                {
                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case PHONE_STATE:

                if (pMsg->Param1 & PHONESTATE_REINIT)
                {
                    //
                    // Be on our best behavior and immediately shutdown
                    // our init instances on the server
                    //
                    
                    if (pMsg->InitContext)
                    {
                        //
                        //  In the case of TAPISRV shutdown, server sends 
                        //  LINEDEVSTATE_REINIT, then waits for everybody to 
                        //  finish, we do not want to retry the connection until
                        //  it indeed stopped, so we insert a wait
                        //
                        Sleep (8000);
                        OnServerDisconnected(pServer);
                        break;
                    }

                    pMsg->hDevice = 0;
                }

                if (pMsg->hDevice)
                {
                    if (!(pPhone = ReferenceObject(
                            ghHandleTable,
                            pMsg->hDevice,
                            DRVPHONE_KEY
                            )))
                    {
                        break;
                    }
                }

                (*gpfnPhoneEventProc)(
                    pMsg->hDevice ? pPhone->htPhone : 0,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

                if (pMsg->hDevice)
                {
                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case LINE_CLOSE:
            {
                PDRVCALL    pCall;


                if ((pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVLINE_KEY
                        )))
                {
                    //
                    // Nullify the hLine field so that when TSPI_Close
                    // is called we know not to call the server
                    //

                    pLine->hLine = 0;


                    //
                    // Safely walk the call list for this line & nullify
                    // each call's hCall field so that when TSPI_CloseCall
                    // is called we know not to call the server
                    //

                    EnterCriticalSection (&gCallListCriticalSection);

                    pCall = pLine->pCalls;

                    while (pCall)
                    {
                        if (pCall->dwKey != DRVCALL_KEY)
                        {
                            LOG((TL_ERROR,
                                "EventHandlerThread: Bad pCall(lc) x%lx",
                                pCall
                                ));

                            continue;
                        }

                        pCall->hCall = 0;
                        pCall = pCall->pNext;
                    }

                    LeaveCriticalSection (&gCallListCriticalSection);

                    (*gpfnLineEventProc)(
                        pLine->htLine,
                        0,
                        LINE_CLOSE,
                        0,
                        0,
                        0
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;
            }
            case PHONE_CLOSE:
            {
                if ((pPhone = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVPHONE_KEY
                        )))
                {
                    //
                    // Nullify the hPhone field so that when TSPI_Close
                    // is called we know not to call the server
                    //

                    pPhone->hPhone = 0;

                    (*gpfnPhoneEventProc)(
                        pPhone->htPhone,
                        PHONE_CLOSE,
                        0,
                        0,
                        0
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;
            }
            case LINE_GATHERDIGITS:
            {
                if (pMsg->TotalSize >= (sizeof (*pMsg) + sizeof (PDRVLINE)))
                {
                    DWORD       hLineCallback = ((DWORD *)(pMsg + 1))[1];
                    HCALL       hCall = (HCALL) pMsg->hDevice;
                    PDRVCALL    pCall;
                    HTAPICALL   htCall;

                    if ((pLine = ReferenceObject(
                            ghHandleTable,
                            hLineCallback,
                            DRVLINE_KEY
                            )))
                    {
                        EnterCriticalSection (&gCallListCriticalSection);

                        pCall = (PDRVCALL) pLine->pCalls;

                        while (pCall && (pCall->hCall != hCall))
                        {
                            pCall = pCall->pNext;
                        }

                        htCall = (pCall ? pCall->htCall : 0);

                        if (pCall && pCall->dwKey != DRVCALL_KEY)
                        {
                            LeaveCriticalSection (&gCallListCriticalSection);

                            goto LINE_GATHERDIGITS_dereference;
                        }

                        LeaveCriticalSection (&gCallListCriticalSection);

                        TSPI_lineGatherDigits_PostProcess (pMsg);

                        (*gpfnLineEventProc)(
                            pLine->htLine,
                            htCall,
                            LINE_GATHERDIGITS,
                            pMsg->Param1,
                            pMsg->Param2,   // dwEndToEndID
                            0
                            );

LINE_GATHERDIGITS_dereference:

                        DereferenceObject (ghHandleTable, hLineCallback, 1);
                    }
                }

                break;
            }

            case LINE_REPLY:
            case PHONE_REPLY:
            {
                ULONG_PTR               Context2;
                DWORD                   originalRequestID;
                PASYNCREQUESTCONTEXT    pContext;


                if ((pContext = ReferenceObjectEx(
                        ghHandleTable,
                        pMsg->Param1,
                        0,
                        (LPVOID *) &Context2
                        )))
                {
                    originalRequestID = DWORD_CAST(Context2,__FILE__,__LINE__);

                    LOG((TL_INFO,
                        "Doing LINE_/PHONE_REPLY: LocID=x%x (RemID=x%x), " \
                            "Result=x%x",
                        originalRequestID,
                        pMsg->Param1,
                        pMsg->Param2
                        ));

                    if (pContext != (PASYNCREQUESTCONTEXT) -1)
                    {
                        if (pContext->dwKey == DRVASYNC_KEY)
                        {
                            //
                            // Set pContext->dwOriginalRequestID so
                            // MakeCallPostProcess &
                            // SetupConferencePostProcess can check it
                            // againt pCall->dwOriginalRequestID for
                            // verification.
                            //

                            pContext->dwOriginalRequestID = (DWORD)
                                originalRequestID;

                            (*pContext->pfnPostProcessProc)(
                                pMsg,
                                pContext
                                );
                        }
                        else
                        {
                            //
                            // Not a valid request id, do a single deref
                            // & break
                            //

                            DereferenceObject (ghHandleTable, pMsg->Param1, 1);
                            break;
                        }
                    }

                    (*gpfnCompletionProc)(
                        (DRV_REQUESTID) originalRequestID,
                        (LONG) pMsg->Param2
                        );


                    //
                    // Double deref to free the object
                    //

                    DereferenceObject (ghHandleTable, pMsg->Param1, 2);
                }

                break;
            }
            case LINE_CREATE:
            {
                //
                // Check validity of new device ID to thwart RPC attacks.
                // Compare with known/existing device ID's on for this
                // server, and also try to get devCaps for this device
                // from server.
                //

                #define V1_0_LINEDEVCAPS_SIZE 236

                BYTE            buf[sizeof (TAPI32_MSG) +
                                    V1_0_LINEDEVCAPS_SIZE];
                DWORD           i, dwRetryCount = 0, dwUsedSize;
                PTAPI32_MSG     pReq = (PTAPI32_MSG) buf;
                PDRVLINELOOKUP  pLookup;

                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpLineLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is already in our global
                            // table, so blow off this msg
                            //
                            TapiLeaveCriticalSection(&gCriticalSection);
                            goto LINE_CREATE_break;
                        }
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                do
                {
                    pReq->u.Req_Func = lGetDevCaps;

                    pReq->Params[0] = pServer->hLineApp;
                    pReq->Params[1] = pMsg->Param1;
                    pReq->Params[2] = TAPI_VERSION1_0;
                    pReq->Params[3] = 0;
                    pReq->Params[4] = V1_0_LINEDEVCAPS_SIZE;

                    dwUsedSize = sizeof (TAPI32_MSG);

                    RpcTryExcept
                    {
                        ClientRequest(
                            pServer->phContext,
                            (char *) pReq,
                            sizeof (buf),
                            &dwUsedSize
                            );

                        dwRetryCount = gdwRetryCount;
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                        dwRetryCount++;

                        if (dwRetryCount < gdwRetryCount)
                        {
                            Sleep (gdwRetryTimeout);
                        }
                        else
                        {
                            pReq->u.Ack_ReturnValue = LINEERR_BADDEVICEID;
                        }
                    }
                    RpcEndExcept

                } while (dwRetryCount < gdwRetryCount);

                if ((LONG) pReq->u.Ack_ReturnValue != LINEERR_BADDEVICEID)
                {
                    if (AddLine(
                        pServer,
                        gdwTempLineID,
                        (DWORD) pMsg->Param1,
                        FALSE,
                        FALSE,
                        0,
                        NULL
                        ) == 0)
                    {
                        (*gpfnLineEventProc)(
                            0,
                            0,
                            LINE_CREATE,
                            (ULONG_PTR) ghProvider,
                            gdwTempLineID--,
                            0
                            );
                    }
                }

LINE_CREATE_break:

                break;
            }
            case LINE_REMOVE:
            {
                PDRVLINELOOKUP  pLookup;
                BOOL            fValidID = FALSE;
                DWORD           dwDeviceID, i;

                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpLineLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is in our global
                            //
                            fValidID = TRUE;
                            dwDeviceID = pLookup->aEntries[i].dwDeviceIDLocal;
                            pLookup->aEntries[i].dwDeviceIDServer = 0xffffffff;
                            break;
                        }
                    }

                    if (fValidID)
                    {
                        break;
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                if (fValidID)
                {
                    (*gpfnLineEventProc)(
                        0,
                        0,
                        LINE_REMOVE,
                        dwDeviceID,
                        0,
                        0
                        );
                }
            }
            break;
            case PHONE_CREATE:
            {
                //
                // Check validity of new device ID to thwart RPC attacks.
                // Compare with known/existing device ID's on for this
                // server, and also try to get devCaps for this device
                // from server.
                //

                #define V1_0_PHONECAPS_SIZE 144

                BYTE            buf[sizeof (TAPI32_MSG) + V1_0_PHONECAPS_SIZE];
                DWORD           i, dwRetryCount = 0, dwUsedSize;
                PTAPI32_MSG     pReq = (PTAPI32_MSG) buf;
                PDRVPHONELOOKUP pLookup;
                
                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpPhoneLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is already in our global
                            // table, so blow off this msg
                            //
                            TapiLeaveCriticalSection(&gCriticalSection);
                            goto PHONE_CREATE_break;
                        }
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                do
                {
                    pReq->u.Req_Func = pGetDevCaps;

                    pReq->Params[0] = pServer->hPhoneApp;
                    pReq->Params[1] = pMsg->Param1;
                    pReq->Params[2] = TAPI_VERSION1_0;
                    pReq->Params[3] = 0;
                    pReq->Params[4] = V1_0_PHONECAPS_SIZE;

                    dwUsedSize = sizeof (TAPI32_MSG);

                    RpcTryExcept
                    {
                        ClientRequest(
                            pServer->phContext,
                            (char *) pReq,
                            sizeof (buf),
                            &dwUsedSize
                            );

                        dwRetryCount = gdwRetryCount;
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                        dwRetryCount++;

                        if (dwRetryCount < gdwRetryCount)
                        {
                            Sleep (gdwRetryTimeout);
                        }
                        else
                        {
                            pReq->u.Ack_ReturnValue = PHONEERR_BADDEVICEID;
                        }
                    }
                    RpcEndExcept

                } while (dwRetryCount < gdwRetryCount);

                if ((LONG) pReq->u.Ack_ReturnValue != PHONEERR_BADDEVICEID)
                {
                    AddPhone(
                        pServer,
                        gdwTempPhoneID,
                        (DWORD) pMsg->Param1,
                        FALSE,
                        FALSE,
                        0,
                        NULL
                        );

                    (*gpfnPhoneEventProc)(
                        0,
                        PHONE_CREATE,
                        (ULONG_PTR) ghProvider,
                        gdwTempPhoneID--,
                        0
                        );
                }

PHONE_CREATE_break:

                break;
            }
            case PHONE_REMOVE:
            {
                PDRVPHONELOOKUP pLookup;
                BOOL            fValidID = FALSE;
                DWORD           dwDeviceID, i;

                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpPhoneLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is in our global
                            //
                            fValidID = TRUE;
                            dwDeviceID = pLookup->aEntries[i].dwDeviceIDLocal;
                            break;
                        }
                    }

                    if (fValidID)
                    {
                        break;
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                if (fValidID)
                {
                    (*gpfnPhoneEventProc)(
                        0,
                        PHONE_REMOVE,
                        dwDeviceID,
                        0,
                        0
                        );
                }
            }
            break;
            case LINE_APPNEWCALL:
            {
                PDRVCALL  pCall;
                HTAPICALL htCall;


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVLINE_KEY
                        )))
                {
                   break;
                }

                if ((pCall = DrvAlloc (sizeof (DRVCALL))))
                {
                    pCall->hCall           = (HCALL) pMsg->Param2;
                    pCall->dwAddressID     = (DWORD) pMsg->Param1;
#if MEMPHIS
#else
                    if (pMsg->TotalSize >=
                            (sizeof (*pMsg) + 2 * sizeof (DWORD)))
                    {
                        pCall->dwCallID        = (DWORD) *(&pMsg->Param4 + 1);
                        pCall->dwRelatedCallID = (DWORD) *(&pMsg->Param4 + 2);
                    }
                    else
                    {
                        pCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;

                        pLine->pServer->bVer2xServer = TRUE;
                    }
#endif

                    if (pLine->htLine)
                    {

                        (*gpfnLineEventProc)(
                            pLine->htLine,
                            0,
                            LINE_NEWCALL,
                            (ULONG_PTR) pCall,
                            (ULONG_PTR) &(pCall->htCall),
                            (ULONG_PTR) 0
                            );

                        EnterCriticalSection (&gCallListCriticalSection);

                        AddCallToList (pLine, pCall);

                        htCall = pCall->htCall;

                        LeaveCriticalSection (&gCallListCriticalSection);

                        if (!htCall)
                        {
                            //
                            // tapi was not able to create it's own instance
                            // to represent ths incoming call, perhaps
                            // because the line was closed, or out of
                            // memory.  if the line was closed then we've
                            // already notified the remote server, and it
                            // should have destroyed the call client.
                            // otherwise, we probably want to do a closecall
                            // here or in a worker thread

                            RemoveCallFromList (pCall);
                        }
                    }
                    else
                    {
                        DrvFree (pCall);
                    }
                }
                else
                {
                }

                DereferenceObject (ghHandleTable, pMsg->hDevice, 1);

                break;
            }
#if DBG
            default:

                LOG((TL_ERROR,
                    "EventHandlerThread: unknown msg=x%x, hDev=x%x, p1=x%x",
                    pMsg->Msg,
                    pMsg->hDevice,
                    pMsg->Param1
                    ));

                break;
#endif
            } // switch (pMsg->dwMsg)

            DereferenceObject (ghHandleTable, pMsg->InitContext, 1);

        } // while ((pMsg = GetEventFromQueue()))

    } // while (1)


    if (gEventHandlerThreadParams.hMailslot != INVALID_HANDLE_VALUE)
    {
        CancelIo (gEventHandlerThreadParams.hMailslot);
    }

#if MEMPHIS
#else
    ClearImpersonationToken();
    RevertImpersonation();
    CloseHandle(hProcess);
#endif

    LOG((TL_INFO, "EventHandlerThread: exit"));

    ExitThread (0);
}


PDRVLINE
GetLineFromID(
    DWORD   dwDeviceID
    )
{
    PDRVLINE    pLine;

    //
    // First check to see if it's a valid device ID.
    //
    if (dwDeviceID < gdwLineDeviceIDBase || gpLineLookup == NULL)
    {
        return NULL;
    }

    TapiEnterCriticalSection(&gCriticalSection);

    //
    // First check to see if it's a "static" device, i.e. a device
    // that we knew about at start up time, in which case we know
    // it's exact location in the lookup table
    //
    if (dwDeviceID < (gdwLineDeviceIDBase + gdwInitialNumLineDevices))
    {
        pLine = gpLineLookup->aEntries + dwDeviceID - gdwLineDeviceIDBase;
    }

    //
    // If here, the id references a "dynamic" device, i.e. one that
    // we found out about on the fly via a CREATE msg, so we need to
    // walk the lookup table(s) to find it
    //
    // TODO: the while loops down below are not efficient at all
    //

    else
    {
        PDRVLINELOOKUP  pLookup = gpLineLookup;
        DWORD i;


        pLine = NULL;

        while (pLookup)
        {
            i = 0;
            while (i != pLookup->dwUsedEntries &&
                   pLookup->aEntries[i].dwDeviceIDLocal != dwDeviceID)
            {
                i++;
            }

            if (i < pLookup->dwUsedEntries)
            {
                pLine = &(pLookup->aEntries[i]);
                break;
            }

            pLookup = pLookup->pNext;
        }
    }

    TapiLeaveCriticalSection(&gCriticalSection);
    return pLine;
}


PDRVPHONE
GetPhoneFromID(
    DWORD   dwDeviceID
    )
{
    PDRVPHONE   pPhone;

    //
    // First check to see if it's a valid device ID.
    //
    if (dwDeviceID < gdwPhoneDeviceIDBase || gpPhoneLookup == NULL)
    {
        return NULL;
    }

    TapiEnterCriticalSection(&gCriticalSection);

    //
    // Then check to see if it's a "static" device, i.e. a device
    // that we knew about at start up time, in which case we know
    // it's exact location in the lookup table
    //
    if (dwDeviceID < (gdwPhoneDeviceIDBase + gdwInitialNumPhoneDevices))
    {
        pPhone = gpPhoneLookup->aEntries + dwDeviceID - gdwPhoneDeviceIDBase;
    }


    //
    // If here, the id references a "dynamic" device, i.e. one that
    // we found out about on the fly via a CREATE msg, so we need to
    // walk the lookup table(s) to find it
    //
    // TODO: the while loops down below are not efficient at all
    //

    else
    {
        PDRVPHONELOOKUP pLookup = gpPhoneLookup;
        DWORD i;


        pPhone = NULL;

        while (pLookup)
        {
            i = 0;

            while (i != pLookup->dwUsedEntries &&
                   pLookup->aEntries[i].dwDeviceIDLocal != dwDeviceID)
            {
                i++;
            }

            if (i < pLookup->dwUsedEntries)
            {
                pPhone = &(pLookup->aEntries[i]);
                break;
            }

            pLookup = pLookup->pNext;
        }
    }

    TapiLeaveCriticalSection(&gCriticalSection);
    return pPhone;
}


BOOL
WINAPI
GrowBuf(
    LPBYTE *ppBuf,
    LPDWORD pdwBufSize,
    DWORD   dwCurrValidBytes,
    DWORD   dwBytesToAdd
    )
{
    DWORD   dwCurrBufSize, dwNewBufSize;
    LPBYTE  pNewBuf;


    //
    // Try to get a new buffer big enough to hold everything
    //

    for(
        dwNewBufSize = 2 * (dwCurrBufSize = *pdwBufSize);
        dwNewBufSize < (dwCurrBufSize + dwBytesToAdd);
        dwNewBufSize *= 2
        );

    if (!(pNewBuf = DrvAlloc (dwNewBufSize)))
    {
        return FALSE;
    }


    //
    // Copy the "valid" bytes in the old buf to the new buf,
    // then free the old buf
    //

    CopyMemory (pNewBuf, *ppBuf, dwCurrValidBytes);

    DrvFree (*ppBuf);


    //
    // Reset the pointers to the new buf & buf size
    //

    *ppBuf = pNewBuf;
    *pdwBufSize = dwNewBufSize;

    return TRUE;
}


PRSP_THREAD_INFO
WINAPI
GetTls(
    void
    )
{
    PRSP_THREAD_INFO    pClientThreadInfo;


    if (!(pClientThreadInfo = TlsGetValue (gdwTlsIndex)))
    {
        pClientThreadInfo = (PRSP_THREAD_INFO)
            DrvAlloc (sizeof(RSP_THREAD_INFO));

        if (!pClientThreadInfo)
        {
            return NULL;
        }

        pClientThreadInfo->pBuf = DrvAlloc (INITIAL_CLIENT_THREAD_BUF_SIZE);

        if (!pClientThreadInfo->pBuf)
        {
            DrvFree (pClientThreadInfo);

            return NULL;
        }

        pClientThreadInfo->dwBufSize = INITIAL_CLIENT_THREAD_BUF_SIZE;

        EnterCriticalSection (&gcsTlsList);

        InsertHeadList (&gTlsListHead, &pClientThreadInfo->TlsList);

        LeaveCriticalSection (&gcsTlsList);

        TlsSetValue (gdwTlsIndex, (LPVOID) pClientThreadInfo);
    }

    return pClientThreadInfo;
}


#if DBG

LONG
WINAPI
RemoteDoFunc(
    PREMOTE_FUNC_ARGS   pFuncArgs,
    char               *pszFuncName
    )

#else

LONG
WINAPI
RemoteDoFunc(
    PREMOTE_FUNC_ARGS   pFuncArgs
    )

#endif
{
    LONG    lResult;
    BOOL    bCopyOnSuccess = FALSE, bRpcImpersonate, bNeedToReInit = FALSE;
    DWORD   i, j, dwUsedSize, dwNeededSize;
    DWORD   dwFuncClassErrorIndex = (pFuncArgs->Flags & 0x00000030) >> 4;
    DWORD   requestID;
    ULONG_PTR           value;
    PDRVSERVER          pServer = NULL;
    PRSP_THREAD_INFO    pTls;


    //
    // Get the tls
    //

    if (!(pTls = GetTls()))
    {
        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
        goto RemoteDoFunc_return;
    }


    //
    // Validate all the func args
    //

    dwNeededSize = dwUsedSize = sizeof (TAPI32_MSG);

    for (i = 0, j = 0; i < (pFuncArgs->Flags & NUM_ARGS_MASK); i++, j++)
    {
        value = pFuncArgs->Args[i];

        switch (pFuncArgs->ArgTypes[i])
        {
        case lpContext:
            // do nothing
            continue;

        case Dword:

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST_HINT(pFuncArgs->Args[i],__FILE__,__LINE__,i);
            continue;

        case LineID:
        {
            PDRVLINE    pLine = GetLineFromID ((DWORD) value);

            try
            {
                pServer = pLine->pServer;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                lResult = LINEERR_BADDEVICEID;
                goto RemoteDoFunc_return;
            }

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pLine->dwDeviceIDServer;

            continue;
        }
        case PhoneID:
        {
            PDRVPHONE   pPhone = GetPhoneFromID ((DWORD) value);

            try
            {
                pServer = pPhone->pServer;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                lResult = PHONEERR_BADDEVICEID;
                goto RemoteDoFunc_return;
            }

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pPhone->dwDeviceIDServer;

            continue;
        }
        case Hdcall:

            //
            // Save the pServer & adjust the call handle as understood by
            // the server
            //

            try
            {
                pServer = ((PDRVCALL) value)->pServer;

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = ((PDRVCALL) value)->hCall;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                lResult = LINEERR_INVALCALLHANDLE;
                goto RemoteDoFunc_return;
            }

            continue;

        case Hdline:

            //
            // Save the pServer & adjust the line handle as understood by
            // the server.  There's no need to wrap this in a try/except
            // since the object pointed at by the pLine is static, whether
            // or not the device is actually open.
            //

            pServer = ((PDRVLINE) value)->pServer;

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = ((PDRVLINE) value)->hLine;

            continue;

        case Hdphone:

            //
            // Save the pServer & adjust the phone handle as understood by
            // the server.  There's no need to wrap this in a try/except
            // since the object pointed at by the pLine is static, whether
            // or not the device is actually open.
            //

            pServer = ((PDRVPHONE) value)->pServer;

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = ((PDRVPHONE) value)->hPhone;

            continue;

        case lpDword:

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;

            bCopyOnSuccess = TRUE;

            continue;

        case lpsz:

            //
            // Check if value is a valid string ptr and if so
            // copy the contents of the string to the extra data
            // buffer passed to the server, else indicate no data
            //

            if (value)
            {
                DWORD   n = (lstrlenW ((WCHAR *) value) + 1) *
                            sizeof (WCHAR),
                        nAligned = (n + 3) & 0xfffffffc;


                if ((nAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            nAligned
                            ))
                    {
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto RemoteDoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, n);


                //
                // Pass the server the offset of the string in the var data
                // portion of the buffer
                //

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);


                //
                // Increment the total number of data bytes
                //

                dwUsedSize   += nAligned;
                dwNeededSize += nAligned;
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
            }

            continue;


        case lpGet_Struct:
        case lpGet_CallParamsStruct:
        case lpGet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpGet_SizeToFollow);
            DWORD dwSize;


            if (bSizeToFollow)
            {
#if DBG
                //
                // Check to make sure the following arg is of type Size
                //

                if ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                    (pFuncArgs->ArgTypes[i + 1] != Size))
                {
                    LOG((TL_ERROR,
                        "DoFunc: error, lpGet_SizeToFollow !followed by Size"
                        ));

                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    goto RemoteDoFunc_return;
                }
#endif
                dwSize = DWORD_CAST_HINT(pFuncArgs->Args[i + 1],__FILE__,__LINE__,i);
            }
            else
            {
                dwSize = *((LPDWORD) value); // lpXxx->dwTotalSize
            }

            if (bSizeToFollow)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
                ++j;++i;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST_HINT(pFuncArgs->Args[i],__FILE__,__LINE__,i);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = dwSize;
            }


            //
            // Now set the bCopyOnSuccess flag to indicate that we've data
            // to copy back on successful completion, and add to the
            // dwNeededSize field
            //

            bCopyOnSuccess = TRUE;

            dwNeededSize += dwSize;

            continue;
        }

        case lpSet_Struct:
        case lpSet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpSet_SizeToFollow);
            DWORD dwSize, dwSizeAligned;

#if DBG
            //
            // Check to make sure the following arg is of type Size
            //

            if (bSizeToFollow &&
                ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                (pFuncArgs->ArgTypes[i + 1] != Size)))
            {
                LOG((TL_ERROR,
                    "DoFunc: error, lpSet_SizeToFollow !followed by Size"
                    ));

                lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                goto RemoteDoFunc_return;
            }
#endif
            if (bSizeToFollow)
            {
                dwSize = (value ? DWORD_CAST_HINT(pFuncArgs->Args[i + 1],__FILE__,__LINE__,i) : 0);
            }
            else
            {
                dwSize = (value ? *((LPDWORD) value) : 0);
            }

            if (dwSize)
            {
                //
                // Grow the buffer if necessary, & do the copy
                //

                dwSizeAligned = (dwSize + 3) & 0xfffffffc;

                if ((dwSizeAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            dwSizeAligned
                            ))
                    {
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto RemoteDoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, dwSize);
            }
            else
            {
                dwSizeAligned = 0;
            }


            //
            // Pass the server the offset of the data in the var data
            // portion of the buffer
            //

            if (dwSize)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
            }


            //
            // Increment the dwXxxSize vars appropriately
            //

            dwUsedSize   += dwSizeAligned;
            dwNeededSize += dwSizeAligned;


            //
            // Since we already know the next arg (Size) just handle
            // it here so we don't have to run thru the loop again
            //

            if (bSizeToFollow)
            {
                ++j;++i;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST_HINT(pFuncArgs->Args[i],__FILE__,__LINE__,i);
            }

            continue;
        }

        case lpServer:

            pServer = (PDRVSERVER) value;
            --j;

            continue;

#if DBG
        case Size:

            LOG((TL_ERROR, "DoFunc: error, hit case Size"));

            continue;

        default:

            LOG((TL_ERROR, "DoFunc: error, unknown arg type"));

            continue;
#endif
        } // switch

    } // for


    //
    // Verify if the target server is valid & in a good state
    //

    if (IsValidObject ((PVOID) pServer, gdwDrvServerKey))
    {
        if (SERVER_REINIT & pServer->dwFlags)
        {
            LOG((TL_ERROR, "pServer says REINIT in RemoteDoFunc"));
            lResult = gaServerReInitErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }

        if (SERVER_DISCONNECTED & pServer->dwFlags)
        {
            LOG((TL_ERROR, "pServer is disconnected in RemoteDoFunc"));
            lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }
    }
    else
    {
        lResult = (pServer ?
            gaOpFailedErrors[dwFuncClassErrorIndex] :
            gaServerDisconnectedErrors[dwFuncClassErrorIndex]);
        goto RemoteDoFunc_return;
    }


    //
    // Now make the request
    //

    if (dwNeededSize > pTls->dwBufSize)
    {
        if (!GrowBuf(
                &pTls->pBuf,
                &pTls->dwBufSize,
                dwUsedSize,
                dwNeededSize - pTls->dwBufSize
                ))
        {
            lResult = gaNoMemErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }
    }

    ((PTAPI32_MSG) pTls->pBuf)->u.Req_Func = (DWORD)HIWORD(pFuncArgs->Flags);


    //
    // If this is an async request then add it to our "handle" table &
    // used the returned value for the request id passed to the server.
    //
    // TODO: would be faster to do this before the loop above so could
    //       bypass 1 or 2 loop iterations
    //

    if (pFuncArgs->Flags & ASYNC)
    {
        PASYNCREQUESTCONTEXT    pContext;


        if (pFuncArgs->Flags & INCL_CONTEXT)
        {
            pContext = (PASYNCREQUESTCONTEXT) pFuncArgs->Args[1];
            pContext->dwKey = DRVASYNC_KEY;
            ((PTAPI32_MSG) pTls->pBuf)->Params[1] = 0;
        }
        else
        {
            pContext = (PASYNCREQUESTCONTEXT) -1;
        }

        requestID =
        ((PTAPI32_MSG) pTls->pBuf)->Params[0] = NewObject(
            ghHandleTable,
            pContext,
            (LPVOID) pFuncArgs->Args[0]     // the original request id
            );

        if (!requestID)
        {
            lResult = gaNoMemErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }
    }


    //
    // Impersonate the client.  In some cases impersonation
    // will fail, mostly likely because we're being called
    // by a worker thread in tapisrv to close a line/call/
    // phone object; what we do in this case is impersonate
    // the logged on user (like the EventHandlerThread does).
    //

    if (!pTls->bAlreadyImpersonated)
    {
#if MEMPHIS
#else
        RPC_STATUS  status;

        status = RpcImpersonateClient(0);

        if (status == RPC_S_OK)
        {
            bRpcImpersonate = TRUE;
        }
        else
        {
            bRpcImpersonate = FALSE;

            LOG((TL_ERROR,
                "RemoteDoFunc: RpcImpersonateClient failed, err=%d",
                status
                ));

            if (!SetProcessImpersonationToken (NULL))
            {
                LOG((TL_ERROR,
                    "RemoteDoFunc: SetProcessImpersToken failed, lastErr=%d",
                    GetLastError()
                    ));

                lResult =  gaOpFailedErrors[dwFuncClassErrorIndex];
                goto RemoteDoFunc_return;
            }
        }
#endif
    }


    {
        DWORD   dwRetryCount = 0;


        do
        {
            //
            // check if the server is shutting down, to avoid making RPC request 
            // with invalid handle
            //
            if (pServer->bShutdown)
            {
                lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
                break;
            }

            RpcTryExcept
            {
                ClientRequest(
                    pServer->phContext,
                    pTls->pBuf,
                    dwNeededSize,
                    &dwUsedSize
                    );

                lResult = (LONG) ((PTAPI32_MSG) pTls->pBuf)->u.Ack_ReturnValue;

                if (lResult == TAPIERR_INVALRPCCONTEXT)
                {
                    OnServerDisconnected (pServer);
                    lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
                }

                break;  // break out of do while
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                if (dwRetryCount++ < gdwRetryCount)
                {
                    Sleep (gdwRetryTimeout);
                }
                else
                {
                    unsigned long ulResult = RpcExceptionCode();


                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];

                    if ((ulResult == RPC_S_SERVER_UNAVAILABLE) ||
                        (ulResult == ERROR_INVALID_HANDLE))
                    {
                        OnServerDisconnected (pServer);
                        lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
                    }

                    break;
                }
            }
            RpcEndExcept

        } while (TRUE); //while (dwRetryCount < gdwRetryCount);
    }

    if (!pTls->bAlreadyImpersonated)
    {
        if (bRpcImpersonate)
        {
            RpcRevertToSelf();
        }
        else
        {
            ClearImpersonationToken();
        }
    }


    //
    // Post-processing for async requests:
    //     SUCCESS - restore the original/local request id for return to tapi
    //     ERROR   - dereference the new/remote request id to free it
    //

    if ((pFuncArgs->Flags & ASYNC))
    {
        if (lResult == (LONG)requestID)
        {
            lResult = (LONG) pFuncArgs->Args[0];
        }
        else // error
        {
            DereferenceObject (ghHandleTable, requestID, 1);
        }
    }


    //
    // Check if server returned REINIT (it's EventNotificationThread
    // timed out on an rpc request so it thinks we're toast)
    //

    if (lResult == LINEERR_REINIT)
    {
        LOG((TL_ERROR, "server returned REINIT in RemoteDoFunc"));

        OnServerDisconnected (pServer);
        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
        goto RemoteDoFunc_return;
    }


    //
    // If request completed successfully and the bCopyOnSuccess flag
    // is set then we need to copy data back to client buffer(s)
    //

    if ((lResult == TAPI_SUCCESS) && bCopyOnSuccess)
    {
        for (i = 0, j = 0; i < (pFuncArgs->Flags & NUM_ARGS_MASK); i++, j++)
        {
            PTAPI32_MSG pMsg = (PTAPI32_MSG) pTls->pBuf;


            switch (pFuncArgs->ArgTypes[i])
            {
            case Dword:
            case LineID:
            case PhoneID:
            case Hdcall:
            case Hdline:
            case Hdphone:
            case lpsz:
            case lpSet_Struct:

                continue;

            case lpServer:
            
                --j;
                continue;

            case lpDword:

                //
                // Fill in the pointer with the return value
                //

                *((LPDWORD) pFuncArgs->Args[i]) = pMsg->Params[j];

                continue;

            case lpGet_SizeToFollow:

                //
                // Fill in the buf with the return data
                //

                CopyMemory(
                    (LPBYTE) pFuncArgs->Args[i],
                    pTls->pBuf + pMsg->Params[j] + sizeof(TAPI32_MSG),
                    pMsg->Params[j+1]
                    );


                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpSet_SizeToFollow:

                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpGet_Struct:

                //
                // Params[j] contains the offset in the var data
                // portion of pTls->pBuf of some TAPI struct.
                // Get the dwUsedSize value from this struct &
                // copy that many bytes from pTls->pBuf to client buf
                //

                if (pMsg->Params[j] != TAPI_NO_DATA)
                {

                    LPDWORD pStruct;


                    pStruct = (LPDWORD) (pTls->pBuf + sizeof(TAPI32_MSG) +
                        pMsg->Params[j]);

                    CopyMemory(
                        (LPBYTE) pFuncArgs->Args[i],
                        (LPBYTE) pStruct,
                        *(pStruct + 2)      // ptr to dwUsedSize field
                        );
                }

                continue;

            case lpGet_CallParamsStruct:

                //
                // Params[j] contains the offset in the var data
                // portion of pTls->pBuf of some TAPI struct.
                // Get the dwUsedSize value from this struct &
                // copy that many bytes from pTls->pBuf to client buf
                //

                if (pMsg->Params[j] != TAPI_NO_DATA)
                {

                    LPDWORD pStruct;


                    pStruct = (LPDWORD) (pTls->pBuf + sizeof(TAPI32_MSG) +
                        pMsg->Params[j]);

                    CopyMemory(
                        (LPBYTE) pFuncArgs->Args[i],
                        (LPBYTE) pStruct,
                        *(pStruct) // callparams has no dwusedsize
                        );
                }

                continue;

            default:

                continue;
            }
        }
    }

RemoteDoFunc_return:
#if DBG
    LOG((TL_INFO, "%s: exit, returning x%x", pszFuncName, lResult));
#endif

    if (bNeedToReInit)
    {
        ASYNCEVENTMSG   msg;


        LOG((TL_INFO,
            "Telephony server is no longer available. " \
                "Sending REINIT message to TAPI"
            ));

        msg.TotalSize = sizeof(msg);
        msg.InitContext = pServer->InitContext;
        msg.fnPostProcessProcHandle = 0;
        msg.hDevice = 0;
        msg.Msg = LINE_LINEDEVSTATE;
        msg.OpenContext = 0;
        msg.Param1 = LINEDEVSTATE_REINIT;
        msg.Param2 = RSP_MSG;
        msg.Param3 = 0;
        msg.Param4 = 0;

        RemoteSPEventProc (NULL, (unsigned char *)&msg, sizeof(msg));
    }

    return lResult;
}


//
// --------------------------- TAPI_lineXxx funcs -----------------------------
//

LONG
TSPIAPI
TSPI_lineAccept(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpsUserUserInfo,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lAccept),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineAccept"));
}


LONG
TSPIAPI
TSPI_lineAddToConference(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdConfCall,
    HDRVCALL        hdConsultCall
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        Hdcall
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdConfCall,
        (ULONG_PTR) hdConsultCall
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lAddToConference),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineAddToConference"));
}


void
PASCAL
TSPI_lineGetAgentxxx_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    )
{
    LOG((TL_INFO, "lineGetAgentxxx_PostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = (DWORD) pMsg->Param4;
        LPBYTE  pParams = (LPBYTE) pContext->Params[0];


        CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
    }
}


void
PASCAL
TSPI_lineDevSpecific_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    );


LONG
TSPIAPI
TSPI_lineAgentSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    DWORD           dwAgentExtensionIDIndex,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) dwAgentExtensionIDIndex,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpParams,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 8, lAgentSpecific),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineDevSpecific_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpParams;
    pContext->Params[1] = dwSize;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lAgentSpecific"));
}


LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpsUserUserInfo,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lAnswer),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineAnswer"));
}


LONG
TSPIAPI
TSPI_lineBlindTransfer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpsz,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpszDestAddress,
        (ULONG_PTR) dwCountryCode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lBlindTransfer),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineBlindTransfer"));
}


LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
    )
{
    //
    // Check if the hLine is still valid (could have been zeroed
    // out on LINE_CLOSE, so no need to call server)
    //

    if (((PDRVLINE) hdLine)->hLine)
    {
        static REMOTE_ARG_TYPES argTypes[] =
        {
            Hdline
        };
        REMOTE_FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 1, lClose),
            (ULONG_PTR *) &hdLine,
            argTypes
        };


        DereferenceObject(
            ghHandleTable,
            ((PDRVLINE) hdLine)->hDeviceCallback,
            1
            );

        EnterCriticalSection (&gCallListCriticalSection);

        ((PDRVLINE) hdLine)->htLine = 0;
        ((PDRVLINE) hdLine)->hDeviceCallback = 0;

        LeaveCriticalSection (&gCallListCriticalSection);

        REMOTEDOFUNC (&funcArgs, "lineClose");
    }

    //assert (((PDRVLINE) hdLine)->pCalls == NULL);

    return 0;
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
    )
{
    PDRVCALL    pCall = (PDRVCALL) hdCall;
    HTAPICALL   htCall;

    //
    // Check if the hCall is still valid (could have been zeroed
    // out on LINE_CLOSE, so no need to call server)
    //

    LOG((TL_INFO, "TSPI_lineCloseCall - pCall x%lx", hdCall));

    EnterCriticalSection (&gCallListCriticalSection);

    if (IsValidObject (pCall, DRVCALL_KEY))
    {
        htCall = pCall->htCall;
    }
    else
    {
        htCall = 0;
    }

    LeaveCriticalSection (&gCallListCriticalSection);

    if (htCall)
    {
        static REMOTE_ARG_TYPES argTypes[] =
        {
            Hdcall
        };
        REMOTE_FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 1, lDeallocateCall),   // API differs
            (ULONG_PTR *) &hdCall,
            argTypes
        };

        REMOTEDOFUNC (&funcArgs, "lineCloseCall");

        EnterCriticalSection (&gCallListCriticalSection);
        RemoveCallFromList (pCall);
        LeaveCriticalSection (&gCallListCriticalSection);
    }

    return 0;
}


void
PASCAL
TSPI_lineCompleteCall_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    )
{
    LOG((TL_INFO, "lineCompleteCall PostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        LPDWORD lpdwCompletionID = (LPDWORD) pContext->Params[0];


        *lpdwCompletionID = (DWORD) pMsg->Param3;
    }
}


LONG
TSPIAPI
TSPI_lineCompleteCall(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPDWORD         lpdwCompletionID,
    DWORD           dwCompletionMode,
    DWORD           dwMessageID
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdcall,
        Dword,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) 0,
        (ULONG_PTR) dwCompletionMode,
        (ULONG_PTR) dwMessageID
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lCompleteCall),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineCompleteCall_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpdwCompletionID;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lineCompleteCall"));
}


LONG
TSPIAPI
TSPI_lineCompleteTransfer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    HDRVCALL        hdConsultCall,
    HTAPICALL       htConfCall,
    LPHDRVCALL      lphdConfCall,
    DWORD           dwTransferMode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdcall,
        Hdcall,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) hdConsultCall,
        (ULONG_PTR) 0,
        (ULONG_PTR) dwTransferMode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lCompleteTransfer),
        args,
        argTypes
    };
    LONG        lResult;
    PDRVCALL    pConfCall;


    if (dwTransferMode == LINETRANSFERMODE_CONFERENCE)
    {
        PASYNCREQUESTCONTEXT pContext;


        if (!(pConfCall = DrvAlloc (sizeof (DRVCALL))))
        {
            return LINEERR_NOMEM;
        }

        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            DrvFree (pConfCall);
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_lineMakeCall_PostProcess;
        pContext->Params[0] = (ULONG_PTR) pConfCall;

        args[1] = (ULONG_PTR) pContext;
		argTypes[1] = lpContext;

        funcArgs.Flags |= INCL_CONTEXT;


        //
        // Assume success & add the call to the line's list before we
        // even make the request.  This makes cleanup alot easier if
        // the server goes down or some such uncooth event.
        //

        pConfCall->dwOriginalRequestID = dwRequestID;

        pConfCall->htCall = htConfCall;

        pConfCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

        AddCallToList ((PDRVLINE) ((PDRVCALL) hdCall)->pLine, pConfCall);

        *lphdConfCall = (HDRVCALL) pConfCall;
    }
    else
    {
        pConfCall = NULL;
    }

    if ((lResult = REMOTEDOFUNC (&funcArgs, "lineCompleteTransfer")) < 0)
    {
        if (pConfCall)
        {
            RemoveCallFromList (pConfCall);
        }
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        Dword,
        lpSet_Struct,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwMediaModes,
        (ULONG_PTR) lpCallParams,
        (ULONG_PTR) 0xFFFFFFFF
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lConditionalMediaDetection),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineConditionalMediaDetection"));

}


void
PASCAL
TSPI_lineDevSpecific_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    )
{
    LOG((TL_INFO, "lineDevSpecificPostProcess: enter"));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = (DWORD) pContext->Params[1];
        LPBYTE  pParams = (LPBYTE) pContext->Params[0];


        CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
    }
}


LONG
TSPIAPI
TSPI_lineCreateAgent(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    LPWSTR         lpszAgentID,
    LPWSTR         lpszAgentPIN,
    LPHAGENT       lphAgent
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        lpszAgentID?lpsz:Dword,
        lpszAgentPIN?lpsz:Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) lpszAgentID,
        (ULONG_PTR) lpszAgentPIN,
        (ULONG_PTR) 0
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lCreateAgent),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lphAgent;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    if ( lpszAgentID == NULL )
    {
        funcArgs.Args[3] = TAPI_NO_DATA;
        funcArgs.ArgTypes[3] = Dword;
    }

    if ( lpszAgentPIN == NULL)
    {
        funcArgs.Args[4] = TAPI_NO_DATA;
        funcArgs.ArgTypes[4] = Dword;
    }

    return (REMOTEDOFUNC (&funcArgs, "lCreateAgent"));
        
}


LONG
TSPIAPI
TSPI_lineCreateAgentSession(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HAGENT              hAgent,
    LPWSTR              lpszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        lpszAgentPIN ? lpsz : Dword,
        Dword,
        lpSet_SizeToFollow,
        Size,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) hAgent,
        (ULONG_PTR) lpszAgentPIN,
        (ULONG_PTR) dwWorkingAddressID,
        (ULONG_PTR) lpGroupID,
        (ULONG_PTR) sizeof(GUID),
        (ULONG_PTR) 0
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 9, lCreateAgentSession),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lphAgentSession;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    if ( lpszAgentPIN == NULL )
    {
        funcArgs.Args[4] = TAPI_NO_DATA;
        funcArgs.ArgTypes[4] = Dword;
    }

    return (REMOTEDOFUNC (&funcArgs, "lCreateAgentSession"));
        
}


LONG
TSPIAPI
TSPI_lineDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HDRVCALL        hdCall,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        (hdCall ? Hdcall : Dword ),
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpParams,   // pass data
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 8, lDevSpecific),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineDevSpecific_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpParams;
    pContext->Params[1] = dwSize;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lineDevSpecific"));
}


LONG
TSPIAPI
TSPI_lineDevSpecificFeature(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwFeature,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwFeature,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpParams,   // pass data
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 7, lDevSpecificFeature),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineDevSpecific_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpParams;
    pContext->Params[1] = dwSize;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lineDevSpecificFeature"));
}


LONG
TSPIAPI
TSPI_lineDial(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpsz,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpszDestAddress,
        (ULONG_PTR) dwCountryCode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lDial),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineDial"));
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpsUserUserInfo,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lDrop),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineDrop"));
}


LONG
TSPIAPI
TSPI_lineForward(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{

    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpSet_Struct,
        Dword,
        Dword,
        lpSet_Struct,
        Dword
    };
    PDRVCALL pCall = DrvAlloc (sizeof (DRVCALL));
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) bAllAddresses,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) lpForwardList,
        (ULONG_PTR) dwNumRingsNoAnswer,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpCallParams,
        (ULONG_PTR) 0xFFFFFFFF

    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 10, lForward),
        args,
        argTypes
    };
    LONG lResult;


    if (pCall)
    {
        PASYNCREQUESTCONTEXT pContext;


        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            DrvFree (pCall);
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_lineMakeCall_PostProcess;
        pContext->Params[0] = (ULONG_PTR) pCall;
        pContext->Params[1] = (ULONG_PTR) lphdConsultCall;
            // save the ptr in case we need to NULL-ify later

        args[1] = (ULONG_PTR) pContext;
		argTypes[1] = lpContext;

        pCall->htCall = htConsultCall;
        pCall->dwOriginalRequestID = dwRequestID;

        pCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

        AddCallToList ((PDRVLINE) hdLine, pCall);

        *lphdConsultCall = (HDRVCALL) pCall;

        if ((lResult = REMOTEDOFUNC (&funcArgs, "lineForward")) < 0)
        {
            RemoveCallFromList (pCall);
        }
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return lResult;

}


void
PASCAL
TSPI_lineGatherDigits_PostProcess(
    PASYNCEVENTMSG          pMsg
    )
{
    DWORD                   dwEndToEndIDRemoteSP = ((DWORD *)(pMsg + 1))[0];
    PASYNCREQUESTCONTEXT    pContext;


    LOG((TL_INFO, "TSPI_lineGatherDigits_PostProcess: enter"));

    if ((pContext = ReferenceObject(
            ghHandleTable,
            dwEndToEndIDRemoteSP,
            0
            )))
    {
        if (pMsg->Param1 &
                (LINEGATHERTERM_BUFFERFULL | LINEGATHERTERM_CANCEL |
                 LINEGATHERTERM_TERMDIGIT | LINEGATHERTERM_INTERTIMEOUT))
        {
            LPSTR   lpsDigits = (LPSTR) pContext->Params[0];
            DWORD   dwNumDigits = (DWORD) pMsg->Param4;
            LPCWSTR pBuffer = (LPCWSTR) ( ( (DWORD *) (pMsg + 1) ) + 2);


            try
            {
                CopyMemory (lpsDigits, pBuffer, dwNumDigits * sizeof(WCHAR));
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
            }
        }

        pMsg->Param2 = DWORD_CAST(pContext->Params[1],__FILE__,__LINE__);

        DereferenceObject (ghHandleTable, dwEndToEndIDRemoteSP, 2);
    }
    else
    {
        pMsg->Param2 = 0;
    }
}


LONG
TSPIAPI
TSPI_lineGatherDigits(
    HDRVCALL    hdCall,
    DWORD       dwEndToEndID,
    DWORD       dwDigitModes,
    LPWSTR      lpsDigits,
    DWORD       dwNumDigits,
    LPCWSTR     lpszTerminationDigits,
    DWORD       dwFirstDigitTimeout,
    DWORD       dwInterDigitTimeout
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        Dword,
        Dword,
        Dword,
        Dword,
        lpsz,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) 0,              // dwEndToEndID,
        (ULONG_PTR) dwDigitModes,
        (ULONG_PTR) 0,              // lpsDigits,
        (ULONG_PTR) dwNumDigits,
        (ULONG_PTR) lpszTerminationDigits,
        (ULONG_PTR) dwFirstDigitTimeout,
        (ULONG_PTR) dwInterDigitTimeout
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 9, lGatherDigits),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT    pContext;


    if (lpsDigits)
    {
        if (IsBadWritePtr (lpsDigits, dwNumDigits * sizeof(WCHAR)))
        {
            return LINEERR_INVALPOINTER;
        }

        if (!(pContext = DrvAlloc (sizeof(*pContext))))
        {
            return LINEERR_NOMEM;
        }

        pContext->Params[0] = (ULONG_PTR) lpsDigits;
        pContext->Params[1] = dwEndToEndID;

        if (!(args[2] = NewObject (ghHandleTable, pContext, NULL)))
        {
            DrvFree (pContext);
            return LINEERR_NOMEM;
        }

        args[4] = 1;    // Set the lpsDigits param to something non-zero
    }

    if (lpszTerminationDigits == (LPCWSTR) NULL)
    {
        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = TAPI_NO_DATA;
    }

    return (REMOTEDOFUNC (&funcArgs, "lineGatherDigits"));
}


LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL    hdCall,
    DWORD       dwEndToEndID,
    DWORD       dwDigitMode,
    LPCWSTR     lpszDigits,
    DWORD       dwDuration
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        Dword,
        lpsz,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwDigitMode,
        (ULONG_PTR) lpszDigits,
        (ULONG_PTR) dwDuration,
        (ULONG_PTR) dwEndToEndID,
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGenerateDigits),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineGenerateDigits"));
}


LONG
TSPIAPI
TSPI_lineGenerateTone(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        Dword,
        Dword,
        Dword,
        Dword,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwToneMode,
        (ULONG_PTR) dwDuration,
        (ULONG_PTR) dwNumTones,
        (ULONG_PTR) TAPI_NO_DATA,
        (ULONG_PTR) 0,
        (ULONG_PTR) dwEndToEndID
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGenerateTone),
        args,
        argTypes
    };


    if (dwToneMode == LINETONEMODE_CUSTOM)
    {
        argTypes[4] = lpSet_SizeToFollow;
        args[4]     = (ULONG_PTR) lpTones;
        argTypes[5] = Size;
        args[5]     = dwNumTones * sizeof(LINEGENERATETONE);
    }

    return (REMOTEDOFUNC (&funcArgs, "lineGenerateTone"));
}


LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        LineID,
        Dword,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) dwTSPIVersion,
        (ULONG_PTR) dwExtVersion,
        (ULONG_PTR) lpAddressCaps,
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetAddressCaps),
        args,
        argTypes
    };
    PDRVLINE pLine = GetLineFromID (dwDeviceID);

    if (NULL == pLine)
    {
        return LINEERR_BADDEVICEID;
    }

    args[0] = pLine->pServer->hLineApp;


    return (REMOTEDOFUNC (&funcArgs, "lineGetAddressCaps"));
}


LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE    hdLine,
    LPDWORD     lpdwAddressID,
    DWORD       dwAddressMode,
    LPCWSTR     lpsAddress,
    DWORD       dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        lpDword,
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) lpdwAddressID,
        (ULONG_PTR) dwAddressMode,
        (ULONG_PTR) lpsAddress,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetAddressID),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineGetAddressID"));
}


LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) lpAddressStatus
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetAddressStatus),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineGetAddressStatus"));
}


LONG
TSPIAPI
TSPI_lineGetAgentActivityList(
    DRV_REQUESTID dwRequestID,
    HDRVLINE      hdLine,
    DWORD         dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentActivityList
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lGetAgentActivityList),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentActivityList;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetAgentActivityList"));

}


LONG
TSPIAPI
TSPI_lineGetAgentCaps(
    DRV_REQUESTID dwRequestID,
    DWORD         dwDeviceID,
    DWORD         dwAddressID,
    DWORD         dwAppAPIVersion,
    LPLINEAGENTCAPS   lpAgentCaps
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Dword,
        LineID,
        Dword,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) dwAppAPIVersion,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentCaps
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 8, lGetAgentCaps),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;
    PDRVLINE pLine = GetLineFromID (dwDeviceID);

    if (NULL == pLine)
    {
        return LINEERR_BADDEVICEID;
    }

    args[2] = pLine->pServer->hLineApp;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentCaps;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetAgentCaps"));

}


LONG
TSPIAPI
TSPI_lineGetAgentGroupList(
    DRV_REQUESTID dwRequestID,
    HDRVLINE      hdLine,
    DWORD         dwAddressID,
    LPLINEAGENTGROUPLIST     lpAgentGroupList
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentGroupList
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lGetAgentGroupList),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentGroupList;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetAgentGroupList"));

}


LONG
TSPIAPI
TSPI_lineGetAgentInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HAGENT              hAgent,
    LPLINEAGENTINFO     lpAgentInfo
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) hAgent,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lGetAgentInfo),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentInfo;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetAgentInfo"));

}


LONG
TSPIAPI
TSPI_lineGetAgentSessionInfo(
    DRV_REQUESTID     dwRequestID,
    HDRVLINE          hdLine,
    HAGENT            hAgent,
    LPLINEAGENTSESSIONINFO   lpAgentSessionInfo
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) hAgent,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentSessionInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lGetAgentSessionInfo),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentSessionInfo;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetAgentSessionInfo"));
}


LONG
TSPIAPI
TSPI_lineGetAgentSessionList(
    DRV_REQUESTID     dwRequestID,
    HDRVLINE          hdLine,
    HAGENT            hAgent,
    LPLINEAGENTSESSIONLIST   lpAgentSessionList
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) hAgent,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentSessionList
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lGetAgentSessionList),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentSessionList;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetAgentSessionList"));
}


LONG
TSPIAPI
TSPI_lineGetAgentStatus(
    DRV_REQUESTID dwRequestID,
    HDRVLINE      hdLine,
    DWORD         dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentStatus
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lGetAgentStatus),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentStatus;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetAgentStatus"));

}


#if MEMPHIS

LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpdwAddressID
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallAddressID),
        args,
        argTypes
    };

    return (REMOTEDOFUNC (&funcArgs, "lineGetCallAddressID"));
}

#else

LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
    )
{
    LONG lResult = LINEERR_INVALCALLHANDLE;


    try
    {
        *lpdwAddressID     = ((PDRVCALL) hdCall)->dwAddressID;

        if (((PDRVCALL) hdCall)->dwKey == DRVCALL_KEY)
        {
            lResult = 0;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        // do nothing, just fall thru
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_lineGetCallHubTracking(
    HDRVLINE                    hdLine,
    LPLINECALLHUBTRACKINGINFO   lpTrackingInfo
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) lpTrackingInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallHubTracking),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineGetCallHubTracking"));
}


LONG
TSPIAPI
TSPI_lineGetCallIDs(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID,
    LPDWORD     lpdwCallID,
    LPDWORD     lpdwRelatedCallID
    )
{
    LONG        lResult = LINEERR_INVALCALLHANDLE;
    PDRVCALL    pCall = (PDRVCALL) hdCall;
    PDRVSERVER  pServer;


    try
    {
        *lpdwAddressID     = pCall->dwAddressID;
        *lpdwCallID        = pCall->dwCallID;
        *lpdwRelatedCallID = pCall->dwRelatedCallID;

        pServer = pCall->pServer;

        if (pCall->dwKey == DRVCALL_KEY)
        {
            lResult = (pCall->dwDirtyStructs & STRUCTCHANGE_CALLIDS ? 1 : 0);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        // do nothing, just fall thru
    }

    if (lResult == 1)
    {
        if (!pServer->bVer2xServer)
        {
            static REMOTE_ARG_TYPES argTypes[] =
            {
                Hdcall,
                lpDword,
                lpDword,
                lpDword
            };
            ULONG_PTR args[] =
            {
                (ULONG_PTR) hdCall,
                (ULONG_PTR) lpdwAddressID,
                (ULONG_PTR) lpdwCallID,
                (ULONG_PTR) lpdwRelatedCallID
            };
            REMOTE_FUNC_ARGS funcArgs =
            {
                MAKELONG (LINE_FUNC | SYNC | 4, lGetCallIDs),
                args,
                argTypes
            };


            lResult = REMOTEDOFUNC (&funcArgs, "lGetCallIDs");
        }
        else
        {
            LINECALLINFO    callInfo;


            callInfo.dwTotalSize = sizeof (callInfo);

            if ((lResult = TSPI_lineGetCallInfo (hdCall, &callInfo)) == 0)
            {
                *lpdwAddressID     = callInfo.dwAddressID;
                *lpdwCallID        = callInfo.dwCallID;
                *lpdwRelatedCallID = callInfo.dwRelatedCallID;
            }
        }

        if (lResult == 0)
        {
            EnterCriticalSection (&gCallListCriticalSection);

            if (IsValidObject (pCall, DRVCALL_KEY))
            {
                pCall->dwAddressID     = *lpdwAddressID;
                pCall->dwCallID        = *lpdwCallID;
                pCall->dwRelatedCallID = *lpdwRelatedCallID;

                pCall->dwDirtyStructs &= ~STRUCTCHANGE_CALLIDS;
            }

            LeaveCriticalSection (&gCallListCriticalSection);
        }
    }

    return lResult;
}

#endif //MEMPHIS


LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    LONG lResult;
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpCallInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallInfo),
        args,
        argTypes
    };
    PDRVCALL pCall = (PDRVCALL)hdCall;

    //
    // Has the cached structure been invalidated?
    //

    EnterCriticalSection (&gCallListCriticalSection);

    if (!IsValidObject (pCall, DRVCALL_KEY))
    {
        LeaveCriticalSection (&gCallListCriticalSection);
        return LINEERR_INVALCALLHANDLE;
    }

    if ( ( pCall->dwDirtyStructs & STRUCTCHANGE_LINECALLINFO ) ||
         ( pCall->dwCachedCallInfoCount > gdwCacheForceCallCount ) )
    {
       //
       // The cache not valid, get the real info
       //

       LeaveCriticalSection (&gCallListCriticalSection);

       lResult = (REMOTEDOFUNC (&funcArgs, "lineGetCallInfo"));

       //
       // Did the function succeed and was the entire struct returned?
       //
       if (
             (ERROR_SUCCESS == lResult)
           &&
             (lpCallInfo->dwNeededSize <= lpCallInfo->dwTotalSize)
          )
       {
          EnterCriticalSection (&gCallListCriticalSection);

          if (!IsValidObject (pCall, DRVCALL_KEY))
          {
             LeaveCriticalSection (&gCallListCriticalSection);
             return LINEERR_INVALCALLHANDLE;
          }


          //
          // Did we already have a good pointer?
          //
          if ( pCall->pCachedCallInfo )
          {
             DrvFree( pCall->pCachedCallInfo );
          }

          pCall->pCachedCallInfo = DrvAlloc( lpCallInfo->dwUsedSize );

          if ( pCall->pCachedCallInfo )
          {
             //
             // Mark the cache data as clean
             //
             pCall->dwDirtyStructs &= ~STRUCTCHANGE_LINECALLINFO;
             pCall->dwCachedCallInfoCount = 0;

             //
             // Adjust the LineID for the local machine
             //
             lpCallInfo->dwLineDeviceID += gdwLineDeviceIDBase;

             CopyMemory( pCall->pCachedCallInfo,
                         lpCallInfo,
                         lpCallInfo->dwUsedSize
                       );
          }

          LeaveCriticalSection (&gCallListCriticalSection);
       }
    }
    else
    {
       //
       // The cache is valid, return data from there
       //

       if ( lpCallInfo->dwTotalSize >= pCall->pCachedCallInfo->dwUsedSize )
       {
          CopyMemory(
              (PBYTE)&(((PDWORD)lpCallInfo)[1]),
              (PBYTE)&(((PDWORD)(pCall->pCachedCallInfo))[1]),
              pCall->pCachedCallInfo->dwUsedSize - sizeof(DWORD)
              );

       }
       else
       {
          // Copy fixed size starting past the dwTotalSize field
          CopyMemory(
              (PBYTE)&(((PDWORD)lpCallInfo)[3]),
              (PBYTE)&(((PDWORD)(pCall->pCachedCallInfo))[3]),
              lpCallInfo->dwTotalSize - sizeof(DWORD)*3
              );

          lpCallInfo->dwNeededSize = pCall->pCachedCallInfo->dwUsedSize;
          lpCallInfo->dwUsedSize = lpCallInfo->dwTotalSize;


          //
          // Zero the dwXxxSize fields so app won't try to read from them
          // (& so tapi32.dll won't try to convert them from unicode to ascii)
          //

          lpCallInfo->dwCallerIDSize =
          lpCallInfo->dwCallerIDNameSize =
          lpCallInfo->dwCalledIDSize =
          lpCallInfo->dwCalledIDNameSize =
          lpCallInfo->dwConnectedIDSize =
          lpCallInfo->dwConnectedIDNameSize =
          lpCallInfo->dwRedirectionIDSize =
          lpCallInfo->dwRedirectionIDNameSize =
          lpCallInfo->dwRedirectingIDSize =
          lpCallInfo->dwRedirectingIDNameSize =
          lpCallInfo->dwAppNameSize =
          lpCallInfo->dwDisplayableAddressSize =
          lpCallInfo->dwCalledPartySize =
          lpCallInfo->dwCommentSize =
          lpCallInfo->dwDisplaySize =
          lpCallInfo->dwUserUserInfoSize =
          lpCallInfo->dwHighLevelCompSize =
          lpCallInfo->dwLowLevelCompSize =
          lpCallInfo->dwChargingInfoSize =
          lpCallInfo->dwTerminalModesSize =
          lpCallInfo->dwDevSpecificSize = 0;

          if (pCall->pLine->dwXPIVersion >= TAPI_VERSION2_0)
          {
              lpCallInfo->dwCallDataSize =
              lpCallInfo->dwSendingFlowspecSize =
              lpCallInfo->dwReceivingFlowspecSize = 0;
          }
       }

       pCall->dwCachedCallInfoCount++;

       LeaveCriticalSection (&gCallListCriticalSection);

       lResult = 0;

    }

    return( lResult );
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    LONG            lResult=0;
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpCallStatus
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallStatus),
        args,
        argTypes
    };
    PDRVCALL pCall = (PDRVCALL)hdCall;

    //
    // Has the cached structure been invalidated?
    //

    EnterCriticalSection (&gCallListCriticalSection);

    if (!IsValidObject (pCall, DRVCALL_KEY))
    {
        LeaveCriticalSection (&gCallListCriticalSection);
        return LINEERR_INVALCALLHANDLE;
    }

    if ( ( pCall->dwDirtyStructs & STRUCTCHANGE_LINECALLSTATUS ) ||
         ( pCall->dwCachedCallStatusCount > gdwCacheForceCallCount ) )
    {
       //
       // The cache not valid, get the real info
       //

       LeaveCriticalSection (&gCallListCriticalSection);

       lResult = (REMOTEDOFUNC (&funcArgs, "lineGetCallStatus"));

       //
       // Did the function succeed and was the entire struct returned?
       //
       if (
             (ERROR_SUCCESS == lResult)
           &&
             (lpCallStatus->dwNeededSize <= lpCallStatus->dwTotalSize)
          )
       {
          EnterCriticalSection (&gCallListCriticalSection);

          if (!IsValidObject (pCall, DRVCALL_KEY))
          {
             LeaveCriticalSection (&gCallListCriticalSection);
             return LINEERR_INVALCALLHANDLE;
          }


          //
          // Did we already have a good pointer?
          //
          if ( pCall->pCachedCallStatus )
          {
             DrvFree( pCall->pCachedCallStatus );
          }

          pCall->pCachedCallStatus = DrvAlloc( lpCallStatus->dwUsedSize );

          if ( pCall->pCachedCallStatus )
          {
             //
             // Mark the cache data as clean
             //
             pCall->dwDirtyStructs &= ~STRUCTCHANGE_LINECALLSTATUS;

             pCall->dwCachedCallStatusCount = 0;

             CopyMemory( pCall->pCachedCallStatus,
                         lpCallStatus,
                         lpCallStatus->dwUsedSize
                       );
          }

          LeaveCriticalSection (&gCallListCriticalSection);
       }
    }
    else
    {
       //
       // The cache is valid, return data from there
       //

       if ( lpCallStatus->dwTotalSize >= pCall->pCachedCallStatus->dwUsedSize )
       {
          CopyMemory(
              (PBYTE)&(((PDWORD)lpCallStatus)[1]),
              (PBYTE)&(((PDWORD)(pCall->pCachedCallStatus))[1]),
              pCall->pCachedCallStatus->dwUsedSize - sizeof(DWORD)
              );
       }
       else
       {
          // Copy fixed size starting past the dwTotalSize field
          CopyMemory(
              (PBYTE)&(((PDWORD)lpCallStatus)[3]),
              (PBYTE)&(((PDWORD)(pCall->pCachedCallStatus))[3]),
              lpCallStatus->dwTotalSize - sizeof(DWORD)*3
              );

          lpCallStatus->dwNeededSize = pCall->pCachedCallStatus->dwUsedSize;
          lpCallStatus->dwUsedSize = lpCallStatus->dwTotalSize;


          //
          // Zero the dwXxxSize fields so app won't try to read from them
          //

          lpCallStatus->dwDevSpecificSize = 0;
       }

       pCall->dwCachedCallStatusCount++;

       LeaveCriticalSection (&gCallListCriticalSection);

       lResult = 0;
    }

    return( lResult );
}


LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    LONG            lResult;

    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        LineID,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwTSPIVersion,
        (ULONG_PTR) dwExtVersion,
        (ULONG_PTR) lpLineDevCaps
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetDevCaps),
        args,
        argTypes
    };
    PDRVLINE pLine = GetLineFromID (dwDeviceID);

    if (NULL == pLine)
    {
        return LINEERR_BADDEVICEID;
    }

    args[0] = pLine->pServer->hLineApp;


    lResult = REMOTEDOFUNC (&funcArgs, "lineGetDevCaps");

    //
    // We were munging the PermID in the original release of tapi 2.1.
    // The intent was to make sure that we didn't present apps with
    // overlapping id's (both local & remote), but none of our other service
    // providers (i.e. unimdm, kmddsp) use the HIWORD(providerID) /
    // LOWORD(devID) model, so it really doesn't do any good.
    //
    // if (lResult == 0)
    // {
    //     lpLineDevCaps->dwPermanentLineID = MAKELONG(
    //         LOWORD(lpLineDevCaps->dwPermanentLineID),
    //         gdwPermanentProviderID
    //         );
    // }
    //

    return lResult;
}


LONG
TSPIAPI
TSPI_lineGetDevConfig(
    DWORD       dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR     lpszDeviceClass
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        LineID,
        lpGet_Struct,
        lpsz
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) lpDeviceConfig,
        (ULONG_PTR) lpszDeviceClass
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetDevConfig),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineGetDevConfig"));
}


LONG
TSPIAPI
TSPI_lineGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
 PDRVLINE pDrvLine = GetLineFromID (dwDeviceID);

    if (NULL == pDrvLine)
    {
        return LINEERR_BADDEVICEID;
    }

    CopyMemory(
        lpExtensionID,
        &pDrvLine->ExtensionID,
        sizeof (LINEEXTENSIONID)
        );

    return 0;
}


LONG
TSPIAPI
TSPI_lineGetGroupList(
    DRV_REQUESTID           dwRequestID,
    HDRVLINE                hdLine,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpAgentGroupList
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 5, lGetGroupList),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpAgentGroupList;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lineGetGroupList"));

}


LONG
TSPIAPI
TSPI_lineGetIcon(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    *lphIcon = ghLineIcon;

    return 0;
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    //
    // NOTE: Tapisrv will handle the "tapi/line" class
    //
    // NOTE: The "GetNewCalls" class is just for remotesp, & is
    //       special cased below
    //

    LONG    lResult;

    const WCHAR szGetNewCalls[] = L"GetNewCalls";
    const WCHAR szTapiPhone[] = L"tapi/phone";


    //
    // The device ID for wave devices is meaningless on remote machines.
    // Return op. unavailable
    //
    if (lpszDeviceClass &&
        (   !_wcsicmp(lpszDeviceClass, L"wave/in")  ||
            !_wcsicmp(lpszDeviceClass, L"wave/out") ||
            !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
            !_wcsicmp(lpszDeviceClass, L"midi/out") ||
            !_wcsicmp(lpszDeviceClass, L"wave/in/out")
        )
       )
    {
        return LINEERR_OPERATIONUNAVAIL;
    }

    if (lpDeviceID ||   // should be NULL if class == "GetNewCalls"
        lstrcmpiW (lpszDeviceClass, szGetNewCalls))

    {
        REMOTE_ARG_TYPES argTypes[] =
        {
            Dword,
            //(dwSelect == LINECALLSELECT_CALL ? Dword : Hdline),
            Dword,
            Dword,
            //(dwSelect == LINECALLSELECT_CALL ? Hdcall : Dword),
            Dword,
            lpGet_Struct,
            lpsz
        };
        ULONG_PTR args[] =
        {
            (ULONG_PTR) hdLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) lpDeviceID,
            (ULONG_PTR) lpszDeviceClass
        };
        REMOTE_FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 6, lGetID),
            args,
            argTypes
        };


        switch (dwSelect)
        {
        case LINECALLSELECT_CALL:

            argTypes[2] = Hdcall;
            break;

        case LINECALLSELECT_ADDRESS:
        case LINECALLSELECT_LINE:

            argTypes[0] = Hdline;
            break;

       case LINECALLSELECT_DEVICEID:

            break;
        }

        lResult = REMOTEDOFUNC (&funcArgs, "lineGetID");


        //
        // If success  &&  dev class == "tapi/phone"  && there was
        // enough room in the device ID struct for a returned ID,
        // then we need to map the 0-based server ID back to it's
        // corresponding local ID.
        //

        if (lResult == 0  &&
            lstrcmpiW (lpszDeviceClass, szTapiPhone) == 0  &&
            lpDeviceID->dwUsedSize >= (sizeof (*lpDeviceID) + sizeof (DWORD)))
        {
            LPDWORD     pdwPhoneID = (LPDWORD) (((LPBYTE) lpDeviceID) +
                            lpDeviceID->dwStringOffset);
            PDRVPHONE   pPhone;
            PDRVSERVER  pServer = ((PDRVLINE) hdLine)->pServer;


            if ((pPhone = GetPhoneFromID (gdwPhoneDeviceIDBase + *pdwPhoneID)))
            {
                if (pPhone->pServer == pServer  &&
                    pPhone->dwDeviceIDServer == *pdwPhoneID)
                {
                    //
                    // The easy case - a direct mapping between the ID
                    // returned from the server & the index into the
                    // lookup table
                    //

                    *pdwPhoneID = pPhone->dwDeviceIDLocal;
                }
                else
                {
                    //
                    // The hard case - have to walk the lookup table(s)
                    // looking for the matching device.
                    //
                    // We'll take the simplest, though slowest, route
                    // and start at the first entry of the first table.
                    // The good news is that there generally won't be
                    // many devices, and this request won't occur often.
                    //

                    DWORD           i;
                    PDRVPHONELOOKUP pLookup = gpPhoneLookup;


                    while (pLookup)
                    {
                        for (i = 0; i < pLookup->dwUsedEntries; i++)
                        {
                            if (pLookup->aEntries[i].dwDeviceIDServer ==
                                    *pdwPhoneID  &&

                                pLookup->aEntries[i].pServer == pServer)
                            {
                                *pdwPhoneID =
                                    pLookup->aEntries[i].dwDeviceIDLocal;

                                goto TSPI_lineGetID_return;
                            }
                        }

                        pLookup = pLookup->pNext;
                    }


                    //
                    // If here no matching local ID, so fail the request
                    //

                    lResult = LINEERR_OPERATIONFAILED;
                }
            }
            else
            {
                lResult = LINEERR_OPERATIONFAILED;
            }
        }
    }
    else
    {
        //
        // An app has done lineGetNewCalls for a remote line.
        // We deal with this by retrieving any new calls for
        // this line (or address), and indicating NEWCALL &
        // CALLSTTE\UNKNOWN msgs to tapi.
        //
        // Note that hTargetProcess is really a pointer to the
        // internal tapisrv!LineEventProc, which actually processes
        // call state msgs, etc inline instead of queueing them for
        // later processing like tapisrv!LineEventProcSP does.
        // We want to submit the LINE_CALLSTATE msgs to this
        // function to make sure they get processed right away
        // so call monitors get created, etc before we return to
        // the call function.
        //

        DWORD           dwTotalSize;
        LINECALLLIST    fastCallList[2], *pCallList = fastCallList;
        LINEEVENT       internalLineEventProc = (LINEEVENT)
                            ((ULONG_PTR) hTargetProcess);
        REMOTE_ARG_TYPES argTypes[] =
        {
            Hdline,
            Dword,
            Dword,
            lpGet_Struct
        };
        ULONG_PTR args[] =
        {
            (ULONG_PTR) hdLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) 0
        };
        REMOTE_FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 4, lGetNewCalls),
            args,
            argTypes
        };


        dwTotalSize = sizeof (fastCallList);

        do
        {
            pCallList->dwTotalSize = dwTotalSize;

            args[3] = (ULONG_PTR) pCallList;

            lResult = REMOTEDOFUNC (&funcArgs, "lineGetNewCalls");

            if (lResult == 0)
            {
                if (pCallList->dwNeededSize > pCallList->dwTotalSize)
                {
                    //
                    // Get a bigger buffer & try again
                    //

                    dwTotalSize = pCallList->dwNeededSize + 4 * sizeof (HCALL);

                    if (pCallList != fastCallList)
                    {
                        DrvFree (pCallList);
                    }

                    if (!(pCallList = DrvAlloc (dwTotalSize)))
                    {
                        return LINEERR_NOMEM;
                    }
                }
                else
                {
                    //
                    // We got all the info, so break
                    //

                    break;
                }
            }

        } while (lResult == 0);

        if (lResult == 0)
        {
            if (pCallList->dwCallsNumEntries == 0)
            {
                lResult = LINEERR_OPERATIONFAILED;
            }
            else
            {
                //
                // For each returned call in the list indicate a NEWCALL
                // & a CALLSTATE\UNKNOWN msg.  (We could call over to the
                // server to retrieve the current call state, call id's,
                // etc, but that would be painful)
                //

                DWORD       i;
                LPHCALL     phCall = (LPHCALL) (((LPBYTE) pCallList) +
                                pCallList->dwCallsOffset);
                PDRVLINE    pLine = (PDRVLINE) hdLine;
                PDRVCALL    pCall;


                EnterCriticalSection (&gCallListCriticalSection);

                if (pLine->htLine)
                {
                    for (i = 0; i < pCallList->dwCallsNumEntries; i++,phCall++)
                    {
                        if ((pCall = DrvAlloc (sizeof (DRVCALL))))
                        {
                            pCall->hCall = *phCall;
                            pCall->dwInitialCallStateMode = 0xa5a5a5a5;
                            pCall->dwInitialPrivilege =
                                LINECALLPRIVILEGE_MONITOR;
#if MEMPHIS
#else
                            pCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;
#endif
                            AddCallToList (pLine, pCall);

                            (*gpfnLineEventProc)(
                                pLine->htLine,
                                0,
                                LINE_NEWCALL,
                                (ULONG_PTR) pCall,
                                (ULONG_PTR) &(pCall->htCall),
                                (ULONG_PTR) 0
                                );

                            if (!pCall->htCall)
                            {
                                //
                                // tapi was not able to create it's own inst
                                // to represent ths incoming call, perhaps
                                // because the line was closed, or out of
                                // memory.  if the line was closed then we've
                                // already notified the remote server, and it
                                // should have destroyed the call client.
                                // otherwise, we probably want to do a
                                // closecall here or in a worker thread
                                //
                                static REMOTE_ARG_TYPES argTypes[] =
                                {
                                    Hdcall
                                };
                                REMOTE_FUNC_ARGS funcArgs =
                                {
                                    MAKELONG (LINE_FUNC | SYNC | 1, lDeallocateCall),
                                    (ULONG_PTR *) &pCall,
                                    argTypes
                                };

                                REMOTEDOFUNC (&funcArgs, "lineCloseCall");

                                RemoveCallFromList (pCall);
                                break;
                            }


                            //
                            // Note we call the internalLineEventProc here,
                            // using ghProvider as a key
                            //

                            (*internalLineEventProc)(
                                pLine->htLine,
                                pCall->htCall,
                                LINE_CALLSTATE,
                                (ULONG_PTR) LINECALLSTATE_UNKNOWN,
                                (ULONG_PTR) &pCall->dwInitialCallStateMode,
                                (ULONG_PTR) 0
                                );
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                LeaveCriticalSection (&gCallListCriticalSection);
            }
        }

        if (pCallList != fastCallList)
        {
            DrvFree (pCallList);
        }
    }

TSPI_lineGetID_return:

    return lResult;
}


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) lpLineDevStatus
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetLineDevStatus),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineGetLineDevStatus"));
}


LONG
TSPIAPI
TSPI_lineGetProxyStatus(
    DWORD  dwDeviceID,
    DWORD  dwAppAPIVersion,
    LPLINEPROXYREQUESTLIST  lpLineProxyReqestList
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        LineID,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwAppAPIVersion,
        (ULONG_PTR) lpLineProxyReqestList
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetProxyStatus),
        args,
        argTypes
    };
    PDRVLINE pLine = GetLineFromID (dwDeviceID);

    if (NULL == pLine)
    {
        return LINEERR_BADDEVICEID;
    }

    args[0] = pLine->pServer->hLineApp;


    return (REMOTEDOFUNC (&funcArgs, "lineGetProxyStatus"));
}


LONG
TSPIAPI
TSPI_lineGetQueueInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwQueueID,
    LPLINEQUEUEINFO lpQueueInfo
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwQueueID,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpQueueInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lGetQueueInfo),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpQueueInfo;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetQueueInfo"));

}


LONG
TSPIAPI
TSPI_lineGetQueueList(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    GUID            *pGroupID,
    LPLINEQUEUELIST lpQueueList
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        lpSet_SizeToFollow,
        Size,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) pGroupID,
        (ULONG_PTR) sizeof( GUID ),
        (ULONG_PTR) 0,
        (ULONG_PTR) lpQueueList
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 7, lGetQueueList),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return LINEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineGetAgentxxx_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpQueueList;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "lGetQueueList"));

}


LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) lpdwNumAddressIDs
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetNumAddressIDs),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineGetNumAddressIDs"));
}


LONG
TSPIAPI
TSPI_lineHold(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lHold),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineHold"));
}

void
PASCAL
TSPI_lineMakeCall_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    )
{
    PDRVCALL    pCall = (PDRVCALL) pContext->Params[0];


    LOG((TL_INFO, "TSPI_lineMakeCall_PostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%x, p2=x%x, p3=x%x, p4=x%x",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    EnterCriticalSection (&gCallListCriticalSection);

    if (!IsValidObject (pCall, DRVCALL_KEY) ||
        (pCall->dwOriginalRequestID != pContext->dwOriginalRequestID))
    {
        LOG((TL_ERROR,
            "TSPI_lineMakeCall_PostProcess: Bad pCall or ID - pCall x%lx",
            pCall
            ));

        pMsg->Param2 = LINEERR_INVALLINEHANDLE;
    }
    else
    {
       if (pMsg->Param2 == 0)
       {
           if (pMsg->Param3 != 0)
           {
               // this is the normal success case

               pCall->hCall = (HCALL) pMsg->Param3;
#if MEMPHIS
#else
               if (pMsg->TotalSize >= (sizeof (*pMsg) + 3 * sizeof(ULONG_PTR)))
               {
                   pCall->dwAddressID     = (DWORD) *(&pMsg->Param4 + 1);
                   pCall->dwCallID        = (DWORD) *(&pMsg->Param4 + 2);
                   pCall->dwRelatedCallID = (DWORD) *(&pMsg->Param4 + 3);
               }
               else
               {
                    pCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;

                    pCall->pServer->bVer2xServer = TRUE;
               }
#endif
           }
           else
           {
              if (pContext->Params[1])
              {
                  //
                  // This is the special lineforward case
                  // where we save the lphdCall in case
                  // we need to null it out
                  //

                  LPHDRVCALL    lphdConsultCall = (LPHDRVCALL)
                                    pContext->Params[1];


                  *lphdConsultCall = 0;

                  RemoveCallFromList (pCall);
              }
              else
              {
              }
           }
       }
       else
       {
           RemoveCallFromList (pCall);
       }
    }

    LeaveCriticalSection (&gCallListCriticalSection);
}


LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        lpsz,
        Dword,
        lpSet_Struct,
        Dword
    };
    PDRVCALL    pCall = DrvAlloc (sizeof (DRVCALL));
    ULONG_PTR args[] =
    {
        (ULONG_PTR) DWORD_CAST(dwRequestID,__FILE__,__LINE__),
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpszDestAddress,
        (ULONG_PTR) DWORD_CAST(dwCountryCode,__FILE__,__LINE__),
        (ULONG_PTR) lpCallParams,
        (ULONG_PTR) 0xffffffff      // dwCallParamsCodePage
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 8, lMakeCall),
        args,
        argTypes
    };
    LONG    lResult;


    if (pCall)
    {
        PASYNCREQUESTCONTEXT pContext;


        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            DrvFree (pCall);
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_lineMakeCall_PostProcess;
        pContext->Params[0] = (ULONG_PTR) pCall;

        args[1] = (ULONG_PTR) pContext;
        argTypes[1] = lpContext;


        //
        // Assume success & add the call to the line's list before we
        // even make the request.  This makes cleanup alot easier if
        // the server goes down or some such uncooth event.
        //

        pCall->dwOriginalRequestID = dwRequestID;

        pCall->htCall = htCall;

        pCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

        AddCallToList ((PDRVLINE) hdLine, pCall);

        *lphdCall = (HDRVCALL) pCall;

        if ((lResult = REMOTEDOFUNC (&funcArgs, "lineMakeCall")) < 0)
        {
            RemoveCallFromList (pCall);
        }

        LOG((TL_INFO, "TSPI_lineMakeCall - new pCall x%lx", pCall));
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL    hdCall,
    DWORD       dwDigitModes
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwDigitModes
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorDigits),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineMonitorDigits"));
}


LONG
TSPIAPI
TSPI_lineMonitorMedia(
    HDRVCALL    hdCall,
    DWORD       dwMediaModes
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwMediaModes
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorMedia),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineMonitorMedia"));
}


LONG
TSPIAPI
TSPI_lineMonitorTones(
    HDRVCALL            hdCall,
    DWORD               dwToneListID,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        lpSet_SizeToFollow,
        Size,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpToneList,
        (ULONG_PTR) dwNumEntries * sizeof (LINEMONITORTONE),
        (ULONG_PTR) dwToneListID
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lMonitorTones),
        args,
        argTypes
    };


    if (!lpToneList)
    {
        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (REMOTEDOFUNC (&funcArgs, "lineMonitorTones"));
}


LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwTSPIVersion,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        LineID,
        Dword,
        Dword,
        Dword,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwTSPIVersion,
        (ULONG_PTR) dwLowVersion,
        (ULONG_PTR) dwHighVersion,
        (ULONG_PTR) lpdwExtVersion,
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lNegotiateExtVersion),
        args,
        argTypes
    };
    PDRVLINE pLine = GetLineFromID (dwDeviceID);

    if (NULL == pLine)
    {
        return LINEERR_BADDEVICEID;
    }

    args[0] = pLine->pServer->hLineApp;

    return (REMOTEDOFUNC (&funcArgs, "lineNegotiateExtVersion"));
}


LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    LONG lRet = 0;

    // 
    // Check ghInst to ensure DllMain(DLL_PROCESS_ATTACH) has been called properly
    //
    if ( NULL == ghInst )
    {
        return LINEERR_OPERATIONFAILED;
    }

    if (dwDeviceID == INITIALIZE_NEGOTIATION)
    {
        *lpdwTSPIVersion = TAPI_VERSION_CURRENT;
    }
    else
    {
        try
        {
            *lpdwTSPIVersion = (GetLineFromID (dwDeviceID))->dwXPIVersion;
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            lRet = LINEERR_OPERATIONFAILED;
        }
    }

    return lRet;
}


LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   pParams,    // Hack Alert!  see below
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
    )
{
    //
    // Hack Alert!
    //
    // Tapisrv does a special case for remotesp and line open
    // to pass in the privileges, etc - htLine is really pParams,
    // pointing at a ULONG_PTR array containing the htLine,
    // privileges, media modes, call params, & ext version
    //

    LONG        lResult;
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,                  // hLineApp
        LineID,                 // dev id
        lpDword,                // lphLine
        Dword,                  // API version
        Dword,                  // ext version
        Dword,                  // callback inst
        Dword,                  // privileges
        Dword,                  // dw media modes
        lpSet_Struct,           // call params
        Dword,                  // dwAsciiCallParamsCodePage
        lpGet_CallParamsStruct,
        Dword                   // remote hLine
    };
    PDRVLINE pLine = GetLineFromID (dwDeviceID);
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) 0,
        (ULONG_PTR) dwTSPIVersion,
        (ULONG_PTR) ((ULONG_PTR *) pParams)[4],  // ext version
        (ULONG_PTR) 0,
        (ULONG_PTR) ((ULONG_PTR *) pParams)[1],  // privilege(s)
        (ULONG_PTR) ((ULONG_PTR *) pParams)[2],  // media mode
        (ULONG_PTR) ((ULONG_PTR *) pParams)[3],  // pCallParams
        (ULONG_PTR) 0xffffffff,
        (ULONG_PTR) ((ULONG_PTR *) pParams)[3],
        (ULONG_PTR) 0
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lOpen),
        args,
        argTypes
    };


    if (NULL == pLine)
    {
        return LINEERR_BADDEVICEID;
    }

    args[0] = pLine->pServer->hLineApp;
    args[2] = (ULONG_PTR)&pLine->hLine;

    if (!(args[11] = NewObject (ghHandleTable, pLine, (LPVOID) 1)))
    {
        return LINEERR_NOMEM;
    }

    pLine->hDeviceCallback = (DWORD) args[11];

    if ( (((ULONG_PTR *) pParams)[3] == 0) ||
         (((ULONG_PTR *) pParams)[3] == TAPI_NO_DATA) )
    {
        argTypes[8] = Dword;
        args[8] = TAPI_NO_DATA;
        argTypes[10] = Dword;
        args[10] = TAPI_NO_DATA;
    }

    pLine->dwKey  = DRVLINE_KEY;
    pLine->htLine = (HTAPILINE) (((ULONG_PTR *) pParams)[0]);

    *lphdLine = (HDRVLINE) pLine;

    lResult = REMOTEDOFUNC (&funcArgs, "lineOpen");

    if (lResult != 0)
    {
        DereferenceObject (ghHandleTable, pLine->hDeviceCallback, 1);

        if ((HIWORD(lResult) == RSP_CALLPARAMS))
        {
            //
            // Hack Alert!
            //
            // If structure too small, give tapisrv the
            // needed size in lphdLine
            //

            *lphdLine = (HDRVLINE)(LOWORD(lResult));
            lResult = LINEERR_STRUCTURETOOSMALL;
        }
    }

    return lResult;
}


void
PASCAL
TSPI_linePark_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    )
{
    LOG((TL_INFO, "lineParkPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD       dwSize = (DWORD) pMsg->Param4;
        LPVARSTRING pNonDirAddress = (LPVARSTRING) pContext->Params[0];


        CopyMemory (pNonDirAddress, (LPBYTE) (pMsg + 1), dwSize);
    }
}


LONG
TSPIAPI
TSPI_linePark(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    DWORD           dwParkMode,
    LPCWSTR         lpszDirAddress,
    LPVARSTRING     lpNonDirAddress
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdcall,
        Dword,
        (dwParkMode == LINEPARKMODE_DIRECTED) ? lpsz : Dword,
        Dword,          // pass ptr as Dword for post processing
        (lpNonDirAddress ? lpGet_Struct : Dword)    // pass ptr as lpGet_Xx to retrieve dwTotalSize
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwParkMode,
        (ULONG_PTR) lpszDirAddress,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpNonDirAddress
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lPark),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (dwParkMode == LINEPARKMODE_NONDIRECTED)
    {
        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_linePark_PostProcess;
        pContext->Params[0] = (ULONG_PTR) lpNonDirAddress;

        args[1] = (ULONG_PTR) pContext;
		argTypes[1] = lpContext;

        funcArgs.Flags |= INCL_CONTEXT;
    }

    return (REMOTEDOFUNC (&funcArgs, "linePark"));
}


LONG
TSPIAPI
TSPI_linePickup(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPICALL       htCall,
    LPHDRVCALL      lphdCall,
    LPCWSTR         lpszDestAddress,
    LPCWSTR         lpszGroupID
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpsz,
        lpsz
    };
    PDRVCALL pCall = DrvAlloc (sizeof (DRVCALL));
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpszDestAddress,
        (ULONG_PTR) lpszGroupID
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 7, lPickup),
        args,
        argTypes
    };
    LONG lResult;


    if (pCall)
    {
        PASYNCREQUESTCONTEXT pContext;


        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            DrvFree (pCall);
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_lineMakeCall_PostProcess;
        pContext->Params[0] = (ULONG_PTR) pCall;

        args[1] = (ULONG_PTR) pContext;
		argTypes[1] = lpContext;

        pCall->htCall = htCall;

        pCall->dwOriginalRequestID = dwRequestID;

        pCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

        AddCallToList ((PDRVLINE) hdLine, pCall);

        *lphdCall = (HDRVCALL) pCall;

        if ((lResult = REMOTEDOFUNC (&funcArgs, "linePickup")) < 0)
        {
            RemoveCallFromList (pCall);
        }
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_linePrepareAddToConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdcall,
        Dword,
        lpSet_Struct,
        Dword
    };
    PDRVCALL pConsultCall = DrvAlloc (sizeof (DRVCALL));
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdConfCall,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpCallParams,
        (ULONG_PTR) 0xffffffff      // dwAsciiCallParamsCodePage
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG(LINE_FUNC | ASYNC | INCL_CONTEXT | 6,lPrepareAddToConference),
        args,
        argTypes
    };
    LONG lResult;


    if (pConsultCall)
    {
        PASYNCREQUESTCONTEXT pContext;


        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            DrvFree (pConsultCall);
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_lineMakeCall_PostProcess;
        pContext->Params[0] = (ULONG_PTR) pConsultCall;

        args[1] = (ULONG_PTR) pContext;
		argTypes[1] = lpContext;

        pConsultCall->htCall = htConsultCall;

        pConsultCall->dwOriginalRequestID = dwRequestID;

        pConsultCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

        AddCallToList (((PDRVCALL) hdConfCall)->pLine, pConsultCall);

        *lphdConsultCall = (HDRVCALL) pConsultCall;

        if ((lResult = REMOTEDOFUNC (&funcArgs, "linePrepareAddToConference"))
                < 0)
        {
            RemoveCallFromList (pConsultCall);
        }
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_lineRedirect(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpsz,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpszDestAddress,
        (ULONG_PTR) dwCountryCode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lRedirect),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineRedirect"));
}


LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lReleaseUserUserInfo),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineReleaseUserUserInfo"));
}


LONG
TSPIAPI
TSPI_lineRemoveFromConference(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lRemoveFromConference),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineRemoveFromConference"));
}


LONG
TSPIAPI
TSPI_lineSecureCall(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lSecureCall),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSecureCall"));
}


LONG
TSPIAPI
TSPI_lineSelectExtVersion(
    HDRVLINE    hdLine,
    DWORD       dwExtVersion
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwExtVersion
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSelectExtVersion),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSelectExtVersion"));

}


LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpsUserUserInfo,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSendUserUserInfo),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSendUserUserInfo"));
}



LONG
TSPIAPI
TSPI_lineSetAgentActivity(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    DWORD           dwActivityID
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) dwActivityID
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentActivity),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetAgentActivity"));
}


LONG
TSPIAPI
TSPI_lineSetAgentGroup(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        lpSet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) lpAgentGroupList
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentGroup),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetAgentGroup"));
}


LONG
TSPIAPI
TSPI_lineSetAgentMeasurementPeriod(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    HAGENT          hAgent,
    DWORD           dwMeasurementPeriod
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) hAgent,
        (ULONG_PTR) dwMeasurementPeriod
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentMeasurementPeriod),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetAgentMeasurementPeriod"));
}


LONG
TSPIAPI
TSPI_lineSetAgentSessionState(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    HAGENTSESSION   hAgentSession,
    DWORD           dwAgentState,
    DWORD           dwNextAgentState
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) hAgentSession,
        (ULONG_PTR) dwAgentState,
        (ULONG_PTR) dwNextAgentState
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetAgentSessionState),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetAgentSessionState"));
}


LONG
TSPIAPI
TSPI_lineSetAgentState(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    DWORD           dwAgentState,
    DWORD           dwNextAgentState
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) dwAgentState,
        (ULONG_PTR) dwNextAgentState
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetAgentState),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetAgentState"));
}
                                   
LONG
TSPIAPI
TSPI_lineSetAgentStateEx(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    HAGENT          hAgent,
    DWORD           dwAgentState,
    DWORD           dwNextAgentState
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) hAgent,
        (ULONG_PTR) dwAgentState,
        (ULONG_PTR) dwNextAgentState
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetAgentStateEx),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetAgentStateEx"));
}


LONG
TSPIAPI
TSPI_lineSetAppSpecific(
    HDRVCALL    hdCall,
    DWORD       dwAppSpecific
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwAppSpecific
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetAppSpecific),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetAppSpecific"));
}


LONG
TSPIAPI
TSPI_lineSetCallData(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPVOID          lpCallData,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpCallData,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetCallData),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetCallData"));
}


LONG
TSPIAPI
TSPI_lineSetCallHubTracking(
    HDRVLINE                    hdLine,
    LPLINECALLHUBTRACKINGINFO   lpTrackingInfo
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        lpSet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) lpTrackingInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetCallHubTracking),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetCallHubTracking"));
}


LONG
TSPIAPI
TSPI_lineSetCallParams(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        Dword,
        Dword,
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwBearerMode,
        (ULONG_PTR) dwMinRate,
        (ULONG_PTR) dwMaxRate,
        (ULONG_PTR) lpDialParams,
        (ULONG_PTR) (lpDialParams ? sizeof (LINEDIALPARAMS) : 0)
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lSetCallParams),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetCallParams"));
}


LONG
TSPIAPI
TSPI_lineSetCallQualityOfService(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPVOID          lpSendingFlowspec,
    DWORD           dwSendingFlowspecSize,
    LPVOID          lpReceivingFlowspec,
    DWORD           dwReceivingFlowspecSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        lpSet_SizeToFollow,
        Size,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) lpSendingFlowspec,
        (ULONG_PTR) dwSendingFlowspecSize,
        (ULONG_PTR) lpReceivingFlowspec,
        (ULONG_PTR) dwReceivingFlowspecSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lSetCallQualityOfService),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetCallQualityOfService"));
}


LONG
TSPIAPI
TSPI_lineSetCallTreatment(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    DWORD           dwTreatment
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwTreatment
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetCallTreatment),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetCallTreatment"));
}


LONG
TSPIAPI
TSPI_lineSetCurrentLocation(
    DWORD   dwLocation
    )
{
    return LINEERR_OPERATIONUNAVAIL;
}


LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwMediaModes,
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetDefaultMediaDetection),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetDefaultMediaDetection"));
}


LONG
TSPIAPI
TSPI_lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        LineID,
        lpSet_SizeToFollow,
        Size,
        lpsz
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) lpDeviceConfig,
        (ULONG_PTR) dwSize,
        (ULONG_PTR) lpszDeviceClass
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lSetDevConfig),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetDevConfig"));
}


LONG
TSPIAPI
TSPI_lineSetLineDevStatus(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwStatusToChange,
    DWORD           fStatus
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwStatusToChange,
        (ULONG_PTR) fStatus
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetLineDevStatus),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetLineDevStatus"));
}


LONG
TSPIAPI
TSPI_lineSetMediaControl(
    HDRVLINE                    hdLine,
    DWORD                       dwAddressID,
    HDRVCALL                    hdCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD                       dwCallStateNumEntries
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        (dwSelect == LINECALLSELECT_CALL ? Dword : Hdline),
        Dword,
        (dwSelect == LINECALLSELECT_CALL ? Hdcall : Dword),
        Dword,
        lpSet_SizeToFollow,
        Size,
        lpSet_SizeToFollow,
        Size,
        lpSet_SizeToFollow,
        Size,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwSelect,
        (ULONG_PTR) lpDigitList,
        (ULONG_PTR) dwDigitNumEntries,
        (ULONG_PTR) lpMediaList,
        (ULONG_PTR) dwMediaNumEntries,
        (ULONG_PTR) lpToneList,
        (ULONG_PTR) dwToneNumEntries,
        (ULONG_PTR) lpCallStateList,
        (ULONG_PTR) dwCallStateNumEntries
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lSetMediaControl),
        args,
        argTypes
    };


    dwDigitNumEntries     *= sizeof (LINEMEDIACONTROLDIGIT);
    dwMediaNumEntries     *= sizeof (LINEMEDIACONTROLMEDIA);
    dwToneNumEntries      *= sizeof (LINEMEDIACONTROLTONE);
    dwCallStateNumEntries *= sizeof (LINEMEDIACONTROLCALLSTATE);

    return (REMOTEDOFUNC (&funcArgs, "lineSetMediaControl"));
}


LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL    hdCall,
    DWORD       dwMediaMode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdcall,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwMediaMode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetMediaMode),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetMediaMode"));
}


LONG
TSPIAPI
TSPI_lineSetQueueMeasurementPeriod(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwQueueID,
    DWORD           dwMeasurementPeriod
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwQueueID,
        (ULONG_PTR) dwMeasurementPeriod
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetQueueMeasurementPeriod),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetQueueMeasurementPeriod"));
}
                                   

LONG
TSPIAPI
TSPI_lineSetStatusMessages(
    HDRVLINE    hdLine,
    DWORD       dwLineStates,
    DWORD       dwAddressStates
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdline,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwLineStates,
        (ULONG_PTR) dwAddressStates
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lSetStatusMessages),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetStatusMessages"));
}


LONG
TSPIAPI
TSPI_lineSetTerminal(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HDRVCALL        hdCall,
    DWORD           dwSelect,
    DWORD           dwTerminalModes,
    DWORD           dwTerminalID,
    DWORD           bEnable
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        (dwSelect == LINECALLSELECT_CALL ? Dword : Hdline),
        Dword,
        (dwSelect == LINECALLSELECT_CALL ? Hdcall : Dword),
        Dword,
        Dword,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) dwSelect,
        (ULONG_PTR) dwTerminalModes,
        (ULONG_PTR) dwTerminalID,
        (ULONG_PTR) bEnable
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lSetTerminal),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSetTerminal"));
}


void
PASCAL
TSPI_lineSetupConference_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    )
{
    PDRVCALL    pConfCall = (PDRVCALL) pContext->Params[0],
                pConsultCall = (PDRVCALL) pContext->Params[1];


    LOG((TL_INFO, "TSPI_lineSetupConference_PostProcess: enter"));

    EnterCriticalSection (&gCallListCriticalSection);

    if (!IsValidObject (pConfCall, DRVCALL_KEY) ||
        pConfCall->dwOriginalRequestID != pContext->dwOriginalRequestID)
    {
        LOG((TL_ERROR,"TSPI_lineSetupConference_PostProcess: Bad pConfCall dwID"));
        pMsg->Param2 = LINEERR_INVALLINEHANDLE;
    }
    else
    {
        if (!IsValidObject (pConsultCall, DRVCALL_KEY) ||
            pConsultCall->dwOriginalRequestID != pContext->dwOriginalRequestID)
        {
            //
            // If here then the was closed & the calls have
            // already been destroyed
            //

            LOG((TL_ERROR,
                "TSPI_lineSetupConference_PostProcess: Bad pConsultCall dwID"
                ));

            pMsg->Param2 = LINEERR_INVALLINEHANDLE;
        }
        else
        {
            LOG((TL_INFO,
                "\t\tp1=x%x, p2=x%x, p3=x%x",
                pMsg->Param1,
                pMsg->Param2,
                pMsg->Param3
                ));

            LOG((TL_INFO,
                "\t\tp4=x%x, p5=x%x, p6=x%x",
                pMsg->Param4,
                *(&pMsg->Param4 + 1),
                pConsultCall
                ));

            if (pMsg->Param2 == 0)
            {
                HCALL   hConfCall    = (HCALL) pMsg->Param3,
                        hConsultCall = (HCALL) *(&pMsg->Param4 + 1);


                pConfCall->hCall    = hConfCall;
                pConsultCall->hCall = hConsultCall;

#if MEMPHIS
#else
                if (pMsg->TotalSize >= (sizeof (*pMsg) + 8 * sizeof (DWORD)))
                {
                    pConfCall->dwAddressID     = (DWORD) *(&pMsg->Param4 + 3);
                    pConfCall->dwCallID        = (DWORD) *(&pMsg->Param4 + 4);
                    pConfCall->dwRelatedCallID = (DWORD) *(&pMsg->Param4 + 5);

                    pConsultCall->dwAddressID     = (DWORD) *(&pMsg->Param4+6);
                    pConsultCall->dwCallID        = (DWORD) *(&pMsg->Param4+7);
                    pConsultCall->dwRelatedCallID = (DWORD) *(&pMsg->Param4+8);
                }
                else
                {
                    pConfCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;

                    pConfCall->pServer->bVer2xServer = TRUE;

                    pConsultCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;
                }
#endif
            }
            else
            {
                RemoveCallFromList (pConfCall);
                RemoveCallFromList (pConsultCall);
            }
        }
    }

    LeaveCriticalSection (&gCallListCriticalSection);
}


LONG
TSPIAPI
TSPI_lineSetupConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HDRVLINE            hdLine,
    HTAPICALL           htConfCall,
    LPHDRVCALL          lphdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        (hdCall ? Hdcall : Dword),
        (hdCall ? Dword : Hdline),
        Dword,
        Dword,
        Dword,
        lpSet_Struct,
        Dword
    };
    PDRVCALL    pConfCall = DrvAlloc (sizeof (DRVCALL)),
                pConsultCall = DrvAlloc (sizeof (DRVCALL));
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) pConfCall,
        (ULONG_PTR) pConsultCall,
        (ULONG_PTR) dwNumParties,
        (ULONG_PTR) lpCallParams,
        (ULONG_PTR) 0xffffffff      // dwAsciiCallParamsCodePage
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 9, lSetupConference),
        args,
        argTypes
    };
    LONG    lResult;


    if (pConfCall)
    {
        if (pConsultCall)
        {
            PDRVLINE                pLine;
            PASYNCREQUESTCONTEXT    pContext;


            if (!(pContext = DrvAlloc (sizeof (*pContext))))
            {
                DrvFree (pConfCall);
                DrvFree (pConsultCall);
                return LINEERR_NOMEM;
            }

            pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
                TSPI_lineSetupConference_PostProcess;
            pContext->Params[0] = (ULONG_PTR) pConfCall;
            pContext->Params[1] = (ULONG_PTR) pConsultCall;

            args[1] = (ULONG_PTR) pContext;
			argTypes[1] = lpContext;

            pConfCall->htCall     = htConfCall;
            pConsultCall->htCall  = htConsultCall;

            pConfCall->dwOriginalRequestID = dwRequestID;
            pConsultCall->dwOriginalRequestID = dwRequestID;

            pConfCall->dwInitialPrivilege    = LINECALLPRIVILEGE_OWNER;
            pConsultCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

            if (hdCall)
            {
                EnterCriticalSection (&gCallListCriticalSection);

                if (IsValidObject ((PVOID) hdCall, DRVCALL_KEY))
                {
                    pLine = ((PDRVCALL) hdCall)->pLine;
                }
                else
                {
                    LeaveCriticalSection (&gCallListCriticalSection);

                    DrvFree (pConfCall);
                    DrvFree (pConsultCall);

                    return LINEERR_INVALCALLHANDLE;
                }

                LeaveCriticalSection (&gCallListCriticalSection);
            }
            else
            {
                pLine = (PDRVLINE) hdLine;
            }

            AddCallToList (pLine, pConfCall);
            AddCallToList (pLine, pConsultCall);

            *lphdConfCall    = (HDRVCALL) pConfCall;
            *lphdConsultCall = (HDRVCALL) pConsultCall;

            if ((lResult = REMOTEDOFUNC (&funcArgs, "lineSetupConference"))
                    < 0)
            {
                RemoveCallFromList (pConfCall);
                RemoveCallFromList (pConsultCall);
            }
        }
        else
        {
            DrvFree (pConfCall);
            lResult = LINEERR_NOMEM;
        }
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_lineSetupTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdcall,
        Dword,
        lpSet_Struct,
        Dword
    };
    PDRVCALL    pConsultCall = DrvAlloc (sizeof (DRVCALL));
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdCall,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpCallParams,
        (ULONG_PTR) 0xffffffff,     // dwAsciiCallParamsCodePage
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lSetupTransfer),
        args,
        argTypes
    };
    LONG    lResult;


    if (pConsultCall)
    {
        PASYNCREQUESTCONTEXT pContext;


        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            DrvFree (pConsultCall);
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_lineMakeCall_PostProcess;
        pContext->Params[0] = (ULONG_PTR) pConsultCall;

        args[1] = (ULONG_PTR) pContext;
		argTypes[1] = lpContext;

        pConsultCall->dwOriginalRequestID = dwRequestID;

        pConsultCall->htCall  = htConsultCall;

        pConsultCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

        AddCallToList (((PDRVCALL) hdCall)->pLine, pConsultCall);

        *lphdConsultCall = (HDRVCALL) pConsultCall;

        if ((lResult = REMOTEDOFUNC (&funcArgs, "lineSetupTransfer")) < 0)
        {
            RemoveCallFromList (pConsultCall);
        }
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_lineSwapHold(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdActiveCall,
    HDRVCALL        hdHeldCall
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall,
        Hdcall
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdActiveCall,
        (ULONG_PTR) hdHeldCall
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSwapHold),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineSwapHold"));
}


LONG
TSPIAPI
TSPI_lineUncompleteCall(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwCompletionID
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdline,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwCompletionID
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lUncompleteCall),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineUncompleteCall"));
}


LONG
TSPIAPI
TSPI_lineUnhold(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdcall
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdCall
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lUnhold),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "lineUnhold"));
}


LONG
TSPIAPI
TSPI_lineUnpark(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPICALL       htCall,
    LPHDRVCALL      lphdCall,
    LPCWSTR         lpszDestAddress
    )
{
    REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdline,
        Dword,
        Dword,
        lpsz
    };
    PDRVCALL    pCall = DrvAlloc (sizeof (DRVCALL));
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdLine,
        (ULONG_PTR) dwAddressID,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpszDestAddress
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | INCL_CONTEXT | 6, lUnpark),
        args,
        argTypes
    };
    LONG    lResult;


    if (pCall)
    {
        PASYNCREQUESTCONTEXT pContext;


        if (!(pContext = DrvAlloc (sizeof (*pContext))))
        {
            DrvFree (pCall);
            return LINEERR_NOMEM;
        }

        pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
            TSPI_lineMakeCall_PostProcess;
        pContext->Params[0] = (ULONG_PTR) pCall;

        args[1] = (ULONG_PTR) pContext;
		argTypes[1] = lpContext;

        pCall->dwOriginalRequestID = dwRequestID;

        pCall->htCall  = htCall;

        pCall->dwInitialPrivilege = LINECALLPRIVILEGE_OWNER;

        AddCallToList ((PDRVLINE) hdLine, pCall);

        *lphdCall = (HDRVCALL) pCall;

        if ((lResult = REMOTEDOFUNC (&funcArgs, "lineUnpark")) < 0)
        {
            RemoveCallFromList (pCall);
        }
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return lResult;
}



//
// -------------------------- TSPI_phoneXxx funcs -----------------------------
//

LONG
TSPIAPI
TSPI_phoneClose(
    HDRVPHONE   hdPhone
    )
{
    //
    // Check if the hPhone is still valid (could have been zeroed
    // out on PHONE_CLOSE, so no need to call server)
    //

    if (((PDRVPHONE) hdPhone)->hPhone)
    {
        static REMOTE_ARG_TYPES argTypes[] =
        {
            Hdphone
        };
        REMOTE_FUNC_ARGS funcArgs =
        {
            MAKELONG (PHONE_FUNC | SYNC | 1, pClose),
            (ULONG_PTR *) &hdPhone,
            argTypes
        };


        DereferenceObject(
            ghHandleTable,
            ((PDRVPHONE) hdPhone)->hDeviceCallback,
            1
            );

        EnterCriticalSection (&gCallListCriticalSection);

        ((PDRVPHONE) hdPhone)->htPhone = 0;
        ((PDRVPHONE) hdPhone)->hDeviceCallback = 0;

        LeaveCriticalSection (&gCallListCriticalSection);

        REMOTEDOFUNC (&funcArgs, "phoneClose");
    }

    return 0;
}


LONG
TSPIAPI
TSPI_phoneDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Dword,
        Hdphone,
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) 0,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) 0,
        (ULONG_PTR) lpParams,   // pass data
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | INCL_CONTEXT | 6, pDevSpecific),
        args,
        argTypes
    };
    PASYNCREQUESTCONTEXT pContext;


    if (!(pContext = DrvAlloc (sizeof (*pContext))))
    {
        return PHONEERR_NOMEM;
    }

    pContext->pfnPostProcessProc = (RSPPOSTPROCESSPROC)
        TSPI_lineDevSpecific_PostProcess;
    pContext->Params[0] = (ULONG_PTR) lpParams;
    pContext->Params[1] = dwSize;

    args[1] = (ULONG_PTR) pContext;
	argTypes[1] = lpContext;

    return (REMOTEDOFUNC (&funcArgs, "phoneDevSpecific"));
}


LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwButtonLampID,
        (ULONG_PTR) lpButtonInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetButtonInfo),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetButtonInfo"));
}


LONG
TSPIAPI
TSPI_phoneGetData(
    HDRVPHONE   hdPhone,
    DWORD       dwDataID,
    LPVOID      lpData,
    DWORD       dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        Dword,
        lpGet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwDataID,
        (ULONG_PTR) lpData,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pGetData),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetData"));
}


LONG
TSPIAPI
TSPI_phoneGetDevCaps(
    DWORD       dwDeviceID,
    DWORD       dwTSPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    LONG        lResult;

    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        PhoneID,
        Dword,
        Dword,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwTSPIVersion,
        (ULONG_PTR) dwExtVersion,
        (ULONG_PTR) lpPhoneCaps
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, pGetDevCaps),
        args,
        argTypes
    };
    PDRVPHONE   pPhone = GetPhoneFromID (dwDeviceID);

    if (NULL == pPhone)
    {
        return PHONEERR_BADDEVICEID;
    }

    args[0] = pPhone->pServer->hPhoneApp;

    lResult = REMOTEDOFUNC (&funcArgs, "phoneGetDevCaps");

    //
    // We were munging the PermID in the original release of tapi 2.1.
    // The intent was to make sure that we didn't present apps with
    // overlapping id's (both local & remote), but none of our other service
    // providers (i.e. unimdm, kmddsp) use the HIWORD(providerID) /
    // LOWORD(devID) model, so it really doesn't do any good.
    //
    // if (lResult == 0)
    // {
    //     lpPhoneCaps->dwPermanentPhoneID = MAKELONG(
    //         LOWORD(lpPhoneCaps->dwPermanentPhoneID),
    //         gdwPermanentProviderID
    //         );
    // }
    //

    return lResult;
}


LONG
TSPIAPI
TSPI_phoneGetDisplay(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDisplay
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) lpDisplay
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetDisplay),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetDisplay"));
}


LONG
TSPIAPI
TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
 PDRVPHONE pPhone = GetPhoneFromID (dwDeviceID);

    if (NULL == pPhone)
    {
        return PHONEERR_BADDEVICEID;
    }

    CopyMemory(
        lpExtensionID,
        &pPhone->ExtensionID,
        sizeof (PHONEEXTENSIONID)
        );

    return 0;
}


LONG
TSPIAPI
TSPI_phoneGetGain(
    HDRVPHONE   hdPhone,
    DWORD       dwHookSwitchDev,
    LPDWORD     lpdwGain
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        Dword,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwHookSwitchDev,
        (ULONG_PTR) lpdwGain
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetGain),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetGain"));
}



LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwHookSwitchDevs
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) lpdwHookSwitchDevs
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetHookSwitch),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetHookSwitch"));
}


LONG
TSPIAPI
TSPI_phoneGetIcon(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    *lphIcon = ghPhoneIcon;

    return 0;
}


LONG
TSPIAPI
TSPI_phoneGetID(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    //
    // NOTE: Tapisrv will handle the "tapi/phone" class
    //

    LONG    lResult;
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        lpGet_Struct,
        lpsz
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) lpDeviceID,
        (ULONG_PTR) lpszDeviceClass
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetID),
        args,
        argTypes
    };


    //
    // The device ID for wave devices is meaningless on remote machines.
    // Return op. unavailable
    //
    if (lpszDeviceClass &&
        (   !_wcsicmp(lpszDeviceClass, L"wave/in")  ||
            !_wcsicmp(lpszDeviceClass, L"wave/out") ||
            !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
            !_wcsicmp(lpszDeviceClass, L"midi/out") ||
            !_wcsicmp(lpszDeviceClass, L"wave/in/out")
        )
       )
    {
        return PHONEERR_OPERATIONUNAVAIL;
    }

    lResult = REMOTEDOFUNC (&funcArgs, "phoneGetID");


    //
    // If success  &&  dev class == "tapi/line"  && there was
    // enough room in the device ID struct for a returned ID,
    // then we need to map the 0-based server ID back to it's
    // corresponding local ID.
    //

    if (lResult == 0  &&
        lstrcmpiW (lpszDeviceClass, L"tapi/line") == 0  &&
        lpDeviceID->dwUsedSize >= (sizeof (*lpDeviceID) + sizeof (DWORD)))
    {
        LPDWORD     pdwLineID = (LPDWORD) (((LPBYTE) lpDeviceID) +
                        lpDeviceID->dwStringOffset);
        PDRVLINE    pLine;
        PDRVSERVER  pServer = ((PDRVPHONE) hdPhone)->pServer;


        if ((pLine = GetLineFromID (gdwLineDeviceIDBase + *pdwLineID)))
        {
            if (pLine->pServer == pServer  &&
                pLine->dwDeviceIDServer == *pdwLineID)
            {
                //
                // The easy case - a direct mapping between the ID
                // returned from the server & the index into the
                // lookup table
                //

                *pdwLineID = pLine->dwDeviceIDLocal;
            }
            else
            {
                //
                // The hard case - have to walk the lookup table(s)
                // looking for the matching device.
                //
                // We'll take the simplest, though slowest, route
                // and start at the first entry of the first table.
                // The good news is that there generally won't be
                // many devices, and this request won't occur often.
                //

                DWORD           i;
                PDRVLINELOOKUP  pLookup;

                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpLineLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if (pLookup->aEntries[i].dwDeviceIDServer ==
                                *pdwLineID  &&

                            pLookup->aEntries[i].pServer == pServer)
                        {
                            *pdwLineID = pLookup->aEntries[i].dwDeviceIDLocal;
                            TapiLeaveCriticalSection(&gCriticalSection);
                            goto TSPI_phoneGetID_return;
                        }
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);


                //
                // If here no matching local ID, so fail the request
                //

                lResult = PHONEERR_OPERATIONFAILED;
            }
        }
        else
        {
            lResult = PHONEERR_OPERATIONFAILED;
        }
    }

TSPI_phoneGetID_return:

    return lResult;
}


LONG
TSPIAPI
TSPI_phoneGetLamp(
    HDRVPHONE   hdPhone,
    DWORD       dwButtonLampID,
    LPDWORD     lpdwLampMode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        Dword,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwButtonLampID,
        (ULONG_PTR) lpdwLampMode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetLamp),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetLamp"));
}


LONG
TSPIAPI
TSPI_phoneGetRing(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwRingMode,
    LPDWORD     lpdwVolume
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        lpDword,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) lpdwRingMode,
        (ULONG_PTR) lpdwVolume
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetRing),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetRing"));
}


LONG
TSPIAPI
TSPI_phoneGetStatus(
    HDRVPHONE       hdPhone,
    LPPHONESTATUS   lpPhoneStatus
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        lpGet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) lpPhoneStatus
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetStatus),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetStatus"));
}


LONG
TSPIAPI
TSPI_phoneGetVolume(
    HDRVPHONE   hdPhone,
    DWORD       dwHookSwitchDev,
    LPDWORD     lpdwVolume
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        Dword,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwHookSwitchDev,
        (ULONG_PTR) lpdwVolume
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetVolume),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneGetVolume"));
}


LONG
TSPIAPI
TSPI_phoneNegotiateExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwTSPIVersion,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        PhoneID,
        Dword,
        Dword,
        Dword,
        lpDword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwTSPIVersion,
        (ULONG_PTR) dwLowVersion,
        (ULONG_PTR) dwHighVersion,
        (ULONG_PTR) lpdwExtVersion,
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, pNegotiateExtVersion),
        args,
        argTypes
    };
    PDRVPHONE   pPhone = GetPhoneFromID (dwDeviceID);

    if (NULL == pPhone)
    {
        return PHONEERR_BADDEVICEID;
    }

    args[0] = pPhone->pServer->hPhoneApp;

    return (REMOTEDOFUNC (&funcArgs, "phoneNegotiateExtVersion"));
}


LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
 LONG lRet = 0;

    if (dwDeviceID == INITIALIZE_NEGOTIATION)
    {
        *lpdwTSPIVersion = TAPI_VERSION_CURRENT;
    }
    else
    {
        try
        {
            *lpdwTSPIVersion = (GetPhoneFromID (dwDeviceID))->dwXPIVersion;
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            lRet = PHONEERR_OPERATIONFAILED;
        }
    }


    return lRet;
}


LONG
TSPIAPI
TSPI_phoneOpen(
    DWORD       dwDeviceID,
    HTAPIPHONE  pParams,        // Hack Alert!  See below
    LPHDRVPHONE lphdPhone,
    DWORD       dwTSPIVersion,
    PHONEEVENT  lpfnEventProc
    )
{
    //
    // Hack Alert!
    //
    // Tapisrv does a special case for remotesp and phone open
    // to pass in the ext version - htPhone is really pParams,
    // pointing at a ULONG_PTR array containing the htPhone &
    // ext version
    //

    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,      // hPhoneApp
        PhoneID,    // dev id
        lpDword,    // lphPhone
        Dword,      // API version
        Dword,      // ext version
        Dword,      // callback inst
        Dword,      // privilege
        Dword       // remote hPhone
    };
    PDRVPHONE   pPhone = GetPhoneFromID (dwDeviceID);
    ULONG_PTR args[] =
    {
        (ULONG_PTR) 0,
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) 0,
        (ULONG_PTR) dwTSPIVersion,
        (ULONG_PTR) ((ULONG_PTR *) pParams)[1],  // ext version
        (ULONG_PTR) 0,
        (ULONG_PTR) PHONEPRIVILEGE_OWNER,
        (ULONG_PTR) pPhone
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 8, pOpen),
        args,
        argTypes
    };
    LONG    lResult;


    if (NULL == pPhone)
    {
        return PHONEERR_BADDEVICEID;
    }

    args[0] = pPhone->pServer->hPhoneApp;
    args[2] = (ULONG_PTR)&pPhone->hPhone;

    if (!(args[7] = NewObject (ghHandleTable, pPhone, (LPVOID) 1)))
    {
        return PHONEERR_NOMEM;
    }

    pPhone->hDeviceCallback = (DWORD) args[7];

    pPhone->dwKey   = DRVPHONE_KEY;
    pPhone->htPhone = (HTAPIPHONE) ((ULONG_PTR *) pParams)[0];

    *lphdPhone = (HDRVPHONE) pPhone;

    lResult = REMOTEDOFUNC (&funcArgs, "phoneOpen");

    if (lResult != 0)
    {
        DereferenceObject (ghHandleTable, pPhone->hDeviceCallback, 1);
    }

    return lResult;
}


LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
    HDRVPHONE   hdPhone,
    DWORD       dwExtVersion
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwExtVersion
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pSelectExtVersion),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSelectExtVersion"));

}


LONG
TSPIAPI
TSPI_phoneSetButtonInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        lpSet_Struct
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwButtonLampID,
        (ULONG_PTR) lpButtonInfo
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetButtonInfo),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetButtonInfo"));
}


LONG
TSPIAPI
TSPI_phoneSetData(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwDataID,
    LPVOID          const lpData,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwDataID,
        (ULONG_PTR) lpData,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 5, pSetData),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetData"));
}


LONG
TSPIAPI
TSPI_phoneSetDisplay(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRow,
    DWORD           dwColumn,
    LPCWSTR         lpsDisplay,
    DWORD           dwSize
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        Dword,
        lpSet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwRow,
        (ULONG_PTR) dwColumn,
        (ULONG_PTR) lpsDisplay,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 6, pSetDisplay),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetDisplay"));
}


LONG
TSPIAPI
TSPI_phoneSetGain(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDev,
    DWORD           dwGain
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwHookSwitchDev,
        (ULONG_PTR) dwGain
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetGain),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetGain"));
}


LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDevs,
    DWORD           dwHookSwitchMode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwHookSwitchDevs,
        (ULONG_PTR) dwHookSwitchMode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetHookSwitch),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetHookswitch"));
}


LONG
TSPIAPI
TSPI_phoneSetLamp(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwButtonLampID,
    DWORD           dwLampMode
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwButtonLampID,
        (ULONG_PTR) dwLampMode
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetLamp),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetLamp"));
}


LONG
TSPIAPI
TSPI_phoneSetRing(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRingMode,
    DWORD           dwVolume
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwRingMode,
        (ULONG_PTR) dwVolume
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetRing),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetRing"));
}


LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
    HDRVPHONE   hdPhone,
    DWORD       dwPhoneStates,
    DWORD       dwButtonModes,
    DWORD       dwButtonStates
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Hdphone,
        Dword,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwPhoneStates,
        (ULONG_PTR) dwButtonModes,
        (ULONG_PTR) dwButtonStates
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pSetStatusMessages),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetStatusMessages"));
}


LONG
TSPIAPI
TSPI_phoneSetVolume(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDev,
    DWORD           dwVolume
    )
{
    static REMOTE_ARG_TYPES argTypes[] =
    {
        Dword,
        Hdphone,
        Dword,
        Dword
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwRequestID,
        (ULONG_PTR) hdPhone,
        (ULONG_PTR) dwHookSwitchDev,
        (ULONG_PTR) dwVolume
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetVolume),
        args,
        argTypes
    };


    return (REMOTEDOFUNC (&funcArgs, "phoneSetVolume"));
}



//
// ------------------------- TSPI_providerXxx funcs ---------------------------
//


LONG
TSPIAPI
TSPI_providerCheckForNewUser(
    DWORD   dwPermanentProviderID
    )
{
    //
    // This func gets called when a new process attaches to TAPISRV.
    // We take advantage of this notification by checking to see if
    // we've previously gone through full initialization, and if not
    // (because previously attached processes were running in the
    // system account which didn't allow for net access, and there
    // was no logged on user to impersonate) then we try again here.
    //
    // Note that TAPISRV serializes calls to this func along with calls
    // to init & shutdown, so we don't have to worry about serialization
    // ourselves.
    //

#if MEMPHIS
#else

    if (!gbInitialized)
    {
        LONG    lResult;
        DWORD   dwNumLines, dwNumPhones;


        LOG((TL_INFO,
            "TSPI_providerCheckForNewUser: trying deferred init..."
            ));

        lResult = TSPI_providerEnumDevices(
            0xffffffff,
            &dwNumLines,
            &dwNumPhones,
            0,
            NULL,
            NULL
            );

        if (lResult == 1)
        {
            lResult = TSPI_providerInit(
                TAPI_VERSION_CURRENT,
                0xffffffff,             // dwPermanentProviderID,
                0,                      // dwLineDeviceIDBase,
                0,                      // dwPhoneDeviceIDBase,
                0,                      // dwNumLines,
                0,                      // dwNumPhones,
                NULL,                   // lpfnCompletionProc,
                NULL                    // lpdwTSPIOptions
                );

            LOG((TL_INFO,
                "TSPI_providerCheckForNewUser: deferred Init result=x%x",
                lResult
                ));
        }
    }

#endif

    return 0;
}


LONG
TSPIAPI
TSPI_providerConfig(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can configure this provider via lineConfigProvider(),
    // otherwise Telephon.cpl will not consider it configurable
    //

    // for this release, we do not implement provider UI functions
    return LINEERR_OPERATIONFAILED;
}


LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    ULONG_PTR   TempID,
    DWORD       dwDeviceID
    )
{
    PDRVLINE    pLine = GetLineFromID ((DWORD) TempID);

    if (NULL == pLine)
    {
        return LINEERR_BADDEVICEID;
    }

    pLine->dwDeviceIDLocal = dwDeviceID;

    if (pLine->dwXPIVersion == 0)
    {
        static REMOTE_ARG_TYPES argTypes[] =
        {
            Dword,
            LineID,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        };
        ULONG_PTR args[] =
        {
            (ULONG_PTR) pLine->pServer->hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) TAPI_VERSION1_0,
            (ULONG_PTR) TAPI_VERSION_CURRENT,
            (ULONG_PTR) &pLine->dwXPIVersion,
            (ULONG_PTR) &pLine->ExtensionID,
            (ULONG_PTR) sizeof (LINEEXTENSIONID)
        };
        REMOTE_FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 7, lNegotiateAPIVersion),
            args,
            argTypes
        };


        REMOTEDOFUNC (&funcArgs, "lineNegotiateAPIVersion");
    }


    return 0;
}


LONG
TSPIAPI
TSPI_providerCreatePhoneDevice(
    ULONG_PTR   TempID,
    DWORD       dwDeviceID
    )
{
    PDRVPHONE   pPhone = GetPhoneFromID ((DWORD) TempID);

    if (NULL == pPhone)
    {
        return PHONEERR_BADDEVICEID;
    }

    pPhone->dwDeviceIDLocal = dwDeviceID;

    if (pPhone->dwXPIVersion == 0)
    {
        static REMOTE_ARG_TYPES argTypes[] =
        {
            Dword,
            PhoneID,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        };
        ULONG_PTR args[] =
        {
            (ULONG_PTR) pPhone->pServer->hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) TAPI_VERSION1_0,
            (ULONG_PTR) TAPI_VERSION_CURRENT,
            (ULONG_PTR) &pPhone->dwXPIVersion,
            (ULONG_PTR) &pPhone->ExtensionID,
            (ULONG_PTR) sizeof (PHONEEXTENSIONID),
        };
        REMOTE_FUNC_ARGS funcArgs =
        {
            MAKELONG (PHONE_FUNC | SYNC | 7, pNegotiateAPIVersion),
            args,
            argTypes
        };


        REMOTEDOFUNC (&funcArgs, "phoneNegotiateAPIVersion");
    }

    return 0;
}


LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
    char        szProviderN[16], szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD       dwSize, dwTID, dwMultiProtocolSupport,
                dwConnectionOrientedOnly,
                dwRSPInitRpcTimeout;
    HKEY        hTelephonyKey;
    HKEY        hProviderNKey;
    DWORD       dwDataSize;
    DWORD       dwDataType;
    PWSTR       pszThingToPassToServer;
    LONG        lResult;
    HANDLE      hProcess;
    PDRVSERVER  pServer;
    PRSP_THREAD_INFO    pTls;
    DWORD       dwDisp;
    RSPSOCKET   socket;

    // 
    // Check ghInst to ensure DllMain(DLL_PROCESS_ATTACH) has been called properly
    //
    if ( NULL == ghInst )
    {
        return LINEERR_OPERATIONFAILED;
    }

    //
    // Init globals.
    //
    // If dwPermanentProviderID != 0xffffffff then we're being called
    // directly by TAPISRV, so we want to init all the globals and
    // keep going.
    //
    // Otherwise, we're being called from TSPI_providerCheckForNewUser,
    // and we only want to continue if we've not actually initialized
    // yet.
    //

    if (dwPermanentProviderID != 0xffffffff)
    {
        ghProvider = hProvider;
        gdwPermanentProviderID = dwPermanentProviderID;
        gpfnLineEventProc  = lpfnLineCreateProc;
        gpfnPhoneEventProc = lpfnPhoneCreateProc;

        gbInitialized = FALSE;
        
        TRACELOGREGISTER(_T("remotesp"));
    }

#if MEMPHIS
#else

    else if (gbInitialized)
    {
        return 0;
    }


    //
    // Is the client app running in the system account?  If so,
    // then try to impersonate the logged-on user, because the
    // system account doesn't have net privileges.  If no one is
    // logged in yet then we'll simply return success & no devices,
    // and if a user happens to log on later & run a tapi app
    // then we'll try to do init at that time (from within
    // TSPI_providerCheckForNewUser).
    //

    if (IsClientSystem())
    {
        LOG((TL_INFO,
            "TSPI_providerEnumDevices: Client is system account"
            ));

        LOG((TL_INFO,
            "  ...attempting logged-on-user impersonation"
            ));

        if (!GetCurrentlyLoggedOnUser (&hProcess))
        {
            LOG((TL_ERROR,
                "TSPI_providerEnumDevices: GetCurrentlyLoggedOnUser failed"
                ));

            LOG((TL_INFO,
                "  ...deferring initialization"
                ));

            gdwInitialNumLineDevices = 0;
            gdwInitialNumPhoneDevices = 0;
            return 0;
        }
    }
    else
    {
        hProcess = NULL;
    }

    gbInitialized = TRUE;

#endif

    gdwDrvServerKey = GetTickCount();

    if (!(gpCurrentInitContext = DrvAlloc (sizeof (RSP_INIT_CONTEXT))))
    {
        if (hProcess)
        {
            CloseHandle (hProcess);
        }
        return LINEERR_NOMEM;
    }

    gpCurrentInitContext->dwDrvServerKey = gdwDrvServerKey;

    InitializeListHead (&gpCurrentInitContext->ServerList);
    InitializeListHead (&gNptListHead);

    if (!(pszThingToPassToServer = DrvAlloc(
            MAX_COMPUTERNAME_LENGTH+1 + 256) // incl protseq 0-N, endpoint 0-N
            ))
    {
        if (hProcess)
        {
            CloseHandle (hProcess);
        }
        DrvFree (gpCurrentInitContext);
        return LINEERR_NOMEM;
    }

    gdwInitialNumLineDevices = gdwLineDeviceIDBase =
    gdwInitialNumPhoneDevices = gdwPhoneDeviceIDBase = 0;

    if (ERROR_SUCCESS !=
        RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszTelephonyKey,
        0,
        KEY_ALL_ACCESS,
        &hTelephonyKey
        ))
    {
        if (hProcess)
        {
            CloseHandle (hProcess);
        }
        DrvFree (gpCurrentInitContext);
        DrvFree (pszThingToPassToServer);
        return LINEERR_OPERATIONFAILED;
    }


    {
        DWORD       dwSize;

        dwSize = MAX_COMPUTERNAME_LENGTH + 1;

#ifdef PARTIAL_UNICODE
        {
            CHAR buf[MAX_COMPUTERNAME_LENGTH + 1];

            GetComputerName (buf, &dwSize);

            MultiByteToWideChar(
                GetACP(),
                MB_PRECOMPOSED,
                buf,
                dwSize,
                gszMachineName,
                dwSize
                );
       }
#else
        GetComputerNameW (gszMachineName, &dwSize);
#endif
    }

    wcscpy( pszThingToPassToServer, gszMachineName );
    wcscat( pszThingToPassToServer, L"\"");


    //
    // See if multi-protocol support is enabled in the registry
    // (for talking to post-TAPI 2.1 servers)
    //

    wsprintf (szProviderN, "Provider%d", gdwPermanentProviderID);

    RegCreateKeyEx(
        hTelephonyKey,
        szProviderN,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hProviderNKey,
        &dwDisp
        );

    dwDataSize = sizeof (dwMultiProtocolSupport);
    dwMultiProtocolSupport = 1;

    RegQueryValueEx(
        hProviderNKey,
        "MultiProtocolSupport",
        0,
        &dwDataType,
        (LPBYTE) &dwMultiProtocolSupport,
        &dwDataSize
        );

    dwDataSize = sizeof (dwConnectionOrientedOnly);
    dwConnectionOrientedOnly = 0;

    RegQueryValueEx(
        hProviderNKey,
        "ConnectionOrientedOnly",
        0,
        &dwDataType,
        (LPBYTE) &dwConnectionOrientedOnly,
        &dwDataSize
        );

    dwDataSize = sizeof (gdwRSPRpcTimeout);
    if (RegQueryValueEx(
        hTelephonyKey,
        "RspRpcTimeout",
        0,
        &dwDataType,
        (LPBYTE) &gdwRSPRpcTimeout,
        &dwDataSize
        ) != ERROR_SUCCESS)
    {
        gdwRSPRpcTimeout = 5 * 60 * 1000;        //  default to 5 minutes
    }
    if (gdwRSPRpcTimeout < 10 * 1000)
    {
        //  Do not allow a value less then 10 seconds
        gdwRSPRpcTimeout = 10 * 1000;
    }

    dwDataSize = sizeof (dwRSPInitRpcTimeout);
    if (RegQueryValueEx(
        hTelephonyKey,
        "RspInitRpcTimeout",
        0,
        &dwDataType,
        (LPBYTE) &dwRSPInitRpcTimeout,
        &dwDataSize
        ) != ERROR_SUCCESS)
    {
        dwRSPInitRpcTimeout = 10 * 1000;        //  default to 10 seconds
    }
    if (dwRSPInitRpcTimeout < 1000)
    {
        //  Do not allow this to be less than 1 second
        dwRSPInitRpcTimeout = 1000;
    }

    dwDataSize = sizeof (gdwMaxEventBufferSize);
    gdwMaxEventBufferSize = DEF_MAX_EVENT_BUFFER_SIZE;

    RegQueryValueEx(
        hProviderNKey,
        "MaxEventBufferSize",
        0,
        &dwDataType,
        (LPBYTE) &gdwMaxEventBufferSize,
        &dwDataSize
        );

    RegCloseKey (hProviderNKey);


    //
    // Init gEventHandlerThreadParams
    //

    gEventHandlerThreadParams.dwEventBufferTotalSize = 1024;
    gEventHandlerThreadParams.dwEventBufferUsedSize  = 0;

    if (!(gEventHandlerThreadParams.pEventBuffer = DrvAlloc(
            gEventHandlerThreadParams.dwEventBufferTotalSize
            )))
    {
        if (hProcess)
        {
            CloseHandle (hProcess);
        }
        DrvFree (gpCurrentInitContext);
        DrvFree (pszThingToPassToServer);
        CloseHandle (hTelephonyKey);
        return LINEERR_NOMEM;
    }

    gEventHandlerThreadParams.pDataIn  =
        gEventHandlerThreadParams.pDataOut =
            gEventHandlerThreadParams.pEventBuffer;

    if (!(gEventHandlerThreadParams.hEvent = CreateEvent(
            (LPSECURITY_ATTRIBUTES) NULL,   // no security attrs
            TRUE,                           // manual reset
            FALSE,                          // initially non-signaled
            NULL                            // unnamed
            )))
    {
        if (hProcess)
        {
            CloseHandle (hProcess);
        }
        DrvFree (gpCurrentInitContext);
        DrvFree (pszThingToPassToServer);
        CloseHandle (hTelephonyKey);
        DrvFree (gEventHandlerThreadParams.pEventBuffer);
        return LINEERR_NOMEM;
    }

    gEventHandlerThreadParams.dwMsgBufferTotalSize = 1024;

    if (!(gEventHandlerThreadParams.pMsgBuffer = DrvAlloc(
            gEventHandlerThreadParams.dwMsgBufferTotalSize
            )))
    {
        if (hProcess)
        {
            CloseHandle (hProcess);
        }
        DrvFree (gpCurrentInitContext);
        DrvFree (pszThingToPassToServer);
        CloseHandle (hTelephonyKey);
        DrvFree (gEventHandlerThreadParams.pEventBuffer);
        CloseHandle (gEventHandlerThreadParams.hEvent);
        return LINEERR_NOMEM;
    }


    //
    // Register the Rpc interface (leverage tapisrv's rpc server thread)
    //

    {
        BOOL            bFoundProtseq;
        DWORD           i;
        RPC_STATUS      status;
        unsigned char * pszSecurity         = NULL;
        unsigned int    cMaxCalls           = 20;
        unsigned char *aszProtseqs[] =
        {
            "ncacn_ip_tcp",
            "ncacn_spx",
            "ncacn_nb_nb",
            NULL
        };
        unsigned char *aszEndpoints[] =
        {
            "251",
            "1000",
            "251",
            NULL
        };
        const WCHAR *awszProtseqs[] =
        {
            L"ncacn_ip_tcp\"",
            L"ncacn_spx\"",
            L"ncacn_nb_nb\"",
            NULL
        };
        const WCHAR *awszEndpoints[] =
        {
            L"251",
            L"1000",
            L"251"
        };


        bFoundProtseq = FALSE;

        for (i = 0; aszProtseqs[i]; i++)
        {
            status = RpcServerUseProtseqEp(
                aszProtseqs[i],
                cMaxCalls,
                aszEndpoints[i],
                pszSecurity           // Security descriptor
                );

            LOG((TL_INFO,
                "RpcServerUseProtseqEp(%s) ret'd %d",
                aszProtseqs[i],
                status
                ));

            if (status == 0  ||  status == RPC_S_DUPLICATE_ENDPOINT)
            {
                wcscat (pszThingToPassToServer, awszProtseqs[i]);
                wcscat (pszThingToPassToServer, awszEndpoints[i]);
                bFoundProtseq = TRUE;

                if (!dwMultiProtocolSupport)
                {
                    //
                    // In TAPI 2.1 we'd only pass 1 proto/port pair to
                    // the server, & the string looked like :
                    //
                    //     <protseq>"<port>
                    //
                    // ... so break out of this loop now that we've found
                    // a valid proto/port pair
                    //

                    break;
                }
                else
                {
                    //
                    // Post-TAPI 2.1 servers support >=1 proto/port pair
                    // strings, & they look like:
                    //
                    //     <protseq1>"<port1>"..."<protseqN>"<portN>"
                    //
                    // ... so we need to append a dbl-quote (") char to
                    // the string, and then continue to look for any
                    // other valid proto/port pairs
                    //

                    wcscat (pszThingToPassToServer, L"\"");
                }
            }
        }

        if (!bFoundProtseq)
        {
            LOG((TL_ERROR,
                "TSPI_providerEnumDevices: fatal error, couldn't get a protseq"
                ));

            if (hProcess)
            {
                CloseHandle (hProcess);
            }
            DrvFree (gpCurrentInitContext);
            DrvFree (pszThingToPassToServer);
            CloseHandle (hTelephonyKey);
            DrvFree (gEventHandlerThreadParams.pEventBuffer);
            CloseHandle (gEventHandlerThreadParams.hEvent);
            return LINEERR_OPERATIONFAILED;
        }

        status = RpcServerRegisterIfEx(
            remotesp_ServerIfHandle,  // interface to register
            NULL,                     // MgrTypeUuid
            NULL,                     // MgrEpv; null means use default
            RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_SECURE_ONLY,
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
            NULL
            );

        if (status)
        {
            LOG((TL_INFO,
                "TSPI_providerEnumDevices: RpcServerRegisterIf ret'd %d",
                status
                ));
        }

        status = RpcServerRegisterAuthInfo(
            NULL,
            RPC_C_AUTHN_WINNT,
            NULL,
            NULL
            );

        if (status)
        {
            LOG((TL_INFO,
                "TSPI_providerEnumDevices: RpcServerRegisterAuthInfo " \
                    "returned %d",
                status
                ));
        }
    }


    //
    // Open a mailslot iff appropriate (use a semi-random name seeded
    // via process id)
    //

    if (!dwConnectionOrientedOnly)
    {
        DWORD dwPID = GetCurrentProcessId(), dwRandomNum;
        WCHAR szMailslotName[32];


        dwRandomNum = (65537 * dwPID * dwPID * dwPID) & 0x00ffffff;

        wsprintfW(
            gszMailslotName,
            L"\\\\%ws\\mailslot\\tapi\\tp%x",
            gszMachineName,
            dwRandomNum
            );

        wsprintfW(
            szMailslotName,
            L"\\\\.\\mailslot\\tapi\\tp%x",
            dwRandomNum
            );

        if ((gEventHandlerThreadParams.hMailslot = CreateMailslotW(
                szMailslotName,
                sizeof (DWORD),         // max msg size
                MAILSLOT_WAIT_FOREVER,
                (LPSECURITY_ATTRIBUTES) NULL

                )) == INVALID_HANDLE_VALUE)
        {
            LOG((TL_ERROR,
                "TSPI_providerEnumDevices: CreateMailslot failed, err=%d",
                GetLastError()
                ));

            goto no_mailslot;
        }
        else
        {
            RegOpenKeyEx(
                hTelephonyKey,
                szProviderN,
                0,
                KEY_ALL_ACCESS,
                &hProviderNKey
                );

            RegCloseKey (hProviderNKey);
        }

        if (gEventHandlerThreadParams.hMailslot != INVALID_HANDLE_VALUE)
        {
            gEventHandlerThreadParams.hMailslotEvent = CreateEvent(
                NULL,   // no security attrs
                FALSE,  // auto-reset
                FALSE,  // initially non-signaled
                NULL    // unnamed
                );

            if (!gEventHandlerThreadParams.hMailslotEvent)
            {
                LOG((TL_ERROR,
                    "TSPI_providerEnumDevices: CreateEvent failed, err=%d",
                    GetLastError()
                    ));

                goto no_mailslot;
            }
        }
    }
    else
    {

no_mailslot:

        LOG((TL_INFO,"TSPI_providerEnumDevices: doing connection-oriented only"));

        gEventHandlerThreadParams.hMailslot = INVALID_HANDLE_VALUE;
        gszMailslotName[0] = (WCHAR) 0;
    }


    //
    // Init globals
    //
    // NOTE: TAPI's xxxEvent & xxxCreate procs are currently one in the same
    //

    wsprintf (szProviderN, "Provider%d", gdwPermanentProviderID);

    gpLineLookup  = (PDRVLINELOOKUP) NULL;
    gpPhoneLookup = (PDRVPHONELOOKUP) NULL;

    RegOpenKeyEx(
        hTelephonyKey,
        szProviderN,
        0,
        KEY_ALL_ACCESS,
        &hProviderNKey
        );

    dwDataSize = sizeof(gdwRetryCount);
    gdwRetryCount = 2;

    RegQueryValueEx(
        hProviderNKey,
        "RetryCount",
        0,
        &dwDataType,
        (LPBYTE) &gdwRetryCount,
        &dwDataSize
        );

    dwDataSize = sizeof(gdwRetryTimeout);
    gdwRetryTimeout = 1000;

    RegQueryValueEx(
        hProviderNKey,
        "RetryTimeout",
        0,
        &dwDataType,
        (LPBYTE) &gdwRetryTimeout,
        &dwDataSize
        );

    gfCacheStructures = TRUE;
    dwDataSize = sizeof(gfCacheStructures);


    RegQueryValueEx(
        hProviderNKey,
        "CacheStructures",
        0,
        &dwDataType,
        (LPBYTE)&gfCacheStructures,
        &dwDataSize
        );

    if (gfCacheStructures)
    {
        gdwCacheForceCallCount = 5;
        dwDataSize = sizeof(gdwCacheForceCallCount);

        RegQueryValueEx(
            hProviderNKey,
            "CacheForceCallCount",
            0,
            &dwDataType,
            (LPBYTE)&gdwCacheForceCallCount,
            &dwDataSize
            );
    }

    dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName (szComputerName, &dwSize);


    //
    // Initialize Directory server lookup
    // we pass in a registry key in case the
    // Directory does not exist
    //

    if (!OpenServerLookup(hProviderNKey))
    {
        LOG((TL_ERROR, "TSPI_providerEnumDevices: OpenServerLookup() failed"));

fatal_error:

        if (hProcess)
        {
            CloseHandle (hProcess);
        }
        DrvFree (gpCurrentInitContext);
        DrvFree (pszThingToPassToServer);
        DrvFree (gEventHandlerThreadParams.pEventBuffer);
        CloseHandle (gEventHandlerThreadParams.hEvent);
        RegCloseKey (hProviderNKey);
        RegCloseKey (hTelephonyKey);

        return LINEERR_OPERATIONFAILED;
    }


#if MEMPHIS
#else

    if (!hProcess)
    {
        RPC_STATUS      status;

        status = RpcImpersonateClient(0);

        if (status != RPC_S_OK && status != RPC_S_NO_CALL_ACTIVE)
        {
            LOG((TL_ERROR, "RpcImpersonateClient failed, err %d", status));

            CloseLookup();

            goto fatal_error;
        }
    }
    else if (!SetProcessImpersonationToken(hProcess))
    {
        LOG((TL_ERROR, "SetProcessImpersonationToken failed"));

        CloseLookup();

        goto fatal_error;
    }

    if (pTls = GetTls())
    {
        pTls->bAlreadyImpersonated = TRUE;
    }

#endif

    if (SockStartup (&socket) != S_OK)
    {
        goto fatal_error;
    }

    //
    // Loop trying to attach to each server
    //

    while (1)
    {
        char                    szServerName[MAX_COMPUTERNAME_LENGTH+1];
        PCONTEXT_HANDLE_TYPE    phContext = NULL;
        BOOL                    bFromReg;


        if (!GetNextServer(szServerName, sizeof(szServerName), &bFromReg))
        {
            CloseLookup();
            break;
        }

        LOG((TL_INFO, "init: Server name='%s'", szServerName));

        if (!szServerName[0])
        {
            continue;
        }

        if (!lstrcmpi(szComputerName, szServerName))
        {
            LOG((TL_ERROR,"init:  ServerName is the same a local computer name"));
            LOG((TL_INFO,"   Ignoring this server"));
            continue;
        }

        //
        // Init the RPC connection
        //

        pServer = DrvAlloc (sizeof (DRVSERVER));

        pServer->pInitContext = gpCurrentInitContext;
        pServer->dwKey        = gdwDrvServerKey;

        lstrcpy (pServer->szServerName, szServerName);

        {
            RPC_STATUS  status;
            unsigned char * pszStringBinding = NULL;


            LOG((TL_INFO, "Creating binding..."));
            status = RpcStringBindingCompose(
                NULL,               // uuid
                "ncacn_np",         // prot
                szServerName,       // server name
                "\\pipe\\tapsrv",   // interface name
                NULL,               // options
                &pszStringBinding
                );

            if (status)
            {
                LOG((TL_ERROR,
                    "RpcStringBindingCompose failed: err=%d, szNetAddr='%s'",
                    status,
                    szServerName
                    ));
            }

            status = RpcBindingFromStringBinding(
                pszStringBinding,
                &hTapSrv
                );

            if (status)
            {
                LOG((TL_ERROR,
                    "RpcBindingFromStringBinding failed, err=%d, szBinding='%s'",
                    status,
                    pszStringBinding
                    ));
            }

            status = RpcStringFree (&pszStringBinding);

            if (status)
            {
                LOG((TL_ERROR, "RpcStringBindingFree failed: err=%d", status));
            }

            status = RpcBindingSetAuthInfo(
                hTapSrv,
                NULL,
                RPC_C_AUTHN_LEVEL_DEFAULT,
//#ifdef MEMPHIS
//                  RPC_C_AUTHN_DEFAULT,
//#else
                RPC_C_AUTHN_WINNT,
//#endif
                NULL,
                0
                );

            if (status)
            {
                LOG((TL_ERROR,
                    "RpcBindingSetAuthInfo failed, err=%d",
                    status
                    ));

                lResult = LINEERR_OPERATIONFAILED;
            }
            else
            {
                DWORD dwSize = 32;
                
                pServer->bSetAuthInfo = TRUE;

                //
                //  Per Bug 110291
                //  RPC team has added a timeout feature we can use in
                //  whistler build. In the past when a RPC server drops
                //  into a user mode debugger, all calling RPC clients
                //  will hang there indefinitely, this is very annoying
                //  in stress enviroment when we need to debug the server
                //  machine we would cause a large number of client breaks. 
                //  This could be fixed by using the RPC timeout feature.
                //  
                //  For RPC calls, we use a timeout value of 5 minutes based
                //  on RPC team recommendation (dwRSPRpcTimeout). But 
                //  during RemoteSP startup, we use a even shorter
                //  timeout value for RPC (dwRSPInitRpcTimeout), this could 
                //  cause us falsely declare a server dead when it is in fact not
                //  if the network connection is bad or the server is busy.
                //  But this would not be a problem because such a server
                //  will be inserted into the gNptListHead list and eventually
                //  recover by the NetworkPollThread.
                //
                //  Both the above timeout value can be configured from
                //  registry by using DWORD registry value of
                //      "RspRpcTimeout" & "RspInitRpcTimeout
                //  under HKLM\Software\Microsoft\Windows\CurrentVersion\Telephony
                //  They should be expressed in the unit of milli-seconds
                //
                RpcBindingSetOption (
                    hTapSrv,
                    RPC_C_OPT_CALL_TIMEOUT,
                    dwRSPInitRpcTimeout
                    );

                //
                // Set the global which RemoteSPAttach looks at to know
                // who the current server is (could pass this as arg to
                // ClientAttach, but this is easiest for now)
                //

                //
                //  RPC exception retry comments (xzhang):
                //
                //  In case we get a RPC exception with the ClientAttach,
                //  we were retrying for 3 times (by default) hoping the
                //  rpc problem could go away in the subsequent retries. This
                //  causes significant delay for remotesp start-up if one
                //  or more of the servers are down thus throwing exceptions.
                //  Since we have a NetworkPollThread taking care of those
                //  temporarily unavailable TAPI servers, we do not really
                //  need to retry here. Thus I removed the retry code.
                //

                gpCurrInitServer = pServer;

                RpcTryExcept
                {
                    pServer->dwSpecialHack = 0;

                    if (SockIsServerResponding(&socket, szServerName) != S_OK)
                    {
                        LOG((TL_ERROR,"init: %s is not responding", szServerName));
                        LOG((TL_INFO,"   Ignoring this server"));
                        lResult = RPC_S_SERVER_UNAVAILABLE;
                    }
                    else
                    {
                        LOG((TL_INFO, "Calling ClientAttach..."));
                        lResult = ClientAttach(
                            &phContext,
                            0xffffffff, // dwProcessID, -1 implies remotesp
                            &pServer->dwSpecialHack,
                            gszMailslotName,
                            pszThingToPassToServer //  gszMachineName
                            );
                        LOG((TL_INFO, "ClientAttach returned..."));
                    }
                        
                    if (lResult != 0)
                    {
                        LogRemoteSPError(pServer->szServerName, 
                                        ERROR_REMOTESP_ATTACH, lResult, 0,
                                        FALSE);
                    }
                    else
                    {
                        LogRemoteSPError(pServer->szServerName, 
                                        ERROR_REMOTESP_NONE, 0, 0,
                                        FALSE);
                    }
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    LogRemoteSPError(pServer->szServerName, 
                                    ERROR_REMOTESP_EXCEPTION,
                                    RpcExceptionCode(), 0, FALSE);
                    //
                    // Go onto next server.  The poll thread
                    // will take care of things...
                    //

                    LOG((TL_ERROR,
                        "ClientAttach failed - check server name"
                        ));

                    lResult = LINEERR_OPERATIONFAILED;
                }
                RpcEndExcept
            }

            pServer->hTapSrv = hTapSrv;
            
            if ( 0 != lResult )
            {
                //
                // RPC attach failed.  We'll start a thread
                // and poll for it.  When it works, we can add
                // the phones/lines dynamically.
                // In the meantime, this thread will continue
                // to contact other servers.
                //

                RpcBindingSetOption (
                    hTapSrv,
                    RPC_C_OPT_CALL_TIMEOUT,
                    gdwRSPRpcTimeout
                    );
                InsertTailList (&gNptListHead, &pServer->ServerList);
                continue;
            }


            //
            //  Enable all events for remotesp
            //
            pServer->phContext = phContext;
            RSPSetEventFilterMasks (
                pServer,
                TAPIOBJ_NULL,
                (LONG_PTR)NULL,
                (ULONG64)EM_ALL
                );

            //
            // Now that we have contacted this server, init it and
            // add the phones/lines.
            //

            FinishEnumDevices(
                pServer,
                phContext,
                lpdwNumLines,
                lpdwNumPhones,
                (dwPermanentProviderID == 0xffffffff ? FALSE : TRUE),
                bFromReg
                );

        }
    }

    SockShutdown (&socket);

    //
    // If we successfully attached to all servers then clean up,
    // otherwise start the poll thread
    //

    if (gpszThingToPassToServer)
    {
        DrvFree (gpszThingToPassToServer);
    }
    gpszThingToPassToServer = pszThingToPassToServer;

    TapiEnterCriticalSection ( &gCriticalSection );

    if (!IsListEmpty (&gNptListHead) && !ghNetworkPollThread)
    {
        ghNptShutdownEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

        if (!(ghNetworkPollThread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) NetworkPollThread,
                (LPVOID) pszThingToPassToServer,
                0,
                &dwTID
                )))
        {
            LOG((TL_ERROR, "Unable to create poll thread! Argh!"));
            CloseHandle (ghNptShutdownEvent);

            while (!IsListEmpty (&gNptListHead))
            {
                LIST_ENTRY  *pEntry = RemoveHeadList (&gNptListHead);

                DrvFree(
                    CONTAINING_RECORD (pEntry, DRVSERVER, ServerList)
                    );
            }

        }
    }

    TapiLeaveCriticalSection( &gCriticalSection );

    RegCloseKey (hProviderNKey);
    RegCloseKey (hTelephonyKey);

    if (hProcess)
    {
        ClearImpersonationToken();
        CloseHandle (hProcess);
    }
    else
    {
        RevertToSelf();
    }

    if (pTls)
    {
        pTls->bAlreadyImpersonated = FALSE;
    }

    //
    // If dwPermanentProviderID == 0xffffffff we're being called by
    // TSPI_providerCheckForNewUser, so return a special value of 1
    // so that it'll know to follow up with a TSPI_providerInit.
    //
    // Otherwise, we're being called directly from TAPI so simply
    // return 0 to indicate success.
    //

    return (dwPermanentProviderID == 0xffffffff ? 1 : 0);
}


LONG
TSPIAPI
TSPI_providerFreeDialogInstance(
    HDRVDIALOGINSTANCE  hdDlgInst
    )
{

    return 0;
}


LONG
TSPIAPI
TSPI_providerGenericDialogData(
    ULONG_PTR           ObjectID,
    DWORD               dwObjectType,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
    LPDWORD             lpBuffer;

    REMOTE_ARG_TYPES argTypes[] =
    {
        LineID,
        Dword,
        lpSet_SizeToFollow,
        Size,
        lpGet_SizeToFollow,
        Size
    };

    ULONG_PTR args[] =
    {
        (ULONG_PTR) ObjectID,
        (ULONG_PTR) dwObjectType,
        (ULONG_PTR) lpParams,
        (ULONG_PTR) dwSize,
        (ULONG_PTR) lpParams,
        (ULONG_PTR) dwSize
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, xUIDLLCallback),
        args,
        argTypes
    };

    // first check to see if this is a message to ourselves.

    lpBuffer = (LPDWORD) lpParams;

    if ((dwSize > (2 * sizeof(DWORD))) &&
        (lpBuffer[0] == RSP_MSG) &&
        (lpBuffer[1] == RSP_MSG_UIID))
    {
        // if it is, we're looking for the real provider ui dll.  fill in the
        // buffer and return

        // note that we only handle one sp here, but it may be easy to handle multiple
        // by sending in additional info in the buffer ( like the line ID or something)

        wcscpy ((LPWSTR)(lpBuffer+2), gszRealSPUIDLL);

        return 0;
    }

    switch (dwObjectType)
    {
    case TUISPIDLL_OBJECT_LINEID:

        // argTypes[0] already set correctly, just break
        break;

    case TUISPIDLL_OBJECT_PHONEID:

        argTypes[0] = PhoneID;
        break;

    case TUISPIDLL_OBJECT_PROVIDERID:
    default: // case TUISPIDLL_OBJECT_DIALOGINSTANCE:

        break;
    }

    return (REMOTEDOFUNC (&funcArgs, "UIDLLCallback"));
}


LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    DWORD   i;


    //
    // Init globals
    //
    // If dwPermanentProviderID != 0xffffffff then we're being called
    // directly by TAPISRV, so we want to init all the globals and
    // keep going only if the gbInitialized flag is set (implying
    // that we've gone thru all the code in EnumDevices).
    //
    // Otherwise, we're being called from TSPI_providerCheckForNewUser.
    //

    if (dwPermanentProviderID != 0xffffffff)
    {
        gdwLineDeviceIDBase  = dwLineDeviceIDBase;
        gdwPhoneDeviceIDBase = dwPhoneDeviceIDBase;

        gpfnCompletionProc = lpfnCompletionProc;

        *lpdwTSPIOptions = 0;

#if MEMPHIS
#else
        if (!gbInitialized)
        {
            return 0;
        }
#endif

    }


    //
    // Adjust the .dwDeviceIDLocal values for all the initial devices
    // now that we know the device id bases
    //

    for (i = 0; i < gdwInitialNumLineDevices; i++)
    {
        gpLineLookup->aEntries[i].dwDeviceIDLocal = dwLineDeviceIDBase + i;
    }

    for (i = 0; i < gdwInitialNumPhoneDevices; i++)
    {
        gpPhoneLookup->aEntries[i].dwDeviceIDLocal = dwPhoneDeviceIDBase + i;
    }


    //
    // Start EventHandlerThread
    //

    gEventHandlerThreadParams.bExit = FALSE;

    if (!(gEventHandlerThreadParams.hThread = CreateThread(
            (LPSECURITY_ATTRIBUTES) NULL,
            0,
            (LPTHREAD_START_ROUTINE) EventHandlerThread,
            NULL,
            0,
            &i      // &dwThreadID
            )))
    {
        LOG((TL_ERROR,
            "CreateThread('EventHandlerThread') failed, err=%d",
            GetLastError()
            ));

        DrvFree (gEventHandlerThreadParams.pEventBuffer);
        CloseHandle (gEventHandlerThreadParams.hEvent);

        return LINEERR_OPERATIONFAILED;
    }

    return 0;
}


LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can add this provider via lineAddProvider(), otherwise
    // Telephon.cpl will not consider it installable
    //
    //

    return 0;

}


LONG
TSPIAPI
TSPI_providerRemove(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can remove this provider via lineRemoveProvider(), otherwise
    // Telephon.cpl will not consider it removable
    //

    return 0;
}


LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    DWORD       i;
    PDRVSERVER  pServer;
    RPC_STATUS  status;
    LIST_ENTRY  *pEntry;


    //
    // If the gbInitialized flag is not set then we never fully
    // initialized because no client process with user (as opposed
    // to system) privileges ever attached to tapisrv and/or there
    // was no logged on user to impersonate.  So we can just return 0.
    //

#if MEMPHIS
#else

    if (!gbInitialized)
    {
        return 0;
    }

#endif


    //
    // Set the flag instructing the EventHandlerThread to terminate
    //

 
    gEventHandlerThreadParams.bExit = TRUE;


    //
    // If there's a network poll thread running then tell it to exit
    // & wait for it to terminate
    //

    TapiEnterCriticalSection ( &gCriticalSection );

    if (ghNetworkPollThread)
    {
        SetEvent (ghNptShutdownEvent);
        TapiLeaveCriticalSection( &gCriticalSection );
        WaitForSingleObject (ghNetworkPollThread, INFINITE);
        TapiEnterCriticalSection ( &gCriticalSection );
        CloseHandle (ghNetworkPollThread);
        ghNetworkPollThread = NULL;
    }

    TapiLeaveCriticalSection( &gCriticalSection );

    if (gpszThingToPassToServer)
    {
        DrvFree (gpszThingToPassToServer);
        gpszThingToPassToServer = NULL;
    }

    //
    // Tell the event handler thread to exit wait for it to terminate
    //

    while (WaitForSingleObject (gEventHandlerThreadParams.hThread, 0) !=
                WAIT_OBJECT_0)
    {
        SetEvent (gEventHandlerThreadParams.hEvent);
        Sleep (50);
    }

    CloseHandle (gEventHandlerThreadParams.hThread);


    //
    // Send detach to each server
    //

#if MEMPHIS
#else
    status = RpcImpersonateClient(0);

    if (status != RPC_S_OK)
    {
        LOG((TL_ERROR, "RpcImpersonateClient failed, err=%d", status));
        // fall thru
    }
#endif

    TapiEnterCriticalSection(&gCriticalSection);

    pEntry = gpCurrentInitContext->ServerList.Flink;

    while (pEntry != &gpCurrentInitContext->ServerList)
    {
        DWORD       dwRetryCount = 0;


        pServer = CONTAINING_RECORD (pEntry, DRVSERVER, ServerList);

        do
        {
            RpcTryExcept
            {
                ClientDetach (&pServer->phContext);

                dwRetryCount = gdwRetryCount;
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                if (dwRetryCount++ < gdwRetryCount)
                {
                    Sleep (gdwRetryTimeout);
                }
            }
            RpcEndExcept

        } while (dwRetryCount < gdwRetryCount);

        pEntry = pEntry->Flink;
    }

    TapiLeaveCriticalSection(&gCriticalSection);

    RpcRevertToSelf();


    //
    // Wait a period of time for all the expected rundowns to occur.
    // If they all occur then free up context info for this
    // provider initialization instance; otherwise,  do a LoadLibrary
    // on ourself (only once) to prevent the possiblity of the
    // rundown routine getting called after the DLL has been unloaded,
    // and insert the current init context in a "stale" queue, removing
    // & freeing the oldest item in the queue if we've reached a
    // pre-determined queue limit
    //

    #define MAX_RSP_WAIT_TIME 2000
    #define RSP_WAIT_INCR 250

    for(
        i = 0;
        ((gpCurrentInitContext->dwNumRundownsExpected != 0) &&
            (i < MAX_RSP_WAIT_TIME));
        i += RSP_WAIT_INCR
        )
    {
        Sleep (RSP_WAIT_INCR);
    }

    if (i < MAX_RSP_WAIT_TIME)
    {
        FreeInitContext (gpCurrentInitContext);
    }
    else
    {
        if (!gbLoadedSelf)
        {
            LoadLibrary (MODULE_NAME);
            gbLoadedSelf = TRUE;
        }

        gpCurrentInitContext->pNextStaleInitContext = gpStaleInitContexts;
        gpStaleInitContexts = gpCurrentInitContext;

        LOG((TL_INFO, "Queued stale init context x%x", gpCurrentInitContext));

        #define RSP_MAX_NUM_STALE_INIT_CONTEXTS 4

        if (gdwNumStaleInitContexts >= RSP_MAX_NUM_STALE_INIT_CONTEXTS)
        {
            PRSP_INIT_CONTEXT   pPrevStaleInitContext;


            while (gpCurrentInitContext->pNextStaleInitContext)
            {
                pPrevStaleInitContext = gpCurrentInitContext;

                gpCurrentInitContext =
                    gpCurrentInitContext->pNextStaleInitContext;
            }

            pPrevStaleInitContext->pNextStaleInitContext = NULL;

            FreeInitContext (gpCurrentInitContext);

            LOG((TL_INFO, "Freed stale init context x%x", gpCurrentInitContext));
        }
        else
        {
            gdwNumStaleInitContexts++;
        }
    }


    //
    // Unregister out rpc server interface
    //

    status = RpcServerUnregisterIf(
        remotesp_ServerIfHandle,    // interface to register
        NULL,                       // MgrTypeUuid
        TRUE                        // wait for calls to complete
        );

    LOG((TL_INFO, "RpcServerUnregisterIf ret'd %d", status));


    //
    // Clean up resources
    //

    DrvFree (gEventHandlerThreadParams.pEventBuffer);
    CloseHandle (gEventHandlerThreadParams.hEvent);


    //
    // Note: We intentionally leak the hMailslot for now, because the
    //       docs say that the mailslot is not actually destroyed
    //       until the process exits.  Since service providers can get
    //       loaded & unloaded alot without tapisrv.exe ever exiting,
    //       we could wind up with alot of mailslots laying around.
    //
    //       Closing this hMailSlot to avoid dependance on the registry to
    //       remember the hMailSlot.
    //

    if (gEventHandlerThreadParams.hMailslot != INVALID_HANDLE_VALUE)
    {
        CloseHandle (gEventHandlerThreadParams.hMailslot);
        CloseHandle (gEventHandlerThreadParams.hMailslotEvent);
    }

    DrvFree (gEventHandlerThreadParams.pMsgBuffer);


    //
    // Manually walk the handle table, completing any pending async
    // requests with an error.  No need to call any post-processing
    // procs, since any calls would've been torn down already, and
    // the other non-MakeCall-style post processing procs simply do
    // CopyMemory, etc.
    //
    // Also, if the gbLoadedSelf flag is set, then we want to deref
    // active handles left in the table, because the table is
    // only freed in DLL_PROCESS_DETACH (which won't get called now)
    // and we don't want to end up leaking handles.
    //

    {
        PHANDLETABLEENTRY   pEntry, pEnd;
        PHANDLETABLEHEADER  pHeader = ghHandleTable;


        EnterCriticalSection (&pHeader->Lock);
        pEnd = pHeader->Table + pHeader->NumEntries;

        for (pEntry = pHeader->Table; pEntry != pEnd; pEntry++)
        {
            if (pEntry->Handle)
            {
                PASYNCREQUESTCONTEXT    pContext = pEntry->Context.C;

                if (pEntry->Context.C2 == (LPVOID) 1)
                {
                    DereferenceObject (
                        ghHandleTable, 
                        pEntry->Handle, 
                        (DWORD)pEntry->ReferenceCount
                        );
                }
                else if (pContext == (PASYNCREQUESTCONTEXT) -1  ||
                    pContext->dwKey == DRVASYNC_KEY)
                {
                    (*gpfnCompletionProc)(
                        DWORD_CAST((ULONG_PTR)pEntry->Context.C2,__FILE__,__LINE__),
                        LINEERR_OPERATIONFAILED
                        );

                    if (gbLoadedSelf)
                    {
                        DereferenceObject(
                            ghHandleTable,
                            pEntry->Handle,
                            (DWORD)pEntry->ReferenceCount
                            );
                    }
                }
            }
        }
        LeaveCriticalSection (&pHeader->Lock);
    }


    //
    // Free the lookup tables
    //

    while (gpLineLookup)
    {
        PDRVLINELOOKUP  pNextLineLookup = gpLineLookup->pNext;


        DrvFree (gpLineLookup);

        gpLineLookup = pNextLineLookup;
    }

    while (gpPhoneLookup)
    {
        PDRVPHONELOOKUP pNextPhoneLookup = gpPhoneLookup->pNext;


        DrvFree (gpPhoneLookup);

        gpPhoneLookup = pNextPhoneLookup;
    }

    TRACELOGDEREGISTER();

    return 0;
}


LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR   lpszUIDLLName
    )
{

    LONG            lResult;
    PDRVSERVER      pServer     = NULL;
    LPDWORD         lpdwHold    = (LPDWORD) lpszUIDLLName;

    // we've put a special case into tapisrv to give this addtional info
    // to remotesp.  the buffer passed in is in the following
    // format

    // DWORD   dwKey        == RSP_MSG  tells us that TAPISRV did fill in this info
    // DWORD   dwDeviceID   == device ID of whatever
    // DWORD   dwType       == TUISPIDLL_ type

    // this way, remotesp can intelligently rpc over to the
    // telephony server.
    BOOL            bOK         = (lpdwHold[0] == RSP_MSG);
    DWORD           dwDeviceID  = (bOK ? lpdwHold[1] : 0);
    DWORD           dwType      = (bOK ? lpdwHold[2] : TUISPIDLL_OBJECT_LINEID);


    // we're being asked for the ui dll name
    // we will return remotesp, but at this point we'll try to find out the
    // real ui dll

    // note that we only only one service provider here, but we may be able
    // to add support for additonal ones by saving the ui dll name on
    // a per provider basis
    REMOTE_ARG_TYPES argTypes[] =
    {
        LineID,
        Dword,
        lpGet_SizeToFollow,
        Size
    };
    ULONG_PTR args[] =
    {
        (ULONG_PTR) dwDeviceID,
        (ULONG_PTR) dwType,
        (ULONG_PTR) gszRealSPUIDLL,
        (ULONG_PTR) MAX_PATH
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, xGetUIDllName),
        args,
        argTypes
    };


    if (bOK)
    {
        // need to get the server first

        if (dwType == TUISPIDLL_OBJECT_LINEID)
        {
            if (gpLineLookup)
            {
                PDRVLINE    pLine;


                if ((pLine = GetLineFromID (dwDeviceID)))
                {
                    pServer  = pLine->pServer;
                }
            }
        }
        else if (dwType == TUISPIDLL_OBJECT_LINEID)
        {
            argTypes[0] = PhoneID;

            if (gpPhoneLookup)
            {
                PDRVPHONE   pPhone;


                if ((pPhone = GetPhoneFromID (dwDeviceID)))
                {
                    pServer  = pPhone->pServer;
                }
            }
        }
        else
        {
        }


        // call over.
        // in the case of the telephony cpl, pLine has not been initialized yet,
        // so we have to do this check.  in that case, we won't have a
        // gszuidllname, but it's OK since the cpl only calls provider UI functions
        // which remotesp can handle by itself.

        if (pServer)
        {
            LOG((TL_INFO, "Calling GetUIDllName in server"));

            lResult = REMOTEDOFUNC (&funcArgs, "GetUIDllName");

        }
    }


    // always return remotesp

    wcscpy(lpszUIDLLName, L"remotesp.tsp");

    return 0;
}


HINSTANCE
TAPILoadLibraryW(
    PWSTR   pLibrary
    )
{
    PSTR        pszTempString;
    HINSTANCE   hResult;
    DWORD       dwSize;


    dwSize = WideCharToMultiByte(
        GetACP(),
        0,
        pLibrary,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    if ( NULL == (pszTempString = LocalAlloc( LPTR, dwSize )) )
    {
        LOG((TL_ERROR, "Alloc failed - LoadLibW - 0x%08lx", dwSize));
        return NULL;
    }

    WideCharToMultiByte(
        GetACP(),
        0,
        pLibrary,
        dwSize,
        pszTempString,
        dwSize,
        NULL,
        NULL
        );


   hResult = LoadLibrary (pszTempString);

   LocalFree (pszTempString);

   return hResult;
}



//
// ---------------------------- TUISPI_xxx funcs ------------------------------
//

LONG
LoadUIDll(
    DWORD               dwDeviceID,
    DWORD               dwDeviceType,
    HANDLE              *phDll,
    CHAR                *pszTUISPI_xxx,
    TUISPIPROC          *ppfnTUISPI_xxx,
    TUISPIDLLCALLBACK   lpfnUIDLLCallback
    )
{
    //
    // At this point, remotesp is loaded as a ui dll in tapi32.dll's
    // (& the client's) context, so we have none of the global info
    // normally available.  Use the ui callback to call into the
    // other instance of remotesp to get the real ui dll name.

    //
    // Note we only handle on sp here, but can easily add in more
    // info when we handle more than one
    //

    LPDWORD         lpBuffer;


    if (!(lpBuffer = DrvAlloc (MAX_PATH + 2 * sizeof (DWORD))))
    {
        return (dwDeviceType == TUISPIDLL_OBJECT_PHONEID ?
                    PHONEERR_NOMEM : LINEERR_NOMEM);
    }

    // format is
    // DWORD        dwKey
    // DWORD        dwMsgType
    // LPWSTR       szUIDLLName (returned)

    lpBuffer[0] = RSP_MSG;

    lpBuffer[1] = RSP_MSG_UIID;

    lpfnUIDLLCallback(
        dwDeviceID,
        dwDeviceType,
        lpBuffer,
        MAX_PATH + 2 * sizeof (DWORD)
        );

    *phDll = TAPILoadLibraryW((LPWSTR)(lpBuffer + 2));

    DrvFree (lpBuffer);

    if (!*phDll)
    {
        LOG((TL_ERROR, "LoadLibrary failed in the LoadUIDll"));

        return (dwDeviceType == TUISPIDLL_OBJECT_PHONEID ?
                    PHONEERR_OPERATIONFAILED : LINEERR_OPERATIONFAILED);
    }

    if (!(*ppfnTUISPI_xxx = (TUISPIPROC) GetProcAddress(
            *phDll,
            pszTUISPI_xxx
            )))
    {
        LOG((TL_ERROR, "GetProcAddress failed on LoadUIDll"));

        FreeLibrary(*phDll);

        return (dwDeviceType == TUISPIDLL_OBJECT_PHONEID ?
                    PHONEERR_OPERATIONFAILED : LINEERR_OPERATIONFAILED);
    }

    return 0;
}


LONG
TSPIAPI
TUISPI_lineConfigDialog(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
    TUISPIPROC      pfnTUISPI_lineConfigDialog;
    HANDLE          hDll;
    LONG            lResult;


    lResult = LoadUIDll(
        dwDeviceID,
        TUISPIDLL_OBJECT_LINEID,
        &hDll,
        "TUISPI_lineConfigDialog",
        &pfnTUISPI_lineConfigDialog,
        lpfnUIDLLCallback
        );

    if (lResult)
    {
        return lResult;
    }


    LOG((TL_INFO, "Calling TUISPI_lineConfigDialog"));

    lResult = (*pfnTUISPI_lineConfigDialog)(
        lpfnUIDLLCallback,
        dwDeviceID,
        hwndOwner,
        lpszDeviceClass
        );

    FreeLibrary (hDll);

    return lResult;

}


LONG
TSPIAPI
TUISPI_lineConfigDialogEdit(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{

    TUISPIPROC      pfnTUISPI_lineConfigDialogEdit;
    HANDLE          hDll;
    LONG            lResult;


    lResult = LoadUIDll(
        dwDeviceID,
        TUISPIDLL_OBJECT_LINEID,
        &hDll,
        "TUISPI_lineConfigDialogEdit",
        &pfnTUISPI_lineConfigDialogEdit,
        lpfnUIDLLCallback
        );

    if (lResult)
    {
        return lResult;
    }

    LOG((TL_INFO, "Calling TUISPI_lineConfigDialogEdit"));

    lResult = (*pfnTUISPI_lineConfigDialogEdit)(
        lpfnUIDLLCallback,
        dwDeviceID,
        hwndOwner,
        lpszDeviceClass,
        lpDeviceConfigIn,
        dwSize,
        lpDeviceConfigOut
        );

    FreeLibrary(hDll);

    return lResult;
}


LONG
TSPIAPI
TUISPI_phoneConfigDialog(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
    TUISPIPROC      pfnTUISPI_phoneConfigDialog;
    HANDLE          hDll;
    LONG            lResult;


    lResult = LoadUIDll(
        dwDeviceID,
        TUISPIDLL_OBJECT_PHONEID,
        &hDll,
        "TUISPI_phoneConfigDialog",
        &pfnTUISPI_phoneConfigDialog,
        lpfnUIDLLCallback
        );

    if (lResult)
    {
        return lResult;
    }

    LOG((TL_INFO, "Calling TUISPI_phoneConfigDialog"));

    lResult = (*pfnTUISPI_phoneConfigDialog)(
        lpfnUIDLLCallback,
        dwDeviceID,
        hwndOwner,
        lpszDeviceClass
        );

    FreeLibrary(hDll);

    return lResult;
}


LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    return LINEERR_OPERATIONFAILED;
    /*
    DialogBoxParam(
        ghInst,
        MAKEINTRESOURCE(IDD_REMOTESPCONFIG),
        hwndOwner,
        (DLGPROC) ConfigDlgProc,
        (LPARAM) dwPermanentProviderID
        );

    return 0;
    */
}

/*
LONG
TSPIAPI
TUISPI_providerGenericDialog(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize,
    HANDLE              hEvent
    )
{
    TUISPIPROC      pfnTUISPI_providerGenericDialog;
    HANDLE          hDll;
    LONG            lResult;


    lResult = LoadUIDll(
        (HWND) 0,
        0,          // hardcode 0
        TUISPIDLL_OBJECT_LINEID,
        &hDll,
        "TUISPI_providerGenericDialog",
        &pfnTUISPI_providerGenericDialog
        );

    if (lResult == 0)
    {
        LOG((TL_INFO, "Calling TUISPI_providerGenericDialog"));

        lResult = (*pfnTUISPI_providerGenericDialog)(
            lpfnUIDLLCallback,
            htDlgInst,
            lpParams,
            dwSize,
            hEvent
            );

        FreeLibrary(hDll);
    }
    else
    {
        LOG((TL_ERROR, "Failed to load UI DLL"));
    }

    return lResult;

}


LONG
TSPIAPI
TUISPI_providerGenericDialogData(
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{

    TUISPIPROC      pfnTUISPI_providerGenericDialogData;
    HANDLE          hDll;
    LONG            lResult;


    DBGOUT((
        3,
        "TUISPI_providerGenericDialogData: enter (lpParams=x%x, dwSize=x%x)",
        lpParams,
        dwSize
        ));

    lResult = LoadUIDll(
        (HWND) 0,
        0,
        TUISPIDLL_OBJECT_LINEID,
        &hDll,
        "TUISPI_providerGenericDialogData",
        &pfnTUISPI_providerGenericDialogData
        );

    if (lResult == 0)
    {
        LOG((TL_INFO, "Calling TUISPI_providerGenericDialogData"));

        lResult = (*pfnTUISPI_providerGenericDialogData)(
            htDlgInst,
            lpParams,
            dwSize
            );

        FreeLibrary(hDll);
    }
    else
    {
        LOG((TL_ERROR, "Failed to load UI DLL"));
    }

    return lResult;


}
*/

//
//  GetRSPID
//      To return the provider ID of remotesp if any. Otherwise
//  return zero
//
DWORD
GetRSPID (
    )
{
    DWORD               dwRet = 0;
    LONG                (WINAPI *pfnGetProviderList)();
    DWORD               dwTotalSize, i;
    HINSTANCE           hTapi32 = NULL;
    LPLINEPROVIDERLIST  pProviderList = NULL;
    LPLINEPROVIDERENTRY pProviderEntry;


    //
    // Load Tapi32.dll & get a pointer to the lineGetProviderList
    // func.  We could just statically link with Tapi32.lib and
    // avoid the hassle (and this wouldn't have any adverse
    // performance effects because of the fact that this
    // implementation has a separate ui dll that runs only on the
    // client context), but a provider who implemented these funcs
    // in it's TSP module would want to do an explicit load like
    // we do here to prevent the performance hit of Tapi32.dll
    // always getting loaded in Tapisrv.exe's context.
    //

    if (!(hTapi32 = LoadLibrary ("tapi32.dll")))
    {
        LOG((TL_ERROR,
            "LoadLibrary(tapi32.dll) failed, err=%d",
            GetLastError()
            ));
        goto ExitHere;
    }

    if (!((FARPROC) pfnGetProviderList = GetProcAddress(
            hTapi32,
            (LPCSTR) "lineGetProviderList"
            )))
    {
        LOG((TL_ERROR,
            "GetProcAddr(lineGetProviderList) failed, err=%d",
            GetLastError()
            ));
        goto ExitHere;
    }


    //
    // Loop until we get the full provider list
    //

    dwTotalSize = sizeof (LINEPROVIDERLIST);

    while (1)
    {
        if (!(pProviderList = DrvAlloc (dwTotalSize)))
        {
            goto ExitHere;
        }
        pProviderList->dwTotalSize = dwTotalSize;

        if (((*pfnGetProviderList)(0x00020000, pProviderList)) != 0)
        {
            goto ExitHere;
        }

        if (pProviderList->dwNeededSize > pProviderList->dwTotalSize)
        {
            dwTotalSize = pProviderList->dwNeededSize;
            DrvFree (pProviderList);
        }
        else
        {
            break;
        }
    }


    //
    // Inspect the provider list entries to see if this provider
    // is already installed
    //

    pProviderEntry = (LPLINEPROVIDERENTRY) (((LPBYTE) pProviderList) +
        pProviderList->dwProviderListOffset);
    for (i = 0; i < pProviderList->dwNumProviders; i++)
    {
        char   *pszInstalledProviderName = ((char *) pProviderList) +
                    pProviderEntry->dwProviderFilenameOffset,
               *psz;

        if ((psz = strrchr (pszInstalledProviderName, '\\')))
        {
            pszInstalledProviderName = psz + 1;
        }
        if (lstrcmpi (pszInstalledProviderName, "remotesp.tsp") == 0)
        {
            dwRet = pProviderEntry->dwPermanentProviderID;
            goto ExitHere;
        }
        pProviderEntry++;
    }

ExitHere:
    if (hTapi32)
    {
        FreeLibrary (hTapi32);
    }
    if (pProviderList)
    {
        DrvFree (pProviderList);
    }
    return dwRet;
}

LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    if (GetRSPID())
    {
        //  Return failure if it is already installed
        //  to prevent duplication
        return TAPIERR_PROVIDERALREADYINSTALLED;
    }
    else
    {
        return S_OK;
    }
}


LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    DWORD       dwProviderID = GetRSPID();
    LONG        lResult = S_OK;
    char        buf[32];
    HKEY        hTelephonyKey;

    if (dwProviderID == 0 || dwProviderID != dwPermanentProviderID)
    {
        //  return failure if remotesp is not installed
        lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    //
    // Clean up our ProviderN section
    //
    wsprintf (buf, "Provider%d", dwPermanentProviderID);
    if (RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            gszTelephonyKey,
            0,
            KEY_ALL_ACCESS,
            &hTelephonyKey

            ) == ERROR_SUCCESS)
    {
        SHDeleteKey (hTelephonyKey, buf);
        RegCloseKey (hTelephonyKey);
    }
    else
    {
        lResult = LINEERR_OPERATIONFAILED;
    }

ExitHere:
    return lResult;
}


//
// ------------------------ Private support routines --------------------------
//

#if DBG
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[128] = "REMOTESP: ";
        va_list ap;


        va_start(ap, lpszFormat);
        wvsprintf (&buf[10], lpszFormat, ap);
        lstrcatA (buf, "\n");
        OutputDebugStringA (buf);
        va_end(ap);
    }
}
#endif


LONG
AddLine(
    PDRVSERVER          pServer,
    DWORD               dwLocalID,
    DWORD               dwServerID,
    BOOL                bInit,
    BOOL                bNegotiate,
    DWORD               dwAPIVersion,
    LPLINEEXTENSIONID   pExtID
    )
{
    PDRVLINE        pLine;
    PDRVLINELOOKUP  pLineLookup;
    LONG            lResult = 0;
    BOOL            bLeaveCriticalSection = FALSE;
    LINEDEVCAPS     lineDevCaps;
    DWORD           dwPermLineID;
    int             iEntry;

    //
    //  Get the permanent line device ID
    //
    static REMOTE_ARG_TYPES argTypes[] =
    {
        lpServer,
        Dword,
        Dword,
        Dword,
        Dword,
        lpGet_Struct
    };
    
    ULONG_PTR args[] =
    {
        (ULONG_PTR) pServer,
        (ULONG_PTR) pServer->hLineApp,
        (ULONG_PTR) dwServerID,
        (ULONG_PTR) (dwAPIVersion?dwAPIVersion:TAPI_VERSION1_0),
        (ULONG_PTR) 0,
        (ULONG_PTR) &lineDevCaps
    };
    
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetDevCaps),
        args,
        argTypes
    };

    lineDevCaps.dwTotalSize = sizeof(LINEDEVCAPS);
    lResult = REMOTEDOFUNC(&funcArgs, "lineGetDevCaps");
    if (lResult != 0)
    {
        goto ExitHere;
    }
    dwPermLineID = lineDevCaps.dwPermanentLineID;

    TapiEnterCriticalSection(&gCriticalSection);
    bLeaveCriticalSection = TRUE;
    if (!gpLineLookup)
    {
        if (!(gpLineLookup = DrvAlloc(
                sizeof(DRVLINELOOKUP) +
                    (DEF_NUM_LINE_ENTRIES-1) * sizeof (DRVLINE)
                )))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }

        gpLineLookup->dwTotalEntries = DEF_NUM_LINE_ENTRIES;
    }

    pLineLookup = gpLineLookup;

    //
    //  Check if the line is already in based on the permanent ID
    //
    if (!bInit)
    {
        while (pLineLookup)
        {
            pLine = pLineLookup->aEntries;
            for (iEntry = 0; 
                iEntry < (int)pLineLookup->dwUsedEntries;
                ++iEntry, ++pLine)
            {
                if ((pLine->dwPermanentLineID == dwPermLineID) &&
                    (pLine->pServer->hTapSrv == pServer->hTapSrv))
                {
                    //
                    //  if dwDeviceIDServer == (-1), it was removed earlier
                    //  put it back, otherwise fail the operation
                    //
                    if (pLine->dwDeviceIDServer == 0xffffffff)
                    {
                        pLine->dwDeviceIDServer = dwServerID;
                        pLine->dwDeviceIDLocal = dwLocalID;
                    }
                    else
                    {
                        lResult = LINEERR_INUSE;
                    }
                    goto ExitHere;
                }
            }
            pLineLookup = pLineLookup->pNext;
        }
    }

    pLineLookup = gpLineLookup;

    while (pLineLookup->pNext)
    {
        pLineLookup = pLineLookup->pNext;
    }

    if (pLineLookup->dwUsedEntries == pLineLookup->dwTotalEntries)
    {
        PDRVLINELOOKUP  pNewLineLookup;


        if (!(pNewLineLookup = DrvAlloc(
                sizeof(DRVLINELOOKUP) +
                    (2 * pLineLookup->dwTotalEntries - 1) * sizeof(DRVLINE)
                )))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }

        pNewLineLookup->dwTotalEntries = 2 * pLineLookup->dwTotalEntries;

        if (bInit)
        {
            pNewLineLookup->dwUsedEntries = pLineLookup->dwTotalEntries;

            CopyMemory(
                pNewLineLookup->aEntries,
                pLineLookup->aEntries,
                pLineLookup->dwTotalEntries * sizeof (DRVLINE)
                );

            DrvFree (pLineLookup);

            gpLineLookup = pNewLineLookup;

        }
        else
        {
            pLineLookup->pNext = pNewLineLookup;
        }

        pLineLookup = pNewLineLookup;

        //
        //  Fix the hDeviceCallback in PDRVLINE 
        //

        pLine = pLineLookup->aEntries;
        for (iEntry = 0; iEntry < (int)pLineLookup->dwUsedEntries; ++iEntry)
        {
            if (pLine->hDeviceCallback)
            {
                DereferenceObject (
                    ghHandleTable, 
                    pLine->hDeviceCallback,
                    1
                    );
                pLine->hDeviceCallback = (DWORD) NewObject (
                    ghHandleTable, 
                    pLine, 
                    (LPVOID) 1
                    );
            }
        }
        
    }

    pLine = pLineLookup->aEntries + pLineLookup->dwUsedEntries;

    pLine->pServer          = pServer;
    pLine->dwDeviceIDLocal  = dwLocalID;
    pLine->dwDeviceIDServer = dwServerID;
    pLine->dwPermanentLineID = dwPermLineID;

    if (bInit)
    {
        gdwInitialNumLineDevices++;
    }

    pLineLookup->dwUsedEntries++;


    //
    // Negotiate the API/SPI version
    //

    if (bNegotiate)
    {
        if (dwAPIVersion)
        {
            pLine->dwXPIVersion = dwAPIVersion;
            CopyMemory (&pLine->ExtensionID, pExtID, sizeof (*pExtID));
        }
        else
        {
            static REMOTE_ARG_TYPES argTypes[] =
            {
                Dword,
                LineID,
                Dword,
                Dword,
                lpDword,
                lpGet_SizeToFollow,
                Size
            };
            ULONG_PTR args[] =
            {
                (ULONG_PTR) pServer->hLineApp,
                (ULONG_PTR) dwLocalID,   //  dwServerID,
                (ULONG_PTR) TAPI_VERSION1_0,
                (ULONG_PTR) TAPI_VERSION_CURRENT,
                (ULONG_PTR) &pLine->dwXPIVersion,
                (ULONG_PTR) &pLine->ExtensionID,
                (ULONG_PTR) sizeof (LINEEXTENSIONID)
            };
            REMOTE_FUNC_ARGS funcArgs =
            {
                MAKELONG (LINE_FUNC | SYNC | 7, lNegotiateAPIVersion),
                args,
                argTypes
            };


            REMOTEDOFUNC (&funcArgs, "lineNegotiateAPIVersion");
        }
    }

ExitHere:
    if (bLeaveCriticalSection)
    {
        TapiLeaveCriticalSection(&gCriticalSection);
    }
    return lResult;
}


LONG
AddPhone(
    PDRVSERVER          pServer,
    DWORD               dwDeviceIDLocal,
    DWORD               dwDeviceIDServer,
    BOOL                bInit,
    BOOL                bNegotiate,
    DWORD               dwAPIVersion,
    LPPHONEEXTENSIONID  pExtID
    )
{
    PDRVPHONE       pPhone;
    PDRVPHONELOOKUP pPhoneLookup;
    LONG            lResult = 0;
    BOOL            bLeaveCriticalSection = FALSE;
    PHONECAPS       phoneDevCaps;
    DWORD           dwPermPhoneID;
    int             iEntry;


    //
    //  Get the permanent phone device ID
    //
    static REMOTE_ARG_TYPES argTypes[] =
    {
        lpServer,
        Dword,
        Dword,
        Dword,
        Dword,
        lpGet_Struct
    };
    
    ULONG_PTR args[] =
    {
        (ULONG_PTR) pServer,
        (ULONG_PTR) pServer->hPhoneApp,
        (ULONG_PTR) dwDeviceIDServer,
        (ULONG_PTR) (dwAPIVersion?dwAPIVersion:TAPI_VERSION1_0),
        (ULONG_PTR) 0,
        (ULONG_PTR) &phoneDevCaps
    };
    
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 6, pGetDevCaps),
        args,
        argTypes
    };

    phoneDevCaps.dwTotalSize = sizeof(PHONECAPS);
    lResult = REMOTEDOFUNC (&funcArgs, "phoneGetDevCaps");
    if (lResult != 0)
    {
        goto ExitHere;
    }
    dwPermPhoneID = phoneDevCaps.dwPermanentPhoneID;

    TapiEnterCriticalSection(&gCriticalSection);
    bLeaveCriticalSection = TRUE;
    if (!gpPhoneLookup)
    {
        if (!(gpPhoneLookup = DrvAlloc(
                sizeof(DRVPHONELOOKUP) +
                    (DEF_NUM_PHONE_ENTRIES-1) * sizeof (DRVPHONE)
                )))
        {
            lResult = (bInit ? LINEERR_NOMEM : PHONEERR_NOMEM);
            goto ExitHere;
        }

        gpPhoneLookup->dwTotalEntries = DEF_NUM_PHONE_ENTRIES;
    }

    //
    //  Check if the phone device is already in based on the permanent ID
    //
    if (!bInit)
    {
        pPhoneLookup = gpPhoneLookup;
        while (pPhoneLookup)
        {
            pPhone = pPhoneLookup->aEntries;
            for (iEntry = 0; 
                iEntry < (int)pPhoneLookup->dwUsedEntries;
                ++iEntry, ++pPhone)
            {
                if ((pPhone->dwPermanentPhoneID == dwPermPhoneID) &&
                    (pPhone->pServer->hTapSrv == pServer->hTapSrv))
                {
                    //
                    //  if dwDeviceIDServer == (-1), it was removed earlier
                    //  put it back, otherwise fail the operation
                    //
                    if (pPhone->dwDeviceIDServer == 0xffffffff)
                    {
                        pPhone->dwDeviceIDServer = dwDeviceIDServer;
                        pPhone->dwDeviceIDLocal = dwDeviceIDLocal;
                    }
                    else
                    {
                        lResult = PHONEERR_INUSE;
                    }
                    goto ExitHere;
                }
            }
            pPhoneLookup = pPhoneLookup->pNext;
        }
    }

    pPhoneLookup = gpPhoneLookup;

    while (pPhoneLookup->pNext)
    {
        pPhoneLookup = pPhoneLookup->pNext;
    }

    if (pPhoneLookup->dwUsedEntries == pPhoneLookup->dwTotalEntries)
    {
        PDRVPHONELOOKUP pNewPhoneLookup;


        if (!(pNewPhoneLookup = DrvAlloc(
                sizeof(DRVPHONELOOKUP) +
                    (2 * pPhoneLookup->dwTotalEntries - 1) * sizeof(DRVPHONE)
                )))
        {
            lResult = (bInit ? LINEERR_NOMEM : PHONEERR_NOMEM);
            goto ExitHere;
        }

        pNewPhoneLookup->dwTotalEntries = 2 * pPhoneLookup->dwTotalEntries;

        if (bInit)
        {
            pNewPhoneLookup->dwUsedEntries = pPhoneLookup->dwTotalEntries;

            CopyMemory(
                pNewPhoneLookup->aEntries,
                pPhoneLookup->aEntries,
                pPhoneLookup->dwTotalEntries * sizeof (DRVPHONE)
                );

            DrvFree (pPhoneLookup);

            gpPhoneLookup = pNewPhoneLookup;
        }
        else
        {
            pPhoneLookup->pNext = pNewPhoneLookup;
        }

        pPhoneLookup = pNewPhoneLookup;

        //
        //  Fix the hDeviceCallback in PDRVPHONE 
        //

        pPhone = pPhoneLookup->aEntries;
        for (iEntry = 0; iEntry < (int) pPhoneLookup->dwUsedEntries; ++iEntry)
        {
            if (pPhone->hDeviceCallback)
            {
                DereferenceObject (
                    ghHandleTable, 
                    pPhone->hDeviceCallback,
                    1
                    );
                pPhone->hDeviceCallback = (DWORD) NewObject (
                    ghHandleTable, 
                    pPhone, 
                    (LPVOID) 1
                    );
            }
        }
    }

    pPhone = pPhoneLookup->aEntries + pPhoneLookup->dwUsedEntries;

    pPhone->pServer          = pServer;
    pPhone->dwDeviceIDLocal  = dwDeviceIDLocal;
    pPhone->dwDeviceIDServer = dwDeviceIDServer;
    pPhone->dwPermanentPhoneID = dwPermPhoneID;

    if (bInit)
    {
        gdwInitialNumPhoneDevices++;
    }

    pPhoneLookup->dwUsedEntries++;


    //
    // Negotiate the API/SPI version
    //

    if (bNegotiate)
    {
        if (dwAPIVersion)
        {
            pPhone->dwXPIVersion = dwAPIVersion;
            CopyMemory (&pPhone->ExtensionID, pExtID, sizeof (*pExtID));
        }
        else
        {
            static REMOTE_ARG_TYPES argTypes[] =
            {
                Dword,
                PhoneID,
                Dword,
                Dword,
                lpDword,
                lpGet_SizeToFollow,
                Size
            };
            ULONG_PTR args[] =
            {
                (ULONG_PTR) pServer->hPhoneApp,
                (ULONG_PTR) dwDeviceIDLocal,
                (ULONG_PTR) TAPI_VERSION1_0,
                (ULONG_PTR) TAPI_VERSION_CURRENT,
                (ULONG_PTR) &pPhone->dwXPIVersion,
                (ULONG_PTR) &pPhone->ExtensionID,
                (ULONG_PTR) sizeof (PHONEEXTENSIONID),
            };
            REMOTE_FUNC_ARGS funcArgs =
            {
                MAKELONG (PHONE_FUNC | SYNC | 7, pNegotiateAPIVersion),
                args,
                argTypes
            };

            TapiLeaveCriticalSection(&gCriticalSection);
            bLeaveCriticalSection = FALSE;

            REMOTEDOFUNC (&funcArgs, "phoneNegotiateAPIVersion");
        }
    }

ExitHere:
    if (bLeaveCriticalSection)
    {
        TapiLeaveCriticalSection(&gCriticalSection);
    }
    return lResult;
}


#if DBG
LPVOID
WINAPI
RSPAlloc(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
#else
LPVOID
WINAPI
RSPAlloc(
    DWORD   dwSize
    )
#endif
{
    LPVOID  p;


#if DBG
    dwSize += sizeof (MYMEMINFO);
#endif

    p = HeapAlloc (ghRSPHeap, HEAP_ZERO_MEMORY, dwSize);

#if DBG
    if (p)
    {
        ((PMYMEMINFO) p)->dwLine  = dwLine;
        ((PMYMEMINFO) p)->pszFile = pszFile;

        p = (LPVOID) (((PMYMEMINFO) p) + 1);
    }
#endif

    return p;
}


void
DrvFree(
    LPVOID  p
    )
{
    if (!p)
    {
        return;
    }

#if DBG

    //
    // Fill the buffer (but not the MYMEMINFO header) with 0xa9's
    // to facilitate debugging
    //

    {
        LPVOID  p2 = p;


        p = (LPVOID) (((PMYMEMINFO) p) - 1);

        FillMemory(
            p2,
            HeapSize (ghRSPHeap, 0, p) - sizeof (MYMEMINFO),
            0xa9
            );
    }

#endif

    HeapFree (ghRSPHeap, 0, p);
}


void
__RPC_FAR *
__RPC_API
midl_user_allocate(
    size_t len
    )
{
    return (DrvAlloc (len));
}


void
__RPC_API
midl_user_free(
    void __RPC_FAR * ptr
    )
{
    DrvFree (ptr);
}


LONG
RemoteSPAttach(
    PCONTEXT_HANDLE_TYPE2  *pphContext
    )
{
    //
    // This func is called by TapiSrv.exe on a remote machine as a
    // result of the call to ClientAttach in TSPI_providerEnumDevices.
    // The gpServer variable contains a pointer to the DRVSERVER
    // structure we are currently initializing for this tapi server,
    // so we'll use this as the context value.
    //

    LOG((TL_INFO, "RemoteSPAttach: enter"));
//    DBGOUT((9, "  hLineApp= 0x%08lx", gpServer));

    *pphContext = (PCONTEXT_HANDLE_TYPE) gpCurrInitServer;

    gpCurrInitServer->bConnectionOriented = TRUE;

    return 0;
}


void
RemoteSPEventProc(
    PCONTEXT_HANDLE_TYPE2   phContext,
    unsigned char          *pBuffer,
    long                    lSize
    )
{
    //
    // This func is called by tapisrv on a remote machine.  We want to do
    // things as quickly as possible here and return so we don't block the
    // calling server thread.
    //
    // This func might also be called by the EventHandlerThread, in the
    // case where we're using a connectionless event notification scheme
    // and we pull events over from the server.  In this case, phContext
    // will == 0xfeedface, and prior to returning we want to set
    // the char pointed at by pBuffer to 1 on success, or 0 otherwise.
    //

    DWORD           dwMsgSize, dwRemainingSize = (DWORD) lSize,
                    dwMoveSize = (DWORD) lSize,
                    dwMoveSizeWrapped = 0;
    unsigned char  *pMsg = pBuffer;


    //
    // Make sure the buffer is DWORD aligned, big enough for at least 1 msg,
    // and that the lSize is not overly large (overflow)
    //

    if ((lSize < 0)  ||
        (lSize & 0x3) ||
        (lSize < sizeof (ASYNCEVENTMSG)) ||
        ((pBuffer + lSize) < pBuffer))
    {
        LOG((TL_ERROR, "RemoteSPEventProc: ERROR! bad lSize=x%x", lSize));

        if (phContext == (PCONTEXT_HANDLE_TYPE2) IntToPtr(0xfeedface))
        {
            *pBuffer = 0;
        }

        return;
    }


    //
    // Validate the pDrvServer pointer in the first msg
    //

    if (!ReferenceObject(
            ghHandleTable,
            ((PASYNCEVENTMSG) pMsg)->InitContext,
            gdwDrvServerKey
            ))
    {
        LOG((TL_ERROR,
            "RemoteSPEventProc: bad InitContext=x%x in msg",
            ((PASYNCEVENTMSG) pMsg)->InitContext
            ));

        if (phContext == (PCONTEXT_HANDLE_TYPE2) IntToPtr(0xfeedface))
        {
            *pBuffer = 0;
        }

        return;
    }

    DereferenceObject (ghHandleTable, ((PASYNCEVENTMSG) pMsg)->InitContext, 1);


    //
    // Make sure every msg in the buffer has a valid dwTotalSize
    //

    do
    {
        dwMsgSize = (DWORD) ((PASYNCEVENTMSG) pMsg)->TotalSize;

        if ((dwMsgSize & 0x3)  ||
            (dwMsgSize < sizeof (ASYNCEVENTMSG))  ||
            (dwMsgSize > dwRemainingSize))
        {
            LOG((TL_ERROR, "RemoteSPEventProc: ERROR! bad msgSize=x%x",dwMsgSize));

            if (phContext == (PCONTEXT_HANDLE_TYPE2) IntToPtr(0xfeedface))
            {
                *pBuffer = 0;
            }

            return;
        }

        dwRemainingSize -= dwMsgSize;

        pMsg += dwMsgSize;

    }  while (dwRemainingSize >= sizeof(ASYNCEVENTMSG));
    if (0 != dwRemainingSize)
    {
        LOG((TL_ERROR, "RemoteSPEventProc: ERROR! bad last msgSize=x%x",dwRemainingSize));

        if (phContext == (PCONTEXT_HANDLE_TYPE2) IntToPtr(0xfeedface))
        {
            *pBuffer = 0;
        }

        return;
    }


    //
    // Enter the critical section to sync access to gEventHandlerThreadParams
    //

    EnterCriticalSection (&gEventBufferCriticalSection);

    {
        PASYNCEVENTMSG  pMsg = (PASYNCEVENTMSG) pBuffer;


        LOG((TL_INFO, "RemoteSPEventProc: x%lx", pMsg));

        if (pMsg->Msg == LINE_REPLY)
        {
            LOG((TL_INFO,
                "Got a LINE_REPLY: p1=%lx,  p2=%lx",
                pMsg->Param1,
                pMsg->Param2
                ));
        }
    }


    //
    // Check to see if there's enough room for this msg in the event buffer.
    // If not, then alloc a new event buffer, copy contents of existing buffer
    // to new buffer (careful to preserve ordering of valid data), free the
    // existing buffer, and reset the pointers.
    //

    if ((gEventHandlerThreadParams.dwEventBufferUsedSize + lSize) >
            gEventHandlerThreadParams.dwEventBufferTotalSize)
    {
        DWORD  dwMoveSize2, dwMoveSizeWrapped2, dwNewEventBufferTotalSize;
        LPBYTE pNewEventBuffer;


        LOG((TL_INFO, "EventHandlerThread: we're gonna need a bigger boat..."));

        //
        // Make sure we're not exceeding our max allowedable buffer size, &
        // alloc a few more bytes than actually needed in the hope that we
        // won't have to do this again soon (we don't want to go overboard
        // & alloc a whole bunch since we don't currently free the buffer
        // until provider shutdown)
        //

        dwNewEventBufferTotalSize =
            gEventHandlerThreadParams.dwEventBufferTotalSize + lSize;

        if (dwNewEventBufferTotalSize > gdwMaxEventBufferSize)
        {
            LOG((TL_ERROR,
                "RemoveSPEventProc: event buf max'd, discarding events"
                ));

            LeaveCriticalSection (&gEventBufferCriticalSection);

            return;
        }
        else if (dwNewEventBufferTotalSize + 512 <= gdwMaxEventBufferSize)
        {
            dwNewEventBufferTotalSize += 512;
        }

        if (!(pNewEventBuffer = DrvAlloc (dwNewEventBufferTotalSize)))
        {
            LeaveCriticalSection (&gEventBufferCriticalSection);

            return;
        }

        if (gEventHandlerThreadParams.dwEventBufferUsedSize != 0)
        {
            if (gEventHandlerThreadParams.pDataIn >
                    gEventHandlerThreadParams.pDataOut)
            {
                dwMoveSize2 = (DWORD) (gEventHandlerThreadParams.pDataIn -
                    gEventHandlerThreadParams.pDataOut);

                dwMoveSizeWrapped2 = 0;
            }
            else
            {
                dwMoveSize2 = (DWORD) ((gEventHandlerThreadParams.pEventBuffer
                    + gEventHandlerThreadParams.dwEventBufferTotalSize)
                    - gEventHandlerThreadParams.pDataOut);

                dwMoveSizeWrapped2 = (DWORD) (gEventHandlerThreadParams.pDataIn
                    - gEventHandlerThreadParams.pEventBuffer);
            }

            CopyMemory(
                pNewEventBuffer,
                gEventHandlerThreadParams.pDataOut,
                dwMoveSize2
                );

            if (dwMoveSizeWrapped2)
            {
                CopyMemory(
                    pNewEventBuffer + dwMoveSize2,
                    gEventHandlerThreadParams.pEventBuffer,
                    dwMoveSizeWrapped2
                    );
            }

            gEventHandlerThreadParams.pDataIn = pNewEventBuffer + dwMoveSize2 +
                dwMoveSizeWrapped2;
        }
        else
        {
            gEventHandlerThreadParams.pDataIn = pNewEventBuffer;
        }


        DrvFree (gEventHandlerThreadParams.pEventBuffer);

        gEventHandlerThreadParams.pDataOut =
        gEventHandlerThreadParams.pEventBuffer = pNewEventBuffer;

        gEventHandlerThreadParams.dwEventBufferTotalSize =
            dwNewEventBufferTotalSize;
    }


    //
    // Write the msg data to the buffer
    //

    if (gEventHandlerThreadParams.pDataIn >=
            gEventHandlerThreadParams.pDataOut)
    {
        DWORD dwFreeSize;


        dwFreeSize = gEventHandlerThreadParams.dwEventBufferTotalSize -
            (DWORD) (gEventHandlerThreadParams.pDataIn -
            gEventHandlerThreadParams.pEventBuffer);

        if (dwMoveSize > dwFreeSize)
        {
            dwMoveSizeWrapped = dwMoveSize - dwFreeSize;

            dwMoveSize = dwFreeSize;
        }
    }

    CopyMemory (gEventHandlerThreadParams.pDataIn, pBuffer, dwMoveSize);

    if (dwMoveSizeWrapped != 0)
    {
        CopyMemory(
            gEventHandlerThreadParams.pEventBuffer,
            pBuffer + dwMoveSize,
            dwMoveSizeWrapped
            );

        gEventHandlerThreadParams.pDataIn =
            gEventHandlerThreadParams.pEventBuffer + dwMoveSizeWrapped;
    }
    else
    {
        gEventHandlerThreadParams.pDataIn += dwMoveSize;

        if (gEventHandlerThreadParams.pDataIn >=
            (gEventHandlerThreadParams.pEventBuffer +
             gEventHandlerThreadParams.dwEventBufferTotalSize))
        {
            gEventHandlerThreadParams.pDataIn =
                gEventHandlerThreadParams.pEventBuffer;
        }

    }

    gEventHandlerThreadParams.dwEventBufferUsedSize += (DWORD) lSize;


    //
    // Tell the EventHandlerThread there's another event to handle by
    // signaling the event (if we're getting called by that thread
    // [phContext == 0xfeedface] then set *pBuffer = 1 to indicate success)
    //

    if (phContext != (PCONTEXT_HANDLE_TYPE2) IntToPtr(0xfeedface))
    {
        SetEvent (gEventHandlerThreadParams.hEvent);
    }
    else
    {
        *pBuffer = 1;
    }


    //
    // We're done...
    //

    LeaveCriticalSection (&gEventBufferCriticalSection);


    LOG((TL_INFO, "RemoteSPEventProc: bytesWritten=x%x", lSize));
}


void
__RPC_USER
PCONTEXT_HANDLE_TYPE2_rundown(
    PCONTEXT_HANDLE_TYPE2   phContext
    )
{
    //
    // This happens (at least) when the server trys to call to REMOTESP, but
    // times out and cancels the RPC request.  When that happens, the RPC
    // session will be broken.  
    //

    PDRVSERVER  pServer = (PDRVSERVER) phContext;


    LOG((TL_INFO, "Rundown: phContext=x%x", phContext));

    try
    {
        if (pServer->dwKey != pServer->pInitContext->dwDrvServerKey)
        {
            LOG((TL_ERROR, "Rundown: bad phContext=x%x", phContext));
            return;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        LOG((TL_ERROR, "Rundown: bad phContext=x%x", phContext));
        return;
    }

    if (!pServer->pInitContext->bShutdown)
    {
        OnServerDisconnected(pServer);
    }

    InterlockedDecrement (&pServer->pInitContext->dwNumRundownsExpected);
}


void
RemoteSPDetach(
    PCONTEXT_HANDLE_TYPE2   *pphContext
    )
{
    PCONTEXT_HANDLE_TYPE2   phContext;


    LOG((TL_INFO, "RemoteSPDetach: phContext=x%x", *pphContext));

    try
    {
        phContext = *pphContext;
        *pphContext = (PCONTEXT_HANDLE_TYPE) NULL;
        ((PDRVSERVER)phContext)->pInitContext->bShutdown = TRUE;
    }
    myexcept
    {
        phContext = NULL;
    }

    if (phContext)
    {
        PCONTEXT_HANDLE_TYPE2_rundown (phContext);
    }

    LOG((TL_INFO, "RemoteSPDetach: exit"));
}


LONG
AddCallToList(
    PDRVLINE    pLine,
    PDRVCALL    pCall
    )
{
    //
    // Initialize some common fields in the call
    //

    pCall->dwKey   = DRVCALL_KEY;

    pCall->pServer = pLine->pServer;

    pCall->pLine   = pLine;


    pCall->pCachedCallInfo = NULL;

    pCall->dwDirtyStructs =
        STRUCTCHANGE_LINECALLSTATUS | STRUCTCHANGE_LINECALLINFO;


    //
    // Safely add the call to the line's list
    //

    EnterCriticalSection (&gCallListCriticalSection);

    if ((pCall->pNext = (PDRVCALL) pLine->pCalls))
    {
        pCall->pNext->pPrev = pCall;
    }

    pLine->pCalls = pCall;

    LeaveCriticalSection (&gCallListCriticalSection);

    return 0;
}


LONG
RemoveCallFromList(
    PDRVCALL    pCall
    )
{
    //
    // Safely remove the call from the line's list
    //

    EnterCriticalSection (&gCallListCriticalSection);

    if (!IsValidObject (pCall, DRVCALL_KEY))
    {
        LOG((TL_ERROR, "RemoveCallFromList: Call x%lx: Call key does not match.", pCall));

        LeaveCriticalSection(&gCallListCriticalSection);
        return 0;
    }

    //
    // Mark the pCall as toast
    //
    pCall->dwKey = DRVINVAL_KEY;

    if (pCall->pNext)
    {
        pCall->pNext->pPrev = pCall->pPrev;
    }

    if (pCall->pPrev)
    {
        pCall->pPrev->pNext = pCall->pNext;
    }
    else
    {
        pCall->pLine->pCalls = pCall->pNext;
    }

    LeaveCriticalSection (&gCallListCriticalSection);

    // free structures
    if ( pCall->pCachedCallInfo )
    {
        DrvFree( pCall->pCachedCallInfo );
    }

    if ( pCall->pCachedCallStatus )
    {
        DrvFree( pCall->pCachedCallStatus );
    }


    DrvFree(pCall);

    return 0;
}


void
Shutdown(
    PDRVSERVER  pServer
    )
{

    TapiEnterCriticalSection (&gCriticalSection);
    if ((pServer == NULL) || pServer->bShutdown)
    {
        TapiLeaveCriticalSection (&gCriticalSection);
        goto ExitHere;
    }
    pServer->bShutdown = TRUE;
    TapiLeaveCriticalSection (&gCriticalSection);

    //
    // Do a lineShutdown
    //

    {
        DWORD                   dwSize;
        TAPI32_MSG              msg;
        PLINESHUTDOWN_PARAMS    pParams;


        msg.u.Req_Func = lShutdown;

        pParams = (PLINESHUTDOWN_PARAMS) &msg;

        pParams->hLineApp = pServer->hLineApp;

        dwSize = sizeof (TAPI32_MSG);

        {
            DWORD dwRetryCount = 0;


            do
            {
                RpcTryExcept
                {
                    ClientRequest(
                        pServer->phContext,
                        (char *) &msg,
                        dwSize,
                        &dwSize
                        );

                    dwRetryCount = gdwRetryCount;
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    // TODO may want to increase the retry count here since we
                    //      have to do this, & a million other clients may be
                    //      trying to do the same thing at the same time

                    if (dwRetryCount++ < gdwRetryCount)
                    {
                        Sleep (gdwRetryTimeout);
                    }
                }
                RpcEndExcept

            } while (dwRetryCount < gdwRetryCount);
        }
    }


    //
    // Do a phoneShutdown
    //

    {
        DWORD                   dwSize;
        TAPI32_MSG              msg;
        PPHONESHUTDOWN_PARAMS   pParams;


        msg.u.Req_Func = pShutdown;

        pParams = (PPHONESHUTDOWN_PARAMS) &msg;

        pParams->hPhoneApp = pServer->hPhoneApp;

        dwSize = sizeof (TAPI32_MSG);

        {
            DWORD dwRetryCount = 0;


            do
            {
                RpcTryExcept
                {
                    ClientRequest(
                        pServer->phContext,
                        (char *) &msg,
                        dwSize,
                        &dwSize
                        );

                    dwRetryCount = gdwRetryCount;
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    // TODO may want to increase the retry count here since we
                    //      have to do this, & a million other clients may be
                    //      trying to do the same thing at the same time

                    if (dwRetryCount++ < gdwRetryCount)
                    {
                        Sleep (gdwRetryTimeout);
                    }
                }
                RpcEndExcept

            } while (dwRetryCount < gdwRetryCount);
        }
    }

    RpcTryExcept
    {
        ClientDetach (&pServer->phContext);
        pServer->phContext = NULL;
    }
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
    {
        pServer->phContext = NULL;
    }
    RpcEndExcept

    TapiEnterCriticalSection (&gCriticalSection);
    
    //
    // Walk the line lookup tables & send a CLOSE msg for each open line
    // associated with the server
    //

    {
        PDRVLINELOOKUP  pLookup = gpLineLookup;

        try
        {
            while (pLookup)
            {
                DWORD     i;
                PDRVLINE  pLine;


                for(
                    i = 0, pLine = pLookup->aEntries;
                    i < pLookup->dwUsedEntries;
                    i++, pLine++
                    )
                {
                    if (pLine->pServer == pServer)
                    {
                        if (pLine->htLine)
                        {
                            PDRVCALL pCall;


                            pLine->hLine = 0;

                            EnterCriticalSection (&gCallListCriticalSection);
                        
                            try
                            {
                                pCall = pLine->pCalls;

                                while (pCall)
                                {
                                    pCall->hCall = 0;

                                    pCall = pCall->pNext;
                                }
                            }
                            except (EXCEPTION_EXECUTE_HANDLER)
                            {
                                LOG((TL_ERROR, "Shutdown: Exception x%lx while walking the calls list", 
                                    GetExceptionCode()));
                            }

                            LeaveCriticalSection (&gCallListCriticalSection);
                            
                            try
                            {
                                (*gpfnLineEventProc)(
                                    pLine->htLine,
                                    0,
                                    LINE_CLOSE,
                                    0,
                                    0,
                                    0
                                    );
                            }
                            except (EXCEPTION_EXECUTE_HANDLER)
                            {
                                LOG((TL_ERROR, "Shutdown: Exception x%lx while sending the LINE_CLOSE message", 
                                    GetExceptionCode()));
                            }
                        }
                    }
                }

                pLookup = pLookup->pNext;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            LOG((TL_ERROR, "Shutdown: Exception x%lx while walking the line lookup table", 
                     GetExceptionCode()));
        }
    }


    //
    // Walk the phone lookup tables & send a CLOSE msg for each open phone
    // associated with the server
    //

    {
        PDRVPHONELOOKUP pLookup = gpPhoneLookup;


        while (pLookup)
        {
            DWORD     i;
            PDRVPHONE pPhone;


            for(
                i = 0, pPhone = pLookup->aEntries;
                i < pLookup->dwUsedEntries;
                i++, pPhone++
                )
            {
                if (pPhone->pServer == pServer)
                {
                    if (pPhone->htPhone)
                    {
                        pPhone->hPhone = 0;

                        (*gpfnPhoneEventProc)(
                            pPhone->htPhone,
                            PHONE_CLOSE,
                            0,
                            0,
                            0
                            );
                    }
                }
            }

            pLookup = pLookup->pNext;
        }
    }

    TapiLeaveCriticalSection (&gCriticalSection);

ExitHere:
    return;
}


/*
BOOL
CALLBACK
ConfigDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static  HKEY    hTelephonyKey, hProviderNKey;

    DWORD   dwDataType, dwDataSize;


    switch (msg)
    {
    case WM_INITDIALOG:
    {
        char    buf[32], szProviderN[16], szServerN[16];
        BOOL    bReadOnly;
//        DWORD   i;
        DWORD   dwPermanentProviderID = (DWORD) lParam;


        //
        // First try to open the Telephony key with read/write access.
        // If that fails, disable any controls that could cause a chg
        // in config & try opening again with read only access.
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszTelephonyKey,
                0,
                KEY_ALL_ACCESS,
                &hTelephonyKey

                ) != ERROR_SUCCESS)
        {
            EnableWindow (GetDlgItem (hwnd, IDOK), FALSE);

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszTelephonyKey,
                    0,
                    KEY_READ,
                    &hTelephonyKey

                    ) != ERROR_SUCCESS)
            {
                EndDialog (hwnd, 0);
                return FALSE;
            }

            bReadOnly = TRUE;
        }
        else
        {
            bReadOnly = FALSE;
        }

        wsprintf (szProviderN, "%s%d", gszProvider, dwPermanentProviderID);

        buf[0] = '\0';

        RegOpenKeyEx(
            hTelephonyKey,
            szProviderN,
            0,
            (bReadOnly ? KEY_READ : KEY_ALL_ACCESS),
            &hProviderNKey
            );

        // we're just going to handle one server for now

        wsprintf (szServerN, "%s%d", gszServer, 0);

        dwDataSize = sizeof(buf);

        RegQueryValueEx(
                        hProviderNKey,
                        szServerN,
                        0,
                        &dwDataType,
                        (LPBYTE) buf,
                        &dwDataSize
                       );

        buf[dwDataSize] = '\0';

        SetDlgItemText(
                       hwnd,
                       IDC_SERVERNAME,
                       (LPSTR)buf
                      );

        SetFocus(
                 GetDlgItem(
                            hwnd,
                            IDC_SERVERNAME
                           )
                );

        SendMessage(
                    GetDlgItem(
                               hwnd,
                               IDC_SERVERNAME
                              ),
                    EM_LIMITTEXT,
                    MAX_COMPUTERNAME_LENGTH,
                    0
                   );


        break;
    }
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            char    buf[MAX_COMPUTERNAME_LENGTH + 1], szServerN[MAX_COMPUTERNAME_LENGTH + 10];
            DWORD   dwSize;
            DWORD   dw = 1;


            if (!GetDlgItemText(
                                hwnd,
                                IDC_SERVERNAME,
                                buf,
                                MAX_COMPUTERNAME_LENGTH + 1
                               ))
            {
                LOG((TL_ERROR, "GetDlgItemText failed"));
                // don't end dialog , cause I think this
                // is the empty string case

                MessageBox(
                           hwnd,
                           "Must enter a server name",
                           "Remote SP Configuration",
                           MB_OK
                          );
                SetFocus(
                         GetDlgItem(
                                    hwnd,
                                    IDC_SERVERNAME
                                   )
                        );
                break;
            }

            dwSize = MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName(
                            szServerN,
                            &dwSize
                           );

            if (!(lstrcmpi(
                         szServerN,
                         buf
                        )
               ))
            {
                LOG((TL_ERROR, "Tried to set the server to the current machine name"));

                MessageBox(hwnd,
                           "Server name cannot be local machine name",
                           "Remote SP Configuration",
                           MB_OK);

                SetFocus(
                         GetDlgItem(
                                    hwnd,
                                    IDC_SERVERNAME
                                   )
                        );
                // don't end dialog
                break;
            }

            wsprintf (szServerN, "%s%d", gszServer, 0);

            // now set the registry key
            RegSetValueEx(
                          hProviderNKey,
                          szServerN,
                          0,
                          REG_SZ,
                          buf,
                          lstrlen(buf) + 1
                         );

            RegSetValueEx(
                          hProviderNKey,
                          gszNumServers,
                          0,
                          REG_DWORD,
                          (LPBYTE)&dw,
                          sizeof(dw)
                         );


            // fall thru to below
        }
        case IDCANCEL:

            RegCloseKey (hProviderNKey);
            RegCloseKey (hTelephonyKey);
            EndDialog (hwnd, 0);
            break;

        } // switch (LOWORD(wParam))

        break;

    } // switch (msg)

    return FALSE;
}
*/

PNEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS
NegotiateAllDevices(
    HLINEAPP                hLineApp,
    DWORD                   dwNumLineDevices,
    DWORD                   dwNumPhoneDevices,
    PCONTEXT_HANDLE_TYPE    phContext
    )
{
    DWORD                                       dwBufSize, dwUsedSize,
                                                dwRetryCount = 0;
    PNEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS    pParams;


    if (!dwNumLineDevices  &&  !dwNumPhoneDevices)
    {
        return NULL;
    }

    dwBufSize  =
        sizeof (TAPI32_MSG) +
        (dwNumLineDevices * sizeof (DWORD)) +
        (dwNumLineDevices * sizeof (LINEEXTENSIONID)) +
        (dwNumPhoneDevices * sizeof (DWORD)) +
        (dwNumPhoneDevices * sizeof (PHONEEXTENSIONID));

    if (!(pParams = DrvAlloc (dwBufSize)))
    {
        return NULL;
    }

    pParams->lResult = xNegotiateAPIVersionForAllDevices;

    pParams->hLineApp                   = hLineApp;
    pParams->dwNumLineDevices           = dwNumLineDevices;
    pParams->dwNumPhoneDevices          = dwNumPhoneDevices;
    pParams->dwAPIHighVersion           = TAPI_VERSION_CURRENT;
    pParams->dwLineAPIVersionListSize   = dwNumLineDevices * sizeof (DWORD);
    pParams->dwLineExtensionIDListSize  = dwNumLineDevices *
        sizeof (LINEEXTENSIONID);
    pParams->dwPhoneAPIVersionListSize  = dwNumPhoneDevices * sizeof (DWORD);
    pParams->dwPhoneExtensionIDListSize = dwNumPhoneDevices *
        sizeof (PHONEEXTENSIONID);

    dwUsedSize = sizeof (TAPI32_MSG);

    {
        do
        {
            RpcTryExcept
            {
                ClientRequest(
                    phContext,
                    (char *) pParams,
                    dwBufSize,
                    &dwUsedSize
                    );

                dwRetryCount = gdwRetryCount;
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                LOG((TL_ERROR,
                    "NegotiateAllDevices: exception %d doing negotiation",
                    RpcExceptionCode()
                    ));

                if (dwRetryCount++ < gdwRetryCount)
                {
                    Sleep (gdwRetryTimeout);
                }
                else
                {
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                }
            }
            RpcEndExcept

        } while (dwRetryCount < gdwRetryCount);
    }

    if (pParams->lResult != 0)
    {
        LOG((TL_ERROR,
            "NegotiateAllDevices: negotiation failed (x%x)",
            pParams->lResult
            ));

        DrvFree (pParams);
        pParams = NULL;
    }

    return pParams;
}


LONG
FinishEnumDevices(
    PDRVSERVER              pServer,
    PCONTEXT_HANDLE_TYPE    phContext,
    LPDWORD                 lpdwNumLines,
    LPDWORD                 lpdwNumPhones,
    BOOL                    fStartup,
    BOOL                    bFromReg
    )
/*++

    Function: FinishEnumDevices

    Purpose: Initializes remote server and queries for
               # of lines and phones.

    Notes:   We must already be connected via ClientAttach
               and we must already be impersonating the client

    Created: 6/26/97 t-mperh

--*/
{
    TAPI32_MSG  msg[2];
    DWORD       dwUsedSize, dwBufSize;
    DWORD       dwRetryCount = 0;
    HLINEAPP    hLineApp;
    HPHONEAPP   hPhoneApp;
    DWORD       dwNumLineDevices, dwNumPhoneDevices;
    DWORD       dwNumDevices = 0;
    BOOL        bFailed = FALSE;

    PNEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS    pNegoAPIVerParams;


    if (!(pServer->InitContext))
    {
        if (!(pServer->InitContext = (DWORD) NewObject(
            ghHandleTable,
            pServer,
            NULL
            )))
        {
            dwNumLineDevices = 0;
            dwNumPhoneDevices = 0;
            bFailed = TRUE;
            goto cleanup;
        }
    }

    {
        PLINEINITIALIZE_PARAMS pParams;


        msg[0].u.Req_Func = lInitialize;

        pParams = (PLINEINITIALIZE_PARAMS) msg;

        //
        // NOTE: we pass the pServer in place of the lpfnCallback
        //       so the we always know which server is sending us
        //       async events
        //

        pParams->InitContext          = pServer->InitContext;
        pParams->hInstance            =
        pParams->dwFriendlyNameOffset =
        pParams->dwModuleNameOffset   = 0;
        pParams->dwAPIVersion         = TAPI_VERSION_CURRENT;

        wcscpy ((WCHAR *) (msg + 1), gszMachineName);

        dwBufSize  =
        dwUsedSize = sizeof (TAPI32_MSG) +
            (lstrlenW (gszMachineName) + 1) * sizeof (WCHAR);

        {
            DWORD dwRetryCount = 0;

            do
            {
                RpcTryExcept
                {
                    ClientRequest(
                        phContext,
                        (char *) &msg,
                        dwBufSize,
                        &dwUsedSize
                        );

                    dwRetryCount = gdwRetryCount;
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    LOG((TL_ERROR,
                         "FinishEnumDevices: exception %d doing lineInit",
                         RpcExceptionCode()
                         ));

                    if (dwRetryCount++ < gdwRetryCount)
                    {
                        Sleep (gdwRetryTimeout);
                    }
                    else
                    {
                        bFailed = TRUE;
                    }
                }
                RpcEndExcept

            } while (dwRetryCount < gdwRetryCount);
        }

        hLineApp = pParams->hLineApp;

        if (pParams->lResult == 0)
        {
            dwNumLineDevices = pParams->dwNumDevs;
        }
        else
        {
            LOG((TL_ERROR,
                "FinishEnumDevices: lineInit failed (x%x) on server %s",
                pParams->lResult,
                pServer->szServerName
                ));

            dwNumLineDevices = 0;
            dwNumPhoneDevices = 0;
            bFailed = TRUE;
            goto cleanup;
        }
    }

    {
        PPHONEINITIALIZE_PARAMS pParams;

        msg[0].u.Req_Func = pInitialize;
        pParams = (PPHONEINITIALIZE_PARAMS) msg;

        //
        // NOTE: we pass the pServer in place of the lpfnCallback
        //       so the we always know which server is sending us
        //       async events
        //

        pParams->InitContext          = pServer->InitContext;
        pParams->hInstance            = 
        pParams->dwFriendlyNameOffset =
        pParams->dwModuleNameOffset   = 0;
        pParams->dwAPIVersion         = TAPI_VERSION_CURRENT;

        wcscpy ((WCHAR *) (msg + 1), gszMachineName);

        dwBufSize  =
        dwUsedSize = sizeof (TAPI32_MSG) +
            (lstrlenW (gszMachineName) + 1) * sizeof (WCHAR);

        {
            DWORD dwRetryCount = 0;

            do
            {
                RpcTryExcept
                {
                    ClientRequest(
                        phContext,
                        (char *) &msg,
                        dwBufSize,
                        &dwUsedSize
                        );

                    dwRetryCount = gdwRetryCount;
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    LOG((TL_ERROR,
                         "FinishEnumDevices: exception %d doing phoneInit",
                         RpcExceptionCode()
                         ));

                    if (dwRetryCount++ < gdwRetryCount)
                    {
                        Sleep (gdwRetryTimeout);
                    }
                    else
                    {
                        bFailed = TRUE;
                    }
                }
                RpcEndExcept

            } while (dwRetryCount < gdwRetryCount);
        }

        hPhoneApp = pParams->hPhoneApp;

        if (pParams->lResult == 0)
        {
            dwNumPhoneDevices = pParams->dwNumDevs;
        }
        else
        {
            LOG((TL_ERROR,
                "FinishEnumDevices: phoneInit failed (x%x) on server %s",
                pParams->lResult,
                pServer->szServerName
                ));

            dwNumPhoneDevices = 0;
            dwNumLineDevices = 0;
            bFailed = TRUE;
            goto cleanup;
        }
    }

    LOG((TL_INFO,
        "FinishEnumDevices: srv='%s', lines=%d, phones=%d",
        pServer->szServerName,
        dwNumLineDevices,
        dwNumPhoneDevices
        ));
    LogRemoteSPError(pServer->szServerName,
                     ERROR_REMOTESP_NONE,
                     dwNumLineDevices,
                     dwNumPhoneDevices,
                     !fStartup);

    if (pServer->dwSpecialHack == 0xa5c369a5)
    {
        pNegoAPIVerParams = NegotiateAllDevices(
            hLineApp,
            dwNumLineDevices,
            dwNumPhoneDevices,
            phContext
            );
    }
    else
    {
        pNegoAPIVerParams = NULL;
    }

    {
        DWORD               dwServerID,
                            dwLocalID,
                            myLineDevIDBase,
                            myTempLineID,
                            myPhoneDevIDBase,
                            myTempPhoneID,
                            dwZero = 0,
                            *pdwAPIVersion;
        LPLINEEXTENSIONID   pExtID;
        LONG                lResult;


        pServer->phContext   = phContext;
        pServer->hLineApp    = hLineApp;
        pServer->hPhoneApp   = hPhoneApp;


        //
        // If we are not being called during initialization
        // we need to simulate LINE_CREATE and PHONE_CREATE
        // messages from the server SP.
        //
        // Note we differentiate between static line devices
        // (those avail. at startup) and dynamic line devices
        // (those we are notified of dynamically) based on the
        // fStartup flag.
        //
        // _NOTE ALSO_ that the local device id's we assign to
        // devices at startup are 0-based, rather than based
        // on the dwDeviceIDBase's (which we don't know yet
        // because providerInit hasn't been called).  This
        // is desirable because AddLine/Phone might have to
        // negotiate versions, which requires a call to DoFunc,
        // which needss to know how to get pDevices from ID's.
        // We'll reset the .dwDeviceIDLocal fields for static
        // devices later on, in TSPI_providerInit.
        //

        myLineDevIDBase = gdwInitialNumLineDevices;
        myTempLineID = gdwTempLineID;

        myPhoneDevIDBase = gdwInitialNumPhoneDevices;
        myTempPhoneID = gdwTempPhoneID;

        if (pNegoAPIVerParams)
        {
            pdwAPIVersion = (LPDWORD)
                (((LPBYTE) pNegoAPIVerParams) + sizeof (TAPI32_MSG) +
                pNegoAPIVerParams->dwLineAPIVersionListOffset);

            pExtID = (LPLINEEXTENSIONID)
                (((LPBYTE) pNegoAPIVerParams) + sizeof (TAPI32_MSG) +
                pNegoAPIVerParams->dwLineExtensionIDListOffset);
        }
        else
        {
            pdwAPIVersion = &dwZero;
            pExtID = (LPLINEEXTENSIONID) NULL;
        }

        for (dwServerID = 0; dwServerID < dwNumLineDevices; dwServerID++)
        {
            dwLocalID = (fStartup ? myLineDevIDBase++ : myTempLineID);

            lResult = AddLine(
                pServer,
                dwLocalID,
                dwServerID,
                fStartup,
                TRUE,
                *pdwAPIVersion,
                pExtID
                );

            if (lResult == LINEERR_NODEVICE)
            {
                if (fStartup)
                {
                    --myLineDevIDBase;
                }
                continue;
            }

            if (lResult != 0)
            {
                break;
            }
            ++dwNumDevices;

            if (pNegoAPIVerParams)
            {
                pdwAPIVersion++;
                pExtID++;
            }


            if (!fStartup)
            {
                --myTempLineID;
                (*gpfnLineEventProc)(
                    0,
                    0,
                    LINE_CREATE,
                    (ULONG_PTR) ghProvider,
                    dwLocalID,
                    0
                    );
            }
        }

        gdwTempLineID = myTempLineID;

        if (pNegoAPIVerParams)
        {
            pdwAPIVersion = (LPDWORD)
                (((LPBYTE) pNegoAPIVerParams) + sizeof (TAPI32_MSG) +
                pNegoAPIVerParams->dwPhoneAPIVersionListOffset);

            pExtID = (LPLINEEXTENSIONID)
                (((LPBYTE) pNegoAPIVerParams) + sizeof (TAPI32_MSG) +
                pNegoAPIVerParams->dwPhoneExtensionIDListOffset);
        }

        for (dwServerID = 0; dwServerID < dwNumPhoneDevices; dwServerID++)
        {
            dwLocalID = (fStartup ? myPhoneDevIDBase++ : myTempPhoneID);

            lResult = AddPhone(
                pServer,
                dwLocalID,
                dwServerID,
                fStartup,
                TRUE,
                *pdwAPIVersion,
                (LPPHONEEXTENSIONID) pExtID
                );

            if (lResult == PHONEERR_NODEVICE)
            {
                if (fStartup)
                {
                    --myPhoneDevIDBase;
                }
                continue;
            }
            
            if (lResult != 0)
            {
                break;
            }
            ++dwNumDevices;

            if (pNegoAPIVerParams)
            {
                pdwAPIVersion++;
                pExtID++;
            }

            if (!fStartup)
            {
                myTempPhoneID--;
                (*gpfnPhoneEventProc)(
                    0,
                    PHONE_CREATE,
                    (ULONG_PTR) ghProvider,
                    dwLocalID,
                    0
                    );
            }
        }

        gdwTempPhoneID = myTempPhoneID;
    }

    if (pNegoAPIVerParams)
    {
        DrvFree (pNegoAPIVerParams);
    }

cleanup:

    if (pServer->bConnectionOriented)
    {
        InterlockedIncrement(
            &gpCurrentInitContext->dwNumRundownsExpected
            );
    }

    TapiEnterCriticalSection(&gCriticalSection);
    InsertTailList(
        &gpCurrentInitContext->ServerList,
        &pServer->ServerList
        );
    TapiLeaveCriticalSection(&gCriticalSection);


    if (TRUE == fStartup)
    {
        gdwInitialNumLineDevices =
        *lpdwNumLines = (gpLineLookup ? gpLineLookup->dwUsedEntries : 0);

        gdwInitialNumPhoneDevices =
        *lpdwNumPhones = (gpPhoneLookup ? gpPhoneLookup->dwUsedEntries : 0);
    }

    if (bFailed)
    {
        //
        //  Failed in seting up lines for this server, retry later.
        //
        Sleep (4000);
        RpcBindingSetOption (
            pServer->hTapSrv,
            RPC_C_OPT_CALL_TIMEOUT,
            gdwRSPRpcTimeout
            );
        OnServerDisconnected (pServer);
    }
    else 
    {
        if (!bFromReg && dwNumDevices == 0)
        {
            //
            //  The server is found from DS and does not
            //  contain any lines for me, detach from it
            //
            TapiEnterCriticalSection(&gCriticalSection);
            RemoveEntryList (&pServer->ServerList);
            TapiLeaveCriticalSection(&gCriticalSection);
            Shutdown (pServer);
            RpcBindingFree(&pServer->hTapSrv);
            pServer->hTapSrv = NULL;
            DereferenceObject (ghHandleTable, pServer->InitContext, 1);
        }
        else
        {
            RpcBindingSetOption (
                pServer->hTapSrv,
                RPC_C_OPT_CALL_TIMEOUT,
                gdwRSPRpcTimeout
                );
        }
    }

    return 0;
}


VOID
WINAPI
NetworkPollThread(
    LPVOID pszThingtoPassToServer
    )
{
    LONG                    lResult;
    LIST_ENTRY              *pEntry;
    PCONTEXT_HANDLE_TYPE    phContext = NULL;

#if MEMPHIS

    LOG((TL_INFO, "NetworkPollThread: enter"));

#else

    HANDLE              hProcess;
    PRSP_THREAD_INFO    pTls;


    LOG((TL_INFO, "NetworkPollThread: enter"));


    //
    // This thread has no user context, which would prevent us from rpc'ing
    // back to remote tapisrv if necessary.  So, find the user that is logged
    // on and impersonate them in this thread.
    //

    if (!GetCurrentlyLoggedOnUser (&hProcess))
    {
        LOG((TL_ERROR, "NetworkPollThread: GetCurrentlyLoggedOnUser failed"));
        goto cleanup;
    }
    else if (!SetProcessImpersonationToken(hProcess))
    {
        LOG((TL_ERROR, "NetworkPollThread: SetProcessImpersonationToken failed"));
        goto cleanup;
    }

    if ((pTls = GetTls()))
    {
        pTls->bAlreadyImpersonated = TRUE;
    }
    else
    {
        goto cleanup;
    }

#endif


    //
    // Try to attach to servers once in a while. If we successfully attach
    // to a server then remove it from the Npt list and insert it in the
    // global "current" list.  When all the servers have been initialized
    // or TSPI_providerShutdown has signalled us then drop out of the loop
    // and clean up.
    //

    while (WaitForSingleObject (ghNptShutdownEvent, NPT_TIMEOUT)
               == WAIT_TIMEOUT)
    {
        BOOL        bListEmpty;
        
        if (gEventHandlerThreadParams.bExit)
        {
            goto cleanup;
        }

        TapiEnterCriticalSection (&gCriticalSection);
        
        bListEmpty = IsListEmpty (&gNptListHead);
        pEntry = gNptListHead.Flink;

        TapiLeaveCriticalSection (&gCriticalSection);
        
        if (bListEmpty)
        {
            continue;
        }

        while (pEntry != &gNptListHead)
        {
            if (gEventHandlerThreadParams.bExit)
            {
                goto cleanup;
            }


            //
            // Set the global which RemoteSPAttach looks at to know
            // who the current server is (could pass this as arg to
            // ClientAttach, but this is easiest for now)
            //

            gpCurrInitServer =
                CONTAINING_RECORD (pEntry, DRVSERVER, ServerList);

            if (!gpCurrInitServer->bSetAuthInfo)
            {
                RPC_STATUS  status;


                status = RpcBindingSetAuthInfo(
                    gpCurrInitServer->hTapSrv,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_AUTHN_WINNT,
                    NULL,
                    0
                    );

                if (status == RPC_S_OK)
                {
                    gpCurrInitServer->bSetAuthInfo = TRUE;
                }
            }

            RpcTryExcept
            {
                // set RPC binding

                hTapSrv = gpCurrInitServer->hTapSrv;

                gpCurrInitServer->dwSpecialHack = 0;

                lResult = ClientAttach(
                    &phContext,
                    0xffffffff,
                    &gpCurrInitServer->dwSpecialHack,
                    gszMailslotName,
                    pszThingtoPassToServer
                    );
                if (lResult != 0)
                {
                    LogRemoteSPError(gpCurrInitServer->szServerName, 
                                    ERROR_REMOTESP_NP_ATTACH, lResult, 0,
                                    TRUE);
                }
                else
                {
                    LogRemoteSPError(gpCurrInitServer->szServerName, 
                                    ERROR_REMOTESP_NONE, 0, 0,
                                    TRUE);
                }
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                LogRemoteSPError (gpCurrInitServer->szServerName,
                                    ERROR_REMOTESP_NP_EXCEPTION,
                                    RpcExceptionCode(), 0, TRUE);
                lResult = LINEERR_OPERATIONFAILED;
            }
            RpcEndExcept

            if (lResult == 0)
            {
                LOG((TL_INFO,
                    "NetworkPollThread: attached to server %s",
                    gpCurrInitServer->szServerName
                    ));

                TapiEnterCriticalSection(&gCriticalSection);
                RemoveEntryList (pEntry);
                pEntry->Blink = NULL;   //This node now is not in any link list
                pEntry = pEntry->Flink;
                TapiLeaveCriticalSection (&gCriticalSection);

                if (gpCurrInitServer->dwFlags & SERVER_DISCONNECTED)
                {
                    OnServerConnected(gpCurrInitServer);
                }

                //
                //  Enable all events for remotesp
                //
                gpCurrInitServer->phContext = phContext;
                RSPSetEventFilterMasks (
                    gpCurrInitServer,
                    TAPIOBJ_NULL,
                    (LONG_PTR)NULL,
                    (ULONG64)EM_ALL
                    );
                
                FinishEnumDevices(
                    gpCurrInitServer,
                    phContext,
                    NULL,
                    NULL,
                    FALSE,   // after init
                    TRUE
                    );
            }
            else
            {
                TapiEnterCriticalSection (&gCriticalSection);
                pEntry = pEntry->Flink;
                TapiLeaveCriticalSection (&gCriticalSection);
            }
        }
    }

cleanup:

#if MEMPHIS
#else
    ClearImpersonationToken();
    CloseHandle(hProcess);
#endif

    CloseHandle (ghNptShutdownEvent);

    TapiEnterCriticalSection (&gCriticalSection);
    while (!IsListEmpty (&gNptListHead))
    {
        PDRVSERVER  pServer;


        pEntry = RemoveHeadList (&gNptListHead);

        pServer = CONTAINING_RECORD (pEntry, DRVSERVER, ServerList);

        RpcBindingFree (&pServer->hTapSrv);

        DrvFree (CONTAINING_RECORD (pEntry, DRVSERVER, ServerList));
    }
    TapiLeaveCriticalSection (&gCriticalSection);

    LOG((TL_INFO, "NetworkPollThread: exit"));

    ExitThread (0);
}


VOID
PASCAL
FreeInitContext(
    PRSP_INIT_CONTEXT   pInitContext
    )
{
    LIST_ENTRY  *pEntry;


    while (!IsListEmpty (&pInitContext->ServerList))
    {
        PDRVSERVER  pServer;


        pEntry = RemoveHeadList (&pInitContext->ServerList);

        pServer = CONTAINING_RECORD (pEntry, DRVSERVER, ServerList);

        RpcBindingFree(&pServer->hTapSrv);

        DereferenceObject (ghHandleTable, pServer->InitContext, 1);
    }

    DrvFree (pInitContext);
}


BOOL
IsClientSystem(
    VOID
    )
{
    BOOL                        bResult = FALSE;
    DWORD                       dwInfoBufferSize, dwSize;
    HANDLE                      hAccessToken;
    LPWSTR                      InfoBuffer;
    PTOKEN_USER                 ptuUser;
    PSID                        pLocalSystemSid = NULL;
    PSID                        pLocalServiceSid = NULL;
    PSID                        pNetworkServiceSid = NULL;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = {SECURITY_NT_AUTHORITY};

    // First, build the SID for LocalSystem;
    if (!AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_LOCAL_SYSTEM_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pLocalSystemSid) ||
        !AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_LOCAL_SERVICE_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pLocalServiceSid) ||
        !AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_NETWORK_SERVICE_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pNetworkServiceSid)
        )
    {
        goto Return;
    }

    // Impersonate the client, and get it's SID
    if (RPC_S_OK != RpcImpersonateClient (0))
    {   
        goto Return;
    }

    if (OpenThreadToken(
            GetCurrentThread(),
            TOKEN_READ,
            FALSE,
            &hAccessToken
            ))
    {
        dwSize = 2048;

alloc_infobuffer:

        dwInfoBufferSize = 0;
        InfoBuffer = (LPWSTR) DrvAlloc (dwSize);
        if (NULL != InfoBuffer)
        {
            ptuUser = (PTOKEN_USER) InfoBuffer;

            if (GetTokenInformation(
                    hAccessToken,
                    TokenUser,
                    InfoBuffer,
                    dwSize,
                    &dwInfoBufferSize
                    ))
            {
                // Now, compare the 2 SIDs
                if (EqualSid (pLocalSystemSid, ptuUser->User.Sid) ||
                    EqualSid (pLocalServiceSid, ptuUser->User.Sid) ||
                    EqualSid (pNetworkServiceSid, ptuUser->User.Sid))
                    {
                        bResult = TRUE;
                    }
            }
            else
            {
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {
                    DrvFree (InfoBuffer);
                    dwSize *= 2;
                    goto alloc_infobuffer;
                }

                LOG((TL_ERROR,
                    "IsClientSystem: GetTokenInformation failed, error=%d",
                    GetLastError()
                    ));
            }
            
            DrvFree (InfoBuffer);

            CloseHandle (hAccessToken);
        }
        else
        {
            LOG((TL_ERROR,
                "IsClientSystem: DrvAlloc (%d) failed",
                dwSize
                ));
        }
    }
    else
    {
        LOG((TL_ERROR,
            "IsClientSystem: OpenThreadToken failed, error=%d",
            GetLastError()
            ));
    }

    RpcRevertToSelf ();

Return:
    if (pLocalSystemSid)
    {
        FreeSid (pLocalSystemSid);
    }
    if (pLocalServiceSid)
    {
        FreeSid (pLocalServiceSid);
    }
    if (pNetworkServiceSid)
    {
        FreeSid (pNetworkServiceSid);
    }
    return bResult;
}

#define LOWDWORD(ul64) ((DWORD)(ul64 & 0xffffffff))
#define HIDWORD(ul64) ((DWORD)((ul64 & 0xffffffff00000000) >> 32))

LONG 
WINAPI 
RSPSetEventFilterMasks (
    PDRVSERVER      pServer,
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMasks
)
{
    ULONG_PTR args[] =
    {
        (ULONG_PTR) pServer,                //  The server to call
        (ULONG_PTR) dwObjType,              //  type of object handle
        (ULONG_PTR) lObjectID,              //  object handle
        (ULONG_PTR) FALSE,                  //  fSubMask
        (ULONG_PTR) 0,                      //  dwSubMasks
        (ULONG_PTR) LOWDWORD(ulEventMasks), //  ulEventMasks low
        (ULONG_PTR) HIDWORD(ulEventMasks)   //  ulEventMasks hi
    };
    REMOTE_ARG_TYPES argTypes[] =
    {
        lpServer,
        Dword,
        Dword,
        Dword,
        Dword,
        Dword,
        Dword
    };
    REMOTE_FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 6, tSetEventMasksOrSubMasks),
        args,
        argTypes
    };

    return (REMOTEDOFUNC (&funcArgs, "RSPSetEventFilter"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\utils.h ===
#ifndef __REMOTESP_UTILS_H__
#define __REMOTESP_UTILS_H__

#ifdef __cplusplus
extern "C" {
#endif


#ifdef TRACELOG
	#include <windows.h>
	#include <winbase.h>
    #include <rtutils.h>
	
    #define MAXDEBUGSTRINGLENGTH 1024

    #define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL  TRACELogRegister(LPCTSTR szName);
    void  TRACELogDeRegister();
    void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

    extern char *TraceLevel(DWORD dwDbgLevel);
    extern void TAPIFormatMessage(HRESULT hr, LPVOID lpMsgBuf);



    #define TRACELOGREGISTER(arg) TRACELogRegister(arg)
    #define TRACELOGDEREGISTER() TRACELogDeRegister()
	#define LOG(arg) TRACELogPrint arg

	extern char    sg_szTraceName[100];
	extern DWORD   sg_dwTracingToDebugger;
	extern DWORD   sg_dwDebuggerMask;
    extern DWORD   sg_dwTraceID;

#else // TRACELOG not defined

    #define TRACELOGREGISTER(arg)
    #define TRACELOGDEREGISTER() 
    #define LOG(arg)

#endif // TRACELOG

#ifdef __cplusplus
}
#endif

#endif //__REMOTESP_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\utils.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif


#ifdef TRACELOG


DWORD   sg_dwTraceID = INVALID_TRACEID;
char    sg_szTraceName[100];   // saves name of dll

DWORD   sg_dwTracingToDebugger = 0;
DWORD   sg_dwTracingToConsole  = 0;
DWORD   sg_dwTracingToFile     = 0;
DWORD   sg_dwDebuggerMask      = 0;


BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{

    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID)
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}
 

char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
        case TL_TRACE: return "TRACE";
        case TL_EVENT: return "EVENT";
        default:       return " ??? ";
    }
}


#endif // TRACELOG
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\sp\remotesp\remotesp.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    remotesp.h

Abstract:

    This module contains defs, etc for the Remote TAPI Service Provider

Author:

    Dan Knudson (DanKn)    09-Aug-1995

Revision History:

--*/

#include "windows.h"
#include "stddef.h"
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "malloc.h"
#include "string.h"
#include "tapi.h"
#include "tspi.h"
#include "client.h"
#include "server.h"
#include "line.h"
#undef DEVICE_ID
#include "phone.h"
#include "tapsrv.h"
#include "tapi.h"
#include "tspi.h"
#include "resource.h"
#include "tlnklist.h"


//#define NO_DATA                         0xffffffff

#define DEF_NUM_LINE_ENTRIES            16
#define DEF_NUM_PHONE_ENTRIES           16
#define DEF_MAX_EVENT_BUFFER_SIZE       0x20000

#define IDI_ICON1                       101
#define IDI_ICON2                       102
#define IDI_ICON3                       103

#define DRVLINE_KEY                     ((DWORD) 'LpsR')
#define DRVCALL_KEY                     ((DWORD) 'CpsR')
#define DRVPHONE_KEY                    ((DWORD) 'PpsR')
#define DRVASYNC_KEY                    ((DWORD) 'ApsR')
#define DRVINVAL_KEY                    ((DWORD) 'IpsR')

#define RSP_MSG_UIID                    1

#define STRUCTCHANGE_LINECALLINFO       0x00000001
#define STRUCTCHANGE_LINECALLSTATUS     0x00000002
#if MEMPHIS
#else
#define STRUCTCHANGE_CALLIDS            0x00000004
#endif

#define INITIALTLSLISTSIZE              10

#define RSP_MAX_SERVER_NAME_SIZE        64

#define NPT_TIMEOUT                     60000

#define MIN_MAILSLOT_TIMEOUT            500
#define MAX_MAILSLOT_TIMEOUT            6000

#define ERROR_REMOTESP_NONE             0
#define ERROR_REMOTESP_ATTACH           1
#define ERROR_REMOTESP_EXCEPTION        2
#define ERROR_REMOTESP_NP_ATTACH        3
#define ERROR_REMOTESP_NP_EXCEPTION     4

typedef struct _RSP_INIT_CONTEXT
{
    DWORD                   dwNumRundownsExpected;
    BOOL                    bShutdown;
    LIST_ENTRY              ServerList;
    struct _RSP_INIT_CONTEXT   *pNextStaleInitContext;

    DWORD                   dwDrvServerKey;

} RSP_INIT_CONTEXT, *PRSP_INIT_CONTEXT;


#define SERVER_DISCONNECTED (0x00000001)
#define SERVER_REINIT       (0x00000002)


typedef struct _DRVSERVER
{
    DWORD                   dwKey;
    PRSP_INIT_CONTEXT       pInitContext;
    PCONTEXT_HANDLE_TYPE    phContext;
    HLINEAPP                hLineApp;

    HPHONEAPP               hPhoneApp;
    RPC_BINDING_HANDLE     *phTapSrv;
    DWORD                   dwFlags;
    BOOL                    bVer2xServer;

    DWORD                   dwSpecialHack;
    BOOL                    bConnectionOriented;
    LIST_ENTRY              ServerList;

    DWORD                   InitContext;
    BOOL                    bSetAuthInfo;
    RPC_BINDING_HANDLE      hTapSrv;
    BOOL                    bShutdown;

    char                    szServerName[MAX_COMPUTERNAME_LENGTH+1];

} DRVSERVER, *PDRVSERVER;


typedef struct _DRVLINE
{
    DWORD                   dwKey;
    DWORD                   dwDeviceIDLocal;
    DWORD                   dwDeviceIDServer;
    DWORD                   hDeviceCallback;

    DWORD                   dwXPIVersion;
    HLINE                   hLine;
    HTAPILINE               htLine;
    LPVOID                  pCalls;

    PDRVSERVER              pServer;
    LINEEXTENSIONID         ExtensionID;
    DWORD                   dwFlags;
    DWORD                   dwPermanentLineID;

} DRVLINE, *PDRVLINE;


typedef struct _DRVCALL
{
    DWORD                   dwKey;
    DWORD                   dwOriginalRequestID;
    PDRVSERVER              pServer;
    PDRVLINE                pLine;

    DWORD                   dwAddressID;
    HCALL                   hCall;
    DWORD                   dwDirtyStructs;
    LPLINECALLINFO          pCachedCallInfo;

    DWORD                   dwCachedCallInfoCount;
    LPLINECALLSTATUS        pCachedCallStatus;
    DWORD                   dwCachedCallStatusCount;
    struct _DRVCALL        *pPrev;

    struct _DRVCALL        *pNext;

    //
    // NOTE: Tapisrv relies on the ordering of the following two
    //       dwInitialXxx fields & the htCall field - don't change this!
    //

    ULONG_PTR               dwInitialCallStateMode;
    ULONG_PTR               dwInitialPrivilege;
    HTAPICALL               htCall;

#if MEMPHIS
#else
    DWORD                   dwCallID;
    DWORD                   dwRelatedCallID;
#endif
    DWORD                   dwFlags;

} DRVCALL, *PDRVCALL;


typedef struct _DRVPHONE
{
    DWORD                   dwKey;
    DWORD                   dwDeviceIDLocal;
    DWORD                   dwDeviceIDServer;
    DWORD                   hDeviceCallback;

    DWORD                   dwXPIVersion;
    HPHONE                  hPhone;
    PDRVSERVER              pServer;
    HTAPIPHONE              htPhone;

    PHONEEXTENSIONID        ExtensionID;
    DWORD                   dwPermanentPhoneID;

} DRVPHONE, *PDRVPHONE;


typedef struct _DRVLINELOOKUP
{
    DWORD                   dwTotalEntries;

    DWORD                   dwUsedEntries;

    struct _DRVLINELOOKUP  *pNext;

    DRVLINE                 aEntries[1];

} DRVLINELOOKUP, *PDRVLINELOOKUP;


typedef struct _DRVPHONELOOKUP
{
    DWORD                   dwTotalEntries;

    DWORD                   dwUsedEntries;

    struct _DRVPHONELOOKUP *pNext;

    DRVPHONE                aEntries[1];

} DRVPHONELOOKUP, *PDRVPHONELOOKUP;


typedef struct _RSP_THREAD_INFO
{
    LIST_ENTRY              TlsList;

    LPBYTE                  pBuf;

    DWORD                   dwBufSize;

    BOOL                    bAlreadyImpersonated;

} RSP_THREAD_INFO, *PRSP_THREAD_INFO;


typedef void (PASCAL *RSPPOSTPROCESSPROC)(PASYNCEVENTMSG pMsg,LPVOID pContext);


typedef struct _ASYNCREQUESTCONTEXT
{
    union
    {
        DWORD               dwKey;
        DWORD               dwOriginalRequestID;
    };

    RSPPOSTPROCESSPROC      pfnPostProcessProc;

    ULONG_PTR               Params[2];

} ASYNCREQUESTCONTEXT, *PASYNCREQUESTCONTEXT;


typedef enum
{
    Dword,
    LineID,
    PhoneID,
    Hdcall,
    Hdline,
    Hdphone,
    lpDword,
    lpsz,
    lpGet_SizeToFollow,
    lpSet_SizeToFollow,
    lpSet_Struct,
    lpGet_Struct,
    lpGet_CallParamsStruct,
    Size,
    lpServer,
    lpContext

} REMOTE_ARG_TYPES, *PREMOTE_ARG_TYPES;


typedef struct _REMOTE_FUNC_ARGS
{
    DWORD                   Flags;

    ULONG_PTR              *Args;

    PREMOTE_ARG_TYPES       ArgTypes;

} REMOTE_FUNC_ARGS, *PREMOTE_FUNC_ARGS;


HANDLE              ghInst;

char                gszServer[] = "Server",
                    gszProvider[] = "Provider",
                    gszNumServers[] = "NumServers",
                    gszTelephonIni[] = "Telephon.ini";

WCHAR               gszMachineName[MAX_COMPUTERNAME_LENGTH + 1];
WCHAR               gszRealSPUIDLL[MAX_PATH+1];
char                gszDomainUser[64];

DWORD               gdwLineDeviceIDBase,
                    gdwPhoneDeviceIDBase,
                    gdwInitialNumLineDevices,
                    gdwInitialNumPhoneDevices,
                    gdwTempLineID = 0xFFFFFFFF,
                    gdwTempPhoneID = 0xFFFFFFFF,
                    gdwTlsIndex,
                    gdwPermanentProviderID,
                    gdwRetryCount,
                    gdwRetryTimeout,
                    gdwCacheForceCallCount,
                    gdwMaxEventBufferSize,
                    gdwRSPRpcTimeout;

BOOL                gfCacheStructures;

HICON               ghLineIcon,
                    ghPhoneIcon;

HANDLE              hToken,
                    ghRpcServerThread;

HPROVIDER           ghProvider;

LINEEVENT           gpfnLineEventProc;
PHONEEVENT          gpfnPhoneEventProc;
PDRVLINELOOKUP      gpLineLookup;
PDRVPHONELOOKUP     gpPhoneLookup;

ASYNC_COMPLETION    gpfnCompletionProc;

CRITICAL_SECTION    gEventBufferCriticalSection,
                    gCallListCriticalSection,
                    gcsTlsList;

#ifdef __TAPI_DEBUG_CS__
    DEBUG_CS_CRITICAL_SECTION   gCriticalSection;
#else
    CRITICAL_SECTION            gCriticalSection;
#endif

DWORD               gdwTlsListUsedEntries,
                    gdwTlsListTotalEntries;
PRSP_THREAD_INFO  * gpTlsList;

BOOL                gbLoadedSelf = FALSE,
                    gbInitialized;
PRSP_INIT_CONTEXT   gpCurrentInitContext, gpStaleInitContexts;
DWORD               gdwNumStaleInitContexts;
DWORD               gdwDrvServerKey;
LIST_ENTRY          gNptListHead;
HANDLE              ghNetworkPollThread = NULL;
PWSTR               gpszThingToPassToServer = NULL;
HANDLE              ghNptShutdownEvent;
PDRVSERVER          gpCurrInitServer;

WCHAR               gszMailslotName[MAX_COMPUTERNAME_LENGTH + 32];

const TCHAR gszTelephonyKey[] =
                "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony";

LONG gaNoMemErrors[3] =
{
    0,
    LINEERR_NOMEM,
    PHONEERR_NOMEM
};

LONG gaOpFailedErrors[3] =
{
    0,
    LINEERR_OPERATIONFAILED,
    PHONEERR_OPERATIONFAILED
};


LONG gaServerDisconnectedErrors[3] =
{
    0,
    LINEERR_DISCONNECTED,
    PHONEERR_DISCONNECTED
};

LONG gaServerReInitErrors[3] =
{
    0,
    LINEERR_REINIT,
    PHONEERR_REINIT
};

struct
{
    HANDLE          hThread;
    DWORD           dwEventBufferTotalSize;
    DWORD           dwEventBufferUsedSize;
    LPBYTE          pEventBuffer;

    LPBYTE          pDataIn;
    LPBYTE          pDataOut;
    HANDLE          hEvent;
    BOOL            bExit;

    HANDLE          hMailslot;
    HANDLE          hMailslotEvent;
    DWORD           dwMsgBufferTotalSize;
    LPBYTE          pMsgBuffer;

} gEventHandlerThreadParams;


#if DBG

LONG
WINAPI
RemoteDoFunc(
    PREMOTE_FUNC_ARGS   pFuncArgs,
    char               *pszFuncName
    );

#define REMOTEDOFUNC(arg1,arg2) RemoteDoFunc(arg1,arg2)

DWORD gdwDebugLevel = 0;
DWORD gdwAllocTag = 0;

#else

LONG
WINAPI
RemoteDoFunc(
    PREMOTE_FUNC_ARGS   pFuncArgs
    );

#define REMOTEDOFUNC(arg1,arg2) RemoteDoFunc(arg1)

#endif


BOOL
WINAPI
_CRT_INIT(
    HINSTANCE   hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    );

void
PASCAL
TSPI_lineMakeCall_PostProcess(
    PASYNCEVENTMSG          pMsg,
    PASYNCREQUESTCONTEXT    pContext
    );

LONG
AddLine(
    PDRVSERVER          pServer,
    DWORD               dwDeviceIDLocal,
    DWORD               dwDeviceIDServer,
    BOOL                bInit,
    BOOL                bNegotiate,
    DWORD               dwAPIVerion,
    LPLINEEXTENSIONID   pExtID
    );

LONG
AddPhone(
    PDRVSERVER          pServer,
    DWORD               dwDeviceIDLocal,
    DWORD               dwDeviceIDServer,
    BOOL                bInit,
    BOOL                bNegotiate,
    DWORD               dwAPIVerion,
    LPPHONEEXTENSIONID  pExtID
    );

LONG
AddCallToList(
    PDRVLINE    pLine,
    PDRVCALL    pCall
    );

LONG
RemoveCallFromList(
    PDRVCALL    pCall
    );

void
Shutdown(
    PDRVSERVER  pServer
    );


BOOL
CALLBACK
ConfigDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG
PASCAL
ProviderInstall(
    char   *pszProviderName,
    BOOL    bNoMultipleInstance
    );

void
FreeLeftoverTlsEntries(
    );

void
RemoveTlsFromList(
    PRSP_THREAD_INFO p
    );

void
AddTlsToList(
    PRSP_THREAD_INFO p
    );

VOID
PASCAL
FreeInitContext(
    PRSP_INIT_CONTEXT   pInitContext
    );

LONG
FinishEnumDevices(
    PDRVSERVER              pServer,
    PCONTEXT_HANDLE_TYPE    phContext,
    LPDWORD                 lpdwNumLines,
    LPDWORD                 lpdwNumPhones,
    BOOL                    fStartup,
    BOOL                    bFromReg
    );

VOID
WINAPI
NetworkPollThread(
    LPVOID pszThingtoPassToServer
    );

VOID
PASCAL
FreeInitContext(
    PRSP_INIT_CONTEXT   pInitContext
    );

BOOL
IsClientSystem(
    VOID
    );

void
PASCAL
TSPI_lineGatherDigits_PostProcess(
    PASYNCEVENTMSG          pMsg
    );

LONG 
WINAPI 
RSPSetEventFilterMasks (
    PDRVSERVER      pServer,
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMasks
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\tapihndl\tapihndl.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    Handle table library.  Handles are generated as follows :

        handle =
            Base value +
            (Table entry index << 4) +
            (Handle usage instance & 0xf)

    A free list is kept in the handle table header, with the oldest free
    entry being at the head of the list & the youngest at the tail.
    The low four bits of the handle values are used for a usage instance
    count, which gets incremented every time a handle is freed (to
    prevent immediate re-use of the same handle value).

Author:

    Dan Knudson (DanKn)    15-Sep-1998

Revision History:

--*/


#include "windows.h"
#include "assert.h"
#include "tlnklist.h"
#include "tapihndl.h"


#define TABLE_DELTA 64


BOOL
GrowTable(
    PHANDLETABLEHEADER  Header
    )
/*++

    Returns: Index of next free table entry if success, -1 if error

--*/
{
    DWORD               numEntries = Header->NumEntries, i, numAdditionalEntries;
    PHANDLETABLEENTRY   newTable;

    // First, we need to compute how many entries we can still alloc.
    // To do this, we need to now how many entries can the table accommodate,
    // so that the largest handle value will not exceed MAXDWORD. We get
    // this by reversing the algorithm used to compute handle values based
    // on the table entry's index.

    numAdditionalEntries = (MAXDWORD - Header->HandleBase) >> 4;    // This is the maximum number of entries in the table,
                                                                    // so that handle values do not overflow DWORDs.
    numAdditionalEntries -= numEntries;                             // This is how many entries we can still alloc;
    if (0 == numAdditionalEntries)
    {
        // The table is already as big as it can be...
        return FALSE;
    }
    if (numAdditionalEntries > TABLE_DELTA)
    {
        numAdditionalEntries = TABLE_DELTA;                         // We only grow the handle table in TABLE_DELTA or
    }                                                               // or smaller increments.

    if (!(newTable = HeapAlloc(
            Header->Heap,
            0,
            (numEntries + numAdditionalEntries) * sizeof (*newTable)
            )))
    {
        return FALSE;
    }

    CopyMemory(
        newTable,
        Header->Table,
        numEntries * sizeof(*newTable)
        );

    for (i = numEntries; i < numEntries + TABLE_DELTA; i++)
    {
        //
        // Init this entry.  Note that we set "Instance = i" to stagger
        // the handle values, because we know tapisrv queues events &
        // completion msgs to a specific SPEVentHandlerThread based on
        // handle values.
        //

        PHANDLETABLEENTRY   entry = newTable + i;


        InsertHeadList (&Header->FreeList, &entry->ListEntry);
        entry->Handle = 0;
        entry->Instance = i;
    }

    if (Header->Table)
    {
        HeapFree (Header->Heap, 0, Header->Table);
    }

    Header->Table = newTable;
    Header->NumEntries += TABLE_DELTA;

    return TRUE;
}


HANDLE
CreateHandleTable(
    HANDLE              Heap,
    FREECONTEXTCALLBACK FreeContextCallback,
    DWORD               MinHandleValue,
    DWORD               MaxHandleValue
    /* Right now, MaxHandleValue is not used. If we find that we
       need to use it however, store it in the table header and
       replace MAXDWORD with it in the code at the beginning of
       GrowTable */
    )
/*++

--*/
{
    PHANDLETABLEHEADER  header;


    if (!(header = HeapAlloc (Heap, HEAP_ZERO_MEMORY, sizeof (*header))))
    {
        return NULL;
    }

    header->Heap = Heap;
    header->HandleBase = MinHandleValue;
    header->FreeContextCallback = FreeContextCallback;

    InitializeListHead (&header->FreeList);

    InitializeCriticalSectionAndSpinCount (&header->Lock, 0x80001000);

    if (!GrowTable (header))
    {
        DeleteCriticalSection (&header->Lock);

        HeapFree (Heap, 0, header);

        return NULL;
    }

    return ((HANDLE) header);
}


VOID
DeleteHandleTable(
    HANDLE      HandleTable
    )
/*++

--*/
{
    PHANDLETABLEHEADER  header = (PHANDLETABLEHEADER) HandleTable;


    HeapFree (header->Heap, 0, header->Table);

    DeleteCriticalSection (&header->Lock);

    HeapFree (header->Heap, 0, header);
}

//
// Distinct calls of NewObject and NewObjectEx in the same handle table always return distinct handles.
// All NewObject calls in tapisrv use the same handle table, so the handles are known to be distinct, 
// even between different types of objects (i.e. HCALL vs. HLINE)
// This will need to remain true if the NewObject() implementation changes in the future, 
// as various TAPI operations use this assumption.
//

DWORD    
NewObject(
    HANDLE      HandleTable,
    LPVOID      Context,
    LPVOID      Context2
    )
/*++

--*/
{
    DWORD               handle;
    PHANDLETABLEENTRY   entry;
    PHANDLETABLEHEADER  header = (PHANDLETABLEHEADER) HandleTable;


    if (header  &&  Context)
    {
        EnterCriticalSection (&header->Lock);

        if (IsListEmpty (&header->FreeList))
        {
            if (!GrowTable (header))
            {
                LeaveCriticalSection (&header->Lock);
                return 0;
            }
        }

        entry = (PHANDLETABLEENTRY) RemoveHeadList (&header->FreeList);

        entry->Context.C = Context;
        entry->Context.C2 = Context2;
        entry->Handle =
            header->HandleBase +
            (((DWORD)(entry - header->Table)) << 4) +   // (entry_index << 4) is guraranteed 
                                                        // to fit in a DWORD (see comments at the
                                                        // start of GrowTable).
            (entry->Instance & 0xf);
        entry->ReferenceCount = 1;

        handle = entry->Handle;

        LeaveCriticalSection (&header->Lock);
    }
    else
    {
        handle = 0;
    }

    return handle;
}


DWORD    
NewObjectEx(
    HANDLE      HandleTable,
    LPVOID      Context,
    LPVOID      Context2,
    DWORD       ModBase,
    DWORD       Remainder
    )
/*++

    The purpose of this func is to support the consult call hack in
    tapisrv!LSetupConference, where we need to make sure that the
    handle we give back will map to the same SPEventThread (queue) ID
    that specified by the ModBase/Remainder params.

--*/
{
    BOOL                growTableCount = 0;
    DWORD               handle;
    PHANDLETABLEENTRY   entry;
    PHANDLETABLEHEADER  header = (PHANDLETABLEHEADER) HandleTable;


    if (header  &&  Context)
    {
        EnterCriticalSection (&header->Lock);

findEntry:

        for(
            entry = (PHANDLETABLEENTRY) header->FreeList.Flink;
            entry != (PHANDLETABLEENTRY) &header->FreeList;
            entry = (PHANDLETABLEENTRY) entry->ListEntry.Flink
            )
        {
            handle =
                header->HandleBase +
                (((DWORD)(entry - header->Table)) << 4) +   // (entry_index << 4) is guraranteed 
                                                            // to fit in a DWORD (see comments at the
                                                            // start of GrowTable).
                (entry->Instance & 0xf);

            // TODO: possible optimization is that if following
            //       evaluates to FALSE try (handle % ModBase)+1, +2, ...
            //       but don't go too far, don't want immediate handle reuse

            if ((handle % ModBase) == Remainder)
            {
                break;
            }
        }

        if (entry != (PHANDLETABLEENTRY) &(header->FreeList))
        {
            RemoveEntryList (&entry->ListEntry);
        }
        else
        {
            //
            // Couldn't find a free entry that works, try growing the table
            //

            if (growTableCount > 3)
            {
                LeaveCriticalSection (&header->Lock);
                return 0;
            }

            if (!GrowTable (HandleTable))
            {
                LeaveCriticalSection (&header->Lock);
                return 0;
            }

            growTableCount++;
            goto findEntry;
        }

        entry->Context.C = Context;
        entry->Context.C2 = Context2;
        entry->Handle = handle;
        entry->ReferenceCount = 1;

        LeaveCriticalSection (&header->Lock);
    }
    else
    {
        handle = 0;
    }

    return handle;
}


LPVOID
ReferenceObject(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       Key
    )
/*++

--*/
{
    LPVOID              context = 0;
    DWORD               index;
    PHANDLETABLEENTRY   entry;
    PHANDLETABLEHEADER  header = (PHANDLETABLEHEADER) HandleTable;


    if (header  &&  Handle >= header->HandleBase)
    {
        index = (Handle - header->HandleBase) >> 4;

        if (index < header->NumEntries)
        {
            EnterCriticalSection (&header->Lock);

            entry = header->Table + index;

            if (entry->Handle == Handle  &&  entry->ReferenceCount != 0)
            {
                context = entry->Context.C;

                if (Key)
                {
                    try
                    {
                        if (*((LPDWORD) context) == Key)
                        {
                            entry->ReferenceCount++;
                        }
                        else
                        {
                            context = 0;
                        }
                    }
                    except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        context = 0;
                    }
                }
                else
                {
                    entry->ReferenceCount++;
                }
            }

            LeaveCriticalSection (&header->Lock);
        }
    }

    return context;
}


LPVOID
ReferenceObjectEx(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       Key,
    LPVOID     *Context2
    )
/*++

--*/
{
    LPVOID              context = 0;
    DWORD               index;
    PHANDLETABLEENTRY   entry;
    PHANDLETABLEHEADER  header = (PHANDLETABLEHEADER) HandleTable;


    if (header  &&  Handle >= header->HandleBase)
    {
        index = (Handle - header->HandleBase) >> 4;

        if (index < header->NumEntries)
        {
            EnterCriticalSection (&header->Lock);

            entry = header->Table + index;

            if (entry->Handle == Handle  &&  entry->ReferenceCount != 0)
            {
                context = entry->Context.C;
                *Context2 = entry->Context.C2;

                if (Key)
                {
                    try
                    {
                        if (*((LPDWORD) context) == Key)
                        {
                            entry->ReferenceCount++;
                        }
                        else
                        {
                            context = 0;
                        }
                    }
                    except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        context = 0;
                    }
                }
                else
                {
                    entry->ReferenceCount++;
                }
            }

            LeaveCriticalSection (&header->Lock);
        }
    }

    return context;
}


VOID
DereferenceObject(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       DereferenceCount
    )
/*++

--*/
{
    LPVOID              context, context2;
    DWORD               index;
    PHANDLETABLEENTRY   entry;
    PHANDLETABLEHEADER  header = (PHANDLETABLEHEADER) HandleTable;


    if (header  &&  Handle >= header->HandleBase)
    {
        index = (Handle - header->HandleBase) >> 4;

        if (index < header->NumEntries)
        {
            EnterCriticalSection (&header->Lock);

            entry = header->Table + index;

            if (entry->Handle == Handle  &&  entry->ReferenceCount != 0)
            {
                assert (DereferenceCount >= entry->ReferenceCount);

                entry->ReferenceCount -= DereferenceCount;

                if (entry->ReferenceCount == 0)
                {
                    entry->Instance = entry->Handle + 1;

                    entry->Handle = 0;

                    context = entry->Context.C;
                    context2 = entry->Context.C2;

                    InsertTailList (&header->FreeList, &entry->ListEntry);

                    LeaveCriticalSection (&header->Lock);

                    (*header->FreeContextCallback)(context, context2);

                    return;
                }
            }
            else
            {
                // assert
            }

            LeaveCriticalSection (&header->Lock);
        }
        else
        {
            // assert
        }
    }
}

void
ReleaseAllHandles(
    HANDLE      HandleTable,
    PVOID       Context2
    )
{
    DWORD               index;
    LPVOID              context, context2;
    PHANDLETABLEENTRY   entry;
    PHANDLETABLEHEADER  header = (PHANDLETABLEHEADER) HandleTable;


    if (header && NULL != Context2)
    {
        EnterCriticalSection (&header->Lock);

        for (index = 0, entry = header->Table;
             index < header->NumEntries;
             index++, entry++)
        {
            if (0 != entry->Handle &&
                entry->Context.C2 == Context2)
            {
                entry->Instance = entry->Handle + 1;

                entry->Handle = 0;

                context = entry->Context.C;
                context2 = entry->Context.C2;

                InsertTailList (&header->FreeList, &entry->ListEntry);

                (*header->FreeContextCallback)(context, context2);
            }
        }

        LeaveCriticalSection (&header->Lock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\thunk\thunk.h ===
#define WF_WINNT 0x4000

#define TAPI_APP_DATA_KEY      0x44415441
#define GWL_APPDATA            0
#define WM_ASYNCEVENT          (WM_USER+111)
#define NUM_TAPI32_PROCS       ( THIS_MUST_BE_THE_LAST_ENTRY )

typedef void (FAR PASCAL *MYPROC)();
//typedef MYPROC NEAR * PMYPROC;


typedef LONG (FAR PASCAL *PFNCALLPROC1)(DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC2)(DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC3)(DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC4)(DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC5)(DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC6)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC7)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC8)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC9)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC10)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC11)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);
typedef LONG (FAR PASCAL *PFNCALLPROC12)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPVOID, DWORD, DWORD);

typedef struct _TAPI16_CALLBACKMSG
{
    DWORD   hDevice;

    DWORD   dwMsg;

    DWORD   dwCallbackInstance;

    DWORD   dwParam1;

    DWORD   dwParam2;

    DWORD   dwParam3;

} TAPI16_CALLBACKMSG, FAR *LPTAPI16_CALLBACKMSG;


typedef struct _TAPI_APP_DATA
{
    DWORD           dwKey;

    HWND            hwnd;

    LINECALLBACK    lpfnCallback;

    BOOL            bPendingAsyncEventMsg;

    DWORD           hXxxApp;

} TAPI_APP_DATA, FAR *LPTAPI_APP_DATA;


typedef enum
{
    lAccept,
    lAddProvider,
    lAddToConference,
    lAnswer,
    lBlindTransfer,
    lClose,
    lCompleteCall,
    lCompleteTransfer,
    lConfigDialog,
    lConfigDialogEdit,
    lConfigProvider,
    lDeallocateCall,
    lDevSpecific,
    lDevSpecificFeature,
    lDial,
    lDrop,
    lForward,
    lGatherDigits,
    lGenerateDigits,
    lGenerateTone,
    lGetAddressCaps,
    lGetAddressID,
    lGetAddressStatus,
    lGetAppPriority,
    lGetCallInfo,
    lGetCallStatus,
    lGetConfRelatedCalls,
    lGetCountry,
    lGetDevCaps,
    lGetDevConfig,
    lGetIcon,
    lGetID,
    lGetLineDevStatus,
    lGetNewCalls,
    lGetNumRings,
    lGetProviderList,
    lGetRequest,
    lGetStatusMessages,
    lGetTranslateCaps,
    lHandoff,
    lHold,
    lInitialize,
    lMakeCall,
    lMonitorDigits,
    lMonitorMedia,
    lMonitorTones,
    lNegotiateAPIVersion,
    lNegotiateExtVersion,
    lOpen,
    lPark,
    lPickup,
    lPrepareAddToConference,
    lRedirect,
    lRegisterRequestRecipient,
    lReleaseUserUserInfo,
    lRemoveFromConference,
    lRemoveProvider,
    lSecureCall,
    lSendUserUserInfo,
    lSetAppPriority,
    lSetAppSpecific,
    lSetCallParams,
    lSetCallPrivilege,
    lSetCurrentLocation,
    lSetDevConfig,
    lSetMediaControl,
    lSetMediaMode,
    lSetNumRings,
    lSetStatusMessages,
    lSetTerminal,
    lSetTollList,
    lSetupConference,
    lSetupTransfer,
    lShutdown,
    lSwapHold,
    lTranslateAddress,
    lTranslateDialog,
    lUncompleteCall,
    lUnhold,
    lUnpark,

    pClose,
    pConfigDialog,
    pDevSpecific,
    pGetButtonInfo,
    pGetData,
    pGetDevCaps,
    pGetDisplay,
    pGetGain,
    pGetHookSwitch,
    pGetID,
    pGetIcon,
    pGetLamp,
    pGetRing,
    pGetStatus,
    pGetStatusMessages,
    pGetVolume,
    pInitialize,
    pOpen,
    pNegotiateAPIVersion,
    pNegotiateExtVersion,
    pSetButtonInfo,
    pSetData,
    pSetDisplay,
    pSetGain,
    pSetHookSwitch,
    pSetLamp,
    pSetRing,
    pSetStatusMessages,
    pSetVolume,
    pShutdown,

    tGetLocationInfo,
    tRequestDrop,
    tRequestMakeCall,
    tRequestMediaCall,

    GetTapi16CallbkMsg,
    LOpenDialAsstVAL,
    LAddrParamsInitedVAL,
    lOpenInt,
    lShutdownInt,
    LocWizardDlgProc32,

	THIS_MUST_BE_THE_LAST_ENTRY

} PROC_INDICES;


char far *gaFuncNames[] =
{
    "lineAccept",
    "lineAddProvider",
    "lineAddToConference",
    "lineAnswer",
    "lineBlindTransfer",
    "lineClose",
    "lineCompleteCall",
    "lineCompleteTransfer",
    "lineConfigDialog",
    "lineConfigDialogEdit",
    "lineConfigProvider",
    "lineDeallocateCall",
    "lineDevSpecific",
    "lineDevSpecificFeature",
    "lineDial",
    "lineDrop",
    "lineForward",
    "lineGatherDigits",
    "lineGenerateDigits",
    "lineGenerateTone",
    "lineGetAddressCaps",
    "lineGetAddressID",
    "lineGetAddressStatus",
    "lineGetAppPriority",
    "lineGetCallInfo",
    "lineGetCallStatus",
    "lineGetConfRelatedCalls",
    "lineGetCountry",
    "lineGetDevCaps",
    "lineGetDevConfig",
    "lineGetIcon",
    "lineGetID",
    "lineGetLineDevStatus",
    "lineGetNewCalls",
    "lineGetNumRings",
    "lineGetProviderList",
    "lineGetRequest",
    "lineGetStatusMessages",
    "lineGetTranslateCaps",
    "lineHandoff",
    "lineHold",
    "lineInitialize",
    "lineMakeCall",
    "lineMonitorDigits",
    "lineMonitorMedia",
    "lineMonitorTones",
    "lineNegotiateAPIVersion",
    "lineNegotiateExtVersion",
    "lineOpen",
    "linePark",
    "linePickup",
    "linePrepareAddToConference",
    "lineRedirect",
    "lineRegisterRequestRecipient",
    "lineReleaseUserUserInfo",
    "lineRemoveFromConference",
    "lineRemoveProvider",
    "lineSecureCall",
    "lineSendUserUserInfo",
    "lineSetAppPriority",
    "lineSetAppSpecific",
    "lineSetCallParams",
    "lineSetCallPrivilege",
    "lineSetCurrentLocation",
    "lineSetDevConfig",
    "lineSetMediaControl",
    "lineSetMediaMode",
    "lineSetNumRings",
    "lineSetStatusMessages",
    "lineSetTerminal",
    "lineSetTollList",
    "lineSetupConference",
    "lineSetupTransfer",
    "lineShutdown",
    "lineSwapHold",
    "lineTranslateAddress",
    "lineTranslateDialog",
    "lineUncompleteCall",
    "lineUnhold",
    "lineUnpark",

    "phoneClose",
    "phoneConfigDialog",
    "phoneDevSpecific",
    "phoneGetButtonInfo",
    "phoneGetData",
    "phoneGetDevCaps",
    "phoneGetDisplay",
    "phoneGetGain",
    "phoneGetHookSwitch",
    "phoneGetID",
    "phoneGetIcon",
    "phoneGetLamp",
    "phoneGetRing",
    "phoneGetStatus",
    "phoneGetStatusMessages",
    "phoneGetVolume",
    "phoneInitialize",
    "phoneOpen",
    "phoneNegotiateAPIVersion",
    "phoneNegotiateExtVersion",
    "phoneSetButtonInfo",
    "phoneSetData",
    "phoneSetDisplay",
    "phoneSetGain",
    "phoneSetHookSwitch",
    "phoneSetLamp",
    "phoneSetRing",
    "phoneSetStatusMessages",
    "phoneSetVolume",
    "phoneShutdown",

    "tapiGetLocationInfo",
    "tapiRequestDrop",
    "tapiRequestMakeCall",
    "tapiRequestMediaCall",

    "GetTapi16CallbackMsg",
    "LOpenDialAsst",
    "LAddrParamsInited",
    "lineOpenInt",
    "lineShutdownInt",
    "LocWizardDlgProc"

};


DWORD     ghLib = 0;
HINSTANCE ghInst;
MYPROC    gaProcs[NUM_TAPI32_PROCS];

LRESULT
CALLBACK
Tapi16HiddenWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

#if CHICOBUILD
DWORD
FAR
PASCAL
LoadLibraryEx32W(
    LPCSTR,
    DWORD,
    DWORD
    );

BOOL
FAR
PASCAL
FreeLibrary32W(
    DWORD
    );

DWORD
FAR
PASCAL
GetProcAddress32W(
    DWORD,
    LPCSTR
    );

DWORD
FAR
PASCAL
CallProc32W(
    DWORD,
    LPVOID,
    DWORD,
    DWORD
    );
#endif


PFNCALLPROC1  pfnCallProc1  = (PFNCALLPROC1)  CallProc32W;
PFNCALLPROC2  pfnCallProc2  = (PFNCALLPROC2)  CallProc32W;
PFNCALLPROC3  pfnCallProc3  = (PFNCALLPROC3)  CallProc32W;
PFNCALLPROC4  pfnCallProc4  = (PFNCALLPROC4)  CallProc32W;
PFNCALLPROC5  pfnCallProc5  = (PFNCALLPROC5)  CallProc32W;
PFNCALLPROC6  pfnCallProc6  = (PFNCALLPROC6)  CallProc32W;
PFNCALLPROC7  pfnCallProc7  = (PFNCALLPROC7)  CallProc32W;
PFNCALLPROC8  pfnCallProc8  = (PFNCALLPROC8)  CallProc32W;
PFNCALLPROC9  pfnCallProc9  = (PFNCALLPROC9)  CallProc32W;
PFNCALLPROC10 pfnCallProc10 = (PFNCALLPROC10) CallProc32W;
PFNCALLPROC11 pfnCallProc11 = (PFNCALLPROC11) CallProc32W;
PFNCALLPROC12 pfnCallProc12 = (PFNCALLPROC12) CallProc32W;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\thunk\makefile.inc ===
# TAPI.DLL thunk makefile
#
# Copyright (c) 1995, Microsoft Corporation
#
# History:
#   Created.
#


!INCLUDE $(NTMAKEENV)\makefile.plt


.SUFFIXES:
.SUFFIXES: .c   .asm .h   .inc .obj .lst .sys .exe .com .map .sym .def .lib .rc .res

# The files currently live in mvdm\wow16\inc and need to be published
#  SDK_INC16_PATH=..\..\..\Base\mvdm\wow16\inc

INCS    = -I..\inc -I$(SDK_INC16_PATH) -I$(SDK_INC_PATH)
INCLUDE_PATH=..\inc;$(SDK_INC16_PATH);$(SDK_INC_PATH)
PATH=$(PATH_TOOLS16);$(PATH)


AOBJ    = -t $(DEFINES) $(INCS)

CW16    = -ALw -G2sw -Os -W3 -Zd -Zp $(DEFINES)
CW16B   = $(CW16) -B1 c1l.exe -B2 c2l.exe -B3 c3l.exe

LINK    = /map /align:16 /batch

!if !$(FREEBUILD)
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Od /Oi
LINK    = $(LINK) /LI
!endif


.asm.obj:
    masm $(AOBJ) $*;

.asm.lst:
    masm $(AOBJ) -l $*,nul,$*.lst;


.c.obj:
    cl16 -c $(CW16) $*.c

.c.pp:
    cl16 -c $(CW16) -E $*.c > $@

.c.lst:
    cl16 -c $(CW16) -Fonul -Fc$*.lst $*.c


#.def.lib:
#    implib $*.lib $*.def

#.map.sym:
#    mapsym $*

.rc.res:


all: $(O)\tapi.dll $(O)\tapi.sym
#    binplace tapi.dll tapi.sym

clean: cleanup all

cleanup:
    if exist *.lrf del *.lrf
    if exist *.obj del *.obj
    if exist *.exe del *.exe
    if exist *.map del *.map
    if exist *.sym del *.sym
    if exist *.drv del *.drv
    if exist *.res del *.res


$(O)\thunk.obj: thunk.c thunk.h
    set include=$(INCLUDE_PATH)
    cl16 -c $(CW16) -Fo$@ thunk.c

$(O)\tapi.res: tapi.rc
    rc16 -DWINNT=1 -r $(INCS) -fo $@ tapi.rc

$(O)\tapi.lrf: makefile.inc
    echo $(SDK_LIB16_PATH)\libentry.obj $(O)\thunk.obj >$@
    echo $*.dll/align:16>>$@
    echo $* $(LINK)>>$@
    echo $(SDK_LIB16_PATH)\ldllcew.lib libw.lib /map /nod>>$@
    echo tapi.def;>>$@

$(O)\tapi.dll $(O)\tapi.map: $(O)\thunk.obj tapi.def $(O)\tapi.res $(O)\tapi.lrf
    link16 @$(O)\tapi.lrf;
    rc16 -t $(O)\tapi.res $(O)\tapi.dll

$(O)\tapi.sym: $(O)\tapi.map
    mapsym -o $@ $*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\thunk\thunk.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    thunk.c

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    dd-Mmm-1995

Revision History:

--*/



#define NOGDI             GDI APIs and definitions
#define NOSOUND           Sound APIs and definitions
#define NODRIVERS         Installable driver APIs and definitions
#define NOIMT             Installable messge thunk APIs and definitions
#define NOMINMAX          min() and max() macros
#define NOLOGERROR        LogError() and related definitions
#define NOPROFILER        Profiler APIs
#define NOLFILEIO         _l* file I/O routines
#define NOOPENFILE        OpenFile and related definitions
#define NORESOURCE        Resource management
#define NOATOM            Atom management
#define NOLANGUAGE        Character test routines
#define NOLSTRING         lstr* string management routines
#define NODBCS            Double-byte character set routines
#define NOKEYBOARDINFO    Keyboard driver routines
#define NOGDICAPMASKS     GDI device capability constants
#define NOCOLOR           COLOR_* color values
#define NOGDIOBJ          GDI pens, brushes, fonts
#define NODRAWTEXT        DrawText() and related definitions
#define NOTEXTMETRIC      TEXTMETRIC and related APIs
#define NOSCALABLEFONT    Truetype scalable font support
#define NOBITMAP          Bitmap support
#define NORASTEROPS       GDI Raster operation definitions
#define NOMETAFILE        Metafile support
#define NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
#define NOSHOWWINDOW      ShowWindow and related definitions
#define NODEFERWINDOWPOS  DeferWindowPos and related definitions
#define NOVIRTUALKEYCODES VK_* virtual key codes
#define NOKEYSTATES       MK_* message key state flags
#define NOWH              SetWindowsHook and related WH_* definitions
#define NOMENUS           Menu APIs
#define NOSCROLL          Scrolling APIs and scroll bar control
#define NOCLIPBOARD       Clipboard APIs and definitions
#define NOICONS           IDI_* icon IDs
#define NOMB              MessageBox and related definitions
#define NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
#define NOMDI             MDI support
//#define NOCTLMGR          Control management and controls
#define NOWINMESSAGES     WM_* window messages


#include "windows.h"

#include <stdlib.h>
//#include <malloc.h>

#include <string.h>


#define TAPI_CURRENT_VERSION 0x00010004

#ifndef ULONG_PTR
#define ULONG_PTR DWORD
#endif
#ifndef DWORD_PTR
#define DWORD_PTR DWORD
#endif

//#include "..\inc\tapi.h"
#include <tapi.h>

#include "thunk.h"


DWORD FAR CDECL CallProcEx32W( DWORD, DWORD, DWORD, ... );



const char gszWndClass[] = "TapiClient16Class";
const char gszTapi32[] = "TAPI32.DLL";


BOOL    gfShutdownDone = FALSE;
BOOL    gfOpenDone = FALSE;
HLINE   ghLine = NULL;
HICON   ghIcon = NULL;

#if DBG

DWORD gdwDebugLevel;

#define DBGOUT OutputDebugString
#else

#define DBGOUT //

#endif



#ifdef MEMPHIS
void LoadTAPI32IfNecessary()
{
    DWORD dw;
    DWORD pfn = 0;
    DWORD hLib = 0;


    hLib = LoadLibraryEx32W ("kernel32.dll", NULL, 0);

    pfn = (DWORD)GetProcAddress32W (hLib, "GetModuleHandleA");


    if ( pfn )
    {
    //     CallProc32W(
    //         arg1,        // TAPI proc args
    //         ...,
    //         argN,
    //
    //         pfnTapi32,   // Pointer to the function in tapi32.dll
    //
    //         0x???,       // Bit mask indicating which args are pointers
    //                      //   that need to be mapped from a 16:16 address
    //                      //   to a 0:32 address. The least significant
    //                      //   bit corresponds to argN, and the Nth bit
    //                      //   corresponds to arg1.
    //                      //
    //                      //   For example, if arg1 & arg2 are pointers, and
    //                      //   arg3 is a DWORD, the the mask would be 0x6
    //                      //   (110 in binary, indicating arg1 & arg2 need to
    //                      //   be mapped)
    //
    //         N            // Number of TAPI proc args
    //         );

       GlobalWire (GlobalHandle (HIWORD(gszTapi32)));

       dw = CallProc32W ((DWORD)gszTapi32, pfn, 1, 1);

       GlobalUnWire (GlobalHandle (HIWORD(gszTapi32)));

       //
       // Is TAPI32.DLL already loaded in this process space?
       // (on Memphis, each 16 bit app is a separate process, but all 16bit
       // apps get loaded into shared memory...)
       //

       if ( 0 == dw )
       {

          // No, TAPI32.DLL is no in this process context.  Load it.

          //
          //NOTE: Probable 16bit bug:
          // Since we've already loaded the address table, mightn't this
          // cause a problem if this instance of TAPI32 in this process has to
          // get relocated on load (because of conflict)?
          //

          ghLib = LoadLibraryEx32W (gszTapi32, NULL, 0);
       }
    }

    FreeLibrary32W( hLib );
}
#endif



//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
void DoFullLoad( void )
{
    int     i;

    //
    // Only do it once
    //
//    if ( 0 == ghLib )
    {
        //
        // Load tapi32.dll & Get all the proc pointers
        //

        ghLib = LoadLibraryEx32W (gszTapi32, NULL, 0);

        for (i = 0; i < NUM_TAPI32_PROCS; i++)
        {
            gaProcs[i] = (MYPROC) GetProcAddress32W(
                ghLib,
                (LPCSTR)gaFuncNames[i]
                );
        }

#ifndef MEMPHIS
        // set the error mode.
        // this has no effect on x86 platforms
        // on RISC platforms, NT will fix
        // alignment faults (at a cost of time)
        {
#define SEM_NOALIGNMENTFAULTEXCEPT  0x0004

            DWORD   dwModule;
            DWORD   dwFunc;

            if ((dwModule = LoadLibraryEx32W ("kernel32.dll", NULL,0)) == NULL)
            {
                DBGOUT("LoadLibraryEx32W on kernel32.dll failed\n");
            }
            else
            {

                if ((dwFunc = GetProcAddress32W(dwModule,
                                                "SetErrorMode")) == NULL)
                {
                    DBGOUT("GetProcAddress32W on SetErrorMode failed\n");
                }
                else
                {
                    DBGOUT("Calling CallProcEx32W\n");

                    CallProcEx32W(
                        1,
                        0,
                        dwFunc,
                        (DWORD) SEM_NOALIGNMENTFAULTEXCEPT
                        );
                }

                FreeLibrary32W(dwModule);
            }
        }
#endif

    }

}


//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
int
FAR
PASCAL
LibMain(
    HINSTANCE hInst,
    WORD wDataSeg,
    WORD cbHeapSize,
    LPSTR lpszCmdLine
    )
{
    WNDCLASS    wc;

    DBGOUT ("TAPI.DLL: Libmain entered\n");

    //
    //
    //

#if DBG

    gdwDebugLevel = (DWORD) GetPrivateProfileInt(
        "Debug",
        "TapiDebugLevel",
        0x0,
        "Telephon.ini"
        );

#endif


    //
    // Save the hInst in a global
    //

    ghInst = hInst;


    //
    // Register a window class for windows used for signaling async
    // completions & unsolicited events
    //

    wc.style         = 0;
    wc.lpfnWndProc   = (WNDPROC) Tapi16HiddenWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 2 * sizeof(DWORD);
    wc.hInstance     = hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = gszWndClass;

    if (!RegisterClass (&wc))
    {
        DBGOUT ("RegisterClass() failed\n");
    }

#ifndef MEMPHIS
    DoFullLoad();
#endif

    return TRUE;
}


int
FAR
PASCAL
WEP(
    int nParam
    )
{

    if ( ghLib )
        FreeLibrary32W (ghLib);

    return TRUE;
}


LRESULT
CALLBACK
Tapi16HiddenWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (msg)
    {


#ifdef B16APPS_CANT_SPIN_THREADS
    case WM_USER:
    {

#ifdef MEMPHIS
       //
       // Check the magic cookies for KC and me
       //
       if ( (0x4b44 == wParam) )
       {
           DBGOUT ("TAPI.DLL: Open is done\r\n");

           gfOpenDone = TRUE;
           ghLine = (HLINE)lParam;
           break;
       }


       if ( (0x4b45 == wParam) )
       {
           DBGOUT ("TAPI.DLL: shut is done\r\n");

           gfShutdownDone = TRUE;

           break;
       }
#endif


       //
       // Check the magic cookies for KC and me
       //
       if ( (0x4b43 == wParam) && (lParam == 0x00424a4d) )
       {
           DWORD pfn;

           DBGOUT ("TAPI.DLL: Got Event!!\r\n");

           pfn = (DWORD)GetProcAddress32W(
                                    ghLib,
                                    "NonAsyncEventThread"
                                  );

           if ( pfn )
           {
               CallProcEx32W( 0,
                              0,
                              pfn
                            );
           }
       }
    }
    break;
#endif


    case WM_ASYNCEVENT:
    {
        //
        // This msg gets posted to us by tapi32.dll to alert us that
        // there's a new callback msg available for the app instance
        // associated with this window. "lParam" is an app instance
        // context tapi32.dll-space.
        //

        LPTAPI_APP_DATA     pAppData = (LPTAPI_APP_DATA)
                                GetWindowLong (hwnd, GWL_APPDATA);
        TAPI16_CALLBACKMSG  msg;


        pAppData->bPendingAsyncEventMsg = FALSE;

        while ((*pfnCallProc2)(
                    (DWORD) lParam,
                    (DWORD) ((LPVOID)&msg),
                    (LPVOID)gaProcs[GetTapi16CallbkMsg],
                    0x1,
                    2
                    ))
        {
            if (pAppData->bPendingAsyncEventMsg == FALSE)
            {
                pAppData->bPendingAsyncEventMsg = TRUE;
                PostMessage (hwnd, WM_ASYNCEVENT, wParam, lParam);

// NOTE:  Tapi16HiddenWndProc: need to verify pAppData in case app calls
//                             shutdown from callback?
            }

            (*(pAppData->lpfnCallback))(
                msg.hDevice,
                msg.dwMsg,
                msg.dwCallbackInstance,
                msg.dwParam1,
                msg.dwParam2,
                msg.dwParam3
                );
        }

        break;
    }
    default:
    {
        return (DefWindowProc (hwnd, msg, wParam, lParam));
    }
    } // switch

    return 0;
}


//
// The following are the routines to thunk TAPI calls from 16-bit apps to
// the 32-bit tapi32.dll. In general, this is done as follows:
//
//     CallProc32W(
//         arg1,        // TAPI proc args
//         ...,
//         argN,
//
//         pfnTapi32,   // Pointer to the function in tapi32.dll
//
//         0x???,       // Bit mask indicating which args are pointers
//                      //   that need to be mapped from a 16:16 address
//                      //   to a 0:32 address. The least significant
//                      //   bit corresponds to argN, and the Nth bit
//                      //   corresponds to arg1.
//                      //
//                      //   For example, if arg1 & arg2 are pointers, and
//                      //   arg3 is a DWORD, the the mask would be 0x6
//                      //   (110 in binary, indicating arg1 & arg2 need to
//                      //   be mapped)
//
//         N            // Number of TAPI proc args
//         );
//
//
// Since callbacks to 16-bit procs cannot be done directly by a 32-bit
// module, we create a hidden window for each successful call to
// lineInitialize and phoneInitialize, and tapi32.dll posts msgs to this
// window when LINE_XXX & PHONE_XXX msgs become available for the client
// process. The window then retrieves all the msgs parameters and calls
// the 16-bit proc's callback function.
//
// Note that we swap the hLineApp & hPhoneApp returned by tapi32.dll with
// the hidden window handle on the client proc side, and substitute the
// window handle for the pointer to the callback function on the tapi32.dll
// side. The former is done to make it easier to reference which window
// belongs to which hLine/PhoneApp, and the latter is done to provide
// tapi32.dll with a means of alerting us of callback msgs. (Tapi32.dll
// distinguishes whether the lpfnCallback it is passed in
// line/phoneInitialize is a pointer to a function of a window handle by
// checking the high WORD- if it is 0xffff then it assumes lpfnCallback
// is really a 16-bit proc's window handle.
//

#if DBG

void
LineResult(
    char   *pszFuncName,
    LONG    lResult
    )
{
#if DBG
    if (gdwDebugLevel > 3)
    {
        char buf[100];

        wsprintf (buf, "TAPI: line%s result=x%lx\n", pszFuncName, lResult);
        DBGOUT (buf);
    }
#endif
}

void
PhoneResult(
    char   *pszFuncName,
    LONG    lResult
    )
{
#if DBG
    if (gdwDebugLevel > 3)
    {
        char buf[100];

        wsprintf (buf, "TAPI: phone%s result=x%lx\n", pszFuncName, lResult);
        DBGOUT (buf);
    }
#endif
}

void
TapiResult(
    char   *pszFuncName,
    LONG    lResult
    )
{
#if DBG
    if (gdwDebugLevel > 3)
    {
        char buf[100];

        wsprintf (buf, "TAPI: tapi%s result=x%lx\n", pszFuncName, lResult);
        DBGOUT (buf);
    }
#endif
}

#else

#define LineResult(arg1,arg2)
#define PhoneResult(arg1,arg2)
#define TapiResult(arg1,arg2)

#endif


VOID
MyCreateIcon(
    )
{
    BYTE FAR *pBlank;
    int xSize, ySize ;

    xSize = GetSystemMetrics( SM_CXICON );
    ySize = GetSystemMetrics( SM_CYICON );

    pBlank = (BYTE FAR *) GlobalAllocPtr (GPTR, ((xSize * ySize) + 7 )/ 8);

    ghIcon = CreateIcon (ghInst, xSize, ySize, 1, 1, pBlank, pBlank);

    GlobalFreePtr (pBlank);
}


LONG
WINAPI
xxxInitialize(
    BOOL            bLine,
    LPHLINEAPP      lphXxxApp,
    HINSTANCE       hInstance,
    LINECALLBACK    lpfnCallback,
    LPCSTR          lpszAppName,
    LPDWORD         lpdwNumDevs
    )
{
    HWND            hwnd = NULL;
    LONG            lResult;
    DWORD           dwAppNameLen;
    char far       *lpszModuleNamePath = NULL;
    char far       *lpszModuleName;
    char far       *lpszFriendlyAndModuleName = NULL;
    LPTAPI_APP_DATA pAppData = (LPTAPI_APP_DATA) NULL;

#if DBG

    if (bLine)
    {
        DBGOUT ("lineInitialize: enter\n");
    }
    else
    {
        DBGOUT ("phoneInitialize: enter\n");
    }

#endif

    //
    // Verify the ptrs
    //

    if (IsBadWritePtr ((LPVOID)lphXxxApp, sizeof(HLINEAPP)) ||
        IsBadCodePtr ((FARPROC) lpfnCallback) ||
        (lpszAppName && IsBadStringPtr (lpszAppName, (UINT) -1)))
    {
        lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        goto xxxInitialize_showResult;
    }

    //
    // Verify hInstance
    //
    if ((HINSTANCE)-1 == hInstance)
    {
        lResult = (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
        goto xxxInitialize_showResult;
    }

    dwAppNameLen = (lpszAppName ? strlen (lpszAppName) + 1 : 0);

#ifdef MEMPHIS
    DoFullLoad();
#endif

    //
    // Create a string that looks like: "<friendly name>\0<module name>\0"
    // (because i don't know if i can work with a 16-bit hInstance in tapi32)
    //

    if ((lpszModuleNamePath = (char far *) malloc (260)))
    {
        if (GetModuleFileName (hInstance, lpszModuleNamePath, 260))
        {
            lpszModuleName = 1 + _fstrrchr (lpszModuleNamePath, '\\');

            if ((lpszFriendlyAndModuleName = (char far *) malloc((unsigned)
                    (260 + (dwAppNameLen ? dwAppNameLen : 32))
                    )))
            {
                int length;


                strcpy(
                    lpszFriendlyAndModuleName,
                    (lpszAppName ? lpszAppName : lpszModuleName)
                    );

                length = strlen (lpszFriendlyAndModuleName);

                strcpy(
                    lpszFriendlyAndModuleName + length + 1,
                    lpszModuleName
                    );
            }
            else
            {
                lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
                goto xxxInitialize_done;
            }
        }
        else
        {
            DBGOUT ("GetModuleFileName() failed\n");

            lResult =
                (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
            goto xxxInitialize_done;
        }
    }
    else
    {
        lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
        goto xxxInitialize_done;
    }


    //
    // Create a window that we can use for signaling async completions
    // & unsolicited events
    //

    if (!(hwnd = CreateWindow(
            gszWndClass,
            "",
            WS_POPUP,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            ghInst,
            NULL
            )))
    {
        lResult = (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);

        DBGOUT ("CreateWindow failed\n");

        goto xxxInitialize_done;
    }


    //
    //
    //

    if (!(pAppData = (LPTAPI_APP_DATA) malloc (sizeof (TAPI_APP_DATA))))
    {
        lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);

        DBGOUT ("malloc failed\n");

        goto xxxInitialize_done;
    }

    pAppData->dwKey                 = TAPI_APP_DATA_KEY;
    pAppData->hwnd                  = hwnd;
    pAppData->bPendingAsyncEventMsg = FALSE;
    pAppData->lpfnCallback          = lpfnCallback;

    SetWindowLong (hwnd, GWL_APPDATA, (LONG) pAppData);


    //
    // Call tapi32.dll
    //

//    GlobalWire( GlobalHandle(HIWORD(lpdwNumDevs)));
//    GlobalWire( GlobalHandle(HIWORD(lpszFriendlyAndModuleName)));

    lResult = (LONG) (*pfnCallProc5)(
       (DWORD) ((LPVOID)&pAppData->hXxxApp),
       (DWORD) hInstance,
       (DWORD) (0xffff0000 | hwnd), // lpfnCallback
       (DWORD) lpszFriendlyAndModuleName,
       (DWORD) lpdwNumDevs,
       (LPVOID)gaProcs[(bLine ? lInitialize : pInitialize)],
       0x13,
       5
       );

//    GlobalUnWire( GlobalHandle(HIWORD(lpdwNumDevs)));
//    GlobalUnWire( GlobalHandle(HIWORD(lpszFriendlyAndModuleName)));


xxxInitialize_done:

    if (lpszModuleNamePath)
    {
        free (lpszModuleNamePath);

        if (lpszFriendlyAndModuleName)
        {
            free (lpszFriendlyAndModuleName);
        }
    }

    if (lResult == 0)
    {
        //
        // Set the app's hLineApp to be the hwnd rather than the real
        // hLineApp, making it easier to locate the window
        //

        *lphXxxApp = (HLINEAPP) pAppData;
    }
    else if (hwnd)
    {
        DestroyWindow (hwnd);

        if (pAppData)
        {
            free (pAppData);
        }
    }

xxxInitialize_showResult:

#if DBG

    if (bLine)
    {
        LineResult ("Initialize", lResult);
    }
    else
    {
        PhoneResult ("Initialize", lResult);
    }

#endif

    return lResult;
}


LPTAPI_APP_DATA
FAR
PASCAL
IsValidXxxApp(
    HLINEAPP    hXxxApp
    )
{
    if (IsBadReadPtr ((LPVOID) hXxxApp, sizeof (TAPI_APP_DATA)) ||
        ((LPTAPI_APP_DATA) hXxxApp)->dwKey != TAPI_APP_DATA_KEY)
    {
        return (LPTAPI_APP_DATA) NULL;
    }

    return (LPTAPI_APP_DATA) hXxxApp;
}


LONG
WINAPI
lineAccept(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpsUserUserInfo,
        (DWORD) dwSize,
        (LPVOID)gaProcs[lAccept],
        0x2,
        3
        );

    LineResult ("Accept", lResult);

    return lResult;
}


LONG
WINAPI
lineAddProvider(
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    LPDWORD lpdwPermanentProviderID
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    lResult = (*pfnCallProc3)(
        (DWORD) lpszProviderFilename,
        (DWORD) (0xffff0000 | hwndOwner),
        (DWORD) lpdwPermanentProviderID,
        (LPVOID)gaProcs[lAddProvider],
        0x5,
        3
        );

    LineResult ("AddProvider", lResult);

    return lResult;
}


LONG
WINAPI
lineAddToConference(
    HCALL   hConfCall,
    HCALL   hConsultCall
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hConfCall,
        (DWORD) hConsultCall,
        (LPVOID)gaProcs[lAddToConference],
        0x0,
        2
        );

    LineResult ("AddToConference", lResult);

    return lResult;
}


LONG
WINAPI
lineAnswer(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpsUserUserInfo,
        (DWORD) dwSize,
        (LPVOID)gaProcs[lAnswer],
        0x2,
        3
        );

    LineResult ("Answer", lResult);

    return lResult;
}


LONG
WINAPI
lineBlindTransfer(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpszDestAddress,
        (DWORD) dwCountryCode,
        (LPVOID)gaProcs[lBlindTransfer],
        0x2,
        3
        );

    LineResult ("BlindTransfer", lResult);

    return lResult;
}


LONG
WINAPI
lineClose(
    HLINE   hLine
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hLine,
        (LPVOID)gaProcs[lClose],
        0x0,
        1
        );

    LineResult ("Close", lResult);

    return lResult;
}


LONG
WINAPI
lineCompleteCall(
    HCALL   hCall,
    LPDWORD lpdwCompletionID,
    DWORD   dwCompletionMode,
    DWORD   dwMessageID
    )
{
    LONG    lResult;


    if (IsBadWritePtr (lpdwCompletionID, sizeof (DWORD)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc4)(
            (DWORD) hCall,
            (DWORD) lpdwCompletionID,   // let tapi32.dll map this
            (DWORD) dwCompletionMode,
            (DWORD) dwMessageID,
            (LPVOID)gaProcs[lCompleteCall],
            0x0,
            4
            );
    }
    LineResult ("CompleteCall", lResult);

    return lResult;
}


LONG
WINAPI
lineCompleteTransfer(
    HCALL   hCall,
    HCALL   hConsultCall,
    LPHCALL lphConfCall,
    DWORD   dwTransferMode
    )
{
    //
    // Tapi32.dll will take care of mapping lphConfCall if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (
          ( dwTransferMode & LINETRANSFERMODE_CONFERENCE )
        &&
          IsBadWritePtr ((void FAR *) lphConfCall, sizeof(HCALL))
       )
    {
        DBGOUT ("Bad lphConfCall with TRANSFERMODE_CONFERENCE\n");
        lResult = LINEERR_INVALPOINTER;
        goto CompleteTransfer_cleanup;
    }

    lResult = (*pfnCallProc4)(
            (DWORD) hCall,
            (DWORD) hConsultCall,
            (DWORD) lphConfCall,
            (DWORD) dwTransferMode,
            (LPVOID)gaProcs[lCompleteTransfer],
            0x0,
            4
            );

CompleteTransfer_cleanup:
    LineResult ("CompleteTransfer", lResult);

    return lResult;
}


LONG
WINAPI
lineConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    lResult = (*pfnCallProc3)(
        (DWORD) dwDeviceID,
        (DWORD) (0xffff0000 | hwndOwner),
        (DWORD) lpszDeviceClass,
        (LPVOID)gaProcs[lConfigDialog],
        0x1,
        3
        );

    LineResult ("ConfigDialog", lResult);

    return lResult;
}


LONG
WINAPI
lineConfigDialogEdit(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass,
    LPVOID  lpDeviceConfigIn,
    DWORD   dwSize,
    LPVARSTRING lpDeviceConfigOut
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    lResult = (*pfnCallProc6)(
        (DWORD) dwDeviceID,
        (DWORD) (0xffff0000 | hwndOwner),
        (DWORD) lpszDeviceClass,
        (DWORD) lpDeviceConfigIn,
        (DWORD) dwSize,
        (DWORD) lpDeviceConfigOut,
        (LPVOID)gaProcs[lConfigDialogEdit],
        0xd,
        6
        );

    LineResult ("ConfigDialogEdit", lResult);

    return lResult;
}


LONG
WINAPI
lineConfigProvider(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    LONG lResult;


#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    lResult = (*pfnCallProc2)(
        (DWORD) (0xffff0000 | hwndOwner),
        (DWORD) dwPermanentProviderID,
        (LPVOID)gaProcs[lConfigProvider],
        0x0,
        2
        );

    LineResult ("ConfigProvider", lResult);

    return lResult;
}


LONG
WINAPI
lineDeallocateCall(
    HCALL   hCall
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hCall,
        (LPVOID)gaProcs[lDeallocateCall],
        0x0,
        1
        );

    LineResult ("DeallocateCall", lResult);

    return lResult;
}


LONG
WINAPI
lineDevSpecific(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    LONG    lResult;


    if (IsBadWritePtr (lpParams, (UINT) dwSize))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc5)(
            (DWORD) hLine,
            (DWORD) dwAddressID,
            (DWORD) hCall,
            (DWORD) lpParams,   // let tapi32.dll map this
            (DWORD) dwSize,
            (LPVOID)gaProcs[lDevSpecific],
            0x0,
            5
            );
    }

    LineResult ("DevSpecific", lResult);

    return lResult;
}


LONG
WINAPI
lineDevSpecificFeature(
    HLINE   hLine,
    DWORD   dwFeature,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    LONG    lResult;


    if (IsBadWritePtr (lpParams, (UINT) dwSize))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc4)(
            (DWORD) hLine,
            (DWORD) dwFeature,
            (DWORD) lpParams,   // let tapi32.dll map this
            (DWORD) dwSize,
            (LPVOID)gaProcs[lDevSpecificFeature],
            0x0,
            4
            );
    }

    LineResult ("DevSpecificFeature", lResult);

    return lResult;
}


LONG
WINAPI
lineDial(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpszDestAddress,
        (DWORD) dwCountryCode,
        (LPVOID)gaProcs[lDial],
        0x2,
        3
        );

    LineResult ("Dial", lResult);

    return lResult;
}


LONG
WINAPI
lineDrop(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpsUserUserInfo,
        (DWORD) dwSize,
        (LPVOID)gaProcs[lDrop],
        0x2,
        3
        );

    LineResult ("Drop", lResult);

    return lResult;
}


LONG
WINAPI
lineForward(
    HLINE   hLine,
    DWORD   bAllAddresses,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    //
    // Tapi32.dll will take care of mapping lphConsultCall if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (IsBadWritePtr ((void FAR *) lphConsultCall, sizeof(HCALL)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc7)(
            (DWORD) hLine,
            (DWORD) bAllAddresses,
            (DWORD) dwAddressID,
            (DWORD) lpForwardList,
            (DWORD) dwNumRingsNoAnswer,
            (DWORD) lphConsultCall,
            (DWORD) lpCallParams,
            (LPVOID)gaProcs[lForward],
            0x9,
            7
            );
    }

    LineResult ("Forward", lResult);

    return lResult;
}


LONG
WINAPI
lineGatherDigits(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPSTR   lpsDigits,
    DWORD   dwNumDigits,
    LPCSTR  lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{
    LONG    lResult;


    if (lpsDigits  &&  IsBadWritePtr (lpsDigits, (UINT)dwNumDigits))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc7)(
            (DWORD) hCall,
            (DWORD) dwDigitModes,
            (DWORD) lpsDigits,      // let tapi32.dll map this
            (DWORD) dwNumDigits,
            (DWORD) lpszTerminationDigits,
            (DWORD) dwFirstDigitTimeout,
            (DWORD) dwInterDigitTimeout,
            (LPVOID)gaProcs[lGatherDigits],
            0x4,
            7
            );
    }

    LineResult ("GatherDigits", lResult);

    return lResult;
}


LONG
WINAPI
lineGenerateDigits(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCSTR  lpsDigits,
    DWORD   dwDuration
    )
{
    LONG    lResult = (*pfnCallProc4)(
        (DWORD) hCall,
        (DWORD) dwDigitMode,
        (DWORD) lpsDigits,
        (DWORD) dwDuration,
        (LPVOID)gaProcs[lGenerateDigits],
        0x2,
        4
        );

    LineResult ("GenerateDigits", lResult);

    return lResult;
}


LONG
WINAPI
lineGenerateTone(
    HCALL   hCall,
    DWORD   dwToneMode,
    DWORD   dwDuration,
    DWORD   dwNumTones,
    LPLINEGENERATETONE const lpTones
    )
{
    LONG    lResult = (*pfnCallProc5)(
        (DWORD) hCall,
        (DWORD) dwToneMode,
        (DWORD) dwDuration,
        (DWORD) dwNumTones,
        (DWORD) lpTones,
        (LPVOID)gaProcs[lGenerateTone],
        0x1,
        5
        );

    LineResult ("GenerateTone", lResult);

    return lResult;
}


LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAddressID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;

    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc6)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAddressID,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) lpAddressCaps,
            (LPVOID)gaProcs[lGetAddressCaps],
            0x1,
            6
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("GetAddressCaps", lResult);

    return lResult;
}


LONG
WINAPI
lineGetAddressID(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCSTR  lpsAddress,
    DWORD   dwSize
    )
{
    LONG    lResult = (*pfnCallProc5)(
        (DWORD) hLine,
        (DWORD) lpdwAddressID,
        (DWORD) dwAddressMode,
        (DWORD) lpsAddress,
        (DWORD) dwSize,
        (LPVOID)gaProcs[lGetAddressID],
        0xa,
        5
        );

    LineResult ("GetAddressID", lResult);

    return lResult;
}


LONG
WINAPI
lineGetAddressStatus(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hLine,
        (DWORD) dwAddressID,
        (DWORD) lpAddressStatus,
        (LPVOID)gaProcs[lGetAddressStatus],
        0x1,
        3
        );

    LineResult ("GetAddressStatus", lResult);

    return lResult;
}


LONG
WINAPI
lineGetAppPriority(
    LPCSTR  lpszAppName,
    DWORD   dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD   dwRequestMode,
    LPVARSTRING lpExtensionName,
    LPDWORD lpdwPriority
    )
{
    LONG  lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


//    GlobalWire( GlobalHandle(HIWORD(lpExtensionName)) );
//    GlobalWire( GlobalHandle(HIWORD(lpdwPriority)) );
//    GlobalWire( GlobalHandle(HIWORD(lpExtensionID)) );
//    GlobalWire( GlobalHandle(HIWORD(lpszAppName)) );

    lResult = (*pfnCallProc6)(
        (DWORD) lpszAppName,
        (DWORD) dwMediaMode,
        (DWORD) lpExtensionID,
        (DWORD) dwRequestMode,
        (DWORD) lpExtensionName,
        (DWORD) lpdwPriority,
        (LPVOID)gaProcs[lGetAppPriority],
        0x2b,
        6
        );

//    GlobalUnWire( GlobalHandle(HIWORD(lpExtensionName)) );
//    GlobalUnWire( GlobalHandle(HIWORD(lpdwPriority)) );
//    GlobalUnWire( GlobalHandle(HIWORD(lpExtensionID)) );
//    GlobalUnWire( GlobalHandle(HIWORD(lpszAppName)) );

    LineResult ("GetAppPriority", lResult);

    return lResult;
}


LONG
WINAPI
lineGetCallInfo(
    HCALL   hCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    LONG    lResult;

//    GlobalWire( GlobalHandle(HIWORD(lpCallInfo)) );

    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) lpCallInfo,
        (LPVOID)gaProcs[lGetCallInfo],
        0x1,
        2
        );

//    GlobalUnWire( GlobalHandle(HIWORD(lpCallInfo)) );

    LineResult ("GetCallInfo", lResult);

    return lResult;
}


LONG
WINAPI
lineGetCallStatus(
    HCALL   hCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) lpCallStatus,
        (LPVOID)gaProcs[lGetCallStatus],
        0x1,
        2
        );

    LineResult ("GetCallStatus", lResult);

    return lResult;
}


LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL   hCall,
    LPLINECALLLIST  lpCallList
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) lpCallList,
        (LPVOID)gaProcs[lGetConfRelatedCalls],
        0x1,
        2
        );

    LineResult ("GetConfRelatedCalls", lResult);

    return lResult;
}


LONG
WINAPI
lineGetCountry(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    LONG  lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    lResult = (*pfnCallProc3)(
        dwCountryID,
        dwAPIVersion,
        (DWORD) lpLineCountryList,
        (LPVOID)gaProcs[lGetCountry],
        0x1,
        3
        );

    LineResult ("GetCountry", lResult);

    return lResult;
}


LONG
WINAPI
lineGetDevCaps(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;

    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc5)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) lpLineDevCaps,
            (LPVOID)gaProcs[lGetDevCaps],
            0x1,
            5
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("GetDevCaps", lResult);

    return lResult;
}


LONG
WINAPI
lineGetDevConfig(
    DWORD       dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCSTR      lpszDeviceClass
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    lResult = (*pfnCallProc3)(
        (DWORD) dwDeviceID,
        (DWORD) lpDeviceConfig,
        (DWORD) lpszDeviceClass,
        (LPVOID)gaProcs[lGetDevConfig],
        0x3,
        3
        );

    LineResult ("GetDevConfig", lResult);

    return lResult;
}


LONG
WINAPI
lineGetIcon(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    LONG    lResult;
    DWORD   hIcon32;


    if (!IsBadWritePtr (lphIcon, sizeof (*lphIcon)))
    {
#ifdef MEMPHIS
        DoFullLoad();
        LoadTAPI32IfNecessary();
#endif

        lResult = (*pfnCallProc3)(
            (DWORD) dwDeviceID,
            (DWORD) lpszDeviceClass,
            (DWORD) &hIcon32,
            (LPVOID) gaProcs[lGetIcon],
            0x3,
            3
            );

        if (lResult == 0)
        {
            if (!ghIcon)
            {
                MyCreateIcon ();
            }

            *lphIcon = ghIcon;
        }
    }
    else
    {
        lResult = LINEERR_INVALPOINTER;
    }

    LineResult ("GetIcon", lResult);

    return lResult;
}


LONG
WINAPI
lineGetID(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPVARSTRING lpDeviceID,
    LPCSTR  lpszDeviceClass
    )
{
    LONG    lResult;

//    GlobalWire( GlobalHandle(HIWORD(lpszDeviceClass)) );
//    GlobalWire( GlobalHandle(HIWORD(lpDeviceID)) );

    lResult = (*pfnCallProc6)(
        (DWORD) hLine,
        (DWORD) dwAddressID,
        (DWORD) hCall,
        (DWORD) dwSelect,
        (DWORD) lpDeviceID,
        (DWORD) lpszDeviceClass,
        (LPVOID)gaProcs[lGetID],
        0x3,
        6
        );

    LineResult ("GetID", lResult);

//    GlobalUnWire( GlobalHandle(HIWORD(lpszDeviceClass)) );
//    GlobalUnWire( GlobalHandle(HIWORD(lpDeviceID)) );

    return lResult;
}


LONG
WINAPI
lineGetLineDevStatus(
    HLINE   hLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hLine,
        (DWORD) lpLineDevStatus,
        (LPVOID)gaProcs[lGetLineDevStatus],
        0x1,
        2
        );

    LineResult ("GetLineDevStatus", lResult);

    return lResult;
}


LONG
WINAPI
lineGetNewCalls(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwSelect,
    LPLINECALLLIST  lpCallList
    )
{
    LONG    lResult = (*pfnCallProc4)(
        (DWORD) hLine,
        (DWORD) dwAddressID,
        (DWORD) dwSelect,
        (DWORD) lpCallList,
        (LPVOID)gaProcs[lGetNewCalls],
        0x1,
        4
        );

    LineResult ("GetNewCalls", lResult);

    return lResult;
}


LONG
WINAPI
lineGetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPDWORD lpdwNumRings
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hLine,
        (DWORD) dwAddressID,
        (DWORD) lpdwNumRings,
        (LPVOID)gaProcs[lGetNumRings],
        0x1,
        3
        );

    LineResult ("GetNumRings", lResult);

    return lResult;
}


LONG
WINAPI
lineGetProviderList(
    DWORD   dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc2)(
        dwAPIVersion,
        (DWORD) lpProviderList,
        (LPVOID)gaProcs[lGetProviderList],
        0x1,
        2
        );

    LineResult ("GetProviderList", lResult);

    return lResult;
}


LONG
WINAPI
lineGetRequest(
    HLINEAPP    hLineApp,
    DWORD   dwRequestMode,
    LPVOID  lpRequestBuffer
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;

    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc3)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwRequestMode,
            (DWORD) lpRequestBuffer,
            (LPVOID)gaProcs[lGetRequest],
            0x1,
            3
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("GetRequest", lResult);

    return lResult;
}


LONG
WINAPI
lineGetStatusMessages(
    HLINE   hLine,
    LPDWORD lpdwLineStates,
    LPDWORD lpdwAddressStates
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hLine,
        (DWORD) lpdwLineStates,
        (DWORD) lpdwAddressStates,
        (LPVOID)gaProcs[lGetStatusMessages],
        0x3,
        3
        );

    LineResult ("GetStatusMessages", lResult);

    return lResult;
}


LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
    LPTAPI_APP_DATA pAppData;
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif



    if (hLineApp == NULL || (pAppData = IsValidXxxApp (hLineApp)))
    {

//        GlobalWire( GlobalHandle(HIWORD(lpTranslateCaps)) );

        lResult = (*pfnCallProc3)(
            (hLineApp == NULL ? (DWORD) 0 : pAppData->hXxxApp),
            (DWORD) dwAPIVersion,
            (DWORD) lpTranslateCaps,
            (LPVOID)gaProcs[lGetTranslateCaps],
            0x1,
            3
            );

//        GlobalUnWire( GlobalHandle(HIWORD(lpTranslateCaps)) );

    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("GetTranslateCaps", lResult);

    return lResult;
}


LONG
WINAPI
lineHandoff(
    HCALL   hCall,
    LPCSTR  lpszFileName,
    DWORD   dwMediaMode
    )
{
    LONG lResult;

//    GlobalWire( GlobalHandle(HIWORD(lpszFileName)) );


    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpszFileName,
        (DWORD) dwMediaMode,
        (LPVOID)gaProcs[lHandoff],
        0x2,
        3
        );

    LineResult ("Handoff", lResult);

//    GlobalUnWire( GlobalHandle(HIWORD(lpszFileName)) );

    return lResult;
}


LONG
WINAPI
lineHold(
    HCALL   hCall
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hCall,
        (LPVOID)gaProcs[lHold],
        0x0,
        1
        );

    LineResult ("Hold", lResult);

    return lResult;
}

LONG
WINAPI
lineInitialize(
    LPHLINEAPP      lphLineApp,
    HINSTANCE       hInstance,
    LINECALLBACK    lpfnCallback,
    LPCSTR          lpszAppName,
    LPDWORD         lpdwNumDevs
    )
{
    return (xxxInitialize(
        TRUE,
        lphLineApp,
        hInstance,
        lpfnCallback,
        lpszAppName,
        lpdwNumDevs
        ));
}


LONG
WINAPI
lineMakeCall(
    HLINE   hLine,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{
    //
    // Tapi32.dll will take care of mapping lphCall if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (IsBadWritePtr ((void FAR *) lphCall, sizeof(HCALL)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
//        GlobalWire( GlobalHandle(HIWORD(lpCallParams)) );
//        GlobalWire( GlobalHandle(HIWORD(lpszDestAddress)) );

        lResult = (*pfnCallProc5)(
            (DWORD) hLine,
            (DWORD) lphCall,
            (DWORD) lpszDestAddress,
            (DWORD) dwCountryCode,
            (DWORD) lpCallParams,
            (LPVOID)gaProcs[lMakeCall],
            0x5,
            5
            );

//        GlobalUnWire( GlobalHandle(HIWORD(lpCallParams)) );
//        GlobalUnWire( GlobalHandle(HIWORD(lpszDestAddress)) );

    }

    LineResult ("MakeCall", lResult);

    return lResult;
}


LONG
WINAPI
lineMonitorDigits(
    HCALL   hCall,
    DWORD   dwDigitModes
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) dwDigitModes,
        (LPVOID)gaProcs[lMonitorDigits],
        0x0,
        2
        );

    LineResult ("MonitorDigits", lResult);

    return lResult;
}


LONG
WINAPI
lineMonitorMedia(
    HCALL   hCall,
    DWORD   dwMediaModes
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) dwMediaModes,
        (LPVOID)gaProcs[lMonitorMedia],
        0x0,
        2
        );

    LineResult ("MonitorMedia", lResult);

    return lResult;
}


LONG
WINAPI
lineMonitorTones(
    HCALL   hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD   dwNumEntries
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpToneList,
        (DWORD) dwNumEntries,
        (LPVOID)gaProcs[lMonitorTones],
        0x2,
        3
        );

    LineResult ("MonitorTones", lResult);

    return lResult;
}


LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc6)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPILowVersion,
            (DWORD) dwAPIHighVersion,
            (DWORD) lpdwAPIVersion,
            (DWORD) lpExtensionID,
            (LPVOID)gaProcs[lNegotiateAPIVersion],
            0x3,
            6
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("NegotiateAPIVersion", lResult);

    return lResult;
}


LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP    hLineApp,
    DWORD   dwDeviceID,
    DWORD   dwAPIVersion,
    DWORD   dwExtLowVersion,
    DWORD   dwExtHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc6)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtLowVersion,
            (DWORD) dwExtHighVersion,
            (DWORD) lpdwExtVersion,
            (LPVOID)gaProcs[lNegotiateExtVersion],
            0x1,
            6
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("NegotiateExtVersion", lResult);

    return lResult;
}



LONG
WINAPI
lineOpen(
    HLINEAPP    hLineApp,
    DWORD   dwDeviceID,
    LPHLINE lphLine,
    DWORD   dwAPIVersion,
    DWORD   dwExtVersion,
    DWORD   dwCallbackInstance,
    DWORD   dwPrivileges,
    DWORD   dwMediaModes,
    LPLINECALLPARAMS const lpCallParams
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


//OutputDebugString("open16");
//DebugBreak();

    if ((pAppData = IsValidXxxApp (hLineApp)))
    {

#ifdef MEMPHIS


        gfOpenDone = FALSE;
        ghLine = NULL;

        lResult = (*pfnCallProc10)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) lphLine,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) dwCallbackInstance,
            (DWORD) dwPrivileges,
            (DWORD) dwMediaModes,
            (DWORD) lpCallParams,
            (DWORD) pAppData->hwnd,
            (LPVOID)gaProcs[lOpenInt],
            0x82,
            10
            );

        if ( 0 == lResult )
        {
            MSG msg;

            //
            // Now wait to hear back from TAPISRV
            //
            DBGOUT((2, "Starting message loop in open16"));

//TODO NOW: Timeout??  (would need to change from GetMessage to PeekMessage)

            while ( !gfOpenDone && GetMessage(&msg, 0, 0, 0) != 0)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            DBGOUT((2, "Done message loop in open16\r\n"));

            //
            // Was it actually an error?
            //
            if ( (DWORD)ghLine >= 0x80000000 && (DWORD)ghLine <= 0x80000055 )
            {
                lResult = (DWORD)ghLine;
            }
            else
            {
                lResult = 0;
                *lphLine = ghLine;
            }

        }

#else
        lResult = (*pfnCallProc9)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) lphLine,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) dwCallbackInstance,
            (DWORD) dwPrivileges,
            (DWORD) dwMediaModes,
            (DWORD) lpCallParams,
            (LPVOID)gaProcs[lOpen],
            0x41,
            9
            );
#endif

    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }


    LineResult ("Open", lResult);

    return lResult;
}


LONG
WINAPI
linePark(
    HCALL   hCall,
    DWORD   dwParkMode,
    LPCSTR  lpszDirAddress,
    LPVARSTRING lpNonDirAddress
    )
{
    LONG    lResult;

//    GlobalWire( GlobalHandle(HIWORD(lpszDirAddress)) );

    lResult = (*pfnCallProc4)(
        (DWORD) hCall,
        (DWORD) dwParkMode,
        (DWORD) lpszDirAddress,
        (DWORD) lpNonDirAddress,    // let tapi32.dll map this
        (LPVOID)gaProcs[lPark],
        0x2,
        4
        );

    LineResult ("Park", lResult);

//    GlobalUnWire( GlobalHandle(HIWORD(lpszDirAddress)) );

    return lResult;
}


LONG
WINAPI
linePickup(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszGroupID
    )
{
    //
    // Tapi32.dll will take care of mapping lphCall if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (IsBadWritePtr ((void FAR *) lphCall, sizeof(HCALL)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc5)(
            (DWORD) hLine,
            (DWORD) dwAddressID,
            (DWORD) lphCall,
            (DWORD) lpszDestAddress,
            (DWORD) lpszGroupID,
            (LPVOID)gaProcs[lPickup],
            0x3,
            5
            );
    }

    LineResult ("Pickup", lResult);

    return lResult;
}


LONG
WINAPI
linePrepareAddToConference(
    HCALL   hConfCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    //
    // Tapi32.dll will take care of mapping lphConsultCall if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (IsBadWritePtr ((void FAR *) lphConsultCall, sizeof(HCALL)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc3)(
            (DWORD) hConfCall,
            (DWORD) lphConsultCall,
            (DWORD) lpCallParams,
            (LPVOID)gaProcs[lPrepareAddToConference],
            0x1,
            3
            );
    }

    LineResult ("PrepareAddToConference", lResult);

    return lResult;
}


LONG
WINAPI
lineRedirect(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpszDestAddress,
        (DWORD) dwCountryCode,
        (LPVOID)gaProcs[lRedirect],
        0x2,
        3
        );

    LineResult ("Redirect", lResult);

    return lResult;
}


LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP    hLineApp,
    DWORD   dwRegistrationInstance,
    DWORD   dwRequestMode,
    DWORD   bEnable
    )
{
    LPTAPI_APP_DATA pAppData;
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc4)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwRegistrationInstance,
            (DWORD) dwRequestMode,
            (DWORD) bEnable,
            (LPVOID)gaProcs[lRegisterRequestRecipient],
            0x0,
            4
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("RegisterRequestRecipient", lResult);

    return lResult;
}


LONG
WINAPI
lineReleaseUserUserInfo(
    HCALL   hCall
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hCall,
        (LPVOID)gaProcs[lReleaseUserUserInfo],
        0x0,
        1
        );

    LineResult ("ReleaseUserUserInfo", lResult);

    return lResult;
}


LONG
WINAPI
lineRemoveFromConference(
    HCALL   hCall
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hCall,
        (LPVOID)gaProcs[lRemoveFromConference],
        0x0,
        1
        );

    LineResult ("RemoveFromConference", lResult);

    return lResult;
}


LONG
WINAPI
lineRemoveProvider(
    DWORD   dwPermanentProviderID,
    HWND    hwndOwner
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc2)(
        (DWORD) dwPermanentProviderID,
        (DWORD) (0xffff0000 | hwndOwner),
        (LPVOID)gaProcs[lRemoveProvider],
        0x0,
        2
        );

    LineResult ("RemoveProvider", lResult);

    return lResult;
}


LONG
WINAPI
lineSecureCall(
    HCALL hCall
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hCall,
        (LPVOID)gaProcs[lSecureCall],
        0x0,
        1
        );

    LineResult ("SecureCall", lResult);

    return lResult;
}


LONG
WINAPI
lineSendUserUserInfo(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hCall,
        (DWORD) lpsUserUserInfo,
        (DWORD) dwSize,
        (LPVOID)gaProcs[lSendUserUserInfo],
        0x2,
        3
        );

    LineResult ("SendUserUserInfo", lResult);

    return lResult;
}


LONG
WINAPI
lineSetAppPriority(
    LPCSTR  lpszAppName,
    DWORD   dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD   dwRequestMode,
    LPCSTR  lpszExtensionName,
    DWORD   dwPriority
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

//    GlobalWire( GlobalHandle(HIWORD(lpszExtensionName)) );
//    GlobalWire( GlobalHandle(HIWORD(lpExtensionID)) );
//    GlobalWire( GlobalHandle(HIWORD(lpszAppName)) );

    lResult = (*pfnCallProc6)(
        (DWORD) lpszAppName,
        (DWORD) dwMediaMode,
        (DWORD) lpExtensionID,
        (DWORD) dwRequestMode,
        (DWORD) lpszExtensionName,
        (DWORD) dwPriority,
        (LPVOID)gaProcs[lSetAppPriority],
        0x2a,
        6
        );

//    GlobalUnWire( GlobalHandle(HIWORD(lpszExtensionName)) );
//    GlobalUnWire( GlobalHandle(HIWORD(lpExtensionID)) );
//    GlobalUnWire( GlobalHandle(HIWORD(lpszAppName)) );

    LineResult ("SetAppPriority", lResult);

    return lResult;
}


LONG
WINAPI
lineSetAppSpecific(
    HCALL   hCall,
    DWORD   dwAppSpecific
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) dwAppSpecific,
        (LPVOID)gaProcs[lSetAppSpecific],
        0x0,
        2
        );

    LineResult ("SetAppSpecific", lResult);

    return lResult;
}


LONG
WINAPI
lineSetCallParams(
    HCALL   hCall,
    DWORD   dwBearerMode,
    DWORD   dwMinRate,
    DWORD   dwMaxRate,
    LPLINEDIALPARAMS const lpDialParams
    )
{
    LONG    lResult = (*pfnCallProc5)(
        (DWORD) hCall,
        (DWORD) dwBearerMode,
        (DWORD) dwMinRate,
        (DWORD) dwMaxRate,
        (DWORD) lpDialParams,
        (LPVOID)gaProcs[lSetCallParams],
        0x1,
        5
        );

    LineResult ("SetCallParams", lResult);

    return lResult;
}


LONG
WINAPI
lineSetCallPrivilege(
    HCALL   hCall,
    DWORD   dwCallPrivilege
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) dwCallPrivilege,
        (LPVOID)gaProcs[lSetCallPrivilege],
        0x0,
        2
        );

    LineResult ("SetCallPrivilege", lResult);

    return lResult;
}


LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP    hLineApp,
    DWORD       dwLocation
    )
{
    LPTAPI_APP_DATA pAppData;
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc2)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwLocation,
            (LPVOID)gaProcs[lSetCurrentLocation],
            0x0,
            2
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("SetCurrentLocation", lResult);

    return lResult;
}


LONG
WINAPI
lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCSTR  lpszDeviceClass
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc4)(
        (DWORD) dwDeviceID,
        (DWORD) lpDeviceConfig,
        (DWORD) dwSize,
        (DWORD) lpszDeviceClass,
        (LPVOID)gaProcs[lSetDevConfig],
        0x5,
        4
        );

    LineResult ("SetDevConfig", lResult);

    return lResult;
}


LONG
WINAPI
lineSetMediaControl(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPLINEMEDIACONTROLDIGIT const lpDigitList,
    DWORD   dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA const lpMediaList,
    DWORD   dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE  const lpToneList,
    DWORD   dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD   dwCallStateNumEntries
    )
{
    LONG    lResult = (*pfnCallProc12)(
        (DWORD) hLine,
        (DWORD) dwAddressID,
        (DWORD) hCall,
        (DWORD) dwSelect,
        (DWORD) lpDigitList,
        (DWORD) dwDigitNumEntries,
        (DWORD) lpMediaList,
        (DWORD) dwMediaNumEntries,
        (DWORD) lpToneList,
        (DWORD) dwToneNumEntries,
        (DWORD) lpCallStateList,
        (DWORD) dwCallStateNumEntries,
        (LPVOID)gaProcs[lSetMediaControl],
        0xaa,
        12
        );

    LineResult ("SetMediaControl", lResult);

    return lResult;
}


LONG
WINAPI
lineSetMediaMode(
    HCALL   hCall,
    DWORD   dwMediaModes
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hCall,
        (DWORD) dwMediaModes,
        (LPVOID)gaProcs[lSetMediaMode],
        0x0,
        2
        );

    LineResult ("lineSetMediaMode", lResult);

    return lResult;
}


LONG
WINAPI
lineSetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwNumRings
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hLine,
        (DWORD) dwAddressID,
        (DWORD) dwNumRings,
        (LPVOID)gaProcs[lSetNumRings],
        0x0,
        3
        );

    LineResult ("SetNumRings", lResult);

    return lResult;
}


LONG
WINAPI
lineSetStatusMessages(
    HLINE hLine,
    DWORD dwLineStates,
    DWORD dwAddressStates
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hLine,
        (DWORD) dwLineStates,
        (DWORD) dwAddressStates,
        (LPVOID)gaProcs[lSetStatusMessages],
        0x0,
        3
        );

    LineResult ("SetStatusMessages", lResult);

    return lResult;
}


LONG
WINAPI
lineSetTerminal(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    DWORD   dwTerminalModes,
    DWORD   dwTerminalID,
    DWORD   bEnable
    )
{
    LONG    lResult = (*pfnCallProc7)(
        (DWORD) hLine,
        (DWORD) dwAddressID,
        (DWORD) hCall,
        (DWORD) dwSelect,
        (DWORD) dwTerminalModes,
        (DWORD) dwTerminalID,
        (DWORD) bEnable,
        (LPVOID)gaProcs[lSetTerminal],
        0x0,
        7
        );

    LineResult ("SetTerminal", lResult);

    return lResult;
}


LONG
WINAPI
lineSetTollList(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    LPCSTR      lpszAddressIn,
    DWORD       dwTollListOption
    )
{
    LPTAPI_APP_DATA pAppData;
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc4)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) lpszAddressIn,
            (DWORD) dwTollListOption,
            (LPVOID)gaProcs[lSetTollList],
            0x2,
            4
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("SetTollList", lResult);

    return lResult;
}


LONG
WINAPI
lineSetupConference(
    HCALL   hCall,
    HLINE   hLine,
    LPHCALL lphConfCall,
    LPHCALL lphConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    //
    // Tapi32.dll will take care of mapping lphXxxCall's if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (IsBadWritePtr ((void FAR *) lphConfCall, sizeof(HCALL)) ||
        IsBadWritePtr ((void FAR *) lphConsultCall, sizeof(HCALL)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc6)(
            (DWORD) hCall,
            (DWORD) hLine,
            (DWORD) lphConfCall,
            (DWORD) lphConsultCall,
            (DWORD) dwNumParties,
            (DWORD) lpCallParams,
            (LPVOID)gaProcs[lSetupConference],
            0x1,
            6
            );
    }

    LineResult ("SetupConference", lResult);

    return lResult;
}


LONG
WINAPI
lineSetupTransfer(
    HCALL   hCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    //
    // Tapi32.dll will take care of mapping lphConsultCall if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (IsBadWritePtr ((void FAR *) lphConsultCall, sizeof(HCALL)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc3)(
            (DWORD) hCall,
            (DWORD) lphConsultCall,
            (DWORD) lpCallParams,
            (LPVOID)gaProcs[lSetupTransfer],
            0x1,
            3
            );
    }

    LineResult ("SetupTransfer", lResult);

    return lResult;
}


LONG
WINAPI
lineShutdown(
    HLINEAPP    hLineApp
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {

#ifdef MEMPHIS

//DBGOUT((1, "Now in ls"));
//DebugBreak();

        gfShutdownDone = FALSE;


        lResult = (LONG) (*pfnCallProc2)(
                                          (DWORD) pAppData->hXxxApp,
                                          (DWORD) pAppData->hwnd,
                                          (LPVOID)gaProcs[lShutdownInt],
                                          0x0,
                                          2
                                        );
        if ( 0 == lResult )
        {
            MSG msg;

            //
            // Now wait to hear back from TAPISRV
            //
            DBGOUT((2, "Starting message loop in shut16\r\n"));

//TODO NOW: Timeout??  (would need to change from GetMessage to PeekMessage)

            while ( !gfShutdownDone && GetMessage(&msg, 0, 0, 0) != 0)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            DBGOUT((2, "Done message loop in shut16\r\n"));

            //
            // Was it actually an error?
            //
            if ( (DWORD)ghLine >= 0x80000000 && (DWORD)ghLine <= 0x80000055 )
            {
                lResult = (DWORD)ghLine;
            }
            else
            {
                lResult = 0;
            }

        }

#else
        lResult = (LONG) (*pfnCallProc1)(
                                          (DWORD) pAppData->hXxxApp,
                                          (LPVOID)gaProcs[lShutdown],
                                          0x0,
                                          1
                                        );
#endif

        if ( lResult == 0 )
        {
            //
            // Destroy the associated window & free the app data instance
            //

            DestroyWindow (pAppData->hwnd);
            pAppData->dwKey = 0xefefefef;
            free (pAppData);
        }
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("Shutdown", lResult);

    return lResult;
}


LONG
WINAPI
lineSwapHold(
    HCALL   hActiveCall,
    HCALL   hHeldCall
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hActiveCall,
        (DWORD) hHeldCall,
        (LPVOID)gaProcs[lSwapHold],
        0x0,
        2
        );

    LineResult ("SwapHold", lResult);

    return lResult;
}


LONG
WINAPI
lineTranslateAddress(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    LPCSTR      lpszAddressIn,
    DWORD       dwCard,
    DWORD       dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
    LPTAPI_APP_DATA pAppData;

    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc7)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPIVersion,
            (DWORD) lpszAddressIn,
            (DWORD) dwCard,
            (DWORD) dwTranslateOptions,
            (DWORD) lpTranslateOutput,
            (LPVOID)gaProcs[lTranslateAddress],
            0x9,
            7
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("TranslateAddress", lResult);

    return lResult;
}


LONG
WINAPI
lineTranslateDialog(
    HLINEAPP    hLineApp,
    DWORD   dwDeviceID,
    DWORD   dwAPIVersion,
    HWND    hwndOwner,
    LPCSTR  lpszAddressIn
    )
{
    LPTAPI_APP_DATA pAppData;

    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif


    if ((pAppData = IsValidXxxApp (hLineApp)))
    {
        lResult = (*pfnCallProc5)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPIVersion,
            (DWORD) (0xffff0000 | hwndOwner),
            (DWORD) lpszAddressIn,
            (LPVOID)gaProcs[lTranslateDialog],
            0x1,
            5
            );
    }
    else
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }

    LineResult ("TranslateDialog", lResult);

    return lResult;
}


LONG
WINAPI
lineUncompleteCall(
    HLINE   hLine,
    DWORD   dwCompletionID
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hLine,
        (DWORD) dwCompletionID,
        (LPVOID)gaProcs[lUncompleteCall],
        0x0,
        2
        );

    LineResult ("UncompleteCall", lResult);

    return lResult;
}


LONG
WINAPI
lineUnhold(
    HCALL   hCall
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hCall,
        (LPVOID)gaProcs[lUnhold],
        0x0,
        1
        );

    LineResult ("Unhold", lResult);

    return lResult;
}


LONG
WINAPI
lineUnpark(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress
    )
{
    //
    // Tapi32.dll will take care of mapping lphCall if/when the
    // request completes successfully, so we don't set the mapping
    // bit down below; do check to see if pointer is valid though.
    //

    LONG    lResult;


    if (IsBadWritePtr ((void FAR *) lphCall, sizeof(HCALL)))
    {
        lResult = LINEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc4)(
            (DWORD) hLine,
            (DWORD) dwAddressID,
            (DWORD) lphCall,
            (DWORD) lpszDestAddress,
            (LPVOID)gaProcs[lUnpark],
            0x1,
            4
            );
    }

    LineResult ("Unpark", lResult);

    return lResult;
}


LONG
WINAPI
phoneClose(
    HPHONE  hPhone
    )
{
    LONG    lResult = (*pfnCallProc1)(
        (DWORD) hPhone,
        (LPVOID)gaProcs[pClose],
        0x0,
        1
        );

    PhoneResult ("Close", lResult);

    return lResult;
}


LONG
WINAPI
phoneConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc3)(
        (DWORD) dwDeviceID,
        (DWORD) (0xffff0000 | hwndOwner),
        (DWORD) lpszDeviceClass,
        (LPVOID)gaProcs[pConfigDialog],
        0x1,
        3
        );

    PhoneResult ("ConfigDialog", lResult);

    return lResult;
}



LONG
WINAPI
phoneDevSpecific(
    HPHONE  hPhone,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    LONG    lResult;


    if (IsBadWritePtr (lpParams, (UINT) dwSize))
    {
        lResult = PHONEERR_INVALPOINTER;
    }
    else
    {
        lResult = (*pfnCallProc3)(
            (DWORD) hPhone,
            (DWORD) lpParams,   // let tapi32.dll map this
            (DWORD) dwSize,
            (LPVOID)gaProcs[pDevSpecific],
            0x0,
            3
            );
    }

    PhoneResult ("DevSpecific", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetButtonInfo(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwButtonLampID,
        (DWORD) lpButtonInfo,
        (LPVOID)gaProcs[pGetButtonInfo],
        0x1,
        3
        );

    PhoneResult ("GetButtonInfo", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetData(
    HPHONE  hPhone,
    DWORD   dwDataID,
    LPVOID  lpData,
    DWORD   dwSize
    )
{
    LONG    lResult = (*pfnCallProc4)(
        (DWORD) hPhone,
        (DWORD) dwDataID,
        (DWORD) lpData,
        (DWORD) dwSize,
        (LPVOID)gaProcs[pGetData],
        0x2,
        4
        );

    PhoneResult ("GetData", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp ((HLINEAPP) hPhoneApp)))
    {
        lResult = (*pfnCallProc5)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) lpPhoneCaps,
            (LPVOID)gaProcs[pGetDevCaps],
            0x1,
            5
            );
    }
    else
    {
        lResult = PHONEERR_INVALAPPHANDLE;
    }

    PhoneResult ("GetDevCaps", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetDisplay(
    HPHONE  hPhone,
    LPVARSTRING lpDisplay
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hPhone,
        (DWORD) lpDisplay,
        (LPVOID)gaProcs[pGetDisplay],
        0x1,
        2
        );

    PhoneResult ("GetDisplay", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetGain(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    LPDWORD lpdwGain
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwHookSwitchDev,
        (DWORD) lpdwGain,
        (LPVOID)gaProcs[pGetGain],
        0x1,
        3
        );

    PhoneResult ("GetGain", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetHookSwitch(
    HPHONE  hPhone,
    LPDWORD lpdwHookSwitchDevs
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hPhone,
        (DWORD) lpdwHookSwitchDevs,
        (LPVOID)gaProcs[pGetHookSwitch],
        0x1,
        2
        );

    PhoneResult ("GetHookSwitch", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetIcon(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    LONG    lResult;
    DWORD   hIcon32;


    if (!IsBadWritePtr (lphIcon, sizeof (*lphIcon)))
    {
#ifdef MEMPHIS
        DoFullLoad();
        LoadTAPI32IfNecessary();
#endif

        lResult = (*pfnCallProc3)(
            (DWORD) dwDeviceID,
            (DWORD) lpszDeviceClass,
            (DWORD) &hIcon32,
            (LPVOID) gaProcs[pGetIcon],
            0x3,
            3
            );

        if (lResult == 0)
        {
            if (!ghIcon)
            {
                MyCreateIcon ();
            }

            *lphIcon = ghIcon;
        }
    }
    else
    {
        lResult = PHONEERR_INVALPOINTER;
    }

    PhoneResult ("GetIcon", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetID(
    HPHONE      hPhone,
    LPVARSTRING lpDeviceID,
    LPCSTR      lpszDeviceClass
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) lpDeviceID,
        (DWORD) lpszDeviceClass,
        (LPVOID)gaProcs[pGetID],
        0x3,
        3
        );

    PhoneResult ("GetID", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetLamp(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    LPDWORD lpdwLampMode
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwButtonLampID,
        (DWORD) lpdwLampMode,
        (LPVOID)gaProcs[pGetLamp],
        0x1,
        3
        );

    PhoneResult ("GetLamp", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetRing(
    HPHONE  hPhone,
    LPDWORD lpdwRingMode,
    LPDWORD lpdwVolume
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) lpdwRingMode,
        (DWORD) lpdwVolume,
        (LPVOID)gaProcs[pGetRing],
        0x3,
        3
        );

    PhoneResult ("GetRing", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetStatus(
    HPHONE          hPhone,
    LPPHONESTATUS   lpPhoneStatus
    )
{
    LONG    lResult = (*pfnCallProc2)(
        (DWORD) hPhone,
        (DWORD) lpPhoneStatus,
        (LPVOID)gaProcs[pGetStatus],
        0x1,
        2
        );

    PhoneResult ("GetStatus", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetStatusMessages(
    HPHONE  hPhone,
    LPDWORD lpdwPhoneStates,
    LPDWORD lpdwButtonModes,
    LPDWORD lpdwButtonStates
    )
{
    LONG    lResult = (*pfnCallProc4)(
        (DWORD) hPhone,
        (DWORD) lpdwPhoneStates,
        (DWORD) lpdwButtonModes,
        (DWORD) lpdwButtonStates,
        (LPVOID)gaProcs[pGetStatusMessages],
        0x7,
        4
        );

    PhoneResult ("GetStatusMessages", lResult);

    return lResult;
}


LONG
WINAPI
phoneGetVolume(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    LPDWORD lpdwVolume
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwHookSwitchDev,
        (DWORD) lpdwVolume,
        (LPVOID)gaProcs[pGetVolume],
        0x1,
        3
        );

    PhoneResult ("GetVolume", lResult);

    return lResult;
}


LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP     lphPhoneApp,
    HINSTANCE       hInstance,
    PHONECALLBACK   lpfnCallback,
    LPCSTR          lpszAppName,
    LPDWORD         lpdwNumDevs
    )
{
    return (xxxInitialize(
        FALSE,
        (LPHLINEAPP) lphPhoneApp,
        hInstance,
        lpfnCallback,
        lpszAppName,
        lpdwNumDevs
        ));
}


LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPILowVersion,
    DWORD       dwAPIHighVersion,
    LPDWORD     lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp ((HLINEAPP) hPhoneApp)))
    {
        lResult = (*pfnCallProc6)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPILowVersion,
            (DWORD) dwAPIHighVersion,
            (DWORD) lpdwAPIVersion,
            (DWORD) lpExtensionID,
            (LPVOID)gaProcs[pNegotiateAPIVersion],
            0x3,
            6
            );
    }
    else
    {
        lResult = PHONEERR_INVALAPPHANDLE;
    }

    PhoneResult ("NegotiateAPIVersion", lResult);

    return lResult;
}


LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP hPhoneApp,
    DWORD dwDeviceID,
    DWORD dwAPIVersion,
    DWORD dwExtLowVersion,
    DWORD dwExtHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp ((HLINEAPP) hPhoneApp)))
    {
        lResult = (*pfnCallProc6)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtLowVersion,
            (DWORD) dwExtHighVersion,
            (DWORD) lpdwExtVersion,
            (LPVOID)gaProcs[pNegotiateExtVersion],
            0x1,
            6
            );
    }
    else
    {
        lResult = PHONEERR_INVALAPPHANDLE;
    }

    PhoneResult ("NegotiateExtVersion", lResult);

    return lResult;
}


LONG
WINAPI
phoneOpen(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    LPHPHONE    lphPhone,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    DWORD       dwCallbackInstance,
    DWORD       dwPrivilege
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp ((HLINEAPP) hPhoneApp)))
    {
        lResult = (*pfnCallProc7)(
            (DWORD) pAppData->hXxxApp,
            (DWORD) dwDeviceID,
            (DWORD) lphPhone,
            (DWORD) dwAPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) dwCallbackInstance,
            (DWORD) dwPrivilege,
            (LPVOID)gaProcs[pOpen],
            0x10,
            7
            );
    }
    else
    {
        lResult = PHONEERR_INVALAPPHANDLE;
    }

    PhoneResult ("Open", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetButtonInfo(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    LPPHONEBUTTONINFO const lpButtonInfo
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwButtonLampID,
        (DWORD) lpButtonInfo,
        (LPVOID)gaProcs[pSetButtonInfo],
        0x1,
        3
        );

    PhoneResult ("SetButtonInfo", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetData(
    HPHONE          hPhone,
    DWORD           dwDataID,
    LPVOID const    lpData,
    DWORD           dwSize
    )
{
    LONG    lResult = (*pfnCallProc4)(
        (DWORD) hPhone,
        (DWORD) dwDataID,
        (DWORD) lpData,
        (DWORD) dwSize,
        (LPVOID)gaProcs[pSetData],
        0x2,
        4
        );

    PhoneResult ("SetData", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetDisplay(
    HPHONE  hPhone,
    DWORD   dwRow,
    DWORD   dwColumn,
    LPCSTR  lpsDisplay,
    DWORD   dwSize
    )
{
    LONG    lResult = (*pfnCallProc5)(
        (DWORD) hPhone,
        (DWORD) dwRow,
        (DWORD) dwColumn,
        (DWORD) lpsDisplay,
        (DWORD) dwSize,
        (LPVOID)gaProcs[pSetDisplay],
        0x2,
        5
        );

    PhoneResult ("SetDisplay", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetGain(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    DWORD   dwGain
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwHookSwitchDev,
        (DWORD) dwGain,
        (LPVOID)gaProcs[pSetGain],
        0x0,
        3
        );

    PhoneResult ("SetGain", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetHookSwitch(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDevs,
    DWORD   dwHookSwitchMode
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwHookSwitchDevs,
        (DWORD) dwHookSwitchMode,
        (LPVOID)gaProcs[pSetHookSwitch],
        0x0,
        3
        );

    PhoneResult ("SetHookSwitch", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetLamp(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    DWORD   dwLampMode
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwButtonLampID,
        (DWORD) dwLampMode,
        (LPVOID)gaProcs[pSetLamp],
        0x0,
        3
        );

    PhoneResult ("SetLamp", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetRing(
    HPHONE  hPhone,
    DWORD   dwRingMode,
    DWORD   dwVolume
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwRingMode,
        (DWORD) dwVolume,
        (LPVOID)gaProcs[pSetRing],
        0x0,
        3
        );

    PhoneResult ("SetRing", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetStatusMessages(
    HPHONE  hPhone,
    DWORD   dwPhoneStates,
    DWORD   dwButtonModes,
    DWORD   dwButtonStates
    )
{
    LONG    lResult = (*pfnCallProc4)(
        (DWORD) hPhone,
        (DWORD) dwPhoneStates,
        (DWORD) dwButtonModes,
        (DWORD) dwButtonStates,
        (LPVOID)gaProcs[pSetStatusMessages],
        0x0,
        4
        );

    PhoneResult ("SetStatusMessages", lResult);

    return lResult;
}


LONG
WINAPI
phoneSetVolume(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    DWORD   dwVolume
    )
{
    LONG    lResult = (*pfnCallProc3)(
        (DWORD) hPhone,
        (DWORD) dwHookSwitchDev,
        (DWORD) dwVolume,
        (LPVOID)gaProcs[pSetVolume],
        0x0,
        3
        );

    PhoneResult ("SetVolume", lResult);

    return lResult;
}


LONG
WINAPI
phoneShutdown(
    HPHONEAPP hPhoneApp
    )
{
    LONG            lResult;
    LPTAPI_APP_DATA pAppData;


    if ((pAppData = IsValidXxxApp ((HLINEAPP) hPhoneApp)))
    {
        if ((lResult = (*pfnCallProc1)(
               (DWORD) pAppData->hXxxApp,
               (LPVOID)gaProcs[pShutdown],
               0x0,
               1

               )) == 0)
        {
            //
            // Destroy the associated window & free the app data instance
            //

            DestroyWindow (pAppData->hwnd);
            pAppData->dwKey = 0xefefefef;
            free (pAppData);
        }
    }
    else
    {
        lResult = PHONEERR_INVALAPPHANDLE;
    }

    PhoneResult ("Shutdown", lResult);

    return lResult;
}


LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc4)(
        (DWORD) lpszDestAddress,
        (DWORD) lpszAppName,
        (DWORD) lpszCalledParty,
        (DWORD) lpszComment,
        (LPVOID)gaProcs[tRequestMakeCall],
        0xf,
        4
        );

    TapiResult ("RequestMakeCall", lResult);

    return lResult;
}


LONG
WINAPI
tapiRequestMediaCall(
    HWND    hWnd,
    WPARAM  wRequestID,
    LPCSTR  lpszDeviceClass,
    LPCSTR  lpDeviceID,
    DWORD   dwSize,
    DWORD   dwSecure,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc10)(
        (DWORD) hWnd,
        (DWORD) wRequestID,
        (DWORD) lpszDeviceClass,
        (DWORD) lpDeviceID,
        (DWORD) dwSize,
        (DWORD) dwSecure,
        (DWORD) lpszDestAddress,
        (DWORD) lpszAppName,
        (DWORD) lpszCalledParty,
        (DWORD) lpszComment,
        (LPVOID)gaProcs[tRequestMediaCall],
        0xcf,
        10
        );

    TapiResult ("RequestMediaCall", lResult);

    return lResult;
}


LONG
WINAPI
tapiRequestDrop(
    HWND    hWnd,
    WPARAM  wRequestID
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc2)(
        (DWORD) hWnd,
        (DWORD) wRequestID,
        (LPVOID)gaProcs[tRequestDrop],
        0x0,
        2
        );

    TapiResult ("Drop", lResult);

    return lResult;
}


LONG
WINAPI
tapiGetLocationInfo(
    LPSTR   lpszCountryCode,
    LPSTR   lpszCityCode
    )
{
    LONG lResult;

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc2)(
        (DWORD) lpszCountryCode,
        (DWORD) lpszCityCode,
        (LPVOID)gaProcs[tGetLocationInfo],
        0x3,
        2
        );

    TapiResult ("GetLocationInfo", lResult);

    return lResult;
}




//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
LONG
WINAPI
LAddrParamsInited(
    LPDWORD lpdwInited
    )
{
    LONG lResult;


#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc1)(
        (DWORD)lpdwInited,
        (LPVOID)gaProcs[LAddrParamsInitedVAL],
        0x1,
        1
        );

    LineResult ("LAddrParamsInited", lResult);

    return lResult;
}


//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
LONG
WINAPI
LOpenDialAsst(
    HWND    hwnd,
    LPCSTR  lpszAddressIn,
    BOOL    fSimple,
    BOOL    fSilentInstall)
{
    LONG lResult;



#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    lResult = (*pfnCallProc4)(
        hwnd,
        (DWORD)lpszAddressIn,
        fSimple,
        fSilentInstall,
        (LPVOID)gaProcs[LOpenDialAsstVAL],
        0x4,
        4
        );

    LineResult ("LOpenDialAsst", lResult);

    return lResult;
}



//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//BOOL CALLBACK EXPORT __loadds LocWizardDlgProc(
//BOOL CALLBACK  LocWizardDlgProc(
BOOL CALLBACK  _loadds LocWizardDlgProc(
                                                    HWND hWnd,
                                                    UINT uMessage,
                                                    WPARAM wParam,
                                                    LPARAM lParam)
{
    DWORD dwMapFlags = 0;
    DWORD dwNewwParam = wParam;
    LPARAM dwNewlParam = lParam;
    LONG  Newnmhdr[3];

#ifdef MEMPHIS
    DoFullLoad();
    LoadTAPI32IfNecessary();
#endif

    if (
         ( WM_HELP == uMessage ) ||
         ( WM_NOTIFY == uMessage )
       )
    {

        //
        // For these messages, lParam is a pointer.  Let's tell the thunk thing
        // to map it.
        //
        dwMapFlags = 0x1;

        if ( WM_NOTIFY == uMessage )
        {
            //
            // Rebuild for 32bit
            //
            Newnmhdr[0] = (DWORD)(((NMHDR *)lParam)->hwndFrom);
            Newnmhdr[1] = (LONG)((int)((NMHDR *)lParam)->idFrom);
            Newnmhdr[2] = (LONG)((int)((NMHDR *)lParam)->code);

            dwNewlParam = (LPARAM)&Newnmhdr;
        }

    }
    else
    {
        if ( WM_COMMAND == uMessage )
        {

            if (
                 (EN_CHANGE == HIWORD(lParam)) ||
                 (CBN_SELCHANGE == HIWORD(lParam))
               )
            {
                //
                // Move the command to the new Win32 place, and zero out the old command place
                //
                dwNewwParam |= ( ((DWORD)HIWORD(lParam)) << 16 );
                dwNewlParam     &= 0x0000ffff;
            }

        }

    }



    return (BOOL)(*pfnCallProc4)(
        hWnd,
        uMessage,
        dwNewwParam,
        dwNewlParam,
        (LPVOID)gaProcs[LocWizardDlgProc32],
        dwMapFlags,
        4
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\tregupr2\debug.c ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  debug.c
                                                              
     Abstract:  Debug routines
                                                              
       Author:  radus - 11/05/98

****************************************************************************/

#if DBG

#include <windows.h>
#include "stdarg.h"
#include "stdio.h"
#include "debug.h"
#include <shlwapi.h>
#include <shlwapip.h>

#define DEBUG_LEVEL                 8


VOID
LibDbgPrt(
    DWORD  dwDbgLevel,
    PSTR   lpszFormat,
    ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static DWORD gdwDebugLevel = DEBUG_LEVEL;   //HACKHACK


    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[256] = "TAPIUPR2 (xxxxxxxx): ";
        
       
        va_list ap;

        wsprintfA( &buf[10], "%08lx", GetCurrentThreadId() );
        buf[18] = ')';

        va_start(ap, lpszFormat);

        wvsprintfA (&buf[21],
                  lpszFormat,
                  ap
                  );

        lstrcatA (buf, "\n");

        OutputDebugStringA (buf);

        va_end(ap);
    }
}

void DebugAssertFailure (LPCTSTR file, DWORD line, LPCTSTR condition)
{
        TCHAR   temp    [0x100];
        CHAR    sz      [0x100];

        wsprintf(temp, TEXT("%s(%d) : Assertion failed, condition: %s\n"), file, line, condition);

        // Due to inconsistant header declairation I'm doing a convert here instead of fixing
        // the 55 places where the header difference causes a problem.  This is lazy, but
        // this is debug only code so I really don't care.  The problem is that
        // DebugAssertFailure is declaired TCHAR while LibDbgPrt is declaired CHAR.
        SHTCharToAnsi(temp, sz, 0x100);
        LibDbgPrt (0, sz);

        DebugBreak();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\tregupr2\debug.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  debug.h
                                                              
     Abstract:  Debug routines
                                                              
       Author:  radus - 11/05/98
              
****************************************************************************/

#if DBG

#define DBGOUT(arg) LibDbgPrt arg
#define assert(condition)       if(condition);else      \
        { DebugAssertFailure (_T(__FILE__), __LINE__, _T(#condition)); }

void
LibDbgPrt(
    DWORD  dwDbgLevel,
    PSTR DbgMessage,
    ...
    );

void DebugAssertFailure (LPCTSTR file, DWORD line, LPCTSTR condition);

#else   // DBG

#define DBGOUT(_x_)
#define assert(condition)

#endif  // DBG

#define EXIT_IF_DWERROR()     \
    if(dwError !=ERROR_SUCCESS)  \
    {                               \
        goto forced_exit;           \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\tregupr2\tregupr2.c ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  tregupr2.c
                                                              
     Abstract:  Upgrades the telephony registry settings to the post NT5b2 format
                                                              
       Author:  radus - 09/11/98
              

        Notes:  stolen from \Nt\Private\tapi\dev\apps\tapiupr\tapiupr.c
 
        
  Rev History:

****************************************************************************/



#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stdlib.h>

// from the old version of loc_comn.h
#define MAXLEN_AREACODE            16
#define OLDFLAG_LOCATION_ALWAYSINCLUDEAREACODE  0x00000008
//
#include "tregupr2.h"
#include "debug.h"

#define BACKUP_OLD_KEYS
#define BACKUP_FILE_LOCATIONS           _T("REGLOCS.OLD")
#define BACKUP_FILE_USER_LOCATIONS      _T("REGULOCS.OLD")
#define BACKUP_FILE_CARDS               _T("REGCARDS.OLD")



#define AREACODERULE_INCLUDEALLPREFIXES     0x00000001
#define AREACODERULE_DIALAREACODE           0x00000002
#define AREACODERULE_DIALNUMBERTODIAL       0x00000004


#define US_COUNTRY_CODE(x)	((x) == 1 || \
		(x >= 100 && x < 200))


#define MAXLEN_NUMBER_LEN          12      
#define MAXLEN_RULE                 128
#define MAXLEN_ACCESS_NUMBER        128
#define MAXLEN_PIN                  128

#define TEMPORARY_ID_FLAG       0x80000000

#define PRIVATE static



PRIVATE DWORD ConvertOneLocation(   HKEY    hLocation);
PRIVATE DWORD CreateAreaCodeRule(   HKEY    hParent,
                            int     iRuleNumber,
                            LPCTSTR  pszAreaCodeToCall,
                            LPCTSTR  pszNumberToDial,
                            LPBYTE   pbPrefixes,
                            DWORD    dwPrefixesLength,
                            DWORD    dwFlags
                            );


PRIVATE DWORD ConvertOneCard(HKEY hCard, DWORD);
PRIVATE DWORD ConvertPIN(HKEY hCard, DWORD);
PRIVATE BOOL  IsTelephonyDigit(TCHAR );
PRIVATE DWORD SplitCallingCardRule(HKEY hCard, LPCTSTR pszRuleName, LPCTSTR pszAccessNumberName);
PRIVATE DWORD RegRenameKey( HKEY hParentKey,
                            LPCTSTR pszOldName,
                            LPCTSTR pszNewName);
PRIVATE DWORD RegCopyKeyRecursive(HKEY hSrcParentKey, LPCTSTR pszSrcName, 
                                  HKEY hDestParentKey, LPCTSTR pszDestName);

#ifdef BACKUP_OLD_KEYS
#ifdef WINNT
PRIVATE
BOOL
EnablePrivilege(
    PTSTR PrivilegeName,
    BOOL  Enable,
    BOOL  *Old
    );
#endif // WINNT

PRIVATE
BOOL    
SaveKey(
    HKEY    hKey,
    LPCTSTR pszFileName
    );
#endif // BACKUP_OLD_KEYS



PRIVATE const TCHAR gszName[]				= _T("Name");
PRIVATE const TCHAR gszID[] 				= _T("ID");
PRIVATE const TCHAR gszAreaCode[]			= _T("AreaCode");
PRIVATE const TCHAR gszAreaCodeRules[]		= _T("AreaCodeRules");
PRIVATE const TCHAR gszCountry[]			= _T("Country");
PRIVATE const TCHAR gszFlags[]				= _T("Flags");
PRIVATE const TCHAR gszDisableCallWaiting[] = _T("DisableCallWaiting");
PRIVATE const TCHAR gszTollList[]			= _T("TollList");
PRIVATE const TCHAR gszNoPrefAC[]			= _T("NoPrefAC");
PRIVATE const TCHAR gszPrefixes[]			= _T("Prefixes");
PRIVATE const TCHAR gszRules[]	    		= _T("Rules");
PRIVATE const TCHAR gszRule[]			    = _T("Rule");
PRIVATE const TCHAR gszAreaCodeToCall[]		= _T("AreaCodeToCall");
PRIVATE const TCHAR gszNumberToDial[]		= _T("NumberToDial");



PRIVATE const TCHAR gszCard[]				= _T("Card");
PRIVATE const TCHAR gszCards[]				= _T("Cards");
PRIVATE const TCHAR gszLocalRule[]			= _T("LocalRule");
PRIVATE const TCHAR gszLDRule[] 			= _T("LDRule");
PRIVATE const TCHAR gszInternationalRule[]	= _T("InternationalRule");
PRIVATE const TCHAR gszLocalAccessNumber[]	= _T("LocalAccessNumber");
PRIVATE const TCHAR gszLDAccessNumber[] 	= _T("LDAccessNumber");
PRIVATE const TCHAR gszInternationalAccessNumber[]	= _T("InternationalAccessNumber");
PRIVATE const TCHAR gszAccountNumber[]	=   _T("AccountNumber");
PRIVATE const WCHAR gwszPIN[] 				= L"PIN";

PRIVATE const TCHAR gszNumEntries[] 		= _T("NumEntries");

PRIVATE const TCHAR gszEmpty[]	   =  _T("");
PRIVATE const TCHAR gszMultiEmpty[]	   =  _T("\0");

PRIVATE const TCHAR gszLocations[] =  _T("Locations");
PRIVATE const TCHAR gszLocation[]  =  _T("Location");

PRIVATE const TCHAR gszLocationsPath[]	  = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations");
PRIVATE const TCHAR gszCardsPath[]	      = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Cards");
PRIVATE const TCHAR gszUSLDSpecifier[]	  = _T("1");

PRIVATE const TCHAR gszLocationListVersion[]  = _T("LocationListVersion");
PRIVATE const TCHAR gszCardListVersion[]  = _T("CardListVersion");

PRIVATE const TCHAR gszKeyRenameHistory[] = _T("KeyRenameHistory");

#pragma check_stack ( off )

//***************************************************************************
//***************************************************************************
//***************************************************************************
//
//  ConvertLocations    - convert the telephony locations to the new format.
//                   see nt\private\tapi\dev\docs\dialrules.doc
//

DWORD ConvertLocations(void)
{
    
    TCHAR       Location[sizeof(gszLocation)/sizeof(TCHAR) + MAXLEN_NUMBER_LEN];
    TCHAR       NewLocation[sizeof(gszLocation)/sizeof(TCHAR) + MAXLEN_NUMBER_LEN];
    DWORD       dwError = ERROR_SUCCESS;
    HKEY        hLocations = NULL;
    HKEY        hLocation = NULL;
    DWORD       dwNumEntries;
    DWORD       dwCount;
    DWORD       dwRenameEntryCount;
    DWORD       dwCountPhase1;
    DWORD       dwLength;
    DWORD       dwType;
    DWORD       dwLocationID;
    DWORD       dwLocationIDTmp;
    DWORD       dwValue;

    PDWORD      pdwRenameList = NULL;
    PDWORD      pdwRenameEntry;
    PDWORD      pdwRenameEntryPhase1;

#ifdef      BACKUP_OLD_KEYS
    TCHAR   szPath[MAX_PATH+1];
#endif

    DBGOUT((9, "ConvertLocations - Enter"));

    

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            gszLocationsPath,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hLocations
                            );

    if(dwError == ERROR_FILE_NOT_FOUND)
    {
        DBGOUT((1, "Locations key not present, so there's nothing to convert"));
        //Nothing to convert
        return ERROR_SUCCESS;
    }

    EXIT_IF_DWERROR();
    
    // Version check
    if(!IsLocationListInOldFormat(hLocations))
    {
        //Nothing to convert
        DBGOUT((1, "Locations key is already in the new format"));
        RegCloseKey(hLocations);
        return ERROR_SUCCESS;
    }

#ifdef      BACKUP_OLD_KEYS

    // Try to save the old key
    dwError = GetWindowsDirectory(szPath, MAX_PATH - 12); // a 8+3 name
    if(dwError)
    {
        if(szPath[3] != _T('\0'))
            lstrcat(szPath, _T("\\"));
        lstrcat(szPath, BACKUP_FILE_LOCATIONS);

        SaveKey(hLocations, szPath);
    
    }
    else
        DBGOUT((1, "Cannot get windows directory (?!?)"));

    dwError = ERROR_SUCCESS;

#endif

    // Read number of entries
    dwLength = sizeof(dwNumEntries);
    dwError = RegQueryValueEx(  hLocations,
                                gszNumEntries,
                                NULL,
                                &dwType,
                                (BYTE *)&dwNumEntries,
                                &dwLength
                                );

    if(dwError==ERROR_SUCCESS && dwType != REG_DWORD)
    {
        dwError = ERROR_INVALID_DATA;
        assert(FALSE);
    }

    // The value could be missing in an empty key
    if(dwError != ERROR_SUCCESS)
        dwNumEntries = 0;

    // Alloc a rename list for the worst case (all key to be renamed using temporary IDs)
    if(dwNumEntries>0)
    {
        pdwRenameList = (PDWORD)GlobalAlloc(GPTR, dwNumEntries*4*sizeof(DWORD) );
        if(pdwRenameList==NULL)
        {
            DBGOUT((1, "Cannot allocate the Rename List"));
            dwError = ERROR_OUTOFMEMORY;
            goto forced_exit;
        }
    }
    pdwRenameEntry = pdwRenameList;
    dwRenameEntryCount = 0;
    
    // Convert from end to the begining in order to avoid name conflicts during the key renames
    for(dwCount = dwNumEntries-1; (LONG)dwCount>=0; dwCount--)
    {
        wsprintf(Location, _T("%s%d"), gszLocation, dwCount);

        dwError = RegOpenKeyEx( hLocations,
                                Location,
                                0,
                                KEY_READ | KEY_WRITE,
                                &hLocation
                                );

        if(dwError == ERROR_FILE_NOT_FOUND)
        {
            DBGOUT((1, "Cannot open old %s", Location));
            // Try to recover - skip to the next entry
            continue;
        }
        EXIT_IF_DWERROR();

        // Read the ID for later usage
        dwLength = sizeof(dwLocationID);
        dwError = RegQueryValueEx(  hLocation,
                                    gszID,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwLocationID,
                                    &dwLength
                                    );
        if(dwError == ERROR_SUCCESS)
        {

            // Convert the location to the new format
            dwError = ConvertOneLocation(hLocation);
        
            if(dwError != ERROR_SUCCESS)
            {
                DBGOUT((1, "%s conversion failed with error %d. Trying to continue...", Location, dwError));
            }
        
            RegCloseKey(hLocation);
            hLocation = NULL;

            // Rename the key if it is necessary
            if(dwLocationID != dwCount)
            {
                wsprintf(NewLocation, _T("%s%d"), gszLocation, dwLocationID);

                // Check the destination for an old key still present. It may be possible to find one if 
                // the original TAPI version was TELEPHON.INI-based.
                assert(!(dwLocationID & TEMPORARY_ID_FLAG));

                dwLocationIDTmp = dwLocationID;

                dwError = RegOpenKeyEx( hLocations,
                                        NewLocation,
                                        0,
                                        KEY_READ,
                                        &hLocation
                                        );

                if(dwError==ERROR_SUCCESS)
                {
                    // use a temporary ID
                    dwLocationIDTmp |= TEMPORARY_ID_FLAG;
                    wsprintf(NewLocation, _T("%s%d"), gszLocation, dwLocationIDTmp);
                }

                if(hLocation)
                {
                    RegCloseKey(hLocation);
                    hLocation = NULL;
                }

                dwError = RegRenameKey( hLocations,
                                        Location,
                                        NewLocation
                                        );
                EXIT_IF_DWERROR();
                // trace the rename. It will be useful when we try to upgrade the HKEY_CURRENT_USER/../Locations key
                *pdwRenameEntry++ = dwCount;
                *pdwRenameEntry++ = dwLocationIDTmp;
                dwRenameEntryCount++;
            }

            DBGOUT  ((9, "Converted location %d (ID %d)", dwCount, dwLocationID));
        }

    }

    dwError = ERROR_SUCCESS;

    // Rewalk the list for renaming the keys with temporary IDs
    pdwRenameEntryPhase1 = pdwRenameList;
    dwCountPhase1 = dwRenameEntryCount;

    for(dwCount=0; dwCount<dwCountPhase1; dwCount++)
    {
        pdwRenameEntryPhase1++;
        dwLocationIDTmp = *pdwRenameEntryPhase1++;

        if(dwLocationIDTmp & TEMPORARY_ID_FLAG)
        {
            wsprintf(Location, _T("%s%d"), gszLocation, dwLocationIDTmp);

            dwLocationID = dwLocationIDTmp & ~TEMPORARY_ID_FLAG;
            wsprintf(NewLocation, _T("%s%d"), gszLocation, dwLocationID);

            dwError = RegRenameKey( hLocations,
                                        Location,
                                        NewLocation
                                        );
            EXIT_IF_DWERROR();
            
            *pdwRenameEntry++ = dwLocationIDTmp;
            *pdwRenameEntry++ = dwLocationID;
            dwRenameEntryCount++;
            
            DBGOUT  ((9, "Renamed to permanent ID %d", dwLocationID));
        }
    }

    // delete the DisableCallWaiting value
    RegDeleteValue(   hLocations,
                      gszDisableCallWaiting
                      );

    // delete the NumEntries value. We don't need it any more
    RegDeleteValue(   hLocations,
                      gszNumEntries);

    // add the rename history
    dwError = RegSetValueEx(    hLocations,
                                gszKeyRenameHistory,
                                0,
                                REG_BINARY,
                                (PBYTE)pdwRenameList,
                                dwRenameEntryCount*2*sizeof(DWORD)
                                );
    EXIT_IF_DWERROR();


    // add the versioning value
    dwValue = TAPI_LOCATION_LIST_VERSION;
    dwError = RegSetValueEx(    hLocations,
                                gszLocationListVersion,
                                0,
                                REG_DWORD,
                                (PBYTE)&dwValue,
                                sizeof(dwValue)
                                );
    EXIT_IF_DWERROR();

forced_exit:

    if(hLocation)
        RegCloseKey(hLocation);
    if(hLocations)
        RegCloseKey(hLocations);
    if(pdwRenameList)
        GlobalFree(pdwRenameList);

    DBGOUT((9, "ConvertLocations - Exit %xh", dwError));

    return dwError;

}

//***************************************************************************
//
//  ConvertOneLocation    - convert one location 
//                      hLocation is the handle of the LocationX key
//  Note    The key rename according to location ID is executed in ConvertLocations

PRIVATE DWORD ConvertOneLocation(   HKEY    hLocation)
{
    DWORD       dwError = ERROR_SUCCESS;
    LPTSTR      pTollList = NULL;
    LPBYTE      pNoPrefAC = NULL;
    TCHAR       *pCrt;
    TCHAR       AreaCode[MAXLEN_AREACODE];
    DWORD       dwFlags;
    DWORD       dwCountryID;
    DWORD       dwType;
    DWORD       dwLength;
    DWORD       dwTollListLength;
    DWORD       dwDisp;
    HKEY        hAreaCodeRules = NULL;
    int         iRuleNumber;

    DBGOUT((9, "ConvertOneLocation - Enter"));

    assert(hLocation);


    // Read the current location flags
    dwLength = sizeof(dwFlags);
    dwError = RegQueryValueEx(  hLocation,
                                gszFlags,
                                NULL,
                                &dwType,
                                (BYTE *)&dwFlags,
                                &dwLength
                                );
    if(dwError==ERROR_SUCCESS && dwType != REG_DWORD)
    {
        dwError=ERROR_INVALID_DATA;
        assert(FALSE);
    }

    EXIT_IF_DWERROR();

    //Read the current Area Code
    dwLength = sizeof(AreaCode);
    dwError = RegQueryValueEx(  hLocation,
                                gszAreaCode,
                                NULL,
                                &dwType,
                                (BYTE *)AreaCode,
                                &dwLength
                                );
    if(dwError==ERROR_SUCCESS && dwType != REG_SZ)
    {
        dwError=ERROR_INVALID_DATA;
        assert(FALSE);
    }

    EXIT_IF_DWERROR();

    //Read the current Country ID
    dwLength = sizeof(dwCountryID);
    dwError = RegQueryValueEx(  hLocation,
                                gszCountry,
                                NULL,
                                &dwType,
                                (BYTE *)&dwCountryID,
                                &dwLength
                                );
    if(dwError==ERROR_SUCCESS && dwType != REG_DWORD)
    {
        dwError=ERROR_INVALID_DATA;
        assert(FALSE);
    }

    EXIT_IF_DWERROR();

    // create the AreaCodeRules subkey
    dwError = RegCreateKeyEx(   hLocation,
                                gszAreaCodeRules,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                NULL,
                                &hAreaCodeRules,
                                &dwDisp
                                );
    if(dwError==ERROR_SUCCESS && dwDisp != REG_CREATED_NEW_KEY)
    {
        dwError=ERROR_INVALID_DATA;
        assert(FALSE);
    }
    EXIT_IF_DWERROR();

    iRuleNumber = 0;

    // Create a rule for "Always Include Area Code" flag..
    if(dwFlags & OLDFLAG_LOCATION_ALWAYSINCLUDEAREACODE)
    {
        dwError = CreateAreaCodeRule(   hAreaCodeRules,
                                        iRuleNumber++,
                                        AreaCode,
                                        gszEmpty,
                                        (LPBYTE)gszMultiEmpty,
                                        sizeof(gszMultiEmpty),
                                        AREACODERULE_DIALAREACODE | AREACODERULE_INCLUDEALLPREFIXES
                                        );
        EXIT_IF_DWERROR();

        // update the location flag
        dwFlags &= ~OLDFLAG_LOCATION_ALWAYSINCLUDEAREACODE;
        dwLength = sizeof(dwFlags);
        dwError = RegSetValueEx(    hLocation,
                                    gszFlags,
                                    0,
                                    REG_DWORD,
                                    (CONST BYTE *)&dwFlags,
                                    dwLength
                                    );
        EXIT_IF_DWERROR();
    }

    // The TollList and NoPrefAC were valid only in countries with Country=1 (US, Canada)
    // Ignore them if other country

    if(US_COUNTRY_CODE(dwCountryID))
    {
        // Translate TollList
        // Length...
        dwError = RegQueryValueEx(  hLocation,
                                    gszTollList,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dwTollListLength);
        if(dwError == ERROR_SUCCESS)
        {

            pTollList=GlobalAlloc(GPTR, dwTollListLength+sizeof(TCHAR)); // We'll convert in place to a 
                                                                         // REG_MULTI_SZ, so reserve an extra space for safety

            dwError = pTollList!=NULL ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
            EXIT_IF_DWERROR();

            // ..and read
            dwError = RegQueryValueEx(  hLocation,
                                        gszTollList,
                                        NULL,
                                        &dwType,
                                        (BYTE *)pTollList,
                                        &dwTollListLength
                                        );
            if(dwError == ERROR_SUCCESS && dwType != REG_SZ)
            {
                dwError = ERROR_INVALID_DATA;
                assert(FALSE);
            }
            EXIT_IF_DWERROR();

            // try to find one toll prefix
            pCrt = pTollList;
            //skip any unwanted commas
            while(*pCrt==_T(','))
            {
                pCrt++;
                dwTollListLength -= sizeof(TCHAR);
            }

            if(*pCrt)
            {
                TCHAR   *   pOut = pCrt;

                // convert inplace to a REG_MULTI_SZ
                while(*pCrt)
                {
                    while(*pCrt && *pCrt!=_T(','))
                    {
                        pCrt++;
                    }
                    if(!*pCrt)
                    {
                        // incorrect string (does not end with a comma)
                        pCrt++;
                        *pCrt = _T('\0');
                        dwTollListLength+=sizeof(TCHAR);
                    }
                    else
                       *pCrt++ = _T('\0');
                }
            
                // Create one rule for all the prefixes
                dwError = CreateAreaCodeRule(   hAreaCodeRules,
                                                iRuleNumber++,
                                                AreaCode,
                                                gszUSLDSpecifier,
                                                (BYTE *)pOut,
                                                dwTollListLength,
                                                AREACODERULE_DIALAREACODE | AREACODERULE_DIALNUMBERTODIAL
                                                );
                EXIT_IF_DWERROR();
            }
                
        }
    

        DBGOUT((9, "ConvertOneLocation - Success TollList"));

        // Translate NoPrefAC
        // Length...
        dwError = RegQueryValueEx(  hLocation,
                                    gszNoPrefAC,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dwLength);

        if(dwError== ERROR_SUCCESS && dwLength>0)
        {

            int iCount;
            DWORD   *pValue;
            TCHAR   AreaCodeToCall[MAXLEN_NUMBER_LEN];

            pNoPrefAC=GlobalAlloc(GPTR, dwLength);

            dwError = pNoPrefAC!=NULL ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
            EXIT_IF_DWERROR();

            // ..and read
            dwError = RegQueryValueEx(  hLocation,
                                        gszNoPrefAC,
                                        NULL,
                                        &dwType,
                                        pNoPrefAC,
                                        &dwLength
                                    );
            if(dwError == ERROR_SUCCESS && dwType != REG_BINARY)
            {
                dwError = ERROR_INVALID_DATA;
                assert(FALSE);
            }
            EXIT_IF_DWERROR();
  
            iCount = dwLength/4;

            pValue = (DWORD *)pNoPrefAC;

            while(iCount--)
            {
                // Create one rule for each area code
                _itot(*pValue, AreaCodeToCall, 10);

                dwError = CreateAreaCodeRule(   hAreaCodeRules,
                                                iRuleNumber++,
                                                AreaCodeToCall,
                                                gszEmpty,
                                                (LPBYTE)gszMultiEmpty,
                                                sizeof(gszMultiEmpty),
                                                AREACODERULE_DIALAREACODE | AREACODERULE_INCLUDEALLPREFIXES
                                                );
                EXIT_IF_DWERROR();

                pValue++;
            }

        }    
        
        DBGOUT((9, "ConvertOneLocation - Success NoPrefAC"));

    }

    dwError = ERROR_SUCCESS;

    // delete the TollList Value
    RegDeleteValue(   hLocation,
                      gszTollList
                      );

    // delete the NoPrefAC Value
    RegDeleteValue(   hLocation,
                      gszNoPrefAC
                      );
    
    // delete the ID Value
    RegDeleteValue(   hLocation,
                      gszID
                      );

forced_exit:

    if(hAreaCodeRules)
        RegCloseKey(hAreaCodeRules);
    if(pTollList)
        GlobalFree(pTollList);
    if(pNoPrefAC)
        GlobalFree(pNoPrefAC);

    DBGOUT((9, "ConvertOneLocation - Exit %xh", dwError));

    return dwError;
}

//***************************************************************************
//
//  CreateAreaCodeRule    - creates an area code rule key
//                      hParent =  handle of the AreaCodeRules key
//                      iRuleNumber = rule number
//                      pszAreaCodeToCall, pszNumberToDial & dwFlags = rule values   
//                      pbPrefixes - prefixes 
//                      dwPrefixesLength - length of the prefixes in bytes (including the NULL characters)                 


PRIVATE     DWORD CreateAreaCodeRule(   HKEY    hParent,
                                        int     iRuleNumber,
                                        LPCTSTR  pszAreaCodeToCall,
                                        LPCTSTR  pszNumberToDial,
                                        LPBYTE   pbPrefixes,
                                        DWORD    dwPrefixesLength,
                                        DWORD    dwFlags
                            )
{

    TCHAR   szBuffer[MAXLEN_NUMBER_LEN + sizeof(gszRule)/sizeof(TCHAR)];
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwDisp;
    DWORD   dwLength;
    HKEY    hRule = NULL;

    DBGOUT((10, "CreateAreaCodeRule - Enter"));

    assert(hParent);
    assert(pszNumberToDial);
    assert(pszAreaCodeToCall);
    assert(pbPrefixes);

    //  Find the rule key name
    wsprintf(szBuffer, _T("%s%d"), gszRule, iRuleNumber);

    //  Create the key
    dwError = RegCreateKeyEx(   hParent,
                                szBuffer,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                NULL,
                                &hRule,
                                &dwDisp
                                );
    EXIT_IF_DWERROR();
    assert(dwDisp==REG_CREATED_NEW_KEY);


    // AreaCodeToCall value
    dwLength = (_tcslen(pszAreaCodeToCall)+1)*sizeof(TCHAR);
    dwError = RegSetValueEx(    hRule,
                                gszAreaCodeToCall,
                                0,
                                REG_SZ,
                                (CONST BYTE *)pszAreaCodeToCall,
                                dwLength
                                );
    EXIT_IF_DWERROR();

    // NumberToDial value
    dwLength = (_tcslen(pszNumberToDial)+1)*sizeof(TCHAR);
    dwError = RegSetValueEx(    hRule,
                                gszNumberToDial,
                                0,
                                REG_SZ,
                                (CONST BYTE *)pszNumberToDial,
                                dwLength
                                );
    EXIT_IF_DWERROR();

    // Flags value
    dwLength = sizeof(dwFlags);
    dwError = RegSetValueEx(    hRule,
                                gszFlags,
                                0,
                                REG_DWORD,
                                (CONST BYTE *)&dwFlags,
                                dwLength
                                );
    EXIT_IF_DWERROR();

    // Prefixes value
    dwError = RegSetValueEx(    hRule,
                                gszPrefixes,
                                0,
                                REG_MULTI_SZ,
                                (CONST BYTE *)pbPrefixes,
                                dwPrefixesLength
                                );

    EXIT_IF_DWERROR();
    
forced_exit:

    if(hRule)
        RegCloseKey(hRule);

    DBGOUT((10, "CreateAreaCodeRule - Exit %xh", dwError));

    return dwError;

}

//***************************************************************************
//***************************************************************************
//***************************************************************************
//
//  ConvertUserLocations    - convert the telephony locations stored in a per user way
//                      The parameter should be HKEY_CURRENT_USER
// 
// 
//

DWORD ConvertUserLocations(HKEY hUser)
{

    TCHAR       Location[sizeof(gszLocation)/sizeof(TCHAR) + MAXLEN_NUMBER_LEN];
    TCHAR       NewLocation[sizeof(gszLocation)/sizeof(TCHAR) + MAXLEN_NUMBER_LEN];
    DWORD       dwError = ERROR_SUCCESS;
    HKEY        hMachineLocations = NULL;
    HKEY        hLocations = NULL;
    DWORD       dwOldID;
    DWORD       dwNewID;
    DWORD       dwCount;
    DWORD       dwLength;
    DWORD       dwType;
    DWORD       dwValue;

    PDWORD      pdwRenameList = NULL;
    PDWORD      pdwRenameEntry;

#ifdef      BACKUP_OLD_KEYS
    TCHAR   szPath[MAX_PATH+1];
#endif


    DBGOUT((8, "ConvertUserLocations - Enter"));

    assert(hUser);

    dwError = RegOpenKeyEx( hUser,
                            gszLocationsPath,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hLocations
                            );

    if(dwError == ERROR_FILE_NOT_FOUND)
    {
        DBGOUT((1, "Locations key not present, so there's nothing to convert"));
        //Nothing to convert
        return ERROR_SUCCESS;
    }
    EXIT_IF_DWERROR();

#ifdef      BACKUP_OLD_KEYS

    // Try to save the old key
    // We DON'T use different files for different users
    dwError = GetWindowsDirectory(szPath, MAX_PATH - 12); // a 8+3 name
    if(dwError)
    {
        if(szPath[3] != _T('\0'))
            lstrcat(szPath, _T("\\"));
        lstrcat(szPath, BACKUP_FILE_USER_LOCATIONS);
    
        SaveKey(hLocations, szPath);
    }
    else
        DBGOUT((1, "Cannot get windows directory (?!?)"));

    dwError = ERROR_SUCCESS;

#endif

    // Version check
    if(!IsLocationListInOldFormat(hLocations))
    {
        //Nothing to convert
        DBGOUT((1, "User Locations key is already in the new format"));
        RegCloseKey(hLocations);
        return ERROR_SUCCESS;
    }

    // Open the Machine Locations key
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            gszLocationsPath,
                            0,
                            KEY_QUERY_VALUE,
                            &hMachineLocations
                            );

    if(dwError == ERROR_FILE_NOT_FOUND)
    {
        DBGOUT((1, "Locations key not present, so there's nothing to convert in User Locations"));
        //Nothing to convert
        return ERROR_SUCCESS;
    }

    EXIT_IF_DWERROR();
    
    // query info about the rename history value
    dwError = RegQueryValueEx(  hMachineLocations,
                                gszKeyRenameHistory,
                                NULL,
                                &dwType,
                                NULL,
                                &dwLength
                                );

    if(dwError==ERROR_SUCCESS && dwType!=REG_BINARY)
    {
        // strange value
        dwError = ERROR_INVALID_DATA;
    }
    if(dwError==ERROR_FILE_NOT_FOUND)
    {
        dwError = ERROR_SUCCESS;
        dwLength = 0;
    }
    EXIT_IF_DWERROR();

    if(dwLength>0)
    {
        pdwRenameList = (PDWORD)GlobalAlloc(GPTR, dwLength);
        if(pdwRenameList == NULL)
        {
            DBGOUT((1, "Cannot allocate the Rename List"));
            dwError = ERROR_OUTOFMEMORY;
            goto forced_exit;
        }
        // Read the list
        dwError = RegQueryValueEx(  hMachineLocations,
                                    gszKeyRenameHistory,
                                    NULL,
                                    NULL,
                                    (PBYTE)pdwRenameList,
                                    &dwLength);
        EXIT_IF_DWERROR();

        //
        RegCloseKey(hMachineLocations);
        hMachineLocations = NULL;

        // convert dwLength to the number of entries
        dwLength /= 2*sizeof(DWORD);

        pdwRenameEntry = pdwRenameList;
        for(dwCount = 0; dwCount<dwLength; dwCount++)
        {
            dwOldID = *pdwRenameEntry++;
            dwNewID = *pdwRenameEntry++;
            
            if(dwNewID != dwOldID)
            {
                wsprintf(Location, _T("%s%d"), gszLocation, dwOldID);
                wsprintf(NewLocation, _T("%s%d"), gszLocation, dwNewID);

                dwError = RegRenameKey( hLocations, 
                                        Location,
                                        NewLocation );
                if(dwError==ERROR_SUCCESS)
                {
                    DBGOUT  ((8, "Renamed user location number from %d to %d", dwOldID, dwNewID));
                }
                // ignore the errors - the key could be missing
            }
        }
    }
    
    // add the versioning value
    dwValue = TAPI_LOCATION_LIST_VERSION;
    dwError = RegSetValueEx(    hLocations,
                                gszLocationListVersion,
                                0,
                                REG_DWORD,
                                (PBYTE)&dwValue,
                                sizeof(dwValue)
                                );
    EXIT_IF_DWERROR();
    
forced_exit:
    
    DBGOUT((8, "ConvertUserLocations - Exit %xh", dwError));
   
    if(hMachineLocations)
        RegCloseKey(hMachineLocations);
    if(hLocations)
        RegCloseKey(hLocations);
    if(pdwRenameList)
        GlobalFree(pdwRenameList);

    return dwError;

}


//***************************************************************************
//***************************************************************************
//***************************************************************************
//
//  ConvertCallingCards    - convert the telephony calling cards to the new format
//                      The parameter should be HKEY_CURRENT_USER or the handle of HKU\.Default
// 
//                   see nt\private\tapi\dev\docs\dialrules.doc
//



DWORD   ConvertCallingCards(HKEY    hUser)
{
    TCHAR       Card[sizeof(gszCard)/sizeof(TCHAR) + MAXLEN_NUMBER_LEN];
    TCHAR       NewCard[sizeof(gszCard)/sizeof(TCHAR) + MAXLEN_NUMBER_LEN];
    DWORD       dwError = ERROR_SUCCESS;
    HKEY        hCards = NULL;
    HKEY        hCard = NULL;
    DWORD       dwNumCards;
    DWORD       dwCardID;
    DWORD       dwCardIDTmp;
    DWORD       dwCount;
    DWORD       dwLength;
    DWORD       dwType;
    DWORD       dwValue;
    BOOL        bCryptInitialized;
    PDWORD      pdwRenameList = NULL;
    PDWORD      pdwRenameEntry;
    DWORD       dwRenameEntryCount;

#ifdef      BACKUP_OLD_KEYS
    TCHAR   szPath[MAX_PATH+1];
#endif

    DBGOUT((8, "ConvertCallingCards - Enter"));
    
    assert(hUser);
    
    bCryptInitialized = FALSE;

    // Open the key
    dwError = RegOpenKeyEx( hUser,
                            gszCardsPath,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hCards
                            );

    if(dwError == ERROR_FILE_NOT_FOUND)
    {
        DBGOUT((1, "Cards key not present, so there's nothing to convert"));
        //Nothing to convert
        return ERROR_SUCCESS;
    }

    EXIT_IF_DWERROR();

    // Version check
    if(!IsCardListInOldFormat(hCards))
    {
        //Nothing to convert
        DBGOUT((1, "Cards key is already in the new format"));
        RegCloseKey(hCards);
        return ERROR_SUCCESS;
    }

#ifdef      BACKUP_OLD_KEYS
    
    // Try to save the old key
    // We DON'T use different files for different users
    dwError = GetWindowsDirectory(szPath, MAX_PATH - 12); // a 8+3 name
    if(dwError)
    {
        if(szPath[3] != _T('\0'))
            lstrcat(szPath, _T("\\"));
        lstrcat(szPath, BACKUP_FILE_CARDS);
    
        SaveKey(hCards, szPath);
    
    }
    else
        DBGOUT((1, "Cannot get windows directory (?!?)"));

    dwError = ERROR_SUCCESS;

#endif
    
    // Read number of cards
    dwLength = sizeof(dwNumCards);
    dwError = RegQueryValueEx(  hCards,
                                gszNumEntries,
                                NULL,
                                &dwType,
                                (BYTE *)&dwNumCards,
                                &dwLength
                                );

    if(dwError==ERROR_SUCCESS && dwType != REG_DWORD)
    {
        dwError = ERROR_INVALID_DATA;
        assert(FALSE);
    }

    // The value could be missing in an empty key
    if(dwError != ERROR_SUCCESS)
        dwNumCards = 0;

    // Alloc storage for a list of card temp IDs
    if(dwNumCards>0)
    {
        pdwRenameList = (PDWORD)GlobalAlloc(GPTR, dwNumCards*sizeof(DWORD) );
        if(pdwRenameList==NULL)
        {
            DBGOUT((1, "Cannot allocate the temp IDs List"));
            dwError = ERROR_OUTOFMEMORY;
            goto forced_exit;
        }
    }
    pdwRenameEntry = pdwRenameList;
    dwRenameEntryCount = 0;
    
    // Initialize the cryptographic part
    dwError = TapiCryptInitialize();
	
    bCryptInitialized = TRUE; // whatever the result was

    if(dwError != ERROR_SUCCESS)
    {
        DBGOUT((8, "ConvertCallingCards - Cannot init Crypt %xh", dwError));
        // Make it not fatal
        dwError = ERROR_SUCCESS;
    }
   

 
    // Convert from end to the begining in order to avoid name conflicts during the key renames
    for(dwCount = dwNumCards-1; (LONG)dwCount>=0; dwCount--)
    {
        wsprintf(Card, _T("%s%d"), gszCard, dwCount);

        dwError = RegOpenKeyEx( hCards,
                                Card,
                                0,
                                KEY_READ | KEY_WRITE,
                                &hCard
                                );
        if(dwError == ERROR_FILE_NOT_FOUND)
        {
            DBGOUT((1, "Cannot open old %s", Card));
            // Try to recover - skip to the next entry
            continue;
        }

        EXIT_IF_DWERROR();
        
        // Read the ID for later usage
        dwLength = sizeof(dwCardID);
        dwError = RegQueryValueEx(  hCard,
                                    gszID,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwCardID,
                                    &dwLength
                                    );
        if(dwError == ERROR_SUCCESS)
        {
            // Convert the card to the new format
            dwError = ConvertOneCard(hCard, dwCardID);
        
            EXIT_IF_DWERROR();
        
            RegCloseKey(hCard);
            hCard = NULL;

            // Rename the key if it is necessary
            if(dwCardID != dwCount)
            {
                wsprintf(NewCard, _T("%s%d"), gszCard, dwCardID);
                // Check the destination for an old key still present. It may be possible to find one if 
                // the original TAPI version was TELEPHON.INI-based.
                assert(!(dwCardID & TEMPORARY_ID_FLAG));

                dwCardIDTmp = dwCardID;

                dwError = RegOpenKeyEx( hCards,
                                        NewCard,
                                        0,
                                        KEY_READ,
                                        &hCard
                                        );

                if(dwError==ERROR_SUCCESS)
                {
                    // use a temporary ID
                    dwCardIDTmp |= TEMPORARY_ID_FLAG;
                    wsprintf(NewCard, _T("%s%d"), gszCard, dwCardIDTmp);
                
                    *pdwRenameEntry++ = dwCardIDTmp;
                    dwRenameEntryCount++;
                }

                if(hCard)
                {
                    RegCloseKey(hCard);
                    hCard = NULL;
                }


                dwError = RegRenameKey( hCards,
                                        Card,
                                        NewCard
                                        );
                EXIT_IF_DWERROR();
            }
        
            DBGOUT  ((8, "Converted card %d (ID %d)", dwCount, dwCardID));
        }
    }

    dwError = ERROR_SUCCESS;

    // Rewalk the list for renaming the keys with temporary IDs
    pdwRenameEntry = pdwRenameList;

    for(dwCount=0; dwCount<dwRenameEntryCount; dwCount++)
    {
        dwCardIDTmp = *pdwRenameEntry++;

        wsprintf(Card, _T("%s%d"), gszCard, dwCardIDTmp);

        dwCardID = dwCardIDTmp & ~TEMPORARY_ID_FLAG;
        wsprintf(NewCard, _T("%s%d"), gszCard, dwCardID);

        dwError = RegRenameKey( hCards,
                                Card,
                                NewCard
                              );
        EXIT_IF_DWERROR();
            
        DBGOUT  ((8, "Renamed to permanent ID %d", dwCardID));
      
    }

    // delete the NumEntries value. We don't need it any more
    RegDeleteValue(   hCards,
                      gszNumEntries);

    // add the versioning value
    dwValue = TAPI_CARD_LIST_VERSION;
    dwError = RegSetValueEx(    hCards,
                                gszCardListVersion,
                                0,
                                REG_DWORD,
                                (PBYTE)&dwValue,
                                sizeof(dwValue)
                                );
    EXIT_IF_DWERROR();

forced_exit:

    if(hCard)
        RegCloseKey(hCard);
    if(hCards)
        RegCloseKey(hCards);
    if(bCryptInitialized)
        TapiCryptUninitialize();
    if(pdwRenameList)
        GlobalFree(pdwRenameList);

    DBGOUT((8, "ConvertCallingCards - Exit %xh", dwError));

    return dwError;

}

//***************************************************************************
//
//  ConvertOneCard    - convert one calling card 
//                      hCard is the handle of the CardX key
//  Note    The key rename according to card ID is executed in ConvertCallingCards
DWORD ConvertOneCard(HKEY hCard, DWORD dwCardID)
{
    DWORD   dwError = ERROR_SUCCESS;

    DBGOUT((9, "ConvertOneCard - Enter"));

    assert(hCard);

    dwError = SplitCallingCardRule( hCard,
                                    gszLocalRule,
                                    gszLocalAccessNumber);
    // ignore any error

    dwError = SplitCallingCardRule( hCard,
                                    gszLDRule,
                                    gszLDAccessNumber);
    // ignore any error

    dwError = SplitCallingCardRule( hCard,
                                    gszInternationalRule,
                                    gszInternationalAccessNumber);
    // ignore any error

    dwError = RegSetValueEx(    hCard,
                                gszAccountNumber,
                                0,
                                REG_SZ,
                                (BYTE *)gszEmpty,
                                sizeof(TCHAR)
                                );
    // Converts the PIN number to a better encrypted form
    dwError = ConvertPIN(hCard, dwCardID);

    // delete the ID Value
    RegDeleteValue(   hCard,
                      gszID
                      );

//forced_exit:

    DBGOUT((9, "ConvertOneCard - Exit %xh", dwError));

    return dwError;
}

//***************************************************************************
//
//  ConvertPIN          - better encryption of the PIN number 
//                      hCard is the handle of the CardX key
//  

DWORD   ConvertPIN(HKEY hCard, DWORD dwCardID)
{
    WCHAR   szOldPIN[MAXLEN_PIN+1];
    PWSTR   pszNewPIN = NULL;
    DWORD   dwError;
    DWORD   dwLength;
    DWORD   dwLength2;
    DWORD   dwLength3;
    DWORD   dwType;

    // Read the old PIN with a UNICODE version of RegQuery..
    dwLength = sizeof(szOldPIN);
    dwError = RegQueryValueExW( hCard,
                                gwszPIN,
                                NULL,
                                &dwType,
                                (BYTE *)szOldPIN,
                                &dwLength
                                );
    if(dwError==ERROR_SUCCESS)
    {
        if(*szOldPIN==L'\0')
        {
            // Nothing to do !
            return ERROR_SUCCESS;
        }
        
        // Decrypts inplace
        dwError = TapiDecrypt(szOldPIN, dwCardID, szOldPIN, &dwLength2);
        if(dwError==ERROR_SUCCESS)
        {
            assert(dwLength2 == dwLength/sizeof(WCHAR));
            // Find the space needed for the encrypted result
            dwError = TapiEncrypt(szOldPIN, dwCardID, NULL, &dwLength2);
            if(dwError == ERROR_SUCCESS)
            {
                // If the length is the same with the original, we have no conversion
                if(dwLength2 > dwLength/sizeof(WCHAR))
                {
                    pszNewPIN = (PWSTR)GlobalAlloc(GMEM_FIXED, dwLength2*sizeof(WCHAR));
                    if(pszNewPIN==NULL)
                    {
                        return ERROR_OUTOFMEMORY;
                    }

                    dwError = TapiEncrypt(szOldPIN, dwCardID, pszNewPIN, &dwLength3);
                    if(dwError == ERROR_SUCCESS)
                    {
                        assert(dwLength3<=dwLength2);

                        // Write the new PIN
                        dwError = RegSetValueExW(   hCard,
                                                    gwszPIN,
                                                    0,
                                                    REG_SZ,
                                                    (BYTE *)pszNewPIN,
                                                    dwLength3*sizeof(WCHAR)
                                                    );

                        // TEST
                        /*
                        ZeroMemory(szOldPIN, sizeof(szOldPIN));
                        dwError = TapiDecrypt(pszNewPIN, dwCardID, szOldPIN, &dwLength3);
                        if(dwError==ERROR_SUCCESS)
                            DBGOUT((5, "TEST Decrypt Card %d - PIN # %S, Length=%d", dwCardID, szOldPIN, dwLength3));
                        else
                            DBGOUT((5, "TEST Decrypt Card %d - Error 0x%x", dwCardID, dwError));
                         */


                    }
                    GlobalFree(pszNewPIN);
                }
                else
                {
                    DBGOUT((5, "PIN for card %d not converted", dwCardID));
                }
            }


        }
        else
        {
            // Strange, shouldn't happen
            assert(FALSE);
        }
    }

    return dwError;
}



//***************************************************************************
//
//  Version Check

BOOL  IsLocationListInOldFormat(HKEY hLocations) // for both user & machine
{
    return (ERROR_SUCCESS != RegQueryValueEx(   hLocations,
                                                gszLocationListVersion,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL
                                             ));

}

BOOL  IsCardListInOldFormat(HKEY hCards)
{
    return (ERROR_SUCCESS != RegQueryValueEx(   hCards,
                                                gszCardListVersion,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL
                                             ));
}



//***************************************************************************
//
//  IsTelephonyDigit    - test range 0123456789#*ABCD


PRIVATE BOOL  IsTelephonyDigit(TCHAR c)
{
     return _istdigit(c) || c==_T('*') || c==_T('#') || c==_T('A') || c==_T('B') || c==_T('C') || c==_T('D');
}

//***************************************************************************
//
//  SplitCallingCardRule    - tries to find the access numbers and updates the coresponding values

PRIVATE DWORD SplitCallingCardRule(HKEY hCard, LPCTSTR pszRuleName, LPCTSTR pszAccessNumberName)
{
    
    TCHAR       OldRule[MAXLEN_RULE];
    TCHAR       NewRule[MAXLEN_RULE];
    TCHAR       AccessNumber[MAXLEN_ACCESS_NUMBER];
    
    TCHAR   *   pOld;
    TCHAR   *   pNew;
    TCHAR   *   pNr;

    DWORD       dwLength;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwType;
        
    // read the local rule
    dwLength = sizeof(OldRule);
    dwError = RegQueryValueEx(  hCard,
                                pszRuleName,
                                NULL,
                                &dwType,
                                (BYTE *)OldRule,
                                &dwLength
                                );
    if(dwError==ERROR_SUCCESS && dwType != REG_SZ)
    {
        dwError = ERROR_INVALID_DATA;
        assert(FALSE);
    }

    if(dwError==ERROR_SUCCESS)
    {
        // Parse the old rule
        pOld = OldRule;
        pNew = NewRule;
        pNr = AccessNumber;

        while(*pOld && IsTelephonyDigit(*pOld))
            *pNr++ = *pOld++;

        if(pNr!=AccessNumber)
            *pNew++ = _T('J');

        while(*pOld)
            *pNew++ = *pOld++;

        *pNew = _T('\0');
        *pNr = _T('\0');

        dwLength = (_tcslen(AccessNumber)+1)*sizeof(TCHAR);
        dwError = RegSetValueEx(    hCard,
                                    pszAccessNumberName,
                                    0,
                                    REG_SZ,
                                    (BYTE *)AccessNumber,
                                    dwLength
                                    );

        EXIT_IF_DWERROR();

        dwLength = (_tcslen(NewRule)+1)*sizeof(TCHAR);
        dwError = RegSetValueEx(    hCard,
                                    pszRuleName,
                                    0,
                                    REG_SZ,
                                    (BYTE *)NewRule,
                                    dwLength
                                    );
        EXIT_IF_DWERROR();
    }

forced_exit:

    return dwError;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************

// Helper functions for renaming the registry keys

PRIVATE DWORD RegRenameKey( HKEY hParentKey,
                            LPCTSTR pszOldName,
                            LPCTSTR pszNewName)
{

    DWORD   dwError;

    assert(pszOldName);
    assert(pszNewName);
    
    DBGOUT((15, "RegRenameKey - Start, from %s to %s", pszOldName, pszNewName));
    
    assert(hParentKey);
    assert(_tcscmp(pszOldName, pszNewName)!=0);

    dwError = RegCopyKeyRecursive(  hParentKey,
                                    pszOldName,
                                    hParentKey,
                                    pszNewName
                                    );
    EXIT_IF_DWERROR();

    dwError = RegDeleteKeyRecursive(hParentKey,
                                    pszOldName);
    EXIT_IF_DWERROR();

forced_exit:
    
    DBGOUT((15, "RegRenameKey - Exit %xh", dwError));

    return dwError;
}


PRIVATE DWORD RegCopyKeyRecursive(HKEY hSrcParentKey, LPCTSTR pszSrcName, 
                                  HKEY hDestParentKey, LPCTSTR pszDestName)
{
    HKEY    hSrcKey = NULL;
    HKEY    hDestKey = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwDisp;
    DWORD   dwMaxSubkeyLength;
    DWORD   dwMaxValueNameLength;
    DWORD   dwMaxValueLength;
    DWORD   dwNumValues;
    DWORD   dwNumSubkeys;
    DWORD   dwIndex;
    DWORD   dwType;
    DWORD   dwValueLength;
    DWORD   dwValueNameLength;
    DWORD   dwSubkeyLength;
    LPTSTR  pszSubkey = NULL;
    LPTSTR  pszValueName = NULL;
    LPBYTE  pbValue = NULL;

    assert(hSrcParentKey);
    assert(hDestParentKey);
    assert(pszSrcName);
    assert(pszDestName);

    // open source key
    dwError = RegOpenKeyEx( hSrcParentKey,
                            pszSrcName,
                            0,
                            KEY_READ,
                            &hSrcKey
                            );

    EXIT_IF_DWERROR();

    // create destination key
    dwError = RegCreateKeyEx(   hDestParentKey,
                                pszDestName,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &hDestKey,
                                &dwDisp
                                );
    EXIT_IF_DWERROR();
    assert(dwDisp==REG_CREATED_NEW_KEY);

    // query some info about the source key in order to allocate memory
    dwError = RegQueryInfoKey(  hSrcKey,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubkeys,
                                &dwMaxSubkeyLength,
                                NULL,
                                &dwNumValues,
                                &dwMaxValueNameLength,
                                &dwMaxValueLength,
                                NULL,
                                NULL
                                );
    EXIT_IF_DWERROR();
    
    pszSubkey = (LPTSTR)GlobalAlloc(GMEM_FIXED, (dwMaxSubkeyLength+1)*sizeof(TCHAR));
    if(pszSubkey==NULL)
        dwError = ERROR_OUTOFMEMORY;
    EXIT_IF_DWERROR();

    pszValueName = (LPTSTR)GlobalAlloc(GMEM_FIXED, (dwMaxValueNameLength+1)*sizeof(TCHAR));
    if(pszValueName==NULL)
        dwError = ERROR_OUTOFMEMORY;
    EXIT_IF_DWERROR();

    pbValue = (LPBYTE)GlobalAlloc(GMEM_FIXED, dwMaxValueLength);
    if(pbValue==NULL)
        dwError = ERROR_OUTOFMEMORY;
    EXIT_IF_DWERROR();

    // enumerate and copy the values
    for(dwIndex=0; dwIndex<dwNumValues; dwIndex++)
    {
        // read one value
        dwValueNameLength = dwMaxValueNameLength + 1;
        dwValueLength = dwMaxValueLength;

        dwError = RegEnumValue( hSrcKey,
                                dwIndex,
                                pszValueName,
                                &dwValueNameLength,
                                NULL,
                                &dwType,
                                pbValue,
                                &dwValueLength
                                );
        EXIT_IF_DWERROR();

        // write it
        dwError = RegSetValueEx(hDestKey,
                                pszValueName,
                                0,
                                dwType,
                                pbValue,
                                dwValueLength
                                );
        EXIT_IF_DWERROR();
    }

    // enumerate and copy the subkeys
    for(dwIndex=0; dwIndex<dwNumSubkeys; dwIndex++)
    {
        // read a subkey
        dwSubkeyLength = dwMaxSubkeyLength +1;
        dwError = RegEnumKeyEx( hSrcKey,
                                dwIndex,
                                pszSubkey,
                                &dwSubkeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
        EXIT_IF_DWERROR();

        // copy it
        dwError = RegCopyKeyRecursive(  hSrcKey,
                                        pszSubkey,
                                        hDestKey,
                                        pszSubkey
                                        );
        EXIT_IF_DWERROR();
    }

forced_exit:

    if(hSrcKey)
        RegCloseKey(hSrcKey);
    if(hDestKey)
        RegCloseKey(hDestKey);

    if(pszSubkey)
        GlobalFree(pszSubkey);
    if(pszValueName)
        GlobalFree(pszValueName);
    if(pbValue)
        GlobalFree(pbValue);

    return dwError;
}


DWORD RegDeleteKeyRecursive (HKEY hParentKey, LPCTSTR pszKeyName)
{
	HKEY	hKey = NULL;
	DWORD	dwError;
	DWORD	dwIndex;
	DWORD	dwSubKeyCount;
	LPTSTR	pszSubKeyName;
	DWORD	dwSubKeyNameLength;			// in characters
	DWORD	dwSubKeyNameLengthBytes;		// in bytes
	DWORD	dwMaxSubKeyLength;;

	dwError = RegOpenKeyEx (hParentKey, pszKeyName, 0, KEY_READ | KEY_WRITE, &hKey);
	if (dwError != ERROR_SUCCESS)
		return dwError;

	dwError = RegQueryInfoKey (
		hKey,					// key in question
		NULL, NULL,				// class
		NULL,					// reserved
		&dwSubKeyCount,			// number of subkeys
		&dwMaxSubKeyLength,		// maximum length of subkey name
		NULL,					// max class length
		NULL,					// number of values
		NULL,					// max value name len
		NULL,					// max value len
		NULL,					// security descriptor
		NULL);					// last write time

	if (dwError != ERROR_SUCCESS) {
		RegCloseKey (hKey);
		return dwError;
	}

	if (dwSubKeyCount > 0) {
		// at least one subkey

		dwSubKeyNameLengthBytes = sizeof (TCHAR) * (dwMaxSubKeyLength + 1);
		pszSubKeyName = (LPTSTR) GlobalAlloc (GMEM_FIXED, dwSubKeyNameLengthBytes);
		if (pszSubKeyName) {

			// delete from end to beginning, to avoid quadratic performance
			// ignore deletion errors

			for (dwIndex = dwSubKeyCount; dwIndex > 0; dwIndex--) {
				dwSubKeyNameLength = dwMaxSubKeyLength + 1;

				dwError = RegEnumKeyEx (hKey, dwIndex - 1, pszSubKeyName, &dwSubKeyNameLength, NULL, NULL, NULL, NULL);
				if (dwError == ERROR_SUCCESS) {
					RegDeleteKeyRecursive (hKey, pszSubKeyName);
				}
			}

			// clean up any stragglers

			for (;;) {
				dwSubKeyNameLength = dwMaxSubKeyLength + 1;

				dwError = RegEnumKeyEx (hKey, 0, pszSubKeyName, &dwSubKeyNameLength, NULL, NULL, NULL, NULL);
				if (dwError == ERROR_SUCCESS)
					RegDeleteKeyRecursive (hKey, pszSubKeyName);
				else
					break;
			}

			GlobalFree (pszSubKeyName);
		}
	}

	RegCloseKey (hKey);
	return RegDeleteKey (hParentKey, pszKeyName);
}


#ifdef BACKUP_OLD_KEYS

#ifdef WINNT

PRIVATE
BOOL
EnablePrivilege(
    PTSTR PrivilegeName,
    BOOL  Enable,
    BOOL  *Old

    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges, OldPrivileges; // place for one priv
    LUID Luid;
    DWORD  Length;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY ,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            sizeof(OldPrivileges),  // it has a place for one luid
            &OldPrivileges,
            &Length
            );

    CloseHandle(Token);

    if(b)
    {
        if(OldPrivileges.PrivilegeCount==0)
            *Old = Enable;
        else
            *Old = (OldPrivileges.Privileges[0].Attributes & SE_PRIVILEGE_ENABLED)
                ? TRUE : FALSE;
    }
    else
        DBGOUT((1, "Cannot change SeBackupPrivilege - Error %d", GetLastError()));

    return(b);
}

#endif  // WINNT


PRIVATE
BOOL    
SaveKey(
    HKEY    hKey,
    LPCTSTR pszFileName
    )
{
    DWORD   dwError;
#ifdef WINNT
    BOOL    bOldBackupPriv = FALSE;
#endif

    // Delete the file if exists (ignore errors)
    DeleteFile(pszFileName);

#ifdef WINNT
    // Enable the BACKUP privilege (ignore errors)
    EnablePrivilege(SE_BACKUP_NAME, TRUE, &bOldBackupPriv);
#endif
    // Save the key
    dwError = RegSaveKey(   hKey,
                            pszFileName,
                            NULL
                        );
    if(dwError==ERROR_SUCCESS)
        DBGOUT((9, "Old Telephony key saved")) ;
    else
        DBGOUT((1, "Cannot save old Telephony key - Error %d", dwError));
 
#ifdef WINNT
    // Restore the BACKUP privilege (ignore errors)
    EnablePrivilege(SE_BACKUP_NAME, bOldBackupPriv, &bOldBackupPriv);
#endif

    return (dwError == ERROR_SUCCESS);
}



#endif // BACKUP_OLD_KEYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\thunk\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 4.00                                                  *
*                                                                             *
*               Copyright (c) 1985-1997, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x040A).  To exclude
*                   definitions introduced in version 4.1 (or above)
*                   #define WINVER 0x0300
*                   0x0310 or 0x0400 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
* NOIMT             Installable messge thunk APIs and definitions
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef NOWIN31                      /* ;Internal */
#define WINVER  0x0300              /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* If WINVER is not defined, assume version 4.1 */
#ifndef WINVER
#define WINVER  0x040A
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
//#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Temp internal compatibility hacks */ /* ;Internal */
#define NOOEMRESOURCE               /* ;Internal */
#ifdef OEMRESOURCE                  /* ;Internal */
#undef NOOEMRESOURCE                /* ;Internal */
#endif                              /* ;Internal */
#ifndef NOCOMM
#define NOCOMM                      /* ;Internal */
#endif
#ifdef USECOMM                      /* ;Internal */
#undef NOCOMM                       /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID        void

#define FAR         _far
#define NEAR        _near
#define PASCAL      _pascal
#define CDECL       _cdecl
#define CONST       const                           /* ;Internal */
                                                    /* ;Internal */
#ifdef BUILDDLL                                     /* ;Internal */
#define WINAPI      _loadds _far _pascal            /* ;Internal */
#define CALLBACK    _loadds _far _pascal            /* ;Internal */
/* Note that to use the BUILDDLL version of */      /* ;Internal */
/* WINCAPI, you must compile with -GD       */      /* ;Internal */
#define WINCAPI     _export _far _cdecl             /* ;Internal */
#else                                               /* ;Internal */
#define WINAPI      _far _pascal
#define CALLBACK    _far _pascal
#define WINCAPI     _far _cdecl
#endif                                              /* ;Internal */
                                                    /* ;Internal */
#define API         WINAPI                          /* ;Internal */

/****** Simple types & common helper macros *********************************/

typedef int             BOOL;
#define FALSE           0
#define TRUE            1

typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

typedef WORD            WCHAR;

typedef unsigned int    UINT;

#ifdef STRICT
typedef signed long     LONG;
#else
#define LONG            long
#endif

typedef short           SHORT;
typedef unsigned long   ULONG;

#define LOBYTE(w)       ((BYTE)(w))
#define HIBYTE(w)       ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)       ((WORD)(DWORD)(l))
#define HIWORD(l)       ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high)     ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT            WPARAM;
typedef LONG            LPARAM;
typedef LONG            LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL            0
#endif

typedef char NEAR*      PSTR;
typedef char NEAR*      NPSTR;

#define SZ char                         /* ;Internal */
                                        /* ;Internal */
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;

typedef BYTE NEAR*      PBYTE;
typedef BYTE FAR*       LPBYTE;
typedef const BYTE FAR* LPCBYTE;

typedef int NEAR*       PINT;
typedef int FAR*        LPINT;

typedef WORD NEAR*      PWORD;
typedef WORD FAR*       LPWORD;

typedef long NEAR*      PLONG;
typedef long FAR*       LPLONG;

typedef DWORD NEAR*     PDWORD;
typedef DWORD FAR*      LPDWORD;

typedef void FAR*       LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*         PHANDLE;
typedef HANDLE NEAR*    SPHANDLE;
typedef HANDLE FAR*     LPHANDLE;

typedef HANDLE          HGLOBAL;
typedef HANDLE          HLOCAL;

typedef HANDLE          GLOBALHANDLE;
typedef HANDLE          LOCALHANDLE;

typedef UINT            ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */
typedef DWORD HKL;                                   

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

#if (WINVER >= 0x0400)
typedef struct tagOSVERSIONINFO {
     	DWORD dwOSVersionInfoSize;
     	DWORD dwMajorVersion;
     	DWORD dwMinorVersion;
     	DWORD dwBuildNumber;
     	DWORD dwPlatformId;
	char  szCSDVersion[128];
} OSVERSIONINFO, NEAR *POSVERSIONINFO, FAR *LPOSVERSIONINFO;

#define VER_PLATFORM_WIN32s    		0
#define VER_PLATFORM_WIN32_WINDOWS	1
#define VER_PLATFORM_WIN32_NT		2

BOOL WINAPI GetVersionEx(LPOSVERSIONINFO lpBuffer);

UINT    WINAPI GetProductName(LPSTR, UINT);
#endif  /* WINVER >= 0x0400 */

#if (WINVER >= 0x0400)
#define GFS_PHYSICALRAMSIZE   0x1793
#define GFS_NEARESTMEGRAMSIZE 0x1794
#endif  /* WINVER >= 0x0400 */
DWORD   WINAPI GetFreeSpace(UINT);

UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#define GFSR_VALID             0x0002  /* ;Internal */
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#if (WINVER < 0x030a)
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#endif
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_DOSPAGING    0x1000
#define WF_HASCPUID     0x2000
#define WF_WINNT        0x4000
#define WF_WLO          0x8000
#define WF_CPUMASK      0xFC000000
#define WF_CPU_X86	0
#define WF_CPU_R4000	1
#define WF_CPU_ALPHA	2
#define WF_CPU_CLIPPER	3


LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING     0x8000
#define ERR_PARAM       0x4000

/* Internal error value masks */    /* ;Internal */
#define ERR_TYPE_MASK   0x0fff      /* ;Internal */
#define ERR_FLAGS_MASK  0xc000      /* ;Internal */
                                    /* ;Internal */
#define ERR_SIZE_MASK   0x3000
#define ERR_SIZE_SHIFT  12          /* ;Internal */
#define ERR_BYTE        0x1000
#define ERR_WORD        0x2000
#define ERR_DWORD       0x3000
                                                                        /* ;Internal */
// Error option flags (set by [kernel] ErrorOptions win.ini variable)   /* ;Internal */
                                                                        /* ;Internal */
#define ERO_PARAM_ERROR_BREAK   0x0001                                  /* ;Internal */
#define ERO_BUFFER_FILL         0x0002                                  /* ;Internal */

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE       0x6001
#define ERR_BAD_FLAGS       0x6002
#define ERR_BAD_INDEX       0x6003
#define ERR_BAD_DVALUE      0x7004
#define ERR_BAD_DFLAGS      0x7005
#define ERR_BAD_DINDEX      0x7006
#define ERR_BAD_PTR         0x7007
#define ERR_BAD_FUNC_PTR    0x7008
#define ERR_BAD_SELECTOR    0x6009
#define ERR_BAD_STRING_PTR  0x700a
#define ERR_BAD_HANDLE      0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069
#define ERR_BAD_HDCEMF          0x606A  /* ;Internal */
#define ERR_BAD_HEMF            0x606B  /* ;Internal */
                                        /* ;Internal */
/* Debug fill constants */              /* ;Internal */
                                        /* ;Internal */
#define DBGFILL_ALLOC           0xfd    /* ;Internal */
#define DBGFILL_FREE            0xfb    /* ;Internal */
#define DBGFILL_BUFFER          0xf9    /* ;Internal */
#define DBGFILL_STACK           0xf7    /* ;Internal */

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
#if (WINVER >= 0x0400)
    WORD    chDefRIP;
#endif /* WINVER >= 0x0400 */
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void    WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);                 /* ;Internal */

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS             0x0001
#define WDI_FILTER              0x0002
#define WDI_ALLOCBREAK          0x0004
#define WDI_DEFRIP              0x0008
#define WDI_VALID               0x00015  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP           0x0001
#define DBO_BUFFERFILL          0x0004
#define DBO_DISABLEGPTRAPPING   0x0010
#define DBO_CHECKFREE           0x0020

#define DBO_SILENT              0x8000

#define DBO_TRACEBREAK          0x2000
#define DBO_WARNINGBREAK        0x1000
#define DBO_NOERRORBREAK        0x0800
#define DBO_NOFATALBREAK        0x0400
#define DBO_INT3BREAK           0x0100

/* DebugOutput flags values */
#define DBF_TRACE               0x0000
#define DBF_WARNING             0x4000
#define DBF_ERROR               0x8000
#define DBF_FATAL               0xc000
#define DBF_SEVMASK             0xc000  /* ;Internal */
#define DBF_FILTERMASK          0x3fff  /* ;Internal */

/* dwFilter values */
#define DBF_KERNEL              0x1000
#define DBF_KRN_MEMMAN          0x0001
#define DBF_KRN_LOADMODULE      0x0002
#define DBF_KRN_SEGMENTLOAD     0x0004
#define DBF_USER                0x0800
#define DBF_GDI                 0x0400
#define DBF_MMSYSTEM            0x0040
#define DBF_PENWIN              0x0020
#define DBF_APPLICATION         0x0008
#define DBF_DRIVER              0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42

#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM         0x43
#define EW_EXITANDEXECAPP       0x44   /* ;Internal */
BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

#define EWX_LOGOFF   0      // ;Internal 4.0
#define EWX_SHUTDOWN 1      // ;Internal 4.0
#define EWX_REBOOT   2      // ;Internal 4.0
#define EWX_FORCE    4      // ;Internal 4.0
#define EWX_POWEROFF 8      // ;Internal 4.0
#define EWX_REALLYLOGOFF 0x80000000   // ;Internal 4.0

#if (WINVER >= 0x0400)                              // ;Internal
BOOL    SaveDesktopState(DWORD, DWORD, DWORD);      // ;Internal
#define SAVEDESKTOPSTATEN_EXITWINDOWS 1             // ;Internal
#define SAVEDESKTOPSTATEN_SHUTDOWN    2             // ;Internal
#define SAVEDESKTOPSTATEN_SUSPEND     3             // ;Internal
                                                    // ;Internal
#define SAVEDESKTOPSTATEF_NOPROMPT    1             // ;Internal
#endif /* WINVER >= 0x0400 */                       // ;Internal
                                                    // ;Internal
void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS      0x0001
#define SEM_NOGPFAULTERRORBOX       0x0002
#define SEM_NOALIGNMENTFAULTEXCEPT  0x0004          // ;Internal NT only
#define SEM_NOOPENFILEERRORBOX      0x8000

UINT    WINAPI SetErrorMode(UINT);

#if (WINVER >= 0x0400)
void    WINAPI SetLastError(DWORD);
DWORD   WINAPI GetLastError(void);
#endif /* WINVER >= 0x0400 */


/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);

#if (WINVER >= 0x0400)
void    WINAPI ProfStart32(void);
void    WINAPI ProfStop32(void);
void    WINAPI ProfClear32(void);
void    WINAPI ProfFlush32(void);
void    WINAPI ProfFinish32(void);
#endif /* WINVER >= 0x0400) */
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

LONG    WINAPI GetExpWinVer(HINSTANCE);     /* ;Internal */
                                            /* ;Internal */
HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

#if (WINVER >= 0x0400)					/* ;Internal */
BOOL    WINAPI GetModuleName(HINSTANCE, LPSTR, int);	/* ;Internal */
#endif /* WINVER >= 0x0400 */				/* ;Internal */
							/* ;Internal */
FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE NEAR *, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT    offSegment;
    UINT    cbSegment;
    UINT    flags;
    UINT    cbAlloc;
    HGLOBAL h;
    UINT    alignShift;
    UINT    reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL 0

/****** Task Management *****************************************************/

#endif /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);
int     WINAPI SetPriority(HTASK, int);     /* ;Internal */

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

DWORD   WINAPI GetAppCompatFlags(HTASK);        // ;Internal
                                                // ;Internal
/* GetAppCompatFlags flag values */             // ;Internal
#define GACF_IGNORENODISCARD    0x00000001      // ;Internal
#define GACF_FORCETEXTBAND      0x00000002      // ;Internal
#define GACF_ONELANDGRXBAND     0x00000004      // ;Internal
#define GACF_DISABLEWIDEFONT    0x00000008      // ;Internal new bit for PSCRIPT
#define GACF_CALLTTDEVICE       0x00000010      // ;Internal
#define GACF_MULTIPLEBANDS      0x00000020      // ;Internal
#define GACF_ALWAYSSENDNCPAINT  0x00000040      // ;Internal
#define GACF_PALETTEAPP         0x00000080      // ;Internal
#define GACF_MOREEXTRAWNDWORDS  0x00000100      // ;Internal
#define GACF_TTIGNORERASTERDUPE 0x00000200      // ;Internal
#define GACF_GLOBALHOOKSONLY16  0x00000400      // ;Internal
#define GACF_DELAYHWHNDSHAKECHK 0x00000800      // ;Internal
#define GACF_ENUMHELVNTMSRMN    0x00001000      // ;Internal
#define GACF_ENUMTTNOTDEVICE    0x00002000      // ;Internal
#define GACF_SUBTRACTCLIPSIBS   0x00004000      // ;Internal
#define GACF_FORCETTGRAPHICS    0x00008000      // ;Internal
#define GACF_NOHRGN1            0x00010000      // ;Internal
#define GACF_NCCALCSIZEONMOVE   0x00020000      // ;Internal
#define GACF_SENDMENUDBLCLK     0x00040000      // ;Internal not needed anymore
#define GACF_MODULESPECIFIC     0x00040000      // ;Internal replaces sendmenudblclk
#define GACF_30AVGWIDTH         0x00080000      // ;Internal
#define GACF_GETDEVCAPSNUMLIE   0x00100000      // ;Internal NT only
/* New flags for Win 4.0. */                    // ;Internal
#define GACF_IGNOREDIBWIDTH     0x00100000      // ;Internal re-use GACF_DEVCAPSNUMLIE
#define GACF_WINVER31           0x00200000      // ;Internal
#define GACF_INCREASESTACK      0x00400000      // ;Internal
#define GACF_HEAPSLACK		    0x00400000	    // ;Internal
#define GACF_FAFORCEDRAWBG      0x00400000      // ;Internal Used in FE only
#define GACF_FORCEWIN31DEVMODESIZE   0x00800000      // ;Internal (replaces PEEKMESSAGEIDLE)
#define GACF_31VALIDMASK        0xFFE484AF      // ;Internal
#define GACF_DISABLEFONTASSOC   0x01000000      // ;Internal Used in FE only
#define GACF_JAPANESCAPEMENT    0x01000000      // ;Internal Used in FE only
#define GACF_IGNOREFAULTS	    0x02000000      // ;Internal

#define GACF_DEQUOTIFYCMDLINE	0x02000000	// ;Internal
#define GACF_NOEMFSPOOLING      0x04000000      // ;Internal
#define GACF_RANDOM3XUI         0x08000000      // ;Internal
#define GACF_USEPRINTINGESCAPES 0x00000004      // ;Internal re-use GACF_ONELANDGRXBAND
#define GACF_FORCERASTERMODE    0x00008000      // ;Internal re-use GACF_FORCETTGRAPHICS
#define GACF_FORCEREGPASSTHRU   0x00008000      // ;Internal re-use GACF_FORCERASTERMODE
#define GACF_DONTJOURNALATTACH  0x10000000      // ;Internal
#define GACF_DISABLEDBCSPROPTT  0x20000000      // ;Internal Used in FE only
#define GACF_NOBRUSHCACHE       0x20000000      // ;Internal re-use GACF_DISABLEDBCSPROPTT 
#define GACF_55MSSYSTEMTIMER    0x20000000      // ;Internal re-use GACF_NOBRUSHCACHE since this is just used for some games and is system wide too
#define GACF_MIRRORREGFONTS     0x40000000      // ;Internal
#define GACF_UNUSED3            0x80000000      // ;Internal

/* Module Compatibility flag values */          // ;Internal
#define MCF_FIXEDSEGLOW         0x0001 // ;Internal Win31 behaviour for FIXED segs
#define MCF_MODPATCH            0x0002 // ;Internal has module patches
#define MCF_NODISCARD           0x0004 // ;Internal make all segments in the module not discardable

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED     0x4000
#define GMEM_LOCKCOUNT     0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);
#if (WINVER >= 0x0400)                      
UINT    WINAPI GlobalSmartPageLock(HGLOBAL);
UINT    WINAPI GlobalSmartPageUnlock(HGLOBAL);
#endif /* WINVER >= 0x0400 */		      

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

extern UINT NEAR* PASCAL pLocalHeap;                /* ;Internal */
#define LocalFreeze(dummy)  (*(pLocalHeap+1) += 1)  /* ;Internal */
#define LocalMelt(dummy)    (*(pLocalHeap+1) -= 1)  /* ;Internal */
                                                    /* ;Internal */
#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif
UINT    WINAPI LocalHandleDelta(UINT);              /* ;Internal */

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED     0x4000
#define LMEM_LOCKCOUNT     0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);
                                                                /* ;Internal */
/* LocalNotify callback */                                      /* ;Internal */
#ifdef STRICT                                                   /* ;Internal */
typedef BOOL (CALLBACK* LNOTIFYPROC)(UINT, HLOCAL, void NEAR*); /* ;Internal */
#else                                                           /* ;Internal */
typedef FARPROC LNOTIFYPROC;                                    /* ;Internal */
#endif                                                          /* ;Internal */
                                                                /* ;Internal */
#define LNOTIFY_OUTOFMEM    0                                   /* ;Internal */
#define LNOTIFY_MOVE        1                                   /* ;Internal */
#define LNOTIFY_DISCARD     2                                   /* ;Internal */
                                                                /* ;Internal */
LNOTIFYPROC WINAPI LocalNotify(LNOTIFYPROC);                    /* ;Internal */
                                                                /* ;Internal */
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

#if (WINVER >= 0x0400)
/* OpenFileEx() Structure */
typedef struct tagOFSTRUCTEX
{
    WORD nBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[260];
} OFSTRUCTEX;
typedef OFSTRUCTEX*       POFSTRUCTEX;
typedef OFSTRUCTEX NEAR* NPOFSTRUCTEX;
typedef OFSTRUCTEX FAR*  LPOFSTRUCTEX;
#endif  /* WINVER >= 0x0400 */

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400  /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400  /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
#if (WINVER >= 0x0400)
HFILE   WINAPI OpenFileEx(LPCSTR, OFSTRUCTEX FAR*, UINT);
#endif  /* WINVER >= 0x0400 */

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ                0
#define WRITE               1
#define READ_WRITE          2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long WINAPI _hread(HFILE, void _huge*, long);
long WINAPI _hwrite(HFILE, const void _huge*, long);
#endif /* WINVER >= 0x030a */

UINT    WINAPI DeletePathname(LPCSTR);      /* ;Internal */
                                            /* ;Internal */
#endif /* NOLFILEIO */

#if (WINVER >= 0x0400)
DWORD   WINAPI GetCurrentDirectory(DWORD, LPSTR);
BOOL    WINAPI SetCurrentDirectory(LPCSTR);

#define MAX_PATH 260

#define _FILETIME_
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, NEAR *PFILETIME, FAR *LPFILETIME;

typedef struct _WIN32_FIND_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    char   cFileName[ MAX_PATH ];
    char   cAlternateFileName[ 14 ];
} WIN32_FIND_DATA, NEAR *PWIN32_FIND_DATA, FAR *LPWIN32_FIND_DATA;

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100
#define FILE_ATTRIBUTE_ATOMIC_WRITE     0x00000200
#define FILE_ATTRIBUTE_XACTION_WRITE    0x00000400

DECLARE_HANDLE32(HFINDFILE);
#define INVALID_HFINDFILE       ((HFINDFILE)-1)

HFINDFILE WINAPI FindFirstFile(LPCSTR, LPWIN32_FIND_DATA);
BOOL      WINAPI FindNextFile(HFINDFILE, LPWIN32_FIND_DATA);
BOOL      WINAPI FindClose(HFINDFILE);

DWORD     WINAPI GetFileAttributes(LPCSTR);
BOOL      WINAPI SetFileAttributes(LPCSTR, DWORD);
BOOL      WINAPI GetDiskFreeSpace(LPCSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
BOOL      WINAPI CreateDirectory(LPCSTR, LPVOID);
BOOL      WINAPI RemoveDirectory(LPCSTR);
BOOL      WINAPI DeleteFile(LPCSTR);
#endif /* WINVER >= 0x0400 */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE     (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS          0x0000
#define WN_NOT_SUPPORTED    0x0001
#define WN_NET_ERROR        0x0002
#define WN_MORE_DATA        0x0003
#define WN_BAD_POINTER      0x0004
#define WN_BAD_VALUE        0x0005
#define WN_BAD_PASSWORD     0x0006
#define WN_ACCESS_DENIED    0x0007
#define WN_FUNCTION_BUSY    0x0008
#define WN_WINDOWS_ERROR    0x0009
#define WN_BAD_USER         0x000A
#define WN_OUT_OF_MEMORY    0x000B
#define WN_CANCEL           0x000C
#define WN_CONTINUE         0x000D

/* Connection errors */
#define WN_NOT_CONNECTED    0x0030
#define WN_OPEN_FILES       0x0031
#define WN_BAD_NETNAME      0x0032
#define WN_BAD_LOCALNAME    0x0033
#define WN_ALREADY_CONNECTED    0x0034
#define WN_DEVICE_ERROR         0x0035
#define WN_CONNECTION_CLOSED    0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)     GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR       MAKEINTRESOURCE(1)
#define RT_BITMAP       MAKEINTRESOURCE(2)
#define RT_ICON         MAKEINTRESOURCE(3)
#define RT_MENU         MAKEINTRESOURCE(4)
#define RT_DIALOG       MAKEINTRESOURCE(5)
#define RT_STRING       MAKEINTRESOURCE(6)
#define RT_FONTDIR      MAKEINTRESOURCE(7)
#define RT_FONT         MAKEINTRESOURCE(8)
#define RT_ACCELERATOR  MAKEINTRESOURCE(9)
#define RT_RCDATA       MAKEINTRESOURCE(10)
#define RT_MESSAGETABLE MAKEINTRESOURCE(11)     // reserved: NT   ;Internal
#define RT_GROUP_CURSOR MAKEINTRESOURCE(12)
#define RT_MENUEX       MAKEINTRESOURCE(13)     // RT_MENU subtype   ;Internal
#define RT_GROUP_ICON   MAKEINTRESOURCE(14)
#define RT_NAMETABLE    MAKEINTRESOURCE(15)     // removed in 3.1    ;Internal
#define RT_VERSION      MAKEINTRESOURCE(16)     // reserved: NT   ;Internal
#define RT_DLGINCLUDE   MAKEINTRESOURCE(17)     // reserved: NT   ;Internal
#define RT_DIALOGEX     MAKEINTRESOURCE(18)     // RT_DIALOG subtype ;Internal
#define RT_PLUGPLAY     MAKEINTRESOURCE(19)
#define RT_VXD          MAKEINTRESOURCE(20)
#define RT_LAST         MAKEINTRESOURCE(20)     // ;Internal
#define RT_AFXFIRST     MAKEINTRESOURCE(0xF0)   // reserved: AFX     ;Internal
#define RT_AFXLAST      MAKEINTRESOURCE(0xFF)   // reserved: AFX     ;Internal

#endif  /* NORESOURCE */


#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#if (WINVER >= 0x040A)
#define OBM_RDRVERT         32559
#define OBM_RDRHORZ         32660
#define OBM_RDR2DIM         32661
#endif  /* WINVER >= 0x040A */

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_NWPEN           32631   // ;Internal 4.0
#define OCR_SIZE            32640   /* OBSOLETE; use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE; use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE; use OIC_WINLOGO */
#define OCR_NO              32648
#define OCR_APPSTARTING	    32650   // ;Internal NT 4.0
#if (WINVER >= 0x0400)
#define OCR_HELP            32651   // ;Internal 4.0
#endif  /* WINVER >= 0x400 */

#if (WINVER >= 0x040A)
#define OCR_RDRVERT         32652
#define OCR_RDRHORZ         32653
#define OCR_RDR2DIM         32654
#define OCR_RDRNORTH        32655
#define OCR_RDRSOUTH        32656
#define OCR_RDRWEST         32657
#define OCR_RDREAST         32658
#define OCR_RDRNORTHWEST    32659
#define OCR_RDRNORTHEAST    32660
#define OCR_RDRSOUTHWEST    32661
#define OCR_RDRSOUTHEAST    32662
#endif  /* WINVER >= 0x040A */

/* Default IDs to get original image from User */   // ;Internal
#define OCR_CONFIGURABLE_FIRST  100 // ;Internal
#define OCR_ARROW_DEFAULT       100 // ;Internal
#define OCR_IBEAM_DEFAULT       101 // ;Internal
#define OCR_WAIT_DEFAULT        102 // ;Internal
#define OCR_CROSS_DEFAULT       103 // ;Internal
#define OCR_UPARROW_DEFAULT     104 // ;Internal
#define OCR_SIZENWSE_DEFAULT    105 // ;Internal
#define OCR_SIZENESW_DEFAULT    106 // ;Internal
#define OCR_SIZEWE_DEFAULT      107 // ;Internal
#define OCR_SIZENS_DEFAULT      108 // ;Internal
#define OCR_SIZEALL_DEFAULT     109 // ;Internal
#define OCR_NO_DEFAULT          110 // ;Internal
#define OCR_APPSTARTING_DEFAULT 111 // ;Internal
#define OCR_HELP_DEFAULT        112 // ;Internal
#define OCR_NWPEN_DEFAULT       113 // ;Internal
#define OCR_ICON_DEFAULT        114 // ;Internal
#define OCR_CONFIGURABLE_LAST   OCR_ICON_DEFAULT   // ;Internal
#define COCR_CONFIGURABLE       (OCR_CONFIGURABLE_LAST-OCR_CONFIGURABLE_FIRST+1)    // ;Internal

#define OIC_SAMPLE              32512
#define OIC_ERROR               32513
#define OIC_QUES                32514
#define OIC_WARNING             32515
#define OIC_INFORMATION         32516
#define OIC_WINLOGO             32517   // ;Internal NT

#define OIC_HAND                OIC_ERROR
#define OIC_BANG                OIC_WARNING
#define OIC_NOTE                OIC_INFORMATION

/* Default IDs to get original image from User */   // ;Internal
#define OIC_CONFIGURABLE_FIRST  100 // ;Internal
#define OIC_APPLICATION_DEFAULT 100 // ;Internal
#define OIC_WARNING_DEFAULT     101 // ;Internal
#define OIC_QUESTION_DEFAULT    102 // ;Internal
#define OIC_ERROR_DEFAULT       103 // ;Internal
#define OIC_INFORMATION_DEFAULT 104 // ;Internal
#define OIC_WINLOGO_DEFAULT     105 // ;Internal
#define OIC_CONFIGURABLE_LAST   OIC_WINLOGO_DEFAULT // ;Internal
#define COIC_CONFIGURABLE       (OIC_CONFIGURABLE_LAST-OIC_CONFIGURABLE_FIRST+1)    // ;Internal

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#if (WINVER >= 0x0400)
BOOL    WINAPI GetPrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
BOOL    WINAPI WritePrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
UINT    WINAPI GetProfileSectionNames(LPSTR, UINT);
UINT    WINAPI GetPrivateProfileSectionNames(LPSTR, UINT, LPCSTR);
int     WINAPI GetPrivateProfileSection(LPCSTR, LPSTR, UINT, LPCSTR);
int     WINAPI GetProfileSection(LPCSTR, LPSTR, UINT);
BOOL    WINAPI WritePrivateProfileSection(LPCSTR, LPCSTR, LPCSTR);
BOOL    WINAPI WriteProfileSection(LPCSTR, LPCSTR);
#endif /* WINVER >= 0x0400 */

/****** Registration Database Support ***************************************/
/* return codes from Registration functions */
/* Retained for win 3.x compatibility  and not needed 4.0 onwards */
/* For 4.0 onwards you should be including winerror.h */

#if (WINVER < 0x0400)

#define ERROR_SUCCESS			0L
#define ERROR_BADDB                     1L
#define ERROR_BADKEY			2L
#define ERROR_CANTOPEN			3L
#define ERROR_CANTREAD			4L
#define ERROR_CANTWRITE			5L
#define ERROR_INSUFFICIENT_MEMORY	6L
#define ERROR_INVALID_PARAMETER         7L
#define	ERROR_ACCESS_DENIED		8L

#endif /* WINVER < 0x400 */

#define REG_SZ				0x0001

#if (WINVER >= 0x0400)
#define REG_BINARY			0x0003
#define REG_DWORD                       0x0004
#endif

typedef DWORD HKEY;
typedef HKEY FAR* LPHKEY;

#if (WINVER < 0x0400)		// Win 3.1 compatibility
#define HKEY_CLASSES_ROOT		(( HKEY) 0x1)
#else				// Win 4 upwards
#define HKEY_CLASSES_ROOT		(( HKEY) 0x80000000)
#define HKEY_CURRENT_USER		(( HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE		(( HKEY) 0x80000002)
#define HKEY_USERS			(( HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA		(( HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG		(( HKEY) 0x80000005)
#define HKEY_DYN_DATA			(( HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS		7
#endif

LONG    WINAPI RegOpenKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCreateKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCloseKey(HKEY);
LONG    WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG    WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG    WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG    WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

#if (WINVER >= 0x0400)
LONG    WINAPI RegDeleteValue(HKEY, LPCSTR);
LONG    WINAPI RegEnumValue(HKEY, DWORD, LPCSTR,
                         LONG FAR *, DWORD, LONG FAR *, LPBYTE,
                         LONG FAR *);
LONG    WINAPI RegQueryValueEx(HKEY, LPCSTR, LONG FAR *, LONG FAR *,
			    LPBYTE, LONG FAR *);
LONG    WINAPI RegSetValueEx(HKEY, LPCSTR, DWORD, DWORD, LPBYTE, DWORD);
LONG    WINAPI RegFlushKey(HKEY);
LONG	WINAPI RegSaveKey(HKEY, LPCSTR,LPVOID);
LONG	WINAPI RegLoadKey(HKEY, LPCSTR,LPCSTR);
LONG	WINAPI RegUnLoadKey(HKEY, LPCSTR);

#endif		// WINVER >= 0x0400

/****** International & Char Translation Support ****************************/

//                                                                  ;Internal
// BOOL WINAPI  CharToOem(LPCSTR, LPSTR);               /* NT */ ;Internal
// BOOL WINAPI  OemToChar(LPCSTR, LPSTR);               /* NT */ ;Internal
//                                                                  ;Internal
void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

//                                                                  ;Internal
// BOOL WINAPI  CharToOemBuff(LPCSTR, LPSTR, UINT);     /* NT */ ;Internal
// BOOL WINAPI  OemToCharBuff(LPCSTR, LPSTR, DWORD);    /* NT */ ;Internal
//                                                                  ;Internal
void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

//                                                                  ;Internal
// LPSTR WINAPI CharNext(LPCSTR);                       /* NT */ ;Internal
// LPSTR WINAPI CharPrev(LPCSTR, LPCSTR);               /* NT */ ;Internal
//                                                                  ;Internal
LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

//                                                                  ;Internal
// LPSTR WINAPI CharUpper(LPSTR);                       /* NT */ ;Internal
// LPSTR WINAPI CharLower(LPSTR);                       /* NT */ ;Internal
//                                                                  ;Internal
LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

//                                                                  ;Internal
// LPSTR WINAPI CharUpperBuff(LPSTR, WORD);             /* NT */ ;Internal
// LPSTR WINAPI CharLowerBuff(LPSTR, WORD);             /* NT */ ;Internal
//                                                                  ;Internal
UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

/* Language driver entry point ordinal */   // ;Internal
#define ORD_LANGDRIVER   1                  // ;Internal
                                            // ;Internal
#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, DWORD);
#if (WINVER >= 0x0400)
LPSTR   WINAPI lstrcatn(LPSTR, LPCSTR, int);
#endif /* WINVER >= 0x0400 */
#endif /* WINVER >= 0x030a */
#endif /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

#if (WINVER >= 0x0400)                                  /* ;Internal NT */
#define FORMAT_MESSAGE_ALLOCATE_BUFFER  0x00000100      /* ;Internal NT */
#define FORMAT_MESSAGE_IGNORE_INSERTS   0x00000200      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_STRING      0x00000400      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_HMODULE     0x00000800      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_SYSTEM      0x00001000      /* ;Internal NT */
//#define FORMAT_MESSAGE_ARGUMENT_ARRAY   0x00002000      /* ;Internal */
#define FORMAT_MESSAGE_MAX_WIDTH_MASK   0x000000FF      /* ;Internal NT */
#define FORMAT_MESSAGE_VALID            0x00003FFF      /* ;Internal */
                                                                                    /* ;Internal NT */
UINT FAR PASCAL FormatMessage(DWORD, LPVOID, UINT, UINT, LPSTR, UINT, LPDWORD);     /* ;Internal NT */
#endif /* WINVER >= 0x0400 */                           /* ;Internal NT */

/****** Keyboard Driver Functions *******************************************/


#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
UINT    WINAPI VkKeyScanEx(UINT,HKL);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
UINT    WINAPI MapVirtualKeyEx(UINT,UINT,HKL);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);
int     WINAPI ToAsciiEx(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags,HKL hkl);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;
typedef const RECT FAR * LPCRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;
typedef const POINT FAR * LPCPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)

/* Common structures for 4.X/Win32 GDI APIs */

typedef struct tagPOINTS
{
   SHORT    x;
   SHORT    y;

} POINTS;
typedef POINTS*       PPOINTS;
typedef POINTS NEAR*  NPPOINTS;
typedef POINTS FAR*   LPPOINTS;
typedef const POINTS FAR* LPCPOINTS;

typedef struct tagPOINTL
{
   LONG     x;
   LONG     y;

} POINTL;
typedef POINTL*       PPOINTL;
typedef POINTL NEAR*  NPPOINTL;
typedef POINTL FAR*   LPPOINTL;
typedef const POINTL FAR* LPCPOINTL;

typedef struct tagSIZEL
{
   LONG     cx;
   LONG     cy;

} SIZEL;
typedef SIZEL*       PSIZEL;
typedef SIZEL NEAR*  NPSIZEL;
typedef SIZEL FAR*   LPSIZEL;
typedef const SIZEL FAR* LPCSIZEL;

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
                       
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;
                                                               /* ;Internal */
typedef struct tagXFORM /* SDK transform of IEEE floats. */    /* ;Internal */
{                                                              /* ;Internal */
    float   eM11;                                              /* ;Internal */
    float   eM12;                                              /* ;Internal */
    float   eM21;                                              /* ;Internal */
    float   eM22;                                              /* ;Internal */
    float   eDx;                                               /* ;Internal */
    float   eDy;                                               /* ;Internal */
                                                               /* ;Internal */
} XFORM;                                                       /* ;Internal */
typedef XFORM*       PXFORM;                                   /* ;Internal */
typedef XFORM NEAR*  NPXFORM;                                  /* ;Internal */
typedef XFORM FAR*   LPXFORM;                                  /* ;Internal */
typedef const XFORM FAR* LPCXFORM;                             /* ;Internal */
                                                               /* ;Internal */
#endif /* WINVER >= 0x0400 */

#define MAKEPOINT(l)     (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);
DWORD   WINAPI SetDCOrg(HDC, int, int);    /* ;Internal */

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, LPCRECT lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, LPRECT lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#define DCB_WINDOWMGR   0x8000                              /* ;Internal */
                                                            /* ;Internal */
/* Internal SelectBitmap stuff */                           /* ;Internal */
/*HBITMAP WINAPI SelectBitmap(HDC hDC, HBITMAP hbm);*/      /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90
#define CAPS1         94    // ;Internal

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100
#define CC_POLYBEZIER       0x0200     /* ;Internal */

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080
#define PC_POLYPOLYGON      0x0100
#define PC_PATHS            0x0200

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

/* CAPS1 */                         // ;Internal
#define C1_TRANSPARENT 	    0x0001  // ;Internal 
#define TC_TT_ABLE	        0x0002  // ;Internal
#define C1_TT_CR_ANY	    0x0004  // ;Internal
#define C1_EMF_COMPLIANT    0x0008  // ;Internal
#define C1_DIBENGINE	    0x0010  // ;Internal
#define C1_GAMMA_RAMP	    0x0020  // ;Internal
#define C1_DIC		        0x0040  // ;Internal
#define C1_REINIT_ABLE      0x0080  // ;Internal
#define C1_GLYPH_INDEX      0x0100  // ;Internal
#define C1_BIT_PACKED       0x0200  // ;Internal
#define C1_BYTE_PACKED      0x0400  // ;Internal
#define C1_COLORCURSOR      0x0800  // ;Internal
#define C1_CMYK_ABLE        0x1000  // ;Internal
#define C1_SLOW_CARD        0x2000  // ;Internal

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT         1
#define MM_LOMETRIC     2
#define MM_HIMETRIC     3
#define MM_LOENGLISH    4
#define MM_HIENGLISH    5
#define MM_TWIPS        6
#define MM_ISOTROPIC    7
#define MM_ANISOTROPIC  8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

int     WINAPI SetRelAbs(HDC, int);   /* ;Internal */
int     WINAPI GetRelAbs(HDC);        /* ;Internal */
                                      /* ;Internal */
/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)      ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)  ((BYTE)(rgb))
#define GetGValue(rgb)  ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)  ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

HBRUSH   WINAPI GetSysColorBrush(int);
COLORREF WINAPI GetSysColor(int);
#ifdef tagWND   // ;Internal
BOOL     WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*); // ;Internal
#else           // ;Internal
void     WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);
#endif          // ;Internal

#define COLOR_SCROLLBAR             0
#define COLOR_DESKTOP               1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER          10
#define COLOR_INACTIVEBORDER        11
#define COLOR_APPWORKSPACE          12
#define COLOR_HIGHLIGHT             13
#define COLOR_HIGHLIGHTTEXT         14
#define COLOR_3DFACE                15
#define COLOR_3DSHADOW              16
#define COLOR_GRAYTEXT              17
#define COLOR_BTNTEXT               18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT   19
#define COLOR_3DHILIGHT             20
#if (WINVER >= 0x0400)
#define COLOR_3DDKSHADOW            21
#define COLOR_3DLIGHT               22
#define COLOR_INFOTEXT              23
#define COLOR_INFOBK                24
#if (WINVER >= 0x40A)
#define COLOR_3DALTFACE             25
#define COLOR_HOTLIGHT              26
#define COLOR_GRADIENTACTIVECAPTION     27
#define COLOR_GRADIENTINACTIVECAPTION   28
#define COLOR_ENDCOLORS             COLOR_GRADIENTINACTIVECAPTION   /* ;Internal */
#else                                          // ;Internal 4.1
#define COLOR_ENDCOLORS             COLOR_INFOBK   /* ;Internal */
#endif // (WINVER >= 0x40A)
#define COLOR_MAX                   (COLOR_ENDCOLORS+1) /* ;Internal */
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

#define COLOR_BACKGROUND            COLOR_DESKTOP
#define COLOR_BTNFACE               COLOR_3DFACE
#define COLOR_BTNSHADOW             COLOR_3DSHADOW
#define COLOR_BTNHIGHLIGHT          COLOR_3DHILIGHT


HANDLE WINAPI SetSysColorsTemp(COLORREF FAR *, HBRUSH FAR *, UINT); /* ;Internal */
#endif  /* NOCOLOR */

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);
#define GDIOBJ_PEN        1    /* ;Internal */
#define GDIOBJ_BRUSH      2    /* ;Internal */
#define GDIOBJ_FONT       3    /* ;Internal */
#define GDIOBJ_PALETTE    4    /* ;Internal */
#define GDIOBJ_BITMAP     5    /* ;Internal */
#define GDIOBJ_RGN        6    /* ;Internal */
#define GDIOBJ_DC         7    /* ;Internal */
#define GDIOBJ_IC         8    /* ;Internal */
#define GDIOBJ_DISABLEDDC 9    /* ;Internal */
#define GDIOBJ_METADC    10    /* ;Internal */
#define GDIOBJ_METAFILE  11    /* ;Internal */

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN         1
#define OBJ_BRUSH       2

#if (WINVER >= 0x0400)

HANDLE WINAPI SetObjectOwner(HGDIOBJ, HANDLE);

#endif

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID        0
#define PS_DASH         1
#define PS_DOT          2
#define PS_DASHDOT      3
#define PS_DASHDOTDOT   4
#define PS_NULL         5
#define PS_INSIDEFRAME  6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN       6
#define BLACK_PEN       7
#define NULL_PEN        8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID        0
#define BS_NULL         1
#define BS_HOLLOW       BS_NULL
#define BS_HATCHED      2
#define BS_PATTERN      3
#define BS_INDEXED      4
#define BS_DIBPATTERN   5

/* Hatch Styles */
#define HS_HORIZONTAL   0
#define HS_VERTICAL     1
#define HS_FDIAGONAL    2
#define HS_BDIAGONAL    3
#define HS_CROSS        4
#define HS_DIAGCROSS    5
#define HS_API_MAX      6

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH        PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH    0
#define LTGRAY_BRUSH   1
#define GRAY_BRUSH     2
#define DKGRAY_BRUSH   3
#define BLACK_BRUSH    4
#define NULL_BRUSH     5
#define HOLLOW_BRUSH   NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(LPCPOINT, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(LPCPOINT, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR           0
#define NULLREGION      1
#define SIMPLEREGION    2
#define COMPLEXREGION   3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND         1
#define RGN_OR          2
#define RGN_XOR         3
#define RGN_DIFF        4
#define RGN_COPY        5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, LPRECT);

BOOL    WINAPI RectInRegion(HRGN, LPCRECT);
BOOL    WINAPI PtInRegion(HRGN, int, int);

#if (WINVER >= 0x0400)                                         /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
/* structures for ExtCreateRegion / GetRegionData APIs */      /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
typedef struct tagRGNDATAHEADER {                              /* ;Internal 4.0 */
   DWORD   dwSize;                                             /* ;Internal 4.0 */
   DWORD   iType;                                              /* ;Internal 4.0 */
   DWORD   nCount;                                             /* ;Internal 4.0 */
   DWORD   nRgnSize;                                           /* ;Internal 4.0 */
   RECTL   rcBound;                                            /* ;Internal 4.0 */
} RGNDATAHEADER;                                               /* ;Internal 4.0 */
typedef RGNDATAHEADER*       PRGNDATAHEADER;                   /* ;Internal 4.0 */
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;                  /* ;Internal 4.0 */
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;                  /* ;Internal 4.0 */
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;             /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
typedef struct tagRGNDATA {                                    /* ;Internal 4.0 */
   RGNDATAHEADER   rdh;                                        /* ;Internal 4.0 */
   char            Buffer[1];                                  /* ;Internal 4.0 */
} RGNDATA;                                                     /* ;Internal 4.0 */
typedef RGNDATA*       PRGNDATA;                               /* ;Internal 4.0 */
typedef RGNDATA NEAR*  NPRGNDATA;                              /* ;Internal 4.0 */
typedef RGNDATA FAR*   LPRGNDATA;                              /* ;Internal 4.0 */
typedef const RGNDATA FAR* LPCRGNDATA;                         /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
int     WINAPI ExtSelectClipRgn(HDC, HRGN, int);               /* ;Internal 4.0 */
DWORD   WINAPI GetRegionData(HRGN, DWORD, LPRGNDATA);          /* ;Internal 4.0 */
HRGN    WINAPI ExtCreateRegion(LPCXFORM, DWORD, LPCRGNDATA);   /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
#endif   /* WINVER >= 0x0400 */                                /* ;Internal 4.0 */

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED 0x01 /* palette index used for animation */
#define PC_EXPLICIT 0x02 /* palette index is explicit to device */
#define PC_NOCOLLAPSE 0x04 /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, LPRECT);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, LPCRECT);

#if (WINVER >= 0x030a)                                                  /* ;Internal */
/* DC hook callback function */                                         /* ;Internal */
                                                                        /* ;Internal */
typedef UINT (CALLBACK* DCHOOKPROC)(HDC hDC, UINT code, DWORD data, DWORD lParam); /* ;Internal */
                                                                        /* ;Internal */
BOOL    WINAPI SetDCHook(HDC hDC, DCHOOKPROC lpNewProc, DWORD data);    /* ;Internal */
DWORD   WINAPI GetDCHook(HDC hDC, DCHOOKPROC FAR* lplpproc);            /* ;Internal */
                                                                        /* ;Internal */
/* Callback reason code values */                                       /* ;Internal */
                                                                        /* ;Internal */
#define DCHC_INVALIDVISRGN  0x0001                                      /* ;Internal */
#define DCHC_DELETEDC       0x0002                                      /* ;Internal */
                                                                        /* ;Internal */
UINT WINAPI SetHookFlags(HDC hDC, UINT flags);                          /* ;Internal */
                                                                        /* ;Internal */
#define DCHF_INVALIDATEVISRGN 0x0001                                    /* ;Internal */
#define DCHF_VALIDATEVISRGN   0x0002                                    /* ;Internal */
#endif  /* WINVER >= 0x030a */                                          /* ;Internal */

/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, LPCPOINT, int);

#if (WINVER >= 0x0400)                                  /* ;Internal 4.0 */
BOOL    WINAPI PolyBezier(HDC, LPCPOINT, UINT);         /* ;Internal 4.0 */
BOOL    WINAPI PolyBezierTo(HDC, LPCPOINT, UINT);       /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI AbortPath(HDC);                          /* ;Internal 4.0 */
BOOL    WINAPI BeginPath(HDC);                          /* ;Internal 4.0 */
BOOL    WINAPI CloseFigure(HDC);                        /* ;Internal 4.0 */
BOOL    WINAPI EndPath(HDC);                            /* ;Internal 4.0 */
BOOL    WINAPI FillPath(HDC);                           /* ;Internal 4.0 */
BOOL    WINAPI FlattenPath(HDC);                        /* ;Internal 4.0 */
long    WINAPI GetPath(HDC, LPPOINTL, LPBYTE, long);    /* ;Internal 4.0 */
HRGN    WINAPI PathToRegion(HDC);                       /* ;Internal 4.0 */
BOOL    WINAPI SelectClipPath(HDC, int);                /* ;Internal 4.0 */
BOOL    WINAPI StrokeAndFillPath(HDC);                  /* ;Internal 4.0 */
BOOL    WINAPI StrokePath(HDC);                         /* ;Internal 4.0 */
BOOL    WINAPI WidenPath(HDC);                          /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
#define  PT_CLOSEFIGURE 0x01  /* GetPath byte flags */  /* ;Internal 4.0 */
#define  PT_LINETO      0x02                            /* ;Internal 4.0 */
#define  PT_BEZIERTO    0x04                            /* ;Internal 4.0 */
#define  PT_MOVETO      0x06                            /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                           /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, LPCPOINT, int);
BOOL    WINAPI PolyPolygon(HDC, LPCPOINT, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, LPCRECT, HBRUSH);
int     WINAPI FrameRect(HDC, LPCRECT, HBRUSH);
BOOL    WINAPI InvertRect(HDC, LPCRECT);

void    WINAPI DrawFocusRect(HDC, LPCRECT);
BOOL    WINAPI FastWindowFrame(HDC, LPCRECT, UINT, UINT, DWORD); /* ;Internal */

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, LPCRECT, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004
#define ETO_GLYPH_INDEX 0x0010
#define ETO_RTLREADING	0x0080

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_TOP              0x0000
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000
#define DT_EDITCONTROL      0x00002000
#define DT_PATH_ELLIPSIS    0x00004000  // ;Internal 4.0
#define DT_END_ELLIPSIS     0x00008000  // ;Internal 4.0
#define DT_MODIFYSTRING     0x00010000  // ;Internal 4.0
#define DT_RTLREADING       0x00020000  // ;Internal 4.0
#define DT_WORD_ELLIPSIS    0x00040000  // ;Internal 4.0
#define DT_VALID            0x0007ffff  // ;Internal: Union of all those above

int     WINAPI DrawText(HDC, LPCSTR, int, LPRECT, UINT);

#if (WINVER >= 0x0400)
typedef struct tagDRAWTEXTPARAMS
{
    DWORD   cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
}   DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;

int     WINAPI DrawTextEx(HDC, LPSTR, int, LPRECT, DWORD, LPDRAWTEXTPARAMS);
#endif /* WINVER >= 0x0400 */

#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

/* Monolithic state-drawing routine */

#if (WINVER >= 0x0400)
/* Image type */
#define DST_COMPLEX     0x0000
#define DST_TEXT        0x0001
#define DST_PREFIXTEXT  0x0002
#define DST_TEXTMAX     0x0002  /* ;Internal */
#define DST_ICON        0x0003
#define DST_BITMAP      0x0004
#define DST_GLYPH       0x0005  /* ;Internal */
#define DST_TYPEMASK    0x0007  /* ;Internal */
#define DST_GRAYSTRING  0x0008  /* ;Internal */

/* State type */
#define DSS_NORMAL      0x0000
#define DSS_UNION       0x0010  /* Old gray string appearance */
#define DSS_DISABLED    0x0020
#define DSS_DEFAULT     0x0040  // ;Internal BOGUS GOING AWAY
#define DSS_MONO        0x0080
#define DSS_INACTIVE    0x0100  // ;Internal
#define DSS_RIGHT 		0x8000

#ifdef STRICT
typedef BOOL (CALLBACK* DRAWSTATEPROC)(HDC, LPARAM, WPARAM, int, int);
#else
typedef FARPROC DRAWSTATEPROC;
#endif
BOOL    WINAPI DrawState(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
#endif /* WINVER >= 0x0400 */

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2
#define TRANSPARENT1    3           /* ;Internal */

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP   0x0000
#define TA_UPDATECP     0x0001
#define TA_LEFT         0x0000
#define TA_RIGHT        0x0002
#define TA_CENTER       0x0006
#define TA_TOP          0x0000
#define TA_BOTTOM       0x0008
#define TA_BASELINE     0x0018
#define TA_RTLREADING   0x0100

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

/* Logical Font */
#define LF_FACESIZE     32

#ifndef NOGDIOBJ
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE     0
#define FW_THIN         100
#define FW_EXTRALIGHT   200
#define FW_LIGHT        300
#define FW_NORMAL       400
#define FW_MEDIUM       500
#define FW_SEMIBOLD     600
#define FW_BOLD         700
#define FW_EXTRABOLD    800
#define FW_HEAVY        900

#define FW_ULTRALIGHT   FW_EXTRALIGHT
#define FW_REGULAR      FW_NORMAL
#define FW_DEMIBOLD     FW_SEMIBOLD
#define FW_ULTRABOLD    FW_EXTRABOLD
#define FW_BLACK        FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#if (WINVER >= 0x0400)
#define	MAC_CHARSET         77
#endif /* WINVER >= 0x0400 */
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define JOHAB_CHARSET       130
#define GB2312_CHARSET      134
#define CHINESEBIG5_CHARSET 136
#define GREEK_CHARSET		 161
#define TURKISH_CHARSET		 162
#define HEBREW_CHARSET		 177
#define ARABIC_CHARSET		 178
#define BALTIC_CHARSET      186
#define RUSSIAN_CHARSET		 204
#define THAI_CHARSET			 222
#define EASTEUROPE_CHARSET	 238
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2
#if (WINVER >= 0x400)
#define NONANTIALIASED_QUALITY  3
#define ANTIALIASED_QUALITY     4
#endif  /* WINVER >= 0x400 */

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02
#if (WINVER >= 0x400)
#define MONO_FONT           0x08
#endif

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16
#define DEFAULT_GUI_FONT    17

DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING    0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define GCP_DBCS           0x0001
#define GCP_REORDER        0x0002
#define GCP_USEKERNING     0x0008
#define GCP_GLYPHSHAPE     0x0010
#define GCP_LIGATE         0x0020
///#define GCP_GLYPHINDEXING  0x0080
#define GCP_DIACRITIC      0x0100
#define GCP_KASHIDA        0x0400
#define GCP_ERROR          0x8000
#define FLI_MASK           0x103B

#define GCP_JUSTIFY        0x00010000L
//#define GCP_NODIACRITICS   0x00020000L
#define FLI_GLYPHS         0x00040000L
#define GCP_CLASSIN        0x00080000L	
#define GCP_MAXEXTENT      0x00100000L
#define GCP_JUSTIFYIN		 0x00200000L
#define GCP_DISPLAYZWG      0x00400000L
#define GCP_SYMSWAPOFF      0x00800000L
#define GCP_NUMERICOVERRIDE 0x01000000L
#define GCP_NEUTRALOVERRIDE 0x02000000L
#define GCP_NUMERICSLATIN   0x04000000L
#define GCP_NUMERICSLOCAL   0x08000000L

#define GCPCLASS_LATIN                  1
#define GCPCLASS_HEBREW                 2
#define GCPCLASS_ARABIC                 2
#define GCPCLASS_NEUTRAL                3
#define GCPCLASS_LOCALNUMBER            4
#define GCPCLASS_LATINNUMBER            5
#define GCPCLASS_LATINNUMERICTERMINATOR 6
#define GCPCLASS_LATINNUMERICSEPARATOR  7
#define GCPCLASS_NUMERICSEPARATOR       8

#define GCPCLASS_PREBOUNDLTR		0x80
#define GCPCLASS_PREBOUNDRTL		0x40
#define GCPCLASS_POSTBOUNDLTR		0x20
#define GCPCLASS_POSTBOUNDRTL		0x10

#define GCPGLYPH_LINKBEFORE		0x8000
#define GCPGLYPH_LINKAFTER			0x4000

typedef struct 
	{
	DWORD 	lStructSize;
	LPSTR 	lpOutString;
	UINT FAR *lpOrder;
	int FAR  *lpDx;
	int FAR  *lpCaretPos; 
    LPSTR     lpClass;
	UINT FAR *lpGlyphs;
	UINT   	nGlyphs;    
	int		nMaxFit;
	} GCP_RESULTS, FAR* LPGCP_RESULTS;

DWORD WINAPI GetFontLanguageInfo( HDC );
DWORD WINAPI GetCharacterPlacement(HDC, LPCSTR, int, int, LPGCP_RESULTS, DWORD);
int     WINAPI GetTextFace(HDC, int, LPSTR);
int		WINAPI GetTextCharset(HDC);					 /* ;Internal 4.0 */

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif /* NOGDIOBJ */


typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;


#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_VARIABLE_PITCH 0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08

/*
 * Yes, this looks bogus.  But it's because we got confused and named the
 * flag wrong.  LOGFONTs have an lfPitchAndFamily field, where FIXED_PITCH
 * is 0x01.  But TEXTMETRICs have a tmPitchAndFamily field, where
 * VARIABLE_PITCH is 0x01.  It's easy to confuse the two.  We're sorry.
*/
#define TMPF_FIXED_PITCH    TMPF_VARIABLE_PITCH

#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x0400)

#define PANOSE_COUNT               10
#define PAN_FAMILYTYPE_INDEX        0
#define PAN_SERIFSTYLE_INDEX        1
#define PAN_WEIGHT_INDEX            2
#define PAN_PROPORTION_INDEX        3
#define PAN_CONTRAST_INDEX          4
#define PAN_STROKEVARIATION_INDEX   5
#define PAN_ARMSTYLE_INDEX          6
#define PAN_LETTERFORM_INDEX        7
#define PAN_MIDLINE_INDEX           8
#define PAN_XHEIGHT_INDEX           9

#define PAN_CULTURE_LATIN           0

#define PAN_ANY                         0 /* Any                            */
#define PAN_NO_FIT                      1 /* No Fit                         */

#define PAN_FAMILY_TEXT_DISPLAY         2 /* Text and Display               */
#define PAN_FAMILY_SCRIPT               3 /* Script                         */
#define PAN_FAMILY_DECORATIVE           4 /* Decorative                     */
#define PAN_FAMILY_PICTORIAL            5 /* Pictorial                      */

#define PAN_SERIF_COVE                  2 /* Cove                           */
#define PAN_SERIF_OBTUSE_COVE           3 /* Obtuse Cove                    */
#define PAN_SERIF_SQUARE_COVE           4 /* Square Cove                    */
#define PAN_SERIF_OBTUSE_SQUARE_COVE    5 /* Obtuse Square Cove             */
#define PAN_SERIF_SQUARE                6 /* Square                         */
#define PAN_SERIF_THIN                  7 /* Thin                           */
#define PAN_SERIF_BONE                  8 /* Bone                           */
#define PAN_SERIF_EXAGGERATED           9 /* Exaggerated                    */
#define PAN_SERIF_TRIANGLE             10 /* Triangle                       */
#define PAN_SERIF_NORMAL_SANS          11 /* Normal Sans                    */
#define PAN_SERIF_OBTUSE_SANS          12 /* Obtuse Sans                    */
#define PAN_SERIF_PERP_SANS            13 /* Prep Sans                      */
#define PAN_SERIF_FLARED               14 /* Flared                         */
#define PAN_SERIF_ROUNDED              15 /* Rounded                        */

#define PAN_WEIGHT_VERY_LIGHT           2 /* Very Light                     */
#define PAN_WEIGHT_LIGHT                3 /* Light                          */
#define PAN_WEIGHT_THIN                 4 /* Thin                           */
#define PAN_WEIGHT_BOOK                 5 /* Book                           */
#define PAN_WEIGHT_MEDIUM               6 /* Medium                         */
#define PAN_WEIGHT_DEMI                 7 /* Demi                           */
#define PAN_WEIGHT_BOLD                 8 /* Bold                           */
#define PAN_WEIGHT_HEAVY                9 /* Heavy                          */
#define PAN_WEIGHT_BLACK               10 /* Black                          */
#define PAN_WEIGHT_NORD                11 /* Nord                           */

#define PAN_PROP_OLD_STYLE              2 /* Old Style                      */
#define PAN_PROP_MODERN                 3 /* Modern                         */
#define PAN_PROP_EVEN_WIDTH             4 /* Even Width                     */
#define PAN_PROP_EXPANDED               5 /* Expanded                       */
#define PAN_PROP_CONDENSED              6 /* Condensed                      */
#define PAN_PROP_VERY_EXPANDED          7 /* Very Expanded                  */
#define PAN_PROP_VERY_CONDENSED         8 /* Very Condensed                 */
#define PAN_PROP_MONOSPACED             9 /* Monospaced                     */

#define PAN_CONTRAST_NONE               2 /* None                           */
#define PAN_CONTRAST_VERY_LOW           3 /* Very Low                       */
#define PAN_CONTRAST_LOW                4 /* Low                            */
#define PAN_CONTRAST_MEDIUM_LOW         5 /* Medium Low                     */
#define PAN_CONTRAST_MEDIUM             6 /* Medium                         */
#define PAN_CONTRAST_MEDIUM_HIGH        7 /* Mediim High                    */
#define PAN_CONTRAST_HIGH               8 /* High                           */
#define PAN_CONTRAST_VERY_HIGH          9 /* Very High                      */

#define PAN_STROKE_GRADUAL_DIAG         2 /* Gradual/Diagonal               */
#define PAN_STROKE_GRADUAL_TRAN         3 /* Gradual/Transitional           */
#define PAN_STROKE_GRADUAL_VERT         4 /* Gradual/Vertical               */
#define PAN_STROKE_GRADUAL_HORZ         5 /* Gradual/Horizontal             */
#define PAN_STROKE_RAPID_VERT           6 /* Rapid/Vertical                 */
#define PAN_STROKE_RAPID_HORZ           7 /* Rapid/Horizontal               */
#define PAN_STROKE_INSTANT_VERT         8 /* Instant/Vertical               */

#define PAN_STRAIGHT_ARMS_HORZ          2 /* Straight Arms/Horizontal       */
#define PAN_STRAIGHT_ARMS_WEDGE         3 /* Straight Arms/Wedge            */
#define PAN_STRAIGHT_ARMS_VERT          4 /* Straight Arms/Vertical         */
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF  5 /* Straight Arms/Single-Serif     */
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF  6 /* Straight Arms/Double-Serif     */
#define PAN_BENT_ARMS_HORZ              7 /* Non-Straight Arms/Horizontal   */
#define PAN_BENT_ARMS_WEDGE             8 /* Non-Straight Arms/Wedge        */
#define PAN_BENT_ARMS_VERT              9 /* Non-Straight Arms/Vertical     */
#define PAN_BENT_ARMS_SINGLE_SERIF     10 /* Non-Straight Arms/Single-Serif */
#define PAN_BENT_ARMS_DOUBLE_SERIF     11 /* Non-Straight Arms/Double-Serif */

#define PAN_LETT_NORMAL_CONTACT         2 /* Normal/Contact                 */
#define PAN_LETT_NORMAL_WEIGHTED        3 /* Normal/Weighted                */
#define PAN_LETT_NORMAL_BOXED           4 /* Normal/Boxed                   */
#define PAN_LETT_NORMAL_FLATTENED       5 /* Normal/Flattened               */
#define PAN_LETT_NORMAL_ROUNDED         6 /* Normal/Rounded                 */
#define PAN_LETT_NORMAL_OFF_CENTER      7 /* Normal/Off Center              */
#define PAN_LETT_NORMAL_SQUARE          8 /* Normal/Square                  */
#define PAN_LETT_OBLIQUE_CONTACT        9 /* Oblique/Contact                */
#define PAN_LETT_OBLIQUE_WEIGHTED      10 /* Oblique/Weighted               */
#define PAN_LETT_OBLIQUE_BOXED         11 /* Oblique/Boxed                  */
#define PAN_LETT_OBLIQUE_FLATTENED     12 /* Oblique/Flattened              */
#define PAN_LETT_OBLIQUE_ROUNDED       13 /* Oblique/Rounded                */
#define PAN_LETT_OBLIQUE_OFF_CENTER    14 /* Oblique/Off Center             */
#define PAN_LETT_OBLIQUE_SQUARE        15 /* Oblique/Square                 */

#define PAN_MIDLINE_STANDARD_TRIMMED    2 /* Standard/Trimmed               */
#define PAN_MIDLINE_STANDARD_POINTED    3 /* Standard/Pointed               */
#define PAN_MIDLINE_STANDARD_SERIFED    4 /* Standard/Serifed               */
#define PAN_MIDLINE_HIGH_TRIMMED        5 /* High/Trimmed                   */
#define PAN_MIDLINE_HIGH_POINTED        6 /* High/Pointed                   */
#define PAN_MIDLINE_HIGH_SERIFED        7 /* High/Serifed                   */
#define PAN_MIDLINE_CONSTANT_TRIMMED    8 /* Constant/Trimmed               */
#define PAN_MIDLINE_CONSTANT_POINTED    9 /* Constant/Pointed               */
#define PAN_MIDLINE_CONSTANT_SERIFED   10 /* Constant/Serifed               */
#define PAN_MIDLINE_LOW_TRIMMED        11 /* Low/Trimmed                    */
#define PAN_MIDLINE_LOW_POINTED        12 /* Low/Pointed                    */
#define PAN_MIDLINE_LOW_SERIFED        13 /* Low/Serifed                    */

#define PAN_XHEIGHT_CONSTANT_SMALL      2 /* Constant/Small                 */
#define PAN_XHEIGHT_CONSTANT_STD        3 /* Constant/Standard              */
#define PAN_XHEIGHT_CONSTANT_LARGE      4 /* Constant/Large                 */
#define PAN_XHEIGHT_DUCKING_SMALL       5 /* Ducking/Small                  */
#define PAN_XHEIGHT_DUCKING_STD         6 /* Ducking/Standard               */
#define PAN_XHEIGHT_DUCKING_LARGE       7 /* Ducking/Large                  */

#endif   /* WINVER >= 0x0400 */

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* NOSCALABLEFONT */
#endif  /* WINVER >= 0x030a */


#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR 0x00000040L
#define NTM_BOLD 0x00000020L
#define NTM_ITALIC 0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
#if (WINVER >= 0x0400)
    char    elfScript[LF_FACESIZE];
#endif
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);
int     WINAPI EnumFontFamiliesEx(HDC, LPLOGFONT, FONTENUMPROC, LPARAM,DWORD);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI ConvertOutlineFontFile(LPCSTR, LPCSTR, LPCSTR);  /* ;Internal */
DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2
#if (WINVER >= 0x0400)
#define	GGO_GRAY2_BITMAP   4
#define	GGO_GRAY4_BITMAP   5
#define	GGO_GRAY8_BITMAP   6
#endif /* WINVER >= 0x0400 */


#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef UINT FAR* LPFONTDIR;                               /* ;Internal */
                                                           /* ;Internal */
DWORD   WINAPI EngineMakeFontDir(HDC, LPFONTDIR, LPCSTR);  /* ;Internal */
                                                           /* ;Internal */
typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE 0x0001
#define TT_ENABLED 0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB       0L
#define BI_RLE8      1L
#define BI_RLE4      2L
#define BI_BITFIELDS 3L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD      bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE      bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

/* Pel Array */                             /* ;Internal */
typedef struct tagPELARRAY                  /* ;Internal */
{                                           /* ;Internal */
    int     paXCount;                       /* ;Internal */
    int     paYCount;                       /* ;Internal */
    int     paXExt;                         /* ;Internal */
    int     paYExt;                         /* ;Internal */
    BYTE    paRGBs;                         /* ;Internal */
} PELARRAY;                                 /* ;Internal */
typedef PELARRAY*       PPELARRAY;          /* ;Internal */
typedef PELARRAY NEAR* NPPELARRAY;          /* ;Internal */
typedef PELARRAY FAR*  LPPELARRAY;          /* ;Internal */
                                            /* ;Internal */
HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

#if (WINVER >= 0x0400)                                                      /* ;Internal 4.0 */
HBITMAP WINAPI CreateDIBSection(HDC, CONST BITMAPINFO FAR*, UINT, LPVOID FAR*, DWORD, DWORD); /* ;Internal 4.0 */
UINT    WINAPI SetDIBColorTable(HDC, UINT, UINT, const RGBQUAD FAR *);      /* ;Internal 4.0 */
UINT    WINAPI GetDIBColorTable(HDC, UINT, UINT, LPRGBQUAD);                /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                                               /* ;Internal 4.0 */
                                                                            /* ;Internal 4.0 */
#ifdef tagWND       // ;Internal
HBITMAP WINAPI OwnerLoadBitmap(HINSTANCE, LPCSTR, HANDLE);  // ;Internal
#else               // ;Internal
HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);
#endif              // ;Internal

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATOR               0x00FA0089L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L
#define SRCSTENCIL          0x00B8074AL
#define SRCINVSTENCIL       0x00E20746L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE 1
#define WHITEONBLACK 2
#define COLORONCOLOR 3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

//                                              ;Internal
// #define HALFTONE            4   /* NT */  ;Internal
// #define STRETCH_HALFSCANS   4   /* NT */  ;Internal
//                                              ;Internal

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR             0x0201
#define META_SETBKMODE              0x0102
#define META_SETMAPMODE             0x0103
#define META_SETROP2                0x0104
#define META_SETRELABS              0x0105
#define META_SETPOLYFILLMODE        0x0106
#define META_SETSTRETCHBLTMODE      0x0107
#define META_SETTEXTCHAREXTRA       0x0108
#define META_SETTEXTCOLOR           0x0209
#define META_SETTEXTJUSTIFICATION   0x020A
#define META_SETWINDOWORG           0x020B
#define META_SETWINDOWEXT           0x020C
#define META_SETVIEWPORTORG         0x020D
#define META_SETVIEWPORTEXT         0x020E
#define META_OFFSETWINDOWORG        0x020F
#define META_SCALEWINDOWEXT         0x0410
#define META_OFFSETVIEWPORTORG      0x0211
#define META_SCALEVIEWPORTEXT       0x0412
#define META_LINETO                 0x0213
#define META_MOVETO                 0x0214
#define META_EXCLUDECLIPRECT        0x0415
#define META_INTERSECTCLIPRECT      0x0416
#define META_ARC                    0x0817
#define META_ELLIPSE                0x0418
#define META_FLOODFILL              0x0419
#define META_PIE                    0x081A
#define META_RECTANGLE              0x041B
#define META_ROUNDRECT              0x061C
#define META_PATBLT                 0x061D
#define META_SAVEDC                 0x001E
#define META_SETPIXEL               0x041F
#define META_OFFSETCLIPRGN          0x0220
#define META_TEXTOUT                0x0521
#define META_BITBLT                 0x0922
#define META_STRETCHBLT             0x0B23
#define META_POLYGON                0x0324
#define META_POLYLINE               0x0325
#define META_ESCAPE                 0x0626
#define META_RESTOREDC              0x0127
#define META_FILLREGION             0x0228
#define META_FRAMEREGION            0x0429
#define META_INVERTREGION           0x012A
#define META_PAINTREGION            0x012B
#define META_SELECTCLIPREGION       0x012C
#define META_SELECTOBJECT           0x012D
#define META_SETTEXTALIGN           0x012E
#define META_DRAWTEXT               0x062F

#define META_CHORD                  0x0830
#define META_SETMAPPERFLAGS         0x0231
#define META_EXTTEXTOUT             0x0a32
#define META_SETDIBTODEV            0x0d33
#define META_SELECTPALETTE          0x0234
#define META_REALIZEPALETTE         0x0035
#define META_ANIMATEPALETTE         0x0436
#define META_SETPALENTRIES          0x0037
#define META_POLYPOLYGON            0x0538
#define META_RESIZEPALETTE          0x0139

#define META_DIBBITBLT              0x0940
#define META_DIBSTRETCHBLT          0x0b41
#define META_DIBCREATEPATTERNBRUSH  0x0142
#define META_STRETCHDIB             0x0f43

#define META_EXTFLOODFILL           0x0548

#define META_RESETDC                0x014C
#define META_STARTDOC               0x014D
#define META_STARTPAGE              0x004F
#define META_ENDPAGE                0x0050
#define META_ABORTDOC               0x0052
#define META_ENDDOC                 0x005E

#define META_DELETEOBJECT           0x01f0

#define META_CREATEPALETTE          0x00f7
#define META_CREATEBRUSH            0x00F8
#define META_CREATEPATTERNBRUSH     0x01F9
#define META_CREATEPENINDIRECT      0x02FA
#define META_CREATEFONTINDIRECT     0x02FB
#define META_CREATEBRUSHINDIRECT    0x02FC
#define META_CREATEBITMAPINDIRECT   0x02FD
#define META_CREATEBITMAP           0x06FE
#define META_CREATEREGION           0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Enhanced Metafile support *******************************************/               /* ;Internal 4.0 */
#if ((WINVER >= 0x0400) && !defined(NOGDI) && !defined(NOMETAFILE))                          /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef struct tagMRMETAFILE                                                                 /* ;Internal 4.0 */
{                                                                                            /* ;Internal 4.0 */
   DWORD    iType;                                                                           /* ;Internal 4.0 */
   DWORD    nSize;                                                                           /* ;Internal 4.0 */
   RECTL    rclBounds;                                                                       /* ;Internal 4.0 */
   RECTL    rclFrame;                                                                        /* ;Internal 4.0 */
   DWORD    dSignature;                                                                      /* ;Internal 4.0 */
   DWORD    nVersion;                                                                        /* ;Internal 4.0 */
   DWORD    nBytes;                                                                          /* ;Internal 4.0 */
   DWORD    nRecords;                                                                        /* ;Internal 4.0 */
   WORD     nHandles;                                                                        /* ;Internal 4.0 */
   WORD     sReserved;                                                                       /* ;Internal 4.0 */
   DWORD    nDescription;                                                                    /* ;Internal 4.0 */
   DWORD    offDescription;                                                                  /* ;Internal 4.0 */
   DWORD    nPalEntries;                                                                     /* ;Internal 4.0 */
   SIZEL    szlDevice;                                                                       /* ;Internal 4.0 */
   SIZEL    szlMillimeters;                                                                  /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
} MRMETAFILE, NEAR* PMRMETAFILE, FAR* LPMRMETAFILE;                                          /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef struct tagENHMETARECORD                                                              /* ;Internal 4.0 */
{                                                                                            /* ;Internal 4.0 */
    DWORD   iType;                                                                           /* ;Internal 4.0 */
    DWORD   nSize;                                                                           /* ;Internal 4.0 */
    DWORD   dParm[1];                                                                        /* ;Internal 4.0 */
} ENHMETARECORD, NEAR* PENHMETARECORD, FAR* LPENHMETARECORD;                                 /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
/* MRMETAFILE constants */                                                                   /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
#define ENHMETA_SIGNATURE        0x464D4520     /* Mandatory signature. */                   /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
/* Stock object flag used in the object handle index in the enhanced */                      /* ;Internal 4.0 */
/* metafile records. */                                                                      /* ;Internal 4.0 */
/* E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH) */                         /* ;Internal 4.0 */
/* represents the stock object BLACK_BRUSH. */                                               /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
#define ENHMETA_STOCK_OBJECT    0x80000000L                                                  /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef HANDLE HENHMETAFILE;                                                                 /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef LONG   INT32;   /* Signed or unsigned integers under NT which must */                /* ;Internal 4.0 */
typedef ULONG  UINT32;  /* always remain 32-bits under Chicago.            */                /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef INT32 (CALLBACK* ENHMFENUMPROC)(HDC, LPHANDLETABLE, LPENHMETARECORD, INT32, LPARAM); /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
/* Enhanced metafile APIs */                                                                 /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
HENHMETAFILE  WINAPI CloseEnhMetaFile(HDC);                                                  /* ;Internal 4.0 */
HENHMETAFILE  WINAPI CopyEnhMetaFile(HENHMETAFILE, LPCSTR);                                  /* ;Internal 4.0 */
HDC   WINAPI CreateEnhMetaFile(HDC, LPCSTR, LPCRECTL, LPCSTR);                               /* ;Internal 4.0 */
BOOL  WINAPI DeleteEnhMetaFile(HENHMETAFILE);                                                /* ;Internal 4.0 */
BOOL  WINAPI EnumEnhMetaFile(HDC, HENHMETAFILE, ENHMFENUMPROC, LPVOID, LPCRECTL);            /* ;Internal 4.0 */
BOOL  WINAPI GdiComment(HDC, UINT32, LPBYTE);                                                /* ;Internal 4.0 */
HENHMETAFILE  WINAPI GetEnhMetaFile(LPCSTR);                                                 /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFileBits(HENHMETAFILE, UINT32, LPBYTE);                              /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFileDescription(HENHMETAFILE, UINT32, LPSTR);                        /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFileHeader(HENHMETAFILE, UINT32, LPMRMETAFILE);                      /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFilePaletteEntries(HENHMETAFILE, UINT32, LPPALETTEENTRY);            /* ;Internal 4.0 */
UINT32 WINAPI GetWinMetaFileBits(HENHMETAFILE, UINT32, LPBYTE, int, HDC);                    /* ;Internal 4.0 */
BOOL  WINAPI PlayEnhMetaFile(HDC, HENHMETAFILE, LPCRECTL);                                   /* ;Internal 4.0 */
BOOL  WINAPI PlayEnhMetaFileRecord(HDC, LPHANDLETABLE, LPENHMETARECORD, UINT32);             /* ;Internal 4.0 */
HENHMETAFILE  WINAPI SetEnhMetaFileBits(UINT32, LPCBYTE);                                    /* ;Internal 4.0 */
HENHMETAFILE  WINAPI SetWinMetaFileBits(UINT32, LPBYTE, HDC, LPMETAFILEPICT);                /* ;Internal 4.0 */
int   WINAPI SetMetaRgn(HDC);                                                                /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
#endif   /* WINVER >= 0x0400 etc. */                                                         /* ;Internal 4.0 */
/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

int WINAPI SetAbortProc(HDC, ABORTPROC);

HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL    WINAPI QueryJob(HANDLE, int);           /* ;Internal */

#endif  /* WINVER >= 0x030a */

typedef struct {
    short   cbSize;
    LPSTR   lpszDocName;
    LPSTR   lpszOutput;
    LPSTR   lpszDatatype;
    DWORD   fwType;
    }   DOCINFO, FAR * LPDOCINFO;

/* bit flags for DOCINFO.fwType */
#define DI_APPBANDING       0x0001
#define DI_ROPS_READ_DESTINATION   0x0002  // ;will use rops that read destination 
                                           // ;pixel values to print the doc. 
                                           // ;Ex: R2_XORPEN, PATINVERT (DPx).

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);
BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED      0x4000
#define SP_ERROR            (-1)
#define SP_APPABORT         (-2)
#define SP_USERABORT        (-3)
#define SP_OUTOFDISK        (-4)
#define SP_OUTOFMEMORY      (-5)

#define PR_JOBSTATUS        0x0000

#endif  /* NOGDI  */

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                1
#define ABORTDOC                2
#define NEXTBAND                3
#define SETCOLORTABLE           4
#define GETCOLORTABLE           5
#define FLUSHOUTPUT             6
#define DRAFTMODE               7
#define QUERYESCSUPPORT         8
#define SETABORTPROC            9
#define STARTDOC                10
#define ENDDOC                  11
#define GETPHYSPAGESIZE         12
#define GETPRINTINGOFFSET       13
#define GETSCALINGFACTOR        14
#define MFCOMMENT               15
#define GETPENWIDTH             16
#define SETCOPYCOUNT            17
#define SELECTPAPERSOURCE       18
#define DEVICEDATA              19
#define PASSTHROUGH             19
#define GETTECHNOLGY            20
#define GETTECHNOLOGY           20
#define SETLINECAP              21
#define SETLINEJOIN             22
#define SETMITERLIMIT           23
#define BANDINFO                24
#define DRAWPATTERNRECT         25
#define GETVECTORPENSIZE        26
#define GETVECTORBRUSHSIZE      27
#define ENABLEDUPLEX            28
#define GETSETPAPERBINS         29
#define GETSETPRINTORIENT       30
#define ENUMPAPERBINS           31
#define SETDIBSCALING           32
#define EPSPRINTING             33
#define ENUMPAPERMETRICS        34
#define GETSETPAPERMETRICS      35
#define POSTSCRIPT_DATA         37
#define POSTSCRIPT_IGNORE       38
#define MOUSETRAILS             39

#define GETEXTENDEDTEXTMETRICS  256
#define GETEXTENTTABLE          257
#define GETPAIRKERNTABLE        258
#define GETTRACKKERNTABLE       259
#define EXTTEXTOUT              512
#define GETFACENAME             513
#define ENABLERELATIVEWIDTHS    768
#define ENABLEPAIRKERNING       769
#define SETKERNTRACK            770
#define SETALLJUSTVALUES        771
#define SETCHARSET              772

#define STRETCHBLT              2048
#define GETSETSCREENPARAMS      3072
#define QUERYDIBSUPPORT         3073
#define QDI_SETDIBITS           0x0001
#define QDI_GETDIBITS           0x0002
#define QDI_DIBTOSCREEN         0x0004
#define QDI_STRETCHDIB          0x0008

#define BEGIN_PATH              4096
#define CLIP_TO_PATH            4097
#define END_PATH                4098
#define EXT_DEVICE_CAPS         4099
#define RESTORE_CTM             4100
#define SAVE_CTM                4101
#define SET_ARC_DIRECTION       4102
#define SET_BACKGROUND_COLOR    4103
#define SET_POLY_MODE           4104
#define SET_SCREEN_ANGLE        4105
#define SET_SPREAD              4106
#define TRANSFORM_CTM           4107
#define SET_CLIP_BOX            4108
#define SET_BOUNDS              4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

#ifdef tagWND                               // ;Internal
#define BASED __based32(__segname("_DATA")) // ;Internal
#ifdef DEBUG                                // ;Internal
#define HWND  HWND_16                       // ;Internal
#define HWNDC HWND_16                       // ;Internal
#else                                       // ;Internal
typedef struct tagWND BASED *HWND;          // ;Internal
typedef HWND HWNDC;                         // ;Internal
#endif                                      // ;Internal
typedef UINT HWND_16;                       // ;Internal
#else                                       // ;Internal
DECLARE_HANDLE(HWND);
#endif                                      // ;Internal

#ifndef NOUSER

#ifdef tagWND                       // ;Internal
#ifdef DEBUG                        // ;Internal
#define HMENU HMENU_16              // ;Internal
#else                               // ;Internal
typedef struct tagMENU FAR* HMENU;  // ;Internal
#endif                              // ;Internal
typedef UINT HMENU_16;              // ;Internal
#else                               // ;Internal
DECLARE_HANDLE(HMENU);
#endif                              // ;Internal

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;     /* HICONs & HCURSORs are polymorphic */


/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXFIXEDFRAME         7
#define SM_CYFIXEDFRAME         8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXSIZEFRAME          32
#define SM_CYSIZEFRAME          33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43
#define SM_SECURE               44
#endif  /* WINVER >= 0x030a */
                                    /* ;Internal 4.0 */
#if (WINVER >= 0x0400)              /* ;Internal 4.0 */
#define SM_CXEDGE               45  /* ;Internal 4.0 */
#define SM_CYEDGE               46  /* ;Internal 4.0 */
#define SM_CXMINSPACING         47  /* ;Internal 4.0 */
#define SM_CYMINSPACING         48  /* ;Internal 4.0 */
#define SM_CXSMICON             49  /* ;Internal 4.0 */
#define SM_CYSMICON             50  /* ;Internal 4.0 */
#define SM_CYSMCAPTION          51  /* ;Internal 4.0 */
#define SM_CXSMSIZE             52  /* ;Internal 4.0 */
#define SM_CYSMSIZE             53  /* ;Internal 4.0 */
#define SM_CXMENUSIZE           54  /* ;Internal 4.0 */
#define SM_CYMENUSIZE           55  /* ;Internal 4.0 */
#define SM_ARRANGE              56  /* ;Internal 4.0 */
#define SM_CXMINIMIZED          57  /* ;Internal 4.0 */
#define SM_CYMINIMIZED          58  /* ;Internal 4.0 */
#define SM_CXMAXTRACK           59  /* ;Internal 4.0 */
#define SM_CYMAXTRACK           60  /* ;Internal 4.0 */
#define SM_CXMAXIMIZED          61  /* ;Internal 4.0 */
#define SM_CYMAXIMIZED          62  /* ;Internal 4.0 */
#define SM_NETWORK              63  /* ;Internal 4.0 */
#define SM_CLEANBOOT		    67  /* ;Internal 4.0 */
#define SM_CXDRAG               68  /* ;Internal 4.0 */
#define SM_CYDRAG               69  /* ;Internal 4.0 */
#define SM_SHOWSOUNDS           70  /* ;Internal 4.0 */
#define SM_CXMENUCHECK          71  /* ;Internal 4.0 */
#define SM_CYMENUCHECK          72  /* ;Internal 4.0 */
#define SM_SLOWMACHINE          73  /* ;Internal 4.0 */
#define SM_MIDEASTENABLED       74  /* ;Internal 4.0 */
#endif  /* WINVER >= 0x0400 */      /* ;Internal 4.0 */

#if (WINVER >= 0x040A)
#define SM_MOUSEWHEELPRESENT    75  // ;public_sur
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
#endif  /* WINVER >= 0x040A */

#define SM_CXDLGFRAME           SM_CXFIXEDFRAME
#define SM_CYDLGFRAME           SM_CYFIXEDFRAME
#define SM_CXFRAME              SM_CXSIZEFRAME
#define SM_CYFRAME              SM_CYSIZEFRAME

#define SM_CYCAPTIONICON        SM_CYSMICON     // ;Internal BOGUS TEMPORARY
#define SM_CYSMCAPTIONICON      SM_CYSMICON     // ;Internal BOGUS TEMPORARY
#define SM_CXWORKAREA           SM_CXSCREEN     // ;Internal BOGUS TEMPORARY
#define SM_CYWORKAREA           SM_CYSCREEN     // ;Internal BOGUS TEMPORARY
#define SM_XWORKAREA            SM_CXBORDER     // ;Internal BOGUS TEMPORARY
#define SM_YWORKAREA            SM_CYBORDER     // ;Internal BOGUS TEMPORARY

// WARNING: If you modify SM_CMETRICS or SM_MAX make sure you   ;Internal
// modify the corresponding values in user.inc, user.api,       ;Internal
// windows.inc and winuser.h                                    ;Internal
#define SM_MAX                  81                          //  ;Internal
#define SM_CMETRICS             82
#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define ARW_BOTTOMLEFT              0x0000      // ;Internal 4.0
#define ARW_BOTTOMRIGHT             0x0001      // ;Internal 4.0
#define ARW_TOPLEFT                 0x0002      // ;Internal 4.0
#define ARW_TOPRIGHT                0x0003      // ;Internal 4.0
#define ARW_STARTMASK               0x0003      // ;Internal 4.0
#define ARW_STARTRIGHT              0x0001      // ;Internal 4.0
#define ARW_STARTTOP                0x0002      // ;Internal 4.0
                                                // ;Internal 4.0
#define ARW_LEFT                    0x0000      // ;Internal 4.0
#define ARW_RIGHT                   0x0000      // ;Internal 4.0
#define ARW_UP                      0x0004      // ;Internal 4.0
#define ARW_DOWN                    0x0004      // ;Internal 4.0
#define ARW_HIDE                    0x0008      // ;Internal 4.0
#define ARW_VALID                   0x000F      // ;Internal 4.0
#define ARW_ARRANGEMASK             0x0007      // ;Internal 4.0
                                                // ;Internal 4.0
#define MMI_MINSIZE                 0           // ;Internal 4.0
#define MMI_MAXSIZE                 1           // ;Internal 4.0
#define MMI_MAXPOS                  2           // ;Internal 4.0
#define MMI_MINTRACK                3           // ;Internal 4.0
#define MMI_MAXTRACK                4           // ;Internal 4.0

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)

#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#if (WINVER >= 0x0400)                          // ;Internal 4.0
                                                // ;Internal 4.0
#ifndef NOGDI                                   // ;Internal 4.0
typedef struct tagCOMMONFONT                    // ;Internal 4.0
{                                               // ;Internal 4.0
    BYTE    lfItalic;                           // ;Internal 4.0
    BYTE    lfUnderline;                        // ;Internal 4.0
    BYTE    lfStrikeOut;                        // ;Internal 4.0
    BYTE    lfCharSet;                          // ;Internal 4.0
    BYTE    lfOutPrecision;                     // ;Internal 4.0
    BYTE    lfClipPrecision;                    // ;Internal 4.0
    BYTE    lfQuality;                          // ;Internal 4.0
    BYTE    lfPitchAndFamily;                   // ;Internal 4.0
    char    lfFaceName[LF_FACESIZE];            // ;Internal 4.0
} COMMONFONT, FAR *LPCOMMONFONT;                // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagLOGFONT_32                    // ;Internal 4.0
{                                               // ;Internal 4.0
    LONG    lfHeight;                           // ;Internal 4.0
    LONG    lfWidth;                            // ;Internal 4.0
    LONG    lfEscapement;                       // ;Internal 4.0
    LONG    lfOrientation;                      // ;Internal 4.0
    LONG    lfWeight;                           // ;Internal 4.0
    COMMONFONT  lfCommon;                       // ;Internal 4.0
} LOGFONT_32, *PLOGFONT_32, FAR *LPLOGFONT_32;  // ;Internal 4.0
                                                // ;Internal 4.0
#define METRICS_USEDEFAULT -1                   // ;Internal 4.0
typedef struct tagNONCLIENTMETRICS              // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iBorderWidth;                       // ;Internal 4.0
    LONG    iScrollWidth;                       // ;Internal 4.0
    LONG    iScrollHeight;                      // ;Internal 4.0
    LONG    iCaptionWidth;                      // ;Internal 4.0
    LONG    iCaptionHeight;                     // ;Internal 4.0
    LOGFONT_32  lfCaptionFont;                  // ;Internal 4.0
    LONG    iSmCaptionWidth;                    // ;Internal 4.0
    LONG    iSmCaptionHeight;                   // ;Internal 4.0
    LOGFONT_32  lfSmCaptionFont;                // ;Internal 4.0
    LONG    iMenuWidth;                         // ;Internal 4.0
    LONG    iMenuHeight;                        // ;Internal 4.0
    LOGFONT_32  lfMenuFont;                     // ;Internal 4.0
    LOGFONT_32  lfStatusFont;                   // ;Internal 4.0
    LOGFONT_32  lfMessageFont;                  // ;Internal 4.0
}   NONCLIENTMETRICS, FAR* LPNONCLIENTMETRICS;  // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagICONMETRICS                   // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iHorzSpacing;                       // ;Internal 4.0
    LONG    iVertSpacing;                       // ;Internal 4.0
    LONG    iTitleWrap;                         // ;Internal 4.0
    LOGFONT_32  lfFont;                         // ;Internal 4.0
}   ICONMETRICS, FAR *LPICONMETRICS;            // ;Internal 4.0
#endif /* NOGDI */                              // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagMINIMIZEDMETRICS              // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iWidth;                             // ;Internal 4.0
    LONG    iHorzGap;                           // ;Internal 4.0
    LONG    iVertGap;                           // ;Internal 4.0
    LONG    iArrange;                           // ;Internal 4.0
}   MINIMIZEDMETRICS, FAR *LPMINIMIZEDMETRICS;  // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagANIMATIONINFO                 // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iMinAnimate;                        // ;Internal 4.0
}   ANIMATIONINFO, FAR *LPANIMATIONINFO;        // ;Internal 4.0
                                                // ;Internal 4.0
#endif /* WINVER >= 0x0400 */                   // ;Internal 4.0
                                                // ;Internal 4.0
#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_TIMEOUTS                7       // ;Internal
#define SPI_KANJIMENU               8       // ;Internal
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36
#define SPI_SETDRAGFULLWINDOWS      37      // ;Internal NT
#define SPI_GETDRAGFULLWINDOWS      38      // ;Internal NT
#define SPI_GETNONCLIENTMETRICS     41      // ;Internal 4.0
#define SPI_SETNONCLIENTMETRICS     42      // ;Internal 4.0
#define SPI_GETMINIMIZEDMETRICS     43      // ;Internal 4.0
#define SPI_SETMINIMIZEDMETRICS     44      // ;Internal 4.0
#define SPI_GETICONMETRICS          45      // ;Internal 4.0
#define SPI_SETICONMETRICS          46      // ;Internal 4.0
#define SPI_SETWORKAREA             47      // ;Internal 4.0
#define SPI_GETWORKAREA             48      // ;Internal 4.0
#define SPI_SETPENWINDOWS           49      // ;Internal 4.0
#define SPI_GETFILTERKEYS           50      // ;Internal 4.0
#define SPI_SETFILTERKEYS           51      // ;Internal 4.0
#define SPI_GETTOGGLEKEYS           52      // ;Internal 4.0
#define SPI_SETTOGGLEKEYS           53      // ;Internal 4.0
#define SPI_GETMOUSEKEYS            54      // ;Internal 4.0
#define SPI_SETMOUSEKEYS            55      // ;Internal 4.0
#define SPI_GETSHOWSOUNDS           56      // ;Internal 4.0
#define SPI_SETSHOWSOUNDS           57      // ;Internal 4.0
#define SPI_GETSTICKYKEYS           58      // ;Internal 4.0
#define SPI_SETSTICKYKEYS           59      // ;Internal 4.0
#define SPI_GETACCESSTIMEOUT        60      // ;Internal 4.0
#define SPI_SETACCESSTIMEOUT        61      // ;Internal 4.0
#define SPI_GETSERIALKEYS           62      // ;Internal 4.0
#define SPI_SETSERIALKEYS           63      // ;Internal 4.0
#define SPI_GETSOUNDSENTRY          64      // ;Internal 4.0
#define SPI_SETSOUNDSENTRY          65      // ;Internal 4.0
#define SPI_GETHIGHCONTRAST         66      // ;Internal 4.0
#define SPI_SETHIGHCONTRAST         67      // ;Internal 4.0
#define SPI_GETKEYBOARDPREF         68      // ;Internal 4.0
#define SPI_SETKEYBOARDPREF         69      // ;Internal 4.0
#define SPI_GETSCREENREADER         70      // ;Internal 4.0
#define SPI_SETSCREENREADER         71      // ;Internal 4.0
#define SPI_GETANIMATION            72      // ;Internal 4.0
#define SPI_SETANIMATION            73      // ;Internal 4.0
#define SPI_GETFONTSMOOTHING        74      // ;Internal 4.0
#define SPI_SETFONTSMOOTHING        75      // ;Internal 4.0
#define SPI_SETDRAGWIDTH            76      // ;Internal 4.0
#define SPI_SETDRAGHEIGHT           77      // ;Internal 4.0
#define SPI_SETHANDHELD             78      // ;Internal 4.0
#define SPI_GETLOWPOWERTIMEOUT	    79	    // ;Internal 4.0
#define SPI_GETPOWEROFFTIMEOUT	    80	    // ;Internal 4.0
#define SPI_SETLOWPOWERTIMEOUT	    81	    // ;Internal 4.0
#define SPI_SETPOWEROFFTIMEOUT	    82	    // ;Internal 4.0
#define SPI_GETLOWPOWERACTIVE	    83	    // ;Internal 4.0
#define SPI_GETPOWEROFFACTIVE	    84	    // ;Internal 4.0
#define SPI_SETLOWPOWERACTIVE	    85	    // ;Internal 4.0
#define SPI_SETPOWEROFFACTIVE	    86	    // ;Internal 4.0
#define SPI_SETCURSORS              87      // ;Internal 4.0
#define SPI_SETICONS                88      // ;Internal 4.0
#define SPI_GETDEFAULTINPUTLANG     89      // ;Internal 4.0
#define SPI_SETDEFAULTINPUTLANG     90	    // ;Internal 4.0
#define SPI_SETLANGTOGGLE           91      // ;Internal 4.0
#define SPI_GETWINDOWSEXTENSION     92      // ;Internal 4.0
#define SPI_SETMOUSETRAILS          93      // ;Internal 4.0
#define SPI_GETMOUSETRAILS          94      // ;Internal 4.0
#define SPI_GETSNAPTODEFBUTTON      95      // ;Internal NT
#define SPI_SETSNAPTODEFBUTTON      96      // ;internal NT
#define SPI_SETSCREENSAVERRUNNING   97      // ;Internal 4.0
#define SPI_GETMOUSEHOVERWIDTH      98      // ;internal
#define SPI_SETMOUSEHOVERWIDTH      99      // ;internal
#define SPI_GETMOUSEHOVERHEIGHT    100      // ;internal
#define SPI_SETMOUSEHOVERHEIGHT    101      // ;internal
#define SPI_GETMOUSEHOVERTIME      102      // ;internal
#define SPI_SETMOUSEHOVERTIME      103      // ;internal
#define SPI_GETWHEELSCROLLLINES    104      // ;internal
#define SPI_SETWHEELSCROLLLINES    105      // ;internal
#define SPI_GETMENUSHOWDELAY       106      // ;internal
#define SPI_SETMENUSHOWDELAY       107      // ;internal
#define SPI_GETUSERPREFERENCE      108      // ;internal
#define SPI_SETUSERPREFERENCE      109      // ;internal
#define SPI_GETSHOWIMEUI           110      // ;internal
#define SPI_SETSHOWIMEUI           111      // ;internal
#define SPI_GETMOUSESPEED          112      // ;internal
#define SPI_SETMOUSESPEED          113      // ;internal
#define SPI_GETSCREENSAVERRUNNING  114      // ;internal

#define SPI_MAX                    115      //  ;internal

// Support Old name                                           // ;Internal
#define SPI_SCREENSAVERRUNNING     SPI_SETSCREENSAVERRUNNING  // ;Internal


//                                                       // ;internal
// ADDING NEW SPI_* VALUES                               // ;internal
// If the value is a BOOL,                               // ;internal
//   it should be added after SPI_STARTBOOLRANGE         // ;internal
// If the value is a DWORD,                              // ;internal
//   it should be added after SPI_STARTDWORDRANGE        // ;internal
// If the value is a structure or a string,              // ;internal
//   go ahead and setup SPI_START*RANGE...               // ;internal
//                                                       // ;internal

#if (WINVER >= 0x040A)                                   // ;internal
//                                                       // ;internal
// If adding a new SPI value in the following ranges:    // ;internal
// -You must define both SPI_GET* and                    // ;internal
//       SPI_SET* using consecutive numbers              // ;internal
// -The low order bit of SPI_GET* must be 0              // ;internal
// -The low order bit of SPI_SET* must be 1              // ;internal
// -Properly update SPI_MAX*RANGE                        // ;internal
//                                                               // ;internal
#define SPIF_SET                  0x00000001                     // ;internal
#define SPIF_BOOL                 0x10000000                     // ;internal
#define SPIF_DWORD                0x20000000                     // ;internal
#define SPIF_RANGETYPEMASK        0x30000000                     // ;internal
//                                                               // ;internal
// BOOLeans range.                                               // ;internal
// For GET, pvParam is a pointer to a BOOL                       // ;internal
// For SET, pvParam is the value                                 // ;internal
//                                                               // ;internal
#define SPI_STARTBOOLRANGE                  0x10000000           // ;internal
#define SPI_GETACTIVEWINDOWTRACKING         0x10000000           // ;internal
#define SPI_SETACTIVEWINDOWTRACKING         0x10000001           // ;internal
#define SPI_GETMENUANIMATION                0x10000002           // ;internal
#define SPI_SETMENUANIMATION                0x10000003           // ;internal
#define SPI_GETCOMBOBOXANIMATION            0x10000004           // ;internal
#define SPI_SETCOMBOBOXANIMATION            0x10000005           // ;internal
#define SPI_GETLISTBOXSMOOTHSCROLLING       0x10000006           // ;internal
#define SPI_SETLISTBOXSMOOTHSCROLLING       0x10000007           // ;internal
#define SPI_GETGRADIENTCAPTIONS             0x10000008           // ;internal
#define SPI_SETGRADIENTCAPTIONS             0x10000009           // ;internal
#define SPI_GETMENUUNDERLINES               0x1000000A           // ;internal
#define SPI_SETMENUUNDERLINES               0x1000000B           // ;internal
#define SPI_GETACTIVEWNDTRKZORDER           0x1000000C           // ;internal
#define SPI_SETACTIVEWNDTRKZORDER           0x1000000D           // ;internal
#define SPI_GETHOTTRACKING                  0x1000000E           // ;internal
#define SPI_SETHOTTRACKING                  0x1000000F           // ;internal
#define SPI_MAXBOOLRANGE                    0x10000010           // ;internal
#define SPI_BOOLRANGECOUNT ((SPI_MAXBOOLRANGE - SPI_STARTBOOLRANGE) / 2) // ;internal
                                                                 // ;internal
//                                                               // ;internal
// DWORDs range.                                                 // ;internal
// For GET, pvParam is a pointer to a DWORD                      // ;internal
// For SET, pvParam is the value                                 // ;internal
//                                                               // ;internal
#define SPI_STARTDWORDRANGE                 0x20000000           // ;internal
#define SPI_GETFOREGROUNDLOCKTIMEOUT        0x20000000           // ;internal
#define SPI_SETFOREGROUNDLOCKTIMEOUT        0x20000001           // ;internal
#define SPI_MAXDWORDRANGE                   0x20000002           // ;internal
#define SPI_DWORDRANGECOUNT ((SPI_MAXDWORDRANGE - SPI_STARTDWORDRANGE) / 2) // ;internal
#endif // #if (WINVER >= 0x040A)                                 // ;internal


/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDCHANGE             0x0002
#define SPIF_SENDWININICHANGE       SPIF_SENDCHANGE
#define SPIF_VALID                  0x0003  /* ;Internal */

typedef struct tagFILTERKEYS            // ;Internal 4.0
{                                       // ;Internal 4.0
    DWORD   cbSize;                     // ;Internal 4.0
    DWORD   dwFlags;                    // ;Internal 4.0
    DWORD   iWaitMSec;                  // ;Internal 4.0 
    DWORD   iDelayMSec;                 // ;Internal 4.0 
    DWORD   iRepeatMSec;                // ;Internal 4.0 
    DWORD   iBounceMSec;                // ;Internal 4.0 
}   FILTERKEYS, FAR* LPFILTERKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define FKF_FILTERKEYSON    0x00000001  // ;Internal 4.0 
#define FKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define FKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define FKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define FKF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define FKF_INDICATOR       0x00000020  // ;Internal 4.0 
#define FKF_CLICKON         0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagSTICKYKEYS            // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
}   STICKYKEYS, FAR* LPSTICKYKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SKF_STICKYKEYSON    0x00000001  // ;Internal 4.0 
#define SKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define SKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define SKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define SKF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define SKF_INDICATOR       0x00000020  // ;Internal 4.0 
#define SKF_AUDIBLEFEEDBACK 0x00000040  // ;Internal 4.0 
#define SKF_TRISTATE        0x00000080  // ;Internal 4.0 
#define SKF_TWOKEYSOFF      0x00000100  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagMOUSEKEYS             // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    DWORD   iMaxSpeed;                  // ;Internal 4.0 
    DWORD   iTimeToMaxSpeed;            // ;Internal 4.0 
    DWORD   iCtrlSpeed;                 // ;Internal 4.0 
    DWORD   dwReserved1;                // ;Internal 4.0 
    DWORD   dwReserved2;                // ;Internal 4.0 
}   MOUSEKEYS, FAR* LPMOUSEKEYS;        // ;Internal 4.0 
                                        // ;Internal 4.0 
#define MKF_MOUSEKEYSON     0x00000001  // ;Internal 4.0 
#define MKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define MKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define MKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define MKF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define MKF_INDICATOR       0x00000020  // ;Internal 4.0 
#define MKF_NOMODIFIERS     0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagACCESSTIMEOUT         // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    DWORD   iTimeOutMSec;               // ;Internal 4.0 
}   ACCESSTIMEOUT, FAR* LPACCESSTIMEOUT;// ;Internal 4.0 
                                        // ;Internal 4.0 
#define ATF_TIMEOUTON       0x00000001  // ;Internal 4.0 
#define ATF_ONOFFFEEDBACK   0x00000002  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagSOUNDSENTRY           // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    DWORD   iFSTextEffect;              // ;Internal 4.0 
    DWORD   iFSTextEffectMSec;          // ;Internal 4.0 
    DWORD   iFSTextEffectColorBits;     // ;Internal 4.0 
    DWORD   iFSGrafEffect;              // ;Internal 4.0 
    DWORD   iFSGrafEffectMSec;          // ;Internal 4.0 
    DWORD   iFSGrafEffectColor;         // ;Internal 4.0 
    DWORD   iWindowsEffect;             // ;Internal 4.0 
    DWORD   iWindowsEffectMSec;         // ;Internal 4.0 
    LPSTR   lpszWindowsEffectDLL;       // ;Internal 4.0 
    DWORD   iWindowsEffectOrdinal;      // ;Internal 4.0 
}   SOUNDSENTRY, FAR* LPSOUNDSENTRY;    // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSF_SOUNDSENTRYON   0x00000001  // ;Internal 4.0 
#define SSF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define SSF_INDICATOR       0x00000004  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSTF_NONE           0x00000001  // ;Internal 4.0 
#define SSTF_CHARS          0x00000002  // ;Internal 4.0 
#define SSTF_BORDER         0x00000004  // ;Internal 4.0 
#define SSTF_DISPLAY        0x00000008  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSGF_NONE           0x00000001  // ;Internal 4.0 
#define SSGF_DISPLAY        0x00000002  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSWF_NONE           0x00000001  // ;Internal 4.0 
#define SSWF_TITLE          0x00000002  // ;Internal 4.0 
#define SSWF_WINDOW         0x00000004  // ;Internal 4.0 
#define SSWF_DISPLAY        0x00000008  // ;Internal 4.0 
#define SSWF_CUSTOM         0x00000010  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagTOGGLEKEYS            // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
}   TOGGLEKEYS, FAR* LPTOGGLEKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define TKF_TOGGLEKEYSON    0x00000001  // ;Internal 4.0 
#define TKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define TKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define TKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define TKF_HOTKEYSOUND     0x00000020  // ;Internal 4.0 
#define TKF_INDICATOR       0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagSERIALKEYS            // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    LPSTR   lpszActivePort;             // ;Internal 4.0 
    LPSTR   lpszPort;                   // ;Internal 4.0 
    DWORD   iBaudRate;                  // ;Internal 4.0 
    DWORD   iPortState;                 // ;Internal 4.0 
    DWORD   iActive;                    // ;Internal 4.0 
}   SERIALKEYS, FAR* LPSERIALKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SERKF_SERIALKEYSON  0x00000001  // ;Internal 4.0 
#define SERKF_AVAILABLE     0x00000002  // ;Internal 4.0 
#define SERKF_INDICATOR     0x00000004  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagHIGHCONTRAST          // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    LPSTR   lpszDefaultScheme;          // ;Internal 4.0 
}   HIGHCONTRAST, FAR* LPHIGHCONTRAST;  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define HCF_HIGHCONTRASTON  0x00000001  // ;Internal 4.0 
#define HCF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define HCF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define HCF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define HCF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define HCF_INDICATOR       0x00000020  // ;Internal 4.0 
#define HCF_HOTKEYAVAILABLE 0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0
#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)

/* Flags for ChangeDisplaySettings */
#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004
#define CDS_GLOBAL          0x00000008
#define CDS_SET_PRIMARY     0x00000010
#define CDS_EXCLUSIVE       0x80000000  // ;internal
#define CDS_RESET           0x40000000
#define CDS_NORESET         0x10000000
#define CDS_VALID           0xF000001F  // ;internal

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4
#define DISP_CHANGE_BADPARAM        -5

typedef struct tagDEVMODE FAR*LPDEVMODE;

LONG WINAPI ChangeDisplaySettings(LPDEVMODE lpDevMode, DWORD flags);

BOOL WINAPI EnumDisplaySettings(
    LPCSTR      lpszDeviceName,
    DWORD       iModeNum,
    LPDEVMODE   lpDevMode);

#if (WINVER >= 0x040A)

#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#define ENUM_REGISTRY_SETTINGS      ((DWORD)-2)

LONG WINAPI ChangeDisplaySettingsEx(
    LPCSTR      lpszDeviceName,
    LPDEVMODE   lpDevMode,
#ifdef tagWND               /* ;Internal */
    HWND_16     hwnd,       /* ;Internal */
#else                       /* ;Internal */
    HWND        hwnd,
#endif                      /* ;Internal */
    DWORD       flags,
    LPVOID      lParam);

#endif  /* WINVER >=0x040A */

#endif  /* WINVER >=0x0400 */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(LPRECT, int, int, int, int);
void    WINAPI SetRectEmpty(LPRECT);

void    WINAPI CopyRect(LPRECT, LPCRECT);

BOOL    WINAPI IsRectEmpty(LPCRECT);

BOOL    WINAPI EqualRect(LPCRECT, LPCRECT);

BOOL    WINAPI IntersectRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI UnionRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI SubtractRect(LPRECT, LPCRECT, LPCRECT);

void    WINAPI OffsetRect(LPRECT, int, int);
void    WINAPI InflateRect(LPRECT, int, int);

BOOL    WINAPI PtInRect(LPCRECT, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
#ifdef tagWND           /* ;Internal */
    HWND_16 hwnd;       /* ;Internal */
#else                   /* ;Internal */
    HWND    hwnd;
#endif                  /* ;Internal */
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
    DWORD   time;
    POINT   pt;
} MSG, * PMSG, NEAR* NPMSG, FAR* LPMSG;

BOOL    WINAPI GetMessage(LPMSG, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(LPMSG, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002
#define PM_VALID        0x0003      /* ;Internal */

#ifdef tagWND   // ;Internal
BOOL    WINAPI WaitMessage(void);   // ;Internal
#else           // ;Internal
void    WINAPI WaitMessage(void);
#endif          // ;Internal

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#if (WINVER >= 0x0400)                      /* ;Internal 4.0 */
LPARAM  WINAPI SetMessageExtraInfo(LPARAM); /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */               /* ;Internal 4.0 */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040
#if (WINVER >= 0x40A)                               
#define QS_ALLPOSTMESSAGE 0x0100
#endif // (WINVER >= 0x40A)                         
// #define QS_HOTKEY       0x0080          // ;Internal NT
// #define QS_ALLINPUT     0x00ff          // ;Internal NT
#define QS_ALLINPUT     0x007f
#define QS_TRANSFER     0x4000          // ;Internal
#define QS_VALID        0x40FF          // ;Internal
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

#ifdef tagWND                                               /* ;Internal */
BOOL    WINAPI PostMessage(HWND_16, UINT, WPARAM, LPARAM);  /* ;Internal */
#else                                                       /* ;Internal */
BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
#endif                                                      /* ;Internal */

LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#if (WINVER >= 0x0400)                      // ;Internal 4.0
#define SMTO_NORMAL         0x0000          // ;Internal NT
#define SMTO_BLOCK          0x0001          // ;Internal NT
#define SMTO_ABORTIFHUNG    0x0002          // ;Internal NT
#define SMTO_BROADCAST      0x0004          // ;Internal 4.0
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008      // ;Internal 4.0
#define SMTO_VALID          0x000F          // ;Internal NT
                                            // ;Internal NT
#ifdef tagWND                               // ;Internal NT
typedef VOID (CALLBACK* SENDASYNCPROC)(HWND_16, UINT, DWORD, LRESULT);  /* ;Internal NT */
#else                                       // ;Internal NT
typedef VOID (CALLBACK* SENDASYNCPROC)(HWND, UINT, DWORD, LRESULT);     /* ;Internal NT */
#endif                                      // ;Internal NT
                                            // ;Internal 4.0
long  WINAPI  BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM); // ;Internal 4.0

#define BROADCAST_QUERY_DENY	0x424D5144	    // Return this value to deny a query.
                                            // ;Internal 4.0
#define BSM_ALLCOMPONENTS       0x00000000  // ;Internal 4.0
#define BSM_VXDS                0x00000001  // ;Internal 4.0
#define BSM_NETDRIVER           0x00000002  // ;Internal 4.0
#define BSM_INSTALLABLEDRIVERS  0x00000004  // ;Internal 4.0
#define BSM_APPLICATIONS        0x00000008  // ;Internal 4.0
                                            // ;Internal 4.0
#define BSF_QUERY               0x00000001  // ;Internal 4.0
#define BSF_IGNORECURRENTTASK   0x00000002  // ;Internal 4.0
#define BSF_FLUSHDISK           0x00000004  // ;Internal 4.0
#define BSF_NOHANG              0x00000008  // ;Internal 4.0
#define BSF_POSTMESSAGE         0x00000010  // ;Internal 4.0
#define BSF_FORCEIFHUNG         0x00000020  // ;Internal 4.0
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040  // ;Internal 4.0
#define BSF_SYSTEMSHUTDOWN      0x40000000  // ;Internal 4.0
#define BSF_MSGSRV32ISOK        0x80000000  // ;Internal 4.0
#define BSF_VALID               0xC000007F  // ;Internal 4.0
                                            // ;Internal 4.0
/* Flags for wParam of WM_DEVICECHANGE message */   // ;Internal 4.0
#define DBWF_LPARAMPOINTER	0x8000	        // ;Internal 4.0	
                                            // ;Internal 4.0    
typedef struct tagBROADCASTSYSMSG           // ;Internal 4.0
{                                           // ;Internal 4.0
/*  DWORD   cbSize; */          // ;Internal BOGUS
    UINT    uiMessage;                      // ;Internal 4.0                
    WPARAM  wParam;                         // ;Internal 4.0
    LPARAM  lParam;                         // ;Internal 4.0
} BROADCASTSYSMSG;                          // ;Internal 4.0
typedef BROADCASTSYSMSG  FAR *LPBROADCASTSYSMSG;    // ;Internal 4.0
                                            // ;Internal 4.0
#endif /* WINVER >= 0x0400 */               // ;Internal 4.0
                                                    /* ;Internal 4.0 */
#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

#ifdef tagWND   // ;Internal
BOOL    WINAPI ReplyMessage(LRESULT);   // ;Internal
#else           // ;Internal
void    WINAPI ReplyMessage(LRESULT);
#endif          // ;Internal
BOOL    WINAPI InSendMessage(void);

DWORD   WINAPI InSendMessageEx(LPVOID);   // ;Internal 4.1
/*                                        // ;Internal 4.1
 * InSendMessageEx return value           // ;Internal 4.1
 */                                       // ;Internal 4.1
#define ISMEX_NOSEND      0x00000000      // ;Internal 4.1
#define ISMEX_SEND        0x00000001      // ;Internal 4.1
#define ISMEX_NOTIFY      0x00000002      // ;Internal 4.1
#define ISMEX_CALLBACK    0x00000004      // ;Internal 4.1
#define ISMEX_REPLIED     0x00000008      // ;Internal 4.1

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST ((HWND)-1)


BOOL WINAPI CallMsgFilter(LPMSG, int);

#define WH_GETMESSAGE           3

#define WH_CALLWNDPROC          4
#define WH_CALLWNDPROCRET       12      // ;Internal 4.0
                                        // ;Internal
typedef struct tagCWPRETSTRUCT          // ;Internal 4.0
{                                       // ;Internal 4.0
    LRESULT lResult;                    // ;Internal 4.0
    WPARAM  wParamHi;                   // ;Internal 4.0
    LPARAM  lParam;                     // ;Internal 4.0
    WPARAM  wParamLo;                   // ;Internal 4.0
    UINT    message;                    // ;Internal 4.0
#ifdef tagWND                           // ;Internal
    HWND_16 hwnd;                       // ;Internal
#else                                   // ;Internal
    HWND    hwnd;                       // ;Internal 4.0
#endif                                  // ;Internal
} CWPRETSTRUCT, FAR * LPCWPRETSTRUCT;   // ;Internal 4.0

// #define WC_INIT              1       // ;Internal NT
// #define WC_SWP               2       // ;Internal NT
// #define WC_DEFWINDOWPROC     3       // ;Internal NT
// #define WC_MINMAX            4       // ;Internal NT
// #define WC_MOVE              5       // ;Internal NT
// #define WC_SIZE              6       // ;Internal NT
// #define WC_DRAWCAPTION       7       // ;Internal NT
                                        // ;Internal
#define WH_MSGFILTER            (-1)
#define WH_SYSMSGFILTER         6
#define WH_FOREGROUNDIDLE       11      // ;Internal NT

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX          0
#define MSGF_MESSAGEBOX         1       // ;Internal
#define MSGF_MENU               2
#define MSGF_MOVE               3
#define MSGF_SIZE               4
#define MSGF_SCROLLBAR          5
#define MSGF_NEXTWINDOW         6
#define MSGF_CBTHOSEBAGSUSEDTHIS 7      // ;Internal
#define MSGF_MAINLOOP           8
#define MSGF_USER               4096
#endif  /* NOMSG */

/* Standard window messages */
/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_NULL                 0x0000
#define WM_CREATE               0x0001
#define WM_DESTROY              0x0002
#define WM_MOVE                 0x0003
#define WM_SIZEWAIT             0x0004      // ;Internal
#define WM_SIZE                 0x0005
#define WM_ACTIVATE             0x0006
#define WM_SETFOCUS             0x0007
#define WM_KILLFOCUS            0x0008
#define WM_SETVISIBLE           0x0009      // ;Internal
#define WM_ENABLE               0x000A
#define WM_SETREDRAW            0x000B
#define WM_SETTEXT              0x000C
#define WM_GETTEXT              0x000D
#define WM_GETTEXTLENGTH        0x000E
#define WM_PAINT                0x000F

#define WM_CLOSE                0x0010
#define WM_QUERYENDSESSION      0x0011
#define WM_QUIT                 0x0012
#define WM_QUERYOPEN            0x0013
#define WM_ERASEBKGND           0x0014
#define WM_SYSCOLORCHANGE       0x0015
#define WM_ENDSESSION           0x0016
#define WM_SYSTEMERROR          0x0017      // ;Internal
#define WM_SHOWWINDOW           0x0018
#define WM_CTLCOLOR             0x0019
#define WM_SETTINGCHANGE        0x001A
#define WM_WININICHANGE         WM_SETTINGCHANGE
#define WM_DEVMODECHANGE        0x001B
#define WM_ACTIVATEAPP          0x001C
#define WM_FONTCHANGE           0x001D
#define WM_TIMECHANGE           0x001E
#define WM_CANCELMODE           0x001F

#define WM_SETCURSOR            0x0020
#define WM_MOUSEACTIVATE        0x0021
#define WM_CHILDACTIVATE        0x0022
#define WM_QUEUESYNC            0x0023
#define WM_GETMINMAXINFO        0x0024
#define WM_LOGOFF               0x0025      // ;Internal NT
#define WM_PAINTICON            0x0026      // ;Internal
#define WM_ICONERASEBKGND       0x0027
#define WM_NEXTDLGCTL           0x0028
#define WM_ALTTABACTIVE         0x0029      // ;Internal
#define WM_SPOOLERSTATUS        0x002A
#define WM_DRAWITEM             0x002B
#define WM_MEASUREITEM          0x002C
#define WM_DELETEITEM           0x002D
#define WM_VKEYTOITEM           0x002E
#define WM_CHARTOITEM           0x002F

#define WM_SETFONT              0x0030
#define WM_GETFONT              0x0031
#define WM_SETHOTKEY            0x0032      // ;Internal
#define WM_GETHOTKEY            0x0033      // ;Internal
#define WM_FILESYSCHANGE        0x0034      // ;Internal
#define WM_SHELLNOTIFY          0x0034      // ;Internal
#define SHELLNOTIFY_DISKFULL    0x0001      // ;Internal
#define SHELLNOTIFY_OLELOADED   0x0002      // ;Internal
#define SHELLNOTIFY_OLEUNLOADED 0x0003      // ;Internal
#define SHELLNOTIFY_WALLPAPERCHANGED 0x0004 // ;Internal
#define SHELLNOTIFY_SWAPGROWFAILED 0x0005   // ;Internal
                                            // ;Internal
#define WM_ISACTIVEICON         0x0035      // ;Internal
#define WM_UNUSED0036           0x0036      // ;Internal
#define WM_QUERYDRAGICON        0x0037
#define WM_WINHELP		        0x0038	    // ;Internal 4.0
#define WM_COMPAREITEM          0x0039
#define WM_FULLSCREEN           0x003A      // ;Internal NT
#define WM_CLIENTSHUTDOWN       0x003B      // ;Internal NT
#define WM_DDEMLEVENT           0x003C      // ;Internal NT
                                            // ;Internal
#ifdef WINABLE                              // ;Internal
#define WMOBJ_ID                0x0000      // ;Internal
#define WMOBJ_POINT             0x0001      // ;Internal
#define WMOBJ_SAMETHREAD        0x8000      // ;Internal
                                            // ;Internal
#define WMOBJID_SELF            0x00000000  // ;Internal
                                            // ;Internal
#define WM_GETOBJECT            0x003D      // ;Internal
#endif // WINABLE                           // ;Internal
#define MM_CALCSCROLL           0x003F      // ;Internal NT

#define WM_TESTING              0x0040      // ;Internal
#define WM_COMPACTING           0x0041
#define WM_OTHERWINDOWCREATED   0x0042      // ;Internal NT
#define WM_OTHERWINDOWDESTROYED 0x0043      // ;Internal NT
#define WM_COMMNOTIFY           0x0044
#define WM_MEDIASTATUSCHANGE    0x0045      // ;Internal 4.0
#define WM_WINDOWPOSCHANGING    0x0046
#define WM_WINDOWPOSCHANGED     0x0047
#define WM_POWER                0x0048
#define WM_COPYGLOBALDATA       0x0049      // ;Internal NT
#define WM_COPYDATA             0x004A      // ;Internal NT
#define WM_CANCELJOURNAL        0x004B      // ;Internal NT
#define WM_LOGONNOTIFY          0x004C      // ;Internal NT
#define WM_KEYF1                0x004D      // ;Internal 4.0
#define WM_NOTIFY               0x004E
#define WM_ACCESS_WINDOW        0x004F      // ;Internal NT

#define WM_INPUTLANGCHANGEREQUEST     0x0050      // ;Internal 4.0
#define WM_INPUTLANGCHANGE      0x0051      // ;Internal 4.0
#define WM_TCARD		        0x0052
#define WM_HELP                 0x0053
#define WM_USERCHANGED		    0x0054
#define WM_NOTIFYFORMAT         0x0055      // ;Internal 4.0
#define NFR_ANSI                1           // ;Internal 4.0
#define NFR_UNICODE             2           // ;Internal 4.0
#define NF_QUERY                3           // ;Internal 4.0
#define NF_REQUERY              4           // ;Internal 4.0
                                            // ;Internal

#define WM_FINALDESTROY         0x0070      // ;Internal NT
#define WM_MEASUREITEM_CLIENTDATA   0x0071  // ;Internal NT
#define WM_CONTEXTMENU          0x007B
#define WM_STYLECHANGING        0x007C      // ;Internal 4.0
#define WM_STYLECHANGED         0x007D      // ;Internal 4.0
#define WM_DISPLAYCHANGE	    0x007E      // ;Internal 4.0
#define WM_GETICON              0x007F      // ;Internal 4.0

#define WM_SETICON              0x0080      // ;Internal 4.0
#define WM_NCCREATE             0x0081
#define WM_NCDESTROY            0x0082
#define WM_NCCALCSIZE           0x0083
#define WM_NCHITTEST            0x0084
#define WM_NCPAINT              0x0085
#define WM_NCACTIVATE           0x0086
#define WM_GETDLGCODE           0x0087
#define WM_SYNCPAINT            0x0088      // ;Internal
#define WM_SYNCTASK             0x0089      // ;Internal

#define WM_NCMOUSEMOVE          0x00A0
#define WM_NCLBUTTONDOWN        0x00A1
#define WM_NCLBUTTONUP          0x00A2
#define WM_NCLBUTTONDBLCLK      0x00A3
#define WM_NCRBUTTONDOWN        0x00A4
#define WM_NCRBUTTONUP          0x00A5
#define WM_NCRBUTTONDBLCLK      0x00A6
#define WM_NCMBUTTONDOWN        0x00A7
#define WM_NCMBUTTONUP          0x00A8
#define WM_NCMBUTTONDBLCLK      0x00A9

#define EM_FIRST_32             0x00B0      // ;Internal
// #define EM_GETSEL            0x00B0      // ;Internal NT
// #define EM_SETSEL            0x00B1      // ;Internal NT
// #define EM_GETRECT           0x00B2      // ;Internal NT
// #define EM_SETRECT           0x00B3      // ;Internal NT
// #define EM_SETRECTNP         0x00B4      // ;Internal NT
// #define EM_SCROLL            0x00B5      // ;Internal NT
// #define EM_LINESCROLL        0x00B6      // ;Internal NT
// #define EM_SCROLLCARET       0x00B7      // ;Internal NT
// #define EM_GETMODIFY         0x00B8      // ;Internal NT
// #define EM_SETMODIFY         0x00B9      // ;Internal NT
// #define EM_GETLINECOUNT      0x00BA      // ;Internal NT
// #define EM_LINEINDEX         0x00BB      // ;Internal NT
// #define EM_SETHANDLE         0x00BC      // ;Internal NT
// #define EM_GETHANDLE         0x00BD      // ;Internal NT
// #define EM_GETTHUMB          0x00BE      // ;Internal NT
// #define EM_LINELENGTH        0x00C1      // ;Internal NT
// #define EM_REPLACESEL        0x00C2      // ;Internal NT
// #define EM_SETFONT           0x00C3      // ;Internal NT
// #define EM_GETLINE           0x00C4      // ;Internal NT
// #define EM_LIMITTEXT         0x00C5      // ;Internal NT
// #define EM_CANUNDO           0x00C6      // ;Internal NT
// #define EM_UNDO              0x00C7      // ;Internal NT
// #define EM_FMTLINES          0x00C8      // ;Internal NT
// #define EM_LINEFROMCHAR      0x00C9      // ;Internal NT
// #define EM_SETWORDBREAK      0x00CA      // ;Internal NT
// #define EM_SETTABSTOPS       0x00CB      // ;Internal NT
// #define EM_SETPASSWORDCHAR   0x00CC      // ;Internal NT
// #define EM_EMPTYUNDOBUFFER   0x00CD      // ;Internal NT
// #define EM_GETFIRSTVISIBLELINE   0x00CE  // ;Internal NT
// #define EM_SETREADONLY       0x00CF      // ;Internal NT
// #define EM_SETWORDBREAKPROC  0x00D0      // ;Internal NT
// #define EM_GETWORDBREAKPROC  0x00D1      // ;Internal NT
// #define EM_GETPASSWORDCHAR   0x00D2      // ;Internal NT
// #define EM_SETMARGINS        0x00D3      // ;Internal NT 4.0
// #define EM_GETMARGINS        0x00D4      // ;Internal NT 4.0
// #define EM_POSFROMCHAR       0x00D5      // ;Internal NT 4.0
// #define EM_CHARFROMPOS       0x00D6      // ;Internal NT 4.0
#define EM_LAST_32              0x00D6      // ;Internal
                                            // ;Internal
#define SBM_FIRST_32            0x00E0      // ;Internal
// #define SBM_SETPOS           0x00E0      // ;Internal NT
// #define SBM_GETPOS           0x00E1      // ;Internal NT
// #define SBM_SETRANGE         0x00E2      // ;Internal NT
// #define SBM_GETRANGE         0x00E3      // ;Internal NT
// #define SBM_ENABLE_ARROWS    0x00E4      // ;Internal NT
// #define SBM_SETRANGEREDRAW   0x00E6      // ;Internal NT
// #define SBM_SETSCROLLINFO    0x00E9      // ;Internal NT 4.0
// #define SBM_GETSCROLLINFO    0x00EA      // ;Internal NT 4.0
#define SBM_LAST_32             0x00EA      // ;Internal
                                            // ;Internal
#define BM_FIRST_32             0x00F0      // ;Internal
// #define BM_GETCHECK          0x00F0      // ;Internal NT
// #define BM_SETCHECK          0x00F1      // ;Internal NT
// #define BM_GETSTATE          0x00F2      // ;Internal NT
// #define BM_SETSTATE          0x00F3      // ;Internal NT
// #define BM_SETSTYLE          0x00F4      // ;Internal NT
// #define BM_CLICK             0x00F5      // ;Internal NT
// #define BM_GETIMAGE          0x00F6      // ;Internal NT 4.0
// #define BM_SETIMAGE          0x00F7      // ;Internal NT 4.0
#define BM_LAST_32              0x00F7      // ;Internal

#define WM_KEYFIRST             0x0100
#define WM_KEYDOWN              0x0100
#define WM_KEYUP                0x0101
#define WM_CHAR                 0x0102
#define WM_DEADCHAR             0x0103
#define WM_SYSKEYDOWN           0x0104
#define WM_SYSKEYUP             0x0105
#define WM_SYSCHAR              0x0106
#define WM_SYSDEADCHAR          0x0107
#define WM_YOMICHAR             0x0108      /* ;Internal JAPAN */
#define WM_KEYLAST              0x0108
#define WM_CONVERTREQUEST       0x010A      /* ;Internal JAPAN */
#define WM_CONVERTRESULT        0x010B      /* ;Internal JAPAN */
#define WM_INTERIM              0x010C      /* ;Internal KOREA */

#define WM_INITDIALOG           0x0110
#define WM_COMMAND              0x0111
#define WM_SYSCOMMAND           0x0112
#define WM_TIMER                0x0113
#define WM_HSCROLL              0x0114
#define WM_VSCROLL              0x0115
#define WM_INITMENU             0x0116
#define WM_INITMENUPOPUP        0x0117
#define WM_SYSTIMER             0x0118      // ;Internal
#define WM_MENUSELECT           0x011F
#define WM_MENUCHAR             0x0120

#define WM_ENTERIDLE            0x0121
#if (WINVER >= 0x40A)                       // ;Internal 4.1
#define WM_MENURBUTTONUP        0x0122      // ;Internal 4.1
#define WM_MENUDRAG             0x0123      // ;Internal 4.1
#define WM_MENUGETOBJECT        0x0124      // ;Internal 4.1
#define WM_UNINITMENUPOPUP      0x0125      // ;Internal 4.1
#define WM_MENUCOMMAND          0x0126      // ;Internal 4.1
#endif // (WINVER >= 0x40A)                 // ;Internal 4.1
                                            // ;Internal NT
#define WM_LBTRACKPOINT         0x0131      // ;Internal 
// #define WM_CTLCOLORFIRST     0x0132      // ;Internal NT
// #define WM_CTLCOLORMSGBOX    0x0132      // ;Internal NT
// #define WM_CTLCOLOREDIT      0x0133      // ;Internal NT
// #define WM_CTLCOLORLISTBOX   0x0134      // ;Internal NT
// #define WM_CTLCOLORBTN       0x0135      // ;Internal NT
// #define WM_CTLCOLORDLG       0x0136      // ;Internal NT
// #define WM_CTLCOLORSCROLLBAR 0x0137      // ;Internal NT
// #define WM_CTLCOLORSTATIC    0x0138      // ;Internal NT
// #define WM_CTLCOLORLAST      0x0138      // ;Internal NT
                                            // ;Internal NT
#define CB_FIRST_32             0x0140      // ;Internal
// #define CB_GETEDITSEL        0x0140      // ;Internal NT
// #define CB_LIMITTEXT         0x0141      // ;Internal NT
// #define CB_SETEDITSEL        0x0142      // ;Internal NT
// #define CB_ADDSTRING         0x0143      // ;Internal NT
// #define CB_DELETESTRING      0x0144      // ;Internal NT
// #define CB_DIR               0x0145      // ;Internal NT
// #define CB_GETCOUNT          0x0146      // ;Internal NT
// #define CB_GETCURSEL         0x0147      // ;Internal NT
// #define CB_GETLBTEXT         0x0148      // ;Internal NT
// #define CB_GETLBTEXTLEN      0x0149      // ;Internal NT
// #define CB_INSERTSTRING      0x014A      // ;Internal NT
// #define CB_RESETCONTENT      0x014B      // ;Internal NT
// #define CB_FINDSTRING        0x014C      // ;Internal NT
// #define CB_SELECTSTRING      0x014D      // ;Internal NT
// #define CB_SETCURSEL         0x014E      // ;Internal NT
// #define CB_SHOWDROPDOWN      0x014F      // ;Internal NT
                                            // ;Internal NT
// #define CB_GETITEMDATA       0x0150      // ;Internal NT
// #define CB_SETITEMDATA       0x0151      // ;Internal NT
// #define CB_GETDROPPEDCONTROLRECT 0x0152  // ;Internal NT
// #define CB_SETITEMHEIGHT     0x0153      // ;Internal NT
// #define CB_GETITEMHEIGHT     0x0154      // ;Internal NT
// #define CB_SETEXTENDEDUI     0x0155      // ;Internal NT
// #define CB_GETEXTENDEDUI     0x0156      // ;Internal NT
// #define CB_GETDROPPEDSTATE   0x0157      // ;Internal NT
// #define CB_FINDSTRINGEXACT   0x0158      // ;Internal NT
// #define CB_SETLOCALE         0x0159      // ;Internal NT
// #define CB_GETLOCALE         0x015A      // ;Internal NT
// #define CB_GETTOPINDEX       0x015B      // ;Internal NT 4.0
// #define CB_SETTOPINDEX       0x015C      // ;Internal NT 4.0
// #define CB_GETHORIZONTALEXTENT   0x015D  // ;Internal NT 4.0
// #define CB_SETHORIZONTALEXTENT   0x015E  // ;Internal NT 4.0
// #define CB_GETDROPPEDWIDTH   0x015F      // ;Internal NT 4.0
// #define CB_SETDROPPEDWIDTH   0x0160      // ;Internal NT 4.0
// #define CB_INITSTORAGE       0x0161      // ;Internal NT 4.0
#define CB_LAST_32              0x0161      // ;Internal
                                            // ;Internal
#define STM_FIRST_32            0x0170      // ;Internal
// #define STM_SETICON          0x0170      // ;Internal NT
// #define STM_GETICON          0x0171      // ;Internal NT
// #define STM_SETIMAGE         0x0172      // ;Internal NT 4.0
// #define STM_GETIMAGE         0x0173      // ;Internal NT 4.0
#define STM_LAST_32             0x0173      // ;Internal
                                            // ;Internal
#define LB_FIRST_32             0x0180      // ;Internal
// #define LB_ADDSTRING         0x0180      // ;Internal NT
// #define LB_INSERTSTRING      0x0181      // ;Internal NT
// #define LB_DELETESTRING      0x0182      // ;Internal NT
// #define LB_SELITEMRANGEEX    0x0183      // ;Internal NT
// #define LB_RESETCONTENT      0x0184      // ;Internal NT
// #define LB_SETSEL            0x0185      // ;Internal NT
// #define LB_SETCURSEL         0x0186      // ;Internal NT
// #define LB_GETSEL            0x0187      // ;Internal NT
// #define LB_GETCURSEL         0x0188      // ;Internal NT
// #define LB_GETTEXT           0x0189      // ;Internal NT
// #define LB_GETTEXTLEN        0x018A      // ;Internal NT
// #define LB_GETCOUNT          0x018B      // ;Internal NT
// #define LB_SELECTSTRING      0x018C      // ;Internal NT
// #define LB_DIR               0x018D      // ;Internal NT
// #define LB_GETTOPINDEX       0x018E      // ;Internal NT
// #define LB_FINDSTRING        0x018F      // ;Internal NT
                                            // ;Internal NT
// #define LB_GETSELCOUNT       0x0190      // ;Internal NT
// #define LB_GETSELITEMS       0x0191      // ;Internal NT
// #define LB_SETTABSTOPS       0x0192      // ;Internal NT
// #define LB_GETHORIZONTALEXTENT  0x0193   // ;Internal NT
// #define LB_SETHORIZONTALEXTENT  0x0194   // ;Internal NT
// #define LB_SETCOLUMNWIDTH    0x0195      // ;Internal NT
// #define LB_ADDFILE           0x0196      // ;Internal NT
// #define LB_SETTOPINDEX       0x0197      // ;Internal NT
// #define LB_GETITEMRECT       0x0198      // ;Internal NT
// #define LB_GETITEMDATA       0x0199      // ;Internal NT
// #define LB_SETITEMDATA       0x019A      // ;Internal NT
// #define LB_SELITEMRANGE      0x019B      // ;Internal NT
// #define LB_SETANCHORINDEX    0x019C      // ;Internal NT
// #define LB_GETANCHORINDEX    0x019D      // ;Internal NT
// #define LB_SETCARETINDEX     0x019E      // ;Internal NT
// #define LB_GETCARETINDEX     0x019F      // ;Internal NT
                                            // ;Internal NT
// #define LB_SETITEMHEIGHT     0x01A0      // ;Internal NT
// #define LB_GETITEMHEIGHT     0x01A1      // ;Internal NT
// #define LB_FINDSTRINGEXACT   0x01A2      // ;Internal NT
// #define LBCB_CARETON         0x01A3      // ;Internal NT
// #define LBCB_CARETOFF        0x01A4      // ;Internal NT
// #define LB_SETLOCALE         0x01A5      // ;Internal NT
// #define LB_GETLOCALE         0x01A6      // ;Internal NT
// #define LB_SETCOUNT          0x01A7      // ;Internal NT
// #define LB_INITSTORAGE       0x01A8      // ;Internal NT 4.0
// #define LB_ITEMFROMPOINT     0x01A9      // ;Internal NT 4.0
// #define LB_INSERTSTRINGUPPER 0x01AA      // ;Internal NT 4.0
// #define LB_INSERTSTRINGLOWER 0x01AB      // ;Internal NT 4.0
// #define LB_ADDSTRINGUPPER    0x01AC      // ;Internal NT 4.0
// #define LB_ADDSTRINGLOWER    0x01AD      // ;Internal NT 4.0
#define LB_LAST_32              0x01AD      // ;Internal
                                            // ;Internal
#define MN_FIRST_32             0x01E0      // ;Internal
// #define MN_SETHMENU          0x01E0      // ;Internal NT
// #define MN_GETHMENU          0x01E1      // ;Internal NT
// #define MN_SIZEWINDOW        0x01E2      // ;Internal NT
// #define MN_OPENHIERARCHY     0x01E3      // ;Internal NT
// #define MN_CLOSEHIERARCHY    0x01E4      // ;Internal NT
// #define MN_SELECTITEM        0x01E5      // ;Internal NT
// #define MN_CANCELMENUS       0x01E6      // ;Internal NT
// #define MN_SELECTFIRSTVALIDITEM  0x01E7  // ;Internal NT
// #define MN_GETPPOPUPMENU     0x01EA      // ;Internal NT
// #define MN_FINDMENUWINDOWFROMPOINT   0x01EB  // ;Internal NT
// #define MN_SHOWPOPUPWINDOW   0x01EC      // ;Internal NT
// #define MN_BUTTONDOWN        0x01ED      // ;Internal NT
// #define MN_MOUSEMOVE         0x01EE      // ;Internal NT
// #define MN_BUTTONUP          0x01EF      // ;Internal NT
// #define MN_SETTIMERTOOPENHIERARCHY   0x01F0  // ;Internal NT
// #define MN_DBLCLK            0x01F1      // ;Internal NT 4.0
#define MN_LAST_32              0x01E7      // ;Internal

#define WM_MOUSEFIRST           0x0200
#define WM_MOUSEMOVE            0x0200
#define WM_LBUTTONDOWN          0x0201
#define WM_LBUTTONUP            0x0202
#define WM_LBUTTONDBLCLK        0x0203
#define WM_RBUTTONDOWN          0x0204
#define WM_RBUTTONUP            0x0205
#define WM_RBUTTONDBLCLK        0x0206
#define WM_MBUTTONDOWN          0x0207
#define WM_MBUTTONUP            0x0208
#define WM_MBUTTONDBLCLK        0x0209
#if (WINVER >= 0x040A)
#define WM_MOUSEWHEEL           0x020A
#define WM_MOUSELAST            0x020A
#define WHEEL_DELTA             120         /* Value for rolling one detent */
#define WHEEL_PAGESCROLL        (-1)        /* Scroll one page (UINT_MAX) */
#else
#define WM_MOUSELAST            0x0209
#endif

#define WM_PARENTNOTIFY         0x0210
#define WM_ENTERMENULOOP        0x0211      // ;Internal
#define WM_EXITMENULOOP         0x0212      // ;Internal
#define WM_NEXTMENU             0x0213      // ;Internal
#define WM_SIZING               0x0214      // ;Internal 4.0
#define WM_CAPTURECHANGED       0x0215      // ;Internal 4.0
#define WM_MOVING               0x0216      // ;Internal 4.0
#define WM_POWERBROADCAST	    0x0218	    // ;Internal 4.0
#define WM_DEVICECHANGE         0x0219      // ;Internal 4.0

#define WM_MDICREATE            0x0220
#define WM_MDIDESTROY           0x0221
#define WM_MDIACTIVATE          0x0222
#define WM_MDIRESTORE           0x0223
#define WM_MDINEXT              0x0224
#define WM_MDIMAXIMIZE          0x0225
#define WM_MDITILE              0x0226
#define WM_MDICASCADE           0x0227
#define WM_MDIICONARRANGE       0x0228
#define WM_MDIGETACTIVE         0x0229
#define WM_DROPOBJECT           0x022A      // ;Internal
#define WM_QUERYDROPOBJECT      0x022B      // ;Internal
#define WM_BEGINDRAG            0x022C      // ;Internal
#define WM_DRAGLOOP             0x022D      // ;Internal
#define WM_DRAGSELECT           0x022E      // ;Internal
#define WM_DRAGMOVE             0x022F      // ;Internal

#define WM_MDISETMENU           0x0230
#define WM_ENTERSIZEMOVE        0x0231      
#define WM_EXITSIZEMOVE         0x0232      
#define WM_DROPFILES            0x0233
#define WM_MDIREFRESHMENU       0x0234      // ;Internal NT
                                            // ;Internal JAPAN/KOREA
#define WM_KANJIFIRST           0x0280      // ;Internal JAPAN
#define WM_KANJILAST            0x029F      // ;Internal JAPAN
#define WM_HANGEULFIRST         0x0280      // ;Internal KOREA
#define WM_HANGEULLAST          0x029F      // ;Internal KOREA


#if (WINVER >= 0x40A)
#define WM_TRACKMOUSEEVENT_FIRST    0x02A0  // ;Internal
#define WM_NCMOUSEHOVER         0x02A0
#define WM_MOUSEHOVER           0x02A1
#define WM_NCMOUSELEAVE         0x02A2
#define WM_MOUSELEAVE           0x02A3
#define WM_TRACKMOUSEEVENT_LAST     0x02AF  // ;Internal
#endif // (WINVER >=0x40A)

#define WM_CUT                  0x0300
#define WM_COPY                 0x0301
#define WM_PASTE                0x0302
#define WM_CLEAR                0x0303
#define WM_UNDO                 0x0304
#define WM_RENDERFORMAT         0x0305
#define WM_RENDERALLFORMATS     0x0306
#define WM_DESTROYCLIPBOARD     0x0307
#define WM_DRAWCLIPBOARD        0x0308
#define WM_PAINTCLIPBOARD       0x0309
#define WM_SIZECLIPBOARD        0x030B
#define WM_VSCROLLCLIPBOARD     0x030A
#define WM_ASKCBFORMATNAME      0x030C
#define WM_CHANGECBCHAIN        0x030D
#define WM_HSCROLLCLIPBOARD     0x030E
#define WM_QUERYNEWPALETTE      0x030F

#define WM_PALETTEISCHANGING    0x0310
#define WM_PALETTEGONNACHANGE WM_PALETTEISCHANGING // ;Internal
#define WM_PALETTECHANGED       0x0311
#define WM_CHANGEPALETTE        WM_PALETTECHANGED // ;Internal
#define WM_HOTKEY               0x0312          // ;Internal NT
#define WM_SYSMENU              0x0313          // ;Internal
#define WM_HOOKMSG              0x0314          // ;Internal NT
#define WM_EXITPROCESS          0x0315          // ;Internal NT
#define WM_WAKETHREAD           0x0316          // ;Internal NT
#define WM_PRINT                0x0317
#define WM_PRINTCLIENT          0x0318

/* WinPad specific messages */
#define WM_HANDHELDFIRST        0x0358
#define WM_HANDHELDLAST         0x035F
                                                // ;Internal
/* Reserved for AFX */                          // ;Internal
#define WM_AFXFIRST             0x0360          // ;Internal
#define WM_AFXLAST              0x037F          // ;Internal

/* PenWindows specific messages */
#define WM_PENWINFIRST          0x0380
#define WM_PENWINLAST           0x038F

/* Coalescing messages */
#define WM_INTERNAL_COALESCE_FIRST  0x0390      // ;Internal
#define WM_COALESCE_FIRST           0x0390
#define WM_COALESCE_LAST            0x039F
#define WM_INTERNAL_COALESCE_LAST   0x03B0      // ;Internal

/* Multimedia messages */                       /* ;Internal */
#define WM_MM_RESERVED_FIRST    0x03A0          /* ;Internal */
#define WM_MM_RESERVED_LAST     0x03DF          /* ;Internal */
                                                /* ;Internal */
/* DDE messages */                              /* ;Internal */
#define WM_INTERNAL_DDE_FIRST   0x03E0          /* ;Internal */
/* #define WM_DDE_INITIATE         0x03E0 */    /* ;Internal */
/* #define WM_DDE_TERMINATE        0x03E1 */    /* ;Internal */
/* #define WM_DDE_ADVISE           0x03E2 */    /* ;Internal */
/* #define WM_DDE_UNADVISE         0x03E3 */    /* ;Internal */
/* #define WM_DDE_ACK              0x03E4 */    /* ;Internal */
/* #define WM_DDE_DATA             0x03E5 */    /* ;Internal */
/* #define WM_DDE_REQUEST          0x03E6 */    /* ;Internal */
/* #define WM_DDE_POKE             0x03E7 */    /* ;Internal */
/* #define WM_DDE_EXECUTE          0x03E8 */    /* ;Internal */
#define WM_INTERNAL_DDE_LAST    0x03EF          /* ;Internal */
                                                /* ;Internal */
/* CBT messages */                              /* ;Internal */
#define WM_CBT_RESERVED_FIRST   0x03F0          /* ;Internal */
#define WM_CBT_RESERVED_LAST    0x03FF          /* ;Internal */
                                                /* ;Internal */
#define WM_USER                 0x0400

/* NOTE: All messages between WM_APP and 0xBFFF are for exclusive use by apps */
#define WM_APP                  0x8000

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)
/*  wParam for WM_SIZING message  */
#define WMSZ_KEYSIZE        0           // ;Internal
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8
#define WMSZ_MOVE           9           // ;Internal
#define WMSZ_KEYMOVE        10          // ;Internal
#define WMSZ_SIZEFIRST      WMSZ_LEFT   // ;Internal

#endif  /* WINVER >= 0x400 */

#if (WINVER >= 0x040A)                            // ;Internal 4.1
                                                  // ;Internal 4.1
/* WM_MENUDODRAGDROP return value */              // ;Internal 4.1
#define MNDD_CONTINUE       0x0000                // ;Internal 4.1
#define MNDD_ENDMENU        0x0001                // ;Internal 4.1
                                                  // ;Internal 4.1
typedef struct tagMENUGETOBJECTINFO               // ;Internal 4.1
{                                                 // ;Internal 4.1
    DWORD  dwFlags;                               // ;Internal 4.1
    UINT   uPos;                                  // ;Internal 4.1
    HMENU  hmenu;                                 // ;Internal 4.1
    LPVOID riid;                                  // ;Internal 4.1
    LPVOID pvObj;                                 // ;Internal 4.1
} MENUGETOBJECTINFO, FAR * LPMENUGETOBJECTINFO;   // ;Internal 4.1
                                                  // ;Internal 4.1
/*                                                // ;Internal 4.1
 * MENUGETOBJECTINFO dwFlags values               // ;Internal 4.1
 */                                               // ;Internal 4.1
                                                  // ;Internal 4.1
#define MNGOF_TOPGAP         0x00000001           // ;Internal 4.1
#define MNGOF_BOTTOMGAP      0x00000002           // ;Internal 4.1
#define MNGOF_GAP            0x00000003           // ;Internal 4.1
#define MNGOF_CROSSBOUNDARY  0x00000004           // ;Internal 4.1
                                                  // ;Internal 4.1
/* WM_MENUGETOBJECT return value */               // ;Internal 4.1
#define MNGO_NOINTERFACE     0x00000000           // ;Internal 4.1
#define MNGO_NOERROR         0x00000001           // ;Internal 4.1
                                                  // ;Internal 4.1
#endif  /* WINVER >= 0x40A */                     // ;Internal 4.1

/****** Application termination *********************************************/

#ifdef tagWND   // ;Internal
BOOL    WINAPI PostQuitMessage(int);    // ;Internal
#else           // ;Internal
void    WINAPI PostQuitMessage(int);
#endif          // ;Internal

/****** Window class management *********************************************/

#ifdef tagWND                                                       /* ;Internal */
typedef LRESULT (CALLBACK* WNDPROC)(HWND_16, UINT, WPARAM, LPARAM); /* ;Internal */
#else                                                               /* ;Internal */
typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
#endif                                                              /* ;Internal */

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;
                                    /* ;Internal 4.0 */
typedef struct tagWNDCLASSEX        /* ;Internal 4.0 */
{                                   /* ;Internal 4.0 */
    DWORD       cbSize;             /* ;Internal 4.0 */
    DWORD       style;              /* ;Internal 4.0 */
    WNDPROC     lpfnWndProc;        /* ;Internal 4.0 */
    int         cbClsExtra;         /* ;Internal 4.0 */
    int         cbWndExtra;         /* ;Internal 4.0 */
    HINSTANCE   hInstance;          /* ;Internal 4.0 */
    HICON       hIcon;              /* ;Internal 4.0 */
    HCURSOR     hCursor;            /* ;Internal 4.0 */
    HBRUSH      hbrBackground;      /* ;Internal 4.0 */
    LPCSTR      lpszMenuName;       /* ;Internal 4.0 */
    LPCSTR      lpszClassName;      /* ;Internal 4.0 */
    HICON       hIconSm;            /* ;Internal 4.0 */
} WNDCLASSEX, FAR* LPWNDCLASSEX;    /* ;Internal 4.0 */

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
ATOM    WINAPI RegisterClassEx(const WNDCLASSEX FAR *);   /* ;Internal 4.0 */
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, LPWNDCLASS);
BOOL    WINAPI GetClassInfoEx(HINSTANCE, LPCSTR, LPWNDCLASSEX);   /* ;Internal 4.0 */
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008

#define CS_OEMCHARS         0x0010  // ;Internal
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_LVB              0x0400  // ;Internal
#define CS_SAVEBITS         0x0800

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#define CS_32BITCLASS       0x00008000  // ;Internal ONLY FOR USER.EXE
#define CS_SYSTEMCLASS      0x08000000  // ;Internal ONLY FOR USER.EXE
#define CS_SHORTCUT         0x10000000  // ;Internal ONLY FOR USER.EXE

#define CS_IME              0x00010000  // ;Internal for 4.0 IME.
#endif /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#if (WINVER >= 0x0400)                      // ;Internal 4.0
#define GCW_HICONSM         (-34)           // ;Internal 4.0
#define GCL_STYLE           GCW_STYLE       // ;Internal 4.0
#endif  /* WINVER >= 0x0400 */              // ;Internal 4.0
#endif  /* WINVER >= 0x030a */
#endif /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED           0x00000000L
#define WS_POPUP                0x80000000L
#define WS_CHILD                0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS         0x04000000L
#define WS_CLIPCHILDREN         0x02000000L

/* Generic window states */
#define WS_VISIBLE              0x10000000L
#define WS_DISABLED             0x08000000L

/* Main window states */
#define WS_MINIMIZE             0x20000000L
#define WS_MAXIMIZE             0x01000000L

/* Main window styles */
#define WS_CAPTION              0x00C00000L     /* WS_BORDER | WS_DLGFRAME */
#define WS_BORDERMASK           0x00C00000L     // ;Internal
#define WS_BORDER               0x00800000L
#define WS_DLGFRAME             0x00400000L
#define WS_VSCROLL              0x00200000L
#define WS_HSCROLL              0x00100000L
#define WS_SYSMENU              0x00080000L
#define WS_THICKFRAME           0x00040000L
#define WS_MINIMIZEBOX          0x00020000L
#define WS_MAXIMIZEBOX          0x00010000L

/* Control window styles */
#define WS_GROUP                0x00020000L
#define WS_TABSTOP              0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW     (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW          (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW          (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_DRAGOBJECT        0x00000002L     // ;Internal
#define WS_EX_NOPARENTNOTIFY    0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
                                                // ;Internal 4.0
#if (WINVER >= 0x0400)                          // ;Internal 4.0
#define WS_EX_MDICHILD          0x00000040L     // ;Internal NT
#define WS_EX_TOOLWINDOW        0x00000080L     // ;Internal 4.0
#define WS_EX_WINDOWEDGE        0x00000100L     // ;Internal 4.0
#define WS_EX_CLIENTEDGE        0x00000200L     // ;Internal 4.0
#define WS_EX_EDGEMASK          (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)   // ;Internal 4.0
#define WS_EX_CONTEXTHELP       0x00000400L     // ;Internal 4.0
                                                // ;Internal 4.0
#define WS_EX_RIGHT             0x00001000L     // ;Internal 4.0
#define WS_EX_LEFT              0x00000000L     // ;Internal 4.0
#define WS_EX_RTLREADING        0x00002000L     // ;Internal 4.0
#define WS_EX_LTRREADING        0x00000000L     // ;Internal 4.0
#define WS_EX_LEFTSCROLLBAR     0x00004000L     // ;Internal 4.0
#define WS_EX_RIGHTSCROLLBAR    0x00000000L     // ;Internal 4.0
#define WS_EX_CONTROLPARENT     0x00010000L     // ;Internal 4.0
#define WS_EX_STATICEDGE        0x00020000L     // ;Internal 4.0
#define WS_EX_APPWINDOW         0x00040000L     // ;Internal 4.0
#define WS_EX_ROUNDFRAME        0x00080000L     // ;Internal 4.1
#define WS_EX_ANSICREATOR       0x80000000L     // ;Internal NT
                                                // ;Internal 4.0
#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)   // ;Internal 4.0
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)    // ;Internal 4.0
                                                // ;Internal 4.0
#endif // ;Internal WINVER >= 0x0400
#endif  /* WINVER >= 0x030a */

#define WS_EX_VALID             0x800F7FFFL     /* ;Internal */
                                                /* ;Internal */
/* Obsolete style names */
#define WS_TILED                WS_OVERLAPPED
#define WS_ICONIC               WS_MINIMIZE
#define WS_SIZEBOX              WS_THICKFRAME
#define WS_TILEDWINDOW          WS_OVERLAPPEDWINDOW

#define WS_VALID                0xffff0000L     /* ;Internal */
                                                /* ;Internal */
#endif  /* NOWINSTYLES */

#if (WINVER >= 0x0400)                                      // ;Internal
/* WM_PRINT flags */                                        // ;Internal 4.0
#define PRF_CHECKVISIBLE    0x00000001L                     // ;Internal 4.0
#define PRF_NONCLIENT       0x00000002L                     // ;Internal 4.0
#define PRF_CLIENT          0x00000004L                     // ;Internal 4.0
#define PRF_ERASEBKGND      0x00000008L                     // ;Internal 4.0
#define PRF_CHILDREN        0x00000010L                     // ;Internal 4.0
#define PRF_OWNED           0x00000020L                     // ;Internal 4.0
                                                            // ;Internal 4.0
/* 3D border styles */                                      // ;Internal 4.0
#define BDR_RAISEDOUTER 0x0001                              // ;Internal 4.0
#define BDR_SUNKENOUTER 0x0002                              // ;Internal 4.0
#define BDR_RAISEDINNER 0x0004                              // ;Internal 4.0
#define BDR_SUNKENINNER 0x0008                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BDR_OUTER       0x0003                              // ;Internal 4.0
#define BDR_INNER       0x000c                              // ;Internal 4.0
#define BDR_RAISED      0x0005                              // ;Internal 4.0
#define BDR_SUNKEN      0x000a                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BDR_VALID       0x000F                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define EDGE_RAISED     (BDR_RAISEDOUTER | BDR_RAISEDINNER) // ;Internal 4.0
#define EDGE_SUNKEN     (BDR_SUNKENOUTER | BDR_SUNKENINNER) // ;Internal 4.0
#define EDGE_ETCHED     (BDR_SUNKENOUTER | BDR_RAISEDINNER) // ;Internal 4.0
#define EDGE_BUMP       (BDR_RAISEDOUTER | BDR_SUNKENINNER) // ;Internal 4.0
                                                            // ;Internal 4.0
/* Border flags */                                          // ;Internal 4.0
#define BF_LEFT         0x0001                              // ;Internal 4.0
#define BF_TOP          0x0002                              // ;Internal 4.0
#define BF_RIGHT        0x0004                              // ;Internal 4.0
#define BF_BOTTOM       0x0008                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_TOPLEFT      (BF_TOP | BF_LEFT)                  // ;Internal 4.0
#define BF_TOPRIGHT     (BF_TOP | BF_RIGHT)                 // ;Internal 4.0
#define BF_BOTTOMLEFT   (BF_BOTTOM | BF_LEFT)               // ;Internal 4.0
#define BF_BOTTOMRIGHT  (BF_BOTTOM | BF_RIGHT)              // ;Internal 4.0
#define BF_RECT         (BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM)  // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_DIAGONAL     0x0010                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_DIAGONAL_ENDTOPRIGHT     (BF_DIAGONAL | BF_TOP | BF_RIGHT)       // ;Internal 4.0
#define BF_DIAGONAL_ENDTOPLEFT      (BF_DIAGONAL | BF_TOP | BF_LEFT)        // ;Internal 4.0
#define BF_DIAGONAL_ENDBOTTOMLEFT   (BF_DIAGONAL | BF_BOTTOM | BF_LEFT)     // ;Internal 4.0
#define BF_DIAGONAL_ENDBOTTOMRIGHT  (BF_DIAGONAL | BF_BOTTOM | BF_RIGHT)    // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_MIDDLE       0x0800                              // ;Internal 4.0
#define BF_SOFT         0x1000                              // ;Internal 4.0
#define BF_ADJUST       0x2000                              // ;Internal 4.0
#define BF_FLAT         0x4000                              // ;Internal 4.0
#define BF_MONO         0x8000                              // ;Internal 4.0
                                                            // ;Internal 4.0
                                                            // ;Internal 4.0
BOOL WINAPI DrawEdge(HDC, LPRECT, UINT, UINT);              // ;Internal 4.0
                                                            // ;Internal 4.0
/* flags for DrawFrameControl */                            // ;Internal 4.0
#define DFC_CAPTION             1                           // ;Internal 4.0
#define DFC_MENU                2                           // ;Internal 4.0
#define DFC_SCROLL              3                           // ;Internal 4.0
#define DFC_BUTTON              4                           // ;Internal 4.0
#define DFC_POPUPMENU           5                           // ;Internal 4.0
#define DFC_CACHE               0xFFFF                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_CAPTIONCLOSE       0x0000                      // ;Internal 4.0
#define DFCS_CAPTIONMIN         0x0001                      // ;Internal 4.0
#define DFCS_CAPTIONMAX         0x0002                      // ;Internal 4.0
#define DFCS_CAPTIONRESTORE     0x0003                      // ;Internal 4.0
#define DFCS_CAPTIONHELP        0x0004                      // ;Internal 4.0
#define DFCS_INMENU             0x0040                      // ;Internal 4.0
#define DFCS_INSMALL            0x0080                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_MENUARROW          0x0000                      // ;Internal 4.0
#define DFCS_MENUCHECK          0x0001                      // ;Internal 4.0
#define DFCS_MENUBULLET         0x0002                      // ;Internal 4.0
#define DFCS_MENUARROWRIGHT     0x0004                      // ;Internal 4.0
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define DFCS_MENUARROWUP        0x0008                      // ;Internal 4.1
#define DFCS_MENUARROWDOWN      0x0010                      // ;Internal 4.1
#endif // (WINVER >= 0x40A)                                 // ;Internal 4.1
                                                            // ;Internal 4.0
#define DFCS_SCROLLMIN          0x0000                      // ;Internal 4.0
#define DFCS_SCROLLVERT         0x0000                      // ;Internal 4.0
#define DFCS_SCROLLMAX          0x0001                      // ;Internal 4.0
#define DFCS_SCROLLHORZ         0x0002                      // ;Internal 4.0
#define DFCS_SCROLLLINE         0x0004                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_SCROLLUP           0x0000                      // ;Internal 4.0
#define DFCS_SCROLLDOWN         0x0001                      // ;Internal 4.0
#define DFCS_SCROLLLEFT         0x0002                      // ;Internal 4.0
#define DFCS_SCROLLRIGHT        0x0003                      // ;Internal 4.0
#define DFCS_SCROLLCOMBOBOX     0x0005                      // ;Internal 4.0
#define DFCS_SCROLLSIZEGRIP     0x0008                      // ;Internal 4.0
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010							// ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_BUTTONCHECK        0x0000                      // ;Internal 4.0
#define DFCS_BUTTONRADIOIMAGE   0x0001                      // ;Internal 4.0
#define DFCS_BUTTONRADIOMASK    0x0002                      // ;Internal 4.0
#define DFCS_BUTTONRADIO        0x0004                      // ;Internal 4.0
#define DFCS_BUTTON3STATE       0x0008                      // ;Internal 4.0
#define DFCS_BUTTONPUSH         0x0010                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_CACHEICON          0x0000                      // ;Internal 4.0
#define DFCS_CACHEBUTTONS       0x0001                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_INACTIVE           0x0100                      // ;Internal 4.0
#define DFCS_PUSHED             0x0200                      // ;Internal 4.0
#define DFCS_CHECKED            0x0400                      // ;Internal 4.0
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define DFCS_TRANSPARENT        0x0800                      // ;Internal 4.1
#define DFCS_HOT                0x1000                      // ;Internal 4.1
#endif // (WINVER >= 0x40A)                                 // ;Internal 4.1
#define DFCS_ADJUSTRECT         0x2000                      // ;Internal 4.0
#define DFCS_FLAT               0x4000                      // ;Internal 4.0
#define DFCS_MONO               0x8000                      // ;Internal 4.0
                                                            // ;Internal 4.0
BOOL    WINAPI DrawFrameControl(HDC, LPRECT, UINT, UINT);   // ;Internal 4.0
                                                            // ;Internal 4.0
/* flags for DrawCaption */                                 // ;Internal 4.0
#define DC_ACTIVE           0x0001                          // ;Internal 4.0
#define DC_SMALLCAP         0x0002                          // ;Internal 4.0
#define DC_ICON             0x0004                          // ;Internal 4.0
#define DC_TEXT             0x0008                          // ;Internal 4.0
#define DC_INBUTTON         0x0010                          // ;Internal 4.0
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define DC_GRADIENT         0x0020                          // ;Internal 4.1
#endif // (WINVER >=0x40A)                                  // ;Internal 4.1
#define DC_NOVISIBLE        0x0800                          // ;Internal
#define DC_BUTTONS          0x1000                          // ;Internal
#define DC_NOSENDMSG        0x2000                          // ;Internal
#define DC_CENTER           0x4000                          // ;Internal
#define DC_FRAME            0x8000                          // ;Internal
#define DC_CAPTION          (DC_ICON | DC_TEXT | DC_BUTTONS)// ;Internal
#define DC_NC               (DC_CAPTION | DC_FRAME)         // ;Internal 
                                                            // ;Internal 4.0
BOOL    WINAPI DrawCaption(HWND, HDC, LPRECT, UINT);        // ;Internal 4.0
BOOL    WINAPI DrawCaptionTemp(HWND, HDC, LPRECT, HFONT, HICON, LPSTR, UINT); // ;Internal 4.0
                                                            // ;Internal 4.0
BOOL    WINAPI  PlaySoundEvent(int idSound);                // ;Internal
                                                            // ;Internal 4.0
#define IDANI_OPEN          1                               // ;Internal 4.0
#define IDANI_CLOSE         2                               // ;Internal 4.0
#define IDANI_CAPTION       3                               // ;Internal 4.0
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define IDANI_BORDER        4                               // ;Internal 4.1
#define IDANI_SLIDE         5                               // ;Internal 4.1
#endif // (WINVER >=0x40A)                                  // ;Internal 4.1
BOOL    WINAPI  DrawAnimatedRects(HWND, int, LPCRECT, LPCRECT);   // ;Internal 4.0
#endif // WINVER >= VER40                                   // ;Internal


#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define PAS_IN          0x0001                              // ;Internal 4.1
#define PAS_OUT         0x0002                              // ;Internal 4.1
#define PAS_LEFT        0x0004                              // ;Internal 4.1
#define PAS_RIGHT       0x0008                              // ;Internal 4.1
#define PAS_UP          0x0010                              // ;Internal 4.1
#define PAS_DOWN        0x0020                              // ;Internal 4.1
#define PAS_HORZ        (PAS_LEFT | PAS_RIGHT)              // ;Internal
#define PAS_VERT        (PAS_UP | PAS_DOWN)                 // ;Internal 
#endif // (WINVER >=0x40A)                                  // ;Internal 4.1

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define HWND_MESSAGE        ((HWND)-3)
#endif // (WINVER >=0x40A)                                  // ;Internal 4.1

#ifdef tagWND                           // ;Internal
BOOL    WINAPI IsWindow(HWND_16);       // ;Internal
#else                                   // ;Internal
BOOL    WINAPI IsWindow(HWND);
#endif // tagWND                        // ;Internal

#ifdef tagWND                   /* ;Internal */
HWND_16  WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND_16, HMENU_16, HINSTANCE, void FAR*);          /* ;Internal */
HWND_16  WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND_16, HMENU_16, HINSTANCE, void FAR*); /* ;Internal */
#else                           /* ;Internal */
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
#endif                          /* ;Internal */

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
#ifdef tagWND                   /* ;Internal */
    HMENU_16  hMenu;            /* ;Internal */
    HWND_16   hwndParent;       /* ;Internal */
#else                           /* ;Internal */
    HMENU     hMenu;
    HWND      hwndParent;
#endif                          /* ;Internal */
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT, FAR * LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

#ifdef tagWND                           /* ;Internal */
HWND_16    WINAPI GetParent(HWND);      /* ;Internal */
HWND_16    WINAPI SetParent(HWND, HWND);/* ;Internal */
#else                                   /* ;Internal */
HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);
#endif                                  /* ;Internal */

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);
#if (WINVER >= 0x0400)                  /* ;Internal 4.0 */
BOOL    WINAPI ShowWindowAsync(HWND, int);  /* ;Internal 4.0 */
#endif                                  /* ;Internal 4.0 */

#if (WINVER >= 0x040A)                             /* ;Internal 4.1 */
BOOL    WINAPI AnimateWindow(HWND, DWORD, DWORD);  /* ;Internal 4.1 */
#endif                                             /* ;Internal 4.1 */

#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           SW_SHOWNORMAL
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         SW_SHOWMAXIMIZED
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10      /* ;Internal NT */
#define SW_MAX              10      /* ;Internal */

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         SW_HIDE
#define SHOW_OPENWINDOW     SW_SHOWNORMAL
#define SHOW_ICONWINDOW     SW_SHOWMINIMIZED
#define SHOW_FULLSCREEN     SW_SHOWMAXIMIZED
#define SHOW_OPENNOACTIVATE SW_SHOWNOACTIVATE

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif /* NOSHOWWINDOW */

#if (WINVER >=0x40A)                                        // ;Internal
//                                                          // ;Internal
// AnimateWindow() Commands                                 // ;Internal
//                                                          // ;Internal
#define AW_HOR_POSITIVE             0x00000001              // ;Internal
#define AW_HOR_NEGATIVE             0x00000002              // ;Internal
#define AW_VER_POSITIVE             0x00000004              // ;Internal
#define AW_VER_NEGATIVE             0x00000008              // ;Internal
#define AW_CENTER                   0x00000010              // ;Internal
#define AW_HIDE                     0x00010000              // ;Internal
#define AW_ACTIVATE                 0x00020000              // ;Internal
#define AW_SLIDE                    0x00040000              // ;Internal
#define AW_BLEND                    0x00080000              // ;Internal
                                                            // ;Internal
#define AW_VALID                    (AW_HOR_POSITIVE |\
                                     AW_HOR_NEGATIVE |\
                                     AW_VER_POSITIVE |\
                                     AW_VER_NEGATIVE |\
                                     AW_CENTER       |\
                                     AW_HIDE         |\
                                     AW_ACTIVATE     |\
                                     AW_SLIDE        |\
                                     AW_BLEND)              // ;Internal
#endif //  (WINVER >=0x40A)                                 // ;Internal


/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

/* Window text */
#ifdef tagWND   // ;Internal
BOOL    WINAPI SetWindowText(HWND, LPCSTR); // ;Internal
DWORD   WINAPI GetWindowTextLength(HWND);   // ;Internal
#else           // ;Internal
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowTextLength(HWND);
#endif          // ;Internal
int     WINAPI GetWindowText(HWND, LPSTR, int);

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC     (-4)
#define GWW_HINSTANCE   (-6)
#define GWW_HWNDPARENT  (-8)
#define GWW_ID          (-12)
#define GWL_STYLE       (-16)
#define GWL_EXSTYLE     (-20)
#define GWL_USERDATA    (-21)       /* ;Internal NT */
#endif  /* NOWINOFFSETS */
                                        /* ;Internal NT */
// BOOL WINAPI  IsWindowUnicode(HWND);  /* ;Internal NT */

#ifdef FE_IME                            // ;Internal IMM
#define SWIMC_SET             (0)        // ;internal IMM
#define SWIMC_RESET           (1)        // ;internal IMM
#define SWIMC_HIMC            (2)        // ;internal IMM
#define SWIMC_HSAVEDIMC       (3)        // ;internal IMM
#define SWIMC_RESETFORTHISIMC (4)        // ;internal IMM
#define SWIMC_SETNULLTOIMC    (5)        // ;internal IMM
#endif                                   // ;Internal IMM

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT     ((int)0x8000)

#ifdef tagWND       // ;Internal
BOOL    WINAPI GetClientRect(HWND, LPRECT);     // ;Internal
BOOL    WINAPI GetWindowRect(HWND, LPRECT);     // ;Internal
#else               // ;Internal
void    WINAPI GetClientRect(HWND, LPRECT);
void    WINAPI GetWindowRect(HWND, LPRECT);
#endif              // ;Internal

//  Multiple Monitor APIs                       // ;Internal
#if (WINVER >= 0x040A)                          // ;Internal
                                                // ;Internal
#ifdef tagWND                                   // ;Internal
#define HMONITOR    PMONITOR                    // ;Internal
#else                                           // ;Internal
DECLARE_HANDLE(HMONITOR);                       // ;Internal
#endif // tagWND                                // ;Internal
                                                // ;Internal
#define MONITOR_DEFAULTTONULL       0x0000      // ;Internal
#define MONITOR_DEFAULTTOPRIMARY    0x0001      // ;Internal
#define MONITOR_DEFAULTTONEAREST    0x0002      // ;Internal
#define MONITOR_VALID               0x0003      // ;Internal
                                                // ;Internal
#define MONITORINFOF_PRIMARY        0x00000001  // ;Internal
                                                // ;Internal
HMONITOR WINAPI MonitorFromPoint(POINT, UINT);  // ;Internal
HMONITOR WINAPI MonitorFromRect(LPCRECT, UINT); // ;Internal
HMONITOR WINAPI MonitorFromWindow(HWND, UINT);  // ;Internal
                                                // ;Internal
                                                // ;Internal
typedef struct tagMONITORINFO                   // ;Internal
{                                               // ;Internal
    DWORD   cbSize;                             // ;Internal
    RECTL   rcMonitor;                          // ;Internal
    RECTL   rcWork;                             // ;Internal
    DWORD   dwFlags;                            // ;Internal
} MONITORINFO, FAR * LPMONITORINFO;             // ;Internal
                                                // ;Internal
typedef struct tagMONITORINFOEX                 // ;Internal
{                                               // ;Internal
    MONITORINFO mi;                             // ;Internal
    char        szDeviceName[32];               // ;Internal
} MONITORINFOEX, FAR * LPMONITORINFOEX;         // ;Internal
                                                // ;Internal
BOOL WINAPI GetMonitorInfo(HMONITOR, LPMONITORINFO);    // ;Internal
                                                // ;Internal
                                                // ;Internal
typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM); // ;Internal
BOOL WINAPI EnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM); // ;Internal
#endif // WINVER >= 0x040A                      // ;Internal


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002
#define WPF_VALID               0x0003  /* ;Internal */

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                                       // ;Internal
BOOL    WINAPI SetWindowPos(HWND, HWNDC, int, int, int, int, UINT); // ;Internal
#else                                                               // ;Internal
BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);
#endif                                                              // ;Internal
                                                                    // ;Internal
/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOCLIENTSIZE    0x0800  // Client didn't resize         ;Internal
#define SWP_NOCLIENTMOVE    0x1000  // Client didn't move           ;Internal
#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000
#define SWP_ASYNCWINDOWPOS  0x4000  /* ;Internal NT BOGUS - make sure this is the same as NT! */
#define SWP_STATECHANGE     0x8000  /* ;Internal Force size, move messages */

/* Don't do any drawing or erasing */                       /* ;Internal */
#define SWP_DEFERDRAWING    SWP_DEFERERASE                  /* ;Internal */
#define SWP_CREATESPB       0x4000                          /* ;Internal */
                                                            /* ;Internal */
#define SWP_CHANGEMASK (SWP_NOSIZE | SWP_NOMOVE |           /* ;Internal */ \
                        SWP_NOZORDER | SWP_FRAMECHANGED |   /* ;Internal */ \
                        SWP_SHOWWINDOW | SWP_HIDEWINDOW |   /* ;Internal */ \
                        SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)/* ;Internal */
                                                            /* ;Internal */
#define SWP_NOCHANGE   (SWP_NOSIZE | SWP_NOMOVE |           /* ;Internal */ \
                        SWP_NOZORDER | SWP_NOCLIENTSIZE |   /* ;Internal */ \
                        SWP_NOCLIENTMOVE)                   /* ;Internal */
#define SWP_VALID       0x67ff                              /* ;Internal */
                                                            /* ;Internal */
/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)
#define HWND_GROUPTOTOP     HWND_TOPMOST    /* ;Internal */


#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
#ifdef tagWND                                                               // ;Internal
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWNDC, int, int, int, int, UINT); // ;Internal
#else                                                                       // ;Internal
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
#endif                                                                      // ;Internal
BOOL    WINAPI EndDeferWindowPos(HDWP);
#if (WINVER >= 0x0400)                              // ;Internal
BOOL    WINAPI EndDeferWindowPosEx(HDWP, BOOL);     // ;Internal NT
#endif                                              // ;Internal

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
#ifdef tagWND                   /* ;Internal */
    HWND_16 hwnd;               /* ;Internal */
    HWND_16 hwndInsertAfter;    /* ;Internal */
#else                           /* ;Internal */
    HWND    hwnd;
    HWND    hwndInsertAfter;
#endif                          /* ;Internal */
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(LPRECT, DWORD, BOOL);
#ifdef tagWND   // ;Internal
BOOL    WINAPI AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD);  // ;Internal
#else           // ;Internal
void    WINAPI AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD);
#endif          // ;Internal

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
#if (WINVER >= 0x40A)
    POINT ptMinSize;
#else
    POINT ptReserved;
#endif // (WINVER >= 0x40A)
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, FAR * LPMINMAXINFO;

BOOL    WINAPI FlashWindow(HWND, BOOL);

#if (WINVER >= 0x40A)
#define FLASHW_STOP         0                                // ;internal 4.1
#define FLASHW_CAPTION      0x00000001                       // ;internal 4.1
#define FLASHW_TRAY         0x00000002                       // ;internal 4.1
#define FLASHW_ALL          (FLASHW_CAPTION | FLASHW_TRAY)   // ;internal 4.1
#define FLASHW_TIMER        0x00000004                       // ;internal 4.1
#define FLASHW_FLASHNOFG    0x00000008                       // ;internal 4.1
#define FLASHW_TIMERNOFG    0x0000000C                       // ;internal 4.1
#define FLASHW_VALID        (FLASHW_ALL | FLASHW_TIMERNOFG)  // ;internal 4.1
#define FLASHW_KILLTIMER    0x40000000                       // ;internal 4.1
#define FLASHW_ON           0x80000000                       // ;internal 4.1
#endif


#ifdef tagWND   // ;Internal
BOOL    WINAPI ShowOwnedPopups(HWND, BOOL); // ;Internal
#else           // ;Internal
void    WINAPI ShowOwnedPopups(HWND, BOOL);
#endif          // ;Internal

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
#ifdef tagWND   // ;Internal
BOOL    WINAPI CloseWindow(HWND);   // ;Internal
#else           // ;Internal
void    WINAPI CloseWindow(HWND);
#endif          // ;Internal
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

#ifdef tagWND   // ;Internal
BOOL    WINAPI ClientToScreen(HWND, LPPOINT);   // ;Internal
BOOL    WINAPI ScreenToClient(HWND, LPPOINT);   // ;Internal
#else           // ;Internal
void    WINAPI ClientToScreen(HWND, LPPOINT);
void    WINAPI ScreenToClient(HWND, LPPOINT);
#endif          // ;Internal

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                               /* ;Internal */
HWND_16    WINAPI WindowFromPoint(POINT);                   /* ;Internal */
HWND_16    WINAPI ChildWindowFromPoint(HWND, POINT);        /* ;Internal */
#else                                                       /* ;Internal */
HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);
#endif                                                      /* ;Internal */
                                                            /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                                      /* ;Internal 4.0 */
#define CWP_ALL             0x0000                          /* ;Internal 4.0 */
#define CWP_SKIPINVISIBLE   0x0001                          /* ;Internal 4.0 */
#define CWP_SKIPDISABLED    0x0002                          /* ;Internal 4.0 */
#define CWP_SKIPTRANSPARENT 0x0004                          /* ;Internal 4.0 */
#define CWP_VALID           0x0007                          /* ;Internal 4.0 */
                                                            /* ;Internal 4.0 */
#ifdef tagWND                                               /* ;Internal 4.0 */
HWND_16 WINAPI ChildWindowFromPointEx(HWND, POINT, UINT);   /* ;Internal 4.0 */
#else                                                       /* ;Internal 4.0 */
HWND    WINAPI ChildWindowFromPointEx(HWND, POINT, UINT);   /* ;Internal 4.0 */
#endif                                                      /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                               /* ;Internal 4.0 */

/****** Window query and enumeration ****************************************/

#ifdef tagWND                                               /* ;Internal */
HWND_16 WINAPI GetDesktopWindow(void);                      /* ;Internal */
HWND_16 WINAPI FindWindow(LPCSTR, LPCSTR);                  /* ;Internal */
HWND_16 WINAPI FindWindowEx(HWND, HWND, LPCSTR, LPCSTR);    /* ;Internal 4.0 */
HWND_16 WINAPI GetShellWindow(void);                        /* ;Internal 4.0 */
BOOL    WINAPI SetShellWindow(HWND_16);                     /* ;Internal 4.0 */
#else                                                       /* ;Internal */
HWND    WINAPI GetDesktopWindow(void);
HWND    WINAPI FindWindow(LPCSTR, LPCSTR);
HWND    WINAPI FindWindowEx(HWND, HWND, LPCSTR, LPCSTR);    /* ;Internal 4.0 */
HWND    WINAPI GetShellWindow(void);                        /* ;Internal 4.0 */
BOOL    WINAPI SetShellWindow(HWND);                        /* ;Internal 4.0 */
#endif                                                      /* ;Internal */

#ifdef STRICT
#ifdef tagWND                                               /* ;Internal */
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND_16, LPARAM);      /* ;Internal */
#else                                                       /* ;Internal */
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#endif                                                      /* ;Internal */
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);
#if (WINVER >= 0x0400)                                          // ;Internal 4.0
BOOL    WINAPI EnumWindowsEx(DWORD, HWND, WNDENUMPROC, LPARAM); // ;Internal 4.0
#endif                                                          // ;Internal 4.0


#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetTopWindow(HWND);              /* ;Internal */
HWND_16 WINAPI GetWindow(HWND, UINT);           /* ;Internal */
HWND_16 WINAPI GetNextWindow(HWND, UINT);       /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetTopWindow(HWND);
HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);
#endif                                          /* ;Internal */

/* GetWindow() constants */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5
#define GW_ENABLEDPOPUP     6 /* ;Internal */
#define GW_MAX              6 /* ;Internal */
                                                /* ;Internal */
#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetNextQueueWindow(HWND, int);   /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetNextQueueWindow(HWND, int);   /* ;Internal */
#endif                                          /* ;Internal */

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);
                                                /* ;Internal 4.0 */
#if (WINVER >= 0x400)                           /* ;Internal 4.0 */
BOOL    WINAPI SetPropEx(HWND, LPCSTR, DWORD);  /* ;Internal 4.0 */
DWORD   WINAPI GetPropEx(HWND, LPCSTR);         /* ;Internal 4.0 */
DWORD   WINAPI RemovePropEx(HWND, LPCSTR);      /* ;Internal 4.0 */
#endif    /* (WINVER >= 0x400) */               /* ;Internal 4.0 */

#ifdef STRICT
#ifdef tagWND                                                   /* ;Internal */
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND_16, LPCSTR, HANDLE); /* ;Internal */
#else                                                           /* ;Internal */
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#endif                                                          /* ;Internal */
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_NORESETATTRS    0x00000004L     // ;Internal
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L
#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L
#define DCX_EXCLUDEUPDATE   0x00000100L     // ;Internal
#define DCX_INTERSECTUPDATE 0x00000200L     // ;Internal
#define DCX_LOCKWINDOWUPDATE 0x00000400L
#define DCX_INVALID         0x00000800L     // ;Internal
#define DCX_INUSE           0x00001000L     // ;Internal
#define DCX_SAVEDRGNINVALID 0x00002000L     // ;Internal
#if (WINVER >= 0x040A)                      // ;Internal
#define DCX_MONITOR         0x00004000L     // ;Internal
#endif  // (WINVER >=0x040A)                // ;Internal
#define DCX_USESTYLE        0x00010000L
#define DCX_NEEDFONT        0x00020000L     // ;Internal OBSOLETE
#define DCX_NODELETERGN     0x00040000L     // ;Internal
#define DCX_NOCLIPCHILDREN  0x00080000L     // ;Internal
#define DCX_NORECOMPUTE     0x00100000L     // ;Internal
#define DCX_VALIDATE        0x00200000L     // ;Internal
                                            // ;Internal
#define DCX_MATCHMASK   (DCX_WINDOW | DCX_CLIPCHILDREN  |   /* ;Internal */ \
                        DCX_CACHE | DCX_CLIPSIBLINGS |      /* ;Internal */ \
                        DCX_LOCKWINDOWUPDATE)               /* ;Internal */
#define DCX_VALID           0x000104fbL                     /* ;Internal */
#endif  /* WINVER >= 0x030a */
                                    /* ;Internal NT */
#if (WINVER >= 0x0400)              /* ;Internal NT */
#ifdef tagWND                       /* ;Internal NT */
HWND_16 WINAPI WindowFromDC(HDC);   /* ;Internal NT */
#else                               /* ;Internal NT */
HWND    WINAPI WindowFromDC(HDC);   /* ;Internal NT */
#endif                              /* ;Internal NT */
#endif  /* WINVER >= 0x0400 */	    /* ;Internal NT */

/****** Window repainting ***************************************************/

// /* WM_SYNCTASK commands */       /* ;Internal NT */
// #define ST_BEGINSWP         0    /* ;Internal NT */
// #define ST_ENDSWP           1    /* ;Internal NT */

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC  hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[16];
//  BYTE rgbReserved[32];        /* ;Internal NT */
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI  BeginPaint(HWND, LPPAINTSTRUCT);
#ifdef tagWND   // ;Internal
BOOL    WINAPI  EndPaint(HWND, const PAINTSTRUCT FAR*); // ;Internal
#else           // ;Internal
void    WINAPI  EndPaint(HWND, const PAINTSTRUCT FAR*);
#endif          // ;Internal

#ifdef tagWND   // ;Internal
BOOL    WINAPI  UpdateWindow(HWND); // ;Internal
#else           // ;Internal
void    WINAPI  UpdateWindow(HWND);
#endif          // ;Internal

int     WINAPI  ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, LPRECT, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

#ifdef tagWND   // ;Internal
BOOL    WINAPI InvalidateRect(HWND, LPCRECT, BOOL);     // ;Internal
BOOL    WINAPI ValidateRect(HWND, LPCRECT);             // ;Internal
BOOL    WINAPI InvalidateRgn(HWND, HRGN, BOOL);         // ;Internal
BOOL    WINAPI ValidateRgn(HWND, HRGN);                 // ;Internal
#else           // ;Internal
void    WINAPI InvalidateRect(HWND, LPCRECT, BOOL);
void    WINAPI ValidateRect(HWND, LPCRECT);
void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);
#endif          // ;Internal
int     WINAPI GetWindowRgn(HWND, HRGN);        // ;Internal 4.0
int     WINAPI SetWindowRgn(HWND, HRGN, BOOL);  // ;Internal 4.0

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, LPCRECT lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE      0x0001
#define RDW_INTERNALPAINT   0x0002
#define RDW_ERASE           0x0004
#define RDW_VALIDATE        0x0008

#define RDW_NOINTERNALPAINT 0x0010
#define RDW_NOERASE         0x0020
#define RDW_NOCHILDREN      0x0040
#define RDW_ALLCHILDREN     0x0080

#define RDW_UPDATENOW       0x0100
#define RDW_ERASENOW        0x0200
#define RDW_FRAME           0x0400
#define RDW_NOFRAME         0x0800
                                                                   // ;Internal
#define RDW_REDRAWWINDOW        0x1000  // ;Internal Called from RedrawWindow()
#define RDW_SUBTRACTSELF        0x2000  // ;Internal Subtract self from hrgn
#define RDW_COPYRGN             0x4000  // ;Internal Copy the passed-in region
#define RDW_IGNOREUPDATEDIRTY   0x8000  // ;Internal ignore WFUPDATEDIRTY

#define RDW_VALID           0x0fff                                  /* ;Internal */
#endif  /* WINVER >= 0x030a */
                                                        /* ;Internal 4.0 */
BOOL WINAPI PaintDesktop(HDC hdc);                      /* ;Internal 4.0 */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, LPCRECT, LPCRECT);
BOOL    WINAPI ScrollDC(HDC, int, int, LPCRECT, LPCRECT, HRGN, LPRECT);

#if (WINVER >= 0x030a)
int WINAPI ScrollWindowEx(HWND, int, int, LPCRECT, LPCRECT, HRGN, LPRECT, UINT);

#define SW_SCROLLCHILDREN       0x0001
#define SW_INVALIDATE           0x0002
#define SW_ERASE                0x0004
#if (WINVER >= 0x40A)
#define SW_SMOOTHSCROLL         0x0010
#endif
#define SW_SCROLLWINDOW         0x8000  /* ;Internal */
#define SW_VALID                0x8017  /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400
                                            /* ;Internal */
#define WVR_MINVALID        WVR_ALIGNTOP    /* ;Internal */
#define WVR_MAXVALID        WVR_VALIDRECTS  /* ;Internal */

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;


/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT          /* ;Internal */
#define HTSIZELAST          HTBOTTOMRIGHT   /* ;Internal */
#define HTOBJECT            19              // ;Internal 4.0
#define HTCLOSE             20              // ;Internal 4.0
#define HTHELP              21              // ;Internal 4.0
#define HTMAX               21              // ;Internal

//***** Drag-and-drop support *********************************    ;Internal
                                                                // ;Internal
// The rest of this section was formerly in userproc.h          // ;Internal
                                                                // ;Internal
typedef struct _dropstruct                                      // ;Internal
{                                                               // ;Internal
#ifdef tagWND                                                   // ;Internal
    HWND_16  hwndSource;                                        // ;Internal
    HWND_16  hwndSink;                                          // ;Internal
#else                                                           // ;Internal
    HWND hwndSource;                                            // ;Internal
    HWND hwndSink;                                              // ;Internal
#endif                                                          // ;Internal
    WORD  wFmt;                                                 // ;Internal
    DWORD dwData;                                               // ;Internal
    POINT ptDrop;                                               // ;Internal
    DWORD dwControlData;                                        // ;Internal
} DROPSTRUCT;                                                   // ;Internal
                                                                // ;Internal
typedef DROPSTRUCT FAR * LPDROPSTRUCT;                          // ;Internal
                                                                // ;Internal
#define DOF_EXECUTABLE      0x8001                              // ;Internal
#define DOF_DOCUMENT        0x8002                              // ;Internal
#define DOF_DIRECTORY       0x8003                              // ;Internal
#define DOF_MULTIPLE        0x8004                              // ;Internal
#define DOF_PROGMAN         0x0001                              // ;Internal
#define DOF_SHELLDATA       0x0002                              // ;Internal
                                                                // ;Internal
// special responses to WM_DROPOBJECT                           // ;Internal
// DO_DROPFILE  -> send a WM_DROPFILES message                  // ;Internal
//  DO_PRINTFILE -> print the files being dragged               // ;Internal
#define DO_DROPFILE         0x454C4946L                         // ;Internal
#define DO_PRINTFILE        0x544E5250L                         // ;Internal
                                                                // ;Internal
WORD API GetInternalWindowPos(HWND,LPRECT,LPPOINT);             // ;Internal
BOOL API SetInternalWindowPos(HWND,WORD,LPRECT,LPPOINT);        // ;Internal
                                                                // ;Internal
#ifdef tagWND                                                   // ;Internal
// DragObject goes through layer!                               // ;Internal
LRESULT API DragObject(HWND, HWND, WORD, DWORD, HANDLE);        // ;Internal
BOOL    API DragDetect(HWND_16, POINT);                         // ;Internal
                                                                // ;Internal
// FillWindow goes through layer!                               // ;Internal
void    CALLBACK FillWindow(HWND, HWND, HDC, HBRUSH);           // ;Internal
#else                                                           // ;Internal
// DragObject goes through layer!                               // ;Internal
LRESULT API DragObject(HWND, HWND, WORD, DWORD, HANDLE);        // ;Internal
BOOL    API DragDetect(HWND, POINT);                            // ;Internal
                                                                // ;Internal
void    CALLBACK FillWindow(HWND, HWND, HDC, HBRUSH);           // ;Internal
#endif                                                          // ;Internal
                                                                // ;Internal
/****** Window activation ***************************************************/

#ifdef tagWND                                       // ;Internal
HWND_16 WINAPI SetActiveWindow(HWND);               // ;Internal
HWND_16 WINAPI GetActiveWindow(void);               // ;Internal
HWND_16 WINAPI GetLastActivePopup(HWND);            // ;Internal
BOOL    WINAPI SetForegroundWindow(HWND);           // ;Internal NT
HWND_16 WINAPI GetForegroundWindow(void);           // ;Internal NT
#else                                               // ;Internal
HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);
HWND    WINAPI GetLastActivePopup(HWND);
#if (WINVER >= 0x0400)                              // ;Internal
BOOL WINAPI SetForegroundWindow(HWND);              // ;Internal NT
HWND WINAPI GetForegroundWindow(void);              // ;Internal NT
#endif                                              // ;Internal
#endif                                              // ;Internal

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

//***** Server *********************************************    ;Internal NT
//                                                              ;Internal NT
// /* Desktops */                                               ;Internal NT
// #define DESKTOP_ENUMWINDOWS      0x0001L                     ;Internal NT
// #define DESKTOP_CREATEWINDOW     0x0002L                     ;Internal NT
// #define DESKTOP_CREATEMENU       0x0004L                     ;Internal NT
// #define DESKTOP_HOOKCONTROL      0x0008L                     ;Internal NT
// #define DESKTOP_JOURNALRECORD    0x0010L                     ;Internal NT
// #define DESKTOP_JOURNALPLAYBACK  0x0020L                     ;Internal NT
// #define DESKTOP_ENUMERATE        0x0040L                     ;Internal NT
//                                                              ;Internal NT
// HDESK    WINAPI  GetThreadDesktop(DWORD idThread);           ;Internal NT
//                                                              ;Internal NT
// /* WinStations */                                            ;Internal NT
// #define WINSTA_ENUMDESKTOPS      0x0001L                     ;Internal NT
// #define WINSTA_READATTRIBUTES    0x0002L                     ;Internal NT
// #define WINSTA_ACCESSCLIPBOARD   0x0004L                     ;Internal NT
// #define WINSTA_CREATEDESKTOP     0x0008L                     ;Internal NT
// #define WINSTA_WRITEATTRIBUTES   0x0010L                     ;Internal NT
// #define WINSTA_ACCESSGLOBALATOMS 0x0020L                     ;Internal NT
// #define WINSTA_EXITWINDOWS       0x0040L                     ;Internal NT
// #define WINSTA_ENUMERATE         0x0100L                     ;Internal NT
// #define WINSTA_READSCREEN        0x0200L                     ;Internal NT
//                                                              ;Internal NT
// HWINSTA  WINAPI  GetProcessWindowStation();                  ;Internal NT
//                                                              ;Internal NT
// /* Security */                                               ;Internal NT
// #define WIN_ACCESSWINDOW         0x0001L                     ;Internal NT
// #define WIN_ENUMERATE            0x0002L                     ;Internal NT
// #define MENU_ACCESSMENU          0x0001L                     ;Internal NT
//                                                              ;Internal NT
// BOOL WINAPI  SetUserObjectSecurity(HANDLE,                   ;Internal NT
//              PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR);   ;Internal NT
// BOOL WINAPI  GetUserObjectSecurity(HANDLE,                   ;Internal NT
//              PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR,    ;Internal NT
//              DWORD, LPDWORD);                                ;Internal NT
// BOOL WINAPI  ImpersonateDDEClientWindow(HWND, HWND);         ;Internal NT
//                                                              ;Internal NT
/****** Keyboard input support **********************************************/

#ifdef tagWND                   /* ;Internal */
HWND_16 WINAPI SetFocus(HWND);  /* ;Internal */
HWND_16 WINAPI GetFocus(void);  /* ;Internal */
#else                           /* ;Internal */
HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);
#endif                          /* ;Internal */

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

#ifdef tagWND   // ;Internal
BOOL    WINAPI GetKeyboardState(LPBYTE);    // ;Internal
BOOL    WINAPI GetKeyboardState(LPBYTE);    // ;Internal
#else           // ;Internal
void    WINAPI GetKeyboardState(LPBYTE);
void    WINAPI SetKeyboardState(LPBYTE);
#endif          // ;Internalx

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED     0x0100
#define KF_DLGMODE      0x0800
#define KF_MENUMODE     0x1000
#define KF_ALTDOWN      0x2000
#define KF_REPEAT       0x4000
#define KF_UP           0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_KANA         0x15    /* ;Internal JAPAN */
#define VK_KANJI        0x19    /* ;Internal JAPAN */
#define VK_HANGEUL      0x15    /* ;Internal KOREA */
#define VK_JUNJA        0x17    /* ;Internal KOREA */
#define VK_HANJA        0x19    /* ;Internal KOREA */
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_LWIN         0x5B
#define VK_RWIN         0x5C
#define VK_APPS         0x5D
#define VK_POWER        0x5E
#define VK_SLEEP        0x5F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '9' */

#endif  /* NOVIRTUALKEYCODES */
                                                        /* ;Internal */
BOOL WINAPI IsTwoByteCharPrefix(char);                  /* ;Internal */
                                                        /* ;Internal NT */
/* Keyboard Layout */                                /* ;Internal NT */
#define HKL_PREV             0                       /* ;Internal NT */
#define HKL_NEXT             1                       /* ;Internal NT */
                                                     /* ;Internal NT */
#define KLF_ACTIVATE         0x1                     /* ;Internal NT */
#define KLF_SUBSTITUTE_OK    0x2                     /* ;Internal NT */
#define KLF_UNLOADPREVIOUS   0x4                     /* ;Internal NT */
#define KLF_REORDER          0x8                     /* ;Internal NT */
                                                     /* ;Internal NT */
#define KLF_REPLACELANG		0x10					 /* ;Internal 4.0 */
#define KLF_NOTELLSHELL		0x80					 /* ;Internal 4.0 */

#define KL_NAMELENGTH        9                       /* ;Internal NT */
HKL  WINAPI  LoadKeyboardLayout(LPCSTR, UINT);       /* ;Internal NT */
HKL  WINAPI  GetKeyboardLayout(DWORD);               /* ;Internal 4.0 */
UINT WINAPI  GetKeyboardLayoutList(UINT, HKL FAR *); /* ;Internal 4.0 */
HKL WINAPI  ActivateKeyboardLayout(HKL, UINT);      /* ;Internal NT */
BOOL WINAPI  UnloadKeyboardLayout(HKL);              /* ;Internal NT */
BOOL WINAPI  GetKeyboardLayoutName(LPSTR);           /* ;Internal NT */

/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD     2

/****** Mouse input support *************************************************/

#ifdef tagWND   // ;Internal
HWND_16 WINAPI SetCapture(HWND);        // ;Internal
HWND_16 WINAPI GetCapture(void);        // ;Internal
BOOL    WINAPI ReleaseCapture(void);    // ;Internal
#else                                   // ;Internal
HWND    WINAPI SetCapture(HWND);
HWND    WINAPI GetCapture(void);
void    WINAPI ReleaseCapture(void);
#endif                                  // ;Internal

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON      0x0001
#define MK_RBUTTON      0x0002
#define MK_SHIFT        0x0004
#define MK_CONTROL      0x0008
#define MK_MBUTTON      0x0010
#endif  /* NOKEYSTATES */

#if (WINVER >= 0x40A)
#ifndef NOTRACKMOUSEEVENT

#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#define TME_NONCLIENT   0x00000010
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_NONCLIENT | TME_QUERY | TME_CANCEL) // ;Internal

#define HOVER_DEFAULT   0xFFFFFFFF

typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
#ifdef tagWND           /* ;Internal */
    HWND_16 hwndTrack;  /* ;Internal */
#else                   /* ;Internal */
    HWND    hwndTrack;
#endif                  /* ;Internal */
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, FAR *LPTRACKMOUSEEVENT;

BOOL WINAPI TrackMouseEvent(LPTRACKMOUSEEVENT);

#endif /* !NOTRACKMOUSEEVENT */
#endif // (WINVER >=0x40A)

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
#ifdef tagWND           /* ;Internal */
    HWND_16 hwnd;       /* ;Internal */
#else                   /* ;Internal */
    HWND    hwnd;
#endif                  /* ;Internal */
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif /* NOWH */

/****** Mode control ********************************************************/

#ifdef tagWND                           /* ;Internal */
HWND_16 WINAPI GetSysModalWindow(void); /* ;Internal */
HWND_16 WINAPI SetSysModalWindow(HWND); /* ;Internal */
#else                                   /* ;Internal */
HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);
#endif                                  /* ;Internal */


/****** Timer support *******************************************************/

#ifdef STRICT
#ifdef tagWND                                                   /* ;Internal */
typedef void (CALLBACK* TIMERPROC)(HWND_16, UINT, UINT, DWORD); /* ;Internal */
#else                                                           /* ;Internal */
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#endif                                                          /* ;Internal */
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);
                                                                /* ;Internal */
WORD   FAR SetSystemTimer(HWND, int, int, TIMERPROC);           /* ;Internal */
BOOL   FAR KillSystemTimer(HWND, int);                          /* ;Internal */
HBRUSH CALLBACK GetControlBrush(HWND, HDC, UINT);               /* ;Internal */
void   CALLBACK PaintRect(HWND, HWND, HDC, HBRUSH, LPRECT);    /* ;Internal */
VOID   WINAPI   SwitchToThisWindow(HWND, BOOL);                      /* ;Internal */

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);


#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, LPMSG);
#endif
                                                            /* ;Internal NT */
#define FVIRTKEY    0x01                                    /* ;Internal NT */
#define FNOINVERT   0x02                                    /* ;Internal NT */
#define FSHIFT      0x04                                    /* ;Internal NT */
#define FCONTROL    0x08                                    /* ;Internal NT */
#define FALT        0x10                                    /* ;Internal NT */
#define FLASTKEY    0x80                                    /* ;Internal NT */
                                                            /* ;Internal NT */
typedef struct tagACCEL                                     /* ;Internal NT */
{                                                           /* ;Internal NT */
    BYTE    fVirt;                                          /* ;Internal NT */
    WORD    key;                                            /* ;Internal NT */
    WORD    cmd;                                            /* ;Internal NT */
}                                                           /* ;Internal NT */
ACCEL, FAR* LPACCEL;                                        /* ;Internal NT */
                                                            /* ;Internal NT */
HACCEL  WINAPI CreateAcceleratorTable(LPACCEL, int);        /* ;Internal NT */
int     WINAPI CopyAcceleratorTable(HACCEL, LPACCEL, int);  /* ;Internal NT */
BOOL    WINAPI DestroyAcceleratorTable(HACCEL);             /* ;Internal NT */
                                                            /* ;Internal NT */
// #define IDHOT_SNAPWINDOW     (-1)                        /* ;Internal NT */
// #define IDHOT_SNAPDESKTOP    (-2)                        /* ;Internal NT */
                                                            /* ;Internal NT */
#ifdef tagWND                                               /* ;Internal NT */
BOOL WINAPI  RegisterHotKey(HWND_16, DWORD, UINT, UINT);    /* ;Internal NT */
BOOL WINAPI  UnregisterHotKey(HWND_16, DWORD);              /* ;Internal NT */
#else                                                       /* ;Internal NT */
BOOL WINAPI  RegisterHotKey(HWND, DWORD, UINT, UINT);       /* ;Internal NT */
BOOL WINAPI  UnregisterHotKey(HWND, DWORD);                 /* ;Internal NT */
#endif                                                      /* ;Internal NT */
#define MOD_ALT         0x0001                              /* ;Internal NT */
#define MOD_CONTROL     0x0002                              /* ;Internal NT */
#define MOD_SHIFT       0x0004                              /* ;Internal NT */
#define MOD_WIN         0x0008                              /* ;Internal NT */

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct tagMENUITEMTEMPLATEHEADER
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct tagMENUITEMTEMPLATE
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x0400)                                          // ;Internal 4.0
typedef struct tagMENUEXTEMPLATE                                // ;Internal 4.0
{                                                               // ;Internal 4.0
    WORD    wMenuVer;                                           // ;Internal 4.0
    WORD    dwHdrSize;                                          // ;Internal 4.0
} MENUEXTEMPLATE, FAR *LPMENUEXTEMPLATE;                        // ;Internal 4.0
                                                                // ;Internal 4.0
typedef struct tagMENUEXHEADER                                  // ;Internal 4.0
{                                                               // ;Internal 4.0
    DWORD   dwHelpID;                                           // ;Internal 4.0
} MENUEXHEADER, FAR *LPMENUEXHEADER;                            // ;Internal 4.0
                                                                // ;Internal 4.0
typedef struct tagMENUEXITEMTEMPLATE                            // ;Internal 4.0
{                                                               // ;Internal 4.0
    DWORD   fType;                                              // ;Internal 4.0
    DWORD   fState;                                             // ;Internal 4.0
    WORD    wID;                                                // ;Internal 4.0
    BYTE    bResInfo;                                           // ;Internal 4.0
} MENUEXITEMTEMPLATE, FAR *LPMENUEXITEMTEMPLATE;                // ;Internal 4.0
    /* Menu String */                                           // ;Internal 4.0
    /* if popup, MENUEXHEADER */                                // ;Internal 4.0
#endif                                                          // ;Internal 4.0
                                                                // ;Internal 4.0
#if (WINVER >= 0x030a)                                          // ;Internal
#ifdef tagWND                                                   // ;Internal
BOOL    WINAPI IsMenu(HMENU_16);                                // ;Internal
#else                                                           // ;Internal
BOOL    WINAPI IsMenu(HMENU);
#endif // tagWND                                                // ;Internal
#endif  /* WINVER >= 0x030a */                                  // ;Internal

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

#ifdef tagWND                                                               // ;Internal
DWORD    WINAPI GetMenu(HWND);                                              // ;Internal
HMENU_16 WINAPI GetSystemMenu(HWND, BOOL);                                  // ;Internal
HMENU_16 WINAPI GetSubMenu(HMENU, UINT);                                    // ;Internal
BOOL     WINAPI InsertMenu(HMENU_16, UINT, UINT, UINT, LPCSTR);             // ;Internal
BOOL     WINAPI AppendMenu(HMENU_16, UINT, UINT, LPCSTR);                   // ;Internal
BOOL     WINAPI ModifyMenu(HMENU_16, UINT, UINT, UINT, LPCSTR);             // ;Internal
BOOL     WINAPI ChangeMenu(HMENU_16, UINT, LPCSTR, UINT, UINT);             // ;Internal
BOOL     WINAPI SetMenuItemBitmaps(HMENU_16, UINT, UINT, HBITMAP, HBITMAP); // ;Internal
int      WINAPI GetMenuString(HMENU_16, UINT, LPSTR, int, UINT);            // ;Internal
#else                                                                       // ;Internal
HMENU   WINAPI GetMenu(HWND);
HMENU   WINAPI GetSystemMenu(HWND, BOOL);
HMENU   WINAPI GetSubMenu(HMENU, UINT);
BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);
BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
#endif // tagWND                                                            // ;Internal

BOOL    WINAPI DestroyMenu(HMENU);
BOOL    WINAPI SetMenu(HWND, HMENU);
BOOL    WINAPI SetSystemMenu(HWND, HMENU);    /* ;Internal */
#ifdef tagWND   // ;Internal
BOOL    WINAPI DrawMenuBar(HWND);   // ;Internal
#else           // ;Internal
void    WINAPI DrawMenuBar(HWND);
#endif          // ;Internal
int     WINAPI DrawMenuBarTemp(HWND, HDC, LPRECT, HMENU, HFONT);   // ;Internal
BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

#define MF_INSERT           0x0000  /* Obsolete -- only used by ChangeMenu */
#define MF_CHANGE           0x0080  /* Obsolete -- only used by ChangeMenu */
#define MF_APPEND           0x0100  /* Obsolete -- only used by ChangeMenu */
#define MF_DELETE           0x0200  /* Obsolete -- only used by ChangeMenu */
#define MF_REMOVE           0x1000  /* Obsolete -- only used by ChangeMenu */

#define MF_BYCOMMAND        0x0000  /* Obsolete -- only old APIs use these */
#define MF_BYPOSITION       0x0400  /* Obsolete -- only old APIs use these */
#define MF_USECHECKBITMAPS  0x0200  /* Obsolete -- replaced by MF_RADIOCHECK */
#define MF_HELP             0x4000  /* Obsolete -- use MF_RIGHTJUSTIFY */

#define MF_POPUP            0x0010  /* Obsolete -- replace by hSubMenu field */
#define MF_END              0x0080  /* Obsolete -- only used by old RES files */
#define MF_SYSMENU          0x2000  /* Passed back during WM_MENUSELECT */
#define MF_MOUSESELECT      0x8000  /* Passed back during WM_MENUSELECT */

#define MFT_STRING          0x0000
#define MFT_BITMAP          0x0004  /* Obsolete -- use MIIM_BITMAP instead */
#define MFT_MENUBARBREAK    0x0020
#define MFT_MENUBREAK       0x0040
#define MFT_OWNERDRAW       0x0100
#define MFT_RADIOCHECK      0x0200
#define MFT_SEPARATOR       0x0800
#define MFT_RIGHTORDER 	    0x2000
#define MFT_RIGHTJUSTIFY    0x4000
#define MFT_MASK            0x6B64		 // ;Internal

#define MFS_GRAYED          0x0003
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         0x0008
#define MFS_HILITE          0x0080
#define MFS_ENABLED         0x0000
#define MFS_UNCHECKED       0x0000
#define MFS_UNHILITE        0x0000
#if (WINVER >= 0x40A)                           // ;Internal 4.1
#define MFS_HOTTRACK        0x0100              // ;Internal 4.1
#define MFS_TOPGAPDROP      0x0200              // ;Internal 4.1
#define MFS_BOTTOMGAPDROP   0x0400              // ;Internal 4.1
#define MFS_GAPDROP      (MFS_TOPGAPDROP | MFS_BOTTOMGAPDROP) // ;Internal 4.1
#endif // (WINVER >= 0x40A)                     // ;Internal 4.1
#define MFS_DEFAULT         0x1000
#define MFS_MASK            0x1F8B		 // ;Internal

#define MFR_POPUP           0x01
#define MFR_END             0x80

/* old names for menu types & states */
#define MF_SEPARATOR        MFT_SEPARATOR

#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_CHECKED          MFS_CHECKED
#define MF_ENABLED          MFS_ENABLED
#define MF_UNCHECKED        MFS_UNCHECKED
#define MF_UNHILITE         MFS_UNHILITE

#define MF_STRING           0x0000     /* Obsolete -- use MIIM_STRING instead */ 
#define MF_BITMAP           MFT_BITMAP /* Obsolete -- use MIIM_BITMAP instead */ 
#define MF_OWNERDRAW        MFT_OWNERDRAW

#define MF_MENUBARBREAK     MFT_MENUBARBREAK
#define MF_MENUBREAK        MFT_MENUBREAK

#define MF_HILITE           MFS_HILITE

#define MF_DEFAULT          MFS_DEFAULT
#define MF_RIGHTJUSTIFY     MFT_RIGHTJUSTIFY

#define MFT_OLDAPI_MASK     0x4B64  // ;Internal
#define MFS_OLDAPI_MASK     0x008B  // ;Internal
#define MFT_NONSTRING       0x0904  // MF_BITMAP | MF_OWNERDRAW | MF_SEPARATOR ;Internal
#define MFT_BREAK           0x0060  // MF_MENUBREAK | MF_MENUBARBREAK          ;Internal

#ifdef tagWND                                       // ;Internal
DWORD   WINAPI EnableMenuItem(HMENU, UINT, UINT);   // ;Internal
DWORD   WINAPI CheckMenuItem(HMENU, UINT, UINT);    // ;Internal
#else                                               // ;Internal
UINT    WINAPI EnableMenuItem(HMENU, UINT, UINT);
UINT    WINAPI CheckMenuItem(HMENU, UINT, UINT);
#endif                                              // ;Internal
BOOL    WINAPI CheckMenuRadioItem(HMENU, UINT, UINT, UINT, UINT);   // ;Internal 4.0

int     WINAPI GetMenuItemCount(HMENU);
#ifdef tagWND                                       // ;Internal
DWORD   WINAPI GetMenuItemID(HMENU, UINT);          // ;Internal
DWORD   WINAPI GetMenuState(HMENU, UINT, UINT);     // ;Internal
#else                                               // ;Internal
UINT    WINAPI GetMenuItemID(HMENU, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);
#endif                                              // ;Internal

DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, LPCRECT);

#if (WINVER >= 0x0400)                                  /* ;Internal 4.0 */
/* return codes for WM_MENUCHAR */                      /* ;Internal 4.0 */
#define MNC_IGNORE  0                                   /* ;Internal 4.0 */
#define MNC_CLOSE   1                                   /* ;Internal 4.0 */
#define MNC_EXECUTE 2                                   /* ;Internal 4.0 */
#define MNC_SELECT  3                                   /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
typedef struct tagTPMPARAMS                             /* ;Internal 4.0 */
{                                                       /* ;Internal 4.0 */
    DWORD   cbSize;                                     /* ;Internal 4.0 */
    RECT    rcExclude;                                  /* ;Internal 4.0 */
}                                                       /* ;Internal 4.0 */
TPMPARAMS, FAR *LPTPMPARAMS;                            /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS);  /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */

#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
#define MNS_NOCHECK          0x80000000                 /* ;Internal 4.1 */
#define MNS_MODELESS         0x40000000                 /* ;Internal 4.1 */
#define MNS_DRAGDROP         0x20000000                 /* ;Internal 4.1 */
#define MNS_AUTODISMISS      0x10000000                 /* ;Internal 4.1 */
#define MNS_NOTIFYBYPOS      0x08000000                 /* ;Internal 4.1 */
#define MNS_CHECKORBMP       0x04000000                 // ;Internal 4.1 */
#define MNS_VALID            0xFC000000                 // ;Internal
                                                        /* ;Internal 4.1 */
#define MIM_MAXHEIGHT        0x00000001                 /* ;Internal 4.1 */
#define MIM_BACKGROUND       0x00000002                 /* ;Internal 4.1 */
#define MIM_HELPID           0x00000004                 /* ;Internal 4.1 */
#define MIM_MENUDATA         0x00000008                 /* ;Internal 4.1 */
#define MIM_STYLE            0x00000010                 /* ;Internal 4.1 */
#define MIM_APPLYTOSUBMENUS  0x80000000                 /* ;Internal 4.1 */
#define MIM_MASK             0x8000001F                 // ;Internal
                                                        /* ;Internal 4.1 */
typedef struct tagMENUINFO                              /* ;Internal 4.1 */
{                                                       /* ;Internal 4.1 */
    DWORD   cbSize;                                     /* ;Internal 4.1 */
    DWORD   fMask;                                      /* ;Internal 4.1 */
    DWORD   dwStyle;                                    /* ;Internal 4.1 */
    DWORD   cyMax;                                      /* ;Internal 4.1 */
    DWORD   hbrBack;                                    /* ;Internal 4.1 */
    DWORD   dwContextHelpID;                            /* ;Internal 4.1 */
    DWORD   dwMenuData;                                 /* ;Internal 4.1 */
}                                                       /* ;Internal 4.1 */
MENUINFO, FAR *LPMENUINFO;                              /* ;Internal 4.1 */
typedef const MENUINFO FAR *LPCMENUINFO;                /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
                                                        /* ;Internal 4.0 */
#define MIIM_STATE       0x00000001                     /* ;Internal 4.0 */
#define MIIM_ID          0x00000002                     /* ;Internal 4.0 */
#define MIIM_SUBMENU     0x00000004                     /* ;Internal 4.0 */
#define MIIM_CHECKMARKS  0x00000008                     /* ;Internal 4.0 */
#define MIIM_TYPE        0x00000010                     /* ;Internal 4.0 */
#define MIIM_DATA        0x00000020                     /* ;Internal 4.0 */
#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
#define MIIM_STRING      0x00000040                     /* ;Internal 4.1 */
#define MIIM_BITMAP      0x00000080                     /* ;Internal 4.1 */
#define MIIM_FTYPE       0x00000100                     /* ;Internal 4.1 */
#define HBMMENU_CALLBACK         ((HBITMAP) -1)         /* ;Internal 4.1 */
#define HBMMENU_MIN              ((HBITMAP)  0)         /* ;Internal 4.1 */
#define HBMMENU_SYSTEM           ((HBITMAP)  1)         /* ;Internal 4.1 */
#define HBMMENU_MBARFIRST        ((HBITMAP)  2)         /* ;Internal 4.1 */
#define HBMMENU_MBAR_RESTORE     ((HBITMAP)  2)         /* ;Internal 4.1 */
#define HBMMENU_MBAR_MINIMIZE    ((HBITMAP)  3)         /* ;Internal 4.1 */
#define HBMMENU_BULLET           ((HBITMAP)  4)         /* ;Internal 4.1 */
#define HBMMENU_MBAR_CLOSE       ((HBITMAP)  5)         /* ;Internal 4.1 */
#define HBMMENU_MBAR_CLOSE_D     ((HBITMAP)  6)         /* ;Internal 4.1 */
#define HBMMENU_MBAR_MINIMIZE_D  ((HBITMAP)  7)         /* ;Internal 4.1 */
#define HBMMENU_MBARLAST         ((HBITMAP)  7)         /* ;Internal 4.1 */
#define HBMMENU_POPUPFIRST       ((HBITMAP)  8)         /* ;Internal 4.1 */
#define HBMMENU_POPUP_CLOSE      ((HBITMAP)  8)         /* ;Internal 4.1 */
#define HBMMENU_POPUP_RESTORE    ((HBITMAP)  9)         /* ;Internal 4.1 */
#define HBMMENU_POPUP_MAXIMIZE   ((HBITMAP) 10)         /* ;Internal 4.1 */
#define HBMMENU_POPUP_MINIMIZE   ((HBITMAP) 11)         /* ;Internal 4.1 */
#define HBMMENU_POPUPLAST        ((HBITMAP) 11)         /* ;Internal 4.1 */
#define HBMMENU_MAX              ((HBITMAP) 12)         /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
#define MIIM40_MASK      0x0000006F                     // ;Internal
#define MIIM_MASK        0x000001FF                     // ;Internal

                                                        /* ;Internal 4.0 */
typedef struct tagMENUITEMINFO40                        /* ;Internal 4.1 */
{                                                       /* ;Internal 4.1 */
    DWORD   cbSize;                                     /* ;Internal 4.1 */
    DWORD   fMask;                                      /* ;Internal 4.1 */
    UINT    fType;                                      /* ;Internal 4.1 */
    UINT    fState;                                     /* ;Internal 4.1 */
    UINT    wID;                                        /* ;Internal 4.1 */
#ifdef tagWND                                           /* ;Internal 4.1 */
    HMENU_16 hSubMenu;                                  /* ;Internal 4.1 */
#else                                                   /* ;Internal 4.1 */
    HMENU   hSubMenu;                                   /* ;Internal 4.1 */
#endif                                                  /* ;Internal 4.1 */
    HBITMAP hbmpChecked;                                /* ;Internal 4.1 */
    HBITMAP hbmpUnchecked;                              /* ;Internal 4.1 */
    DWORD   dwItemData;                                 /* ;Internal 4.1 */
    LPSTR   dwTypeData;                                 /* ;Internal 4.1 */
    UINT    cch;                                        /* ;Internal 4.1 */ 
}                                                       /* ;Internal 4.1 */
MENUITEMINFO40, FAR* LPMENUITEMINFO40;                  /* ;Internal 4.1 */
typedef const MENUITEMINFO40 FAR * LPCMENUITEMINFO40;   /* ;Internal 4.1 */
                                                        /* ;Internal 4.0 */
typedef struct tagMENUITEMINFO                          /* ;Internal 4.0 */
{                                                       /* ;Internal 4.0 */
    DWORD   cbSize;                                     /* ;Internal 4.0 */
    DWORD   fMask;                                      /* ;Internal 4.0 */
    UINT    fType;                                      /* ;Internal 4.0 */
    UINT    fState;                                     /* ;Internal 4.0 */
    UINT    wID;                                        /* ;Internal 4.0 */
#ifdef tagWND                                           /* ;Internal 4.0 */
    HMENU_16 hSubMenu;                                  /* ;Internal 4.0 */
#else                                                   /* ;Internal 4.0 */
    HMENU   hSubMenu;                                   /* ;Internal 4.0 */
#endif                                                  /* ;Internal 4.0 */
    HBITMAP hbmpChecked;                                /* ;Internal 4.0 */
    HBITMAP hbmpUnchecked;                              /* ;Internal 4.0 */
    DWORD   dwItemData;                                 /* ;Internal 4.0 */
    LPSTR   dwTypeData;                                 /* ;Internal 4.0 */
    UINT    cch;                                        /* ;Internal 4.0 */ 
#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
    HBITMAP hbmpItem;                                   /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
}                                                       /* ;Internal 4.0 */
MENUITEMINFO, FAR* LPMENUITEMINFO;                      /* ;Internal 4.0 */
typedef const MENUITEMINFO FAR * LPCMENUITEMINFO;       /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI InsertMenuItem (HMENU, UINT, BOOL, LPCMENUITEMINFO); /* ;Internal 4.0 */
BOOL    WINAPI GetMenuItemInfo(HMENU, UINT, BOOL, LPMENUITEMINFO);  /* ;Internal 4.0 */
BOOL    WINAPI SetMenuItemInfo(HMENU, UINT, BOOL, LPCMENUITEMINFO); /* ;Internal 4.0 */

#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
BOOL    WINAPI GetMenuInfo(HMENU, LPMENUINFO);          /* ;Internal 4.1 */
BOOL    WINAPI SetMenuInfo(HMENU, LPCMENUINFO);         /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
                                                        /* ;Internal 4.0 */
#define GMDI_USEDISABLED    0x0001                      /* ;Internal 4.0 */
#define GMDI_GOINTOPOPUPS   0x0002                      /* ;Internal 4.0 */
DWORD   WINAPI GetMenuDefaultItem(HMENU, BOOL, UINT);   /* ;Internal 4.0 */
BOOL    WINAPI SetMenuDefaultItem(HMENU, UINT, BOOL);   /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI GetMenuItemRect(HWND, HMENU, UINT, LPRECT);    /* ;Internal 4.0 */
int     WINAPI MenuItemFromPoint(HWND, HMENU, POINT);         /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                           /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON      0x0000

#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON     0x0002
#define TPM_LEFTALIGN       0x0000
#define TPM_CENTERALIGN     0x0004
#define TPM_RIGHTALIGN      0x0008
                                                        // ;Internal
#if (WINVER >= 0x0400)                                  // ;Internal
#define TPM_TOPALIGN        0x0000                      // ;Internal 4.0
#define TPM_VCENTERALIGN    0x0010                      // ;Internal 4.0
#define TPM_BOTTOMALIGN     0x0020                      // ;Internal 4.0
                                                        // ;Internal 4.0
#define TPM_HORIZONTAL      0x0000                      // ;Internal 4.0
#define TPM_VERTICAL        0x0040                      // ;Internal 4.0
#define TPM_NONOTIFY        0x0080                      // ;Internal 4.0
#define TPM_RETURNCMD       0x0100                      // ;Internal 4.0
#define TPM_SYSMENU         0x0200                      // ;Internal
#if (WINVER >= 0x040A)                                  // ;Internal 4.1
#define TPM_RECURSE         0x0001                      // ;Internal 4.1
#endif /* WINVER >= 0x040A */                           // ;Internal 4.1
#endif /* WINVER >= 0x0400 */                           // ;Internal
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8
#define SB_MSGCMD_MAX       8     /* ;Internal */

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3
#define SB_MAX              3                               // ;Internal

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
#ifdef tagWND   // ;Internal
LONG    WINAPI GetScrollPos(HWND, int);                     // ;Internal
BOOL    WINAPI GetScrollRange(HWND, int, LPINT, LPINT);     // ;Internal
BOOL    WINAPI SetScrollRange(HWND, int, int, int, BOOL);   // ;Internal
BOOL    WINAPI ShowScrollBar(HWND, int, BOOL);              // ;Internal
#else           // ;Internal
int     WINAPI GetScrollPos(HWND, int);    
void    WINAPI GetScrollRange(HWND, int, LPINT, LPINT); 
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
#endif          // ;Internal
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT
#define ESB_MAX             0x0003                          // ;Internal
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH                // ;Internal
                                                            // ;Internal
#define SBM_FIRST_16        WM_USER                         // ;Internal
#define SBM_SETPOS          (WM_USER)                       // ;Internal
#define SBM_GETPOS          (WM_USER+1)                     // ;Internal
#define SBM_SETRANGE        (WM_USER+2)                     // ;Internal
#define SBM_GETRANGE        (WM_USER+3)                     // ;Internal
#define SBM_ENABLE_ARROWS   (WM_USER+4)                     // ;Internal
                                                            // ;Internal
#if (WINVER >= 0x0400)                                      // ;Internal 4.0
#define SBM_SETRANGEREDRAW  (WM_USER+6)                     // ;Internal 4.0
#define SBM_SETSCROLLINFO   (WM_USER+9)                     // ;Internal 4.0
#define SBM_GETSCROLLINFO   (WM_USER+10)                    // ;Internal 4.0
#define SBM_MSGMAX          (WM_USER+11)                    // ;Internal 4.0
                                                            // ;Internal 4.0
#define SIF_RANGE           0x0001                          // ;Internal 4.0
#define SIF_PAGE            0x0002                          // ;Internal 4.0
#define SIF_POS             0x0004                          // ;Internal 4.0
#define SIF_DISABLENOSCROLL 0x0008                          // ;Internal 4.0
#define SIF_TRACKPOS        0x0010                          // ;Internal 4.0
#define SIF_ALL             (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)// ;Internal
#define SIF_RETURNOLDPOS    0x1000                          // ;Internal
#define SIF_NOSCROLL        0x2000                          // ;Internal
#define SIF_MASK            0x701F                          // ;Internal
                                                            // ;Internal 4.0
typedef struct tagSCROLLINFO                                // ;Internal 4.0
{                                                           // ;Internal 4.0
    DWORD   cbSize;                                         // ;Internal 4.0
    DWORD   fMask;                                          // ;Internal 4.0
    LONG    nMin;                                           // ;Internal 4.0
    LONG    nMax;                                           // ;Internal 4.0
    DWORD   nPage;                                          // ;Internal 4.0
    LONG    nPos;                                           // ;Internal 4.0
    LONG    nTrackPos;                                      // ;Internal 4.0
}                                                           // ;Internal 4.0
SCROLLINFO, FAR *LPSCROLLINFO;                              // ;Internal 4.0
typedef const SCROLLINFO FAR *LPCSCROLLINFO;                // ;Internal 4.0

                                                            // ;Internal 4.0
LONG WINAPI SetScrollInfo(HWND, int, LPCSCROLLINFO, BOOL);  // ;Internal 4.0
BOOL WINAPI GetScrollInfo(HWND, int, LPSCROLLINFO);         // ;Internal 4.0
#endif /* WINVER >= 0x0400 */                               // ;Internal 4.0
#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_FIRST            1
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13      // ;Internal NT
#define CF_ENHMETAFILE      14      // ;Internal NT
#define CF_HDROP            15      // ;Internal 4.0
#define CF_LOCALE           16      // ;Internal 4.0
#define CF_MAX              17      // ;Internal 4.0

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
#define CF_DSPENHMETAFILE   0x008E  /* ;Internal NT */

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetOpenClipboardWindow(void);    /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetOpenClipboardWindow(void);
#endif                                          /* ;Internal */
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetClipboardOwner(void);         /* ;Internal */
HWND_16 WINAPI SetClipboardViewer(HWND);        /* ;Internal */
HWND_16 WINAPI GetClipboardViewer(void);        /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);
#endif                                          /* ;Internal */

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
#ifdef tagWND   // ;Internal
DWORD   WINAPI GetPriorityClipboardFormat(UINT FAR*, int);  // ;Internal
#else           // ;Internal
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);
#endif          // ;Internal

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

#endif  /* NOCLIPBOARD */
                                                /* ;Internal NT */
// /* LPARAM of WM_COPYDATA */                  /* ;Internal NT */
// typedef struct tagCOPYDATASTRUCT             /* ;Internal NT */
// {                                            /* ;Internal NT */
//    DWORD   dwData;                           /* ;Internal NT */
//    DWORD   cbData;                           /* ;Internal NT */
//    LPSTR   lpData;                           /* ;Internal NT */
// } COPYDATASTRUCT, FAR *LPCOPYDATASTRUCT;     /* ;Internal NT */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);
#ifdef tagWND   // ;Internal
BOOL    WINAPI ClipCursor(LPCRECT); // ;Internal
BOOL    WINAPI SetCursorPos(int, int);  // ;Internal
BOOL    WINAPI GetCursorPos(LPPOINT);   // ;Internal
#else           // ;Internal
void    WINAPI ClipCursor(LPCRECT);
void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(LPPOINT);
#endif          // ;Internal

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#ifdef tagWND   // ;Internal
BOOL    WINAPI GetClipCursor(LPRECT);   // ;Internal
#else           // ;Internal
void    WINAPI GetClipCursor(LPRECT);
#endif          // ;Internal
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW               MAKEINTRESOURCE(32512)
#define IDC_IBEAM               MAKEINTRESOURCE(32513)
#define IDC_WAIT                MAKEINTRESOURCE(32514)
#define IDC_CROSS               MAKEINTRESOURCE(32515)
#define IDC_UPARROW             MAKEINTRESOURCE(32516)
#define IDC_NWPEN               MAKEINTRESOURCE(32631)  // ;Internal
#define IDC_HUNG                MAKEINTRESOURCE(32632)  // ;Internal
#define IDC_SIZE                MAKEINTRESOURCE(32640)  /* OBSOLETE: use IDC_SIZEALL */
#define IDC_ICON                MAKEINTRESOURCE(32641)  /* OBSOLETE: use IDC_ARROW */
#define IDC_SIZENWSE            MAKEINTRESOURCE(32642)
#define IDC_SIZENESW            MAKEINTRESOURCE(32643)
#define IDC_SIZEWE              MAKEINTRESOURCE(32644)
#define IDC_SIZENS              MAKEINTRESOURCE(32645)
#define IDC_SIZEALL             MAKEINTRESOURCE(32646)
#define IDC_NO                  MAKEINTRESOURCE(32648)
#define IDC_APPSTARTING         MAKEINTRESOURCE(32650)  // ;Internal NT 4.0
#if (WINVER >= 0x0400)                                  // ;Internal 4.0
#define IDC_HELP                MAKEINTRESOURCE(32651)  // ;Internal 4.0
#endif  /* WINVER >= 0x400 */                           // ;Internal 4.0


/****** Icon support *********************************************************/


HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
                                                        /* ;Internal NT */
/* Icon/cursor information */                           /* ;Internal NT */
typedef struct tagICONINFO                              /* ;Internal NT */
{                                                       /* ;Internal NT */
    BOOL     fIcon;                                     /* ;Internal NT */
    int      xHotspot;                                  /* ;Internal NT */
    int      yHotspot;                                  /* ;Internal NT */
    HBITMAP  hbmMask;                                   /* ;Internal NT */
    HBITMAP  hbmColor;                                  /* ;Internal NT */
} ICONINFO, *PICONINFO, FAR *LPICONINFO;                /* ;Internal NT */
                                                        /* ;Internal NT */
HICON    WINAPI  CreateIconIndirect(const ICONINFO FAR *);  /* ;Internal NT */
BOOL     WINAPI  GetIconInfo(HICON, LPICONINFO);        /* ;Internal NT */
                                                        /* ;Internal 4.0 */
#define RES_ICON    1                                   /* ;Internal 4.0 */
#define RES_CURSOR  2                                   /* ;Internal 4.0 */

typedef struct tagNEWHEADER
{
    WORD    Reserved;
    WORD    ResType;        /* RES_ICON or RES_CURSOR */
    WORD    ResCount;
} NEWHEADER, FAR *LPNEWHEADER;
                                                                            // ;Internal
#ifdef STRICT                                                               // ;Internal 
int WINAPI LookupIconIdFromDirectoryEx(LPNEWHEADER, BOOL, int, int, UINT);  // ;Internal 4.0 
#else                                                                       // ;Internal     
int WINAPI LookupIconIdFromDirectoryEx(LPVOID, BOOL, int, int, UINT);       // ;Internal 4.0 
#endif /* STRICT */                                                         // ;Internal   
                                                                            // ;Internal 4.0
HICON    WINAPI CreateIconFromResourceEx(LPVOID, DWORD, BOOL, DWORD,        // ;Internal 4.0
                UINT, UINT, UINT);                                          // ;Internal 4.0

#if (WINVER >= 0x0400)
/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE, FAR *LPCURSORSHAPE;
                                  
#define IMAGE_BITMAP        0           // ;Internal 4.0
#define IMAGE_ICON          1           // ;Internal 4.0
#define IMAGE_CURSOR        2           // ;Internal 4.0
#define IMAGE_ENHMETAFILE   3           // ;Internal 4.0
#define IMAGE_MAX           4           // ;Internal 4.0
                                        // ;Internal 4.0
HANDLE  WINAPI  LoadImage(HINSTANCE, LPCSTR, UINT, int, int, UINT); // ;Internal 4.0
HANDLE  WINAPI  CopyImage(HINSTANCE, HANDLE, UINT, int, int, UINT); // ;Internal 4.0
                                        // ;Internal 4.0
#define LR_DEFAULTCOLOR     0x0000      // ;Internal 4.0
#define LR_MONOCHROME       0x0001      // ;Internal 4.0
#define LR_COLOR            0x0002      // ;Internal 4.0
#define LR_COPYRETURNORG    0x0004      // ;Internal 4.0
#define LR_COPYDELETEORG    0x0008      // ;Internal 4.0
#define LR_LOADFROMFILE     0x0010      // ;Internal 4.0
#define LR_LOADTRANSPARENT  0x0020      // ;Internal 4.0
#define LR_DEFAULTSIZE      0x0040      // ;Internal 4.0
#define LR_VGACOLOR         0x0080      // ;Internal 4.0
#define LR_LOADMAP3DCOLORS  0x1000      // ;Internal 4.0
#define LR_CREATEDIBSECTION 0x2000      // ;Internal 4.0
#define LR_COPYFROMRESOURCE 0x4000      // ;Internal 4.0
#define LR_SHARED           0x8000      // ;Internal 4.0
                                        // ;Internal 4.0
#define DI_MASK             0x0001      // ;Internal 4.0
#define DI_IMAGE            0x0002      // ;Internal 4.0
#define DI_NORMAL           0x0003      // ;Internal 4.0
#define DI_COMPAT           0x0004      // ;Internal 4.0
#define DI_DEFAULTSIZE      0x0008      // ;Internal 4.0
                                        // ;Internal 4.0 
BOOL    WINAPI DrawIconEx(HDC hdc, int x, int y, HICON hIcon, int cx,   // ;Internal 4.0
    int cy, UINT istepIfAniCur, HBRUSH hbrFastDraw, UINT diFlags);      // ;Internal 4.0
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_ERROR           32513   /* ;win40: Name changed from IDI_HAND */
#define IDI_QUESTION        32514
#define IDI_WARNING         32515   /* ;win40: Name changed from IDI_EXCLAMATION */
#define IDI_INFORMATION     32516   /* ;win40: Name changed from IDI_ASTERISK */
#define IDI_WINLOGO         32517   /* ;Internal NT */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_ERROR           MAKEINTRESOURCE(32513)  /* ;win40: Name changed from IDI_HAND */
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_WARNING         MAKEINTRESOURCE(32515)  /* ;win40: Name changed from IDI_EXCLAMATION */
#define IDI_INFORMATION     MAKEINTRESOURCE(32516)  /* ;win40: Name changed from IDI_ASTERISK */
#define IDI_WINLOGO         MAKEINTRESOURCE(32517)  /* ;Internal NT */
#endif /* RC_INVOKED */

#define IDI_HAND            IDI_ERROR
#define IDI_EXCLAMATION     IDI_WARNING
#define IDI_ASTERISK        IDI_INFORMATION

#endif  /* NOICONS */


/****** Caret support ********************************************************/

#ifdef tagWND       /* ;Internal */
BOOL    WINAPI CreateCaret(HWND, HBITMAP, int, int);    /* ;Internal */
BOOL    WINAPI DestroyCaret(void);                      /* ;Internal */
BOOL    WINAPI ShowCaret(HWND);                         /* ;Internal */
BOOL    WINAPI HideCaret(HWND);                         /* ;Internal */
BOOL    WINAPI SetCaretPos(int, int);                   /* ;Internal */
BOOL    WINAPI SetCaretBlinkTime(UINT);                 /* ;Internal */
BOOL    WINAPI GetCaretPos(LPPOINT);                    /* ;Internal */
#else               /* ;Internal */
void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);
void    WINAPI ShowCaret(HWND);
void    WINAPI HideCaret(HWND);
void    WINAPI SetCaretPos(int, int);
void    WINAPI SetCaretBlinkTime(UINT);
void    WINAPI GetCaretPos(LPPOINT);
#endif              /* ;Internal */
UINT    WINAPI GetCaretBlinkTime(void);

/****** WM_SYSCOMMAND support ***********************************************/

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150
#define SC_DEFAULT      0xF160  /* ;Internal 4.0 */
#define SC_MONITORPOWER 0xF170  /* ;Internal 4.0 */
#define SC_CONTEXTHELP  0xF180  /* ;Internal 4.0 */
#define SC_SYSTEMSLEEP	0xF190	/* ;Internal 4.10 */
#define SC_SEPARATOR    0xF00F  /* ;Internal 4.0 */

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
#ifdef tagWND                   /* ;Internal */
    HMENU_16  hWindowMenu;      /* ;Internal */
#else                           /* ;Internal */
    HMENU  hWindowMenu;
#endif                          /* ;Internal */
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;

typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#define MDITILE_SKIPDISABLED    0x0002
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                                      /* ;Internal */
LRESULT WINAPI DefFrameProc(HWND, HWND_16, UINT, WPARAM, LPARAM);  /* ;Internal */
#else                                                              /* ;Internal */
LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
#endif                                                             /* ;Internal */

LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, LPMSG);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);
BOOL    WINAPI TileChildWindows(HWND, UINT);
BOOL    WINAPI CascadeChildWindows(HWND, UINT);
                                                                /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                                          /* ;Internal 4.0 */
#ifdef tagWND                                                   /* ;Internal 4.0 */
typedef const HWND_16 FAR *LPHWND;                              /* ;Internal 4.0 */
#else                                                           /* ;Internal 4.0 */
typedef const HWND FAR *LPHWND;                                 /* ;Internal 4.0 */
#endif /* tagWND */                                             /* ;Internal 4.0 */
                                                                /* ;Internal 4.0 */
UINT WINAPI TileWindows   (HWND, UINT, LPCRECT, UINT, LPHWND);  /* ;Internal 4.0 */
UINT WINAPI CascadeWindows(HWND, UINT, LPCRECT, UINT, LPHWND);  /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                                   /* ;Internal 4.0 */
#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA 30

/* Dialog styles */
#define DS_ABSALIGN         0x0001L
#define DS_SYSMODAL         0x0002L
#define DS_LOCALEDIT        0x0020L
#define DS_SETFONT          0x0040L     
#define DS_MODALFRAME       0x0080L
#define DS_NOIDLEMSG        0x0100L
#define DS_SETFOREGROUND    0x0200L     // ;Internal NT
#define DS_VALID31          0x03e7L     // ;Internal
#if (WINVER >= 0x0400)                  // ;Internal
#define DS_3DLOOK           0x0004L     // ;Internal 4.0
#define DS_FIXEDSYS         0x0008L     // ;Internal 4.0
#define DS_NOFAILCREATE     0x0010L     // ;Internal 4.0
#define DS_CONTROL          0x0400L     // ;Internal 4.0
#define DS_RECURSE          DS_CONTROL  // ;Internal BOGUS GOING AWAY
#define DS_CENTER           0x0800L     // ;Internal 4.0
#define DS_CENTERMOUSE      0x1000L     // ;Internal 4.0
#define DS_CONTEXTHELP      0x2000L     // ;Internal 4.0
#define DS_COMMONDIALOG     0x4000L     // ;Internal
#define DS_VALID40          0x7FFFL     // ;Internal
#endif /* WINVER >= 0x0400 */           // ;Internal

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)
#define DM_REPOSITION       (WM_USER+2)     /* ;Internal 4.0 */
                                            /* ;Internal 4.0 */
#if WINVER >= 0x0400                        /* ;Internal 4.0 */
#define PSM_PAGEINFO        (WM_USER+100)   /* ;Internal 4.0 */
#define PSM_SHEETINFO       (WM_USER+101)   /* ;Internal 4.0 */
                                            /* ;Internal 4.0 */
#define PSI_SETACTIVE       0x0001L         /* ;Internal 4.0 */
#define PSI_KILLACTIVE      0x0002L         /* ;Internal 4.0 */
#define PSI_APPLY           0x0003L         /* ;Internal 4.0 */
#define PSI_RESET           0x0004L         /* ;Internal 4.0 */
#define PSI_HASHELP         0x0005L         /* ;Internal 4.0 */
#define PSI_HELP            0x0006L         /* ;Internal 4.0 */
                                            /* ;Internal 4.0 */
#define PSI_CHANGED         0x0001L         /* ;Internal 4.0 */
#define PSI_GUISTART        0x0002L         /* ;Internal 4.0 */
#define PSI_REBOOT          0x0003L         /* ;Internal 4.0 */
#define PSI_GETSIBLINGS     0x0004L         /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */               /* ;Internal 4.0 */

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#ifdef STRICT
#ifdef tagWND                                                   /* ;Internal */
typedef BOOL (CALLBACK* DLGPROC)(HWND_16, UINT, WPARAM, LPARAM);/* ;Internal */
#else                                                           /* ;Internal */
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#endif                                                          /* ;Internal */
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT       0
#define DWL_DLGPROC         4
#define DWL_USER            8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, LPMSG);
#endif

#ifdef tagWND                                                   /* ;Internal */
LRESULT WINAPI DefDlgProc(HWND_16, UINT, WPARAM, LPARAM);       /* ;Internal */
#else                                                           /* ;Internal */
LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);
#endif                                                          /* ;Internal */

#ifdef tagWND                                                                                   /* ;Internal */
HWND_16 WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);                                  /* ;Internal */
HWND_16 WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);                 /* ;Internal */
HWND_16 WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);                     /* ;Internal */
HWND_16 WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);    /* ;Internal */
#else                                                                                           /* ;Internal */
HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);
#endif                                                                                          /* ;Internal */

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
#ifdef tagWND                                                                       /* ;Internal */
long     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);           /* ;Internal */
long     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);  /* ;Internal */
#else                                                                               /* ;Internal */
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);
#endif                                                                              /* ;Internal */

void    WINAPI EndDialog(HWND, int);
BOOL    WINAPI EndDialog32(HWND, long);   /* ;Internal NT */

#ifdef tagWND                           /* ;Internal */
long    WINAPI GetDlgCtrlID(HWND);      /* ;Internal */
HWND_16 WINAPI GetDlgItem(HWND, int);   /* ;Internal */
#else                                   /* ;Internal */
int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
#endif                                  /* ;Internal */
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR *, BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

#ifdef tagWND                                           /* ;Internal */
HWND_16 WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);   /* ;Internal */
HWND_16 WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);     /* ;Internal */
#else                                                   /* ;Internal */
HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);
#endif                                                  /* ;Internal */

#ifdef tagWND   // ;Internal
BOOL    WINAPI MapDialogRect(HWND, LPRECT);     // ;Internal
#else           // ;Internal
void    WINAPI MapDialogRect(HWND, LPRECT);
#endif          // ;Internal
DWORD   WINAPI GetDialogBaseUnits(void);

/* dialog codes */
#define DLGC_WANTARROWS         0x0001
#define DLGC_WANTTAB            0x0002
#define DLGC_WANTALLKEYS        0x0004
#define DLGC_WANTMESSAGE        0x0004
#define DLGC_HASSETSEL          0x0008
#define DLGC_DEFPUSHBUTTON      0x0010
#define DLGC_UNDEFPUSHBUTTON    0x0020
#define DLGC_RADIOBUTTON        0x0040
#define DLGC_WANTCHARS          0x0080
#define DLGC_STATIC             0x0100
#define DLGC_BUTTON             0x2000

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6
#define CTLCOLOR_MAX            7       // ;Internal

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
#if (WINVER >= 0x0400)          /* ;Internal 4.0 */
#define IDCLOSE         8       /* ;Internal 4.0 */
#define IDHELP          9       /* ;Internal 4.0 */
#define IDUSERICON      10      /* ;Internal 4.0 */
#endif                          /* ;Internal 4.0 */


//***** Control Notification support *********************  ;Internal 4.0
// should this be marked internal?                      //  ;Internal 4.0
typedef struct tagNMHDR
{
#ifdef tagWND
    HWND_16 hwndFrom;
#else
    HWND  hwndFrom;
#endif
    WORD  _wDummy1;						
    UINT  idFrom;
    WORD  _wDummy2;
    UINT  code;
    WORD  _wDummy3;
}   NMHDR;
typedef NMHDR FAR * LPNMHDR;

typedef struct tagSTYLESTRUCT                           // ;Internal 4.0
{                                                       // ;Internal 4.0
    /* Win4.0 fields */                                 // ;Internal 4.0
    DWORD   styleOld;                                   // ;Internal 4.0
    DWORD   styleNew;                                   // ;Internal 4.0 
}   STYLESTRUCT;                                        // ;Internal 4.0
typedef STYLESTRUCT FAR * LPSTYLESTRUCT;                // ;Internal 4.0
                                                        // ;Internal 4.0
/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU            1
#define ODT_LISTBOX         2
#define ODT_COMBOBOX        3
#define ODT_BUTTON          4
#define ODT_STATIC          5           /* ;Internal 4.0 */

/* Owner draw actions */
#define ODA_DRAWENTIRE      0x0001
#define ODA_SELECT          0x0002
#define ODA_FOCUS           0x0004

/* Owner draw state */
#define ODS_SELECTED        0x0001
#define ODS_GRAYED          0x0002
#define ODS_DISABLED        0x0004
#define ODS_CHECKED         0x0008
#define ODS_FOCUS           0x0010
#if (WINVER >= 0x0400)                  /* ;Internal 4.0 */
#define ODS_DEFAULT         0x0020      /* ;Internal 4.0 */
#define ODS_COMBOBOXEDIT    0x1000      /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */           /* ;Internal 4.0 */
#if (WINVER >= 0x040A)                  /* ;Internal 4.1 */
#define ODS_HOTLIGHT        0x0040      /* ;Internal 4.1 */
#define ODS_INACTIVE        0x0080      /* ;Internal 4.1 */
#endif /* WINVER >= 0x040A */           /* ;Internal 4.1 */

/* LPARAM of WM_DRAWITEM is LPDRAWITEMSTRUCT */
typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
#ifdef tagWND                   /* ;Internal */
    HWND_16     hwndItem;       /* ;Internal */
#else                           /* ;Internal */
    HWND        hwndItem;
#endif                          /* ;Internal */
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

/* LPARAM of WM_MEASUREITEM is LPMEASUREITEMSTRUCT */
typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

/* LPARAM of WM_DELETEITEM is LPDELETEITEMSTRUCT */
typedef struct tagDELETEITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
#ifdef tagWND                   /* ;Internal */
    HWND_16     hwndItem;       /* ;Internal */
#else                           /* ;Internal */
    HWND        hwndItem;
#endif                          /* ;Internal */
    DWORD       itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

/* LPARAM of WM_COMPAREITEM is LPCOMPAREITEMSTRUCT */
typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
#ifdef tagWND                   /* ;Internal */
    HWND_16 hwndItem;           /* ;Internal */
#else                           /* ;Internal */
    HWND hwndItem;
#endif                          /* ;Internal */
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL     // ;Internal
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_OWNERDRAW        0x0000000DL     // ;Internal 4.0
#define SS_BITMAP           0x0000000EL     // ;Internal 4.0
#define SS_ENHMETAFILE      0x0000000FL     // ;Internal 4.0
#define SS_ETCHEDHORZ       0x00000010L     // ;Internal 4.0
#define SS_ETCHEDVERT       0x00000011L     // ;Internal 4.0
#define SS_ETCHEDFRAME      0x00000012L     // ;Internal 4.0
#define SS_TYPEMASK         0x0000001FL     // ;Internal 4.0

#define SS_NOPREFIX         0x00000080L
#define SS_NOTIFY           0x00000100L     // ;Internal 4.0
#define SS_CENTERIMAGE      0x00000200L     // ;Internal 4.0
#define SS_RIGHTJUST        0x00000400L     // ;Internal 4.0
#define SS_REALSIZEIMAGE    0x00000800L     // ;Internal 4.0
#define SS_SUNKEN           0x00001000L     // ;Internal 4.0
#define SS_EDITCONTROL	    0x00002000L	    // ;Internal

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_FIRST_16        WM_USER         // ;Internal
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#if (WINVER >= 0x0400)                      // ;Internal 4.0
#define STM_SETIMAGE        (WM_USER+2)     // ;Internal 4.0
#define STM_GETIMAGE        (WM_USER+3)     // ;Internal 4.0
                                            // ;Internal 4.0
#define STN_CLICKED         0               // ;Internal 4.0
#define STN_DBLCLK          1               // ;Internal 4.0
#define STN_ENABLE          2               // ;Internal 4.0
#define STN_DISABLE         3               // ;Internal 4.0
#endif /* WINVER >= 0x0400 */               // ;Internal 4.0
#define STM_MSGMAX         (WM_USER+4)      // ;Internal 4.0
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_PUSHBOX          0x0000000AL     // ;Internal
#define BS_OWNERDRAW        0x0000000BL
#define BS_TYPEMASK         0x0000000FL     // ;Internal

#define BS_TEXT             0x00000000L     // ;Internal 4.0
#define BS_RIGHTBUTTON      0x00000020L
#define BS_ICON             0x00000040L     // ;Internal 4.0
#define BS_BITMAP           0x00000080L     // ;Internal 4.0
#define BS_IMAGEMASK        0x000000C0L     // ;Internal 4.0
                                            // ;Internal 4.0
#define BS_LEFT             0x00000100L     // ;Internal 4.0
#define BS_RIGHT            0x00000200L     // ;Internal 4.0
#define BS_CENTER           0x00000300L     // ;Internal 4.0
#define BS_HORZMASK         0x00000300L     // ;Internal 4.0
#define BS_TOP              0x00000400L     // ;Internal 4.0
#define BS_BOTTOM           0x00000800L     // ;Internal 4.0
#define BS_VCENTER          0x00000C00L     // ;Internal 4.0
#define BS_VERTMASK         0x00000C00L     // ;Internal 4.0
#define BS_ALIGNMASK        0x00000F00L     // ;Internal 4.0
                                            // ;Internal 4.0
#define BS_PUSHLIKE         0x00001000L     // ;Internal 4.0
#define BS_MULTILINE        0x00002000L     // ;Internal 4.0
#define BS_NOTIFY           0x00004000L     // ;Internal 4.0
#define BS_FLAT             0x00008000L     // ;Internal 4.0

#define BS_LEFTTEXT         BS_RIGHTBUTTON

#ifndef NOWINMESSAGES
/* Button Control Messages  */
#define BM_FIRST_16         WM_USER         // ;Internal
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)
#define BM_CLICK            (WM_USER+5)
#define BM_GETIMAGE         (WM_USER+6)     // ;Internal 4.0
#define BM_SETIMAGE         (WM_USER+7)     // ;Internal 4.0
#define BM_MSGMAX           (WM_USER+8)     // ;Internal 4.0

#define BST_UNCHECKED       0x0000
#define BST_CHECKED         0x0001
#define BST_INDETERMINATE   0x0002
#define BST_CHECKMASK       0x0003  // ;Internal
#define BST_PUSHED          0x0004
#define BST_FOCUS           0x0008
#define BST_INCLICK         0x0010  // ;Internal -- inside click code
#define BST_CAPTURED        0x0020  // ;Internal -- we have mouse capture
#define BST_MOUSE           0x0040  // ;Internal -- mouse initiated
#define BST_DONTCLICK       0x0080  // ;Internal -- Don't check on get focus.
#define BST_INBMCLICK       0x0100  // ;Internal -- processing BM_CLICK message

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_PUSHED           2
#define BN_HILITE           BN_PUSHED
#define BN_UNPUSHED         3
#define BN_UNHILITE         BN_UNPUSHED
#define BN_DISABLE          4
#define BN_DBLCLK           5
#define BN_DOUBLECLICKED    BN_DBLCLK
#define BN_SETFOCUS         6               /* ;Internal 4.0 */
#define BN_KILLFOCUS        7               /* ;Internal 4.0 */
#endif /* NOWINMESSAGES */

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT                 0x0000L
#define ES_CENTER               0x0001L
#define ES_RIGHT                0x0002L
#define ES_MULTILINE            0x0004L
#define ES_UPPERCASE            0x0008L
#define ES_LOWERCASE            0x0010L
#define ES_PASSWORD             0x0020L
#define ES_AUTOVSCROLL          0x0040L
#define ES_AUTOHSCROLL          0x0080L
#define ES_NOHIDESEL            0x0100L
#define ES_COMBOBOX             0x0200L         /* ;Internal */
#define ES_OEMCONVERT           0x0400L
#if (WINVER >= 0x030a)
#define ES_READONLY             0x0800L
#define ES_WANTRETURN           0x1000L
#endif  /* WINVER >= 0x030a */
#if (WINVER >= 0x0400)
#define ES_NUMBER               0x2000L
#endif  /* WINVER >= 0x0400 */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_FIRST_16             WM_USER         // ;Internal
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_SCROLL               (WM_USER+5)     // ;Internal
#define EM_LINESCROLL           (WM_USER+6)
#define EM_SCROLLCARET          (WM_USER+7)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_GETTHUMB             (WM_USER+14)    // ;Internal
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_SETLIMITTEXT         (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)

#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
                                                /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                          /* ;Internal 4.0 */
#define EM_SETMARGINS           (WM_USER+35)    /* ;Internal 4.0 */
#define EM_GETMARGINS           (WM_USER+36)    /* ;Internal 4.0 */
#define EM_GETLIMITTEXT         (WM_USER+37)    /* ;Internal 4.0 */
#define EM_POSFROMCHAR          (WM_USER+38)    /* ;Internal 4.0 */
#define EM_CHARFROMPOS          (WM_USER+39)    /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                   /* ;Internal 4.0 */

#if (WINVER >= 0x0400)                          /* ;Internal 4.1 */
#define EM_SETIMESTATUS         (WM_USER+40)    /* ;Internal 4.1 */
#define EM_GETIMESTATUS         (WM_USER+41)    /* ;Internal 4.1 */
#endif /* WINVER >= 0x040A */                   /* ;Internal 4.1 */

#define EM_LIMITTEXT            EM_SETLIMITTEXT
#define EM_MSGMAX               (WM_USER+42)    // ;Internal 4.0

#if (WINVER >= 0x0400)                          /* ;Internal 4.0 */
#define EM_RESERVED1		    (WM_USER+0x40)  // ;Internal
#define EM_RESERVED2			(WM_USER+0x41)  // ;Internal
#define EM_RESERVED3			(WM_USER+0x42)  // ;Internal
#define EM_RESERVED4			(WM_USER+0x43)  // ;Internal
#define EM_RESERVED5			(WM_USER+0x44)  // ;Internal
#endif /* WINVER >= 0x0400 */                   /* ;Internal 4.0 */

#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT                 0
#define WB_RIGHT                1
#define WB_ISDELIMITER          2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS             0x0100
#define EN_KILLFOCUS            0x0200
#define EN_CHANGE               0x0300
#define EN_UPDATE               0x0400
#define EN_ERRSPACE             0x0500
#define EN_MAXTEXT              0x0501
#define EN_HSCROLL              0x0601
#define EN_VSCROLL              0x0602

#if (WINVER >= 0x0400)
#define  EN_ALIGN_LTR      (0x700)
#define  EN_ALIGN_RTL      (0x701)
#endif
                                        /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                  /* ;Internal 4.0 */
#define  EC_LEFTMARGIN          0x0001  /* ;Internal 4.0 */
#define  EC_RIGHTMARGIN         0x0002  /* ;Internal 4.0 */
#define  EC_USEFONTINFO         0xffff  /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */           /* ;Internal 4.0 */

#if (WINVER >= 0x0400)                          /* ;Internal 4.1 */
/* wParam of EM_GET/SETIMESTATUS  */            /* ;Internal 4.1 */
#define EMSIS_COMPOSITIONSTRING        0x0001   /* ;Internal 4.1 */
#define EMSIS_GETLBBIT                 0x8001   /* ;Internal 4.1 */
                                                /* ;Internal 4.1 */
/* lParam for EMSIS_COMPOSITIONSTRING  */       /* ;Internal 4.1 */
#define EIMES_GETCOMPSTRATONCE         0x0001   /* ;Internal 4.1 */
#define EIMES_CANCELCOMPSTRINFOCUS     0x0002   /* ;Internal 4.1 */
#define EIMES_COMPLETECOMPSTRKILLFOCUS 0x0004   /* ;Internal 4.1 */
#endif /* WINVER >= 0x040A */                   /* ;Internal 4.1 */

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                0x0000L /* Type of scrollbar */
#define SBS_VERT                0x0001L /* Type of scrollbar */
#define SBS_TOPALIGN            0x0002L
#define SBS_LEFTALIGN           0x0002L
#define SBS_BOTTOMALIGN         0x0004L
#define SBS_RIGHTALIGN          0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX             0x0008L /* Type of scrollbar */
#define SBS_SIZEGRIP            0x0010L /* Type of scrollbar */

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY              0x0001L
#define LBS_SORT                0x0002L
#define LBS_NOREDRAW            0x0004L
#define LBS_MULTIPLESEL         0x0008L
#define LBS_OWNERDRAWFIXED      0x0010L
#define LBS_OWNERDRAWVARIABLE   0x0020L
#define LBS_HASSTRINGS          0x0040L
#define LBS_USETABSTOPS         0x0080L
#define LBS_NOINTEGRALHEIGHT    0x0100L
#define LBS_MULTICOLUMN         0x0200L
#define LBS_WANTKEYBOARDINPUT   0x0400L
#define LBS_EXTENDEDSEL         0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL     0x1000L
#define LBS_NODATA              0x2000L
#if (WINVER >= 0x0400)
#define LBS_NOSEL               0x4000L
#endif  /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */
#define LBS_COMBOBOX            0x8000L         // ;Internal
#define LBS_STANDARD            (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_FIRST_16             (WM_USER+1)     // ;Internal
#define LB_ADDSTRING            (WM_USER+1)
#define LB_INSERTSTRING         (WM_USER+2)
#define LB_DELETESTRING         (WM_USER+3)
#define LB_SELITEMRANGEEX       (WM_USER+4)     // ;Internal 4.0 NT
#define LB_RESETCONTENT         (WM_USER+5)
#define LB_SETSEL               (WM_USER+6)
#define LB_SETCURSEL            (WM_USER+7)
#define LB_GETSEL               (WM_USER+8)
#define LB_GETCURSEL            (WM_USER+9)
#define LB_GETTEXT              (WM_USER+10)
#define LB_GETTEXTLEN           (WM_USER+11)
#define LB_GETCOUNT             (WM_USER+12)
#define LB_SELECTSTRING         (WM_USER+13)
#define LB_DIR                  (WM_USER+14)
#define LB_GETTOPINDEX          (WM_USER+15)
#define LB_FINDSTRING           (WM_USER+16)
#define LB_GETSELCOUNT          (WM_USER+17)
#define LB_GETSELITEMS          (WM_USER+18)
#define LB_SETTABSTOPS          (WM_USER+19)
#define LB_GETHORIZONTALEXTENT  (WM_USER+20)
#define LB_SETHORIZONTALEXTENT  (WM_USER+21)
#define LB_SETCOLUMNWIDTH       (WM_USER+22)
#define LB_ADDFILE              (WM_USER+23)    // ;Internal
#define LB_SETTOPINDEX          (WM_USER+24)
#define LB_GETITEMRECT          (WM_USER+25)
#define LB_GETITEMDATA          (WM_USER+26)
#define LB_SETITEMDATA          (WM_USER+27)
#define LB_SELITEMRANGE         (WM_USER+28)
#define LB_SETANCHORINDEX       (WM_USER+29)
#define LB_GETANCHORINDEX       (WM_USER+30)
#define LB_SETCARETINDEX        (WM_USER+31)
#define LB_GETCARETINDEX        (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT        (WM_USER+33)
#define LB_GETITEMHEIGHT        (WM_USER+34)
#define LB_FINDSTRINGEXACT      (WM_USER+35)
#define LBCB_CARETON            (WM_USER+36)    // ;Internal
#define LBCB_CARETOFF           (WM_USER+37)    // ;Internal
                                                // ;Internal NT
#define LB_SETLOCALE            (WM_USER+38)    // ;Internal NT
#define LB_GETLOCALE            (WM_USER+39)    // ;Internal NT
#define LB_SETCOUNT             (WM_USER+40)    // ;Internal NT
                                                // ;Internal
#if (WINVER >= 0x0400)                          // ;Internal 4.0
#define LB_FIRST_40             (WM_USER+41)    // ;Internal 4.0
#define LB_INITSTORAGE          (WM_USER+41)    // ;Internal 4.0
#define LB_ITEMFROMPOINT        (WM_USER+42)    // ;Internal 4.0
#define LB_INSERTSTRINGUPPER    (WM_USER+43)    // ;Internal 4.0
#define LB_INSERTSTRINGLOWER    (WM_USER+44)    // ;Internal 4.0
#define LB_ADDSTRINGUPPER       (WM_USER+45)    // ;Internal 4.0
#define LB_ADDSTRINGLOWER       (WM_USER+46)    // ;Internal 4.0
#endif  /* WINVER >= 0x0400 */                  // ;Internal 4.0
#endif  /* WINVER >= 0x030a */
                                                // ;Internal
#define LB_MSGMAX               (WM_USER+47)    // ;Internal

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE            (-2)
#define LBN_SELCHANGE           1
#define LBN_DBLCLK              2
#define LBN_SELCANCEL           3
#define LBN_SETFOCUS            4
#define LBN_KILLFOCUS           5

/* Listbox message return values */
#define LB_OKAY                 0
#define LB_ERR                  (-1)
#define LB_ERRSPACE             (-2)

#define LB_CTLCODE              0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE           0x0000
#define DDL_READONLY            0x0001
#define DDL_HIDDEN              0x0002
#define DDL_SYSTEM              0x0004
#define DDL_DIRECTORY           0x0010
#define DDL_ARCHIVE             0x0020

#define DDL_NOFILES             0x1000  /* ;Internal */
#define DDL_POSTMSGS            0x2000
#define DDL_DRIVES              0x4000
#define DDL_EXCLUSIVE           0x8000
#define DDL_VALID               0xf03f  /* ;Internal */

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE              0x0001L
#define CBS_DROPDOWN            0x0002L
#define CBS_DROPDOWNLIST        0x0003L
#define CBS_OWNERDRAWFIXED      0x0010L
#define CBS_OWNERDRAWVARIABLE   0x0020L
#define CBS_AUTOHSCROLL         0x0040L
#define CBS_OEMCONVERT          0x0080L
#define CBS_SORT                0x0100L
#define CBS_HASSTRINGS          0x0200L
#define CBS_NOINTEGRALHEIGHT    0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL     0x0800L
#if (WINVER >= 0x0400)                      /* ;Internal 4.0 */
#define CBS_UPPERCASE           0x2000L     /* ;Internal 4.0 */
#define CBS_LOWERCASE           0x4000L     /* ;Internal 4.0 */
#endif  /* WINVER >= 0x0400 */              /* ;Internal 4.0 */
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_FIRST_16             (WM_USER+0) // ;Internal
#define CB_GETEDITSEL           (WM_USER+0)
#define CB_LIMITTEXT            (WM_USER+1)
#define CB_SETEDITSEL           (WM_USER+2)
#define CB_ADDSTRING            (WM_USER+3)
#define CB_DELETESTRING         (WM_USER+4)
#define CB_DIR                  (WM_USER+5)
#define CB_GETCOUNT             (WM_USER+6)
#define CB_GETCURSEL            (WM_USER+7)
#define CB_GETLBTEXT            (WM_USER+8)
#define CB_GETLBTEXTLEN         (WM_USER+9)
#define CB_INSERTSTRING         (WM_USER+10)
#define CB_RESETCONTENT         (WM_USER+11)
#define CB_FINDSTRING           (WM_USER+12)
#define CB_SELECTSTRING         (WM_USER+13)
#define CB_SETCURSEL            (WM_USER+14)
#define CB_SHOWDROPDOWN         (WM_USER+15)
#define CB_GETITEMDATA          (WM_USER+16)
#define CB_SETITEMDATA          (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT        (WM_USER+19)
#define CB_GETITEMHEIGHT        (WM_USER+20)
#define CB_SETEXTENDEDUI        (WM_USER+21)
#define CB_GETEXTENDEDUI        (WM_USER+22)
#define CB_GETDROPPEDSTATE      (WM_USER+23)
#define CB_FINDSTRINGEXACT      (WM_USER+24)
                                                /* ;Internal NT */
#define CB_SETLOCALE            (WM_USER+25)    /* ;Internal NT */
#define CB_GETLOCALE            (WM_USER+26)    /* ;Internal NT */
#if (WINVER >= 0x0400)                          /* ;Internal 4.0 */
#define CB_FIRST_40             (WM_USER+27)    // ;Internal 4.0
#define CB_GETTOPINDEX          (WM_USER+27)    /* ;Internal 4.0 */
#define CB_SETTOPINDEX          (WM_USER+28)    /* ;Internal 4.0 */
#define CB_GETHORIZONTALEXTENT  (WM_USER+29)    /* ;Internal 4.0 */
#define CB_SETHORIZONTALEXTENT  (WM_USER+30)    /* ;Internal 4.0 */
#define CB_GETDROPPEDWIDTH      (WM_USER+31)    /* ;Internal 4.0 */
#define CB_SETDROPPEDWIDTH      (WM_USER+32)    /* ;Internal 4.0 */
#define CB_INITSTORAGE          (WM_USER+33)    /* ;Internal 4.0 */
#endif  /* WINVER >= 0x0400 */                  /* ;Internal 4.0 */
#endif  /* WINVER >= 0x030a */
#define CB_MSGMAX               (WM_USER+34)    // ;Internal 4.0

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE            (-1)
#define CBN_SELCHANGE           1
#define CBN_DBLCLK              2
#define CBN_SETFOCUS            3
#define CBN_KILLFOCUS           4
#define CBN_EDITCHANGE          5
#define CBN_EDITUPDATE          6
#define CBN_DROPDOWN            7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP             8
#define CBN_SELENDOK            9
#define CBN_SELENDCANCEL        10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY                 0
#define CB_ERR                  (-1)
#define CB_ERRSPACE             (-2)

#endif /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */
                                                                // ;Internal
#define WH_MIN                  (-1)                            // ;Internal
#define WH_MAX                  12                              // ;Internal
#define WH_MINHOOK              WH_MIN                          // ;Internal
#define WH_MAXHOOK              WH_MAX                          // ;Internal
#define WH_CHOOKS               (WH_MAXHOOK - WH_MINHOOK+1)     // ;Internal

/* Standard hook code */
#define HC_ACTION               0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN            (-3)
#define HC_LPLPFNNEXT           (-2)
#define HC_LPFNNEXT             (-1)

#endif /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE        0
#define HCBT_MINMAX          1
#define HCBT_QS              2
#define HCBT_CREATEWND       3
#define HCBT_DESTROYWND      4
#define HCBT_ACTIVATE        5
#define HCBT_CLICKSKIPPED    6
#define HCBT_KEYSKIPPED      7
#define HCBT_SYSCOMMAND      8
#define HCBT_SETFOCUS        9
#define HCBT_SETWINDOWTEXT  10

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    LPCREATESTRUCT lpcs;
#ifdef tagWND                   /* ;Internal */
    HWND_16 hwndInsertAfter;    /* ;Internal */
#else                           /* ;Internal */
    HWND    hwndInsertAfter;
#endif                          /* ;Internal */
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
#ifdef tagWND                   /* ;Internal */
    HWND_16 hWndActive;         /* ;Internal */
#else                           /* ;Internal */
    HWND    hWndActive;
#endif                          /* ;Internal */
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
#ifdef tagWND           /* ;Internal */
    HWND_16 hWnd;       /* ;Internal */
#else                   /* ;Internal */
    HWND    hWnd;
#endif                  /* ;Internal */
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3
#if (WINVER >= 0x0400)
#define HSHELL_WINDOWACTIVATED     4
#define HSHELL_GETMINRECT          5
#define HSHELL_REDRAW              6
#define HSHELL_TASKMAN             7
#define HSHELL_LANGUAGE            8 
#endif  /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG *PEVENTMSGMSG;                 /* ;Internal */
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSGMSG;            /* ;Internal */

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif /* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG        9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT        0x0001
#define HELP_QUIT           0x0002
#define HELP_INDEX          0x0003
#define HELP_CONTENTS       0x0003
#define HELP_HELPONHELP     0x0004
#define HELP_SETINDEX       0x0005
#define HELP_SETCONTENTS    0x0005
#define HELP_CONTEXTPOPUP   0x0008
#define HELP_FORCEFILE      0x0009
#define HELP_KEY            0x0101
#define HELP_COMMAND        0x0102
#define HELP_PARTIALKEY     0x0105
#define HELP_MULTIKEY       0x0201
#define HELP_SETWINPOS      0x0203

#if (WINVER >= 0x0400)

#define HELP_CONTEXTMENU    0x000a
#define HELP_FINDER         0x000b
#define HELP_WM_HELP        0x000c
#define HELP_SETPOPUP_POS   0x000d

#define HELP_TCARD          0x8000
#define HELP_TCARD_DATA     0x0010
#define HELP_TCARD_NEXT     0x0011
#define HELP_TCARD_OTHER_CALLER 0x0011

#endif  /* WINVER >= 0x0400 */

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

#if (WINVER >= 0x0400)
#define HELPINFO_WINDOW    0x0001
#define HELPINFO_MENUITEM  0x0002
typedef  struct  tagHELPINFO
{
    DWORD   cbSize;
    int     iContextType;
    int     iCtrlId;
    HANDLE  hItemHandle;
    DWORD   dwContextId;
    POINT   MousePos;
}
HELPINFO, FAR* LPHELPINFO;
                                                    /* ;Internal 4.0 */
BOOL  WINAPI  SetWindowContextHelpId(HWND, DWORD);  /* ;Internal 4.0 */
DWORD WINAPI  GetWindowContextHelpId(HWND);         /* ;Internal 4.0 */
BOOL  WINAPI  SetMenuContextHelpId(HMENU, DWORD);   /* ;Internal 4.0 */
DWORD WINAPI  GetMenuContextHelpId(HMENU);          /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */


/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
#ifdef tagWND   // ;Internal
BOOL    WINAPI MessageBeep(UINT);   // ;Internal
#else           // ;Internal
void    WINAPI MessageBeep(UINT);
#endif          // ;Internal

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONERROR        0x0010      /* ;win40: Name changed from MB_ICONHAND */
#define MB_ICONQUESTION     0x0020
#define MB_ICONWARNING      0x0030      /* ;win40: Name changed from MB_ICONEXCLAMATION */
#define MB_ICONINFORMATION  0x0040      /* ;win40: Name changed from MB_ICONASTERISK */
#if (WINVER >= 0x400)                   /* ;Internal 4.0 */
#define MB_USERICON         0x0080      /* ;Internal 4.0 */
#endif                                  /* ;Internal 4.0 */
#define MB_ICONMASK         0x00F0

#define MB_ICONHAND         MB_ICONERROR
#define MB_ICONSTOP         MB_ICONERROR
#define MB_ICONEXCLAMATION  MB_ICONWARNING
#define MB_ICONASTERISK     MB_ICONINFORMATION

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#if (WINVER >= 0x0400)
#define MB_DEFBUTTON4       0x0300
#endif
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000
                                                                // ;Internal 4.0
#if (WINVER >= 0x0400)                                          // ;Internal 4.0
#define MB_HELP             0x4000                              // ;Internal 4.0
#define MB_RIGHT			0x00080000
#define MB_RTLREADING		0x00100000
#endif                                                          // ;Internal 4.0
#define MB_NOFOCUS          0x8000
                                                                // ;Internal 4.0
#define MB_TYPEMASK         0x000F                              // ;Internal 4.0
#define MB_ICONMASK         0x00F0                              // ;Internal 4.0
#define MB_DEFMASK          0x0F00                              // ;Internal 4.0
#define MB_MODEMASK         0x3000                              // ;Internal 4.0
#define MB_MISCMASK         0xC000                              // ;Internal 4.0
#define MB_VALID            0xb377                              // ;Internal 4.0
                                                                // ;Internal 4.0
#define MB_SETFOREGROUND    0x00010000                          // ;Internal NT
// #define MB_DEFAULT_DESKTOP_ONLY  0x00020000                  // ;Internal NT
#if (WINVER >= 0x0400)                                          // ;Internal NT
int WINAPI MessageBoxEx(HWND, LPCSTR, LPCSTR, DWORD, WORD);     // ;Internal NT
#endif // WINVER >= 0x0400                                      // ;Internal NT
                                                                // ;Internal 4.0
#if (WINVER >= 0x400)                                           // ;Internal 4.0
#define MB_TOPMOST          0x00040000                          // ;Internal 4.0
#define MBEX_VALIDL         0xf3f7                              // ;Internal 4.0
#define MBEX_VALIDH         1                                   // ;Internal 4.0
                                                                // ;Internal 4.0
typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo); // ;Internal 4.0
                                                                // ;Internal 4.0
typedef struct tagMSGBOXPARAMS                                  // ;Internal 4.0
{                                                               // ;Internal 4.0
    DWORD           cbSize;                                     // ;Internal 4.0
#ifdef tagWND                                                   // ;Internal 4.0
    HWND_16         hwndOwner;                                  // ;Internal 4.0
#else                                                           // ;Internal 4.0
    HWND            hwndOwner;                                  // ;Internal 4.0
#endif                                                          // ;Internal 4.0
    HINSTANCE       hInstance;                                  // ;Internal 4.0
    LPCSTR          lpszText;                                   // ;Internal 4.0
    LPCSTR          lpszCaption;                                // ;Internal 4.0
    DWORD           dwStyle;                                    // ;Internal 4.0
    LPCSTR          lpszIcon;                                   // ;Internal 4.0
    DWORD           dwContextHelpId;                            // ;Internal 4.0
    MSGBOXCALLBACK  lpfnMsgBoxCallback;                         // ;Internal 4.0
    DWORD	    dwLanguageId;				// ;Internal 4.0
}   MSGBOXPARAMS, FAR *LPMSGBOXPARAMS;                          // ;Internal 4.0
                                                                // ;Internal 4.0
int     WINAPI MessageBoxIndirect(LPMSGBOXPARAMS);              // ;Internal 4.0
#endif /* WINVER >=0x0400 */                                    // ;Internal 4.0
#endif  /* NOMB */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
LPINT   WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512     0
#define S_PERIOD1024    1
#define S_PERIOD2048    2
#define S_PERIODVOICE   3
#define S_WHITE512      4
#define S_WHITE1024     5
#define S_WHITE2048     6
#define S_WHITEVOICE    7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY    0
#define S_THRESHOLD     1
#define S_ALLTHRESHOLD  2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL        0
#define S_LEGATO        1
#define S_STACCATO      2

/* Error return values */
#define S_SERDVNA       (-1)
#define S_SEROFM        (-2)
#define S_SERMACT       (-3)
#define S_SERQFUL       (-4)
#define S_SERBDNT       (-5)
#define S_SERDLN        (-6)
#define S_SERDCC        (-7)
#define S_SERDTP        (-8)
#define S_SERDVL        (-9)
#define S_SERDMD        (-10)
#define S_SERDSH        (-11)
#define S_SERDPT        (-12)
#define S_SERDFQ        (-13)
#define S_SERDDR        (-14)
#define S_SERDSR        (-15)
#define S_SERDST        (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY        0
#define ODDPARITY       1
#define EVENPARITY      2
#define MARKPARITY      3
#define SPACEPARITY     4

#define ONESTOPBIT      0
#define ONE5STOPBITS    1
#define TWOSTOPBITS     2

#define IGNORE          0
#define INFINITE        0xFFFF

/* Error Flags */
#define CE_RXOVER       0x0001
#define CE_OVERRUN      0x0002
#define CE_RXPARITY     0x0004
#define CE_FRAME        0x0008
#define CE_BREAK        0x0010
#define CE_CTSTO        0x0020
#define CE_DSRTO        0x0040
#define CE_RLSDTO       0x0080
#define CE_TXFULL       0x0100
#define CE_PTO          0x0200
#define CE_IOE          0x0400
#define CE_DNS          0x0800
#define CE_OOP          0x1000
#define CE_MODE         0x8000

#define IE_BADID        (-1)
#define IE_OPEN         (-2)
#define IE_NOPEN        (-3)
#define IE_MEMORY       (-4)
#define IE_DEFAULT      (-5)
#define IE_HARDWARE     (-10)
#define IE_BYTESIZE     (-11)
#define IE_BAUDRATE     (-12)

/* Events */
#define EV_RXCHAR       0x0001
#define EV_RXFLAG       0x0002
#define EV_TXEMPTY      0x0004
#define EV_CTS          0x0008
#define EV_DSR          0x0010
#define EV_RLSD         0x0020
#define EV_BREAK        0x0040
#define EV_ERR          0x0080
#define EV_RING         0x0100
#define EV_PERR         0x0200
#define EV_CTSS         0x0400
#define EV_DSRS         0x0800
#define EV_RLSDS        0x1000
#define EV_RingTe       0x2000
#define EV_RINGTE       EV_RingTe
#define EV_VALID        0x3fff  /* ;Internal */

/* Escape Functions */
#define SETXOFF         1
#define SETXON          2
#define SETRTS          3
#define CLRRTS          4
#define SETDTR          5
#define CLRDTR          6
#define RESETDEV        7

#define LPTx            0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT       8
#define GETMAXCOM       9
#define GETBASEIRQ      10

/* Comm Baud Rate indices */
#define CBR_110         0xFF10
#define CBR_300         0xFF11
#define CBR_600         0xFF12
#define CBR_1200        0xFF13
#define CBR_2400        0xFF14
#define CBR_4800        0xFF15
#define CBR_9600        0xFF16
#define CBR_14400       0xFF17
#define CBR_19200       0xFF18
#define CBR_38400       0xFF1B
#define CBR_56000       0xFF1F
#define CBR_128000      0xFF23
#define CBR_256000      0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE      0x0001
#define CN_TRANSMIT     0x0002
#define CN_EVENT        0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD            0x0001
#define DRV_ENABLE          0x0002
#define DRV_OPEN            0x0003
#define DRV_CLOSE           0x0004
#define DRV_DISABLE         0x0005
#define DRV_FREE            0x0006
#define DRV_CONFIGURE       0x0007
#define DRV_QUERYCONFIGURE  0x0008
#define DRV_INSTALL         0x0009
#define DRV_REMOVE          0x000A
#define DRV_EXITSESSION     0x000B
#define DRV_EXITAPPLICATION 0x000C
#define DRV_POWER           0x000F
#define DRV_NOTIFYMSG	      0x0010
/*#define DRV_QUERYENDSESSION 0x0010      */
/*#define DRV_EXITSESSIONCANCELLED 0x0011 */

#define DRV_RESERVED        0x0800
#define DRV_USER            0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL       0x0000
#define DRVCNF_OK           0x0001
#define DRVCNF_RESTART      0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT    0x0001
#define DRVEA_ABNORMALEXIT  0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002
#define GND_VALID               0x00000003  /* ;Internal */

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */

/****** Installable Message Thunk support ***********************************/

#if (WINVER > 0x030a)
#ifndef NOIMT

/* wReason codes */
#define IMT_REASON_ASYNC    0x00001
#define IMT_REASON_LS       0x00002
#define IMT_REASON_AFTER    0x00004

typedef struct tagIMTMSG
{
    HWND    hwnd;
    UINT    message;
    DWORD   wParam;
    LPARAM  lParam;
} IMTMSG, FAR* LPIMTMSG;

typedef struct tagIMTBUFFER
{
    DWORD   dwT1;
    DWORD   dwT2;
} IMTBUFFER, FAR* LPIMTBUFFER;

typedef BOOL (CALLBACK *IMTDISP)(WORD wReason, LPDWORD lpRetVal,
                                 LPIMTMSG lpMsg, LPIMTBUFFER lpBuffer);
BOOL WINAPI InstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                       WORD msgLo, WORD msgHi);
BOOL WINAPI UnInstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                         WORD msgLo, WORD msgHi);

#endif  /* !NOIMT */
#endif  /* WINVER > 0x030a */

#endif  /* NOUSER */

#if (WINVER >= 0x040A)                          // ;Internal 4.1
#define        MWMO_WAITALL         0x0001      // ;Internal 4.1
#define        MWMO_ALERTABLE       0x0002      // ;Internal 4.1
#define        MWMO_INPUTAVAILABLE  0x0004      // ;Internal 4.1
#endif  /* WINVER >= 0x040A */                  // ;Internal 4.1

DWORD WINAPI RegisterServiceProcess(DWORD dwProcessId, DWORD dwServiceType);
#define RSP_UNREGISTER_SERVICE	0x00000000
#define RSP_SIMPLE_SERVICE	0x00000001

VOID WINAPI RegisterNetworkCapabilities(DWORD dwBitsToSet, DWORD dwValues);
#define RNC_NETWORKS  		0x00000001

                                                                                    // ;Internal
VOID API RegisterSystemThread(DWORD flags, DWORD reserved);                         // ;Internal
#define RST_DONTATTACHQUEUE         0x00000001                                      // ;Internal
#define RST_DONTJOURNALATTACH       0x00000002                                      // ;Internal
#define RST_ALWAYSFOREGROUNDABLE    0x00000004                                      // ;Internal
#define RST_FAULTTHREAD             0x00000008                                      // ;Internal
                                                                                    // ;Internal
DWORD API EndTask(HWND hwnd, DWORD idProcess, LPSTR lpszCaption, DWORD dwFlags);    // ;Internal
                                                                                    // ;Internal
#define ET_ALLOWFORWAIT     0x00000001                                              // ;Internal
#define ET_TRYTOKILLNICELY  0x00000002                                              // ;Internal
#define ET_NOUI             0x00000004                                              // ;Internal
#define ET_NOWAIT           0x00000008                                              // ;Internal
                                                                                    // ;Internal
#define ET_VALID            0x0000000F                                              // ;Internal

BOOL API IsValidLocale(DWORD Lcid, DWORD dwFlags);	/* ;Internal */
#define LCID_INSTALLED	    0x00000001			/* ;Internal */

#if (WINVER >= 0x040A)                                  // ;Internal 4.1
//                                                      // ;Internal 4.1
// EXECUTION_STATE for SetThreadExecutionState esFlags 	// ;Internal 4.1
//                                                      // ;Internal 4.1
                                                        // ;Internal 4.1
#define ES_SYSTEM_REQUIRED	((ULONG)0x00000001)         // ;Internal 4.1
#define ES_DISPLAY_REQUIRED	((ULONG)0x00000002)         // ;Internal 4.1
#define ES_CONTINUOUS		((ULONG)0x80000000)         // ;Internal 4.1
                                                        // ;Internal 4.1
typedef ULONG EXECUTION_STATE;                          // ;Internal 4.1
                                                        // ;Internal 4.1
#endif  /* WINVER >= 0x040A */                  // ;Internal 4.1
                                        /* ;Internal */
#ifndef NOWINDOWSX                      /* ;Internal */
#ifndef RC_INVOKED                      /* ;Internal */
#include <windowsx.h>                   /* ;Internal */
#ifndef STRICT                          /* ;Internal */
#undef  SelectFont                      /* ;Internal */
#endif  /* STRICT */                    /* ;Internal */
#endif  /* RC_INVOKED */                /* ;Internal */
#endif  /* NOWINDOWSX */                /* ;Internal */
                                        /* ;Internal */
#ifdef tagWND                           /* ;Internal */
#ifdef DEBUG                            /* ;Internal */
#undef HWND                             /* ;Internal */
#undef HWNDC                            /* ;Internal */
#undef HMENU                            /* ;Internal */
typedef struct tagWND  BASED    *HWND;  /* ;Internal */
typedef HWND HWNDC;                     /* ;Internal */
typedef struct tagMENU FAR      *HMENU; /* ;Internal */
#endif                                  /* ;Internal */
#endif /* tagWND */                     /* ;Internal */


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif /* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\tregupr2\crypt.c ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  crypt.c
                                                              
     Abstract:  Encryption/Decryption routines
                                                              
       Author:  radus - 11/05/98
              

        Notes:  Used for encrypting/decrypting of the PIN numbers.
                It is NOT thread-safe

        
  Rev History:

****************************************************************************/

#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include "tregupr2.h"
#include "debug.h"

// Context
static LONG        gdwNrOfClients       = 0;
static PTSTR       gpszSidText          = NULL;
static HCRYPTPROV  ghCryptProvider      = 0;
static BOOL        gbUseOnlyTheOldAlgorithm = TRUE; 
static BOOL        gbCryptAvailChecked  = FALSE;
static BOOL        gbCryptAvailable     = TRUE;


static const CHAR  MAGIC_1  =  'B';
static const CHAR  MAGIC_5  =  'L';
static const CHAR  MAGIC_2  =  'U';
static const CHAR  MAGIC_4  =  'U';
static const CHAR  MAGIC_3  =  'B';

#define ENCRYPTED_MARKER    L'X'


// prototypes
static BOOL GetUserSidText(LPTSTR  *);
static BOOL GetUserTokenUser(TOKEN_USER  **);
static BOOL ConvertSidToText(PSID, LPTSTR, LPDWORD);
static BOOL CreateSessionKey(HCRYPTPROV, LPTSTR, DWORD, HCRYPTKEY *);
static void DestroySessionKey(HCRYPTKEY );
static void Unscrambler( DWORD, LPWSTR, LPWSTR );
static void CopyScrambled( LPWSTR, LPWSTR, DWORD);
 

DWORD TapiCryptInitialize(void)
{
    DWORD           dwNew;
    DWORD           dwError;
    HCRYPTKEY       hKey;
    PBYTE           bTestData = "Testing";
    DWORD           dwTestSize = strlen(bTestData);

    // Only one initialization
    dwNew = InterlockedIncrement(&gdwNrOfClients);
    if(dwNew>1)
        return ERROR_SUCCESS;
    // By default
    gbUseOnlyTheOldAlgorithm = TRUE;
    dwError = ERROR_SUCCESS;

#ifdef WINNT
    // New encryption only for Windows NT

    if(gbCryptAvailable || !gbCryptAvailChecked)
    {

        // Acquire CryptoAPI context
        if(CryptAcquireContext( &ghCryptProvider,
                                NULL,
                                MS_DEF_PROV,
                                PROV_RSA_FULL,
                                CRYPT_VERIFYCONTEXT  // No need of private/public keys
                                ))
        {
            // Get the user SID
            if(GetUserSidText(&gpszSidText))
            {
                
                if (gbCryptAvailChecked == FALSE)
	            {
                    if(CreateSessionKey(ghCryptProvider, gpszSidText, 0, &hKey))
                    {
        	        // try to use the test key and check for the NTE_PERM error meaning that we are not 
		            // going to be able to use crypt
		                if (CryptEncrypt(hKey, 0, TRUE, 0, (BYTE *)bTestData, &dwTestSize, 0) == FALSE)
		                {
			                if (GetLastError() == NTE_PERM)
			                {
                                DBGOUT((5, "Encryption unavailable"));
				                gbCryptAvailable = FALSE;
                            }
                        }
// FOR TEST
//                      DBGOUT((5, "Encryption unavailable"));  // Test Only
//    	                gbCryptAvailable = FALSE;               // Test Only

		                gbCryptAvailChecked = TRUE;
                        DestroySessionKey(hKey);
                    }
                    else
                        dwError = GetLastError();
                }
                gbUseOnlyTheOldAlgorithm = !gbCryptAvailable;
            }
            else
                dwError = GetLastError();
        }
        else
        {
            dwError = GetLastError();
            DBGOUT((5, "CryptAcquireContext failed"));

        }
    }
    

#endif // WINNT

    return dwError;
}



void  TapiCryptUninitialize(void)
{
    DWORD   dwNew;

    dwNew = InterlockedDecrement(&gdwNrOfClients);
    if(dwNew>0)
        return;

#ifdef WINNT
    
    if(ghCryptProvider)
    {
        CryptReleaseContext(ghCryptProvider, 0);
        ghCryptProvider = 0;
    }
    if(gpszSidText)
    {
        GlobalFree(gpszSidText);
        gpszSidText = NULL;
    }
    
#endif
    
    gbUseOnlyTheOldAlgorithm = TRUE;

    return;
}

/////////////////////////////////
//  TapiEncrypt
//
//  Encrypts the text specified in pszSource.
//  Uses the old scrambling algorithm or a cryptographic one.
//  The result buffer should be a little bit larger than the source - for pads, etc.
//


DWORD TapiEncrypt(PWSTR pszSource, DWORD dwKey, PWSTR pszDest, DWORD *pdwLengthNeeded)
{
    DWORD       dwError;
    DWORD       dwDataLength,
                dwLength,
                dwLengthDwords,
                dwLengthAlpha;
    // for speed
    BYTE        bBuffer1[0x20];
    
    PBYTE       pBuffer1 = NULL;
    HCRYPTKEY   hKey = 0;

    DWORD       *pdwCrt1;
    WCHAR       *pwcCrt2;

    DWORD       dwShift;
    DWORD       dwCount, dwCount2;

#ifdef WINNT

    if(!gbUseOnlyTheOldAlgorithm)
    {
        // A null PIN is not encrypted
        if(*pszSource==L'\0')
        {
            if(pszDest)
                *pszDest = L'\0';
            if(pdwLengthNeeded)
                *pdwLengthNeeded = 1;

            return ERROR_SUCCESS;
        }
         
        dwDataLength = (wcslen(pszSource) + 1)*sizeof(WCHAR); // in bytes
        dwLength = dwDataLength + 16;                         // space for pads, a marker etc.
        dwLengthAlpha = dwLength*3;                       // due to the binary->alphabetic conversion

        if(pszDest==NULL && pdwLengthNeeded != NULL)
        {
            *pdwLengthNeeded = dwLengthAlpha/sizeof(WCHAR);   // length in characters
            dwError = ERROR_SUCCESS;
        }
        else
        {
      
            ZeroMemory(bBuffer1, sizeof(bBuffer1));

            pBuffer1 = dwLength>sizeof(bBuffer1) ? (PBYTE)GlobalAlloc(GPTR, dwLength) : bBuffer1;
            if(pBuffer1!=NULL)
            {
                // Copy the source
                wcscpy((PWSTR)pBuffer1, pszSource);
                // create session key
                if(CreateSessionKey(ghCryptProvider, gpszSidText, dwKey, &hKey))
                {
                    // Encrypt inplace
                    if(CryptEncrypt(hKey,
                                    0,
                                    TRUE,
                                    0,
                                    pBuffer1,
                                    &dwDataLength,
                                    dwLength))
                    {
                        // Convert to UNICODE between 0030 - 006f
                        // I hope !
                        assert((dwDataLength % sizeof(DWORD))==0);
                        assert(sizeof(DWORD)==4);
                        assert(sizeof(DWORD) == 2*sizeof(WCHAR));

                        pdwCrt1 = (DWORD *)pBuffer1;
                        pwcCrt2 = (WCHAR *)pszDest;

                        // Place a marker
                        *pwcCrt2++ = ENCRYPTED_MARKER;

                        // dwDataLength has the length in bytes of the ciphered data
                        dwLengthAlpha = dwDataLength*3;                      
                        dwLengthDwords = dwDataLength / sizeof(DWORD);
                        for(dwCount=0; dwCount<dwLengthDwords; dwCount++)
                        {
                            dwShift = *pdwCrt1++;

                            for(dwCount2=0; dwCount2<6; dwCount2++)
                            {
                                *pwcCrt2++ = (WCHAR)((dwShift & 0x3f) + 0x30);
                                dwShift >>= 6;
                            }
                        }
                        // Put a NULL terminator
                        *pwcCrt2++ = L'\0';

                        if(pdwLengthNeeded)
                            *pdwLengthNeeded = (dwLengthAlpha/sizeof(WCHAR))+2; // including the NULL and the marker
                        
                        dwError = ERROR_SUCCESS;
                    }
                    else
                        dwError = GetLastError();
                }
                else
                    dwError = GetLastError();
            }
            else
                dwError = GetLastError();
        }
        
        if(pBuffer1 && pBuffer1!=bBuffer1)
            GlobalFree(pBuffer1);
        if(hKey!=0)
            DestroySessionKey(hKey);
    }
    else
    {
#endif
        if(pdwLengthNeeded != NULL)
        {
            *pdwLengthNeeded = wcslen(pszSource) + 1; // dim in characters
        }
        
        if(pszDest!=NULL)
        {
            CopyScrambled(pszSource, pszDest, dwKey);
        }
        dwError = ERROR_SUCCESS;

#ifdef WINNT
    }
#endif

    return dwError;

}



DWORD TapiDecrypt(PWSTR pszSource, DWORD dwKey, PWSTR pszDest, DWORD *pdwLengthNeeded)
{
    DWORD           dwError;
    DWORD           dwLengthCrypted;
    DWORD           dwDataLength;
    DWORD           dwLengthDwords;
    HCRYPTKEY       hKey = 0;
    WCHAR           *pwcCrt1;
    DWORD           *pdwCrt2;
    DWORD           dwCount;
    DWORD           dwCount2;
    DWORD           dwShift;



    // A null PIN is not encrypted
    if(*pszSource==L'\0')
    {
        if(pszDest)
            *pszDest = L'\0';
        if(pdwLengthNeeded)
            *pdwLengthNeeded = 1;

        return ERROR_SUCCESS;
    }

    dwError = ERROR_SUCCESS;

    // If the first char is a 'X', we have encrypted data
    if(*pszSource == ENCRYPTED_MARKER)
    {
#ifdef WINNT
        if(gbCryptAvailable && gdwNrOfClients>0)
        {
            dwLengthCrypted = wcslen(pszSource) +1 -2;    // In characters, without the marker and the NULL
            assert(dwLengthCrypted % 6 == 0);
            dwLengthDwords = dwLengthCrypted / 6;

            if(pszDest==NULL && pdwLengthNeeded)
            {
                *pdwLengthNeeded = dwLengthDwords*(sizeof(DWORD)/sizeof(WCHAR));
                dwError = ERROR_SUCCESS;
            }
            else
            {
                // Convert to binary
                pwcCrt1 = pszSource + dwLengthCrypted; // end of the string, before the NULL
                pdwCrt2 = ((DWORD *)pszDest) + dwLengthDwords -1; // Last DWORD


                for(dwCount=0; dwCount<dwLengthDwords; dwCount++)
                {
                    dwShift=0;
                    
                    for(dwCount2=0; dwCount2<6; dwCount2++)
                    {
                         dwShift <<= 6;
                         dwShift |= ((*pwcCrt1-- - 0x30) & 0x3f);  
                    }
                    *pdwCrt2-- = dwShift;
                }

                if(CreateSessionKey(ghCryptProvider, gpszSidText, dwKey, &hKey))
                {
                    dwDataLength = dwLengthDwords * sizeof(DWORD);
                    // Decrypt in place
                    if(CryptDecrypt(hKey,
                                    0,
                                    TRUE,
                                    0,
                                    (PBYTE)pszDest,
                                    &dwDataLength))
                    {
                        dwDataLength /= sizeof(WCHAR);
                        if(*(pszDest+dwDataLength-1)==L'\0') // The ending NULL was encrypted too
                        {
                            if(pdwLengthNeeded)
                                *pdwLengthNeeded = dwDataLength;

                            dwError = ERROR_SUCCESS;
                        }
                        else
                        {
                            *pszDest = L'\0';
                            dwError = ERROR_INVALID_DATA;
                        }
                    }
                    else
                        dwError = GetLastError();

                    DestroySessionKey(hKey);

                }
                else
                    dwError = GetLastError();
            }
        }
        else
            dwError = ERROR_INVALID_DATA;
#else
        dwError = ERROR_INVALID_DATA;
#endif
    }
    else
    {
        if(pdwLengthNeeded != NULL)
        {
            *pdwLengthNeeded = wcslen(pszSource) + 1; // dim in characters
        }
        
        if(pszDest!=NULL)
        {
            Unscrambler(dwKey, pszSource, pszDest);
        }
        dwError = ERROR_SUCCESS;
    }
    return dwError;
}


/////////////////////////////////
//  TapiIsSafeToDisplaySensitiveData
//
//  Detects if the current process is running in the "LocalSystem" security context.
//  Returns FALSE if it is, TRUE if it is not.
//  Returns also FALSE if an error occurs.

BOOL TapiIsSafeToDisplaySensitiveData(void)
{
#ifdef WINNT

    DWORD       dwError = ERROR_SUCCESS;
	TOKEN_USER	*User = NULL;
	SID_IDENTIFIER_AUTHORITY	SidAuth = SECURITY_NT_AUTHORITY;
	PSID		SystemSid = NULL;
	BOOL		bIsSafe = FALSE;

	// Get the User info
    if(GetUserTokenUser(&User))
    {
    	// Create a system SID
    	if(AllocateAndInitializeSid(&SidAuth,
    								1,
    								SECURITY_LOCAL_SYSTEM_RID,
    								0, 0, 0, 0, 0, 0, 0,
    								&SystemSid
    								))
    	{
    		// Compare the two sids
    		bIsSafe = !EqualSid(SystemSid, User->User.Sid);

    		FreeSid(SystemSid);
    		
    	}
    	else
    	{
    		dwError = GetLastError();
    	}

    	GlobalFree(User);
    }
    else
    {
    	dwError = GetLastError();
    }

    DBGOUT((5, "TapiIsSafeToDisplaySensitiveData - dwError=0x%x, Safe=%d", dwError, bIsSafe));

	return bIsSafe;

#else // WINNT

	return TRUE;	// always safe

#endif

}



#ifdef WINNT


/////////////////////////////////
//  GetUserSidText
//
//  Retrieves the SID from the token of the current process in text format

BOOL GetUserSidText(LPTSTR  *ppszResultSid)
{
    TOKEN_USER  *User = NULL;
    DWORD       dwLength;
    LPTSTR      pszSidText = NULL;


	// Get the SID
    if(!GetUserTokenUser(&User))
    {
        DBGOUT((5, "GetMagic  (0) failed, 0x%x", GetLastError()));
        return FALSE;
    }

    // Query the space needed for the string format of the SID
    dwLength=0;
    if(!ConvertSidToText(User->User.Sid, NULL, &dwLength) 
            && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        DBGOUT((5, "GetMagic  (1) failed, 0x%x", GetLastError()));
        GlobalFree(User);
        return FALSE;
    }

    // Alloc the space
    pszSidText = (LPTSTR)GlobalAlloc(GMEM_FIXED, dwLength);
    if(pszSidText==NULL)
    {
        GlobalFree(User);
        return FALSE;
    }
    
    //  Convert the SID in string format
    if(!ConvertSidToText(User->User.Sid, pszSidText, &dwLength))
    {
        DBGOUT((5, "GetMagic  (2) failed, 0x%x", GetLastError()));
        GlobalFree(User);
        GlobalFree(pszSidText);
        return FALSE;
    }

    GlobalFree(User);

    // The caller should free the buffer
    *ppszResultSid = pszSidText;

    return TRUE;
}

/////////////////////////////////
//  GetUserTokenUser
//
//  Retrieves the TOKEN_USER structure from the token of the current process

BOOL GetUserTokenUser(TOKEN_USER  **ppszResultTokenUser)
{
    HANDLE      hToken = NULL;
    DWORD		dwLength;
    TOKEN_USER  *User = NULL;
    
    // Open the current process token (for read)
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
    {
        if( GetLastError() == ERROR_NO_TOKEN) 
        {
        	// try with the process token
        	if (! OpenProcessToken ( GetCurrentProcess(), TOKEN_QUERY, &hToken))
        	{
        	    DBGOUT((5, "OpenProcessToken failed, 0x%x", GetLastError()));
                return FALSE;
            }
        }
        else
        {
       	    DBGOUT((5, "OpenThreadToken failed, 0x%x", GetLastError()));
            return FALSE;
        }
    }
   
    // Find the space needed for the SID
    if(!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwLength) 
            && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        DBGOUT((5, "GetTokenInformation (1) failed, 0x%x", GetLastError()));
        CloseHandle(hToken);
        return FALSE;
    }
   
    // Alloc the space
    User = (TOKEN_USER *)GlobalAlloc(GMEM_FIXED, dwLength);
    if(User==NULL)
    {
        CloseHandle(hToken);
        return FALSE;
    }
     
    // Retrieve the SID
    if(!GetTokenInformation(hToken, TokenUser, User, dwLength, &dwLength))
    {
        DBGOUT((5, "GetTokenInformation (2) failed, 0x%x", GetLastError()));
        CloseHandle(hToken);
        GlobalFree(User);
        return FALSE;
    }

    CloseHandle(hToken);

    // The caller should free the buffer
    *ppszResultTokenUser = User;

    return TRUE;
}


/////////////////////////////////
//  ConvertSidToText
//
//  Transforms a binary SID in string format
//  Author Jeff Spelman


BOOL ConvertSidToText(
    PSID pSid,            // binary Sid
    LPTSTR TextualSid,    // buffer for Textual representation of Sid
    LPDWORD lpdwBufferLen // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Validate the binary SID.

    if(!IsValidSid(pSid)) return FALSE;

    // Get the identifier authority value from the SID.

    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.

    if (*lpdwBufferLen < dwSidSize)
    {
        *lpdwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Add 'S' prefix and revision number to the string.

    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // Add SID identifier authority to the string.

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    return TRUE;
}

/////////////////////////////////
//  CreateSessionKey
//
//  Creates a session key derived from the user SID and a hint (currently the calling card ID)
// 
// 
 
BOOL    CreateSessionKey(HCRYPTPROV hProv, LPTSTR pszSidText, DWORD dwHint, HCRYPTKEY *phKey)
{
    HCRYPTHASH  hHash = 0;
    CHAR        szTmpBuff[0x20];
    DWORD       dwSize;
    LPSTR       pszBuf;
    
    // Create a hash object
    if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
    {
        DBGOUT((5, "CryptCreateHash failed, 0x%x, Prov=0x%x", GetLastError(), hProv));
        return FALSE;
    }
    
    // the Sid is of type TCHAR but, for back compat reasons, we want to encrypt the ANSI
    // version of this string.  We can either:
    //      1.) Convert the creation path for pszSid to ANSI (more correct solution)
    //      2.) thunk pszSid to ansi before converting (lazy solution)
    // I'm lazy so I'm choosing option #2.  It should be safe to thunk to ANSI because the
    // Sid should correctly round trip back to unicode.
    dwSize = lstrlen(pszSidText)+1;
    pszBuf = (LPSTR)GlobalAlloc( GPTR, dwSize*sizeof(CHAR) );
    if ( !pszBuf )
    {
        // out of memory
        CryptDestroyHash(hHash);
        return FALSE;
    }
    SHTCharToAnsi( pszSidText, pszBuf, dwSize );

#ifdef DEBUG
#ifdef UNICODE
    {
        // ensure that the SID round trips.  If it doesn't round trip then the validity of this
        // encription scheme is questionable on NT.  The solution would be to encrypt using Unicode,
        // but that would break back compat.
        LPTSTR pszDebug;
        pszDebug = (LPTSTR)GlobalAlloc( GPTR, dwSize*sizeof(TCHAR) );
        if ( pszDebug )
        {
            SHAnsiToTChar(pszBuf, pszDebug, dwSize);
            if ( 0 != StrCmp( pszDebug, pszSidText ) )
            {
                DBGOUT((1,"CRYPT ERROR!  Sid doesn't round trip!  FIX THIS!!!"));
            }
            GlobalFree(pszDebug);
        }
    }
#endif
#endif

    // hash the SID
    if(!CryptHashData(hHash, (PBYTE)pszBuf, (dwSize)*sizeof(CHAR), 0))
    {
        CryptDestroyHash(hHash);
        return FALSE;
    }

    GlobalFree(pszBuf);

    // hash a "magic" and the hint
    ZeroMemory(szTmpBuff, sizeof(szTmpBuff));

    wsprintfA(szTmpBuff, "-%c%c%c%c%c%x", MAGIC_1, MAGIC_2, MAGIC_3, MAGIC_4, MAGIC_5, dwHint);
    if(!CryptHashData(hHash, (PBYTE)szTmpBuff, sizeof(szTmpBuff), 0))
    {
        CryptDestroyHash(hHash);
        return FALSE;
    }
    
    // Generate the key, use block alg
    if(!CryptDeriveKey(hProv, CALG_RC2, hHash, 0, phKey))
    {
        DBGOUT((5, "CryptDeriveKey failed, 0x%x", GetLastError()));
        CryptDestroyHash(hHash);
        return FALSE;
    }
    
    CryptDestroyHash(hHash);
    
    return TRUE;

}

/////////////////////////////////
//  DestroySessionKey
//
//  Destroys a session key
// 
// 

void DestroySessionKey(HCRYPTKEY hKey)
{
    CryptDestroyKey(hKey);
}
    


#endif //WINNT

// Old routines
#define IsWDigit(c) (((WCHAR)(c)) >= (WCHAR)'0' && ((WCHAR)(c)) <= (WCHAR)'9')


void Unscrambler( DWORD  dwKey,
                         LPWSTR  lpszSrc,
                         LPWSTR  lpszDst )

{
   UINT  uIndex;
   UINT  uSubKey;
   UINT  uNewKey;

//   InternalDebugOut((101, "Entering Unscrambler"));
   if ( !lpszSrc || !lpszDst )
      {
      goto  done;
      }

   uNewKey = (UINT)dwKey & 0x7FFF;
   uSubKey = (UINT)dwKey % 10;

   for ( uIndex = 1; *lpszSrc ; lpszSrc++, lpszDst++, uIndex++ )
      {
      if ( IsWDigit( *lpszSrc ))
         {
         // do the unscramble thang
         //------------------------
         uSubKey  = ((*lpszSrc - (WCHAR)'0') - ((uSubKey + uIndex + uNewKey) % 10) + 10) % 10;
         *lpszDst = (WCHAR)(uSubKey + (WCHAR)'0');
         }
      else
         *lpszDst = *lpszSrc;    // just save the byte
      }

done:
    *lpszDst = (WCHAR)'\0';
    //InternalDebugOut((101, "Leaving Unscrambler"));
    return;
}


void CopyScrambled( LPWSTR lpszSrc,
                            LPWSTR lpszDst,
                            DWORD  dwKey
                          )
{
   UINT  uIndex;
   UINT  uSubKey;
   UINT  uNewKey;

   //nternalDebugOut((50, "Entering IniScrambler"));
   if ( !lpszSrc || !lpszDst )
      {
      goto  done;
      }  // end if

   uNewKey = (UINT)dwKey & 0x7FFF;
   uSubKey = (UINT)dwKey % 10;

   for ( uIndex = 1; *lpszSrc ; lpszSrc++, lpszDst++, uIndex++ )
      {
      if ( IsWDigit( *lpszSrc ))
         {
         // do the scramble thang
         //----------------------
         *lpszDst = (WCHAR)(((uSubKey + (*lpszSrc - (WCHAR)'0') + uIndex + uNewKey) % 10) + (WCHAR)'0');
         uSubKey = (UINT)(*lpszSrc - (WCHAR)'0');
         }
      else
         *lpszDst = *lpszSrc;    // just save the byte
      }  // end for


done:

    *lpszDst = (WCHAR)'\0';
//    InternalDebugOut((60, "Leaving IniScrambler"));

    return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\add2strw.c ===
#define UNICODE
#define _UNICODE

#include "inc.h"
#pragma hdrstop

#define RtlIpv4AddressToStringT RtlIpv4AddressToStringW
#define RtlIpv6AddressToStringT RtlIpv6AddressToStringW
#define RtlIpv4AddressToStringExT RtlIpv4AddressToStringExW
#define RtlIpv6AddressToStringExT RtlIpv6AddressToStringExW

#include "add2strt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\add2stra.c ===
#undef UNICODE
#undef _UNICODE

#include "inc.h"
#pragma hdrstop

#define RtlIpv6AddressToStringT RtlIpv6AddressToStringA
#define RtlIpv4AddressToStringT RtlIpv4AddressToStringA
#define RtlIpv6AddressToStringExT RtlIpv6AddressToStringExA
#define RtlIpv4AddressToStringExT RtlIpv4AddressToStringExA

#include "add2strt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\adt.c ===
//================================================================================
//  Microsoft Confidential
//  Copyright (C) Microsoft 1997
//
//  Author: RameshV
//================================================================================


//================================================================================
//  Required Headers
//================================================================================
#include <adt.h>

//================================================================================
//  Definitions of the functions.
//================================================================================

DWORD                                // Win32 Errors
InitializeProducerConsumer(          // Initialize the pointer
    OUT  PPRODCONS   Synch,          // The memory must be pre-allocated
    IN   DWORD       MaxProducers,   // Total # of simultaneous producers
    IN   DWORD       MaxConsumers    // Totat # of consumers
) {
    Synch->ProducerSemaphore = Synch->ConsumerSemaphore = NULL;

    Synch->ProducerSemaphore = CreateSemaphore(
        (LPSECURITY_ATTRIBUTES)NULL, // No security here
        MaxProducers,                // Initial allowed # of producers
        MaxProducers,                // Max allowed at any time
        NULL                         // Unnamed
    );
    if( NULL == Synch->ProducerSemaphore ) return GetLastError();

    Synch->ConsumerSemaphore = CreateSemaphore(
        (LPSECURITY_ATTRIBUTES)NULL, // No security here
        0,                           // Initial allowed # of consumers
        MaxConsumers,                // Max allowed at any time
        NULL                         // Unnamed
    );
    if( NULL == Synch->ConsumerSemaphore ) return GetLastError();

    Synch->MaxProducers = MaxProducers;
    Synch->MaxConsumers = MaxConsumers;

    return ERROR_SUCCESS;
}

VOID
DestroyProducerConsumer(             // Destroy and free up resources
    IN  PPRODCONS   Synch            // The producer consumer object
) {
    if(Synch->ProducerSemaphore) CloseHandle(Synch->ProducerSemaphore);
    if(Synch->ConsumerSemaphore) CloseHandle(Synch->ConsumerSemaphore);
}

//================================================================================
//  StartProducerEx is expected to be called before trying to "produce" an
//  element.  If a timeout is specified, then the timeout will act like the
//  same as in WaitForSingleObjectEx. Also, if the Alertable flag is on, the
//  wait is altertable.  The same thing with StartConsumerEx.
//================================================================================

DWORD  static _inline                // Win32 errors
StartProdConsExInternal(             // Gen. fn to enter prod/cons code (internal)
    IN  PPRODCONS    Synch,          // Synchronization object
    IN  DWORD        TimeOutMilliSec,// Timeout in milliseconds; 0 ==> polling
    IN  BOOL         Alertable,      // Is the wait alertable?
    IN  BOOL         Producer        // Is this call from a producer or consumer?
) {
    DWORD   Status;

    Status = WaitForSingleObjectEx(
        Producer? Synch->ProducerSemaphore : Synch->ConsumerSemaphore,
        TimeOutMilliSec,
        Alertable
    );

    return Status;
}

DWORD  static _inline                 // Win32 errors
EndProdConsExInternal(                // Gen. fn to leave prod/cons code(internal)
    IN  PPRODCONS     Synch,          // Synchronization object
    IN  BOOL          Producer        // Is this call from a producer or consumer?
) {
    BOOL    Status;

    Status = ReleaseSemaphore(
        Producer? Synch->ConsumerSemaphore : Synch->ProducerSemaphore,
        1,                            // Release one producer/consumer
        NULL                          // Dont care about how many are still out there
    );

    if( FALSE == Status ) return GetLastError();
    return ERROR_SUCCESS;
}

//================================================================================
// The exported versions are below.  The Ex functions allow specification of
// TimeOut and if the wait is alertable.  The non-Ex functions have the timeout
// as INFINITE and Alertable as FALSE by default.
//================================================================================

DWORD                                // Win32 errors
StartProducerEx(                     // See StartProdConsExInternal
    IN  PPRODCONS    Synch,          // Syncho. object
    IN  DWORD        TimeOutMilliSec,// Timeout for wait in milliseconds
    IN  BOOL         Alertable       // Is the wait alertable?
) {
    return StartProdConsExInternal(Synch,TimeOutMilliSec,Alertable,TRUE);
}

DWORD                                // Win32 errors
StartConsumerEx(                     // See StartProdConsExInternal
    IN  PPRODCONS    Synch,          // Syncho. object
    IN  DWORD        TimeOutMilliSec,// Timeout for wait in milliseconds
    IN  BOOL         Alertable       // Is the wait alertable?
) {
    return StartProdConsExInternal(Synch,TimeOutMilliSec,Alertable,FALSE);
}

// These are usual versions.  Return value is success if we entered.
// Alertable wait by default, timeout = infinite.  So, can return
// WAIT_IO_COMPLETION on success.
DWORD                                // Win32 errors
StartProducer(                       // Wait until a producer can start
    IN  PPRODCONS    Synch           // The synch object
) {
    DWORD   Status = StartProducerEx(Synch, INFINITE, FALSE);

    if( WAIT_OBJECT_0 == Status ) return ERROR_SUCCESS;
    return Status;
}

DWORD                                // Win32 errors
StartConsumer(                       // Wait until a consumer can start
    IN  PPRODCONS    Synch           // The synch object
) {
    DWORD   Status = StartConsumerEx(Synch, INFINITE, FALSE);

    if( WAIT_OBJECT_0 == Status ) return ERROR_SUCCESS;
    return Status;
}

DWORD                                // Win32 Errors
EndProducer(                         // See EndProdConsExInternal
    IN  PPRODCONS     Synch          // Synch object
) {
    return EndProdConsExInternal(Synch, TRUE);
}

DWORD                                // Win32 errors
EndConsumer(                         // See EndProdConsExInternal
    IN  PPRODCONS     Synch          // Synch object
) {
    return EndProdConsExInternal(Synch, TRUE);
}


//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\adt.h ===
//================================================================================
//  Microsoft Confidential.
//  Copyright (C) Microsoft 1997.
//
//  Author: RameshV
//================================================================================

#ifndef ADT_H_INCLUDED
#define ADT_H_INCLUDED
//================================================================================
//  Required headers
//================================================================================
#include <winbase.h>                // Semaphores and wait functions

//================================================================================
//  Some Data type implementations. EXPORTED
//================================================================================
typedef struct st_prodcons {        // structure for producer-consumer sychro.
    HANDLE  ProducerSemaphore;      // Semaphore for tracking producers
    HANDLE  ConsumerSemaphore;      // Semaphore for tracking consumers
    DWORD   MaxProducers;           // Maximum # of producers
    DWORD   MaxConsumers;           // Maximum # of consumers
    DWORD   Flags;                  // Options -- Unused?
} PRODCONS, *PPRODCONS;

//================================================================================
//  Function headers of EXPORTED functions
//================================================================================

DWORD                                // Win32 Errors
InitializeProducerConsumer(          // Initialize the pointer
    OUT  PPRODCONS   Synch,          // The memory must be pre-allocated
    IN   DWORD       MaxProducers,   // Total # of simultaneous producers
    IN   DWORD       MaxConsumers    // Totat # of consumers
);

VOID
DestroyProducerConsumer(             // Destroy and free up resources
    IN  PPRODCONS   Synch            // The producer consumer object
);

DWORD                                // Win32 errors
StartProducerEx(                     // See StartProdConsExInternal
    IN  PPRODCONS    Synch,          // Syncho. object
    IN  DWORD        TimeOutMilliSec,// Timeout for wait in milliseconds
    IN  BOOL         Alertable       // Is the wait alertable?
);


DWORD                                // Win32 errors
StartConsumerEx(                     // See StartProdConsExInternal
    IN  PPRODCONS    Synch,          // Syncho. object
    IN  DWORD        TimeOutMilliSec,// Timeout for wait in milliseconds
    IN  BOOL         Alertable       // Is the wait alertable?
);

DWORD                                // Win32 errors
StartProducer(                       // Wait until a producer can start
    IN  PPRODCONS    Synch           // The synch object
);

DWORD                                // Win32 errors
StartConsumer(                       // Wait until a consumer can start
    IN  PPRODCONS    Synch           // The synch object
);

DWORD                                // Win32 Errors
EndProducer(                         // See EndProdConsExInternal
    IN  PPRODCONS     Synch          // Synch object
);

DWORD                                // Win32 errors
EndConsumer(                         // See EndProdConsExInternal
    IN  PPRODCONS     Synch          // Synch object
);


//================================================================================
//  End of file
//================================================================================
#endif ADT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\compare.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:
    File contains the functions used to compare to MIB_XXXROW.  They are passed
    as arguments to CRTs qsort(). They have to be of the form
        int __cdecl Compare(Elem1, Elem2)
	
	All these functions behave like strcmp. They return values are:
          < 0 if Row1 is less than Row2
         == 0 if Row1 is equal to Row2
          > 0 if Row1 is greater than Row2

Revision History:

    Amritansh Raghav          6/8/95  Created

--*/


#include "inc.h"
#pragma hdrstop

// The following structures are used to sort the output of GetIpAddrTable
// and GetIfTable. The adapter order is specified under Tcpip\Linkage key
// in the 'Bind' value as a list of device GUID values. The mapping from 
// this ordering to active interfaces is constructed by GetAdapterOrderMap
// which fills an array with interface-indices in the order corresponding
// to the adapter order.
// Our comparison routines require this map for each comparison,
// so we use a global variable to store the map before attempting to sort
// on adapter order, and protect the map using the critical section 'g_ifLock'.
// See 'CompareIfIndex' for the use of this map.

extern PIP_ADAPTER_ORDER_MAP g_adapterOrderMap;

int
CompareIfIndex(
    ULONG index1,
    ULONG index2
    );

int
__cdecl
CompareIfRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    PMIB_IFROW  pRow1 = (PMIB_IFROW)pvElem1;
    PMIB_IFROW  pRow2 = (PMIB_IFROW)pvElem2;

    if(pRow1->dwIndex < pRow2->dwIndex)
    {
        return -1;
    }
    else
    {
        if(pRow1->dwIndex > pRow2->dwIndex)
        {
            return 1;
        }
    }

    return 0;
}

int
__cdecl
CompareIfRow2(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    PMIB_IFROW  pRow1 = (PMIB_IFROW)pvElem1;
    PMIB_IFROW  pRow2 = (PMIB_IFROW)pvElem2;

    return CompareIfIndex(pRow1->dwIndex, pRow2->dwIndex);
}

int
__cdecl
CompareIpAddrRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    int iRes;

    PMIB_IPADDRROW  pRow1 = (PMIB_IPADDRROW)pvElem1;
    PMIB_IPADDRROW  pRow2 = (PMIB_IPADDRROW)pvElem2;

    InetCmp(pRow1->dwAddr,
            pRow2->dwAddr,
            iRes);
    
    return iRes;
}


int
__cdecl
CompareIpAddrRow2(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    int iRes;

    PMIB_IPADDRROW  pRow1 = (PMIB_IPADDRROW)pvElem1;
    PMIB_IPADDRROW  pRow2 = (PMIB_IPADDRROW)pvElem2;

    return CompareIfIndex(pRow1->dwIndex, pRow2->dwIndex);
}

int
__cdecl
CompareTcpRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;
    
    PMIB_TCPROW pRow1 = (PMIB_TCPROW)pvElem1;
    PMIB_TCPROW pRow2 = (PMIB_TCPROW)pvElem2;
        
    if(InetCmp(pRow1->dwLocalAddr,
               pRow2->dwLocalAddr,
               lResult) isnot 0)
    {
        return lResult;
    }


    if(PortCmp(pRow1->dwLocalPort,
               pRow2->dwLocalPort,
               lResult) isnot 0)
    {   
        return lResult;
    }


    if(InetCmp(pRow1->dwRemoteAddr,
               pRow2->dwRemoteAddr,
               lResult) isnot 0)
    {
        return lResult;
    }


    return PortCmp(pRow1->dwRemotePort,
                   pRow2->dwRemotePort,
                   lResult);

}

int
__cdecl
CompareTcp6Row(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    TCP6ConnTableEntry *pRow1 = (TCP6ConnTableEntry *)pvElem1;
    TCP6ConnTableEntry *pRow2 = (TCP6ConnTableEntry *)pvElem2;

    lResult = memcmp(&pRow1->tct_localaddr, &pRow2->tct_localaddr,
                     sizeof(pRow1->tct_localaddr));
    if (lResult isnot 0)
    {
        return lResult;
    }

    if (pRow1->tct_localscopeid != pRow2->tct_localscopeid) {
        return pRow1->tct_localscopeid - pRow2->tct_localscopeid;
    }

    if(PortCmp(pRow1->tct_localport,
               pRow2->tct_localport,
               lResult) isnot 0)
    {
        return lResult;
    }

    lResult = memcmp(&pRow1->tct_remoteaddr, &pRow2->tct_remoteaddr,
                     sizeof(pRow1->tct_remoteaddr));
    if (lResult isnot 0)
    {
        return lResult;
    }

    if (pRow1->tct_remotescopeid != pRow2->tct_remotescopeid) {
        return pRow1->tct_remotescopeid - pRow2->tct_remotescopeid;
    }

    return PortCmp(pRow1->tct_remoteport,
                   pRow2->tct_remoteport,
                   lResult);

}

int
__cdecl
CompareUdpRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    PMIB_UDPROW pRow1 = (PMIB_UDPROW)pvElem1;
    PMIB_UDPROW pRow2 = (PMIB_UDPROW)pvElem2;

    if(InetCmp(pRow1->dwLocalAddr,
               pRow2->dwLocalAddr,
               lResult) isnot 0)
    {
        return lResult;
    }

    return PortCmp(pRow1->dwLocalPort,
                   pRow2->dwLocalPort,
                   lResult);
}

int
__cdecl
CompareUdp6Row(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    UDP6ListenerEntry *pRow1 = (UDP6ListenerEntry *)pvElem1;
    UDP6ListenerEntry *pRow2 = (UDP6ListenerEntry *)pvElem2;

    lResult = memcmp(&pRow1->ule_localaddr, &pRow2->ule_localaddr, 
                     sizeof(pRow1->ule_localaddr));
    if (lResult isnot 0) 
    {
        return lResult;
    }

    if (pRow1->ule_localscopeid != pRow2->ule_localscopeid) 
    {
        return pRow1->ule_localscopeid - pRow2->ule_localscopeid;
    }

    return PortCmp(pRow1->ule_localport,
                   pRow2->ule_localport,
                   lResult);
}

int
__cdecl
CompareIpNetRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    PMIB_IPNETROW   pRow1 = (PMIB_IPNETROW)pvElem1;
    PMIB_IPNETROW   pRow2 = (PMIB_IPNETROW)pvElem2;
    
    if(Cmp(pRow1->dwIndex,
           pRow2->dwIndex,
           lResult) isnot 0)
    {
        return lResult;
    }

    
    return InetCmp(pRow1->dwAddr,
                   pRow2->dwAddr,
                   lResult);
}

int
__cdecl
CompareIpForwardRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    PMIB_IPFORWARDROW   pRow1 = (PMIB_IPFORWARDROW)pvElem1;
    PMIB_IPFORWARDROW   pRow2 = (PMIB_IPFORWARDROW)pvElem2;
    
    if(InetCmp(pRow1->dwForwardDest,
               pRow2->dwForwardDest,
               lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwForwardProto,
           pRow2->dwForwardProto,
           lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwForwardPolicy,
           pRow2->dwForwardPolicy,
           lResult) isnot 0)
    {
        return lResult;
    }

    return InetCmp(pRow1->dwForwardNextHop,
                   pRow2->dwForwardNextHop,
                   lResult);
}


int
__cdecl
NhiCompareIfInfoRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    PIP_INTERFACE_NAME_INFO pRow1 = (PIP_INTERFACE_NAME_INFO)pvElem1;
    PIP_INTERFACE_NAME_INFO pRow2 = (PIP_INTERFACE_NAME_INFO)pvElem2;

    if(pRow1->Index < pRow2->Index)
    {
        return -1;
    }
    else
    {
        if(pRow1->Index > pRow2->Index)
        {
            return 1;
        }
    }

    return 0;
}


DWORD
OpenTcpipKey(
    PHKEY Key
    )
{
    DWORD   dwResult;
    CHAR    keyName[sizeof("SYSTEM\\CurrentControlSet\\Services\\Tcpip")];

    //
    // open the handle to this adapter's TCPIP parameter key
    //

    strcpy(keyName, "SYSTEM\\CurrentControlSet\\Services\\Tcpip");

    Trace1(ERR,"OpenTcpipKey: %s", keyName);

    dwResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                          keyName,
                          Key);
    return dwResult;

}

PIP_INTERFACE_INFO 
GetAdapterNameAndIndexInfo(
    VOID
    )
{
    PIP_INTERFACE_INFO pInfo;
    ULONG              dwSize, dwError;

    dwSize = 0; pInfo = NULL;

    while( 1 ) {

        dwError = GetInterfaceInfo( pInfo, &dwSize );
        if( ERROR_INSUFFICIENT_BUFFER != dwError ) break;

        if( NULL != pInfo ) HeapFree(g_hPrivateHeap,0, pInfo);
        if( 0 == dwSize ) return NULL;

        pInfo = HeapAlloc(g_hPrivateHeap,0, dwSize);
        if( NULL == pInfo ) return NULL;

    }

    if( ERROR_SUCCESS != dwError || (pInfo && 0 == pInfo->NumAdapters) ) {
        if( NULL != pInfo ) HeapFree(g_hPrivateHeap,0, pInfo);
        return NULL;
    }

    return pInfo;
}


int
CompareIfIndex(
    ULONG Index1,
    ULONG Index2
    )
{
    ULONG i;
#define MAXORDER (MAXLONG/2)
    ULONG Order1 = MAXORDER;
    ULONG Order2 = MAXORDER;

    // Determine the adapter-order for each interface-index,
    // using 'MAXLONG/2' as the default for unspecified indices
    // so that such interfaces all appear at the end of the array.
    // We then return an unsigned comparison of the resulting orders.

    for (i = 0; i < g_adapterOrderMap->NumAdapters; i++) {
        if (Index1 == g_adapterOrderMap->AdapterOrder[i]) {
            Order1 = i; if (Order2 != MAXORDER) { break; }
        }
        if (Index2 == g_adapterOrderMap->AdapterOrder[i]) {
            Order2 = i; if (Order1 != MAXORDER) { break; }
        }
    }
    return (ULONG)Order1 - (ULONG)Order2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\compare.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    net\sockets\tcpcmd\compare.h

Abstract:
    Forward declarations for the comparison functions
    
Revision History:

    Amritansh Raghav

--*/

#ifndef __COMPARE_H__
#define __COMPARE_H__

int
__cdecl
CompareIfRow(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareIfRow2(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareIpAddrRow(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );int
__cdecl
CompareIpAddrRow2(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareTcpRow(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareTcp6Row(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareUdpRow(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareUdp6Row(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareIpNetRow(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );
int
__cdecl
CompareIpForwardRow(
    CONST VOID *pElem1,
    CONST VOID *pElem2
    );

int
__cdecl
NhiCompareIfInfoRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    );


#endif // __COMPARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\add2strt.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    add2strt.h

Abstract:

    Code for IP address-to-string translation routines.

Author:

    Dave Thaler (dthaler)   3-28-2001

Revision History:

    IPv6 conversion code originally by Rich Draves (richdr)

--*/

NTSTATUS
RtlIpv6AddressToStringExT(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT LPTSTR AddressString,
    IN OUT PULONG AddressStringLength
    )

/*++

Routine Description:

    This is the extension routine which handles a full address conversion
    including address, scopeid and port (scopeid and port are optional).

Arguments:

    Address - The address part to be translated.

    ScopeId - The Scope ID of the address (optional).

    Port - The port number of the address (optional). 
           Port is in network byte order.

    AddressString - Pointer to output buffer where we will fill in address string.

    AddressStringLength - For input, it is the length of the input buffer; for 
                          output it is the length we actual returned.
Return Value:

    STATUS_SUCCESS if the operation is successful, error code otherwise.

--*/
{
    TCHAR String[INET6_ADDRSTRLEN];
    LPTSTR S;
    ULONG Length;
    
    if ((Address == NULL) ||
        (AddressString == NULL) ||
        (AddressStringLength == NULL)) {

        return STATUS_INVALID_PARAMETER;
    }
    S = String;
    if (Port) {
        S += _stprintf(S, _T("["));
    }

    //
    // Now translate this address.
    //
    S = RtlIpv6AddressToStringT(Address, S);
    if (ScopeId != 0) {
        S += _stprintf(S, _T("%%%u"), ScopeId);
    }
    if (Port != 0) {
        S += _stprintf(S, _T("]:%u"), RtlUshortByteSwap(Port));
    }
    Length = (ULONG)(S - String + 1);
    if (*AddressStringLength < Length) {
        //
        // Before return, tell the caller how big 
        // the buffer we need.
        //
        *AddressStringLength = Length;
        return STATUS_INVALID_PARAMETER;
    }
    *AddressStringLength = Length;
    RtlCopyMemory(AddressString, String, Length * sizeof(TCHAR));
    return STATUS_SUCCESS;

}
    

NTSTATUS
RtlIpv4AddressToStringExT(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT LPTSTR AddressString,
    IN OUT PULONG AddressStringLength
    )

/*++

Routine Description:

    This is the extension routine which handles a full address conversion
    including address and port (port is optional).
    
Arguments:

    Address - The address part to translate.

    Port - Port number if there is any, otherwise 0. Port is in network 
           byte order. 

    AddressString - Receives the formatted address string.
    
    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    STATUS_SUCCESS if the operation is successful, error code otherwise.

--*/

{

    TCHAR String[INET_ADDRSTRLEN];
    LPTSTR S;
    ULONG Length;

    //
    // Quick sanity checks.
    //
    if ((Address == NULL) ||
        (AddressString == NULL) ||
        (AddressStringLength == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }
    S = String;

    //
    // Now translate this address.
    //
    S = RtlIpv4AddressToStringT(Address, S);
    if (Port != 0) {
        S += _stprintf(S, _T(":%u"), RtlUshortByteSwap(Port));
    }
    Length = (ULONG)(S - String + 1);
    if (*AddressStringLength < Length) {
        //
        // Before return, tell the caller how big
        // the buffer we need. 
        //
        *AddressStringLength = Length;
        return STATUS_INVALID_PARAMETER;
    }
    RtlCopyMemory(AddressString, String, Length * sizeof(TCHAR));
    *AddressStringLength = Length;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\extapi.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    net\routing\iphlpapi.c

Abstract:
    This files contains the public APIs are that exported by IPHLPAPI.DLL

Revision History:

    Amritansh Raghav

--*/

#include "inc.h"
#pragma hdrstop

#define CLASSA_ADDR(a)  (( (*((uchar *)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)  (( (*((uchar *)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)  (( (*((uchar *)&(a))) & 0xe0) == 0xc0)
#define CLASSD_ADDR(a)  (( (*((uchar *)&(a))) & 0xf0) == 0xe0)
#define CLASSE_ADDR(a)  ((( (*((uchar *)&(a))) & 0xf0) == 0xf0) && \
                        ((a) != 0xffffffff))

#define CLASSA_MASK     0x000000FF
#define CLASSB_MASK     0x0000FFFF
#define CLASSC_MASK     0x00FFFFFF
#define CLASSD_MASK     0x000000E0
#define CLASSE_MASK     0xFFFFFFFF

#define GetClassMask(a)                                         \
            (CLASSA_ADDR(a) ? CLASSA_MASK :                     \
            (CLASSB_ADDR(a) ? CLASSB_MASK :                     \
            (CLASSC_ADDR(a) ? CLASSC_MASK :                     \
            (CLASSD_ADDR(a) ? CLASSD_MASK : CLASSE_MASK))))

PIP_ADAPTER_ORDER_MAP g_adapterOrderMap = NULL;
extern PIP_ADAPTER_ORDER_MAP APIENTRY GetAdapterOrderMap();

DWORD
GetArpEntryCount(
    OUT PDWORD  pdwNumEntries
    );

BOOL
IsRouterRunning(VOID);

DWORD
GetBestInterfaceFromIpv6Stack(
    IN  LPSOCKADDR_IN6 pSockAddr,
    OUT PDWORD         pdwBestIfIndex
    );

DWORD
WINAPI
GetNumberOfInterfaces(
    OUT PDWORD pdwNumIf
    )
{
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_IFNUMBER       pIfNum;
    MIB_OPAQUE_QUERY    mqQuery;
    DWORD               dwResult, dwOutEntrySize;
    MIB_IPSTATS         IpSnmpInfo;

    TraceEnter("GetIfNumber");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetIfNumber: No IP Stack on machine\n");

        TraceLeave("GetIfNumber");

        return ERROR_NOT_SUPPORTED;
    }

    if (!pdwNumIf) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pdwNumIf = 0;

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = IF_NUMBER;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIfNumber: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("GetIfNumber");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IFNUMBER, pIfNum);

        *pdwNumIf = pIfNum->dwValue;

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetIpStatsFromStack(&IpSnmpInfo);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIfNumber: GetIpStatsFromStack failed with error %x",
                   dwResult);

            TraceLeave("GetIfNumber");

            return dwResult;
        }

        *pdwNumIf = IpSnmpInfo.dwNumIf;
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetIfNumber");

    return NO_ERROR;
}


DWORD
WINAPI
GetIfTable(
    OUT    PMIB_IFTABLE pIfTable,
    IN OUT PULONG       pdwSize,
    IN     BOOL         bOrder
    )
{
    DWORD   dwNumIf, dwResult, dwOutEntrySize;

    PMIB_IFTABLE        pTable;
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;
    BOOL bForceUpdate = FALSE;    

    TraceEnter("GetIfTable");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetIfTable: No IP Stack on machine\n");

        TraceLeave("GetIfTable");

        return ERROR_NOT_SUPPORTED;
    }

    if(pdwSize is NULL)
    {
        Trace0(ERR,"GetIfTable: pdwSize is NULL");

        TraceLeave("GetIfTable");

        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwSize, sizeof(ULONG))) {
      return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pIfTable, *pdwSize)) {
      return ERROR_INVALID_PARAMETER;
    }

    dwResult = GetNumberOfInterfaces(&dwNumIf);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetIfTable: GetIfNumber returned error %d",
               dwResult);

        TraceLeave("GetIfTable");

        return dwResult;
    }

    if(dwNumIf is 0)
    {
        Trace0(ERR,"GetIfTable: No interfaces");

        TraceLeave("GetIfTable");

        return ERROR_NO_DATA;
    }

    if( (*pdwSize < SIZEOF_IFTABLE(dwNumIf)) || (pIfTable is NULL) )
    {
        Trace3(TRACE,"GetIfTable: In size %d. Required %d. With overflow %d",
               *pdwSize,
               SIZEOF_IFTABLE(dwNumIf),
               SIZEOF_IFTABLE(dwNumIf + OVERFLOW_COUNT));

        *pdwSize = SIZEOF_IFTABLE(dwNumIf + OVERFLOW_COUNT);

        TraceLeave("GetIfTable");

        return ERROR_INSUFFICIENT_BUFFER;
    }

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = IF_TABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIfTable: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("GetIfTable");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IFTABLE, pTable);

        if(pTable->dwNumEntries is 0)
        {
            Trace0(ERR,"GetIfTable: MprAdminMIBEntryGet returned 0 interfaces");

            MprAdminMIBBufferFree((PVOID)pInfo);

            TraceLeave("GetIfTable");

            return ERROR_NO_DATA;
        }

        if(*pdwSize < SIZEOF_IFTABLE(pTable->dwNumEntries))
        {
            Trace3(ERR,"GetIfTable: After MIBQuery. In size %d. Required %d. With overflow %d",
                   *pdwSize,
                   SIZEOF_IFTABLE(pTable->dwNumEntries),
                   SIZEOF_IFTABLE(pTable->dwNumEntries + OVERFLOW_COUNT));

            *pdwSize = SIZEOF_IFTABLE(pTable->dwNumEntries + OVERFLOW_COUNT);

            TraceLeave("GetIfTable");

            return ERROR_INSUFFICIENT_BUFFER;
        }

        *pdwSize = SIZEOF_IFTABLE(pTable->dwNumEntries);

        CopyMemory((PVOID)(pIfTable),
                   (PVOID)pTable,
                   SIZEOF_IFTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
        
#endif        
        EnterCriticalSection(&g_ifLock);


        if (dwNumIf != g_dwNumIf)
        {
            bForceUpdate = TRUE;
        }


        g_dwNumIf = dwNumIf;

        LeaveCriticalSection(&g_ifLock);        

        dwResult = GetIfTableFromStack(pIfTable,
                                       *pdwSize,
                                       bOrder,
                                       bForceUpdate);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIfTable: GetIfTableFromStack failed with error %d",
                   dwResult);
        }

#ifndef CHICAGO
    }
#endif

    // if bOrder is 0 sort on adapter order
    if( (bOrder == 0) && (dwResult == NO_ERROR) && (pIfTable) ) {
        EnterCriticalSection(&g_ifLock);
        if (g_adapterOrderMap = GetAdapterOrderMap()) {
            qsort(pIfTable->table,
                pIfTable->dwNumEntries,
                sizeof(MIB_IFROW),
                CompareIfRow2);
            LocalFree(g_adapterOrderMap);
        }
        LeaveCriticalSection(&g_ifLock);
    }
    
    TraceLeave("GetIfTable");

    return dwResult;
}


DWORD
WINAPI
GetIpAddrTable(
    OUT     PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT  PULONG           pdwSize,
    IN      BOOL             bOrder
    )
{
    DWORD       dwResult, dwOutEntrySize;
    MIB_IPSTATS miStats;

    PMIB_IPADDRTABLE    pTable;
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;

    TraceEnter("GetIpAddrTable");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetIpAddrTable: No IP Stack on machine\n");

        TraceLeave("GetIpAddrTable");

        return ERROR_NOT_SUPPORTED;
    }

    if(pdwSize is NULL)
    {
        Trace0(ERR,"GetIpAddrTable: pdwSize is NULL");

        TraceLeave("GetIpAddrTable");

        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwSize, sizeof(ULONG))) {
      return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pIpAddrTable, *pdwSize)) {
      return ERROR_INVALID_PARAMETER;
    }

    dwResult = GetIpStatsFromStack(&miStats);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetIpAddrTable: GetIpStatistics returned error %d",
               dwResult);

        TraceLeave("GetIpAddrTable");

        return dwResult;
    }

    if(miStats.dwNumAddr is 0)
    {
        Trace0(ERR,"GetIpAddrTable: No entries");

        TraceLeave("GetIpAddrTable");

        return ERROR_NO_DATA;
    }

    if( (*pdwSize < SIZEOF_IPADDRTABLE(miStats.dwNumAddr)) || (pIpAddrTable is NULL) )
    {
        Trace3(TRACE,"GetIpAddrTable: In size %d. Required %d. With overflow %d",
               *pdwSize,
               SIZEOF_IPADDRTABLE(miStats.dwNumAddr),
               SIZEOF_IPADDRTABLE(miStats.dwNumAddr + OVERFLOW_COUNT));

        *pdwSize = SIZEOF_IPADDRTABLE(miStats.dwNumAddr + OVERFLOW_COUNT);

        TraceLeave("GetIpAddrTable");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Retrieve the IP address table directly from TCP/IP. Note that we do not
    // determine first whether RRAS is running, since the IP address table
    // held by TCP/IP is always complete, and always contains interface indices
    // consistent with those held by RRAS.
    //

    dwResult = GetIpAddrTableFromStack(pIpAddrTable,
                                       *pdwSize,
                                       bOrder);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetIpAddrTable: GetIpAddrTableFromStack failed with error %d",
               dwResult);
    }

    // if bOrder is 0 sort on adapter order
    if( (bOrder == 0) && (dwResult == NO_ERROR) && (pIpAddrTable) ) {
        EnterCriticalSection(&g_ifLock);
        if (g_adapterOrderMap = GetAdapterOrderMap()) {
            qsort(pIpAddrTable->table,
                  pIpAddrTable->dwNumEntries,
                  sizeof(MIB_IPADDRROW),
                  CompareIpAddrRow2);
            LocalFree(g_adapterOrderMap);
        }
        LeaveCriticalSection(&g_ifLock);
    }

    TraceLeave("GetIpAddrTable");

    return dwResult;
}


DWORD
WINAPI
GetIpNetTable(
    OUT     PMIB_IPNETTABLE pIpNetTable,
    IN OUT  PULONG          pdwSize,
    IN      BOOL            bOrder
    )
{
    DWORD       dwResult, dwOutEntrySize, dwArpCount;

    PMIB_IPNETTABLE     pTable;
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;

    TraceEnter("GetIpNetTable");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetIpNetTable: No IP Stack on machine\n");

        TraceLeave("GetIpNetTable");

        return ERROR_NOT_SUPPORTED;
    }

    if(pdwSize is NULL)
    {
        Trace0(ERR,"GetIpNetTable: pdwSize is NULL");

        TraceLeave("GetIpNetTable");

        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwSize, sizeof(ULONG))) {
      return ERROR_INVALID_PARAMETER;
    }
    
    if (IsBadWritePtr(pIpNetTable, *pdwSize)) {
      return ERROR_INVALID_PARAMETER;
    }

    dwArpCount = 0;

    EnterCriticalSection(&g_ipNetLock);

    dwResult = GetArpEntryCount(&dwArpCount);

    LeaveCriticalSection(&g_ipNetLock);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetIpNetTable: GetIpStatistics returned error %d",
               dwResult);

        TraceLeave("GetIpNetTable");

        return dwResult;
    }

    if(dwArpCount is 0)
    {
        Trace0(ERR,"GetIpNetTable: No entries");

        TraceLeave("GetIpNetTable");

        return ERROR_NO_DATA;
    }

    if( (*pdwSize < SIZEOF_IPNETTABLE(dwArpCount)) || (pIpNetTable is NULL) )
    {
        Trace3(TRACE,"GetIpNetTable: In size %d. Required %d. With overflow %d",
               *pdwSize,
               SIZEOF_IPNETTABLE(dwArpCount),
               SIZEOF_IPNETTABLE(dwArpCount + OVERFLOW_COUNT));

        *pdwSize = SIZEOF_IPNETTABLE(dwArpCount + OVERFLOW_COUNT);

        TraceLeave("GetIpNetTable");

        return ERROR_INSUFFICIENT_BUFFER;
    }

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = IP_NETTABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIpNetTable: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("GetIpNetTable");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IPNETTABLE, pTable);

        if(pTable->dwNumEntries is 0)
        {
            Trace0(ERR,"GetIpNetTable: MprAdminMIBEntryGet returned 0 interfaces");

            MprAdminMIBBufferFree((PVOID)pInfo);

            TraceLeave("GetIpNetTable");

            return ERROR_NO_DATA;
        }

        if(*pdwSize < SIZEOF_IPNETTABLE(pTable->dwNumEntries))
        {
            Trace3(ERR,"GetIpNetTable: After MIBQuery. In size %d. Required %d. With overflow %d",
                   *pdwSize,
                   SIZEOF_IPNETTABLE(pTable->dwNumEntries),
                   SIZEOF_IPNETTABLE(pTable->dwNumEntries + OVERFLOW_COUNT));

            *pdwSize = SIZEOF_IPNETTABLE(pTable->dwNumEntries + OVERFLOW_COUNT);

            TraceLeave("GetIpNetTable");

            return ERROR_INSUFFICIENT_BUFFER;
        }

        *pdwSize = SIZEOF_IPNETTABLE(pTable->dwNumEntries);

        CopyMemory((PVOID)(pIpNetTable),
                   (PVOID)pTable,
                   SIZEOF_IPNETTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetIpNetTableFromStack(pIpNetTable,
                                          *pdwSize,
                                          bOrder,
                                          FALSE);


        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIpNetTable: GetIpNetTableFromStack failed with error %d",
                   dwResult);
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetIpNetTable");

    return dwResult;
}


DWORD
WINAPI
GetIpForwardTable(
    OUT     PMIB_IPFORWARDTABLE pIpForwardTable,
    IN OUT  PULONG              pdwSize,
    IN      BOOL                bOrder
    )
{
    DWORD       dwResult, dwOutEntrySize;
    MIB_IPSTATS miStats;

    PMIB_IPFORWARDTABLE pTable;
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;


    TraceEnter("GetIpForwardTable");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetIpForwardTable: No IP Stack on machine\n");

        TraceLeave("GetIpForwardTable");

        return ERROR_NOT_SUPPORTED;
    }

    if(pdwSize is NULL)
    {
        Trace0(ERR,"GetIpForwardTable: pdwSize is NULL");

        TraceLeave("GetIpForwardTable");

        return ERROR_INVALID_PARAMETER;
    }
    
    if (IsBadWritePtr(pdwSize, sizeof(ULONG))) {
      return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pIpForwardTable, *pdwSize)) {
      return ERROR_INVALID_PARAMETER;
    }

    dwResult = GetIpStatistics(&miStats);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetIpForwardTable: GetIpStatistics returned error %d",
               dwResult);

        TraceLeave("GetIpForwardTable");

        return dwResult;
    }

    if(miStats.dwNumRoutes is 0)
    {
        Trace0(ERR,"GetIpForwardTable: No entries");

        TraceLeave("GetIpForwardTable");

        return ERROR_NO_DATA;
    }

    if( (*pdwSize < SIZEOF_IPFORWARDTABLE(miStats.dwNumRoutes)) || (pIpForwardTable is NULL) )
    {
        Trace3(TRACE,"GetIpForwardTable: In size %d. Required %d. With overflow %d",
               *pdwSize,
               SIZEOF_IPFORWARDTABLE(miStats.dwNumRoutes),
               SIZEOF_IPFORWARDTABLE(miStats.dwNumRoutes + ROUTE_OVERFLOW_COUNT));

        *pdwSize = SIZEOF_IPFORWARDTABLE(miStats.dwNumRoutes + ROUTE_OVERFLOW_COUNT);

        TraceLeave("GetIpForwardTable");

        return ERROR_INSUFFICIENT_BUFFER;
    }

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = IP_FORWARDTABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIpForwardTable: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("GetIpForwardTable");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IPFORWARDTABLE, pTable);

        if(pTable->dwNumEntries is 0)
        {
            Trace0(ERR,"GetIpForwardTable: MprAdminMIBEntryGet returned 0 interfaces");

            MprAdminMIBBufferFree((PVOID)pInfo);

            TraceLeave("GetIpForwardTable");

            return ERROR_NO_DATA;
        }

        if(*pdwSize < SIZEOF_IPFORWARDTABLE(pTable->dwNumEntries))
        {
            Trace3(ERR,"GetIpForwardTable: After MIBQuery. In size %d. Required %d. With overflow %d",
                   *pdwSize,
                   SIZEOF_IPFORWARDTABLE(pTable->dwNumEntries),
                   SIZEOF_IPFORWARDTABLE(pTable->dwNumEntries + ROUTE_OVERFLOW_COUNT));

            *pdwSize = SIZEOF_IPFORWARDTABLE(pTable->dwNumEntries + ROUTE_OVERFLOW_COUNT);

            TraceLeave("GetIpForwardTable");

            return ERROR_INSUFFICIENT_BUFFER;
        }

        *pdwSize = SIZEOF_IPFORWARDTABLE(pTable->dwNumEntries);

        CopyMemory((PVOID)(pIpForwardTable),
                   (PVOID)pTable,
                   SIZEOF_IPFORWARDTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetIpForwardTableFromStack(pIpForwardTable,
                                              *pdwSize,
                                              bOrder);


        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIpForwardTable: GetIpForwardTableFromStack failed with error %d",
                   dwResult);
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("GetIpForwardTable");

    return dwResult;
}


DWORD
WINAPI
GetTcpTable(
    OUT     PMIB_TCPTABLE   pTcpTable,
    IN OUT  PDWORD          pdwSize,
    IN      BOOL            bOrder
    )
{
    DWORD       dwResult, dwOutEntrySize;

    PMIB_TCPTABLE       pTable;
    MIB_TCPSTATS        mtStats;
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;

    TraceEnter("GetTcpTable");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetTcpTable: No IP Stack on machine\n");

        TraceLeave("GetTcpTable");

        return ERROR_NOT_SUPPORTED;
    }

    if(pdwSize is NULL)
    {
        Trace0(ERR,"GetTcpTable: pdwSize is NULL");

        TraceLeave("GetTcpTable");

        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwSize, sizeof(ULONG))) {
      return ERROR_INVALID_PARAMETER;
    }
    
    if (IsBadWritePtr(pTcpTable, *pdwSize)) {
      return ERROR_INVALID_PARAMETER;
    }

    dwResult = GetTcpStatistics(&mtStats);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetTcpTable: GetTcpStatistics returned error %d",
               dwResult);

        TraceLeave("GetTcpTable");

        return dwResult;
    }

    if(mtStats.dwNumConns is 0)
    {
        Trace0(ERR,"GetTcpTable: No entries");

        TraceLeave("GetTcpTable");

        return ERROR_NO_DATA;
    }

    if( (*pdwSize < SIZEOF_TCPTABLE(mtStats.dwNumConns)) || (pTcpTable is NULL) )
    {
        Trace3(TRACE,"GetTcpTable: In size %d. Required %d. With overflow %d",
               *pdwSize,
               SIZEOF_TCPTABLE(mtStats.dwNumConns),
               SIZEOF_TCPTABLE(mtStats.dwNumConns + OVERFLOW_COUNT));

        *pdwSize = SIZEOF_TCPTABLE(mtStats.dwNumConns + OVERFLOW_COUNT);

        TraceLeave("GetTcpTable");

        return ERROR_INSUFFICIENT_BUFFER;
    }

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = TCP_TABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetTcpTable: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("GetTcpTable");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_TCPTABLE, pTable);

        if(pTable->dwNumEntries is 0)
        {
            Trace0(ERR,"GetTcpTable: MprAdminMIBEntryGet returned 0 interfaces");

            MprAdminMIBBufferFree((PVOID)pInfo);

            TraceLeave("GetTcpTable");

            return ERROR_NO_DATA;
        }

        if(*pdwSize < SIZEOF_TCPTABLE(pTable->dwNumEntries))
        {
            Trace3(ERR,"GetTcpTable: After MIBQuery. In size %d. Required %d. With overflow %d",
                   *pdwSize,
                   SIZEOF_TCPTABLE(pTable->dwNumEntries),
                   SIZEOF_TCPTABLE(pTable->dwNumEntries + OVERFLOW_COUNT));

            *pdwSize = SIZEOF_TCPTABLE(pTable->dwNumEntries + OVERFLOW_COUNT);

            TraceLeave("GetTcpTable");

            return ERROR_INSUFFICIENT_BUFFER;
        }

        *pdwSize = SIZEOF_TCPTABLE(pTable->dwNumEntries);

        CopyMemory((PVOID)(pTcpTable),
                   (PVOID)pTable,
                   SIZEOF_TCPTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetTcpTableFromStack(pTcpTable,
                                        *pdwSize,
                                        bOrder);


        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetTcpTable: GetTcpTableFromStack failed with error %d",
                   dwResult);
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetTcpTable");

    return dwResult;
}

DWORD
WINAPI
GetUdpTable(
    OUT     PMIB_UDPTABLE   pUdpTable,
    IN OUT  PDWORD          pdwSize,
    IN      BOOL            bOrder
    )
{
    DWORD       dwResult, dwOutEntrySize;

    PMIB_UDPTABLE       pTable;
    MIB_UDPSTATS        muStats;
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;

    TraceEnter("GetUdpTable");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetUdpTable: No IP Stack on machine\n");

        TraceLeave("GetUdpTable");

        return ERROR_NOT_SUPPORTED;
    }

    if(pdwSize is NULL)
    {
        Trace0(ERR,"GetUdpTable: pdwSize is NULL");

        TraceLeave("GetUdpTable");

        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwSize, sizeof(ULONG))) {
      return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pUdpTable, *pdwSize)) {
      return ERROR_INVALID_PARAMETER;
    }

    dwResult = GetUdpStatistics(&muStats);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetUdpTable: GetUdpStatistics returned error %d",
               dwResult);

        TraceLeave("GetUdpTable");

        return dwResult;
    }

    if(muStats.dwNumAddrs is 0)
    {
        Trace0(ERR,"GetUdpTable: No entries");

        TraceLeave("GetUdpTable");

        return ERROR_NO_DATA;
    }

    if( (*pdwSize < SIZEOF_UDPTABLE(muStats.dwNumAddrs)) || (pUdpTable is NULL) )
    {
        Trace3(TRACE,"GetUdpTable: In size %d. Required %d. With overflow %d",
               *pdwSize,
               SIZEOF_UDPTABLE(muStats.dwNumAddrs),
               SIZEOF_UDPTABLE(muStats.dwNumAddrs + OVERFLOW_COUNT));

        *pdwSize = SIZEOF_UDPTABLE(muStats.dwNumAddrs + OVERFLOW_COUNT);

        TraceLeave("GetUdpTable");

        return ERROR_INSUFFICIENT_BUFFER;
    }

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = UDP_TABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetUdpTable: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("GetUdpTable");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_UDPTABLE, pTable);

        if(pTable->dwNumEntries is 0)
        {
            Trace0(ERR,"GetUdpTable: MprAdminMIBEntryGet returned 0 interfaces");

            MprAdminMIBBufferFree((PVOID)pInfo);

            TraceLeave("GetUdpTable");

            return ERROR_NO_DATA;
        }

        if(*pdwSize < SIZEOF_UDPTABLE(pTable->dwNumEntries))
        {
            Trace3(ERR,"GetUdpTable: After MIBQuery. In size %d. Required %d. With overflow %d",
                   *pdwSize,
                   SIZEOF_UDPTABLE(pTable->dwNumEntries),
                   SIZEOF_UDPTABLE(pTable->dwNumEntries + OVERFLOW_COUNT));

            *pdwSize = SIZEOF_UDPTABLE(pTable->dwNumEntries + OVERFLOW_COUNT);

            TraceLeave("GetUdpTable");

            return ERROR_INSUFFICIENT_BUFFER;
        }

        *pdwSize = SIZEOF_UDPTABLE(pTable->dwNumEntries);

        CopyMemory((PVOID)(pUdpTable),
                   (PVOID)pTable,
                   SIZEOF_UDPTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetUdpTableFromStack(pUdpTable,
                                        *pdwSize,
                                        bOrder);


        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetUdpTable: GetUdpTableFromStack failed with error %d",
                   dwResult);
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetUdpTable");

    return dwResult;
}


DWORD
WINAPI
GetIpStatisticsEx(
    OUT  PMIB_IPSTATS   pStats,
    IN   DWORD          dwFamily
    )
{
    DWORD  dwResult, dwOutEntrySize;

    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_IPSTATS        pIpStats;

    TraceEnter("GetIpStatisticsEx");

    if (pStats == NULL) 
    {
       return ERROR_INVALID_PARAMETER;
    }
    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pStats, sizeof(MIB_IPSTATS))) {
      return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if (((dwFamily == AF_INET)  && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        Trace0(ERR, "GetIpStatistics: No IP Stack on machine\n");

        TraceLeave("GetIpStatistics");

        return ERROR_NOT_SUPPORTED;
    }

#ifndef CHICAGO
    if((dwFamily == AF_INET) && IsRouterRunning())
    {
        mqQuery.dwVarId = IP_STATS;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("GetIpStats");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IPSTATS, pIpStats);

        *pStats = *pIpStats;

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetIpStatsFromStackEx(pStats, dwFamily);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIpStatsFromStackEx failed with error %x",
                   dwResult);
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetIpStatisticsEx");

    return dwResult;
}

DWORD
WINAPI
GetIpStatistics(
    OUT  PMIB_IPSTATS   pStats
    )
{
    return GetIpStatisticsEx(pStats, AF_INET);
}

DWORD
WINAPI
GetIcmpStatistics(
    OUT PMIB_ICMP   pStats
    )
{
    DWORD  dwResult, dwOutEntrySize;

    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_ICMP           pIcmp;

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetIcmpStatistics: No IP Stack on machine\n");

        TraceLeave("GetIcmpStatistics");

        return ERROR_NOT_SUPPORTED;
    }


    if (pStats == NULL) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pStats, sizeof(MIB_ICMP))) {
        return ERROR_INVALID_PARAMETER;
    }

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = ICMP_STATS;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("GetIcmpStats");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_ICMP, pIcmp);

        *pStats = *pIcmp;

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif

        dwResult = GetIcmpStatsFromStack(pStats);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIpStatsFromStack failed with error %x",
                   dwResult);
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetIcmpStats");

    return NO_ERROR;
}

VOID
MakeIcmpStatsEx(
    OUT PMIBICMPSTATS_EX pNewStats,
    IN  PMIBICMPSTATS    pOldStats
    )    
{
    pNewStats->dwMsgs = pOldStats->dwMsgs;
    pNewStats->dwErrors = pOldStats->dwErrors;
    ZeroMemory(pNewStats->rgdwTypeCount, sizeof(pNewStats->rgdwTypeCount));
    pNewStats->rgdwTypeCount[ICMP4_DST_UNREACH] = pOldStats->dwDestUnreachs;
    pNewStats->rgdwTypeCount[ICMP4_TIME_EXCEEDED] = pOldStats->dwTimeExcds;
    pNewStats->rgdwTypeCount[ICMP4_PARAM_PROB] = pOldStats->dwParmProbs;
    pNewStats->rgdwTypeCount[ICMP4_SOURCE_QUENCH] = pOldStats->dwSrcQuenchs;
    pNewStats->rgdwTypeCount[ICMP4_REDIRECT] = pOldStats->dwRedirects;
    pNewStats->rgdwTypeCount[ICMP4_ECHO_REQUEST] = pOldStats->dwEchos;
    pNewStats->rgdwTypeCount[ICMP4_ECHO_REPLY] = pOldStats->dwEchoReps;
    pNewStats->rgdwTypeCount[ICMP4_TIMESTAMP_REQUEST] = pOldStats->dwTimestamps;
    pNewStats->rgdwTypeCount[ICMP4_TIMESTAMP_REPLY] = pOldStats->dwTimestampReps;
    pNewStats->rgdwTypeCount[ICMP4_MASK_REQUEST] = pOldStats->dwAddrMasks;
    pNewStats->rgdwTypeCount[ICMP4_MASK_REPLY] = pOldStats->dwAddrMaskReps;
}

DWORD
WINAPI
GetIcmpStatisticsEx(
    OUT PMIB_ICMP_EX pStats,
    IN  DWORD        dwFamily
    )
{
    DWORD  dwResult, dwOutEntrySize;

    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;
    PVOID               pIcmp;

    TraceEnter("GetIcmpStatisticsEx");

    if (pStats == NULL) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pStats, sizeof(MIB_ICMP_EX))) {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if (((dwFamily == AF_INET)  && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        Trace0(ERR, "GetIcmpStatisticsEx: No IP Stack on machine\n");

        TraceLeave("GetIcmpStatisticsEx");

        return ERROR_NOT_SUPPORTED;
    }

    if (dwFamily == AF_INET)
    {
        //
        // The IPv4 stack doesn't yet support MIB_ICMP_EX, so we'll
        // get the MIB_ICMP structure and convert it.
        //
        MIB_ICMP OldStats;

        dwResult = GetIcmpStatistics(&OldStats);
        if(dwResult == NO_ERROR)
        {
            MakeIcmpStatsEx(&pStats->icmpInStats, 
                            &OldStats.stats.icmpInStats);
            MakeIcmpStatsEx(&pStats->icmpOutStats, 
                            &OldStats.stats.icmpOutStats);
        }
    }
    else
    {
        dwResult = GetIcmpStatsFromStackEx(pStats, dwFamily);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIpStatsFromStackEx failed with error %x",
                   dwResult);
        }
    }

    TraceLeave("GetIcmpStatisticsEx");

    return dwResult;
}

DWORD
WINAPI
GetTcpStatisticsEx(
    OUT PMIB_TCPSTATS   pStats,
    IN  DWORD           dwFamily
    )
{
    DWORD  dwResult, dwOutEntrySize;

    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_TCPSTATS       pTcpStats;

    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if (((dwFamily == AF_INET)  && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        Trace0(ERR, "GetTcpStatistics: No IP Stack on machine\n");

        TraceLeave("GetTcpStatistics");

        return ERROR_NOT_SUPPORTED;
    }

    if(pStats == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pStats, sizeof(MIB_TCPSTATS))) {
      return ERROR_INVALID_PARAMETER;
    }

#ifndef CHICAGO
    if((dwFamily == AF_INET) && IsRouterRunning())
    {
        mqQuery.dwVarId = TCP_STATS;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("GetTcpStats");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_TCPSTATS, pTcpStats);

        *pStats = *pTcpStats;

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetTcpStatsFromStackEx(pStats, dwFamily);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetTcpStatsFromStackEx failed with error %x",
                   dwResult);
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetTcpStats");

    return dwResult;
}

DWORD
WINAPI
GetTcpStatistics(
    OUT PMIB_TCPSTATS   pStats
    )
{
    return GetTcpStatisticsEx(pStats, AF_INET);
}

DWORD
WINAPI
GetUdpStatisticsEx(
    OUT PMIB_UDPSTATS   pStats,
    IN  DWORD           dwFamily
    )
{
    DWORD  dwResult,dwOutEntrySize;

    PMIB_OPAQUE_INFO    pInfo;
    PMIB_UDPSTATS       pUdpStats;
    MIB_OPAQUE_QUERY    mqQuery;

    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if (((dwFamily == AF_INET)  && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        Trace0(ERR, "GetUdpStatistics: No IP Stack on machine\n");

        TraceLeave("GetUdpStatistics");

        return ERROR_NOT_SUPPORTED;
    }


    if(pStats == NULL) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pStats, sizeof(MIB_UDPSTATS))) {
      return ERROR_INVALID_PARAMETER;
    }

#ifndef CHICAGO
    if((dwFamily == AF_INET) && IsRouterRunning())
    {
        mqQuery.dwVarId = UDP_STATS;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("GetUdpStats");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_UDPSTATS, pUdpStats);

        *pStats = *pUdpStats;

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetUdpStatsFromStackEx(pStats, dwFamily);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetUdpStatsFromStack failed with error %x",
                   dwResult);
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("GetUdpStats");

    return dwResult;
}

DWORD
WINAPI
GetUdpStatistics(
    OUT PMIB_UDPSTATS   pStats
    )
{
    return GetUdpStatisticsEx(pStats, AF_INET);
}


DWORD
GetIfEntry(
    IN OUT PMIB_IFROW  pIfEntry
    )
{
    if (!pIfEntry ||
        IsBadWritePtr(pIfEntry, sizeof(MIB_IFROW)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }
   
    return GetIfEntryFromStack(pIfEntry,
                               pIfEntry->dwIndex,
                               TRUE);
}

DWORD
WINAPI
SetIfEntry(
    IN PMIB_IFROW pIfRow
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pInfo,MIB_IFROW, pSetRow);

    TraceEnter("SetIfEntry");

    if(pIfRow == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadReadPtr(pIfRow, sizeof(MIB_IFROW))) {
      return ERROR_INVALID_PARAMETER;
    }
    
    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "SetIfEntry: No IP Stack on machine\n");

        TraceLeave("SetIfEntry");

        return ERROR_NOT_SUPPORTED;
    }

    if (!pInfo) {
        Trace0(ERR, "SetIfEntry: If Entry NULL\n");

        TraceLeave("SetIfEntry");

        return ERROR_INVALID_DATA;

    }

    pInfo->dwId = IF_ROW;
    *pSetRow    = *pIfRow;

    dwResult = InternalSetIfEntry(pInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "SetIfEntry: InternalSetIfEntry returned %d",
               dwResult);
    }

    TraceLeave("SetIfEntry");

    return dwResult;
}


DWORD
WINAPI
CreateIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pCreateInfo,MIB_IPFORWARDROW,pCreateRow);

    TraceEnter("CreateIpForwardEntry");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "CreateIpForwardEntry: No IP Stack on machine\n");

        TraceLeave("CreateIpForwardEntry");

        return ERROR_NOT_SUPPORTED;
    }

    if(pRoute == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if (IsBadReadPtr(pRoute, sizeof(MIB_IPFORWARDROW))) {
      return ERROR_INVALID_PARAMETER;
    }

    pCreateInfo->dwId = IP_FORWARDROW;
    *pCreateRow       = *pRoute;

    dwResult = InternalCreateIpForwardEntry(pCreateInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "CreateIpForwardEntry: InternalCreateIpForwardEntry returned %d",
               dwResult);
    }
    if (dwResult == STATUS_INVALID_PARAMETER) {
       return(ERROR_INVALID_PARAMETER);
    }

    TraceLeave("CreateIpForwardEntry");

    return dwResult;
}


DWORD
WINAPI
SetIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pSetInfo,MIB_IPFORWARDROW,pSetRow);

    TraceEnter("SetIpForwardEntry");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "SetIpForwardEntry: No IP Stack on machine\n");

        TraceLeave("SetIpForwardEntry");

        return ERROR_NOT_SUPPORTED;
    }


    if(pRoute == NULL) 
    {
        return(ERROR_INVALID_PARAMETER);
    }
    
    if (IsBadReadPtr(pRoute, sizeof(MIB_IPFORWARDROW))) {
      return ERROR_INVALID_PARAMETER;
    }

    pSetInfo->dwId  = IP_FORWARDROW;
    *pSetRow        = *pRoute;

    dwResult = InternalSetIpForwardEntry(pSetInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "SetIpForwardEntry: InternalSetIpForwardEntry returned %d",
               dwResult);
    }

    if (dwResult == STATUS_INVALID_PARAMETER) {

       return(ERROR_INVALID_PARAMETER);
    }


    TraceLeave("SetIpForwardEntry");

    return dwResult;
}


DWORD
WINAPI
DeleteIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pDeleteInfo,MIB_IPFORWARDROW,pDeleteRow);


    TraceEnter("DeleteIpForwardEntry");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "DeleteIpForwardEntry: No IP Stack on machine\n");

        TraceLeave("DeleteIpForwardEntry");

        return ERROR_NOT_SUPPORTED;
    }


    if(pRoute == NULL) 
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if (IsBadReadPtr(pRoute, sizeof(MIB_IPFORWARDROW))) {
      return ERROR_INVALID_PARAMETER;
    }

    pDeleteInfo->dwId   = IP_FORWARDROW;
    *pDeleteRow         = *pRoute;

    dwResult = InternalDeleteIpForwardEntry(pDeleteInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "DeleteIpForwardEntry: InternalDeleteIpForwardEntry returned %d",
               dwResult);
    }
    if (dwResult == STATUS_INVALID_PARAMETER) {
       return(ERROR_NOT_FOUND);
    }



    TraceLeave("DeleteIpForwardEntry");

    return dwResult;
}

DWORD
WINAPI
SetIpTTL(
    UINT nTTL
    )
{
    MIB_IPSTATS   Stats;
    DWORD         dwResult;

    TraceEnter("SetIpTTL");
    
    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "SetIpTTL: No IP Stack on machine\n");

        TraceLeave("SetIpTTL");

        return ERROR_NOT_SUPPORTED;
    }

    dwResult = GetIpStatistics( &Stats );

    if(dwResult isnot NO_ERROR)
    {
          Trace1(ERR,"SetIpTll: GetIpStatistics failed with error %x",
         dwResult);
      
      TraceLeave("SetIpTTL");
      
      return dwResult;
    }

    Stats.dwForwarding = MIB_USE_CURRENT_FORWARDING;
    Stats.dwDefaultTTL = nTTL;

    dwResult = SetIpStatistics( &Stats );

    if(dwResult isnot NO_ERROR)
    {
          Trace1(ERR,"SetIpTll: GetIpStatistics failed with error %x",
         dwResult);
      
    }

    TraceLeave("SetIpTTL");
    return dwResult;
}


DWORD
WINAPI
SetIpStatistics(
    IN PMIB_IPSTATS pIpStats
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pSetInfo,MIB_IPSTATS,pSetStats);

    TraceEnter("SetIpStatistics");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "SetIpStatistics: No IP Stack on machine\n");

        TraceLeave("SetIpStatistics");

        return ERROR_NOT_SUPPORTED;
    }

    if(pIpStats == NULL) 
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if (IsBadReadPtr(pIpStats, sizeof(MIB_IPSTATS))) {
      return ERROR_INVALID_PARAMETER;
    }

    pSetInfo->dwId  = IP_STATS;
    *pSetStats      = *pIpStats;

    dwResult = InternalSetIpStats(pSetInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "SetIpStatistics: InternalSetIpStats returned %d",
               dwResult);
    }

    TraceLeave("SetIpStatistics");

    return dwResult;
}


DWORD
WINAPI
CreateIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pCreateInfo,MIB_IPNETROW,pCreateRow);

    TraceEnter("CreateIpNetEntry");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "CreateIpNetEntry: No IP Stack on machine\n");

        TraceLeave("CreateIpNetEntry");

        return ERROR_NOT_SUPPORTED;
    }

    if(!pArpEntry)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    pCreateInfo->dwId   = IP_NETROW;
    *pCreateRow         = *pArpEntry;

    if((pArpEntry->dwPhysAddrLen is 0) or
       (pArpEntry->dwPhysAddrLen > MAXLEN_PHYSADDR))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(((pArpEntry->dwAddr & 0x000000FF) is 0x0000007F) or
       ((DWORD)(pArpEntry->dwAddr  & 0x000000FF) >= (DWORD) 0x000000E0))
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    dwResult = InternalCreateIpNetEntry(pCreateInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "CreateIpNetEntry: InternalCreateIpNetEntry returned %d",
               dwResult);
    }

    TraceLeave("CreateIpNetEntry");

    return dwResult;
}


DWORD
WINAPI
SetIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pSetInfo,MIB_IPNETROW,pSetRow);

    TraceEnter("SetIpNetEntry");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "SetIpNetEntry: No IP Stack on machine\n");

        TraceLeave("SetIpNetEntry");

        return ERROR_NOT_SUPPORTED;
    }

    if (!pArpEntry) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadReadPtr(pArpEntry, sizeof(MIB_IPNETROW))) {
      return ERROR_INVALID_PARAMETER;
    }

    pSetInfo->dwId  = IP_NETROW;
    *pSetRow        = *pArpEntry;

    dwResult = InternalSetIpNetEntry(pSetInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "SetIpNetEntry: InternalSetIpNetEntry returned %d",
               dwResult);
    }

    TraceLeave("SetIpNetEntry");

    return dwResult;
}


DWORD
WINAPI
DeleteIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pDeleteInfo,MIB_IPNETROW,pDeleteRow);

    TraceEnter("DeleteIpNetEntry");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "DeleteIpNetEntry: No IP Stack on machine\n");

        TraceLeave("DeleteIpNetEntry");

        return ERROR_NOT_SUPPORTED;
    }

    if(pArpEntry == NULL) 
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if (IsBadReadPtr(pArpEntry, sizeof(MIB_IPNETROW))) {
      return ERROR_INVALID_PARAMETER;
    }

    pDeleteInfo->dwId   = IP_NETROW;
    *pDeleteRow         = *pArpEntry;

    dwResult = InternalDeleteIpNetEntry(pDeleteInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "DeleteIpNetEntry: InternalDeleteIpNetEntry returned %d",
               dwResult);
    }

    TraceLeave("DeleteIpNetEntry");


    return dwResult;
}

DWORD
WINAPI
FlushIpNetTable(
    IN DWORD    dwIfIndex
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pDeleteInfo,MIB_IPNETROW,pDeleteRow);

    TraceEnter("FlushIpNetTable");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "FlushIpNetTable: No IP Stack on machine\n");

        TraceLeave("FlushIpNetTable");

        return ERROR_NOT_SUPPORTED;
    }

    if(dwIfIndex == 0)
    {
        return(ERROR_INVALID_PARAMETER);
    }

#ifndef CHICAGO

    if(IsRouterRunning())
    {
        MIB_OPAQUE_QUERY    Query;

        Query.dwVarId = IP_NETTABLE;

        Query.rgdwVarIndex[0] = dwIfIndex;

        dwResult = MprAdminMIBEntryDelete(g_hMIBServer,
                                          PID_IP,
                                          IPRTRMGR_PID,
                                          &Query,
                                          sizeof(Query));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryDelete failed with error %x",
                   dwResult);

            TraceLeave("FlushIpNetTable");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = FlushIpNetTableFromStack(dwIfIndex);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"FlushIpNetTableFromStack failed with error %d",
                   dwResult);

            TraceLeave("FlushIpNetTable");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("FlushIpNetTable");

    return dwResult;
}


DWORD
WINAPI
SetTcpEntry(
    IN PMIB_TCPROW pTcpRow
    )
{
    DWORD               dwResult;
    DEFINE_MIB_BUFFER(pSetInfo,MIB_TCPROW,pSetRow);

    TraceEnter("SetTcpEntry");
    
    if(!pTcpRow) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "SetTcpEntry: No IP Stack on machine\n");

        TraceLeave("SetTcpEntry");

        return ERROR_NOT_SUPPORTED;
    }

    if (IsBadReadPtr(pTcpRow, sizeof(MIB_TCPROW))) {
      return ERROR_INVALID_PARAMETER;
    }

    pSetInfo->dwId  = TCP_ROW;
    *pSetRow        = *pTcpRow;

    dwResult = InternalSetTcpEntry(pSetInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "SetTcpEntry: InternalSetTcpEntry returned %d",
               dwResult);
    }

    TraceLeave("SetTcpEntry");

    return dwResult;
}

DWORD
WINAPI
GetBestInterface(
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex 
    )
{
    DWORD               dwResult, dwOutEntrySize;
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_BEST_IF        pBestIf;

    TraceEnter("GetBestInterface");

    if(pdwBestIfIndex is NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwBestIfIndex, sizeof(DWORD))) {
      return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetBestInterface: No IP Stack on machine\n");

        TraceLeave("GetBestInterface");

        return ERROR_NOT_SUPPORTED;
    }

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId         = BEST_IF;
        mqQuery.rgdwVarIndex[0] = dwDestAddr;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetIfTable: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("GetIfTable");

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_BEST_IF, pBestIf);

        if(dwDestAddr is pBestIf->dwDestAddr)
        {
            *pdwBestIfIndex = pBestIf->dwIfIndex;
        }
        else
        {
            dwResult = ERROR_CAN_NOT_COMPLETE;
        }

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = GetBestInterfaceFromStack(dwDestAddr,
                                             pdwBestIfIndex);

        if(dwResult is STATUS_SUCCESS)
        {
            dwResult = NO_ERROR;
        }
        else
        {
            dwResult = ERROR_CAN_NOT_COMPLETE;
        }
#ifndef CHICAGO
    }
#endif

    return dwResult;
}

DWORD
WINAPI
GetBestInterfaceEx(
    IN  LPSOCKADDR pSockAddr,
    OUT PDWORD     pdwBestIfIndex 
    )
{
    DWORD dwResult;
    LPSOCKADDR_IN6 pSin6;
    IPAddr dwDestAddr;

    if (IsBadReadPtr(pSockAddr, sizeof(SOCKADDR))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pSockAddr->sa_family == AF_INET) {
        return GetBestInterface(((LPSOCKADDR_IN)pSockAddr)->sin_addr.s_addr, pdwBestIfIndex);
    }
    if (pSockAddr->sa_family != AF_INET6) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadReadPtr(pSockAddr, sizeof(SOCKADDR_IN6))) {
        return ERROR_INVALID_PARAMETER;
    }
    pSin6 = (LPSOCKADDR_IN6)pSockAddr;

    if (IN6_IS_ADDR_V4MAPPED(&pSin6->sin6_addr)) {
        CopyMemory(&dwDestAddr,
                   &pSin6->sin6_addr.s6_words[6],
                   sizeof(dwDestAddr));

        return GetBestInterface(dwDestAddr, pdwBestIfIndex);
    }

    if (pdwBestIfIndex is NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwBestIfIndex, sizeof(DWORD))) {
      return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();

    if (!g_bIp6Configured) {
        Trace0(ERR, "GetBestInterface: No IPv6 Stack on machine\n");
        return ERROR_NOT_SUPPORTED;
    }

    dwResult = GetBestInterfaceFromIpv6Stack(pSin6, pdwBestIfIndex);

    return dwResult;
}

DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    )
{
    DWORD               dwResult, dwOutEntrySize, dwQuerySize;

    TraceEnter("GetBestRoute");

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "GetBestInterface: No IP Stack on machine\n");

        TraceLeave("GetBestInterface");

        return ERROR_NOT_SUPPORTED;
    }

    if(pBestRoute is NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pBestRoute, sizeof(MIB_IPFORWARDROW))) {
        return ERROR_INVALID_PARAMETER;
    }

    dwResult = GetBestRouteFromStack(dwDestAddr,
                                     dwSourceAddr,
                                     pBestRoute);

    if(dwResult is STATUS_SUCCESS)
    {
        dwResult = NO_ERROR;
    }
    else
    {
        dwResult = ERROR_CAN_NOT_COMPLETE;
    }

    return dwResult;
}

DWORD
WINAPI
CreateProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    )
{
    DWORD       dwResult, dwClassMask;
    DEFINE_MIB_BUFFER(pSetInfo,MIB_PROXYARP,pParpRow);

    TraceEnter("CreateProxyArpEntry");

#ifdef CHICAGO

    TraceLeave("CreateProxyArpEntry");

    return ERROR_NOT_SUPPORTED;

#else

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, "CreateProxyArpEntry: No IP Stack on machine\n");

        TraceLeave("CreateProxyArpEntry");

        return ERROR_NOT_SUPPORTED;
    }

    dwClassMask = GetClassMask(dwAddress);

    //
    // Address & Mask should == Address
    // Address should not be in the loopback range
    // Address should not be all 0's
    // Address should not be < ClassD
    // Address should not be the all subnets broadcast
    //

    if(((dwAddress & 0x000000FF) is 0x0000007F) or
       (dwAddress is 0x00000000) or
       ((DWORD)(dwAddress  & 0x000000FF) >= (DWORD) 0x000000E0) or
       ((dwAddress & dwMask) isnot dwAddress) or
       (dwAddress is (dwAddress | ~dwClassMask)))
    {
        TraceLeave("CreateProxyArpEntry");

        return ERROR_INVALID_PARAMETER;
    }

    if(IsRouterRunning())
    {
        pSetInfo->dwId      = PROXY_ARP;

        pParpRow->dwAddress = dwAddress;
        pParpRow->dwMask    = dwMask;
        pParpRow->dwIfIndex = dwIfIndex;
        
        dwResult = MprAdminMIBEntrySet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pSetInfo,
                                       MIB_INFO_SIZE(MIB_PROXYARP));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "MprAdminMIBEntrySet failed with error %x",
                   dwResult);

            TraceLeave("CreateProxyArpEntry");

            return dwResult;
        }
    }
    else
    {
        dwResult = SetProxyArpEntryToStack(dwAddress,
                                           dwMask,
                                           dwIfIndex,
                                           TRUE,
                                           FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "SetProxyArpEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("CreateProxyArpEntry");

            return dwResult;
        }

    }

    TraceLeave("CreateProxyArpEntry");

    return NO_ERROR;

#endif

}

DWORD
WINAPI
DeleteProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    )
{
    DWORD               dwResult, dwClassMask;
    PMIB_OPAQUE_QUERY   pmqQuery;

#define QUERY_SIZE      sizeof(MIB_OPAQUE_QUERY) + 2 * sizeof(DWORD)

    BYTE                rgbyBuffer[QUERY_SIZE];

#undef QUERY_SIZE

    TraceEnter("DeleteProxyArpEntry");

#ifdef CHICAGO

    TraceLeave("DeleteProxyArpEntry");

    return ERROR_NOT_SUPPORTED;

#else

    CheckTcpipState();

    if(!g_bIpConfigured)
    {
        Trace0(ERR, 
               "DeleteProxyArpEntry: No IP Stack on machine\n");

        TraceLeave("DeleteProxyArpEntry");

        return ERROR_NOT_SUPPORTED;
    }

    dwClassMask = GetClassMask(dwAddress);

    if(((dwAddress & 0x000000FF) is 0x0000007F) or
       (dwAddress is 0x00000000) or
       ((DWORD)(dwAddress  & 0x000000FF) >= (DWORD) 0x000000E0) or
       ((dwAddress & dwMask) isnot dwAddress) or
       (dwAddress is (dwAddress | ~dwClassMask)))
    {
        TraceLeave("DeleteProxyArpEntry");

        return ERROR_INVALID_PARAMETER;
    }


    if(IsRouterRunning())
    {
        pmqQuery = (PMIB_OPAQUE_QUERY)rgbyBuffer;

        pmqQuery->dwVarId         = PROXY_ARP;
        pmqQuery->rgdwVarIndex[0] = dwAddress;
        pmqQuery->rgdwVarIndex[1] = dwMask;
        pmqQuery->rgdwVarIndex[2] = dwIfIndex;

        dwResult = MprAdminMIBEntryDelete(g_hMIBServer,
                                          PID_IP,
                                          IPRTRMGR_PID,
                                          (PVOID)pmqQuery,
                                          sizeof(rgbyBuffer));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "MprAdminMIBEntryDelete failed with error %x",
                   dwResult);

            TraceLeave("DeleteProxyArpEntry");

            return dwResult;
        }
    }
    else
    {
        dwResult = SetProxyArpEntryToStack(dwAddress,
                                           dwMask,
                                           dwIfIndex,
                                           FALSE,
                                           FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "SetProxyArpEntryToStack failed with error %x",
                   dwResult);

            TraceLeave("DeleteProxyArpEntry");

            return dwResult;
        }

    }

    TraceLeave("DeleteProxyArpEntry");

    return NO_ERROR;

#endif
}

DWORD
WINAPI
GetFriendlyIfIndex(
    DWORD IfIndex
    )
{
    return (0x00FFFFFF & IfIndex);
}

PWCHAR
NhGetInterfaceTypeString(
    IN  DWORD   dwIfType
    )
{
    PWCHAR  pwszOut;


    if((dwIfType < MIN_IF_TYPE) or
       (dwIfType > MAX_IF_TYPE))
    {
        return NULL;
    }

    pwszOut = HeapAlloc(g_hPrivateHeap,
                        0,
                        MAX_IF_TYPE_LENGTH * sizeof(WCHAR));

    if(pwszOut is NULL)
    {
        return NULL;
    }

    if(!LoadStringW(g_hModule,
                    dwIfType,
                    pwszOut,
                    MAX_IF_TYPE_LENGTH))
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 pwszOut);

        return NULL;
    }

    return pwszOut;
}

VOID            
NhFreeString(
    IN  PWCHAR  pwszString
    )
{
    HeapFree(g_hPrivateHeap,
             0,
             pwszString);
}


VOID
CheckTcpipState()
{
    // Check whether tcpip was configured 
    // if not, check whether tcpip is configured now
  
    EnterCriticalSection(&g_stateLock);

    if (!g_bIpConfigured) {
        if(OpenTCPDriver(AF_INET) == NO_ERROR) {
            g_bIpConfigured = TRUE;
            if(UpdateAdapterToIFInstanceMapping() != NO_ERROR) {
                g_bIpConfigured = FALSE;
                CloseTCPDriver();
            } else {
                if(UpdateAdapterToATInstanceMapping() != NO_ERROR) {
                    g_bIpConfigured = FALSE;
                    CloseTCPDriver();
                } else {
                    g_bIpConfigured = TRUE;
                }
            }
        } else {
            g_bIpConfigured = FALSE;                                          
        }

        if (g_bIpConfigured) {
            if (IpcfgdllInit(NULL, DLL_PROCESS_ATTACH, NULL) == FALSE) {
                g_bIpConfigured = FALSE;
                CloseTCPDriver();
            }
        }
    }

    if (!g_bIp6Configured) {
        if(OpenTCPDriver(AF_INET6) == NO_ERROR) {
            g_bIp6Configured = TRUE;
        } else {
            g_bIp6Configured = FALSE;
        }
    }

    LeaveCriticalSection(&g_stateLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\defs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    net\routing\ip\infoutil\defs.h

Abstract:


Revision History:
     MohsinA, 04-Jul-97. Console debugging support for Memphis.


--*/

#ifndef __DEFS_H__
#define __DEFS_H__


#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define INVALID_INDEX_OR_INSTANCE   0xffffffff

#define INVALID_IF_INSTANCE         INVALID_INDEX_OR_INSTANCE
#define INVALID_AT_INSTANCE         INVALID_INDEX_OR_INSTANCE

#define MAP_HASH_SIZE               37

#define GET_IF_ENTRY                0
#define SET_IF_ENTRY                1

#define OVERFLOW_COUNT              10
#define ROUTE_OVERFLOW_COUNT        20

#define IF_CACHE_LIFE               (60 * 1000)
#define ARP_CACHE_LIFE              (60 * 1000)

#define MAX_IF_TYPE_LENGTH          256

//
// VOID
// ConvertRouteToForward(IPRouteEntry* route, PMIB_IPFORWARDROW forwardRow)
//

#define ConvertRouteToForward(route,forwardRow){                \
    (forwardRow)->dwForwardDest      = (route)->ire_dest;       \
    (forwardRow)->dwForwardIfIndex   = (route)->ire_index;      \
    (forwardRow)->dwForwardMetric1   = (route)->ire_metric1;    \
    (forwardRow)->dwForwardMetric2   = (route)->ire_metric2;    \
    (forwardRow)->dwForwardMetric3   = (route)->ire_metric3;    \
    (forwardRow)->dwForwardMetric4   = (route)->ire_metric4;    \
    (forwardRow)->dwForwardMetric5   = (route)->ire_metric5;    \
    (forwardRow)->dwForwardNextHop   = (route)->ire_nexthop;    \
    (forwardRow)->dwForwardType	     = (route)->ire_type;       \
    (forwardRow)->dwForwardProto     = (route)->ire_proto;      \
    (forwardRow)->dwForwardAge       = (route)->ire_age;        \
    (forwardRow)->dwForwardMask      = (route)->ire_mask;       \
    (forwardRow)->dwForwardNextHopAS = 0;                       \
    (forwardRow)->dwForwardPolicy    = 0;                       \
  }

#ifdef CHICAGO
#define ConvertForwardToRoute(route,forwardRow){                \
    (route)->ire_dest       = (forwardRow)->dwForwardDest;      \
    (route)->ire_index      = (forwardRow)->dwForwardIfIndex;   \
    (route)->ire_metric1    = (forwardRow)->dwForwardMetric1;   \
    (route)->ire_metric2    = (forwardRow)->dwForwardMetric2;   \
    (route)->ire_metric3    = (forwardRow)->dwForwardMetric3;   \
    (route)->ire_metric4    = (forwardRow)->dwForwardMetric4;   \
    (route)->ire_metric5    = (forwardRow)->dwForwardMetric5;   \
    (route)->ire_nexthop    = (forwardRow)->dwForwardNextHop;   \
    (route)->ire_type       = (forwardRow)->dwForwardType;      \
    (route)->ire_proto      = (forwardRow)->dwForwardProto;     \
    (route)->ire_age        = (forwardRow)->dwForwardAge;       \
    (route)->ire_mask       = (forwardRow)->dwForwardMask;      \
  }
#else
#define ConvertForwardToRoute(route,forwardRow){                \
    (route)->ire_dest       = (forwardRow)->dwForwardDest;      \
    (route)->ire_index      = (forwardRow)->dwForwardIfIndex;   \
    (route)->ire_metric1    = (forwardRow)->dwForwardMetric1;   \
    (route)->ire_metric2    = (forwardRow)->dwForwardMetric2;   \
    (route)->ire_metric3    = (forwardRow)->dwForwardMetric3;   \
    (route)->ire_metric4    = (forwardRow)->dwForwardMetric4;   \
    (route)->ire_metric5    = (forwardRow)->dwForwardMetric5;   \
    (route)->ire_nexthop    = (forwardRow)->dwForwardNextHop;   \
    (route)->ire_type       = (forwardRow)->dwForwardType;      \
    (route)->ire_proto      = (forwardRow)->dwForwardProto;     \
    (route)->ire_age        = (forwardRow)->dwForwardAge;       \
    (route)->ire_mask       = (forwardRow)->dwForwardMask;      \
    (route)->ire_context    = 0x00000000;                       \
  }
#endif
#if API_TRACE

#define IPHLPAPI_TRACE_ANY              ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPHLPAPI_TRACE_ERR              ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPHLPAPI_TRACE_TRACE            ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPHLPAPI_TRACE_ENTER            ((DWORD)0x80000000 | TRACE_USE_MASK)

#define TRACEID         g_dwTraceHandle


#define Trace0(l,a)             \
            TracePrintfEx(TRACEID, IPHLPAPI_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEID, IPHLPAPI_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEID, IPHLPAPI_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEID, IPHLPAPI_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEID, IPHLPAPI_TRACE_ ## l, a, b, c, d, e)

#if DBG

#define TraceEnter(X)           \
    TracePrintfEx(TRACEID, IPHLPAPI_TRACE_ENTER, "Entered: " X)
#define TraceLeave(X)           \
    TracePrintfEx(TRACEID, IPHLPAPI_TRACE_ENTER, "Leaving: " X"\n")

#endif // DBG

#else // API_TRACE

#define Trace0(l,a)
#define Trace1(l,a,b)
#define Trace2(l,a,b,c)
#define Trace3(l,a,b,c,d)
#define Trace4(l,a,b,c,d,e)

#define TraceEnter(X)
#define TraceLeave(X)

#endif  // API_TRACE




typedef struct _AIHASH
{
  LIST_ENTRY  leList;
  DWORD       dwAdapterIndex;
  DWORD       dwATInstance;
  DWORD       dwIFInstance;
}AIHASH, *LPAIHASH;

#endif


// MohsinA, 04-Jul-97. Debugging on console.

#if 0

#undef Trace0
#undef Trace1
#undef Trace2
#undef Trace3
#undef Trace4
#undef TraceEnter
#undef TraceLeave

#define Trace0(l,a)          DEBUG_PRINT((" " ## #l ## " " ## a ## "\n" ));
#define Trace1(l,a,b)        DEBUG_PRINT((" " ## #l ## " " ## a ## "\n", b ));
#define Trace2(l,a,b,c)      DEBUG_PRINT((" " ## #l ## " " ## a ## "\n", b, c ));
#define Trace3(l,a,b,c,d)    DEBUG_PRINT((" " ## #l ## " " ## a ## "\n", b, c, d ));
#define Trace4(l,a,b,c,d,e)  DEBUG_PRINT((" " ## #l ## " " ## a ## "\n", b, c, d, e ));
#define TraceEnter(X)        DEBUG_PRINT(("-> " ## X "\n" ));
#define TraceLeave(X)        DEBUG_PRINT(("<- " ## X "\n" ));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\error.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//

#include "inc.h"
#pragma hdrstop

#include "localmsg.h"

struct ErrorTable {
    IP_STATUS Error;
    DWORD ErrorCode;
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,            IP_MESSAGE_BUF_TOO_SMALL            },
    { IP_DEST_NO_ROUTE,            IP_MESSAGE_DEST_NO_ROUTE            },
    { IP_DEST_PROHIBITED,          IP_MESSAGE_DEST_PROHIBITED          },
    { IP_DEST_SCOPE_MISMATCH,      IP_MESSAGE_DEST_SCOPE_MISMATCH      },
    { IP_DEST_ADDR_UNREACHABLE,    IP_MESSAGE_DEST_ADDR_UNREACHABLE    },
    { IP_DEST_PORT_UNREACHABLE,    IP_MESSAGE_DEST_PORT_UNREACHABLE    },
    { IP_DEST_UNREACHABLE,         IP_MESSAGE_DEST_UNREACHABLE         },
    { IP_NO_RESOURCES,             IP_MESSAGE_NO_RESOURCES             },
    { IP_BAD_OPTION,               IP_MESSAGE_BAD_OPTION               },
    { IP_HW_ERROR,                 IP_MESSAGE_HW_ERROR                 },
    { IP_PACKET_TOO_BIG,           IP_MESSAGE_PACKET_TOO_BIG           },
    { IP_REQ_TIMED_OUT,            IP_MESSAGE_REQ_TIMED_OUT            },
    { IP_BAD_REQ,                  IP_MESSAGE_BAD_REQ                  },
    { IP_BAD_ROUTE,                IP_MESSAGE_BAD_ROUTE                },
    { IP_HOP_LIMIT_EXCEEDED,       IP_MESSAGE_HOP_LIMIT_EXCEEDED       },
    { IP_REASSEMBLY_TIME_EXCEEDED, IP_MESSAGE_REASSEMBLY_TIME_EXCEEDED },
    { IP_PARAMETER_PROBLEM,        IP_MESSAGE_PARAMETER_PROBLEM        },
    { IP_OPTION_TOO_BIG,           IP_MESSAGE_OPTION_TOO_BIG           },
    { IP_BAD_DESTINATION,          IP_MESSAGE_BAD_DESTINATION          },
    { IP_TIME_EXCEEDED,            IP_MESSAGE_TIME_EXCEEDED            },
    { IP_BAD_HEADER,               IP_MESSAGE_BAD_HEADER               },
    { IP_UNRECOGNIZED_NEXT_HEADER, IP_MESSAGE_UNRECOGNIZED_NEXT_HEADER },
    { IP_ICMP_ERROR,               IP_MESSAGE_ICMP_ERROR               },
    // the following error must be last - it is used as a sentinel
    { IP_GENERAL_FAILURE,          IP_MESSAGE_GENERAL_FAILURE          }
};

DWORD
WINAPI
GetIpErrorString(
    IN IP_STATUS ErrorCode,
    OUT PWCHAR Buffer,
    IN OUT PDWORD Size
    )
/*++

Routine Description:

    Returns the error message corresponding to the specified error code
    in the user supplied buffer.
    
Arguments:

    ErrorCode - Supplies the code identifying the error.
    
    Buffer - Returns the error message.
 
    Size - Supplies the number of characters that can be stored in 'Buffer',
        excluding the terminating nul. Returns the required character count.
    
Return Value:

    NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
    
--*/    
{
    DWORD Count, Status = NO_ERROR;
    PWCHAR Message = NULL;
    int i;
    
    for (i = 0; ErrorTable[i].Error != IP_GENERAL_FAILURE; i++) {
        if (ErrorTable[i].Error == ErrorCode) {
            break;
        }
    }
    
    Count = FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE     |
        FORMAT_MESSAGE_ALLOCATE_BUFFER  |
        FORMAT_MESSAGE_IGNORE_INSERTS   |
        FORMAT_MESSAGE_MAX_WIDTH_MASK,
        g_hModule,
        ErrorTable[i].ErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR) &Message,
        0,
        NULL);
    
    if (*Size < Count) {
        *Size = Count;
        Status = ERROR_INSUFFICIENT_BUFFER;
    } else if (Message) {
        wcscpy(Buffer, Message);
        LocalFree(Message);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\globals.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\globals.h

Abstract:

    Bunch of external declarations

Revision History:

    AmritanR    Created

--*/

#pragma once

extern CRITICAL_SECTION g_ifLock;
extern CRITICAL_SECTION g_ipNetLock;
extern CRITICAL_SECTION g_tcpipLock;
extern CRITICAL_SECTION g_stateLock;


extern HANDLE      g_hPrivateHeap;
extern HANDLE      g_hTCPDriverGetHandle;
extern HANDLE      g_hTCP6DriverGetHandle;
extern HANDLE      g_hTCPDriverSetHandle;
extern HANDLE      g_hTCP6DriverSetHandle;
extern DWORD       g_dwTraceHandle;
extern LIST_ENTRY  g_pAdapterMappingTable[MAP_HASH_SIZE];
extern DWORD       g_dwLastIfUpdateTime;
extern PDWORD      g_pdwArpEntTable;
extern DWORD       g_dwNumArpEntEntries;
extern DWORD       g_dwLastArpUpdateTime;
extern DWORD       g_dwNumIf;
extern BOOL        g_bIpConfigured;
extern BOOL        g_bIp6Configured;

extern MIB_SERVER_HANDLE    g_hMIBServer;

extern HANDLE       g_hModule;

#ifdef CHICAGO
// Not needed currently only in stack.c
// extern HANDLE vnbt_device_handle;
// extern HANDLE dhcp_device_handle;
// extern HANDLE vtcp_device_handle;
#endif

#ifdef DBG

// used by TRACE_PRINT macro in ../common2/mdebug.h
extern int trace;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\guid.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\guid.h

Abstract:

    Header for guid.c

Revision History:

    AmritanR    Created

--*/

#ifndef __IPHLPAPI_GUID_H__
#define __IPHLPAPI_GUID_H__


DWORD
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszBuffer
    );

DWORD
ConvertStringToGuid(
    IN  PWCHAR  pwszGuid,
    IN  ULONG   ulStringLen,
    OUT GUID    *pGuid
    );

#endif // __IPHLPAPI_GUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\fltapis.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:


Abstract:
    Implementation of the packet filter control code

Revision History:

Author:
    Arnold Miller (ArnoldM)      24-Sept-1997
--*/

#ifndef CHICAGO         // don't need this on Memphis

#include "fltapis.hxx"

extern InterfaceContainer icContainer;

//
// The WIN32 APIs. These are wrappers to call the
// appropriate class methods.
//

PFAPIENTRY
PfCreateInterface(
        DWORD            dwName,
        PFFORWARD_ACTION inAction,
        PFFORWARD_ACTION outAction,
        BOOL             bUseLog,
        BOOL             bMustBeUnique,
        INTERFACE_HANDLE *ppInterface)
/*++
Routine Description:
   Create a new interface.

    dwName -- the interface name. A 0 means a new, unique interface. Any
              other value is a potentially shared interface. Note that
              the argument bMustBeUnique can turn a shared interface
              into a unique one. But by using that, this call can fail.
    inAction  -- default action for input frame.
    outAction -- default action for output frames
    bUseLog   -- If there is a log, bind it to this interface
    bMustBeUnique -- if TRUE, this interface cannot be shared
    ppInterface -- if successful, the interface handle to be used
                   on subsequent operations.
--*/
{
    return(icContainer.AddInterface(
              dwName,
              inAction,
              outAction,
              bUseLog,
              bMustBeUnique,
              ppInterface));
}

PFAPIENTRY
PfDeleteInterface(
      INTERFACE_HANDLE pInterface)
/*++
Routine Description:
  Delete an interface

   pInterface -- the interface handle gotten from PfCreateInterface
--*/
{
    return(icContainer.DeleteInterface(pInterface));
}

PFAPIENTRY
PfAddFiltersToInterface(INTERFACE_HANDLE   pInterface,
                        DWORD cInFilters,  PPF_FILTER_DESCRIPTOR pfiltIn,
                        DWORD cOutFilters, PPF_FILTER_DESCRIPTOR pfiltOut,
                        PFILTER_HANDLE  pfHandle OPTIONAL)
/*++
Routine Description:
  Add the described filters to the interface.
     cInFilters   --    number of input filters
     cOutFilters  --    number of output filters
     pfiltIn      --    array of input filters if any
     pfiltOut     --    array of output filters if any
     pfHandle     --    array to return filter handeles. 

--*/
{
    PacketFilterInterface * pif;
    DWORD err;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        err = pif->AddFilters(cInFilters, pfiltIn,
                              cOutFilters, pfiltOut,
                              pfHandle);
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfRemoveFiltersFromInterface(INTERFACE_HANDLE   pInterface,
                             DWORD cInFilters,  PPF_FILTER_DESCRIPTOR pfiltIn,
                             DWORD cOutFilters, PPF_FILTER_DESCRIPTOR pfiltOut)
/*++
Routine Description:
  Remove the described filters to the interface.
     cInFilters   --    number of input filters
     cOutFilters  --    number of output filters
     pfiltIn      --    array of input filters if any
     pfiltOut     --    array of output filters if any

--*/
{
    PacketFilterInterface * pif;
    DWORD err;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        err = pif->DeleteFiltersByFilter(cInFilters, pfiltIn,
                                         cOutFilters, pfiltOut);
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfRemoveFilterHandles(  INTERFACE_HANDLE   pInterface,
                        DWORD cFilters,  PFILTER_HANDLE pvHandles)
/*++
Routine Description:
  Add the described filters to the interface.
     cFilters   --    number of filter handles provided. These
                      are obtained from the PfAddFiltersToInterface call
     pvHandles  --    array of handles

--*/
{
    PacketFilterInterface * pif;
    DWORD err;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        err = pif->DeleteFiltersByHandle(cFilters, pvHandles);
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfAddGlobalFilterToInterface(INTERFACE_HANDLE   pInterface,
                             GLOBAL_FILTER      gfFilter)
/*++
Routine Description:
   Put a global filter on the specified interface
--*/
{
    PacketFilterInterface * pif;
    DWORD err;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        err = pif->AddGlobalFilter(gfFilter);
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfRemoveGlobalFilterFromInterface(INTERFACE_HANDLE   pInterface,
                                  GLOBAL_FILTER      gfFilter)
/*++
Routine Description:
   Remove the specified global filter from the interface
--*/
{
    PacketFilterInterface * pif;
    DWORD err;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        err = pif->DeleteGlobalFilter(gfFilter);
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfUnBindInterface(INTERFACE_HANDLE   pInterface)
/*++
Routine Description:
  Unbound a bound interface.
--*/
{
    PacketFilterInterface * pif;
    DWORD err;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        err = pif->UnBindInterface();
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfBindInterfaceToIndex(INTERFACE_HANDLE   pInterface,
                       DWORD dwIndex,
                       PFADDRESSTYPE pfatLinkType,
                       PBYTE LinkIPAddress)
/*++
Routine Description:
  Bind an interface to the given IP stack index
--*/
{
    PacketFilterInterface * pif;
    DWORD err;
    DWORD LinkAddress; 


    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        if (ValidateIndex(dwIndex))
        {
            __try 
            {
                LinkAddress = *(PDWORD)LinkIPAddress;
                
            }
            __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
            {
                err = ERROR_INVALID_PARAMETER;
            }
            
            if ((err == ERROR_SUCCESS) && 
                (LinkAddress && (pfatLinkType != PF_IPV4)))
            {
                err =  ERROR_INVALID_PARAMETER;
            }

            if (err == ERROR_SUCCESS) 
            {
                err = pif->BindByIndex(dwIndex, LinkAddress);
            }
        }
        else
        {
           err = ERROR_INVALID_PARAMETER;
        }
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfBindInterfaceToIPAddress(INTERFACE_HANDLE   pInterface,
                           PFADDRESSTYPE pfatType,
                           PBYTE IPAddress)
/*++
Routine Description:
  Bind an interface to the IP stack index having the given address
--*/
{
    PacketFilterInterface * pif;
    DWORD err = NO_ERROR;

    if(pfatType != PF_IPV4)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        __try
        {
            err = pif->BindByAddress(*(PDWORD)IPAddress);
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
        {
           err = ERROR_INVALID_PARAMETER;
        }
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfRebindFilters(INTERFACE_HANDLE    pInterface,
                PPF_LATEBIND_INFO   pLateBindInfo)
/*++
Routine Description:
   Rebind the filters on the given interface based on the rebind
   values in pfilt. What gets rebound depends on how the filter
   was created.
--*/
{
    PacketFilterInterface * pif;
    DWORD err = NO_ERROR;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        __try
        {
            err = pif->RebindFilters(pLateBindInfo);
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
        {
           err = ERROR_INVALID_PARAMETER;
        }

        icContainer.Deref();

    }
    return(err);
}

PFAPIENTRY
PfMakeLog( HANDLE hEvent )
/*++
Routine Description:
  Make a log to be used by the interfaces. Note well that
  once an interface exists, a log cannot be retroactively applied.
  At most one log may exist.
--*/
{
    DWORD err;

    err = icContainer.MakeLog( hEvent );
    return(err);
}

PFAPIENTRY
PfSetLogBuffer(
                PBYTE  pbBuffer,
                DWORD  dwSize,
                DWORD  dwThreshold,
                DWORD  dwEntries,
                PDWORD pdwLoggedEntries,
                PDWORD pdwLostEntries,
                PDWORD pdwSizeUsed)
/*++
Routine Description:
  Give a new log buffer to the log and get back the old one

  pbBuffer -- the new log buffer. Must be quad-word aligned
  dwSize   -- size of the buffer in bytes
  dwThreahold  -- number of bytes used before signalling the event
  dwEntries   -- number of entries that causes the signalling
  pdwLoggedEntries -- entires in the old buffer
  pdwLostEntries  -- entries that could not be put into the old buffer
  pdwSizeUsed    -- total size used in the old buffer

  The last three are returned values. If there is no old buffer, then
  what is returned is undefined.  Note this does not return
  the address of the old buffer. It is up to the caller to
  remember this. On success, the provided buffer is locked.
  Hence the caller should provide a buffer large enough to capture
  the traffic but so large as to be an impediment. A buffer of
  128K, used in a double-buffer scheme with another of that size,
  has proven to be quite adequate. In fact, a smaller buffer is
  likely to be sufficient.
  
--*/
{
    DWORD err;

    err = icContainer.SetLogBuffer(
                     pbBuffer,
                     dwSize,
                     dwThreshold,
                     dwEntries,
                     pdwLoggedEntries,
                     pdwLostEntries,
                     pdwSizeUsed);

    return(err);
}

PFAPIENTRY
PfGetInterfaceStatistics(
                INTERFACE_HANDLE    pInterface,
                PPF_INTERFACE_STATS ppfStats,
                PDWORD              pdwBufferSize,
                BOOL                fResetCounters)
/*++
Routine Description:
   Get statistics for an interface. There are two characteristic
   errors from this:

   ERROR_INSUFFICIENT_BUFFER -- the supplied user buffer is too
                                small for the filters. The correct
                                size is returned as is the
                                interface statistics which contains
                                the filter counts
   PFERROR_BUFFER_TOO_SMALL  -- the user buffer is too small
                                for even the interface statistics.
                                The returned size is the size of
                                the interface statistics but does
                                not include space for filters. So the
                                next call should get the first error.

   For now, ppfStatusV6 and pdwBufferSizeV6 MBZ. When IPV6
   is implemented, these will be allowed

--*/
{
    PacketFilterInterface * pif;
    DWORD err;

    err = icContainer.FindInterfaceAndRef(pInterface, &pif);

    if(err == ERROR_SUCCESS)
    {
        err = pif->GetStatistics(ppfStats,
                                 pdwBufferSize,
                                 fResetCounters);
        icContainer.Deref();
    }
    return(err);
}

PFAPIENTRY
PfDeleteLog()
/*++
Routine Description:
   Delete the log. Will remove it from all of the interfaces and
   diable it.
--*/
{
    return(icContainer.DeleteLog());
}

PFAPIENTRY
PfTestPacket( INTERFACE_HANDLE pInInterface,
              INTERFACE_HANDLE pOutInterface,
              DWORD            cBytes,
              PBYTE            pbPacket,
              PPFFORWARD_ACTION ppAction)
/*++
Routine Description:
  Given a packet and an interface, ask the driver what
  action it would take. If successful, return the
  action
--*/
{
    PacketFilterInterface * pifIn, *pifOut, *pif;
    DWORD err;

    if(pInInterface)
    {
        err = icContainer.FindInterfaceAndRef(pInInterface, &pifIn);
    }
    else
    {
        pifIn = 0;
        err = ERROR_SUCCESS;
    }

    if(err)
    {
       return(err);
    }

    pifOut = 0;
    if(pOutInterface)
    {
        err = icContainer.FindInterfaceAndRef(pOutInterface, &pifOut);
    }
    else
    {
        err = ERROR_SUCCESS;
    }

    if(!err && pifIn && (pifIn == pifOut))
    {
        //
        // the same interface is given for each. Can't be
        //

        err = ERROR_INVALID_PARAMETER;
    }

    if(err == ERROR_SUCCESS)
    {
        if(pifIn)
        {
           pif = pifIn;
        }
        else
        {
           pif = pifOut;
        }
        if(pif)
        {
            err =   pif->TestPacket(
                              pifIn,
                              pifOut,
                              cBytes,
                              pbPacket,
                              ppAction); 
        }
        else
        {
            *ppAction = PF_ACTION_FORWARD;
        }
    }
    if(pifIn)
    {
        icContainer.Deref();
    }
    if(pifOut)
    {
        icContainer.Deref();
    }
    return(err);
}

#endif     // CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\fltclass.cxx ===
/*++
                                           PDWORD * ppdwAddress*++

Copyright (c) 1997  Microsoft Corporation

Module Name:


Abstract:
    Implementation of the packet filter control code

Revision History:

Author:
    Arnold Miller (ArnoldM)      24-Sept-1997
--*/
#ifndef CHICAGO           // don't need these on Memphis

#include "fltapis.hxx"

//
// these care called from the DLL entry which is C code, so
// declare the names to be something the C compiler can
// generate
//

extern "C"
{
VOID
InitFilterApis();

VOID
UnInitFilterApis();

DWORD
AllocateAndGetIpAddrTableFromStack(
    OUT MIB_IPADDRTABLE   **ppIpAddrTable,
    IN  BOOL              bOrder,
    IN  HANDLE            hHeap,
    IN  DWORD             dwFlags
    );
}

InterfaceContainer icContainer;

//
// All of the class methods. If you're looking for the WIN32
// APIs, try the file fltapis.cxx
//

VOID
InterfaceContainer::InitInterfaceContainer()
{
    if(!_Inited)
    {
        _InitResource();
        __try {
            InitializeCriticalSection(&_csDriverLock);
            _Log = 0;
            _hDriver = 0;
            _Inited = TRUE;
        }

        __except (EXCEPTION_EXECUTE_HANDLER) {
            _DestroyResource();
            _Inited = FALSE;
        }
    }
}


DWORD
InterfaceContainer::FindInterfaceAndRef(INTERFACE_HANDLE pInterface,
                                        PacketFilterInterface ** ppif)
/*++
Routine Description:
   Verify that an INTERFACE_HANDLE refers to an extant filter interface.
   If successful the object resource is held shared and must be
   derefenced when done
--*/
{
    DWORD err;
    PacketFilterInterface * ppfInterface;
    PacketFilterInterface * plook = (PacketFilterInterface *)pInterface;

    //
    // No need for a _DriverReady here. The verification of the
    // interface is sufficient.
    //
    _AcquireShared();

    ppfInterface = (PacketFilterInterface *)_hcHandles.FetchHandleValue(
                                                  (DWORD)((DWORD_PTR)pInterface));
    if(ppfInterface)
    {
        *ppif = ppfInterface;
        err = ERROR_SUCCESS;
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }

    if(err != ERROR_SUCCESS)
    {
        _Release();
    }
    return(err);
}

DWORD
InterfaceContainer::AddInterface(
        DWORD          dwName,
        PFFORWARD_ACTION inAction,
        PFFORWARD_ACTION outAction,
        BOOL            fUseLog,
        BOOL            fMustBeUnique,
        INTERFACE_HANDLE *ppInterface)
/*++
Routine Description:
   Add a new interface. All this does is create the interface in
   the driver. It does not bind it to the stack.
--*/
{
    PacketFilterInterface *pfi;
    DWORD err = NO_ERROR;

    err = _DriverReady();
    if(err != STATUS_SUCCESS)
    {
        return(err);
    }

    _AcquireExclusive();

    pfi = new PacketFilterInterface(
                    _hDriver,
                    dwName,
                    fUseLog ? _Log : 0,
                    fMustBeUnique,
                    (FORWARD_ACTION)inAction,
                    (FORWARD_ACTION)outAction);

    if(!pfi)
    {
        err = GetLastError();
    }
    else if((err = pfi->GetStatus()) != STATUS_SUCCESS)
    {
        delete pfi;
    }
    else
    {
        __try
        {
           err = _hcHandles.NewHandle((PVOID)pfi,
                                       (PDWORD)ppInterface);
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
        {
           err = ERROR_INVALID_PARAMETER;
        }
        if(err)
        {
            //
            // Could not add the handle so destroy the interface
            //

            delete pfi;
        }
    }

    _Release();
    return(err);
}

DWORD
InterfaceContainer::DeleteInterface(INTERFACE_HANDLE pInterface)
/*++
Routine Description:
   Delete a filter interface.
--*/
{
    DWORD err;
    PacketFilterInterface *pfi;

    _AcquireExclusive();

    pfi = (PacketFilterInterface *)_hcHandles.FetchHandleValue(
                                                  (DWORD)((DWORD_PTR)pInterface));
    if(pfi)
    {
        //
        // a valid handle. Destroy the associated
        // interface and free the handle
        //
        delete pfi;
        (VOID)_hcHandles.DeleteHandle((DWORD)((DWORD_PTR)pInterface));
        err = ERROR_SUCCESS;
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }
    _Release();
    return(err);
}


DWORD
InterfaceContainer::SetLogBuffer(
                PBYTE pbBuffer,
                DWORD  dwSize,
                DWORD  dwThreshold,
                DWORD  dwEntries,
                PDWORD pdwLoggedEntries,
                PDWORD pdwLostEntries,
                PDWORD pdwSizeUsed)
/*++
  Routine Description:
    Set a new log buffer for the log
--*/
{
    NTSTATUS Status;
    PFSETBUFFER pfSet;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD err;

    //
    // Buffer size should be atleast as big as one frame. Actually,
    // we can't really say what the size of a frame is going to be
    // because the frame has IpHeader and the data which is bigger
    // than sizeof(PFLOGFRAME), nevertheless this is a good paramter
    // check if caller was passing a zero or something for the size.
    //

    if (dwSize < sizeof(PFLOGFRAME)) {
       return(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // Make sure that the starting address and the offset both are
    // quadword alligned.
    //

    if (!COUNT_IS_ALIGNED((UINT_PTR)pbBuffer, ALIGN_WORST) ||
        !COUNT_IS_ALIGNED(dwSize, ALIGN_WORST)
        )
    {
        return(ERROR_MAPPED_ALIGNMENT);
    }

    //
    // Check the upper bounds for threshold values (dwEntries and dwThreshold) 
    //

    if ( dwThreshold > dwSize ||
    	(dwEntries * sizeof(PFLOGFRAME)) > dwSize)
    	return (ERROR_INVALID_PARAMETER);

    //
    // Check the lower bounds for threshold values (dwEntries and dwThreshold) 
    //

    if ( dwThreshold < sizeof(PFLOGFRAME) )
    	return (ERROR_INVALID_PARAMETER);

    //
    // Make sure all the writable memory looks good.
    //

    if (
         IsBadWritePtr(pdwLoggedEntries, sizeof(DWORD)) ||
         IsBadWritePtr(pdwLostEntries, sizeof(DWORD))   ||
         IsBadWritePtr(pdwSizeUsed, sizeof(DWORD))      ||
         IsBadWritePtr(pbBuffer, dwSize)
       )
    {
        return(ERROR_INVALID_PARAMETER);
    }


    //
    // no need to call _DriverReady. If the log exists, the
    // driver is ready.
    //

    _AcquireExclusive();

    if(!_Log)
    {
        err =  ERROR_INVALID_HANDLE;
        goto Error;
    }

    pfSet.pfLogId = _Log;
    pfSet.dwSize = dwSize;
    pfSet.dwSizeThreshold = dwThreshold;
    pfSet.dwEntriesThreshold = dwEntries;
    pfSet.dwFlags = 0;
    pfSet.pbBaseOfLog = pbBuffer;
    Status = NtDeviceIoControlFile(  _hDriver,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_SET_LOG_BUFFER,
                                     (PVOID)&pfSet,
                                     sizeof(pfSet),
                                     (PVOID)&pfSet,
                                     sizeof(pfSet));
    if(NT_SUCCESS(Status))
    {
        *pdwLoggedEntries = pfSet.dwLoggedEntries;
        *pdwLostEntries = pfSet.dwLostEntries;
        *pdwSizeUsed = pfSet.dwSize;
        err = ERROR_SUCCESS;
    }
    else
    {
        err = CoerceDriverError(Status);
    }

Error:

    _Release();

    return(err);
}


DWORD
InterfaceContainer::MakeLog( HANDLE hEvent )
/*++
Routine Description:
   Make a log for this
--*/
{
    DWORD err;
    PFLOG pfSet;
    NTSTATUS Status;
    IO_STATUS_BLOCK ioStatus;

    err = _DriverReady();
    if(err != STATUS_SUCCESS)
    {
        return(err);
    }

    _AcquireExclusive();

    if(_Log)
    {
        err = ERROR_ALREADY_ASSIGNED;
    }
    else
    {
        memset(&pfSet, 0, sizeof(pfSet));

        pfSet.hEvent = hEvent;
        pfSet.dwFlags = 0;

        Status = NtDeviceIoControlFile(
                                     _hDriver,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &ioStatus,
                                     IOCTL_PF_CREATE_LOG,
                                     (PVOID)&pfSet,
                                     sizeof(pfSet),
                                     (PVOID)&pfSet,
                                     sizeof(pfSet));

        if(NT_SUCCESS(Status))
        {
            _Log = pfSet.pfLogId;
        }
        else
        {
            err = CoerceDriverError(Status);
        }
    }
    _Release();
    return(err);
}

DWORD
InterfaceContainer::DeleteLog( VOID )
/*++
Routine Description:
   Delete the log and by implication remove the log from all
   of the interfaces
--*/
{
    DWORD err = ERROR_SUCCESS;
    PFDELETELOG pfSet;
    NTSTATUS Status;
    IO_STATUS_BLOCK ioStatus;

    _AcquireExclusive();

    if(!_Log)
    {
        err = ERROR_INVALID_HANDLE;
    }
    else
    {

        pfSet.pfLogId = _Log;

        Status = NtDeviceIoControlFile(
                                     _hDriver,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &ioStatus,
                                     IOCTL_PF_DELETE_LOG,
                                     (PVOID)&pfSet,
                                     sizeof(pfSet),
                                     (PVOID)&pfSet,
                                     sizeof(pfSet));

        if(NT_SUCCESS(Status))
        {
            _Log = 0;
        }
        else
        {
            err = CoerceDriverError(Status);
        }
    }
    _Release();
    return(err);
}

VOID
InterfaceContainer::AddressUpdateNotification()
{
}

//
// The PacketFilterInterface methods.
//

PacketFilterInterface::PacketFilterInterface(
            HANDLE  hDriver,
            DWORD   dwName,
            PFLOGGER pfLog,
            BOOL     fMustBeUnique,
            FORWARD_ACTION inAction,
            FORWARD_ACTION outAction)
/*++
Routine Description:
   Constructor for a new interface. If this interface must
   be unique, then dwName should be 0. Otherwise pick
   a name that can be associated with other uses, such as the
   IP address of the interface or some manifest. This assumes
   the creater of this will check the status code and destruct
   the object if it is not successful. This is important since
   the other methods do not check for successful construction.
--*/
{
    PFINTERFACEPARAMETERS Parms;
    DWORD dwInBufLen = sizeof(Parms);
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    InitializeCriticalSection(&_cs);
    _hDriver = hDriver;
    _dwFlags = 0;

    //
    // now create the interface.
    //

    memset(&Parms, 0, sizeof(Parms));

    Parms.pfbType = PF_BIND_NAME;
    Parms.eaIn = inAction;
    Parms.eaOut = outAction;
    Parms.dwBindingData = dwName;
    Parms.fdInterface.dwIfIndex = dwName;
    Parms.fdInterface.pvRtrMgrContext = UlongToPtr(dwName);
    Parms.pfLogId = pfLog;
    if(fMustBeUnique)
    {
        //
        // this is a non-sharable interface. Mark it as such
        //
        Parms.dwInterfaceFlags |= PFSET_FLAGS_UNIQUE;
    }

    Status = NtDeviceIoControlFile(_hDriver,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_PF_CREATE_AND_SET_INTERFACE_PARAMETERS,
                                   (PVOID)&Parms,
                                   dwInBufLen,
                                   (PVOID)&Parms,
                                   dwInBufLen);


    if(NT_SUCCESS(Status))
    {
        _err = ERROR_SUCCESS;
        _pvDriverContext = Parms.fdInterface.pvDriverContext;
    }
    else
    {
        _err = icContainer.CoerceDriverError(Status);
    }
}

PacketFilterInterface::~PacketFilterInterface()
/*++
Routine Description:
   Destructor. Tells the filter driver to forget this interface. Any
   filters will be removed by the driver.
--*/
{
    if(!_err)
    {
        IO_STATUS_BLOCK IoStatusBlock;
        FILTER_DRIVER_DELETE_INTERFACE di;

        di.pvDriverContext = _pvDriverContext;

        NtDeviceIoControlFile(_hDriver,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              IOCTL_DELETE_INTERFACEEX,
                              (PVOID)&di,
                              sizeof(di),
                              (PVOID)&di,
                              sizeof(di));
    }
    DeleteCriticalSection(&_cs);
}

DWORD
PacketFilterInterface::_CommonBind(PFBINDINGTYPE dwBindType, DWORD dwData, DWORD LinkData)
/*++
Routine Description:
   Common routine to bind an interface. The driver has
   been verified.
--*/
{
    INTERFACEBINDING2 Bind2;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    DWORD err;

    //
    // Must serialize this. Even though the shared resource is held,
    // this is a "write" operation and therfore needs strict
    // serialization.
    //
    _Lock();
    if(_IsBound())
    {
        _UnLock();
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // We're not bound.
    // Note that we are using new type of struture for the compitability.
    // The old INTERFACEBINDING structure does not have support for
    // link addresses. Note also that we are using a new IOCTL here.
    //

    Bind2.pvDriverContext = _pvDriverContext;
    Bind2.pfType = dwBindType;
    Bind2.dwAdd = dwData;
    Bind2.dwLinkAdd = LinkData;


    Status = NtDeviceIoControlFile(_hDriver,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_SET_INTERFACE_BINDING2,
                                   (PVOID)&Bind2,
                                   sizeof(Bind2),
                                   (PVOID)&Bind2,
                                   sizeof(Bind2));

    if(NT_SUCCESS(Status))
    {
        _SetBound();
        err = ERROR_SUCCESS;
        _dwEpoch = Bind2.dwEpoch;
    }
    else
    {
        err = icContainer.CoerceDriverError(Status);
    }
    _UnLock();
    return(err);
}

DWORD
PacketFilterInterface::UnBindInterface( VOID )
/*++
Routine Description:
  Unbind the interface from whatever it is bound to
--*/
{
    INTERFACEBINDING Bind;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    DWORD err;

    //
    // Must serialize this. Even though the shared resource is held,
    // this is a "write" operation and therfore needs strict
    // serialization.
    //
    _Lock();
    if(!_IsBound())
    {
        _UnLock();
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // We're address bound. So unbind from the stack
    //

    Bind.pvDriverContext = _pvDriverContext;
    Bind.dwEpoch = _dwEpoch;

   Status = NtDeviceIoControlFile(_hDriver,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  IOCTL_CLEAR_INTERFACE_BINDING,
                                  (PVOID)&Bind,
                                  sizeof(Bind),
                                  (PVOID)&Bind,
                                  sizeof(Bind));

    if(NT_SUCCESS(Status))
    {
        _ClearBound();
        err = STATUS_SUCCESS;
    }
    else
    {
        err = icContainer.CoerceDriverError(Status);
    }
    _UnLock();
    return(err);
}

DWORD
PacketFilterInterface::AddGlobalFilter(GLOBAL_FILTER gf)
/*++
Routine Description:
   Add the specified global filter to the interface
--*/
{
    PF_FILTER_DESCRIPTOR fd;
    DWORD err;
    FILTER_HANDLE fh;

    memset(&fd, 0, sizeof(fd));

    switch(gf)
    {
         default:
              //
              // fall through ...
              //
         case GF_FRAGCACHE:
         case GF_FRAGMENTS:
         case GF_STRONGHOST:
             err = _AddFilters((PFETYPE)gf, 1, &fd, 0, 0, &fh);
             break;
    }
    return(err);
}

DWORD
PacketFilterInterface::DeleteGlobalFilter(GLOBAL_FILTER gf)
/*++
Routine Descriptor:
   Remove a global filter from this interface
--*/
{
    PF_FILTER_DESCRIPTOR fd;
    DWORD err;
    FILTER_HANDLE fh;

    memset(&fd, 0, sizeof(fd));

    switch(gf)
    {
         default:
              //
              // fall through ...
              //
         case GF_FRAGCACHE:
         case GF_FRAGMENTS:
         case GF_STRONGHOST:
             err = _DeleteFiltersByFilter((PFETYPE)gf, 1, &fd, 0, 0);
             break;
    }

    return(err);
}

DWORD
PacketFilterInterface::DeleteFiltersByHandle(DWORD cHandles,
                                             PFILTER_HANDLE pvHandles)
/*++
Routine Description:
   Remove filters by handles returned when the filters were created
--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    DWORD dwSize = sizeof(PFDELETEBYHANDLE) - sizeof(PVOID) +
                   (sizeof(PVOID) * cHandles);
    PPFDELETEBYHANDLE pDelHandle;
    DWORD err = NO_ERROR;

    pDelHandle = (PPFDELETEBYHANDLE)new PBYTE[dwSize];

    if(!pDelHandle)
    {
        return(GetLastError());
    }

    pDelHandle->pvDriverContext = _pvDriverContext;

    __try
    {

       memcpy(&pDelHandle->pvHandles[0],
              pvHandles,
              cHandles * sizeof(PVOID));
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
    {
       err = ERROR_INVALID_PARAMETER;
       delete pDelHandle;
       return(err);
    }


    Status = NtDeviceIoControlFile(_hDriver,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_PF_DELETE_BY_HANDLE,
                                    (PVOID)pDelHandle,
                                    dwSize,
                                    0,
                                    0);

    delete pDelHandle;

    if(NT_SUCCESS(Status))
    {
        err = ERROR_SUCCESS;
    }
    else
    {
        err = icContainer.CoerceDriverError(Status);
    }

    return(err);
}

PFILTER_DRIVER_SET_FILTERS
PacketFilterInterface::_SetFilterBlock(
                                PFETYPE pfe,
                                DWORD cInFilters,  PPF_FILTER_DESCRIPTOR pfiltIn,
                                DWORD cOutFilters, PPF_FILTER_DESCRIPTOR pfiltOut,
                                PDWORD pdwSize,
                                PFILTER_DESCRIPTOR2 * ppfdIn,
                                PFILTER_DESCRIPTOR2 * ppfdOut)
/*++
Routine Description:
   Private method to allocate and construct an argument block for
   setting or deleting filters. This is the heart of this code
   as it forms the data structure used for creating filters
   and for removing filters by descriptor.
--*/
{
    PFILTER_DRIVER_SET_FILTERS pSet;
    DWORD  dwSetSize, dwInInfoSize, dwOutInfoSize;
    DWORD  dwOutFilters, dwInFilters;
    PRTR_INFO_BLOCK_HEADER pIo;
    PFILTER_DESCRIPTOR2 p2;
    DWORD err = ERROR_SUCCESS;

    //
    // compute the memory size needed.
    //

    dwSetSize = sizeof(FILTER_DRIVER_SET_FILTERS) +
                sizeof(RTR_INFO_BLOCK_HEADER) +
                (ALIGN_SIZE - 1) +   // worst case alignment padding
                (2 * sizeof(FILTER_DESCRIPTOR2));

    if(cInFilters)
    {
        dwInFilters = cInFilters;
        dwInInfoSize = sizeof(FILTER_INFOEX) * dwInFilters;
        dwSetSize += dwInInfoSize;
        dwInInfoSize += sizeof(FILTER_DESCRIPTOR2);

    }
    else
    {
        dwInInfoSize = sizeof(FILTER_DESCRIPTOR2);
        dwInFilters = 0;
    }

    if(cOutFilters)
    {
        dwOutFilters = cOutFilters;
        dwOutInfoSize = sizeof(FILTER_INFOEX) * dwOutFilters;
        dwSetSize += dwOutInfoSize;
        dwOutInfoSize += sizeof(FILTER_DESCRIPTOR2);
    }
    else
    {
        dwOutFilters = 0;
        dwOutInfoSize = sizeof(FILTER_DESCRIPTOR2);
    }


    if(dwSetSize == (sizeof(FILTER_DRIVER_SET_FILTERS) +
                     sizeof(RTR_INFO_BLOCK_HEADER) +
                     (2 * sizeof(FILTER_DESCRIPTOR2))) )
    {
        SetLastError(PFERROR_NO_FILTERS_GIVEN);
        return(NULL);
    }

    pSet = (PFILTER_DRIVER_SET_FILTERS)new PBYTE[dwSetSize];

    if(pSet)
    {
        *pdwSize = dwSetSize;

        //
        // create the argument block
        //

        pSet->pvDriverContext = _pvDriverContext;
        pIo = &pSet->ribhInfoBlock;
        pIo->Version = RTR_INFO_BLOCK_VERSION;
        pIo->Size = dwSetSize;
        pIo->TocEntriesCount = 2;       // always two of these.

        //
        // create the ouput filter TOC first. No particular reason,
        // but one of them has to be first
        //


        pIo->TocEntry[0].InfoType = IP_FILTER_DRIVER_OUT_FILTER_INFO;

        pIo->TocEntry[0].InfoSize = dwOutInfoSize;

        pIo->TocEntry[0].Count = 1;

        //
        // the filters go after the header and TOCs
        //
        pIo->TocEntry[0].Offset = sizeof(RTR_INFO_BLOCK_HEADER) +
                                  sizeof(RTR_TOC_ENTRY);
        ALIGN_LENGTH(pIo->TocEntry[0].Offset);

        //
        // make the FILTER_DESCRIPTOR2 values
        //

        p2 = (PFILTER_DESCRIPTOR2)((PBYTE)pIo + pIo->TocEntry[0].Offset);
        *ppfdOut = p2;
        p2->dwVersion = 2;
        p2->dwNumFilters = dwOutFilters;

        while(cOutFilters--)
        {
            //
            // marshall each filter into the block
            //

            err = _MarshallFilter(pfe, pfiltOut++, &p2->fiFilter[cOutFilters]);


            if(err)
            {
                goto OuttaHere;
            }
        }

        //
        // now the input filters
        //

        pIo->TocEntry[1].InfoType = IP_FILTER_DRIVER_IN_FILTER_INFO;

        pIo->TocEntry[1].InfoSize = dwInInfoSize;

        pIo->TocEntry[1].Count = 1;

        //
        // the filters go after the header and TOCs
        //
        pIo->TocEntry[1].Offset = pIo->TocEntry[0].Offset +
                                  dwOutInfoSize;

        p2 = (PFILTER_DESCRIPTOR2)((PBYTE)pIo + pIo->TocEntry[1].Offset);
        *ppfdIn = p2;
        p2->dwVersion = 2;
        p2->dwNumFilters = dwInFilters;

        while(cInFilters--)
        {
            //
            // marshall each filter into the block
            //

            err = _MarshallFilter(pfe, pfiltIn++, &p2->fiFilter[cInFilters]);
            if(err)
            {
                break;
            }
        }
    }

OuttaHere:
    if(err && pSet)
    {
        delete pSet;
        pSet = 0;
        SetLastError(err);
    }
    return(pSet);
}

DWORD
PacketFilterInterface::_MarshallFilter(
                        PFETYPE pfe,
                        PPF_FILTER_DESCRIPTOR pFilt,
                        PFILTER_INFOEX     pInfo)
/*++
RoutineDescription:
  Converts an API version of a filter into a driver version
--*/
{
    DWORD err = NO_ERROR;

    __try
    {

        pInfo->type = pfe;
        pInfo->dwFlags = (pFilt->dwFilterFlags & FD_FLAGS_ALLFLAGS) |
                        FLAGS_INFOEX_ALLOWDUPS                |
                        FLAGS_INFOEX_ALLOWANYREMOTEADDRESS    |
                        FLAGS_INFOEX_ALLOWANYLOCALADDRESS;

        pInfo->info.addrType = IPV4;
        pInfo->dwFilterRule = pFilt->dwRule;
        pInfo->info.dwProtocol = pFilt->dwProtocol;
        pInfo->info.fLateBound = pFilt->fLateBound;
        pInfo->info.wSrcPort = pFilt->wSrcPort;
        pInfo->info.wDstPort = pFilt->wDstPort;
        pInfo->info.wSrcPortHigh = pFilt->wSrcPortHighRange;
        pInfo->info.wDstPortHigh = pFilt->wDstPortHighRange;

        if ((pfe == PFE_SYNORFRAG) || (pfe == PFE_STRONGHOST) || (pfe == PFE_FRAGCACHE)) {
            pInfo->info.dwaSrcAddr[0] = 0;
            pInfo->info.dwaSrcMask[0] = 0;

            pInfo->info.dwaDstAddr[0] = 0;
            pInfo->info.dwaDstMask[0] = 0;
            return(ERROR_SUCCESS);
        }

        //
        // mow the addresses
        //

        pInfo->info.dwaSrcAddr[0] = *(PDWORD)pFilt->SrcAddr;
        pInfo->info.dwaSrcMask[0] = *(PDWORD)pFilt->SrcMask;

        pInfo->info.dwaDstAddr[0] = *(PDWORD)pFilt->DstAddr;
        pInfo->info.dwaDstMask[0] = *(PDWORD)pFilt->DstMask;
        err = ERROR_SUCCESS;
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
    {
        err = ERROR_INVALID_PARAMETER;
    }

    return(err);
}


DWORD
PacketFilterInterface::_AddFilters(
                                PFETYPE pfe,
                                DWORD cInFilters,  PPF_FILTER_DESCRIPTOR pfiltIn,
                                DWORD cOutFilters, PPF_FILTER_DESCRIPTOR pfiltOut,
                                PFILTER_HANDLE  pfHandle)
/*++
Routine Description:
   Private member function to add filters to an interface.
--*/
{
    PFILTER_DRIVER_SET_FILTERS pSet;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    DWORD dwSize, err;
    PFILTER_DESCRIPTOR2 pfdInput, pfdOutput;

    //
    // Check the handles before using them, if the memory supplied is
    // not accessible, we will save the trouble of calling the IOCTL.
    //

    if (pfHandle) {
       if (IsBadWritePtr(
               pfHandle,
               sizeof(FILTER_HANDLE)*(cInFilters+cOutFilters)
               )
          ) {
          return(ERROR_INVALID_PARAMETER);
       }
    }

    pSet = _SetFilterBlock(pfe,
                            cInFilters,
                            pfiltIn,
                            cOutFilters,
                            pfiltOut,
                            &dwSize,
                            &pfdInput,
                            &pfdOutput);
    if(!pSet)
    {
        return(GetLastError());
    }

    //
    // ready to apply the filters.
    //

    Status = NtDeviceIoControlFile(_hDriver,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_SET_INTERFACE_FILTERS_EX,
                                   (PVOID)pSet,
                                   dwSize,
                                   (PVOID)pSet,
                                   dwSize);

    if(NT_SUCCESS(Status))
    {
        //
        // did it. If the caller wants the generated handles
        // copy them before freeing the buffer
        //

        if(pfHandle)
        {
            _CopyFilterHandles(pfdInput, pfdOutput, pfHandle);
        }

        err = ERROR_SUCCESS;
    }
    else
    {
        err = icContainer.CoerceDriverError(Status);
    }

    _FreeSetBlock(pSet);
    return(err);
}

DWORD
PacketFilterInterface::_DeleteFiltersByFilter(PFETYPE pfe,
                       DWORD cInFilters,  PPF_FILTER_DESCRIPTOR pfiltIn,
                       DWORD cOutFilters, PPF_FILTER_DESCRIPTOR pfiltOut)
/*++
Routine Description:
   Private method to delete filters using filter descriptors
   instead of handles. Very slow.
--*/
{
    PFILTER_DRIVER_SET_FILTERS pSet;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    DWORD dwSize, err;
    PFILTER_DESCRIPTOR2 pfdInput, pfdOutput;

    pSet = _SetFilterBlock(pfe,
                            cInFilters,
                            pfiltIn,
                            cOutFilters,
                            pfiltOut,
                            &dwSize,
                            &pfdInput,
                            &pfdOutput);
    if(!pSet)
    {
        return(GetLastError());
    }

    //
    // ready to apply the filters.
    //

    Status = NtDeviceIoControlFile(_hDriver,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_DELETE_INTERFACE_FILTERS_EX,
                                   (PVOID)pSet,
                                   dwSize,
                                   (PVOID)pSet,
                                   dwSize);

    if(NT_SUCCESS(Status))
    {
        err = ERROR_SUCCESS;
    }
    else
    {
        err = icContainer.CoerceDriverError(Status);
    }
    _FreeSetBlock(pSet);
    return(err);
}


VOID
PacketFilterInterface::_CopyFilterHandles(PFILTER_DESCRIPTOR2 pfd1,
                   PFILTER_DESCRIPTOR2 pfd2,
                   PFILTER_HANDLE  pfHandle)
/*++
Routine Description
   Copy the generated filter handles from the pSet to the pfHandle.
   Called after successfully setting filters.
--*/
{
    DWORD dwFilters;

    for(dwFilters = pfd1->dwNumFilters; dwFilters;)
    {
        *pfHandle++ = pfd1->fiFilter[--dwFilters].pvFilterHandle;
    }

    for(dwFilters = pfd2->dwNumFilters; dwFilters;)
    {
        *pfHandle++ = pfd2->fiFilter[--dwFilters].pvFilterHandle;
    }
}

DWORD
PacketFilterInterface::RebindFilters(PPF_LATEBIND_INFO   pLateBindInfo)
/*++
Routine Description:
   Public method to adjust filter values for switched interface
--*/
{
    FILTER_DRIVER_BINDING_INFO Info;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    _Lock();          // serialize this

    Info.pvDriverContext = _pvDriverContext;

    Info.dwLocalAddr  = *(PDWORD)pLateBindInfo->SrcAddr;
    Info.dwRemoteAddr = *(PDWORD)pLateBindInfo->DstAddr;
    Info.dwMask       = *(PDWORD)pLateBindInfo->Mask;


    Status = NtDeviceIoControlFile(_hDriver,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_SET_LATE_BOUND_FILTERSEX,
                                    (PVOID)&Info,
                                    sizeof(Info),
                                    (PVOID)&Info,
                                    sizeof(Info));

    _UnLock();

    if(NT_SUCCESS(Status))
    {
        return(ERROR_SUCCESS);
    }

    return(icContainer.CoerceDriverError(Status));
}

DWORD
PacketFilterInterface::TestPacket(
                                  PacketFilterInterface * pInInterface,
                                  PacketFilterInterface * pOutInterface,
                                  DWORD cBytes,
                                  PBYTE pbPacket,
                                  PPFFORWARD_ACTION ppAction)
/*++
Routine Description:
  Public method to do a test packet operation. Note this is just
  passed to any interface.
--*/
{
    PFILTER_DRIVER_TEST_PACKET Packet;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    DWORD err, dwSize;

    if (cBytes > MAXUSHORT)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Get some data.
    //

    Packet = (PFILTER_DRIVER_TEST_PACKET) new BYTE[cBytes +
                      sizeof(FILTER_DRIVER_TEST_PACKET) - 1];

    if(!Packet)
    {
        return(GetLastError());
    }

    if(pInInterface)
    {
        Packet->pvInInterfaceContext = pInInterface->GetDriverContext();
    }
    else
    {
        Packet->pvInInterfaceContext = 0;
    }

    if(pOutInterface)
    {
        Packet->pvOutInterfaceContext = pOutInterface->GetDriverContext();
    }
    else
    {
        Packet->pvOutInterfaceContext = 0;
    }

    __try
    {
        memcpy(Packet->bIpPacket, pbPacket, cBytes);
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
    {
       delete Packet;
       return(ERROR_INVALID_PARAMETER);
    }

    dwSize = cBytes + FIELD_OFFSET(FILTER_DRIVER_TEST_PACKET, bIpPacket[0]);

    Status = NtDeviceIoControlFile(_hDriver,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_TEST_PACKET,
                                    (PVOID)Packet,
                                    dwSize,
                                    (PVOID)Packet,
                                    dwSize);


    if(NT_SUCCESS(Status))
    {
        *ppAction = (PFFORWARD_ACTION)Packet->eaResult;
        err = ERROR_SUCCESS;
    }
    else
    {
        err = icContainer.CoerceDriverError(Status);
    }

    delete Packet;

    return(err);
}


DWORD
PacketFilterInterface::GetStatistics(
                PPF_INTERFACE_STATS ppfStats,
                PDWORD              pdwBufferSize,
                BOOL                fResetCounters)
/*++
Routine Description:
   Get the interface statistics, including information on
   the filters. Because the WIN32 form of this differs
   from the underlying form, this code must allocate
   memory to use to store the driver's version of this and
   then marshall the results in the user's buffer.
--*/
{
    PBYTE pbBuffer = NULL;
    PPFGETINTERFACEPARAMETERS pfGetip;
    DWORD dwipSize, err = NO_ERROR;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    __try
    {
       if(*pdwBufferSize < _IfBaseSize())
       {
           //
           // the caller must supply at least this much.
           //
           *pdwBufferSize = _IfBaseSize();
           err = PFERROR_BUFFER_TOO_SMALL;
       }
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
    {
       err = ERROR_INVALID_PARAMETER;
    }

    if (err != NO_ERROR)
    {
       goto Cleanup;
    }



    dwipSize = _IpSizeFromifSize(*pdwBufferSize);

    pbBuffer = new BYTE[dwipSize];
    if(!pbBuffer)
    {
        return(GetLastError());
    }

    //
    // make the arguments
    //

    pfGetip = (PPFGETINTERFACEPARAMETERS)pbBuffer;
    pfGetip->dwReserved = dwipSize;

    pfGetip->pvDriverContext = _pvDriverContext;

    pfGetip->dwFlags = GET_FLAGS_FILTERS;

    if(fResetCounters)
    {
        pfGetip->dwFlags |= GET_FLAGS_RESET;
    }

    Status = NtDeviceIoControlFile(_hDriver,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_PF_GET_INTERFACE_PARAMETERS,
                                    (PVOID)pfGetip,
                                    dwipSize,
                                    (PVOID)pfGetip,
                                    dwipSize);

    if(!NT_SUCCESS(Status))
    {
        err = icContainer.CoerceDriverError(Status);
    }
    else if(pfGetip->dwReserved !=  dwipSize)
    {
        //
        // Here when the user buffer is insufficient. Compute
        // the size needed and return the characteristic error.
        // Always return the common statistics
        //

        __try
        {
            _MarshallCommonStats(ppfStats, pfGetip);
        }
        __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
        {
           err = ERROR_INVALID_PARAMETER;
        }

        *pdwBufferSize = _IfSizeFromipSize((ULONG)pfGetip->dwReserved);
        err = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        DWORD i, dwFiltersReturned;
        PDWORD pdwAddressOffset;

        //
        // got some data. Need to marshall the result into
        // the user's buffer do the easy part
        //

        __try
        {

           _MarshallCommonStats(ppfStats, pfGetip);

           //
           // Get the number of filters returned
           //

           dwFiltersReturned = pfGetip->dwNumInFilters +
                                 pfGetip->dwNumOutFilters;


           pdwAddressOffset = (PDWORD)((PBYTE)ppfStats +
                                   _IfBaseSize() +
                                   (sizeof(PF_FILTER_STATS) *
                                     dwFiltersReturned));
           //
           // marshall each filter back to the user.
           //

           for(i = 0; i < dwFiltersReturned; i++)
           {
              _MarshallStatFilter(&pfGetip->FilterInfo[i],
                                  &ppfStats->FilterInfo[i],
                                  &pdwAddressOffset);
           }
        }
        __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
        {
           err = ERROR_INVALID_PARAMETER;
        }
    }

Cleanup:

    if (pbBuffer) delete pbBuffer;
    return(err);
}

VOID
PacketFilterInterface::_MarshallStatFilter(PFILTER_STATS_EX pstat,
                                           PPF_FILTER_STATS  pfstats,
                                           PDWORD * ppdwAddress)
/*++
Routine Description:
   Private method to marshall a driver supplied filter stats to
   an API form of it.
--*/
{
    PDWORD pdwSpace = *ppdwAddress;

    pfstats->dwNumPacketsFiltered = pstat->dwNumPacketsFiltered;
    pfstats->info.dwFilterFlags = 0;
    pfstats->info.dwRule = pstat->info.dwFilterRule;
    pfstats->info.pfatType = PF_IPV4;

    pfstats->info.dwProtocol = pstat->info.info.dwProtocol;
    pfstats->info.fLateBound = pstat->info.info.fLateBound;
    pfstats->info.wSrcPort = pstat->info.info.wSrcPort;
    pfstats->info.wDstPort = pstat->info.info.wDstPort;
    pfstats->info.wSrcPortHighRange = pstat->info.info.wSrcPortHigh;
    pfstats->info.wDstPortHighRange = pstat->info.info.wDstPortHigh;
    pfstats->info.SrcAddr = (PBYTE)pdwSpace;
    *pdwSpace++ = pstat->info.info.dwaSrcAddr[0];
    pfstats->info.SrcMask = (PBYTE)pdwSpace;
    *pdwSpace++ = pstat->info.info.dwaSrcMask[0];
    pfstats->info.DstAddr = (PBYTE)pdwSpace;
    *pdwSpace++ = pstat->info.info.dwaDstAddr[0];
    pfstats->info.DstMask = (PBYTE)pdwSpace;
    *pdwSpace++ = pstat->info.info.dwaDstMask[0];
    *ppdwAddress = pdwSpace;

}

VOID
InitFilterApis()
{
    icContainer.InitInterfaceContainer();
}

VOID
UnInitFilterApis()
{
    icContainer.UnInitInterfaceContainer();
}

DWORD StartIpFilterDriver(VOID)
{
    SC_HANDLE   schSCManager;
    SC_HANDLE   schService;
    DWORD       dwErr = NO_ERROR;
    BOOL        bSuccess;
    TCHAR       *DriverName = TEXT("IPFILTERDRIVER");

    schSCManager =
        OpenSCManager(
            NULL,                 // machine (NULL == local)
            NULL,                 // database (NULL == default)
            SC_MANAGER_ALL_ACCESS // access required
            );

    if (!schSCManager) {
        return(GetLastError());

    }

    schService =
        OpenService(
            schSCManager,
            DriverName,
            SERVICE_ALL_ACCESS
            );
    if (!schService) {
       CloseServiceHandle(schSCManager);
       return(GetLastError());
    }

    bSuccess =
        StartService(
            schService,
            0,
            NULL
            );


   CloseServiceHandle(schService);
   CloseServiceHandle(schSCManager);


   if (!bSuccess) {
      dwErr = GetLastError();
      if (dwErr == ERROR_SERVICE_ALREADY_RUNNING) {
         return(NO_ERROR);

      }
   }

   return(dwErr);

 }

BOOL
ValidateIndex(DWORD dwIndex)
{
    DWORD i, err;
    PMIB_IPADDRTABLE    pTable;

    err = AllocateAndGetIpAddrTableFromStack(&pTable,
                                             FALSE,
                                             GetProcessHeap(),
                                             0);

    if (err != NO_ERROR) {
        return FALSE;
    }

    for (i = 0; i < pTable->dwNumEntries; i++) {
        if (pTable->table[i].dwIndex == dwIndex) {

            HeapFree(GetProcessHeap(),
                     0,
                     pTable);

            return TRUE;
        }
    }

    HeapFree(GetProcessHeap(),
             0,
             pTable);

    return FALSE;
}

#endif          // CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\guid.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\guid.c

Abstract:

    Cut-n-Paste of rtl\guid.c but without UNICODE_STRINGs

Revision History:

    AmritanR    Created

--*/

#include "inc.h"
#pragma hdrstop

#define GUID_FORMAT_W   L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"

int
__cdecl
ScanHexFormat(
    IN const WCHAR* pwszBuffer,
    IN ULONG        ulCharCount,
    IN const WCHAR* pwszFormat,
    ...
    )

/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    pwszBuffer  Source buffer which is to be scanned.

    ulCharCount Maximum length in characters for which Buffer is searched.
                This implies that Buffer need not be UNICODE_NULL terminated.

    Format      Format string which defines both the acceptable string form as
                contained in pwszBuffer


Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     iFormatItems;

    va_start(ArgList, pwszFormat);

    //
    // Count of number of parameters filled
    //

    iFormatItems = 0;

    while(TRUE)
    {
        switch (*pwszFormat) 
        {
            case UNICODE_NULL:
            {
                //
                // end of string
                //

                return (*pwszBuffer && ulCharCount) ? -1 : iFormatItems;
            }

            case L'%':
            {
                //
                // Format specifier
                //

                pwszFormat++;

                if (*pwszFormat != L'%') 
                {
                    ULONG   ulNumber;
                    int     iWidth;
                    int     iLong;
                    PVOID   pvPointer;

                    //
                    // So it isnt a %%
                    //

                    iLong = 0;
                    iWidth = 0;

                    while(TRUE)
                    {
                        if((*pwszFormat >= L'0') && 
                           (*pwszFormat <= L'9')) 
                        {
                            iWidth = iWidth * 10 + *pwszFormat - '0';
                        } 
                        else
                        {
                            if(*pwszFormat == L'l') 
                            {
                                iLong++;
                            } 
                            else 
                            {
                                if((*pwszFormat == L'X') || 
                                   (*pwszFormat == L'x')) 
                                {
                                    break;
                                }
                            }
                        }
                       
                        //
                        // Move to the next specifier
                        //
 
                        pwszFormat++;
                    }

                    pwszFormat++;

                    for(ulNumber = 0; iWidth--; pwszBuffer++, ulCharCount--) 
                    {
                        if(!ulCharCount)
                        {
                            return -1;
                        }

                        ulNumber *= 16;

                        if((*pwszBuffer >= L'0') && 
                           (*pwszBuffer <= L'9')) 
                        {
                            ulNumber += (*pwszBuffer - L'0');
                        } 
                        else
                        {
                            if((*pwszBuffer >= L'a') && 
                               (*pwszBuffer <= L'f')) 
                            {
                                ulNumber += (*pwszBuffer - L'a' + 10);
                            }
                            else
                            {
                                if((*pwszBuffer >= L'A') && 
                                   (*pwszBuffer <= L'F')) 
                                {
                                    ulNumber += (*pwszBuffer - L'A' + 10);
                                } 
                                else 
                                {
                                    return -1;
                                }
                            }
                        }
                    }

                    pvPointer = va_arg(ArgList, PVOID);

                    if(iLong) 
                    {
                        *(PULONG)pvPointer = ulNumber;
                    } 
                    else 
                    {
                        *(PUSHORT)pvPointer = (USHORT)ulNumber;
                    }

                    iFormatItems++;

                    break;
                }
           
                //
                // NO BREAK
                // 

            }

            default:
            {
                if (!ulCharCount || (*pwszBuffer != *pwszFormat))
                {
                    return -1;
                }

                pwszBuffer++;

                ulCharCount--;

                pwszFormat++;

                break;
            }
        }
    }
}

DWORD
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszBuffer
    )

/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    pGuid       Contains the GUID to translate.

    pwszBuffer  Space for storing the string. Must be >= 39 * sizeof(WCHAR)

Return Value:


--*/

{
    return swprintf(pwszBuffer, 
                    GUID_FORMAT_W, 
                    pGuid->Data1, 
                    pGuid->Data2, 
                    pGuid->Data3, 
                    pGuid->Data4[0], 
                    pGuid->Data4[1], 
                    pGuid->Data4[2], 
                    pGuid->Data4[3], 
                    pGuid->Data4[4], 
                    pGuid->Data4[5], 
                    pGuid->Data4[6], 
                    pGuid->Data4[7]);
}

DWORD
ConvertStringToGuid(
    IN  PWCHAR  pwszGuid,
    IN  ULONG   ulStringLen,
    OUT GUID    *pGuid
    )

/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/

{
    USHORT    Data4[8];
    int       Count;

    if (ScanHexFormat(pwszGuid,
                      ulStringLen/sizeof(WCHAR),
                      GUID_FORMAT_W,
                      &pGuid->Data1, 
                      &pGuid->Data2, 
                      &pGuid->Data3, 
                      &Data4[0], 
                      &Data4[1], 
                      &Data4[2], 
                      &Data4[3], 
                      &Data4[4], 
                      &Data4[5], 
                      &Data4[6], 
                      &Data4[7]) == -1) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    for(Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) 
    {
        pGuid->Data4[Count] = (UCHAR)Data4[Count];
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\lanmap.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\lanmap.c

Abstract:

    This module maps lan adapter GUIDs to friendly names.

Revision History:

    AmritanR    Created

--*/

#include "inc.h"

LIST_ENTRY          g_LanGuidHashTable[LAN_HASH_TABLE_SIZE];
LIST_ENTRY          g_LanNameHashTable[LAN_HASH_TABLE_SIZE];
CRITICAL_SECTION    g_LanTableLock;


ULONG
__inline
LAN_NAME_HASH(
    IN  PWCHAR  pwszName
    )
{
    ULONG   ulLen, ulNumChars, i, ulIndex = 0;

    ulLen = wcslen(pwszName);

    ulNumChars = ulLen < 6 ? ulLen : 6;

    ulLen--;

    for(i = 0; i < ulNumChars; i++)
    {
        ulIndex += pwszName[i];
        ulIndex += pwszName[ulLen - i];
    }

    return ulIndex % LAN_HASH_TABLE_SIZE;
}

DWORD
InitLanNameMapper(
    VOID
    )

{
    ULONG   i;

    for(i = 0; i < LAN_HASH_TABLE_SIZE; i ++)
    {
        InitializeListHead(&(g_LanGuidHashTable[i]));
        InitializeListHead(&(g_LanNameHashTable[i]));
    }

    InitializeCriticalSection(&g_LanTableLock);

    return NO_ERROR;
}

VOID
DeinitLanNameMapper(
    VOID
    )

{
    ULONG   i;

    for(i = 0; i < LAN_HASH_TABLE_SIZE; i ++)
    {
        while(!IsListEmpty(&(g_LanGuidHashTable[i])))
        {
            PLIST_ENTRY pleNode;

            pleNode = RemoveHeadList(&(g_LanGuidHashTable[i]));

            HeapFree(g_hPrivateHeap,
                     0,
                     pleNode);
        }
    }

    DeleteCriticalSection(&g_LanTableLock);
}


DWORD
OpenConnectionKey(
    IN  GUID    *pGuid,
    OUT PHKEY    phkey
    )
{
    WCHAR       wszRegPath[256];
    WCHAR       wszGuid[40];
    DWORD       dwResult;

    *phkey = NULL;

    ConvertGuidToString(pGuid,
                        wszGuid);

    wsprintfW(wszRegPath,
              CONN_KEY_FORMAT_W,
              wszGuid);

    dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                             wszRegPath,
                             0,
                             KEY_READ,
                             phkey);

    return dwResult;
}

DWORD
NhiGetLanConnectionNameFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN OUT  PULONG  pulBufferLength,
    IN      BOOL    bRefresh,
    IN      BOOL    bCache
    )
{
    DWORD       dwType, dwResult;
    HKEY        hkey;
    PLAN_NODE   pNode;

    if(*pulBufferLength < (MAX_INTERFACE_NAME_LEN * sizeof(WCHAR)))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if(!bCache)
    {
        dwResult = OpenConnectionKey(pGuid,
                                     &hkey);

        if(dwResult isnot NO_ERROR)
        {
            return dwResult;
        }

        dwResult = RegQueryValueExW(hkey,
                                    REG_VALUE_CONN_NAME_W,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pwszBuffer,
                                    pulBufferLength);

        RegCloseKey(hkey);

        if(dwResult isnot NO_ERROR)
        {
            return dwResult;
        }

        if(dwType isnot REG_SZ)
        {
            return ERROR_REGISTRY_CORRUPT;
        }

        return NO_ERROR;
    }

    //
    // Lock the table
    //

    EnterCriticalSection(&g_LanTableLock);

    if(bRefresh)
    {
        //
        // refresh the cache
        //

        dwResult = UpdateLanLookupTable();

        if(dwResult isnot NO_ERROR)
        {
            LeaveCriticalSection(&g_LanTableLock);

            return dwResult;
        }
    }

    //
    // Now lookup the table
    //

    pNode = LookupLanNodeByGuid(pGuid);

    if(pNode is NULL)
    {
        LeaveCriticalSection(&g_LanTableLock);

        return ERROR_NOT_FOUND;
    }

    wcscpy(pwszBuffer,
           pNode->rgwcName);

    LeaveCriticalSection(&g_LanTableLock);

    return NO_ERROR;
}

DWORD
NhiGetGuidFromLanConnectionName(
    IN  PWCHAR  pwszName,
    OUT GUID    *pGuid,
    IN  BOOL    bRefresh,
    IN  BOOL    bCache
    )
{
    DWORD       dwResult;
    PLAN_NODE  pNode;

    //
    // Lock the table
    //

    EnterCriticalSection(&g_LanTableLock);

    if(bRefresh)
    {
        //
        // refresh the cache
        //

        dwResult = UpdateLanLookupTable();

        if(dwResult isnot NO_ERROR)
        {
            LeaveCriticalSection(&g_LanTableLock);

            return dwResult;
        }
    }

    //
    // Now lookup the table
    //

    pNode = LookupLanNodeByName(pwszName);

    if(pNode is NULL)
    {
        LeaveCriticalSection(&g_LanTableLock);

        return ERROR_NOT_FOUND;
    }

    *pGuid = pNode->Guid;

    LeaveCriticalSection(&g_LanTableLock);

    return NO_ERROR;
}

DWORD
NhiGetLanConnectionDescriptionFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )
{
    return NO_ERROR;
}

PLAN_NODE
LookupLanNodeByGuid(
    IN  GUID    *pGuid
    )

/*++

Routine Description:

    Looks up the ipip node in the hash table

Locks:

    Called with the ipip table lock held

Arguments:

    pGuid   Guid for the node

Return Value:

    LanNode if found
    NULL    otherwise

--*/

{
    ULONG       ulIndex;
    PLIST_ENTRY pleNode;

    ulIndex = LAN_GUID_HASH(pGuid);

    for(pleNode = g_LanGuidHashTable[ulIndex].Flink;
        pleNode isnot &(g_LanGuidHashTable[ulIndex]);
        pleNode = pleNode->Flink)
    {
        PLAN_NODE   pLanNode;

        pLanNode = CONTAINING_RECORD(pleNode,
                                     LAN_NODE,
                                     leGuidLink);

        if(IsEqualGUID(&(pLanNode->Guid),
                       pGuid))
        {
            return pLanNode;
        }
    }

    return NULL;
}

PLAN_NODE
LookupLanNodeByName(
    IN  PWCHAR  pwszName
    )

/*++

Routine Description:

    Looks up the ipip node in the hash table

Locks:

    Called with the ipip table lock held

Arguments:

    pwszName    Name of the phonebook entry

Return Value:

    RasNode if found
    NULL    otherwise

--*/

{
    ULONG       ulIndex;
    PLIST_ENTRY pleNode;

    ulIndex = LAN_NAME_HASH(pwszName);

    for(pleNode = g_LanNameHashTable[ulIndex].Flink;
        pleNode isnot &(g_LanNameHashTable[ulIndex]);
        pleNode = pleNode->Flink)
    {
        PLAN_NODE   pLanNode;

        pLanNode = CONTAINING_RECORD(pleNode,
                                      LAN_NODE,
                                      leNameLink);

        if(_wcsicmp(pLanNode->rgwcName,
                    pwszName) is 0)
        {
            return pLanNode;
        }
    }

    return NULL;
}


DWORD
AddLanNode(
    IN  GUID    *pGuid,
    IN  PWCHAR  pwszName
    )

/*++

Routine Description:

    Creates a node in the hash table for the given ipip info

Locks:

    Called with the LAN table lock held

Arguments:

    pInfo   Lan name info

Return Value:

    NO_ERROR
    ERROR_NOT_ENOUGH_MEMORY

--*/

{
    ULONG       ulGuidIndex, ulNameIndex;
    PLAN_NODE   pLanNode;

    pLanNode = HeapAlloc(g_hPrivateHeap,
                          0,
                          sizeof(LAN_NODE));

    if(pLanNode is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pLanNode->Guid = *pGuid;

    wcscpy(pLanNode->rgwcName,
           pwszName);

    ulGuidIndex = LAN_GUID_HASH(pGuid);
    ulNameIndex = LAN_NAME_HASH(pwszName);

    InsertHeadList(&(g_LanGuidHashTable[ulGuidIndex]),
                   &(pLanNode->leGuidLink));

    InsertHeadList(&(g_LanNameHashTable[ulNameIndex]),
                   &(pLanNode->leNameLink));


    return NO_ERROR;
}

VOID
RemoveLanNode(
    IN  PLAN_NODE   pNode
    )

/*++

Routine Description:

    Removes the given node from the hash tables

Locks:

    Called with the LAN table lock held

Arguments:

    pNode   Node to remove

Return Value:

    None

--*/

{
    RemoveEntryList(&(pNode->leGuidLink));
    RemoveEntryList(&(pNode->leNameLink));
}


DWORD
UpdateLanLookupTable(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to retrieve an array of LAN connections,

Arguments:

    None

Return Value:

    DWORD - Win32 status code.

--*/

{
    BOOLEAN bCleanupOle = TRUE;
    ULONG   ulConCount;
    HRESULT hrErr;
    ULONG   i, j;
    DWORD   dwResult;

    NETCON_STATUS   ncs;
    NTSTATUS        status;

    INetConnection          *rgpConArray[32];
    NETCON_PROPERTIES       *pLanProps;
    INetConnectionManager   *pConMan = NULL;
    IEnumNetConnection      *pEnumCon = NULL;
    UNICODE_STRING          UnicodeString;


    hrErr = CoInitializeEx(NULL,
                           COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);

    if(!SUCCEEDED(hrErr))
    {
        if(hrErr is RPC_E_CHANGED_MODE)
        {
            bCleanupOle = FALSE;
        }
        else
        {
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    i = 0;

    do
    {
        //
        // Instantiate the connection manager
        //

        hrErr = CoCreateInstance(&CLSID_ConnectionManager,
                                 NULL,
                                 CLSCTX_SERVER,
                                 &IID_INetConnectionManager,
                                 (PVOID*)&pConMan);

        if(!SUCCEEDED(hrErr))
        {
            pConMan = NULL;

            break;
        }

        //
        // Instantiate a connection-enumerator
        //

        hrErr = INetConnectionManager_EnumConnections(pConMan,
                                                      NCME_DEFAULT,
                                                      &pEnumCon);

        if(!SUCCEEDED(hrErr))
        {
            pEnumCon = NULL;

            break;
        }

        hrErr = CoSetProxyBlanket((IUnknown*)pEnumCon,
                                  RPC_C_AUTHN_WINNT,
                                  RPC_C_AUTHN_NONE,
                                  NULL,
                                  RPC_C_AUTHN_LEVEL_CALL,
                                  RPC_C_IMP_LEVEL_IMPERSONATE,
                                  NULL,
                                  EOAC_NONE);

        //
        // Enumerate the items
        //

        while(TRUE)
        {
            hrErr = IEnumNetConnection_Next(pEnumCon,
                                            sizeof(rgpConArray)/sizeof(rgpConArray[0]),
                                            rgpConArray,
                                            &ulConCount);

            if(!SUCCEEDED(hrErr) or
               !ulConCount)
            {
                hrErr = S_OK;

                break;
            }

            //
            // Examine the properties for the connections retrieved
            //

            for(j = 0; j < ulConCount; j++)
            {
                hrErr = INetConnection_GetProperties(rgpConArray[j],
                                                     &pLanProps);

                INetConnection_Release(rgpConArray[j]);

                if(SUCCEEDED(hrErr) and
                   pLanProps->MediaType is NCM_LAN)
                {
                    PLAN_NODE   pNode;

                    pNode = LookupLanNodeByGuid(&(pLanProps->guidId));

                    if(!pNode)
                    {
                        dwResult = AddLanNode(&(pLanProps->guidId),
                                               pLanProps->pszwName);
                    }
                    else
                    {
                        //
                        // Node exists, if different remove and re-add
                        //

                        if(_wcsicmp(pNode->rgwcName,
                                    pLanProps->pszwName) isnot 0)
                        {
                            RemoveLanNode(pNode);

                            dwResult = AddLanNode(&(pLanProps->guidId),
                                                  pLanProps->pszwName);
                        }
                    }
                }

                CoTaskMemFree(pLanProps->pszwName);
                CoTaskMemFree(pLanProps->pszwDeviceName);
                CoTaskMemFree(pLanProps);
            }
        }

    } while(FALSE);

    if(pEnumCon)
    {
        IEnumNetConnection_Release(pEnumCon);
    }

    if(pConMan)
    {
        INetConnectionManager_Release(pConMan);
    }

    if(bCleanupOle)
    {
        CoUninitialize();
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\inc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    //KERNEL/RAZZLE3/src/sockets/tcpcmd/iphlpapi/inc.h

Abstract:


Revision History:



--*/

#ifndef __INC_H__
#define __INC_H__


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <stddef.h>
#include <ntddip.h>
#include <ntddip6.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <tcpinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <arpinfo.h>

#include <objbase.h>

#define UNICODE
#define _UNICODE

#include <rasapip.h>

#undef UNICODE
#undef _UNICODE

#include <raserror.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <icmpapi.h>

#include <assert.h>
#include <mdebug.h>

#include <netcon.h>

#ifndef CHICAGO

#include <ntddip.h>

#endif


#if API_TRACE
#include <rtutils.h>
#endif

#include <mprapi.h>
#include <rtinfo.h>
#include <iprtrmib.h>
#include <ipcmp.h>

#include <iphlpapi.h>
#include <iphlpint.h>
#include <iphlpstk.h>
#include <nhapi.h>

#include "defs.h"
#include "strdefs.h"
#include "guid.h"
#include "map.h"
#include "compare.h"
#include "globals.h"
#include "namemap.h"
#include "rasmap.h"
#include "lanmap.h"

#ifdef KSL_IPINIP
#include "ipipmap.h"
#endif //KSL_IPINIP

#ifdef CHICAGO

#include <vxd32.h>
#include <wscntl.h>
#include <netvxd.h>
#include <tdistat.h>

#endif

#undef  DEBUG_PRINT

#ifdef CHICAGO

#define DEBUG_PRINT(X)  printf X

//
// On Memphis, we can define DEBUG_PRINT to be printf provided the 
// application which calls this dll also has a printf.
//

#else

#define DEBUG_PRINT(X)  DbgPrint X

#endif

DWORD
OpenTCPDriver(
    IN DWORD dwFamily
    );

DWORD
CloseTCPDriver(VOID);

DWORD
CloseTCP6Driver(VOID);

extern BOOL IpcfgdllInit(HINSTANCE hInstDll, DWORD fdwReason, LPVOID pReserved);

VOID
CheckTcpipState();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\iphlpapi.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    net\routing\iphlpapi.c

Abstract:
    This files contains the DLL entry point and some miscellanous functions for
    IPHLPAPI.DLL

Revision History:

    Amritansh Raghav

--*/

#include "inc.h"
#pragma hdrstop

#include <initguid.h>
#include <ifguid.h>

HANDLE      g_hPrivateHeap;
HANDLE      g_hTCPDriverGetHandle;
HANDLE      g_hTCP6DriverGetHandle;
HANDLE      g_hTCPDriverSetHandle;
HANDLE      g_hTCP6DriverSetHandle;
HANDLE      g_hIPDriverHandle;
HANDLE      g_hIP6DriverHandle;
HANDLE      g_hIPGetDriverHandle;
HANDLE      g_hIP6GetDriverHandle;
DWORD       g_dwTraceHandle;
LIST_ENTRY  g_pAdapterMappingTable[MAP_HASH_SIZE];
DWORD       g_dwLastIfUpdateTime;
PDWORD      g_pdwArpEntTable;
DWORD       g_dwNumArpEntEntries;
DWORD       g_dwLastArpUpdateTime;
DWORD       g_dwNumIf;
BOOL        g_bIpConfigured;
BOOL        g_bIp6Configured;
BOOL        g_bProcessAttached;

HANDLE      g_hModule;

MIB_SERVER_HANDLE   g_hMIBServer;
CRITICAL_SECTION    g_ifLock;
CRITICAL_SECTION    g_ipNetLock;
CRITICAL_SECTION    g_tcpipLock;
CRITICAL_SECTION    g_stateLock;
WSADATA WsaData;


#ifndef CHICAGO
VOID
InitFilterApis();

VOID
UnInitFilterApis();
#endif

BOOL WINAPI
IcmpEntryPoint(
    HANDLE   hDll,
    DWORD    dwReason,
    LPVOID   lpReserved
    );


BOOL WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    DWORD   dwResult;
    int retcode;

    UNREFERENCED_PARAMETER( pReserved );

    Trace1(ERR,"IpHlpDllEntry %d", fdwReason );

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            Trace0(ERR,"IpHlpDllEntry DLL_PROCESS_ATTACH");

            g_bProcessAttached = FALSE;

            // Check platform.
            if (GetVersion() & 0x80000000)
            {
                // CHICAGO
#ifndef CHICAGO
                DEBUG_PRINT(("IpHlpDllEntry: This an NT product.\n"));
                return FALSE;
#endif
            }
            else
            {
                // NT
#ifdef CHICAGO
                DEBUG_PRINT(("IpHlpDllEntry: This is an CHICAGO product.\n"));
                return FALSE;
#endif
            }


            //
            // we use WsControl amongst other things from wsock32
            //
	    
#ifdef CHICAGO
	        retcode = WSAStartup(0x0101, &WsaData);
	        if (retcode != 0)
            {
	            DEBUG_PRINT(("WSAStartup failed %d\n", GetLastError() ));
	            return FALSE;
	        }
#endif
            DisableThreadLibraryCalls(hInstDll);

            if (!IcmpEntryPoint(hInstDll, fdwReason, pReserved))
            {
                return FALSE;
            }

            g_hPrivateHeap = HeapCreate(0, 4*1024, 0);
            if (g_hPrivateHeap is NULL)
            {
                IcmpEntryPoint(hInstDll, DLL_PROCESS_DETACH, pReserved);
                return FALSE;
            }

            InitializeCriticalSection(&g_ifLock);
            InitializeCriticalSection(&g_ipNetLock);

            InitializeCriticalSection(&g_tcpipLock);
            InitializeCriticalSection(&g_stateLock);

            g_dwLastIfUpdateTime    = 0;
            g_dwLastArpUpdateTime   = 0;
            g_pdwArpEntTable        = NULL;
            g_dwNumArpEntEntries    = 0;
            g_dwNumIf               = 0;

            InitAdapterMappingTable();

            g_hMIBServer = NULL;

#if API_TRACE
            g_dwTraceHandle = TraceRegister("IPHLPAPI");

            if (g_dwTraceHandle is INVALID_TRACEID)
            {
                UnInitAdapterMappingTable();
                DeleteCriticalSection(&g_ifLock);
                DeleteCriticalSection(&g_ipNetLock);
                DeleteCriticalSection(&g_tcpipLock);
                DeleteCriticalSection(&g_stateLock);
                HeapDestroy(g_hPrivateHeap);
                IcmpEntryPoint(hInstDll, DLL_PROCESS_DETACH, pReserved);
                return FALSE;
            }

#endif  // API_TRACE

            if (OpenTCPDriver(AF_INET) is NO_ERROR)
            {
                g_bIpConfigured = TRUE;
                if (UpdateAdapterToIFInstanceMapping() isnot NO_ERROR ||
                    UpdateAdapterToATInstanceMapping() isnot NO_ERROR)
                {
                    g_bIpConfigured = FALSE;
                    CloseTCPDriver();
#if API_TRACE
                    TraceDeregister(g_dwTraceHandle);
#endif  // API_TRACE
                    UnInitAdapterMappingTable();
                    DeleteCriticalSection(&g_ifLock);
                    DeleteCriticalSection(&g_ipNetLock);
                    DeleteCriticalSection(&g_tcpipLock);
                    DeleteCriticalSection(&g_stateLock);
                    HeapDestroy(g_hPrivateHeap);
                    IcmpEntryPoint(hInstDll, DLL_PROCESS_DETACH, pReserved);
                    return FALSE;
                }
            }
            else
            {
                //
                // we are not running on an IP machine
                //

                g_bIpConfigured = FALSE;
            }

#ifndef CHICAGO
            InitFilterApis();

            //
            // Attach ipcfgdll library
            //
            if (g_bIpConfigured)
            {
                if (IpcfgdllInit(hInstDll, fdwReason, pReserved) == FALSE)
                {
                    UnInitFilterApis();
                    CloseTCPDriver();
#if API_TRACE
                    TraceDeregister(g_dwTraceHandle);
#endif  // API_TRACE
                    UnInitAdapterMappingTable();
                    DeleteCriticalSection(&g_ifLock);
                    DeleteCriticalSection(&g_ipNetLock);
                    DeleteCriticalSection(&g_tcpipLock);
                    DeleteCriticalSection(&g_stateLock);
                    HeapDestroy(g_hPrivateHeap);
                    IcmpEntryPoint(hInstDll, DLL_PROCESS_DETACH, pReserved);
                    return FALSE;
                }
            }
#endif

            g_hModule = hInstDll;

            InitNameMappers();

            g_bProcessAttached = TRUE;

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            Trace0(ERR,"IpHlpDllEntry DLL_PROCESS_DETACH");

            if (!g_bProcessAttached)
            {
                break;
            }

            DeinitNameMappers();

            if (g_hPrivateHeap isnot NULL)
            {
                HeapDestroy(g_hPrivateHeap);
            }

            DeleteCriticalSection(&g_ifLock);
            DeleteCriticalSection(&g_ipNetLock);
            DeleteCriticalSection(&g_tcpipLock);
            DeleteCriticalSection(&g_stateLock);

#ifndef CHICAGO

            if (g_hMIBServer isnot NULL)
            {
                MprAdminMIBServerDisconnect(g_hMIBServer);
            }
#endif
            if (g_bIpConfigured)
            {
                CloseTCPDriver();
            }

            if (g_bIp6Configured)
            {
                CloseTCP6Driver();
            }

#ifndef CHICAGO
            UnInitFilterApis();

            //
            // Detach ipcfgdll library
            //
            IpcfgdllInit(hInstDll, fdwReason, pReserved);
#endif

#if API_TRACE

            TraceDeregister(g_dwTraceHandle);

#endif  // API_TRACE

            g_bProcessAttached = FALSE;

            if (!IcmpEntryPoint(hInstDll, fdwReason, pReserved))
            {
                return FALSE;
            }
            break;
        }
        default:
        {
            break;
        }
    }

    return TRUE;
}

#ifndef CHICAGO
BOOL
IsRouterRunning(VOID)
{
    DWORD           dwResult;

    if(!MprAdminIsServiceRunning(NULL))
    {
        g_hMIBServer = NULL;

        return FALSE;
    }

    if(g_hMIBServer is NULL)
    {
        dwResult = MprAdminMIBServerConnect(NULL,
                                            &g_hMIBServer);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "IsRouterRunning: Error %d connecting to MIB Server\n",
                   dwResult);

            g_hMIBServer = NULL;

            return FALSE;
        }
    }

    return TRUE;
}

BOOL
IsRouterSettingRoutes(VOID)
{
    DWORD   dwResult, dwOutEntrySize;
    BOOL    bRet;

    MIB_OPAQUE_QUERY    Query;
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_ROUTESTATE     pState;



    //
    // This has to be called after calling IsRouterRunning, so g_hMibServer
    // is already set
    //

    if(g_hMIBServer is NULL)
    {
        return FALSE;
    }

    Query.dwVarId = ROUTE_STATE;

    dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                   PID_IP,
                                   IPRTRMGR_PID,
                                   (PVOID)&Query,
                                   sizeof(MIB_OPAQUE_QUERY),
                                   (PVOID)&pInfo,
                                   &dwOutEntrySize);

    if(dwResult isnot NO_ERROR)
    {
        return FALSE;
    }

    CAST_MIB_INFO(pInfo, PMIB_ROUTESTATE, pState);

    bRet = pState->bRoutesSetToStack;

    MprAdminMIBBufferFree((PVOID)pInfo);;

    return bRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\makefile.inc ===
$(O)\msg00001.bin: localmsg.mc
    $(MC) -v -h $(O) -r $(O) localmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\internal.c ===
/*++


Copyright (c) 1995  Microsoft Corporation

Module Name:
    net\sockets\tcpcmd\iphlpapi\internal.c

Abstract:
    Contains the private APIs exported by IPHLPAP.DLL  These
    are exposed because of the MIB-II subagent, and to allow
    more flexible use of the dll

Revision History:

    Amritansh Raghav

--*/

#include "inc.h"
#pragma hdrstop


HANDLE AddressChangeNotification = NULL;
HANDLE RouteChangeNotification = NULL;

HANDLE ChangeNotificationHandle = INVALID_HANDLE_VALUE;

extern HANDLE g_hIPDriverHandle;
extern HANDLE g_hIPGetDriverHandle;

HANDLE Change6NotificationHandle = INVALID_HANDLE_VALUE;

extern HANDLE g_hIP6DriverHandle;
extern HANDLE g_hIP6GetDriverHandle;

#define ROUTE_CHANGE 0
#define ADDRESS_CHANGE 1
#define TERMINATE_EVENT 2

int ThreadCreated=0;

typedef VOID (*PFNChangeHandler)(PVOID pContext);

typedef VOID (*PFNChangeHandler)(PVOID pContext);

DWORD
NotifyRouteChangeEx(
    PHANDLE      pHandle,
    LPOVERLAPPED pOverLapped,
    BOOL         bExQueue
    );

typedef struct
{
   LIST_ENTRY ListEntry;
   PVOID context;
   PFNChangeHandler Proc;

}NotifyContext;

DWORD
WINAPI
GetNumberOfInterfaces(
    PDWORD  pdwNumIf
    );

LIST_ENTRY AddrNotifyListHead;
LIST_ENTRY RouteNotifyListHead;

int
TCPSendIoctl(
    HANDLE hHandle,
    ulong Ioctl,
    void *InBuf,
    ulong *InBufLen,
    void *OutBuf,
    ulong *OutBufLen
    );

BOOL
IsRouterRunning(VOID);

BOOL
IsRouterSettingRoutes(VOID);

extern DWORD IPv4ToMibOperStatus[];
#define NUM_IPV4_OPER_STATUSES (IF_OPER_STATUS_OPERATIONAL+1)

DWORD
InternalGetIfTable(
    OUT  MIB_IFTABLE  **ppIfTable,
    IN   HANDLE       hHeap,
    IN   DWORD        dwAllocFlags
    )
{
    MIB_OPAQUE_QUERY    mqQuery;
    PMIB_OPAQUE_INFO    pInfo;
    PMIB_IFTABLE        pTable;
    DWORD               dwResult, dwOutEntrySize, i;

    TraceEnter("InternalGetIfTable");

    *ppIfTable = NULL;

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = IF_TABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"InternalGetIfTable: MprAdminMIBEntryGet failed with error %x",
                   dwResult);

            TraceLeave("InternalGetIfTable");

            return dwResult;
        }

        *ppIfTable = HeapAlloc(hHeap,
                               dwAllocFlags,
                               dwOutEntrySize);

        if(*ppIfTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace1(ERR,"InternalGetIfTable: Allocation failed with error %d",
                   dwResult);

            TraceLeave("InternalGetIfTable");

            MprAdminMIBBufferFree((PVOID)pInfo);

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IFTABLE, pTable);

        Trace3(ERR, "**pTable %x pInfo %x rgdata %x\n",
               pTable, pInfo, pInfo->rgbyData);

        CopyMemory((PVOID)(*ppIfTable),
                   (PVOID)pTable,
                   SIZEOF_IFTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = AllocateAndGetIfTableFromStack(ppIfTable,
                                                  TRUE,
                                                  hHeap,
                                                  dwAllocFlags,
                                                  TRUE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "InternalGetIfTable: AllocateAndGetIfTableFromStack failed with error %x",
                   dwResult);

            TraceLeave("InternalGetIfTable");

            return dwResult;
        }
#ifndef CHICAGO
    }
#endif

    //
    // Convert operational status to the numbering space used in the
    // MIB RFC's.
    //

    for (i = 0; i < (*ppIfTable)->dwNumEntries; i++)
    {
        (*ppIfTable)->table[i].dwOperStatus =
            ((*ppIfTable)->table[i].dwOperStatus < NUM_IPV4_OPER_STATUSES)
                  ? IPv4ToMibOperStatus[(*ppIfTable)->table[i].dwOperStatus]
                  : IF_STATUS_UNKNOWN;
    }

    TraceLeave("InternalGetIfTable");

    return NO_ERROR;
}

DWORD
InternalGetIpAddrTable(
    OUT  MIB_IPADDRTABLE  **ppIpAddrTable,
    IN   HANDLE           hHeap,
    IN   DWORD            dwAllocFlags
    )
{
    PMIB_OPAQUE_INFO    pInfo;
    MIB_OPAQUE_QUERY    mqQuery;
    DWORD               dwResult, dwOutEntrySize;
    PMIB_IPADDRTABLE    pTable;

    TraceEnter("InternalGetIpAddrTable");

    *ppIpAddrTable = NULL;

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = IP_ADDRTABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("InternalGetIpAddrTable");

            return dwResult;
        }

        *ppIpAddrTable = HeapAlloc(hHeap,
                                   dwAllocFlags,
                                   dwOutEntrySize);

        if(*ppIpAddrTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace1(ERR,"Allocation failed with error %d",
                   dwResult);
            TraceLeave("InternalGetIpAddrTable");

            MprAdminMIBBufferFree((PVOID)pInfo);

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IPADDRTABLE, pTable);

        CopyMemory((PVOID)(*ppIpAddrTable),
                   (PVOID)pTable,
                   SIZEOF_IPADDRTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = AllocateAndGetIpAddrTableFromStack(ppIpAddrTable,
                                                      TRUE,
                                                      hHeap,
                                                      dwAllocFlags);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"InternalGetIpAddrTableFromStack failed with error %x",
                   dwResult);
            TraceLeave("InternalGetIpAddrTable");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("InternalGetIpAddrTable");

    return NO_ERROR;
}

DWORD
InternalGetIpNetTable(
    OUT   MIB_IPNETTABLE    **ppIpNetTable,
    IN    HANDLE            hHeap,
    IN    DWORD             dwAllocFlags
    )
{
    PMIB_OPAQUE_INFO    pInfo;
    MIB_OPAQUE_QUERY    mqQuery;
    DWORD               dwResult, dwOutEntrySize;
    PMIB_IPNETTABLE     pTable;

    TraceEnter("InternalGetIpNetTable");

    *ppIpNetTable = NULL;

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = IP_NETTABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("InternalGetIpNetTable");

            return dwResult;
        }

        *ppIpNetTable = HeapAlloc(hHeap,
                                  dwAllocFlags,
                                  dwOutEntrySize);

        if(*ppIpNetTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace1(ERR,"Allocation failed with error %d",
                   dwResult);
            TraceLeave("InternalGetIpNetTable");

            MprAdminMIBBufferFree((PVOID)pInfo);

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IPNETTABLE, pTable);

        CopyMemory((PVOID)(*ppIpNetTable),
                   (PVOID)pTable,
                   SIZEOF_IPNETTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = AllocateAndGetIpNetTableFromStack(ppIpNetTable,
                                                     TRUE,
                                                     hHeap,
                                                     dwAllocFlags,
                                                     FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"AllocateAndGetIpNetTableFromStack failed with error %x",
                   dwResult);
            TraceLeave("InternalGetIpNetTable");

            return dwResult;
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("InternalGetIpNetTable");

    return NO_ERROR;
}

DWORD
InternalGetIpForwardTable(
    OUT   MIB_IPFORWARDTABLE    **ppIpForwardTable,
    IN    HANDLE                hHeap,
    IN    DWORD                 dwAllocFlags
    )
{
    PMIB_OPAQUE_INFO    pInfo;
    MIB_OPAQUE_QUERY    mqQuery;
    DWORD               dwResult, dwOutEntrySize;
    PMIB_IPFORWARDTABLE pTable;

    TraceEnter("InternalGetIpForwardTable");

    *ppIpForwardTable = NULL;

#ifndef CHICAGO
    if(IsRouterRunning() &&
       IsRouterSettingRoutes())
    {
        mqQuery.dwVarId = IP_FORWARDTABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("InternalGetIpForwardTable");

            return dwResult;
        }

        *ppIpForwardTable = HeapAlloc(hHeap,
                                      dwAllocFlags,
                                      dwOutEntrySize);

        if(*ppIpForwardTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace1(ERR,"Allocation failed with error %d",
                   dwResult);
            TraceLeave("InternalGetIpForwardTable");

            MprAdminMIBBufferFree((PVOID)pInfo);

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_IPFORWARDTABLE, pTable);

        CopyMemory((PVOID)(*ppIpForwardTable),
                   (PVOID)pTable,
                   SIZEOF_IPFORWARDTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = AllocateAndGetIpForwardTableFromStack(ppIpForwardTable,
                                                         TRUE,
                                                         hHeap,
                                                         dwAllocFlags);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"InternalGetIpForwardTableFromStack failed with error %x",
                   dwResult);
            TraceLeave("InternalGetIpForwardTable");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("InternalGetIpForwardTable");

    return NO_ERROR;
}

DWORD
InternalGetTcpTable(
    OUT MIB_TCPTABLE    **ppTcpTable,
    IN  HANDLE          hHeap,
    IN  DWORD           dwAllocFlags
    )
{
    PMIB_OPAQUE_INFO    pInfo;
    MIB_OPAQUE_QUERY    mqQuery;
    DWORD               dwResult, dwOutEntrySize;
    PMIB_TCPTABLE       pTable;

    TraceEnter("InternalGetTcpTable");

    *ppTcpTable = NULL;

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = TCP_TABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("InternalGetTcpTable");

            return dwResult;
        }

        *ppTcpTable = HeapAlloc(hHeap,
                                dwAllocFlags,
                                dwOutEntrySize);

        if(*ppTcpTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace1(ERR,"Allocation failed with error %d",
                   dwResult);
            TraceLeave("InternalGetTcpTable");

            MprAdminMIBBufferFree((PVOID)pInfo);

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_TCPTABLE, pTable);

        CopyMemory((PVOID)(*ppTcpTable),
                   (PVOID)pTable,
                   SIZEOF_TCPTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = AllocateAndGetTcpTableFromStack(ppTcpTable,
                                                   TRUE,
                                                   hHeap,
                                                   dwAllocFlags);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"InternalGetTcpTableFromStack failed with error %x",
                   dwResult);
            TraceLeave("InternalGetTcpTable");

            return dwResult;
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("InternalGetTcpTable");

    return NO_ERROR;
}

DWORD
InternalGetUdpTable(
    OUT MIB_UDPTABLE    **ppUdpTable,
    IN  HANDLE          hHeap,
    IN  DWORD           dwAllocFlags
    )
{
    PMIB_OPAQUE_INFO    pInfo;
    MIB_OPAQUE_QUERY    mqQuery;
    DWORD               dwResult, dwOutEntrySize;
    PMIB_UDPTABLE       pTable;

    TraceEnter("InternalGetUdpTable");

    *ppUdpTable = NULL;

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        mqQuery.dwVarId = UDP_TABLE;

        dwResult = MprAdminMIBEntryGet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)&mqQuery,
                                       sizeof(MIB_OPAQUE_QUERY),
                                       (PVOID)&pInfo,
                                       &dwOutEntrySize);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryGet failed with error %x",
                   dwResult);
            TraceLeave("InternalGetUdpTable");

            return dwResult;
        }

        *ppUdpTable = HeapAlloc(hHeap,
                                dwAllocFlags,
                                dwOutEntrySize);

        if(*ppUdpTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace1(ERR,"Allocation failed with error %d",
                   dwResult);

            MprAdminMIBBufferFree((PVOID)pInfo);

            return dwResult;
        }

        CAST_MIB_INFO(pInfo, PMIB_UDPTABLE, pTable);

        CopyMemory((PVOID)(*ppUdpTable),
                   (PVOID)pTable,
                   SIZEOF_UDPTABLE(pTable->dwNumEntries));

        MprAdminMIBBufferFree((PVOID)pInfo);
    }
    else
    {
#endif
        dwResult = AllocateAndGetUdpTableFromStack(ppUdpTable,
                                                   TRUE,
                                                   hHeap,
                                                   dwAllocFlags);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"InternalGetUdpTableFromStack failed with error %x",
                   dwResult);
            TraceLeave("InternalGetUdpTable");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("InternalGetUdpTable");

    return NO_ERROR;
}

DWORD
InternalSetIfEntry(
    IN   PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IFROW  pIfRow = (PMIB_IFROW)(pInfoRow->rgbyData);
    DWORD       dwResult;

    TraceEnter("SetIfEntry");

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        pInfoRow->dwId = IF_ROW;

        dwResult = MprAdminMIBEntrySet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pInfoRow,
                                       MIB_INFO_SIZE(MIB_IFROW));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntrySet failed with error %x",
                   dwResult);
            TraceLeave("SetIfEntry");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIfEntryToStack(pIfRow,
                                     FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIfEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("SetIfEntry");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif
    TraceLeave("SetIfEntry");

    return NO_ERROR;
}

DWORD
InternalCreateIpForwardEntry(
    IN PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IPFORWARDROW   pIpForwardRow = (PMIB_IPFORWARDROW)(pInfoRow->rgbyData);
    DWORD               dwResult;

    TraceEnter("CreateIpForwardEntry");

#ifndef CHICAGO
    if(IsRouterRunning() &&
       IsRouterSettingRoutes())
    {
        pInfoRow->dwId = IP_FORWARDROW;

        dwResult = MprAdminMIBEntryCreate(g_hMIBServer,
                                          PID_IP,
                                          IPRTRMGR_PID,
                                          (PVOID)pInfoRow,
                                          MIB_INFO_SIZE(MIB_IPFORWARDROW));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryCreate failed with error %x",
                   dwResult);
            TraceLeave("CreateIpForwardEntry");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIpForwardEntryToStack(pIpForwardRow);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIpForwarEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("CreateIpForwardEntry");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("CreateIpForwardEntry");
    return NO_ERROR;
}

DWORD
InternalSetIpForwardEntry(
    IN    PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IPFORWARDROW   pIpForwardRow = (PMIB_IPFORWARDROW)(pInfoRow->rgbyData);
    DWORD               dwResult;

    TraceEnter("SetIpForwardEntry");

#ifndef CHICAGO
    if(IsRouterRunning() &&
       IsRouterSettingRoutes())
    {
        pInfoRow->dwId = IP_FORWARDROW;

        dwResult = MprAdminMIBEntrySet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pInfoRow,
                                       MIB_INFO_SIZE(MIB_IPFORWARDROW));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntrySet failed with error %x",
                   dwResult);
            TraceLeave("SetIpForwardEntry");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIpForwardEntryToStack(pIpForwardRow);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIpForwarEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("SetIpForwardEntry");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif
    TraceLeave("SetIpForwardEntry");
    return NO_ERROR;
}

DWORD
InternalDeleteIpForwardEntry(
    IN PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IPFORWARDROW  pIpForwardRow = (PMIB_IPFORWARDROW)(pInfoRow->rgbyData);
    DWORD              dwResult;

    TraceEnter("DeleteIpForwardEntry");

    pIpForwardRow->dwForwardType = MIB_IPROUTE_TYPE_INVALID;


#ifndef CHICAGO
    if(IsRouterRunning() &&
       IsRouterSettingRoutes())
    {
        DWORD               rgdwInfo[5];
        PMIB_OPAQUE_QUERY   pIndex = (PMIB_OPAQUE_QUERY)rgdwInfo;

        pIndex->dwVarId          = IP_FORWARDROW;

        pIndex->rgdwVarIndex[0]    = pIpForwardRow->dwForwardDest;
        pIndex->rgdwVarIndex[1]    = pIpForwardRow->dwForwardProto;
        pIndex->rgdwVarIndex[2]    = pIpForwardRow->dwForwardPolicy;
        pIndex->rgdwVarIndex[3]    = pIpForwardRow->dwForwardNextHop;

        dwResult = MprAdminMIBEntryDelete(g_hMIBServer,
                                          PID_IP,
                                          IPRTRMGR_PID,
                                          (PVOID)pIndex,
                                          sizeof(rgdwInfo));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryDelete failed with error %x",
                   dwResult);
            TraceLeave("DeleteIpForwardEntry");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIpForwardEntryToStack(pIpForwardRow);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIpForwarEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("CreateIpForwardEntry");

            return dwResult;
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("CreateIpForwardEntry");
    return NO_ERROR;
}

DWORD
InternalSetIpStats(
    IN   PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IPSTATS    pIpStats = (PMIB_IPSTATS)(pInfoRow->rgbyData);
    DWORD           dwResult;

    TraceEnter("SetIpStats");

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        pInfoRow->dwId = IP_STATS;

        dwResult = MprAdminMIBEntrySet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pInfoRow,
                                       MIB_INFO_SIZE(MIB_IPSTATS));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntrySet failed with error %x",
                   dwResult);
            TraceLeave("SetIpStats");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIpStatsToStack(pIpStats);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIpStatsToStack failed with error %d",
                   dwResult);

            TraceLeave("SetIpStats");

            return dwResult;
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("SetIpStats");
    return NO_ERROR;
}


DWORD
InternalCreateIpNetEntry(
    IN PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IPNETROW   pIpNetRow = (PMIB_IPNETROW)(pInfoRow->rgbyData);
    DWORD           dwResult;

    TraceEnter("CreateIpNetEntry");

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        pInfoRow->dwId = IP_NETROW;

        dwResult = MprAdminMIBEntryCreate(g_hMIBServer,
                                          PID_IP,
                                          IPRTRMGR_PID,
                                          (PVOID)pInfoRow,
                                          MIB_INFO_SIZE(MIB_IPNETROW));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryCreate failed with error %x",
                   dwResult);
            TraceLeave("CreateIpNetEntry");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIpNetEntryToStack(pIpNetRow,
                                        FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIpNetEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("CreateIpNetEntry");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("CreateIpNetEntry");
    return NO_ERROR;
}


DWORD
InternalSetIpNetEntry(
    PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IPNETROW   pIpNetRow = (PMIB_IPNETROW)(pInfoRow->rgbyData);
    DWORD           dwResult;

    TraceEnter("SetIpNetEntry");

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        pInfoRow->dwId = IP_NETROW;

        dwResult = MprAdminMIBEntrySet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pInfoRow,
                                       MIB_INFO_SIZE(MIB_IPNETROW));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntrySet failed with error %x",
                   dwResult);
            TraceLeave("SetIpNetEntry");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIpNetEntryToStack(pIpNetRow,
                                        FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIpNetEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("SetIpNetEntry");

            return dwResult;
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("SetIpNetEntry");
    return NO_ERROR;
}

DWORD
InternalDeleteIpNetEntry(
    PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_IPNETROW   pIpNetRow = (PMIB_IPNETROW)(pInfoRow->rgbyData);
    DWORD           dwResult;

    TraceEnter("DeleteIpNetEntry");

    pIpNetRow->dwType = MIB_IPNET_TYPE_INVALID;

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        DWORD               rgdwInfo[3];
        PMIB_OPAQUE_QUERY  pIndex = (PMIB_OPAQUE_QUERY)rgdwInfo;

        pIndex->dwVarId = IP_NETROW;

        pIndex->rgdwVarIndex[0] = pIpNetRow->dwIndex;
        pIndex->rgdwVarIndex[1] = pIpNetRow->dwAddr;

        dwResult = MprAdminMIBEntryDelete(g_hMIBServer,
                                          PID_IP,
                                          IPRTRMGR_PID,
                                          (PVOID)pIndex,
                                          sizeof(rgdwInfo));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntryDelete failed with error %x",
                   dwResult);
            TraceLeave("DeleteIpNetEntry");

            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetIpNetEntryToStack(pIpNetRow,
                                        FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetIpNetEntryToStack failed with error %d",
                   dwResult);

            TraceLeave("DeleteIpNetEntry");

            return dwResult;
        }

#ifndef CHICAGO
    }
#endif

    TraceLeave("DeleteIpNetEntry");
    return NO_ERROR;
}

DWORD
InternalSetTcpEntry(
    PMIB_OPAQUE_INFO pInfoRow
    )
{
    PMIB_TCPROW pTcpRow = (PMIB_TCPROW)(pInfoRow->rgbyData);
    DWORD       dwResult;

    TraceEnter("SetTcpEntry");

#ifndef CHICAGO
    if(IsRouterRunning())
    {
        pInfoRow->dwId = TCP_ROW;

        dwResult = MprAdminMIBEntrySet(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pInfoRow,
                                       MIB_INFO_SIZE(MIB_TCPROW));

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"MprAdminMIBEntrySet failed with error %x",
                   dwResult);
            TraceLeave("SetTcpEntry");
            return dwResult;
        }
    }
    else
    {
#endif
        dwResult = SetTcpEntryToStack(pTcpRow);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"SetTcpEntryToStack failed with error %d",
                   dwResult);
            TraceLeave("SetTcpEntry");
            return dwResult;
        }
#ifndef CHICAGO
    }
#endif

    TraceLeave("SetTcpEntry");
    return NO_ERROR;
}


//#define MAX_ADAPTER_NAME_LENGTH 256

DWORD
OpenAdapterKey(
    LPSTR Name,
    PHKEY Key
    )
{
    DWORD   dwResult;
    CHAR    keyName[MAX_ADAPTER_NAME_LENGTH +
                    sizeof("\\Parameters\\Tcpip") +
                    sizeof("SYSTEM\\CurrentControlSet\\Services\\")];

    //
    // open the handle to this adapter's TCPIP parameter key
    //

    strcpy(keyName, "SYSTEM\\CurrentControlSet\\Services\\");
    strcat(keyName, Name);
    strcat(keyName, "\\Parameters\\Tcpip");

    Trace1(ERR,"OpenAdapterKey: %s", keyName);

    dwResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                          keyName,
                          Key);
    return dwResult;

}

DWORD
ReadRegistryDword(HKEY Key, LPSTR ParameterName, PULONG Value)
{
    DWORD dwResult, valueLength, valueType;

    valueLength = sizeof(*Value);

    dwResult = RegQueryValueEx(Key,
                               ParameterName,
                               NULL, // reserved
                               &valueType,
                               (LPBYTE)Value,
                               &valueLength);

    return dwResult;
}

DWORD
GetAdapterIPInterfaceContext(LPSTR AdapterName, PULONG Context)
{
    HKEY key;
    DWORD dwResult;

    if ((dwResult = OpenAdapterKey(AdapterName, &key)) != NO_ERROR) {
        return(dwResult);
    }

    if ((dwResult = ReadRegistryDword(key, "IPInterfaceContext", Context))
            != NO_ERROR) {
        return(dwResult);
    }

    RegCloseKey(key);

    return(NO_ERROR);
}

DWORD
GetInterfaceInfo(PIP_INTERFACE_INFO pIPIfInfo, PULONG dwOutBufLen)
{
#if defined(NT4) || defined(_WIN95_)
    return ERROR_NOT_SUPPORTED;
#else
    DWORD status=0;
    DWORD dwNumIf, NumAdapters;
    int i;
    DWORD dwResult;
    MIB_IPSTATS         IpSnmpInfo;

    if (IsBadWritePtr(dwOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pIPIfInfo, *dwOutBufLen)) {
        return ERROR_INVALID_PARAMETER;
    }

    dwResult = GetIpStatsFromStack(&IpSnmpInfo);

    if(dwResult isnot NO_ERROR) {
        Trace1(ERR,"GetInterfaceInfo: GetIpStatsFromStack returned error %d",
               dwResult);
        return dwResult;
    }

    dwNumIf = IpSnmpInfo.dwNumIf;

    if(dwNumIf is 0) {
        Trace0(ERR,"GetInterfaceInfo: No interfaces");
        return ERROR_NO_DATA;
    }

    if (dwOutBufLen == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!pIPIfInfo ||
        (*dwOutBufLen <
            (ULONG)sizeof(IP_ADAPTER_INDEX_MAP)*(dwNumIf + OVERFLOW_COUNT))) {

        *dwOutBufLen =
            (ULONG)sizeof(IP_ADAPTER_INDEX_MAP)*(dwNumIf + OVERFLOW_COUNT);

        return ERROR_INSUFFICIENT_BUFFER;
    }

    Trace1(ERR, "GetInterfaceInfo: outbuflen %d", *dwOutBufLen);

    return TCPSendIoctl(g_hIPGetDriverHandle,
                        IOCTL_IP_INTERFACE_INFO,
                        NULL,
                        &status,
                        pIPIfInfo,
                        dwOutBufLen);
#endif
}

DWORD
GetUniDirectionalAdapterInfo(PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pIPIfInfo,
                             PULONG dwOutBufLen)
{
    DWORD status=0;
    if (dwOutBufLen == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    return TCPSendIoctl(g_hIPGetDriverHandle,
                        IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS,
                        NULL,
                        &status,
                        pIPIfInfo,
                        dwOutBufLen);

}

DWORD
GetIgmpList(IPAddr NTEAddr, IPAddr *pIgmpList, PULONG pdwOutBufLen)

/*++

Routine Description:

    When pIgmpList is NULL, get the amount of space necessary to hold
    the group addresses joined on a given interface address.

    When pIgmpList is non-NULL and *pdwOutBufLen is more than 4 bytes,
    get the actual group addresses.

Arguments:

    NTEAddr      - Supplies the address of an interface whose multicast
                   group information is being requested.

    pIgmpList    - Supplies a buffer in which to put group addresses, or 
                   NULL to just request amount of space desired.

    pdwOutBufLen - When pIgmpList is NULL, returns the amount of space
                   the caller should allocate to get all groups.

                   When pIgmpList is non-NULL, supplies the size of
                   the buffer supplied, and returns the amount of
                   space actually used.

Return Value:

    NO_ERROR
    ERROR_INVALID_PARAMETER if the arguments don't meet the requirements.
    ERROR_INSUFFICIENT_BUFFER if more groups are available than fit.

--*/

{
    DWORD inlen = sizeof(IPAddr);
    DWORD dwStatus;

    if (pdwOutBufLen == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pdwOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pIgmpList == NULL) {
        DWORD dwSize;

        // 
        // When pIgmpList is NULL, the caller is just asking for the
        // amount of space needed, so use pdwOutBufLen as the buffer.
        //
        dwSize = sizeof(*pdwOutBufLen);
        dwStatus = TCPSendIoctl(g_hIPGetDriverHandle,
                                IOCTL_IP_GET_IGMPLIST,
                                &NTEAddr,
                                &inlen,
                                pdwOutBufLen,
                                &dwSize);
    } else {
        //
        // Otherwise the caller wants the list of groups.
        //
        if (IsBadWritePtr(pIgmpList, *pdwOutBufLen)) {
            return ERROR_INVALID_PARAMETER;
        }
        if (*pdwOutBufLen <= sizeof(ULONG)) {
            //
            // Make sure the buffer is bigger than a ULONG or we'll get
            // the size back, not group data.  The IOCTL insures that
            // when the caller requests the size needed, the amount 
            // returned will be bigger than a ULONG.
            //
            return ERROR_INVALID_PARAMETER;
        }

        dwStatus = TCPSendIoctl(g_hIPGetDriverHandle,
                                IOCTL_IP_GET_IGMPLIST,
                                &NTEAddr,
                                &inlen,
                                pIgmpList,
                                pdwOutBufLen);
    }

    if (dwStatus == ERROR_MORE_DATA) {
        //
        // Callers expect ERROR_INSUFFICIENT_BUFFER when *pdwOutBufLen is
        // too small.  However, the stack actually generates a warning 
        // (ERROR_MORE_DATA), rather than an error (ERROR_INSUFFICIENT_BUFFER)
        // so that the data gets passed back to the caller.
        //
        dwStatus = ERROR_INSUFFICIENT_BUFFER;
    }

    return dwStatus;
}

DWORD
SetBlockRoutes(IPRouteBlock *RouteBlock, PULONG poutbuflen, PULONG statusblock)
{
    DWORD  inlen;

    if (IsRouterRunning()) {
        return ERROR_NOT_SUPPORTED;
    }

    if (poutbuflen == NULL) {
        // Null pointers ?
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadReadPtr(poutbuflen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadReadPtr(RouteBlock, sizeof(IPRouteBlock))) {
        return ERROR_INVALID_PARAMETER;
    }

    inlen = (RouteBlock->numofroutes * sizeof(IPRouteEntry)) + sizeof(ulong);

    if (IsBadReadPtr(RouteBlock, inlen)) {
        return ERROR_INVALID_PARAMETER;
    }

    return TCPSendIoctl(g_hIPDriverHandle,
                        IOCTL_IP_SET_BLOCKOFROUTES,
                        RouteBlock,
                        &inlen,
                        statusblock,
                        poutbuflen);
}

DWORD
SetRouteWithRef(IN IPRouteEntry *RouteEntry
                )
{
    DWORD  inlen = sizeof(IPRouteEntry);
    ULONG  outbuflen;

    if (IsRouterRunning()) {
        return ERROR_NOT_SUPPORTED;
    }

    if (IsBadReadPtr(RouteEntry, inlen)) {
        return ERROR_INVALID_PARAMETER;
    }

    return TCPSendIoctl(g_hIPDriverHandle,
                        IOCTL_IP_SET_ROUTEWITHREF,
                        RouteEntry,
                        &inlen,
                        NULL,
                        &outbuflen);
}

DWORD
GetAdapterIndex(
    IN LPWSTR  AdapterName,
    OUT PULONG IfIndex
    )
/*++

Routine Description:

    Gets the target IP interface given the name of the adapter associated with it.


Arguments:

    AdapterName - A unicode string identifying the adapter/interface to which
                  to add the new NTE.
    ifIndex     - Interface index associated with the adapter name.

Return Value:

    ERROR_SUCCESS or windows error
--*/

{
#ifdef CHICAGO
    return ERROR_NOT_SUPPORTED;
#else
    int i;

    DWORD dwResult;
    MIB_IPADDRTABLE *pIpAddrTable;
    MIB_IPADDRROW *pIpAddrEntry;
    ULONG  Context;
    int NumEntries;
    IP_INTERFACE_INFO *pIPIfInfo=NULL;
    DWORD dwNumIf, NumAdapters;
    ULONG dwOutBufLen;

    if (AdapterName == NULL || IfIndex == NULL)
    {
       return(ERROR_INVALID_PARAMETER);
    }

    dwResult = GetNumberOfInterfaces(&dwNumIf);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetAdapterIndex: GetNumberOfInterfaces returned error %d",
               dwResult);

        return dwResult;
    }

    if(dwNumIf is 0)
    {
        Trace0(ERR,"GetAdapterIndex: No interfaces");
        return ERROR_NO_DATA;
    }

    dwOutBufLen = (ULONG)sizeof(IP_ADAPTER_INDEX_MAP)*(dwNumIf + OVERFLOW_COUNT);

    pIPIfInfo = HeapAlloc(g_hPrivateHeap, FALSE, dwOutBufLen);

    if(pIPIfInfo is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "GetAdapterIndex: Couldnt allocate memory. Error %d",
               dwResult);

        return dwResult;
    }

    dwResult = GetInterfaceInfo(pIPIfInfo, &dwOutBufLen);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetAdapterIndex: Error %d calling GetInterfaceInfo",
               dwResult);
        HeapFree(g_hPrivateHeap, 0, pIPIfInfo);
        return dwResult;
    }

    // search for the adaptername within this info and return the index.

    NumAdapters = pIPIfInfo->NumAdapters;

    for (i = 0; i < (int)pIPIfInfo->NumAdapters; i++) {
        if (lstrcmpiW(AdapterName, pIPIfInfo->Adapter[i].Name) == 0)
        {
            break;
        }
    }

    if (i < (int)pIPIfInfo->NumAdapters)
    {

       *IfIndex = pIPIfInfo->Adapter[i].Index;

       HeapFree(g_hPrivateHeap, 0, pIPIfInfo);
       return(NO_ERROR);
    }

    HeapFree(g_hPrivateHeap, 0, pIPIfInfo);
    return(ERROR_DEV_NOT_EXIST);
#endif
}



DWORD
AddIPAddress(IPAddr Address, IPMask IpMask, DWORD IfIndex, PULONG NTEContext,
             PULONG NTEInstance)
{
#ifdef CHICAGO
    return ERROR_NOT_SUPPORTED;
#else

    IP_ADD_NTE_REQUEST requestBuffer;
    PIP_ADD_NTE_RESPONSE responseBuffer =
        (PIP_ADD_NTE_RESPONSE) &requestBuffer;
    DWORD requestBufferSize = sizeof(requestBuffer);
    DWORD responseBufferSize = sizeof(requestBuffer);
    DWORD status;

    //
    // Validate the IP address to be added. Check for
    // * broadcast address,
    // * loopback address,
    // * zero address,
    // * Class D address,
    // * zero subnet-broadcast address
    // * all-ones subnet-broadcast address
    // * non-contiguous mask (which we test by negating the host-order mask
    //      and verifying that all the bits change when we add 1, i.e. that
    //      the negation is of the form 2^n-1).
    //
    if ((Address == INADDR_BROADCAST) ||
        ((ntohl(Address) & IN_CLASSA_NET) ==
         (INADDR_LOOPBACK & IN_CLASSA_NET)) ||
        (Address == 0) ||
        (IN_CLASSD(ntohl(Address))) ||
        ((Address & ~IpMask) == 0) ||
        ((Address & ~IpMask) == ~IpMask) ||
        ((~ntohl(IpMask) + 1) & ~ntohl(IpMask))) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (NTEContext == NULL) || (NTEInstance == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(NTEContext, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(NTEInstance, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    requestBuffer.InterfaceContext = (unsigned long) IfIndex;
    requestBuffer.Address = Address;
    requestBuffer.SubnetMask = IpMask;

    status = TCPSendIoctl(g_hIPDriverHandle,
                          IOCTL_IP_ADD_NTE,
                          &requestBuffer,
                          &requestBufferSize,
                          responseBuffer,
                          &responseBufferSize);

    if (status == NO_ERROR) {
        *NTEContext = (ULONG) responseBuffer->Context;
        *NTEInstance = responseBuffer->Instance;
    } else if (status == STATUS_DUPLICATE_OBJECTID) {
        status = ERROR_DUP_DOMAINNAME;
    }

    return(status);
#endif
}

DWORD
DeleteIPAddress(ULONG NTEContext)
{
#ifdef CHICAGO
    return ERROR_NOT_SUPPORTED;
#else
    IP_DELETE_NTE_REQUEST requestBuffer;
    DWORD requestBufferSize = sizeof(requestBuffer);
    DWORD responseBufferSize = 0;
    DWORD status;

    requestBuffer.Context = (unsigned short) NTEContext;


    status = TCPSendIoctl(g_hIPDriverHandle,
                          IOCTL_IP_DELETE_NTE,
                          &requestBuffer,
                          &requestBufferSize,
                          NULL,
                          &responseBufferSize);
    return(status);
#endif
}


#define DEFAULT_TTL                 32
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             5000L

#include <icmpapi.h>
#ifndef CHICAGO
#include <ntddip.h>
#endif

BOOL
GetRTT(IPAddr DestIpAddress, PULONG Rtt)
{
    uchar FAR  *Opt = (uchar FAR *)0;         // Pointer to send options
    uint    OptLength = 0;
    int     OptIndex = 0;               // Current index into SendOptions
    uchar   Flags = 0;
    ulong   Timeout = DEFAULT_TIMEOUT;
    IP_OPTION_INFORMATION SendOpts;
    HANDLE  IcmpHandle;
    PICMP_ECHO_REPLY  reply;
    char    SendBuffer[32], RcvBuffer[4096];
    uint    RcvSize=4096;
    uint    SendSize = 32;
    uint    i;
    DWORD   numberOfReplies;


    IcmpHandle = IcmpCreateFile();

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    if (IsBadWritePtr(Rtt, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize the send buffer pattern.
    //

    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = (char) ('a' + (i % 23));
    }

    //
    // Initialize the send options
    //

    SendOpts.OptionsData = Opt;
    SendOpts.OptionsSize = (UCHAR) OptLength;
    SendOpts.Ttl = DEFAULT_TTL;
    SendOpts.Tos = DEFAULT_TOS;
    SendOpts.Flags = Flags;

    numberOfReplies = IcmpSendEcho(IcmpHandle,
                                   DestIpAddress,
                                   SendBuffer,
                                   (unsigned short) SendSize,
                                   &SendOpts,
                                   RcvBuffer,
                                   RcvSize,
                                   DEFAULT_TIMEOUT);
    if (numberOfReplies) {
        numberOfReplies = IcmpSendEcho(IcmpHandle,
                                       DestIpAddress,
                                       SendBuffer,
                                       (unsigned short) SendSize,
                                       &SendOpts,
                                       RcvBuffer,
                                       RcvSize,
                                       Timeout);
        if (numberOfReplies) {
            reply = (PICMP_ECHO_REPLY) RcvBuffer;
            *Rtt = reply->RoundTripTime;
            IcmpCloseHandle(IcmpHandle);
            return(TRUE);
        }
    }

    IcmpCloseHandle(IcmpHandle);
    return(FALSE);
}

BOOL
GetRTTAndHopCount(IPAddr DestIpAddress, PULONG HopCount, ULONG  MaxHops,
                  PULONG RTT)
{
    DWORD numberOfReplies;
    uchar FAR *Opt = (uchar FAR *)0;         // Pointer to send options
    uint OptLength = 0;
    int OptIndex = 0;               // Current index into SendOptions
    uchar Flags = 0;
    ulong Timeout = DEFAULT_TIMEOUT;
    IP_OPTION_INFORMATION SendOpts;
    HANDLE IcmpHandle;
    PICMP_ECHO_REPLY  reply;
    char SendBuffer[32], RcvBuffer[4096];
    uint RcvSize=4096;
    uint SendSize = 32;
    uint i,status;
    ULONG RTT1;

    IcmpHandle = IcmpCreateFile();

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    if (!HopCount || !RTT) {
        return (FALSE);
    }

    if (DestIpAddress == -1L) {
        return(FALSE);
    }

    if (IsBadWritePtr(RTT, sizeof(ULONG))) {
        return (FALSE);
    }

    if (IsBadWritePtr(HopCount, sizeof(ULONG))) {
        return (FALSE);
    }

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = (char) ('a' + (i % 23));
    }
    //
    // Initialize the send options
    //
    SendOpts.OptionsData = Opt;
    SendOpts.OptionsSize = (UCHAR) OptLength;
    SendOpts.Ttl = 1;
    SendOpts.Tos = DEFAULT_TOS;
    SendOpts.Flags = Flags;


    while (SendOpts.Ttl <= MaxHops) {

        numberOfReplies = IcmpSendEcho(IcmpHandle,
                                       DestIpAddress,
                                       SendBuffer,
                                       (unsigned short) SendSize,
                                       &SendOpts,
                                       RcvBuffer,
                                       RcvSize,
                                       Timeout);
        if (numberOfReplies == 0) {
            status = GetLastError();
            reply = NULL;
        } else {
            reply = (PICMP_ECHO_REPLY)RcvBuffer;
            status = reply->Status;
        }

        if (status == IP_SUCCESS) {

            *HopCount = SendOpts.Ttl;

            IcmpCloseHandle(IcmpHandle);

            if (GetRTT(DestIpAddress, &RTT1)) {
                *RTT = RTT1;
                return TRUE;
            } else {
                return FALSE;
            }

        } else if (status == IP_TTL_EXPIRED_TRANSIT) {
            SendOpts.Ttl++;
        } else {
            IcmpCloseHandle(IcmpHandle);
            return FALSE;
        }
    }

    IcmpCloseHandle(IcmpHandle);
    return FALSE;
}

#define LOOPBACK_ADDR   0x0100007f

DWORD
IsLocalAddress(IPAddr InAddress)
{
    int     i;
    DWORD   dwResult;
    int     NumEntries;

    PMIB_IPADDRTABLE pIpAddrTable;
    PMIB_IPADDRROW   pIpAddrEntry;

    dwResult = AllocateAndGetIpAddrTableFromStack(&pIpAddrTable,
                                                  FALSE,
                                                  g_hPrivateHeap,
                                                  0);

    if(dwResult isnot NO_ERROR) {
        Trace1(ERR,"GetIpAddrTableFromStack failed with error %x",dwResult);
        TraceLeave("IsLocalAddress");
        return dwResult;
    }

    if (InAddress == LOOPBACK_ADDR) {
        HeapFree(g_hPrivateHeap, 0, pIpAddrTable);
        return(NO_ERROR);
    }

    NumEntries = (*pIpAddrTable).dwNumEntries;

    Trace2(ERR,"IsLocalAddress number of addresses %d chking %x",
           NumEntries,InAddress);

    for (i = 0; i < NumEntries; i++) {
        pIpAddrEntry = &(*pIpAddrTable).table[i];
        Trace1(ERR,"IsLocalAddress cmparing %x",pIpAddrEntry->dwAddr);
        if (pIpAddrEntry->dwAddr == (DWORD)InAddress) {
            HeapFree(g_hPrivateHeap, 0, pIpAddrTable);
            return(NO_ERROR);
        }
    }

    HeapFree(g_hPrivateHeap, 0, pIpAddrTable);
    return(ERROR_INVALID_ADDRESS);
}

DWORD
GetArpTable(PMIB_IPNETTABLE pIpNetTable, PDWORD pdwSize)
{
    return(GetIpNetTable(pIpNetTable,pdwSize,TRUE));
}

DWORD
AddArpEntry(IPAddr IPAddress, PUCHAR pPhyAddress, ULONG PhyAddrLen,
            ULONG IfIndex, BOOLEAN Dynamic)
{
    MIB_IPNETROW NetRow;
    uint i;
    DWORD dwResult;

    NetRow.dwIndex = IfIndex;
    NetRow.dwPhysAddrLen = PhyAddrLen;

    if (pPhyAddress == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    if (PhyAddrLen > MAXLEN_PHYSADDR) {
        return(ERROR_INVALID_PARAMETER);
    }

    // Check for bcast, loopback and class D address
    if ((IPAddress == 0xffffffff) ||
        (ntohl(IPAddress) == 0x7f000001) ||
        ((ntohl(IPAddress) >= 0xe0000000) &&
         (ntohl(IPAddress) <= 0xefffffff))) {
        return ERROR_INVALID_PARAMETER;
    }

    for (i=0; i < PhyAddrLen; i++) {
        NetRow.bPhysAddr[i] = pPhyAddress[i];
    }
    NetRow.dwAddr = IPAddress;

    NetRow.dwType = MIB_IPNET_TYPE_DYNAMIC;
    if (!Dynamic) {
        NetRow.dwType = MIB_IPNET_TYPE_STATIC;
    }

    dwResult = SetIpNetEntryToStack(&NetRow, FALSE);

    if (dwResult == STATUS_INVALID_PARAMETER) {
        return(ERROR_INVALID_PARAMETER);
    } else if (dwResult == STATUS_INVALID_DEVICE_REQUEST) {
        return(ERROR_INVALID_PARAMETER);
    }

    if (dwResult == STATUS_SUCCESS) {
        return(NO_ERROR);
    } else {
        return(dwResult);
    }
}

DWORD
DeleteArpEntry(IPAddr IPAddress, ULONG IfIndex)
{
    MIB_IPNETROW NetRow;
    DWORD dwResult;

    NetRow.dwIndex = IfIndex;
    NetRow.dwAddr = IPAddress;
    NetRow.dwType = MIB_IPNET_TYPE_INVALID;

    dwResult = SetIpNetEntryToStack(&NetRow, FALSE);

    if (dwResult == STATUS_INVALID_PARAMETER) {
        return(ERROR_INVALID_PARAMETER);
    }
    return(dwResult);
}

DWORD
NotifyAddrChange(HANDLE *pHandle, OVERLAPPED *pOverLapped)
{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
    BOOL b;
    DWORD dwResult;
    DWORD temp;

    if ((pHandle != NULL) && (pOverLapped != NULL)) {

        Trace0(ERR, "NotifyAddressChange: overlapped request");

        if (IsBadWritePtr(pHandle, sizeof(HANDLE))) {
            return ERROR_INVALID_PARAMETER;
        }

        if (IsBadWritePtr(pOverLapped, sizeof(OVERLAPPED))) {
            return ERROR_INVALID_PARAMETER;
        }

        *pHandle = ChangeNotificationHandle;

        if (*pHandle == INVALID_HANDLE_VALUE){
            Trace1(ERR, "NotifyAddressChange: CreateFile=%d", GetLastError());
            return ERROR_OPEN_FAILED;
        }


        b = DeviceIoControl(*pHandle,
                            IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST,
                            NULL,
                            0,
                            NULL,
                            0,
                            &temp,
                            pOverLapped);

        if (!b) {
            dwResult = GetLastError();
            Trace1(ERR, "NotifyAddrChange: DeviceIoControl=%d", dwResult);
            return dwResult;
        }

    } else {

        // Synchronous change notification
        // This call will block

        Trace0(ERR, "NotifyAddrChange: synchronous request");

        b = DeviceIoControl(g_hIPGetDriverHandle,
                            IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST,
                            NULL,
                            0,
                            NULL,
                            0,
                            &temp,
                            NULL);

        if (!b) {
            dwResult = GetLastError();
            Trace1(ERR, "NotifyAddressChange: DeviceIoControl=%d", dwResult);
            return dwResult;
        }
    }

    return NO_ERROR;
#endif
}

DWORD
NotifyRouteChange(HANDLE *pHandle, OVERLAPPED *pOverLapped)
{
    return NotifyRouteChangeEx(pHandle, pOverLapped, FALSE);
}


DWORD
NotifyRouteChangeEx(
    PHANDLE         pHandle,
    LPOVERLAPPED    pOverLapped,
    BOOL            bExQueue
    )
{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
     BOOL b;
     DWORD dwResult;
     DWORD temp;
     DWORD    dwIoctl;

     if(bExQueue) {
        dwIoctl = IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX;
    } else {
        dwIoctl = IOCTL_IP_RTCHANGE_NOTIFY_REQUEST;
    }

    if ((pHandle != NULL) && (pOverLapped != NULL)) {

        Trace0(ERR, "NotifyRouteChange: overlapped request");

        if (IsBadWritePtr(pHandle, sizeof(HANDLE))) {
            return ERROR_INVALID_PARAMETER;
        }

        if (IsBadWritePtr(pOverLapped, sizeof(OVERLAPPED))) {
            return ERROR_INVALID_PARAMETER;
        }

        *pHandle = ChangeNotificationHandle;

        if(*pHandle == INVALID_HANDLE_VALUE){
            Trace1(ERR, "NotifyRouteChange: CreateFile=%d", GetLastError());
            return ERROR_OPEN_FAILED;
        }


        b = DeviceIoControl(*pHandle,
                            dwIoctl,
                            NULL,
                            0,
                            NULL,
                            0,
                            &temp,
                            pOverLapped);

        if (!b) {
            dwResult = GetLastError();
            Trace1(ERR, "NotifyRouteChange: DeviceIoControl=%d", dwResult);
            return dwResult;
        }

   } else {

        // Synchronous change notification
        // This call will block

        Trace0(ERR, "NotifyRouteChange: synchronous request");

        b = DeviceIoControl(g_hIPGetDriverHandle,
                            dwIoctl,
                            NULL,
                            0,
                            NULL,
                            0,
                            &temp,
                            NULL);

        if (!b) {

            dwResult = GetLastError();
            Trace1(ERR, "NotifyRouteChange: DeviceIoControl=%d", dwResult);
            return dwResult;
        }
    }

    return NO_ERROR;
#endif
}


DWORD WINAPI
EnableRouter(HANDLE *pHandle, OVERLAPPED *pOverLapped)
{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
    BOOL b;
    DWORD dwResult;
    DWORD temp;

    if ((pHandle != NULL) && (pOverLapped != NULL)) {

        Trace0(ERR,"EnableRouter: overlapped request");

        if (IsBadWritePtr(pHandle, sizeof(HANDLE)) ||
            IsBadWritePtr(pOverLapped, sizeof(OVERLAPPED))) {
            return ERROR_INVALID_PARAMETER;
        }

        *pHandle = g_hIPDriverHandle;

        if (*pHandle == INVALID_HANDLE_VALUE) {
            return ERROR_OPEN_FAILED;
        }


        b = DeviceIoControl(
                *pHandle,
                IOCTL_IP_ENABLE_ROUTER_REQUEST,
                NULL,
                0,
                NULL,
                0,
                &temp,
                pOverLapped
                );

        if (!b) { return GetLastError(); }

   } else {

        Trace0(ERR,"EnableRouter: synchronous request");

        b = DeviceIoControl(
                g_hIPDriverHandle,
                IOCTL_IP_ENABLE_ROUTER_REQUEST,
                NULL,
                0,
                NULL,
                0,
                &temp,
                NULL
                );

        if (!b) {
            dwResult = GetLastError();
            Trace1(ERR,"EnableRouter: DeviceIoControl=%d", dwResult);
            return dwResult;
        }
   }

   return NO_ERROR;
#endif
}

DWORD WINAPI
UnenableRouter(OVERLAPPED* pOverlapped, LPDWORD lpdwEnableCount OPTIONAL)
{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
    BOOL b;
    DWORD EnableCount;
    DWORD temp;
    if (lpdwEnableCount && IsBadWritePtr(lpdwEnableCount, sizeof(DWORD))) {
        return ERROR_INVALID_PARAMETER;
    }
    if (g_hIPDriverHandle == INVALID_HANDLE_VALUE) {
        return ERROR_OPEN_FAILED;
    }
    b = DeviceIoControl(
            g_hIPDriverHandle,
            IOCTL_IP_UNENABLE_ROUTER_REQUEST,
            (PVOID)&pOverlapped,
            sizeof(PVOID),
            &EnableCount,
            sizeof(DWORD),
            &temp,
            NULL
            );
    if (!b) { return GetLastError(); }
    if (lpdwEnableCount) { *lpdwEnableCount = EnableCount; }
    return NO_ERROR;
#endif
}




DWORD WINAPI
DisableMediaSense(HANDLE *pHandle, OVERLAPPED *pOverLapped)
{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
    BOOL b;
    DWORD dwResult;
    DWORD temp;

    if ((pHandle != NULL) && (pOverLapped != NULL)) {

        Trace0(ERR,"DisableMediaSense: overlapped request");

        if (IsBadWritePtr(pHandle, sizeof(HANDLE)) ||
            IsBadWritePtr(pOverLapped, sizeof(OVERLAPPED))) {
            return ERROR_INVALID_PARAMETER;
        }

        *pHandle = g_hIPDriverHandle;

        if (*pHandle == INVALID_HANDLE_VALUE) {
            return ERROR_OPEN_FAILED;
        }


        b = DeviceIoControl(
                *pHandle,
                IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST,
                NULL,
                0,
                NULL,
                0,
                &temp,
                pOverLapped
                );

        if (!b) { return GetLastError(); }

   } else {

        Trace0(ERR,"DisableMediaSense: synchronous request");

        b = DeviceIoControl(
                g_hIPDriverHandle,
                IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST,
                NULL,
                0,
                NULL,
                0,
                &temp,
                NULL
                );

        if (!b) {
            dwResult = GetLastError();
            Trace1(ERR,"DisableMediaSense: DeviceIoControl=%d", dwResult);
            return dwResult;
        }
   }

   return NO_ERROR;
#endif
}

DWORD WINAPI
RestoreMediaSense(OVERLAPPED* pOverlapped, LPDWORD lpdwEnableCount OPTIONAL)
{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
    BOOL b;
    DWORD EnableCount;
    DWORD temp;
    if (lpdwEnableCount && IsBadWritePtr(lpdwEnableCount, sizeof(DWORD))) {
        return ERROR_INVALID_PARAMETER;
    }
    if (g_hIPDriverHandle == INVALID_HANDLE_VALUE) {
        return ERROR_OPEN_FAILED;
    }
    b = DeviceIoControl(
            g_hIPDriverHandle,
            IOCTL_IP_ENABLE_MEDIA_SENSE_REQUEST,
            (PVOID)&pOverlapped,
            sizeof(PVOID),
            &EnableCount,
            sizeof(DWORD),
            &temp,
            NULL
            );
    if (!b) { return GetLastError(); }
    if (lpdwEnableCount) { *lpdwEnableCount = EnableCount; }
    return NO_ERROR;
#endif
}



#if !defined(NT4) && !defined(_WIN95_)
extern DWORD GetFixedInfoEx(PFIXED_INFO pFixedInfo, PULONG pOutBufLen);
extern DWORD GetAdapterInfoEx(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
extern DWORD GetAdapterAddressesEx(ULONG Family, DWORD Flags, PIP_ADAPTER_ADDRESSES pAdapterInfo, PULONG pOutBufLen);
#endif

#if !defined(NT4) && !defined(CHICAGO)
extern DWORD GetPerAdapterInfoEx(ULONG IfIndex, PIP_PER_ADAPTER_INFO pPerAdapterInfo, PULONG pOutBufLen);
#endif


DWORD
GetNetworkParams(PFIXED_INFO pFixedInfo, PULONG pOutBufLen)
{
#if !defined(NT4) && !defined(_WIN95_)
    CheckTcpipState();

    if (IsBadReadPtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pFixedInfo != NULL &&
        IsBadWritePtr(pFixedInfo, sizeof(FIXED_INFO))) {
        return ERROR_INVALID_PARAMETER;
    }

    return GetFixedInfoEx(pFixedInfo, pOutBufLen);
#else
    return ERROR_NOT_SUPPORTED;
#endif
}

DWORD 
GetAdaptersAddresses(ULONG Family, DWORD Flags, PVOID Reserved,
                     PIP_ADAPTER_ADDRESSES pAdapterAddresses,
                     PULONG pOutBufLen)
{
#if !defined(NT4) && !defined(_WIN95_)
    CheckTcpipState();

    if (IsBadReadPtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (Reserved != NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pAdapterAddresses != NULL &&
        IsBadWritePtr(pAdapterAddresses, sizeof(IP_ADAPTER_ADDRESSES))) {
        return ERROR_INVALID_PARAMETER;
    }

    return GetAdapterAddressesEx(Family, Flags, pAdapterAddresses, pOutBufLen);
#else
    return ERROR_NOT_SUPPORTED;
#endif
}


DWORD
GetAdaptersInfo(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen)
{
#if !defined(NT4) && !defined(_WIN95_)
    // call the init
    CheckTcpipState();

    if (IsBadReadPtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pAdapterInfo != NULL &&
        IsBadWritePtr(pAdapterInfo, sizeof(IP_ADAPTER_INFO))) {
        return ERROR_INVALID_PARAMETER;
    }

    return GetAdapterInfoEx(pAdapterInfo, pOutBufLen);
#else
    return ERROR_NOT_SUPPORTED;
#endif
}


DWORD
GetPerAdapterInfo(ULONG IfIndex, PIP_PER_ADAPTER_INFO pPerAdapterInfo,
                  PULONG pOutBufLen)
{
#if !defined(NT4) && !defined(CHICAGO)

    CheckTcpipState();

    if (IsBadReadPtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(pOutBufLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pPerAdapterInfo != NULL &&
        IsBadWritePtr(pPerAdapterInfo, sizeof(IP_PER_ADAPTER_INFO))) {
        return ERROR_INVALID_PARAMETER;
    }

    return GetPerAdapterInfoEx(IfIndex, pPerAdapterInfo, pOutBufLen);
#else
    return ERROR_NOT_SUPPORTED;
#endif
}

extern DWORD
DhcpReleaseParameters(
    LPWSTR AdapterName
    );

extern DWORD
DhcpAcquireParameters(
    LPWSTR AdapterName);

#define TCP_EXPORT_STRING_PREFIX L"\\DEVICE\\TCPIP_"

DWORD
IpReleaseAddress(PIP_ADAPTER_INDEX_MAP AdapterInfo)
{
#if defined(NT4) || defined(_WIN95_)
    return ERROR_NOT_SUPPORTED;
#else
    DWORD status;

    if (!AdapterInfo) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadReadPtr(AdapterInfo, sizeof(IP_ADAPTER_INDEX_MAP))) {
        return ERROR_INVALID_PARAMETER;
    }

#ifdef CHICAGO
    {
    // Convert the string to a widechar name
    WCHAR  Name[11];
    uint   i;
    uint   Index = AdapterInfo->Index;

    i = sizeof(Name)/sizeof(Name[0]);
    Name[--i] = L'\0';
    while (i > 0 ) {
        Name[--i] = L'0' + (Index%10);
        Index /= 10;
    }
    status = DhcpReleaseParameters(Name);
    }
#else
    {
    LPWSTR tmpstr;

    if (wcslen(AdapterInfo->Name) <= wcslen(TCP_EXPORT_STRING_PREFIX)) {
        return ERROR_INVALID_PARAMETER;
    }

    tmpstr = AdapterInfo->Name + wcslen(TCP_EXPORT_STRING_PREFIX);

    __try {
        status = DhcpReleaseParameters(tmpstr);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_PROC_NOT_FOUND;
    }
    }
#endif
    return(status);
#endif
}


DWORD
IpRenewAddress(PIP_ADAPTER_INDEX_MAP AdapterInfo)
{
#if defined(NT4) || defined(_WIN95_)
    return ERROR_NOT_SUPPORTED;
#else
    DWORD status;

    if (!AdapterInfo) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadReadPtr(AdapterInfo, sizeof(IP_ADAPTER_INDEX_MAP))) {
        return ERROR_INVALID_PARAMETER;
    }

#ifdef CHICAGO
    {
    // Convert the string to a widechar name
    WCHAR  Name[11];
    uint   i;
    uint   Index = AdapterInfo->Index;

    i = sizeof(Name)/sizeof(Name[0]);
    Name[--i] = L'\0';
    while (i > 0 ) {
        Name[--i] = L'0' + (Index%10);
        Index /= 10;
    }
    status = DhcpAcquireParameters(Name);
    }
#else
    {
    LPWSTR tmpstr;

    if (wcslen(AdapterInfo->Name) <= wcslen(TCP_EXPORT_STRING_PREFIX)) {
        return ERROR_INVALID_PARAMETER;
    }

    tmpstr = AdapterInfo->Name + wcslen(TCP_EXPORT_STRING_PREFIX);

    __try {
        status = DhcpAcquireParameters(tmpstr);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_PROC_NOT_FOUND;
    }
  }
#endif
    return(status);
#endif
}

DWORD
SendARP(IPAddr DestIP, IPAddr SrcIP, PULONG pMacAddr, PULONG  PhyAddrLen)
{
#if defined(NT4) || defined(_WIN95_)
    return ERROR_NOT_SUPPORTED;
#else
    ARP_SEND_REPLY    requestBuffer;
    DWORD requestBufferSize = sizeof(requestBuffer);
    DWORD status;

    requestBuffer.DestAddress = DestIP;
    requestBuffer.SrcAddress = SrcIP;

    if (IsBadWritePtr(pMacAddr, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadWritePtr(PhyAddrLen, sizeof(ULONG))) {
        return ERROR_INVALID_PARAMETER;
    }

    status = TCPSendIoctl(g_hIPGetDriverHandle,
                          IOCTL_ARP_SEND_REQUEST,
                          &requestBuffer,
                          &requestBufferSize,
                          pMacAddr,
                          PhyAddrLen);
    return(status);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\icmp.c ===
/*++

Copyright (c) 1991-1997  Microsoft Corporation
Module Name: //KERNEL/RAZZLE3/src/sockets/tcpcmd/icmp/icmp.c
Abstract: Definitions of the ICMP Echo request API.
Author: Mike Massa (mikemas)           Dec 30, 1993
Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     12-30-93    created
    RameshV     20-Jul-97   new async function IcmpSendEcho2

Notes:
   In the functions do_echo_req/do_echo_rep the
   precedence/tos bits are not used as defined RFC 1349.
                                          -- MohsinA,    30-Jul-97
--*/

#include "inc.h"
#pragma hdrstop

#include <align.h>
#include <icmp.h>
#include <icmpapi.h>
#include <icmpif.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <wscntl.h>
#include <ntddip6.h>

//
// Constants
//
#define PLATFORM_NT           0x0
#define PLATFORM_VXD          0x1
#define VXD_HANDLE_VALUE      0xDFFFFFFF

//
// Common Global variables
//
DWORD      Platform = 0xFFFFFFFF;

// VxD external function pointers
//
LPWSCONTROL  wsControl = NULL;


__inline void
CopyTDIFromSA6(TDI_ADDRESS_IP6 *To, SOCKADDR_IN6 *From)
{
    memcpy(To, &From->sin6_port, sizeof *To);
}

__inline void
CopySAFromTDI6(SOCKADDR_IN6 *To, TDI_ADDRESS_IP6 *From)
{
    To->sin6_family = AF_INET6;
    memcpy(&To->sin6_port, From, sizeof *From);
}


/////////////////////////////////////////////////////////////////////////////
//
// Public functions
//
/////////////////////////////////////////////////////////////////////////////
HANDLE
WINAPI
IcmpCreateFile(
    VOID
    )

/*++

Routine Description:

    Opens a handle on which ICMP Echo Requests can be issued.

Arguments:

    None.

Return Value:

    An open file handle or INVALID_HANDLE_VALUE. Extended error information
    is available by calling GetLastError().

Notes:

    This function is effectively a no-op for the VxD platform.

--*/

{
    HANDLE   IcmpHandle = INVALID_HANDLE_VALUE;


    if (Platform == PLATFORM_NT) {
        OBJECT_ATTRIBUTES   objectAttributes;
        IO_STATUS_BLOCK     ioStatusBlock;
        UNICODE_STRING      nameString;
        NTSTATUS            status;

        //
        // Open a Handle to the IP driver.
        //
        RtlInitUnicodeString(&nameString, DD_IP_DEVICE_NAME);

        InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status = NtCreateFile(
                    &IcmpHandle,
                    GENERIC_EXECUTE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(status)) {
            SetLastError(RtlNtStatusToDosError(status));
            IcmpHandle = INVALID_HANDLE_VALUE;
        }
    }
    else {
        IcmpHandle = LongToHandle(VXD_HANDLE_VALUE);
    }

    return(IcmpHandle);

}  // IcmpCreateFile

HANDLE
WINAPI
Icmp6CreateFile(
    VOID
    )

/*++

Routine Description:

    Opens a handle on which ICMPv6 Echo Requests can be issued.

Arguments:

    None.

Return Value:

    An open file handle or INVALID_HANDLE_VALUE. Extended error information
    is available by calling GetLastError().

--*/

{
    HANDLE   IcmpHandle = INVALID_HANDLE_VALUE;


    if (Platform == PLATFORM_NT) {
        OBJECT_ATTRIBUTES   objectAttributes;
        IO_STATUS_BLOCK     ioStatusBlock;
        UNICODE_STRING      nameString;
        NTSTATUS            status;

        //
        // Open a Handle to the IPv6 driver.
        //
        RtlInitUnicodeString(&nameString, DD_IPV6_DEVICE_NAME);

        InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status = NtCreateFile(
                    &IcmpHandle,
                    GENERIC_EXECUTE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(status)) {
            SetLastError(RtlNtStatusToDosError(status));
            IcmpHandle = INVALID_HANDLE_VALUE;
        }
    }
    else {
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        IcmpHandle = INVALID_HANDLE_VALUE;
    }

    return(IcmpHandle);

}

BOOL
WINAPI
IcmpCloseHandle(
    HANDLE  IcmpHandle
    )

/*++

Routine Description:

    Closes a handle opened by IcmpCreateFile.

Arguments:

    IcmpHandle  - The handle to close.

Return Value:

    TRUE if the handle was closed successfully, otherwise FALSE. Extended
       error information is available by calling GetLastError().

Notes:

    This function is a no-op for the VxD platform.

--*/

{
    if (Platform == PLATFORM_NT) {
        NTSTATUS status;


        status = NtClose(IcmpHandle);

        if (!NT_SUCCESS(status)) {
            SetLastError(RtlNtStatusToDosError(status));
            return(FALSE);
        }
    }

    return(TRUE);

}  // IcmpCloseHandle


DWORD
IcmpParseReplies(
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize
    )

/*++

Routine Description:

    Parses the reply buffer provided and returns the number of ICMP responses found.

Arguments:

    ReplyBuffer            - This must be the same buffer that was passed to IcmpSendEcho2
                             This is rewritten to hold an array of ICMP_ECHO_REPLY structures.
                             (i.e. the type is PICMP_ECHO_REPLY).

    ReplySize              - This must be the size of the above buffer.

Return Value:
    Returns the number of ICMP responses found.  If there is an errors, return value is
    zero.  The error can be determined by a call to GetLastError.

--*/
{
    DWORD                numberOfReplies = 0;
    PICMP_ECHO_REPLY     reply;
    unsigned short       i;

    reply = ((PICMP_ECHO_REPLY) ReplyBuffer);

    if( NULL == reply || 0 == ReplySize ) {
        //
        // Invalid parameter passed. But we ignore this and just return # of replies =0
        //
        return 0;
    }

    //
    // Convert new IP status IP_NEGOTIATING_IPSEC to IP_DEST_HOST_UNREACHABLE.
    //
    if (reply->Status == IP_NEGOTIATING_IPSEC) {
        reply->Status = IP_DEST_HOST_UNREACHABLE;
    }

    //
    // The reserved field of the first reply contains the number of replies.
    //
    numberOfReplies = reply->Reserved;
    reply->Reserved = 0;

    if (numberOfReplies == 0) {
        //
        // Internal IP error. The error code is in the first reply slot.
        //
        SetLastError(reply->Status);
    }
    else {
        //
        // Walk through the replies and convert the data offsets to user mode
        // pointers.
        //

        for (i=0; i<numberOfReplies; i++, reply++) {
            reply->Data = ((UCHAR *) reply) + ((ULONG_PTR) reply->Data);
            reply->Options.OptionsData =
                ((UCHAR FAR *) reply) + ((ULONG_PTR) reply->Options.OptionsData);
        }
    }

    return(numberOfReplies);

}  // IcmpParseReplies


DWORD
IcmpParseReplies2(
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize
    )

/*++

Routine Description:

    Parses the reply buffer provided and returns the number of ICMP responses found.

Arguments:

    ReplyBuffer            - This must be the same buffer that was passed to IcmpSendEcho2
                             This is rewritten to hold an array of ICMP_ECHO_REPLY structures.
                             (i.e. the type is PICMP_ECHO_REPLY).

    ReplySize              - This must be the size of the above buffer.

Return Value:
    Returns the number of ICMP responses found.  If there is an errors, return value is
    zero.  The error can be determined by a call to GetLastError.

--*/
{
    DWORD                numberOfReplies = 0;
    PICMP_ECHO_REPLY     reply;
    unsigned short       i;

    reply = ((PICMP_ECHO_REPLY) ReplyBuffer);

    if( NULL == reply || 0 == ReplySize ) {
        //
        // Invalid parameter passed. But we ignore this and just return # of replies =0
        //
        return 0;
    }


    //
    // The reserved field of the first reply contains the number of replies.
    //
    numberOfReplies = reply->Reserved;
    reply->Reserved = 0;

    if (numberOfReplies == 0) {
        //
        // Internal IP error. The error code is in the first reply slot.
        //
        SetLastError(reply->Status);
    }
    else {
        //
        // Walk through the replies and convert the data offsets to user mode
        // pointers.
        //

        for (i=0; i<numberOfReplies; i++, reply++) {
            reply->Data = ((UCHAR *) reply) + ((ULONG_PTR) reply->Data);
            reply->Options.OptionsData =
                ((UCHAR FAR *) reply) + ((ULONG_PTR) reply->Options.OptionsData);
        }
    }

    return(numberOfReplies);

}  // IcmpParseReplies

DWORD
WINAPI
IcmpSendEcho(
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    )

/*++

Routine Description:

    Sends an ICMP Echo request and returns one or more replies. The
    call returns when the timeout has expired or the reply buffer
    is filled.

Arguments:

    IcmpHandle           - An open handle returned by ICMPCreateFile.

    DestinationAddress   - The destination of the echo request.

    RequestData          - A buffer containing the data to send in the
                           request.

    RequestSize          - The number of bytes in the request data buffer.

    RequestOptions       - Pointer to the IP header options for the request.
                           May be NULL.

    ReplyBuffer          - A buffer to hold any replies to the request.
                           On return, the buffer will contain an array of
                           ICMP_ECHO_REPLY structures followed by options
                           and data. The buffer must be large enough to
                           hold at least one ICMP_ECHO_REPLY structure.
                           It should be large enough to also hold
                           8 more bytes of data - this is the size of
                           an ICMP error message.

    ReplySize            - The size in bytes of the reply buffer.

    Timeout              - The time in milliseconds to wait for replies.

Return Value:

    Returns the number of replies received and stored in ReplyBuffer. If
    the return value is zero, extended error information is available
    via GetLastError().

--*/

{
    PICMP_ECHO_REQUEST   requestBuffer = NULL;
    ULONG                requestBufferSize;
    DWORD                numberOfReplies = 0;
    PICMP_ECHO_REPLY     reply;
    unsigned short       i;


    if (ReplySize < sizeof(ICMP_ECHO_REPLY)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(0);
    }

    requestBufferSize = sizeof(ICMP_ECHO_REQUEST) + RequestSize;

    if (RequestOptions != NULL) {
        requestBufferSize += RequestOptions->OptionsSize;
    }

    if (requestBufferSize < ReplySize) {
        requestBufferSize = ReplySize;
    }

    requestBuffer = LocalAlloc(LMEM_FIXED, requestBufferSize);

    if (requestBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0);
    }

    //
    // Initialize the input buffer.
    //
    requestBuffer->Address = DestinationAddress;
    requestBuffer->Timeout = Timeout;
    requestBuffer->DataSize = RequestSize;

    requestBuffer->OptionsOffset = sizeof(ICMP_ECHO_REQUEST);

    if (RequestOptions != NULL) {
        requestBuffer->OptionsValid = 1;
        requestBuffer->Ttl = RequestOptions->Ttl;
        requestBuffer->Tos = RequestOptions->Tos;
        requestBuffer->Flags = RequestOptions->Flags;
        requestBuffer->OptionsSize = RequestOptions->OptionsSize;

        if (RequestOptions->OptionsSize > 0) {

            CopyMemory(
                ((UCHAR *) requestBuffer) + requestBuffer->OptionsOffset,
                RequestOptions->OptionsData,
                RequestOptions->OptionsSize
                );
        }
    }
    else {
        requestBuffer->OptionsValid = 0;
        requestBuffer->OptionsSize = 0;
    }

    requestBuffer->DataOffset = requestBuffer->OptionsOffset +
                                requestBuffer->OptionsSize;

    if (RequestSize > 0) {

        CopyMemory(
            ((UCHAR *)requestBuffer) + requestBuffer->DataOffset,
            RequestData,
            RequestSize
            );
    }

    if (Platform == PLATFORM_NT) {
        IO_STATUS_BLOCK      ioStatusBlock;
        NTSTATUS             status;
        HANDLE               eventHandle;

        eventHandle = CreateEvent(
                          NULL,    // default security
                          FALSE,   // auto reset
                          FALSE,   // initially non-signalled
                          NULL     // unnamed
                          );

        if (NULL == eventHandle) {
            goto error_exit;
        }

        status = NtDeviceIoControlFile(
                     IcmpHandle,                // Driver handle
                     eventHandle,               // Event
                     NULL,                      // APC Routine
                     NULL,                      // APC context
                     &ioStatusBlock,            // Status block
                     IOCTL_ICMP_ECHO_REQUEST,   // Control code
                     requestBuffer,             // Input buffer
                     requestBufferSize,         // Input buffer size
                     ReplyBuffer,               // Output buffer
                     ReplySize                  // Output buffer size
                     );

        if (status == STATUS_PENDING) {
            status = NtWaitForSingleObject(
                         eventHandle,
                         FALSE,
                         NULL
                         );
        }

        CloseHandle(eventHandle);

        if (status != STATUS_SUCCESS) {
            SetLastError(RtlNtStatusToDosError(status));
            goto error_exit;
        }
    }
    else {
        //
        // VxD Platform
        //
        DWORD  status;
        ULONG  replyBufferSize = ReplySize;

        status = (*wsControl)(
                     IPPROTO_TCP,
                     WSCNTL_TCPIP_ICMP_ECHO,
                     requestBuffer,
                     &requestBufferSize,
                     ReplyBuffer,
                     &replyBufferSize
                     );

        if (status != NO_ERROR) {
            SetLastError(status);
            goto error_exit;
        }
    }

    numberOfReplies = IcmpParseReplies(ReplyBuffer, ReplySize);

error_exit:

    LocalFree(requestBuffer);

    return(numberOfReplies);

}  // IcmpSendEcho


DWORD
WINAPI
IcmpSendEcho2(
    HANDLE                   IcmpHandle,
    HANDLE                   Event,
    PIO_APC_ROUTINE          ApcRoutine,
    PVOID                    ApcContext,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    )

/*++

Routine Description:

    Sends an ICMP Echo request and the call returns either immediately
    (if Event or ApcRoutine is NonNULL) or returns after the specified
    timeout.   The ReplyBuffer contains the ICMP responses, if any.

Arguments:

    IcmpHandle           - An open handle returned by ICMPCreateFile.

    Event                - This is the event to be signalled whenever an IcmpResponse
                           comes in.

    ApcRoutine           - This routine would be called when the calling thread
                           is in an alertable thread and an ICMP reply comes in.

    ApcContext           - This optional parameter is given to the ApcRoutine when
                           this call succeeds.

    DestinationAddress   - The destination of the echo request.

    RequestData          - A buffer containing the data to send in the
                           request.

    RequestSize          - The number of bytes in the request data buffer.

    RequestOptions       - Pointer to the IP header options for the request.
                           May be NULL.

    ReplyBuffer          - A buffer to hold any replies to the request.
                           On return, the buffer will contain an array of
                           ICMP_ECHO_REPLY structures followed by options
                           and data. The buffer must be large enough to
                           hold at least one ICMP_ECHO_REPLY structure.
                           It should be large enough to also hold
                           8 more bytes of data - this is the size of
                           an ICMP error message + this should also have
                           space for IO_STATUS_BLOCK which requires 8 or
                           16 bytes...

    ReplySize            - The size in bytes of the reply buffer.

    Timeout              - The time in milliseconds to wait for replies.
                           This is NOT used if ApcRoutine is not NULL or if Event
                           is not NULL.

Return Value:

    Returns the number of replies received and stored in ReplyBuffer. If
    the return value is zero, extended error information is available
    via GetLastError().

Remarks:

    On NT platforms,
    If used Asynchronously (either ApcRoutine or Event is specified), then
    ReplyBuffer and ReplySize are still needed.  This is where the response
    comes in.
    ICMP Response data is copied to the ReplyBuffer provided, and the caller of
    this function has to parse it asynchronously.  The function IcmpParseReply
    is provided for this purpose.

    On non-NT platforms,
    Event, ApcRoutine and ApcContext are IGNORED.

--*/

{
    PICMP_ECHO_REQUEST   requestBuffer = NULL;
    ULONG                requestBufferSize;
    DWORD                numberOfReplies = 0;
    unsigned short       i;
    BOOL                 Asynchronous;

    Asynchronous = (Platform == PLATFORM_NT && (Event || ApcRoutine));

    if (ReplySize < sizeof(ICMP_ECHO_REPLY)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(0);
    }

    requestBufferSize = sizeof(ICMP_ECHO_REQUEST) + RequestSize;

    if (RequestOptions != NULL) {
        requestBufferSize += RequestOptions->OptionsSize;
    }

    if (requestBufferSize < ReplySize) {
        requestBufferSize = ReplySize;
    }

    requestBuffer = LocalAlloc(LMEM_FIXED, requestBufferSize);

    if (requestBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0);
    }

    //
    // Initialize the input buffer.
    //
    requestBuffer->Address = DestinationAddress;
    requestBuffer->Timeout = Timeout;
    requestBuffer->DataSize = RequestSize;

    requestBuffer->OptionsOffset = sizeof(ICMP_ECHO_REQUEST);

    if (RequestOptions != NULL) {
        requestBuffer->OptionsValid = 1;
        requestBuffer->Ttl = RequestOptions->Ttl;
        requestBuffer->Tos = RequestOptions->Tos;
        requestBuffer->Flags = RequestOptions->Flags;
        requestBuffer->OptionsSize = RequestOptions->OptionsSize;

        if (RequestOptions->OptionsSize > 0) {

            CopyMemory(
                ((UCHAR *) requestBuffer) + requestBuffer->OptionsOffset,
                RequestOptions->OptionsData,
                RequestOptions->OptionsSize
                );
        }
    }
    else {
        requestBuffer->OptionsValid = 0;
        requestBuffer->OptionsSize = 0;
    }

    requestBuffer->DataOffset = requestBuffer->OptionsOffset +
                                requestBuffer->OptionsSize;

    if (RequestSize > 0) {

        CopyMemory(
            ((UCHAR *)requestBuffer) + requestBuffer->DataOffset,
            RequestData,
            RequestSize
            );
    }

    if (Platform == PLATFORM_NT) {
        IO_STATUS_BLOCK      *pioStatusBlock;
        NTSTATUS             status;
        HANDLE               eventHandle;

        //
        // allocate status block on the reply buffer..
        //

        pioStatusBlock = (IO_STATUS_BLOCK*)((LPBYTE)ReplyBuffer + ReplySize);
        pioStatusBlock --;
        pioStatusBlock = ROUND_DOWN_POINTER(pioStatusBlock, ALIGN_WORST);
        ReplySize = (ULONG)(((LPBYTE)pioStatusBlock) - (LPBYTE)ReplyBuffer );
        if( (PVOID)pioStatusBlock < ReplyBuffer
            || ReplySize < sizeof(ICMP_ECHO_REPLY) ) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto error_exit;
        }

        if(!Asynchronous) {         // Normal synchronous.
            eventHandle = CreateEvent(
                          NULL,     // default security
                          FALSE,    // auto reset
                          FALSE,    // initially non-signalled
                          NULL      // unnamed
                          );

            if (NULL == eventHandle) {
                goto error_exit;
            }
        } else {                   // Asynchronous call.
            eventHandle = Event;   // Use specified Event.
        }

        status = NtDeviceIoControlFile(
                     IcmpHandle,                // Driver handle
                     eventHandle,               // Event
                     ApcRoutine,                // APC Routine
                     ApcContext,                // APC context
                     pioStatusBlock,            // Status block
                     IOCTL_ICMP_ECHO_REQUEST,   // Control code
                     requestBuffer,             // Input buffer
                     requestBufferSize,         // Input buffer size
                     ReplyBuffer,               // Output buffer
                     ReplySize                  // Output buffer size
                     );

        if (Asynchronous) {
            // Asynchronous calls.  We cannot give any information.
            // We let the user do the other work.
            SetLastError(RtlNtStatusToDosError(status));
            goto error_exit;
        }

        if (status == STATUS_PENDING) {
            status = NtWaitForSingleObject(
                         eventHandle,
                         FALSE,
                         NULL
                         );

        }

        CloseHandle(eventHandle);

        if (status != STATUS_SUCCESS) {
            SetLastError(RtlNtStatusToDosError(status));
            goto error_exit;
        }
    }
    else {
        //
        // VxD Platform
        //
        DWORD  status;
        ULONG  replyBufferSize = ReplySize;

        status = (*wsControl)(
                     IPPROTO_TCP,
                     WSCNTL_TCPIP_ICMP_ECHO,
                     requestBuffer,
                     &requestBufferSize,
                     ReplyBuffer,
                     &replyBufferSize
                     );

        if (status != NO_ERROR) {
            SetLastError(status);
            goto error_exit;
        }
    }

    numberOfReplies = IcmpParseReplies2(ReplyBuffer, ReplySize);

error_exit:

    LocalFree(requestBuffer);

    return(numberOfReplies);

}  // IcmpSendEcho2

DWORD
Icmp6ParseReplies(
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize
    )

/*++

Routine Description:

    Parses the reply buffer provided and returns the number of ICMPv6 responses 
    found.

Arguments:

    ReplyBuffer  - This must be the same buffer that was passed to 
                   Icmp6SendEcho2.  This is written to hold an array of 
                   ICMPV6_ECHO_REPLY structures (i.e., the type is 
                   PICMPV6_ECHO_REPLY).

    ReplySize    - This must be the size of the above buffer.

Return Value:
    Returns the number of ICMPv6 responses found.  If there is an error, 
    return value is zero.  The error can be determined by a call to 
    GetLastError.

--*/

{
    PICMPV6_ECHO_REPLY   reply;
    unsigned short       i;

    reply = ((PICMPV6_ECHO_REPLY) ReplyBuffer);

    if( NULL == reply || 0 == ReplySize ) {
        //
        // Invalid parameter passed. But we ignore this and just return # of 
        // replies =0
        //
        return 0;
    }

    //
    // Convert new IP status IP_NEGOTIATING_IPSEC to IP_DEST_HOST_UNREACHABLE.
    //
    if (reply->Status == IP_NEGOTIATING_IPSEC) {
        reply->Status = IP_DEST_HOST_UNREACHABLE;
    }

    if ((reply->Status == IP_SUCCESS) || (reply->Status == IP_TTL_EXPIRED_TRANSIT)) {
        return 1;
    } else {
        //
        // Internal IP error. The error code is in the first reply slot.
        //
        SetLastError(reply->Status);
        return 0;
    }
}

DWORD
WINAPI
Icmp6SendEcho2(
    HANDLE                   IcmpHandle,
    HANDLE                   Event,
    PIO_APC_ROUTINE          ApcRoutine,
    PVOID                    ApcContext,
    LPSOCKADDR_IN6           SourceAddress,
    LPSOCKADDR_IN6           DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    )

/*++

Routine Description:

    Sends an ICMPv6 Echo request and the call returns either immediately
    (if Event or ApcRoutine is NonNULL) or returns after the specified
    timeout.   The ReplyBuffer contains the ICMPv6 responses, if any.

Arguments:

    IcmpHandle           - An open handle returned by ICMP6CreateFile.

    Event                - This is the event to be signalled whenever an 
                           IcmpResponse comes in.

    ApcRoutine           - This routine would be called when the calling thread
                           is in an alertable thread and an ICMPv6 reply comes 
                           in.

    ApcContext           - This optional parameter is given to the ApcRoutine 
                           when this call succeeds.

    DestinationAddress   - The destination of the echo request.

    RequestData          - A buffer containing the data to send in the
                           request.

    RequestSize          - The number of bytes in the request data buffer.

    RequestOptions       - Pointer to the IPv6 header options for the request.
                           May be NULL.

    ReplyBuffer          - A buffer to hold any replies to the request.
                           On return, the buffer will contain an array of
                           ICMPV6_ECHO_REPLY structures followed by options
                           and data. The buffer must be large enough to
                           hold at least one ICMPV6_ECHO_REPLY structure.
                           It should be large enough to also hold
                           8 more bytes of data - this is the size of
                           an ICMPv6 error message + this should also have
                           space for IO_STATUS_BLOCK which requires 8 or
                           16 bytes...

    ReplySize            - The size in bytes of the reply buffer.

    Timeout              - The time in milliseconds to wait for replies.
                           This is NOT used if ApcRoutine is not NULL or if 
                           Event is not NULL.

Return Value:

    Returns the number of replies received and stored in ReplyBuffer. If
    the return value is zero, extended error information is available
    via GetLastError().

Remarks:

    If used Asynchronously (either ApcRoutine or Event is specified), then
    ReplyBuffer and ReplySize are still needed.  This is where the response
    comes in.
    ICMP Response data is copied to the ReplyBuffer provided, and the caller of
    this function has to parse it asynchronously.  The function Icmp6ParseReply
    is provided for this purpose.

--*/

{
    PICMPV6_ECHO_REQUEST requestBuffer = NULL;
    ULONG                requestBufferSize;
    DWORD                numberOfReplies = 0;
    unsigned short       i;
    BOOL                 Asynchronous;
    IO_STATUS_BLOCK      *pioStatusBlock;
    NTSTATUS             status;
    HANDLE               eventHandle;

    Asynchronous = (Platform == PLATFORM_NT && (Event || ApcRoutine));

    if (ReplySize < sizeof(ICMPV6_ECHO_REPLY)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(0);
    }

    requestBufferSize = sizeof(ICMPV6_ECHO_REQUEST) + RequestSize;

    requestBuffer = LocalAlloc(LMEM_FIXED, requestBufferSize);

    if (requestBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0);
    }

    if (Platform != PLATFORM_NT) {
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        goto error_exit;
    }

    //
    // Initialize the input buffer.
    //
    CopyTDIFromSA6(&requestBuffer->DstAddress, DestinationAddress);
    CopyTDIFromSA6(&requestBuffer->SrcAddress, SourceAddress);
    requestBuffer->Timeout = Timeout;
    requestBuffer->TTL = RequestOptions->Ttl;
    requestBuffer->Flags = RequestOptions->Flags;

    if (RequestSize > 0) {

        CopyMemory(
            (UCHAR *)(requestBuffer + 1),
            RequestData,
            RequestSize
            );
    }

    //
    // allocate status block on the reply buffer..
    //

    pioStatusBlock = (IO_STATUS_BLOCK*)((LPBYTE)ReplyBuffer + ReplySize);
    pioStatusBlock --;
    pioStatusBlock = ROUND_DOWN_POINTER(pioStatusBlock, ALIGN_WORST);
    ReplySize = (ULONG)(((LPBYTE)pioStatusBlock) - (LPBYTE)ReplyBuffer );
    if( (PVOID)pioStatusBlock < ReplyBuffer
        || ReplySize < sizeof(ICMPV6_ECHO_REPLY) ) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto error_exit;
    }

    if(!Asynchronous) {         // Normal synchronous.
        eventHandle = CreateEvent(
                      NULL,     // default security
                      FALSE,    // auto reset
                      FALSE,    // initially non-signalled
                      NULL      // unnamed
                      );

        if (NULL == eventHandle) {
            goto error_exit;
        }
    } else {                   // Asynchronous call.
        eventHandle = Event;   // Use specified Event.
    }

    status = NtDeviceIoControlFile(
                 IcmpHandle,                // Driver handle
                 eventHandle,               // Event
                 ApcRoutine,                // APC Routine
                 ApcContext,                // APC context
                 pioStatusBlock,            // Status block
                 IOCTL_ICMPV6_ECHO_REQUEST, // Control code
                 requestBuffer,             // Input buffer
                 requestBufferSize,         // Input buffer size
                 ReplyBuffer,               // Output buffer
                 ReplySize                  // Output buffer size
                 );

    if (Asynchronous) {
        // Asynchronous calls.  We cannot give any information.
        // We let the user do the other work.
        SetLastError(RtlNtStatusToDosError(status));
        goto error_exit;
    }

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     eventHandle,
                     FALSE,
                     NULL
                     );

    }

    CloseHandle(eventHandle);

    if (status != STATUS_SUCCESS) {
        SetLastError(RtlNtStatusToDosError(status));
        goto error_exit;
    }

    numberOfReplies = Icmp6ParseReplies(ReplyBuffer, ReplySize);

error_exit:

    LocalFree(requestBuffer);

    return(numberOfReplies);

}

//
// Constants
//

#define PING_WAIT     1000
#define DEFAULT_TTL   32

//
// Local type definitions
//
typedef struct icmp_local_storage {
    struct icmp_local_storage  *Next;
    HANDLE                      IcmpHandle;
    LPVOID                      ReplyBuffer;
    DWORD                       NumberOfReplies;
    DWORD                       Status;
} ICMP_LOCAL_STORAGE, *PICMP_LOCAL_STORAGE;

typedef struct status_table {
    IP_STATUS   NewStatus;
    int         OldStatus;
} STATUS_TABLE, *PSTATUS_TABLE;


//
// Global variables
//
CRITICAL_SECTION     g_IcmpLock;
PICMP_LOCAL_STORAGE  RequestHead = NULL;
STATUS_TABLE         StatusTable[] = {
{ IP_SUCCESS,               ECHO_REPLY      },
{ IP_DEST_NET_UNREACHABLE,  DEST_UNR        },
{ IP_DEST_HOST_UNREACHABLE, DEST_UNR        },
{ IP_NEGOTIATING_IPSEC,     DEST_UNR        },
{ IP_DEST_PROT_UNREACHABLE, DEST_UNR        },
{ IP_TTL_EXPIRED_TRANSIT,   TIME_EXCEEDED   },
{ IP_TTL_EXPIRED_REASSEM,   TIME_EXCEEDED   },
{ IP_PARAM_PROBLEM,         PARAMETER_ERROR },
{ IP_BAD_ROUTE,             PARAMETER_ERROR },
{ IP_BAD_OPTION,            PARAMETER_ERROR },
{ IP_BUF_TOO_SMALL,         PARAMETER_ERROR },
{ IP_PACKET_TOO_BIG,        PARAMETER_ERROR },
{ IP_BAD_DESTINATION,       PARAMETER_ERROR },
{ IP_GENERAL_FAILURE,       POLL_FAILED     }
};

HANDLE
STRMAPI
register_icmp(
    void
    )
{
    HANDLE               icmpHandle;

    icmpHandle = IcmpCreateFile();

    if (icmpHandle == INVALID_HANDLE_VALUE) {
        SetLastError(ICMP_OPEN_ERROR);
        return(ICMP_ERROR);
    }

    return(icmpHandle);

}  // register_icmp


int
STRMAPI
do_echo_req(
    HANDLE  fd,
    long    addr,
    char   *data,
    int     amount,
    char   *optptr,
    int     optlen,
    int     df,
    int     ttl,
    int     tos,
    int     precedence
    )
{
    PICMP_LOCAL_STORAGE    localStorage;
    DWORD                  replySize;
    IP_OPTION_INFORMATION  options;
    LPVOID                 replyBuffer;


    replySize = sizeof(ICMP_ECHO_REPLY) + amount + optlen;

    //
    // Allocate a buffer to hold the reply.
    //
    localStorage = (PICMP_LOCAL_STORAGE) LocalAlloc(
                                             LMEM_FIXED,
                                             replySize +
                                                 sizeof(ICMP_LOCAL_STORAGE)
                                             );

    if (localStorage == NULL) {
        return((int)GetLastError());
    }

    replyBuffer = ((char *) localStorage) + sizeof(ICMP_LOCAL_STORAGE);

    if (ttl == 0) {
        options.Ttl = DEFAULT_TTL;
    }
    else {
        options.Ttl = (BYTE)ttl;
    }

    options.Tos = (tos << 4) | precedence;
    options.Flags = df ? IP_FLAG_DF : 0;
    options.OptionsSize = (BYTE)optlen;
    options.OptionsData = optptr;

    localStorage->NumberOfReplies = IcmpSendEcho(
                                        fd,
                                        (IPAddr) addr,
                                        data,
                                        (WORD)amount,
                                        &options,
                                        replyBuffer,
                                        replySize,
                                        PING_WAIT
                                        );

    if (localStorage->NumberOfReplies == 0) {
        localStorage->Status = GetLastError();
    }
    else {
        localStorage->Status = IP_SUCCESS;
    }

    localStorage->IcmpHandle = fd;
    localStorage->ReplyBuffer = replyBuffer;

    //
    // Save the reply for later retrieval.
    //
    EnterCriticalSection(&g_IcmpLock);
    localStorage->Next = RequestHead;
    RequestHead = localStorage;
    LeaveCriticalSection(&g_IcmpLock);

    return(0);

}  // do_echo_req


int
STRMAPI
do_echo_rep(
    HANDLE   fd,
    char    *data,
    int      amount,
    int     *rettype,
    int     *retttl,
    int     *rettos,
    int     *retprec,
    int     *retdf,
    char    *ropt,
    int     *roptlen
    )
{
    PICMP_LOCAL_STORAGE  localStorage, tmp;
    PICMP_ECHO_REPLY     reply;
    PSTATUS_TABLE        entry;
    DWORD                status;


    //
    // Find the reply.
    //
    EnterCriticalSection(&g_IcmpLock);

    for ( localStorage = RequestHead, tmp = NULL;
          localStorage != NULL;
          localStorage = localStorage->Next
        ) {
        if (localStorage->IcmpHandle == fd) {
            if (RequestHead == localStorage) {
                RequestHead = localStorage->Next;
            }
            else {
                tmp->Next = localStorage->Next;
            }
            break;
        }
        tmp = localStorage;
    }

    LeaveCriticalSection(&g_IcmpLock);

    if (localStorage == NULL) {
        SetLastError(POLL_FAILED);
        return(-1);
    }

    //
    // Process the reply.
    //
    if (localStorage->NumberOfReplies == 0) {
        status = localStorage->Status;
        reply = NULL;
    }
    else {
        reply = (PICMP_ECHO_REPLY) localStorage->ReplyBuffer;
        status = reply->Status;
    }

    if ((status == IP_SUCCESS) && (reply != NULL)) {
        if (amount < reply->DataSize) {
            status = POLL_FAILED;
            goto der_error_exit;
        }

        CopyMemory(data, reply->Data, reply->DataSize);

        *rettype = ECHO_REPLY;
    }
    else {
        //
        // Map to the appropriate old status code & return value.
        //
        if (status < IP_STATUS_BASE) {
            status = POLL_FAILED;
            goto der_error_exit;
        }

        if (status == IP_REQ_TIMED_OUT) {
            status = POLL_TIMEOUT;
            goto der_error_exit;
        }

        for ( entry = StatusTable;
              entry->NewStatus != IP_GENERAL_FAILURE;
              entry++
            ) {
            if (entry->NewStatus == status) {
                *rettype = entry->OldStatus;
                break;
            }
        }

        if (entry->NewStatus == IP_GENERAL_FAILURE) {
            status = POLL_FAILED;
            goto der_error_exit;
        }
    }

    if (reply != NULL) {
        *retdf = reply->Options.Flags ? 1 : 0;
        *retttl = reply->Options.Ttl;
        *rettos = (reply->Options.Tos & 0xf0) >> 4;
        *retprec = reply->Options.Tos & 0x0f;

        if (ropt) {
            if (reply->Options.OptionsSize > *roptlen) {
                reply->Options.OptionsSize = (BYTE)*roptlen;
            }

            *roptlen = reply->Options.OptionsSize;

            if (reply->Options.OptionsSize) {
                CopyMemory(
                    ropt,
                    reply->Options.OptionsData,
                    reply->Options.OptionsSize
                    );
            }
        }
    }

    LocalFree(localStorage);
    return(0);

der_error_exit:
    LocalFree(localStorage);
    SetLastError(status);
    return(-1);

}  // do_echo_rep


//////////////////////////////////////////////////////////////////////////////
//
// DLL entry point
//
//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
IcmpEntryPoint(
    HANDLE   hDll,
    DWORD    dwReason,
    LPVOID   lpReserved
    )
{
    OSVERSIONINFO        versionInfo;
    PICMP_LOCAL_STORAGE  entry;

    UNREFERENCED_PARAMETER(hDll);
    UNREFERENCED_PARAMETER(lpReserved);

    switch(dwReason) {

    case DLL_PROCESS_ATTACH:

        versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (!GetVersionEx(&versionInfo)) {
            return(FALSE);
        }

        //
        // NT 3.1 interface initialization
        //
        InitializeCriticalSection(&g_IcmpLock);

        if (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
            HINSTANCE  WSock32Dll;

            Platform = PLATFORM_VXD;

            WSock32Dll = LoadLibrary("wsock32.dll");

            if (WSock32Dll == NULL) {
                return(FALSE);
            }

            wsControl = (LPWSCONTROL) GetProcAddress(
                            WSock32Dll,
                            "WsControl"
                            );

            if (wsControl == NULL) {
                return(FALSE);
            }
        }
        else if (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {

            Platform = PLATFORM_NT;

        }
        else {
            //
            // Unsupported OS Version
            //
            return(FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // NT 3.1 interface cleanup
        //
        DeleteCriticalSection(&g_IcmpLock);

        while((entry = RequestHead) != NULL) {
            RequestHead = RequestHead->Next;
            LocalFree(entry);
        }

        break;

    default:
        break;
    }

    return(TRUE);

}  // DllEntryPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\lanmap.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\lanmap.h

Abstract:

    Header for lanmap.c

Revision History:

    AmritanR    Created

--*/

#pragma once

#define REG_VALUE_CONN_NAME_W   L"Name"
#define CONN_KEY_FORMAT_W       L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%s\\Connection"


#define LAN_HASH_TABLE_SIZE     29

#define LAN_GUID_HASH(pg)   \
    (((ULONG)((pg)->Data1 + *((ULONG *)(&((pg)->Data2))))) % LAN_HASH_TABLE_SIZE)

typedef struct _LAN_NODE
{
    LIST_ENTRY  leGuidLink;
    LIST_ENTRY  leNameLink;
    GUID        Guid;
    WCHAR       rgwcName[MAX_INTERFACE_NAME_LEN + 2];

}LAN_NODE, *PLAN_NODE;

DWORD
NhiGetLanConnectionNameFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszName,
    IN OUT  PULONG  pulBufferLength,
    IN      BOOL    bRefresh,
    IN      BOOL    bCache
    );

DWORD
NhiGetGuidFromLanConnectionName(
    IN  PWCHAR  pwszBuffer,
    OUT GUID    *pGuid,
    IN  BOOL    bRefresh,
    IN  BOOL    bCache
    );

DWORD
NhiGetLanConnectionDescriptionFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    );

DWORD
InitLanNameMapper(
    VOID
    );

VOID
DeinitLanNameMapper(
    VOID
    );

DWORD
OpenConnectionKey(
    IN  GUID    *pGuid,
    OUT PHKEY    phkey
    );

PLAN_NODE
LookupLanNodeByGuid(
    IN  GUID    *pGuid
    );

PLAN_NODE
LookupLanNodeByName(
    IN  PWCHAR  pwszName
    );

DWORD
AddLanNode(
    IN  GUID    *pGuid,
    IN  PWCHAR  pwszName
    );

VOID
RemoveLanNode(
    IN  PLAN_NODE   pNode
    );

DWORD
UpdateLanLookupTable(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\map.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:

Revision History:

    Amritansh Raghav

--*/
#include "inc.h"
#pragma hdrstop

int
TCPQueryInformationEx(
    DWORD Family,
    void *InBuf,
    ulong *InBufLen,
    void *OutBuf,
    ulong *OutBufLen
    );

int
TCPSetInformationEx(
    void    *InBuf,
    ULONG   *InBufLen,
    void    *OutBuf,
    ULONG   *OutBufLen
    );

TDIEntityID*
GetTdiEntityCount(
    PULONG  pulNumEntities
    );


VOID
InitAdapterMappingTable(VOID)
{
    DWORD i;

    for(i = 0; i < MAP_HASH_SIZE; i++)
    {
        InitializeListHead(&g_pAdapterMappingTable[i]);
    }
}

VOID
UnInitAdapterMappingTable(VOID)
{
    DWORD i;

    for(i = 0; i < MAP_HASH_SIZE; i++)
    {
        PLIST_ENTRY pleHead = &g_pAdapterMappingTable[i];

        while(!IsListEmpty(pleHead))
        {
            PLIST_ENTRY pleNode;
            LPAIHASH lpAIBlock;

            pleNode = RemoveHeadList(pleHead);
            lpAIBlock = CONTAINING_RECORD(pleNode,AIHASH,leList);

            HeapFree(g_hPrivateHeap,0,lpAIBlock);
        }
    }
}


DWORD
StoreAdapterToATInstanceMap(
    DWORD dwAdapterIndex,
    DWORD dwATInst
    )
{
    LPAIHASH lpAIBlock;

    if((lpAIBlock = LookUpAdapterMap(dwAdapterIndex)) isnot NULL)
    {
        lpAIBlock->dwATInstance = dwATInst;
        return NO_ERROR;
    }

    //
    // Wasnt found
    //

    if((lpAIBlock = HeapAlloc(g_hPrivateHeap,0,sizeof(AIHASH))) is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // New one so make everything else unmapped to avoid nasty surprises
    //

    lpAIBlock->dwAdapterIndex = dwAdapterIndex;
    lpAIBlock->dwATInstance = dwATInst;
    lpAIBlock->dwIFInstance = INVALID_IF_INSTANCE;

    InsertAdapterMap(lpAIBlock);

    return NO_ERROR;
}

DWORD
StoreAdapterToIFInstanceMap(
    DWORD dwAdapterIndex,
    DWORD dwIFInst
    )
{
    LPAIHASH lpAIBlock;

    if((lpAIBlock = LookUpAdapterMap(dwAdapterIndex)) isnot NULL)
    {
        lpAIBlock->dwIFInstance = dwIFInst;
        return NO_ERROR;
    }

    //
    // Wasnt found
    //

    if((lpAIBlock = HeapAlloc(g_hPrivateHeap,0,sizeof(AIHASH))) is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // New one so make everything else unmapped to avoid nasty surprises
    //

    lpAIBlock->dwAdapterIndex = dwAdapterIndex;
    lpAIBlock->dwATInstance   = INVALID_AT_INSTANCE;
    lpAIBlock->dwIFInstance   = dwIFInst;

    InsertAdapterMap(lpAIBlock);

    return NO_ERROR;
}


DWORD
GetIFInstanceFromAdapter(
    DWORD dwAdapterIndex
    )
{
    LPAIHASH lpAIBlock;

    if((lpAIBlock = LookUpAdapterMap(dwAdapterIndex)) isnot NULL)
    {
        return lpAIBlock->dwIFInstance;
    }

    return INVALID_IF_INSTANCE;
}

DWORD
GetATInstanceFromAdapter(
    DWORD dwAdapterIndex
    )
{
    LPAIHASH lpAIBlock;

    if((lpAIBlock = LookUpAdapterMap(dwAdapterIndex)) isnot NULL)
    {
        return lpAIBlock->dwATInstance;
    }

    return INVALID_IF_INSTANCE;
}

LPAIHASH
LookUpAdapterMap(
    DWORD dwAdapterIndex
    )
{
    DWORD dwHashIndex;
    LPAIHASH lpAIBlock;
    PLIST_ENTRY lpleCurrent;

    dwHashIndex = dwAdapterIndex % MAP_HASH_SIZE;

    //
    // The list is not ordered, travel the whole hash bucket
    //

    for(lpleCurrent = g_pAdapterMappingTable[dwHashIndex].Flink;
        lpleCurrent isnot &g_pAdapterMappingTable[dwHashIndex];
        lpleCurrent = lpleCurrent->Flink)
    {
        lpAIBlock = CONTAINING_RECORD(lpleCurrent,AIHASH,leList);
        if(lpAIBlock->dwAdapterIndex is dwAdapterIndex)
        {
            return lpAIBlock;
        }
    }

    return NULL;
}

VOID
InsertAdapterMap(
    LPAIHASH lpaiBlock
    )
{
    DWORD dwHashIndex;

    dwHashIndex = lpaiBlock->dwAdapterIndex % MAP_HASH_SIZE;
    InsertHeadList(&g_pAdapterMappingTable[dwHashIndex],&lpaiBlock->leList);

}

DWORD
UpdateAdapterToIFInstanceMapping(
    VOID
    )
{
    DWORD                              dwResult;
    DWORD                              dwOutBufLen;
    DWORD                              dwInBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;
    MIB_IFROW                          maxIfEntry;
    DWORD                              i;
    ULONG                              ulNumEntities;
    TDIEntityID                        *entityList;
    TDIEntityID                        *pEntity = NULL; 

    entityList = GetTdiEntityCount(&ulNumEntities);

    if(entityList == NULL)
    {
        Trace0(ERR,
               "UpdateAdapterToIFInstanceMapping: Couldnt get num entities\n");
	
        return ERROR_GEN_FAILURE;
    }

    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    ID = &(trqiInBuf.ID);
    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ID->toi_entity.tei_entity = IF_ENTITY;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IF_MIB_STATS_ID;

    //
    // First go through and invalidate all the mappings
    //

    for(i = 0; i < MAP_HASH_SIZE; i ++)
    {
        PLIST_ENTRY pCurrentNode;
        LPAIHASH    lpAIBlock;

        for(pCurrentNode = g_pAdapterMappingTable[i].Flink;
            pCurrentNode isnot &(g_pAdapterMappingTable[i]);
            pCurrentNode = pCurrentNode->Flink)
        {
            lpAIBlock = CONTAINING_RECORD(pCurrentNode,AIHASH,leList);

            lpAIBlock->dwIFInstance = INVALID_IF_INSTANCE;
        }
    }

    //
    // Read the interface entry items
    //

    for ( i = 0, pEntity = entityList; i < ulNumEntities ; ++i, ++pEntity)
    {
        if (pEntity->tei_entity == IF_ENTITY) 
        {
            dwOutBufLen = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);
	  
            ID->toi_entity.tei_instance = pEntity->tei_instance;
	  
            ZeroMemory(Context,CONTEXT_SIZE);
	  
            dwResult = TCPQueryInformationEx(AF_INET,
                                             &trqiInBuf,
                                             &dwInBufLen,
                                             (LPVOID)&(maxIfEntry.dwIndex),
                                             &dwOutBufLen );
            if (dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "Error %x querying information from stack. Continuing",
                       dwResult);
	      
                continue;
            }
	  
            StoreAdapterToIFInstanceMap(maxIfEntry.dwIndex,
                                        pEntity->tei_instance);
        }
    }

    //
    // Now delete the blocks that have invalid mappings
    //

    for(i = 0; i < MAP_HASH_SIZE; i ++)
    {
        PLIST_ENTRY pCurrentNode;
        LPAIHASH    lpAIBlock;

        pCurrentNode = g_pAdapterMappingTable[i].Flink;

        while(pCurrentNode isnot &(g_pAdapterMappingTable[i]))
        {
            PLIST_ENTRY pTempNode;

            pTempNode = pCurrentNode;
            
            pCurrentNode = pCurrentNode->Flink;
            
            lpAIBlock = CONTAINING_RECORD(pTempNode,
                                          AIHASH,
                                          leList);

            if(lpAIBlock->dwIFInstance is INVALID_IF_INSTANCE)
            {
                //
                // Delete it
                //

                RemoveEntryList(&(lpAIBlock->leList));

                HeapFree(g_hPrivateHeap,
                         0,
                         lpAIBlock);
            }
        }
    }

    g_dwLastIfUpdateTime = GetCurrentTime();

    HeapFree(g_hPrivateHeap,0, entityList);

    return NO_ERROR;
}

DWORD
UpdateAdapterToATInstanceMapping(
    VOID
    )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              i;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    DWORD                              dwSize;
    AddrXlatInfo                       AXI;

    //
    // When we update the mapping, we also update the ArpEntities
    // Infact we use the same function to do both
    //

    if(g_pdwArpEntTable)
    {
        HeapFree(g_hPrivateHeap,
                 HEAP_NO_SERIALIZE,
                 g_pdwArpEntTable);

        g_pdwArpEntTable = NULL;
    }

    dwResult = AllocateAndGetArpEntTableFromStack(&g_pdwArpEntTable,
                                                  &g_dwNumArpEntEntries,
                                                  g_hPrivateHeap,
                                                  0,
                                                  0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "UpdateAdapterToATInstanceMapping: Couldnt get ArpEntTable. Error %d",
               dwResult);

        g_pdwArpEntTable = NULL;

        return ERROR_CAN_NOT_COMPLETE;
    }

    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ID = &(trqiInBuf.ID);

    for (i = 0; i < g_dwNumArpEntEntries; i++ )
    {

        ID->toi_entity.tei_entity   = AT_ENTITY;
        ID->toi_type                = INFO_TYPE_PROVIDER;
        ID->toi_class               = INFO_CLASS_PROTOCOL;
        ID->toi_id                  = AT_MIB_ADDRXLAT_INFO_ID;
        ID->toi_entity.tei_instance = g_pdwArpEntTable[i];

        dwSize = sizeof(AXI);
        ZeroMemory(Context, CONTEXT_SIZE);

        dwResult = TCPQueryInformationEx(AF_INET,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         &AXI,
                                         &dwSize );

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "UpdateAdapterToATInstanceMapping: Error %x querying stack",
                   dwResult);

            return dwResult;
        }

        StoreAdapterToATInstanceMap(AXI.axi_index,g_pdwArpEntTable[i]);
    }

    g_dwLastArpUpdateTime = GetCurrentTime();

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\map.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    net\sockets\tcpcmd\map.h

Abstract:


Revision History:

    Amritansh Raghav

--*/


VOID 
InitAdapterMappingTable(VOID);
VOID
UnInitAdapterMappingTable(VOID);
DWORD 
StoreAdapterToATInstanceMap(
    DWORD dwAdapterIndex, 
    DWORD dwATInst
    );
DWORD 
StoreAdapterToIFInstanceMap(
    DWORD dwAdapterIndex, 
    DWORD dwIFInst
    );
DWORD 
GetIFInstanceFromAdapter(
    DWORD dwAdapterIndex
    );
DWORD 
GetATInstanceFromAdapter(
    DWORD dwAdapterIndex
    );
LPAIHASH 
LookUpAdapterMap(
    DWORD dwAdapterIndex
    );
VOID 
InsertAdapterMap(
    LPAIHASH lpaiBlock
    );
DWORD 
UpdateAdapterToIFInstanceMapping(VOID);
DWORD 
UpdateAdapterToATInstanceMapping(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\namemap.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\namemap.h

Abstract:

    Header for namemap.c

Revision History:

    AmritanR    Created

--*/

#pragma once

typedef struct _NH_NAME_MAPPER
{
    HANDLE                          hDll;
    PNH_NAME_MAPPER_INIT            pfnInit;
    PNH_NAME_MAPPER_DEINIT          pfnDeinit;
    PNH_NAME_MAPPER_MAP_GUID        pfnMapGuid;
    PNH_NAME_MAPPER_MAP_NAME        pfnMapName;
    PNH_NAME_MAPPER_GET_DESCRIPTION pfnGetDescription;

}NH_NAME_MAPPER, *PNH_NAME_MAPPER;

PNH_NAME_MAPPER g_pNameMapperTable;

NH_NAME_MAPPER  TempTable[2];

ULONG   g_ulNumNameMappers;


DWORD
InitNameMappers(
    VOID
    );

VOID
DeinitNameMappers(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\namemap.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\namemap.c

Abstract:

    Contains all the functions for mapping an interface name to
    a friendly name

Revision History:

    AmritanR    Created

--*/

#include "inc.h"

DWORD
InitNameMappers(
    VOID
    )

{
    DWORD   dwResult, i;

    //
    // For now all we need are the mappers for LAN, RRAS, and IP in IP
    //

    TempTable[0].hDll               = NULL;
    TempTable[0].pfnInit            = InitLanNameMapper;
    TempTable[0].pfnDeinit          = DeinitLanNameMapper;
    TempTable[0].pfnMapGuid         = NhiGetLanConnectionNameFromGuid;
    TempTable[0].pfnMapName         = NhiGetGuidFromLanConnectionName;
    TempTable[0].pfnGetDescription  = NhiGetLanConnectionDescriptionFromGuid;

    TempTable[1].hDll               = NULL;
    TempTable[1].pfnInit            = InitRasNameMapper;
    TempTable[1].pfnDeinit          = DeinitRasNameMapper;
    TempTable[1].pfnMapGuid         = NhiGetPhonebookNameFromGuid;
    TempTable[1].pfnMapName         = NhiGetGuidFromPhonebookName;
    TempTable[1].pfnGetDescription  = NhiGetPhonebookDescriptionFromGuid;

#ifdef KSL_IPINIP
    TempTable[2].hDll               = NULL;
    TempTable[2].pfnInit            = InitIpIpNameMapper;
    TempTable[2].pfnDeinit          = DeinitIpIpNameMapper;
    TempTable[2].pfnMapGuid         = NhiGetIpIpNameFromGuid;
    TempTable[2].pfnMapName         = NhiGetGuidFromIpIpName;
    TempTable[2].pfnGetDescription  = NhiGetIpIpDescriptionFromGuid;
#endif //KSL_IPINIP

    g_pNameMapperTable = TempTable;

    g_ulNumNameMappers = sizeof(TempTable)/sizeof(NH_NAME_MAPPER);

    for(i = 0; i < g_ulNumNameMappers; i++)
    {
        if(g_pNameMapperTable[i].pfnInit)
        {
            dwResult = (g_pNameMapperTable[i].pfnInit)();

            ASSERT(dwResult == NO_ERROR);
        }
    }

    return NO_ERROR;
}

VOID
DeinitNameMappers(
    VOID
    )
{
    ULONG   i;

    for(i = 0; i < g_ulNumNameMappers; i++)
    {
        if(g_pNameMapperTable[i].pfnDeinit)
        {
            (g_pNameMapperTable[i].pfnDeinit)();
        }
    }

    g_ulNumNameMappers = 0;

    g_pNameMapperTable = NULL;
}
    
DWORD
NhGetInterfaceNameFromDeviceGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )
{
    DWORD dwResult, i, dwCount;
    PIP_INTERFACE_NAME_INFO pTable;

    //
    // Obtain a table of interface information,
    // map the device GUID to an interface GUID,
    // and invoke the interface-name query routine.
    //

    dwResult = NhpAllocateAndGetInterfaceInfoFromStack(&pTable,
                                                       &dwCount,
                                                       TRUE,
                                                       GetProcessHeap(),
                                                       0);
    if (dwResult != NO_ERROR)
    {
        return dwResult;
    }

    dwResult = ERROR_NOT_FOUND;

    for (i = 0; i < dwCount; i++)
    {
        if (IsEqualGUID(&pTable[i].DeviceGuid, pGuid))
        {
            if (IsEqualGUID(&pTable[i].InterfaceGuid, &GUID_NULL))
            {
                pGuid = &pTable[i].DeviceGuid;
            }
            else
            {
                pGuid = &pTable[i].InterfaceGuid;
            }
            dwResult = NhGetInterfaceNameFromGuid(pGuid,
                                                  pwszBuffer,
                                                  pulBufferSize,
                                                  bCache,
                                                  bRefresh);
            break;
        }
    }

    HeapFree(GetProcessHeap(), 0, pTable);

    return dwResult;
}

DWORD
NhGetInterfaceNameFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PDWORD  pdwBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )

{
    DWORD   dwResult, i;

    //
    // Make sure that there is a buffer and its size is enough
    //

    while(TRUE)
    {
        //
        // Call the helpers
        //

        for(i = 0; i < g_ulNumNameMappers; i++)
        {
            dwResult = g_pNameMapperTable[i].pfnMapGuid(pGuid,
                                                        pwszBuffer,
                                                        pdwBufferSize,
                                                        bRefresh,
                                                        bCache);
            if(dwResult is NO_ERROR)
            {
                break;
            }
        }

        if(dwResult is NO_ERROR)
        {
            break;
        }

        //
        // So didnt match any - do the same thing again, but this time with 
        // force a cache refresh
        //

        if(bRefresh)
        {
            break;
        }
        else
        {
            bRefresh = TRUE;
        }
    }

    return dwResult;
}

DWORD
NhGetGuidFromInterfaceName(
    IN      PWCHAR  pwszBuffer,
    OUT     GUID    *pGuid,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )
{
    DWORD   dwResult, i;

    //
    // Make sure that there is a buffer and its size is enough
    //

    while(TRUE)
    {
        //
        // Call the helpers
        //

        for(i = 0; i < g_ulNumNameMappers; i++)
        {
            dwResult = g_pNameMapperTable[i].pfnMapName(pwszBuffer,
                                                        pGuid,
                                                        bRefresh,
                                                        bCache);
            if(dwResult is NO_ERROR)
            {
                break;
            }
        }

        if(dwResult is NO_ERROR)
        {
            break;
        }

        //
        // So didnt match any - do the same thing again, but this time with
        // force a cache refresh
        //

        if(bRefresh)
        {
            break;
        }
        else
        {
            bRefresh = TRUE;
        }
    }

    return dwResult;
}

DWORD
NhGetInterfaceDescriptionFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )

{
    DWORD   dwResult, i;

    //
    // Make sure that there is a buffer and its size is enough
    //

    while(TRUE)
    {
        //
        // Call the helpers
        //

        for(i = 0; i < g_ulNumNameMappers; i++)
        {
            dwResult = g_pNameMapperTable[i].pfnGetDescription(pGuid,
                                                               pwszBuffer,
                                                               pulBufferSize,
                                                               bRefresh,
                                                               bCache);
            if(dwResult is NO_ERROR)
            {
                break;
            }
        }

        if(dwResult is NO_ERROR)
        {
            break;
        }

        //
        // So didnt match any - do the same thing again, but this time with
        // force a cache refresh
        //

        if(bRefresh)
        {
            break;
        }
        else
        {
            bRefresh = TRUE;
        }
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\rasmap.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\rasmap.h

Abstract:

    Header for rasmap.h

Revision History:

    AmritanR    Created

--*/

#ifndef __IPHLPAPI_RASMAP__
#define __IPHLPAPI_RASMAP__

typedef struct _RAS_INFO_TABLE
{
    ULONG               ulTotalCount;
    ULONG               ulValidCount;
    RASENUMENTRYDETAILS rgEntries[ANY_SIZE];

}RAS_INFO_TABLE, *PRAS_INFO_TABLE;

#define SIZEOF_RASTABLE(n)                          \
    (FIELD_OFFSET(RAS_INFO_TABLE, rgEntries[0]) +   \
     (n) * sizeof(RASENUMENTRYDETAILS))

#define INIT_RAS_ENTRY_COUNT    5
#define RAS_OVERFLOW_COUNT      5
#define RAS_HASH_TABLE_SIZE     13

#define RAS_GUID_HASH(pg)   \
    (((ULONG)((pg)->Data1 + *((ULONG *)(&((pg)->Data2))))) % RAS_HASH_TABLE_SIZE)

typedef struct _RAS_NODE
{
    LIST_ENTRY  leGuidLink;
    LIST_ENTRY  leNameLink;
    GUID        Guid;
    WCHAR       rgwcName[RASAPIP_MAX_ENTRY_NAME + 2];

}RAS_NODE, *PRAS_NODE;

DWORD
NhiGetPhonebookNameFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN OUT  PULONG  pulBufferSize,
    IN      BOOL    bRefresh,
    IN      BOOL    bCache
    );

DWORD
NhiGetGuidFromPhonebookName(
    IN  PWCHAR  pwszBuffer,
    OUT GUID    *pGuid,
    IN  BOOL    bRefresh,
    IN  BOOL    bCache
    );

DWORD
NhiGetPhonebookDescriptionFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    );

DWORD
InitRasNameMapper(
    VOID
    );

VOID
DeinitRasNameMapper(
    VOID
    );

DWORD
RefreshRasCache(
    IN      PWCHAR          pwszPhonebook,
    IN OUT  RAS_INFO_TABLE  **ppTable
    );

DWORD
UpdateRasLookupTable(
    IN  PRAS_INFO_TABLE pTable
    );

PRAS_NODE
LookupRasNodeByGuid(
    IN  GUID    *pGuid
    );

PRAS_NODE
LookupRasNodeByName(
    IN  PWCHAR  pwszName
    );

DWORD
AddRasNode(
    IN LPRASENUMENTRYDETAILS    pInfo
    );

VOID
RemoveRasNode(
    IN  PRAS_NODE   pNode
    );

#endif // __IPHLPAPI_RASMAP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\rasmap.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\rasmap.c

Abstract:

    This module maps ras dial out and router names to friendly names.

Revision History:

    AmritanR    Created

--*/

#include "inc.h"
#pragma  hdrstop

#include <ifguid.h>

LIST_ENTRY          g_RasGuidHashTable[RAS_HASH_TABLE_SIZE];
LIST_ENTRY          g_RasNameHashTable[RAS_HASH_TABLE_SIZE];
PRAS_INFO_TABLE     g_pRasTable, g_pRouterTable;
CRITICAL_SECTION    g_RasTableLock;

WCHAR   g_rgwcRasServerIf[MAX_INTERFACE_NAME_LEN + 2];
ULONG   g_ulRasServerIfSize;

ULONG
__inline
RAS_NAME_HASH(
    IN  PWCHAR  pwszName
    )
{
    ULONG   ulLen, ulNumChars, i, ulIndex = 0;
    
    ulLen = wcslen(pwszName);

    ulNumChars = ulLen < 6 ? ulLen : 6;

    ulLen--;

    for(i = 0; i < ulNumChars; i++)
    {
        ulIndex += pwszName[i];
        ulIndex += pwszName[ulLen - i];
    }

    return ulIndex % RAS_HASH_TABLE_SIZE;
}

DWORD
InitRasNameMapper(
    VOID
    )

{
    ULONG   i;

    for(i = 0; i < RAS_HASH_TABLE_SIZE; i ++)
    {
        InitializeListHead(&(g_RasNameHashTable[i]));
        InitializeListHead(&(g_RasGuidHashTable[i]));
    }

    InitializeCriticalSection(&g_RasTableLock);

    if(!LoadStringW(g_hModule,
                    STRING_RAS_SERVER_INTERFACE,
                    g_rgwcRasServerIf,
                    MAX_INTERFACE_NAME_LEN + 1))
    {
        return GetLastError();
    }

    g_ulRasServerIfSize = (wcslen(g_rgwcRasServerIf) + 1) * sizeof(WCHAR);
    
    return NO_ERROR;
}

VOID
DeinitRasNameMapper(
    VOID
    )

{
    ULONG   i;

    for(i = 0; i < RAS_HASH_TABLE_SIZE; i ++)
    {
        while(!IsListEmpty(&(g_RasGuidHashTable[i])))
        {
            PLIST_ENTRY pleNode;
            PRAS_NODE   pRasNode;

            pleNode = RemoveHeadList(&(g_RasGuidHashTable[i]));

            pRasNode = CONTAINING_RECORD(pleNode,
                                         RAS_NODE,
                                         leGuidLink);

            RemoveEntryList(&(pRasNode->leNameLink));

            HeapFree(g_hPrivateHeap,
                     0,
                     pleNode);
        }
    }

    if(g_pRasTable)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 g_pRasTable);

        g_pRasTable = NULL;
    }

    DeleteCriticalSection(&g_RasTableLock);
}

DWORD
NhiGetPhonebookNameFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN OUT  PDWORD  pdwBufferSize,
    IN      BOOL    bRefresh,
    IN      BOOL    bCache
    )

{
    DWORD       dwResult;
    PRAS_NODE   pNode = NULL;
    WCHAR       wszRouterPbk[MAX_PATH + 2];


    if(IsEqualGUID(pGuid, &GUID_IpRasServerInterface))
    {
        if(*pdwBufferSize < g_ulRasServerIfSize)
        {
            *pdwBufferSize = g_ulRasServerIfSize;

            return ERROR_INSUFFICIENT_BUFFER;
        }
        
        wcscpy(pwszBuffer,
               g_rgwcRasServerIf);

        *pdwBufferSize = g_ulRasServerIfSize;

        return NO_ERROR;
    }

    //
    // Lock the table
    //

    EnterCriticalSection(&g_RasTableLock);
   
    //
    // Check if a refresh of the Ras Table is needed.
    //
    if((g_pRasTable is NULL)  or
       bRefresh)
    {
        //
        // refresh the Ras Table cache
        //
        
        dwResult = RefreshRasCache(NULL,
                                   &g_pRasTable);
        
        //
        // Now lookup the table
        //
        pNode = LookupRasNodeByGuid(pGuid);
    }

    //
    // Check if a refresh of the Ras Router Table is needed.
    //
    if(((g_pRouterTable is NULL) and (pNode is NULL)) or
        bRefresh)
    {
        //
        // refresh the Router Table cache
        //

        ZeroMemory(wszRouterPbk, (MAX_PATH + 2) * sizeof(WCHAR));
        
        GetSystemDirectoryW(wszRouterPbk, MAX_PATH + 1);

        wcscat(wszRouterPbk, L"\\ras\\router.pbk");
        
        wszRouterPbk[MAX_PATH + 1] = 0;

        dwResult = RefreshRasCache(wszRouterPbk,
                                   &g_pRouterTable);
        
        //
        // Now lookup the table
        //
        pNode = LookupRasNodeByGuid(pGuid);
    }

    if(pNode is NULL)
    {
        LeaveCriticalSection(&g_RasTableLock);
        
        return ERROR_NOT_FOUND;
    }

    wcscpy(pwszBuffer, 
           pNode->rgwcName);

    LeaveCriticalSection(&g_RasTableLock); 

    return NO_ERROR;
}

DWORD
NhiGetGuidFromPhonebookName(
    IN  PWCHAR  pwszName,
    OUT GUID    *pGuid,
    IN  BOOL    bRefresh,
    IN  BOOL    bCache
    )

{
    DWORD       dwResult;
    PRAS_NODE   pNode = NULL;


    if(_wcsicmp(pwszName, g_rgwcRasServerIf) == 0)
    {
        //
        // Structure copy
        //
        
        *pGuid = GUID_IpRasServerInterface;
        
        return NO_ERROR;
    }

    //
    // Lock the table
    //

    EnterCriticalSection(&g_RasTableLock);
   
    //
    // Check if a refresh of the Ras Table is needed.
    //
    if((g_pRasTable is NULL)  or
       bRefresh)
    {
        //
        // refresh the Ras Table cache
        //
        
        dwResult = RefreshRasCache(NULL,
                                   &g_pRasTable);
        
        //
        // Now lookup the table
        //
        pNode = LookupRasNodeByGuid(pGuid);
    }

    //
    // Check if a refresh of the Ras Router Table is needed.
    //
    if(((g_pRouterTable is NULL) and (pNode is NULL)) or
        bRefresh)
    {
        //
        // refresh the Router Table cache
        //

        dwResult = RefreshRasCache(L"router.pbk",
                                   &g_pRouterTable);
        
        //
        // Now lookup the table
        //
        pNode = LookupRasNodeByGuid(pGuid);
    }

    if(pNode is NULL)
    {
        LeaveCriticalSection(&g_RasTableLock);
        
        return ERROR_NOT_FOUND;
    }

    *pGuid = pNode->Guid;

    LeaveCriticalSection(&g_RasTableLock); 

    return NO_ERROR;

}

DWORD
NhiGetPhonebookDescriptionFromGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )

{
    return NO_ERROR;
}

DWORD
RefreshRasCache(
    IN      PWCHAR          pwszPhonebook,
    IN OUT  RAS_INFO_TABLE  **ppTable
    )

/*++

Routine Description:

    This functions refreshes the ras cache for a given phonebook entry
    As a side effect, it also return the table of phonebook entries.
    It tries to overwrite the given table, if there is space, otherwise
    frees the given table and allocates a new table

Locks:

    None needed. If the ppTable points to some global, then the function
    needs to be synchronized since it frees the table

Arguments:

    pwszPhonebook
    ppTable

Return Value:

    NO_ERROR
    ERROR_NOT_ENOUGH_MEMORY
    ERROR_CAN_NOT_COMPLETE
    
--*/

{
    DWORD       dwResult;
    ULONG       ulSize;
    ULONG       i, ulCount, ulCurrentCount;

    if(*ppTable is NULL)
    {
        //
        // If there is no table present, allocate the minimum
        //

        *ppTable = HeapAlloc(g_hPrivateHeap,
                             0,
                             SIZEOF_RASTABLE(INIT_RAS_ENTRY_COUNT));

        if(*ppTable is NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        (*ppTable)->ulTotalCount = INIT_RAS_ENTRY_COUNT;
    }

    (*ppTable)->ulValidCount  = 0;
    
    ulCurrentCount  = (*ppTable)->ulTotalCount;
    
    i = 0;
    
    while(i < 3)
    {
        ulSize = (*ppTable)->ulTotalCount * sizeof(RASENUMENTRYDETAILS);

        (*ppTable)->rgEntries[0].dwSize = sizeof(RASENUMENTRYDETAILS);
        
        dwResult = DwEnumEntryDetails(pwszPhonebook,
                                      (*ppTable)->rgEntries,
                                      &ulSize,
                                      &ulCount);

        if(dwResult is NO_ERROR)
        {
            //
            // Things are good, update the hash table and move on
            //
            
            (*ppTable)->ulValidCount = ulCount;
            
            dwResult = UpdateRasLookupTable(*ppTable);
            
            if(dwResult isnot NO_ERROR)
            {
                //
                // Free the ras table so that we can try next time
                //
                
                HeapFree(g_hPrivateHeap,
                         0,
                         *ppTable);
                
                *ppTable = NULL;

                return ERROR_CAN_NOT_COMPLETE;
            }

            break;
        }
        else
        {
            //
            // Free the old buffer
            //
            
            HeapFree(g_hPrivateHeap,
                     0,
                     *ppTable);
            
            *ppTable = NULL;
            
            if(dwResult is ERROR_BUFFER_TOO_SMALL)
            {
                //
                // Go back and recalculate
                // See what size RAS required, add an overflow
                //

                ulCurrentCount += ulCount;
                
                *ppTable = HeapAlloc(g_hPrivateHeap,
                                     0,
                                     SIZEOF_RASTABLE(ulCurrentCount));
                
                if(*ppTable is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                (*ppTable)->ulTotalCount = ulCurrentCount;
                
                i++;
            }
            else
            {
                return dwResult;
            }
        }
    }

    return NO_ERROR;
}

DWORD
UpdateRasLookupTable(
    IN PRAS_INFO_TABLE  pTable
    )

/*++

Routine Description:

    Updates the fast lookup table for ras entries    
    If even one fails, we bail out of the function
    
Locks:

    Called with the RAS lock held

Arguments:

    pTable

Return Value:

    NO_ERROR
    
--*/


{
    PRAS_NODE   pNode;
    ULONG       i;
    DWORD       dwResult;
    
    //
    // Go through the entries in the phone book table and put them in
    // the hash table
    //

    for(i = 0; i < pTable->ulValidCount; i++)
    {
        pNode = LookupRasNodeByGuid(&(pTable->rgEntries[i].guidId));

        if(!pNode)
        {
            dwResult = AddRasNode(&(pTable->rgEntries[i]));

            if(dwResult isnot NO_ERROR)
            {
                return dwResult;
            }
        }
        else
        {
            //
            // Node exists, if different remove and re-add
            //

            if(wcscmp(pNode->rgwcName,
                      pTable->rgEntries[i].szEntryName) isnot 0)
            {
                RemoveRasNode(pNode);

                dwResult = AddRasNode(&(pTable->rgEntries[i]));

                if(dwResult isnot NO_ERROR)
                {
                    return dwResult;
                }
            }
        }
    }

    return NO_ERROR;
}

PRAS_NODE
LookupRasNodeByGuid(
    IN  GUID    *pGuid
    )

/*++

Routine Description:

    Looks up the ras node in the hash table    

Locks:

    Called with the ras table lock held

Arguments:

    pGuid   Guid for the node

Return Value:

    RasNode if found
    NULL    otherwise
    
--*/

{
    ULONG       ulIndex;
    PLIST_ENTRY pleNode;
    
    ulIndex = RAS_GUID_HASH(pGuid);

    for(pleNode = g_RasGuidHashTable[ulIndex].Flink;
        pleNode isnot &(g_RasGuidHashTable[ulIndex]);
        pleNode = pleNode->Flink)
    {
        PRAS_NODE   pRasNode;

        pRasNode = CONTAINING_RECORD(pleNode,
                                     RAS_NODE,
                                     leGuidLink);

        if(IsEqualGUID(&(pRasNode->Guid), 
                       pGuid))
        {
            return pRasNode;
        }
    }

    return NULL;
}

PRAS_NODE
LookupRasNodeByName(
    IN  PWCHAR  pwszName
    )

/*++

Routine Description:

    Looks up the ras node in the hash table

Locks:

    Called with the ras table lock held

Arguments:

    pwszName    Name of the phonebook entry

Return Value:

    RasNode if found
    NULL    otherwise

--*/

{
    ULONG       ulIndex;
    PLIST_ENTRY pleNode;

    ulIndex = RAS_NAME_HASH(pwszName);

    for(pleNode = g_RasNameHashTable[ulIndex].Flink;
        pleNode isnot &(g_RasNameHashTable[ulIndex]);
        pleNode = pleNode->Flink)
    {
        PRAS_NODE   pRasNode;

        pRasNode = CONTAINING_RECORD(pleNode,
                                     RAS_NODE,
                                     leNameLink);

        if(_wcsicmp(pRasNode->rgwcName,
                    pwszName) is 0)
        {
            return pRasNode;
        }
    }

    return NULL;
}

DWORD
AddRasNode(
    IN LPRASENUMENTRYDETAILS    pInfo
    )

/*++

Routine Description:

    Creates a node in the hash table for the given ras info    
    
Locks:

    Called with the RAS table lock held

Arguments:

    pInfo   Phonebook entry info

Return Value:

    NO_ERROR
    ERROR_NOT_ENOUGH_MEMORY
    
--*/

{
    ULONG       ulGuidIndex, ulNameIndex;
    PRAS_NODE   pRasNode;
    

    pRasNode = HeapAlloc(g_hPrivateHeap,
                         0,
                         sizeof(RAS_NODE));

    if(pRasNode is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRasNode->Guid = pInfo->guidId;
    
    wcscpy(pRasNode->rgwcName,
           pInfo->szEntryName);

    ulGuidIndex = RAS_GUID_HASH(&(pInfo->guidId));
    ulNameIndex = RAS_NAME_HASH(pInfo->szEntryName);

    InsertHeadList(&(g_RasGuidHashTable[ulGuidIndex]),
                   &(pRasNode->leGuidLink));

    InsertHeadList(&(g_RasNameHashTable[ulNameIndex]),
                   &(pRasNode->leNameLink));

    return NO_ERROR;
}

VOID
RemoveRasNode(
    IN  PRAS_NODE   pNode
    )

/*++

Routine Description:

    Removes the given node from the hash tables    

Locks:

    Called with the RAS table lock held

Arguments:

    pNode   Node to remove

Return Value:

    None
    
--*/

{
    RemoveEntryList(&(pNode->leGuidLink));
    RemoveEntryList(&(pNode->leNameLink));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\mscapis.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:


Abstract:
    Implementation of various time APIs

Revision History:

Author:
    Arnold Miller (ArnoldM)      18-Oct-1997
--*/

#include "fltapis.hxx"
#include <winsock2.h>
#include <time.h>


//
// The system time for 0h 1900
//
LARGE_INTEGER li1900 = {0xfde04000,
                        0x14f373b};

EXTERNCDECL
DWORD
WINAPI
NTTimeToNTPTime(PULONG pTime,
                PFILETIME pft OPTIONAL)
/*++
Routine Description:
   Convert NT filetime to NTP time. If no time provided use
   the current time.
--*/
{
#ifdef CHICAGO
    return ERROR_NOT_SUPPORTED;
#else
    LARGE_INTEGER liTime;
    LONGLONG Increment;
    DWORD  dwMs;

    //
    // put the current time into the quadword pointed to by the arg
    // The argument points to two consecutive ULONGs in which  the
    // time in seconds goes into the first work and the fractional
    // time in seconds in the second word.


    if(!pft)
    {
        GetSystemTimeAsFileTime((LPFILETIME)&liTime);
    }
    else
    {
        *(LPFILETIME)&liTime = *pft;
    }

    //
    // Seconds is simply the time difference
    //
    *pTime = htonl((ULONG)((liTime.QuadPart - li1900.QuadPart) / 10000000));

    //
    // Ms is the residue from the seconds calculation.
    //
    dwMs = (DWORD)(((liTime.QuadPart - li1900.QuadPart) % 10000000) / 10000);


    //
    // time base in the beginning of the year 1900
    //


    *(1 + pTime) = htonl((unsigned long)
                     (.5+0xFFFFFFFF*(double)(dwMs/1000.0)));
    return(ERROR_SUCCESS);
#endif
}

EXTERNCDECL
DWORD
WINAPI
NTPTimeToNTFileTime(PLONG pTime, PFILETIME pft, BOOL bHostOrder)
/*++
Routine Description:
    Convert NTP timestamp to NT filetime.
--*/
{
#ifdef CHICAGO
    return ERROR_NOT_SUPPORTED;
#else
    time_t lmaj;
    LONG lmin;
    struct tm *newtime;
    SYSTEMTIME nt;

    if(bHostOrder)
    {
        lmaj = *pTime;
        lmin = *(pTime + 1);
    }
    else
    {
        lmaj = ntohl(*pTime);
        lmin = ntohl(*(pTime + 1));
    }

    //
    // convert time since 1970 to time since 1900.
    //

    lmaj -= (time_t)(365.2422*70*24*60*60+3974.4);

    //
    // get a time structure based on the seconds part of the NTP time.
    //
    newtime = gmtime(&lmaj);
    if(!newtime)
    {
        return(GetLastError());
    }

    //
    // marshall this into a SYSTEMTIME
    //

    nt.wYear=(WORD)(newtime->tm_year+1900);
    nt.wMonth=(WORD)(newtime->tm_mon+1);
    nt.wDay=(WORD)newtime->tm_mday;
    nt.wHour=(WORD)newtime->tm_hour;
    nt.wMinute=(WORD)newtime->tm_min;
    nt.wSecond=(WORD)newtime->tm_sec;

    //
    // compute ms part from the fractional value of the NTP time
    //
    nt.wMilliseconds=(WORD)(.5+1000*(double)lmin /
                                    (unsigned int)0xFFFFFFFF);
    if (nt.wMilliseconds > 999)
    {
#if 0
        //
        // this is more accurate but it can also produce a failure
        // and since this isn't supposed to happen anway, it is
        // likely failure will ensue. So just truncate the ms field
        //

        nt.wMilliseconds -= 1000;
        if (++nt.wSecond > 59)
        {
            nt.wSecond = 0;
            if (++nt.wMinute > 59)
            {
                nt.wMinute = 0;
                if (++nt.wHour > 23)
                {
                    return(ERROR_INVALID_TIME);
                }
            }
        }
#else
        nt.wMilliseconds = 999;
#endif

    }
    return(SystemTimeToFileTime(&nt, pft));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\str2adda.c ===
#undef UNICODE
#undef _UNICODE

#include "inc.h"
#pragma hdrstop

#define RtlIpv4StringToAddressT RtlIpv4StringToAddressA
#define RtlIpv6StringToAddressT RtlIpv6StringToAddressA
#define RtlIpv4StringToAddressExT RtlIpv4StringToAddressExA
#define RtlIpv6StringToAddressExT RtlIpv6StringToAddressExA

#include "str2addt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\str2addw.c ===
#define UNICODE
#define _UNICODE

#include "inc.h"
#pragma hdrstop

#define RtlIpv4StringToAddressT RtlIpv4StringToAddressW
#define RtlIpv6StringToAddressT RtlIpv6StringToAddressW
#define RtlIpv4StringToAddressExT RtlIpv4StringToAddressExW
#define RtlIpv6StringToAddressExT RtlIpv6StringToAddressExW

#include "str2addt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\stack.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:

Revision History:

    Amritansh Raghav

--*/

#include "inc.h"
#pragma hdrstop

#include <ntddip.h>

#ifdef CHICAGO
LPWSCONTROL pWsControl         = NULL;
HANDLE      hWsock             = NULL;
#endif

extern HANDLE g_hIPDriverHandle;
extern HANDLE g_hIPGetDriverHandle;
extern HANDLE ChangeNotificationHandle;

extern HANDLE g_hIP6DriverHandle;
extern HANDLE g_hIP6GetDriverHandle;
extern HANDLE Change6NotificationHandle;

#ifdef DBG
int trace = 1;
#endif

DWORD
OpenTCPDriver(
    IN DWORD dwFamily
    );
DWORD
OpenIPDriver(
    IN DWORD dwFamily
    );
DWORD
CloseIPDriver();
DWORD
CloseIP6Driver();

TDIEntityID*
GetTdiEntityCount(
    PULONG  pulNumEntities
    );

DWORD
GetArpEntryCount(
    OUT PDWORD  pdwNumEntries
    );

int
TCPQueryInformationEx(
    DWORD Family,
    void *InBuf,
    ulong *InBufLen,
    void *OutBuf,
    ulong *OutBufLen
    );
int
TCPSetInformationEx(
    void    *InBuf,
    ULONG   *InBufLen,
    void    *OutBuf,
    ULONG   *OutBufLen
    );

DWORD
AccessIfEntryInStack(
    IN     DWORD       dwAction,
    IN     DWORD       dwInstance,
    IN OUT PMIB_IFROW  pIfEntry
    );

int
TCPSendIoctl(
    HANDLE hHandle,
    ulong Ioctl,
    void *InBuf,
    ulong *InBufLen,
    void *OutBuf,
    ulong *OutBufLen
    );

// ========================================================================

#ifdef CHICAGO

uint
ConvertTdiErrorToDosError(uint TdiErr)
{
  switch (TdiErr) {
  case TDI_INVALID_REQUEST:
  case TDI_INVALID_QUERY:
    return ERROR_INVALID_FUNCTION;
  case TDI_BUFFER_TOO_SMALL:
    return ERROR_INSUFFICIENT_BUFFER;
  case TDI_BUFFER_OVERFLOW:
    return ERROR_INSUFFICIENT_BUFFER;
  case TDI_PENDING:
    return ERROR_SIGNAL_PENDING;
  default:
    return ERROR_INVALID_PARAMETER;
  }
}
#endif

DWORD
AllocateAndGetIfTableFromStack(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    )
{
    DWORD       dwResult, dwCount, dwOutBufLen;
    MIB_IPSTATS miStats;


    *ppIfTable  = NULL;

    dwResult = GetIpStatsFromStack(&miStats);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetIfTableFromStack: Couldnt get Ip Stats From stack. Error %d",
               dwResult);

        return dwResult;
    }

    dwCount     = miStats.dwNumIf + OVERFLOW_COUNT;
    dwOutBufLen = SIZEOF_IFTABLE(dwCount);

    *ppIfTable = HeapAlloc(hHeap,
                           dwFlags,
                           dwOutBufLen);

    if(*ppIfTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "AllocateAndGetIfTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        return dwResult;
    }


    if(miStats.dwNumIf is 0)
    {
        (*ppIfTable)->dwNumEntries = 0;

        return NO_ERROR;
    }

    EnterCriticalSection(&g_ifLock);

    if (!bForceUpdate && miStats.dwNumIf != g_dwNumIf)
    {
        bForceUpdate = TRUE;
    }
    g_dwNumIf = miStats.dwNumIf;

    LeaveCriticalSection(&g_ifLock);

    dwResult = GetIfTableFromStack(*ppIfTable,
                                   dwOutBufLen,
                                   bOrder,
                                   bForceUpdate);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetIfTableFromStack: Error %d calling GetIfTableFromStack",
               dwResult);
        HeapFree(hHeap, dwFlags, *ppIfTable);
        *ppIfTable = NULL;
    }

    return dwResult;
}

// ========================================================================

DWORD
GetIfTableFromStack(
    OUT PMIB_IFTABLE pIfTable,
    IN  DWORD        dwSize,
    IN  BOOL         bOrder,
    IN  BOOL         bForceUpdate
    )

/*++

Routine Description


Locks

     None needed on entry.  It takes the If lock within the function

Arguments


Return Value

    NO_ERROR

--*/

{
    DWORD       i, dwNumRows, dwCount, dwErr, dwResult;
    PLIST_ENTRY pCurrentNode;
    LPAIHASH    lpAIBlock;


    dwNumRows = (dwSize - FIELD_OFFSET(MIB_IFTABLE,table[0]))/sizeof(MIB_IFROW);

    dwCount = 0;
    dwErr   = NO_ERROR;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    EnterCriticalSection(&g_ifLock);

    if(bForceUpdate or
       (g_dwLastIfUpdateTime is 0) or
       ((GetCurrentTime() - g_dwLastIfUpdateTime) > IF_CACHE_LIFE))
    {
        dwResult = UpdateAdapterToIFInstanceMapping();

	Trace0(ERR, "Update the mapping \n");

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "GetIfTableFromStack: Couldnt update map. Error %d",
                   dwResult);

            LeaveCriticalSection(&g_ifLock);

            return ERROR_CAN_NOT_COMPLETE;
        }

    }


    for(i = 0; i < MAP_HASH_SIZE; i ++)
    {
        for(pCurrentNode = g_pAdapterMappingTable[i].Flink;
            pCurrentNode isnot &(g_pAdapterMappingTable[i]);
            pCurrentNode = pCurrentNode->Flink)
        {

            lpAIBlock = CONTAINING_RECORD(pCurrentNode,AIHASH,leList);

	    Trace1(ERR,
		   "Instance %d \n", lpAIBlock->dwIFInstance);


            if(lpAIBlock->dwIFInstance is INVALID_IF_INSTANCE)
            {
                continue;
            }

            //
            // If there is no more space in the buffer, bail out
            //

            if(dwCount >= dwNumRows)
            {

	        Trace2(ERR,
		       "return here dwCount %d dwNumRows %d \n", dwCount, dwNumRows);

                dwErr = ERROR_MORE_DATA;

                break;
            }


            dwResult = AccessIfEntryInStack(GET_IF_ENTRY,
                                            lpAIBlock->dwIFInstance,
                                            &(pIfTable->table[dwCount]));

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "GetIfTableFromStack: Err %d getting row for inst %d",
                       dwResult, lpAIBlock->dwIFInstance);

                // dwErr = ERROR_MORE_DATA;
		// at this point the stack doesn't have the interface

		continue;

                g_dwLastIfUpdateTime = 0;
            }
            else
            {
                dwCount++;
            }
        }
    }

    g_dwNumIf = dwCount;
    LeaveCriticalSection(&g_ifLock);

    pIfTable->dwNumEntries = dwCount;

    if(bOrder && (dwCount > 0))
    {
        qsort(pIfTable->table,
              dwCount,
              sizeof(MIB_IFROW),
              CompareIfRow);
    }

    return dwErr;
}

// ========================================================================

DWORD
GetIfEntryFromStack(
    OUT PMIB_IFROW  pIfEntry,
    IN  DWORD       dwAdapterIndex,
    IN  BOOL        bForceUpdate
    )

/*++

Routine Description


Locks


Arguments


Return Value
    NO_ERROR

--*/
{
    DWORD       dwResult,dwInBufLen,dwOutBufLen,dwInstance;
    TDIObjectID *ID;
    BYTE        *Context;

    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;

    if (pIfEntry == NULL) {
       return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    EnterCriticalSection(&g_ifLock);

    if(bForceUpdate)
    {
        dwResult = UpdateAdapterToIFInstanceMapping();

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "GetIfEntryFromStack: Couldnt update map. Error %d",
                   dwResult);

            LeaveCriticalSection(&g_ifLock);

            return ERROR_CAN_NOT_COMPLETE;
        }

        dwInstance = GetIFInstanceFromAdapter(dwAdapterIndex);
    }
    else
    {
        dwInstance = GetIFInstanceFromAdapter(dwAdapterIndex);

        if(dwInstance is INVALID_IF_INSTANCE)
        {
            Trace0(ERR,
                   "GetIfEntryFromStack: Couldnt map to instance - first try");

            dwResult = UpdateAdapterToIFInstanceMapping();

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "GetIfEntryFromStack: Couldnt update map. Error %d",
                       dwResult);


                LeaveCriticalSection(&g_ifLock);

                return ERROR_CAN_NOT_COMPLETE;
            }

            dwInstance = GetIFInstanceFromAdapter(dwAdapterIndex);
        }
    }

    LeaveCriticalSection(&g_ifLock);

    if(dwInstance is INVALID_IF_INSTANCE)
    {
        Trace0(ERR,
               "GetIfEntryFromStack: Couldnt map to instance second try!!!!");

        return ERROR_INVALID_DATA;
    }


    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = IF_ENTITY;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IF_MIB_STATS_ID;
    ID->toi_entity.tei_instance = dwInstance;

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(IFEntry);

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    dwResult = AccessIfEntryInStack(GET_IF_ENTRY,
                                    dwInstance,
                                    pIfEntry);

    return dwResult;
}

// ========================================================================

DWORD
SetIfEntryToStack(
    IN MIB_IFROW  *pIfEntry,
    IN BOOL       bForceUpdate
    )
/*++
Routine Description


Locks


Arguments


Return Value
    NO_ERROR

--*/
{
    DWORD       dwResult,dwInstance;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    EnterCriticalSection(&g_ifLock);

    if(bForceUpdate)
    {
        dwResult = UpdateAdapterToIFInstanceMapping();

        if(dwResult isnot NO_ERROR)
        {
            LeaveCriticalSection(&g_ifLock);

            Trace1(ERR,
                   "SetIfEntryToStack: Couldnt update map. Error %d",
                   dwResult);

            return ERROR_CAN_NOT_COMPLETE;
        }

        dwInstance = GetIFInstanceFromAdapter(pIfEntry->dwIndex);
    }
    else
    {
        dwInstance = GetIFInstanceFromAdapter(pIfEntry->dwIndex);

        if(dwInstance is INVALID_IF_INSTANCE)
        {
            Trace0(ERR,
                   "SetIfEntryToStack: Couldnt map to instance - first try");

            dwResult = UpdateAdapterToIFInstanceMapping();

            if(dwResult isnot NO_ERROR)
            {
                LeaveCriticalSection(&g_ifLock);

                Trace1(ERR,
                       "SetIfEntryToStack: Couldnt update map. Error %d",
                       dwResult);


                return ERROR_CAN_NOT_COMPLETE;
            }

            dwInstance = GetIFInstanceFromAdapter(pIfEntry->dwIndex);
        }
    }

    if(dwInstance is INVALID_IF_INSTANCE)
    {
        LeaveCriticalSection(&g_ifLock);

        Trace0(ERR,
               "SetIfEntryToStack: Couldnt map to instance");

        return ERROR_INVALID_DATA;
    }


    dwResult = AccessIfEntryInStack(SET_IF_ENTRY,
                                    dwInstance,
                                    pIfEntry);

    LeaveCriticalSection(&g_ifLock);

    return dwResult;
}

// ========================================================================
/*++
  Routine Description

  Arguments
        dwAction   Can be SET_IF or GET_IF
        picb       the Interface Control Block
        lpOutBuf

  Return Value
        DWORD: NO_ERROR or some error code
--*/

DWORD
AccessIfEntryInStack(
    IN     DWORD       dwAction,
    IN     DWORD       dwInstance,
    IN OUT PMIB_IFROW  pIfEntry
    )
{
    DWORD       dwResult;
    DWORD       dwInBufLen,dwOutBufLen;
    TDIObjectID *ID;
    BYTE        *Context;


    switch(dwAction)
    {
        case GET_IF_ENTRY:
        {
            TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;

            dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

            ID = &(trqiInBuf.ID);
            Context = (BYTE *) &(trqiInBuf.Context[0]);
            ID->toi_entity.tei_entity = IF_ENTITY;
            ID->toi_class = INFO_CLASS_PROTOCOL;
            ID->toi_type = INFO_TYPE_PROVIDER;
            ID->toi_id = IF_MIB_STATS_ID;

            dwOutBufLen = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);

            ID->toi_entity.tei_instance = dwInstance;

            ZeroMemory( Context, CONTEXT_SIZE );

            dwResult = TCPQueryInformationEx(AF_INET,
                                             &trqiInBuf,
                                             &dwInBufLen,
                                             &(pIfEntry->dwIndex),
                                             &dwOutBufLen);
            break;
        }
        case SET_IF_ENTRY:
        {
            TCP_REQUEST_SET_INFORMATION_EX    *lptrsiInBuf;
            IFEntry                           *pifeSetInfo;

            dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IFEntry) - 1;

            lptrsiInBuf = HeapAlloc(g_hPrivateHeap,0,dwInBufLen);

            if(lptrsiInBuf is NULL)
            {
                dwResult = ERROR_NOT_ENOUGH_MEMORY;

                Trace1(ERR,
                       "AccessIfEntryInStack: Error %d allocating memory",
                       dwResult);

                return dwResult;
            }

            ID = &lptrsiInBuf->ID;
            ID->toi_class = INFO_CLASS_PROTOCOL;
            ID->toi_type = INFO_TYPE_PROVIDER;
            ID->toi_entity.tei_entity = IF_ENTITY;
            ID->toi_id = IF_MIB_STATS_ID;
            ID->toi_entity.tei_instance = dwInstance;

            lptrsiInBuf->BufferSize = sizeof(IFEntry);
            dwOutBufLen = 0;

            pifeSetInfo = (IFEntry*)lptrsiInBuf->Buffer;
            *pifeSetInfo = *(IFEntry*)(&(pIfEntry->dwIndex));

            dwResult = TCPSetInformationEx((PVOID) lptrsiInBuf,
                                           &dwInBufLen,
                                           NULL,
                                           &dwOutBufLen);

            HeapFree(g_hPrivateHeap,0,lptrsiInBuf);

            break;
        }
    }

    return dwResult;
}

DWORD
NhpGetInterfaceIndexFromStack(
    IN  PWCHAR      pwszIfName,
    OUT PDWORD      pdwIfIndex
    )

/*++

Routine Description

    Gets the interface index from IP

Locks

    None

Arguments

    pwszIfName  NULL terminated unique name for interface
    dwIfIndex   [OUT] Interface Index

Return Value

    NO_ERROR
    ERROR_INVALID_PARAMETER

--*/

{
    DWORD   rgdwBuffer[255], dwStatus, dwInSize, dwOutSize;

    PIP_GET_IF_INDEX_INFO   pInfo;

#ifdef _WIN95_

    return ERROR_NOT_SUPPORTED;

#else
    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // The if name should be NULL terminated and should fit in the buffer
    // above
    //

    if((FIELD_OFFSET(IP_GET_IF_INDEX_INFO, Name[0]) +
        ((wcslen(pwszIfName) + 1) * sizeof(WCHAR))) > sizeof(rgdwBuffer))
    {
        return ERROR_INVALID_PARAMETER;
    }

    pInfo = (PIP_GET_IF_INDEX_INFO)rgdwBuffer;

    ZeroMemory(rgdwBuffer,
               sizeof(rgdwBuffer));

    wcscpy(pInfo->Name,
           pwszIfName);


    dwInSize  = FIELD_OFFSET(IP_GET_IF_INDEX_INFO, Name[0]) +
                ((wcslen(pwszIfName) + 1) * sizeof(WCHAR));

    dwOutSize = dwInSize;

    dwStatus = TCPSendIoctl(g_hIPGetDriverHandle,
                            IOCTL_IP_GET_IF_INDEX,
                            pInfo,
                            &dwInSize,
                            pInfo,
                            &dwOutSize);


    *pdwIfIndex = pInfo->Index;

    return dwStatus;

#endif
}

DWORD
NhpAllocateAndGetInterfaceInfoFromStack(
    OUT IP_INTERFACE_NAME_INFO  **ppTable,
    OUT PDWORD                  pdwCount,
    IN  BOOL                    bOrder,
    IN  HANDLE                  hHeap,
    IN  DWORD                   dwFlags
    )

/*++

Routine Description

    Internal no fuss routine for getting the interface info.
    This is not an optimal routine when there are many interfaces in the
    stack, since the allocations become huge

Locks

    None

Arguments

    ppTable     Allocated table
    pdwCount    Number of entries in the allocated table
    bOrder      If TRUE, the table is ordered
    hHeap       Handle of heap to allocate from
    dwFlags     Flags to use for allocation

Return Value

    NO_ERROR

--*/

{
    MIB_IPSTATS             miStats;
    PIP_GET_IF_NAME_INFO    pInfo;
    DWORD                   i, dwResult, dwOutSize, dwInSize, dwCount;

    *ppTable  = NULL;
    *pdwCount = 0;

    dwResult = GetIpStatsFromStack(&miStats);

    if(dwResult isnot NO_ERROR)
    {
        return dwResult;
    }

    dwCount     = miStats.dwNumIf + OVERFLOW_COUNT;
    dwOutSize   = FIELD_OFFSET(IP_GET_IF_NAME_INFO, Info) +
                  (dwCount * sizeof(IP_INTERFACE_NAME_INFO));

    dwInSize    = FIELD_OFFSET(IP_GET_IF_NAME_INFO, Info);

    pInfo = HeapAlloc(g_hPrivateHeap,
                      0,
                      dwOutSize);

    if(pInfo is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pInfo->Context = 0;

    dwResult = TCPSendIoctl(g_hIPGetDriverHandle,
                            IOCTL_IP_GET_IF_NAME,
                            pInfo,
                            &dwInSize,
                            pInfo,
                            &dwOutSize);

    if(dwResult isnot NO_ERROR)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 pInfo);

        return dwResult;
    }

#if DBG

    dwCount = (dwOutSize - FIELD_OFFSET(IP_GET_IF_NAME_INFO, Info))/sizeof(IP_INTERFACE_NAME_INFO);

    ASSERT(dwCount is pInfo->Count);

#endif

    if(pInfo->Count is 0)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 pInfo);

        return ERROR_NO_DATA;
    }

    //
    // Allocate for the user and copy out the info
    //

    dwOutSize = pInfo->Count * sizeof(IP_INTERFACE_NAME_INFO);

    *ppTable = HeapAlloc(hHeap,
                         dwFlags,
                         dwOutSize);

    if(*ppTable is NULL)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 pInfo);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy out the info
    //

    for(i = 0; i < pInfo->Count; i++)
    {
        //
        // Structure copy
        //

        (*ppTable)[i] = pInfo->Info[i];
    }

    if(pInfo->Count and bOrder)
    {
        qsort(*ppTable,
              pInfo->Count,
              sizeof(IP_INTERFACE_NAME_INFO),
              NhiCompareIfInfoRow);
    }

    *pdwCount = pInfo->Count;

    HeapFree(g_hPrivateHeap,
             0,
             pInfo);

    return NO_ERROR;
}


// ========================================================================

DWORD
AllocateAndGetIpAddrTableFromStack(
    OUT MIB_IPADDRTABLE   **ppIpAddrTable,
    IN  BOOL              bOrder,
    IN  HANDLE            hHeap,
    IN  DWORD             dwFlags
    )
{
    DWORD   dwResult,dwCount;
    DWORD   dwOutBufLen;

    MIB_IPSTATS IpSnmpInfo;

    *ppIpAddrTable = NULL;

    //
    // Find out the number of entries the stack has. It returns this as part of
    // the IP Stats
    //

    dwResult = GetIpStatsFromStack(&IpSnmpInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetIpAddrTableFromStack: Couldnt get Ip Stats From stack. Error %d",
               dwResult);

        return dwResult;
    }

    //
    // Add extra to take care of increase between the two calls
    //

    dwCount        = IpSnmpInfo.dwNumAddr + OVERFLOW_COUNT;
    dwOutBufLen    = SIZEOF_IPADDRTABLE(dwCount);

    *ppIpAddrTable = HeapAlloc(hHeap,
                               dwFlags,
                               dwOutBufLen);

    if(*ppIpAddrTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "AllocateAndGetIpAddrTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        return dwResult;
    }

    if(IpSnmpInfo.dwNumAddr is 0)
    {
        //
        // Just return an empty table.
        // We do this because there is some code in MIB-II agent that
        // expects to get a table back, even if there are not entries in
        // it.
        //


        (*ppIpAddrTable)->dwNumEntries = 0;

        return NO_ERROR;
    }

    dwResult = GetIpAddrTableFromStack(*ppIpAddrTable,
                                       dwOutBufLen,
                                       bOrder);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetIpAddrTableFromStack: Error %d GetIpAddrTableFromStack",
               dwResult);
        HeapFree(hHeap, dwFlags, *ppIpAddrTable);
        *ppIpAddrTable = NULL;
    }

    return dwResult;
}

// ========================================================================

DWORD
GetIpAddrTableFromStack(
    OUT PMIB_IPADDRTABLE  pIpAddrTable,
    IN  DWORD             dwSize,
    IN  BOOL              bOrder
    )
{
    DWORD       dwOutBufLen, dwInBufLen, dwResult;
    BYTE        *Context;
    TDIObjectID *ID;

    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP_MIB_ADDRTABLE_ENTRY_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);

    ZeroMemory(Context,CONTEXT_SIZE);

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = dwSize - FIELD_OFFSET(MIB_IPADDRTABLE, table[0]);

    dwResult = TCPQueryInformationEx(AF_INET,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)(pIpAddrTable->table),
                                     &dwOutBufLen);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpAddrTableFromStack: Couldnt Query information from stack. Error %x",
               dwResult);

        return (dwResult);
    }

    pIpAddrTable->dwNumEntries = (dwOutBufLen / sizeof(MIB_IPADDRROW));

    //
    // Now sort the address table.  Key is IP address.
    //

    if((pIpAddrTable->dwNumEntries > 0) and bOrder)
    {
        qsort(pIpAddrTable->table,
              pIpAddrTable->dwNumEntries,
              sizeof(MIB_IPADDRROW),
              CompareIpAddrRow);
    }

    return NO_ERROR;
}

// ========================================================================

DWORD
AllocateAndGetTcpTableFromStack(
    OUT MIB_TCPTABLE  **ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags
    )
{
    DWORD           dwResult,dwCount;
    DWORD           dwOutBufLen;
    MIB_TCPSTATS    TcpInfo;

    *ppTcpTable = NULL;

    //
    // Find out the number of entries the stack has. It returns this as part of
    // the Tcp Stats
    //

    dwResult = GetTcpStatsFromStack(&TcpInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetTcpTableFromStack: Couldnt get Tcp Stats From stack. Error %d",
               dwResult);

        return dwResult;
    }


    dwCount     = TcpInfo.dwNumConns + OVERFLOW_COUNT;
    dwOutBufLen = SIZEOF_TCPTABLE(dwCount);

    *ppTcpTable = HeapAlloc(hHeap,
                            dwFlags,
                            dwOutBufLen);

    if(*ppTcpTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "AllocateAndGetTcpTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        return dwResult;
    }

    if(TcpInfo.dwNumConns is 0)
    {
        (*ppTcpTable)->dwNumEntries = 0;

        return NO_ERROR;
    }

    dwResult = GetTcpTableFromStack(*ppTcpTable,
                                    dwOutBufLen,
                                    bOrder);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetTcpTableFromStack: Error %d GetTcpTableFromStack",
               dwResult);
        HeapFree(hHeap, dwFlags, *ppTcpTable);
        *ppTcpTable = NULL;
    }

    return dwResult;
}

// ========================================================================

DWORD
GetTcpTableFromStack(
    OUT PMIB_TCPTABLE   pTcpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder
    )
{
    DWORD       dwInBufLen, dwOutBufLen, dwResult;
    TDIObjectID *ID;
    BYTE        *Context;

    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CO_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = TCP_MIB_TABLE_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = dwSize - FIELD_OFFSET(MIB_TCPTABLE, table[0]);

    dwResult = TCPQueryInformationEx(AF_INET,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)(pTcpTable->table),
                                     &dwOutBufLen);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetTcpTableFromStack: Couldnt query stack. Error %x",
               dwResult);

        return dwResult;
    }

    pTcpTable->dwNumEntries = (dwOutBufLen/sizeof(MIB_TCPROW));

    if((pTcpTable->dwNumEntries > 0) and bOrder)
    {

        qsort(pTcpTable->table,
              pTcpTable->dwNumEntries,
              sizeof(MIB_TCPROW),
              CompareTcpRow);

    }

    return NO_ERROR;
}

// ========================================================================

DWORD
SetTcpEntryToStack(
    IN PMIB_TCPROW pTcpRow
    )
{
    TCP_REQUEST_SET_INFORMATION_EX    *ptrsiInBuf;
    TDIObjectID                       *ID;
    MIB_TCPROW                        *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

#define REQ_SIZE    sizeof(TCP_REQUEST_SET_INFORMATION_EX) +    \
                    sizeof(MIB_TCPROW) - 1

    BYTE    rgbyBuffer[REQ_SIZE + 4]; // +4 to avoid any alignment problems


    ptrsiInBuf  = (TCP_REQUEST_SET_INFORMATION_EX *)rgbyBuffer;

    dwInBufLen  = REQ_SIZE;

#undef REQ_SIZE

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ID = &ptrsiInBuf->ID;

    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_entity.tei_entity   = CO_TL_ENTITY;
    ID->toi_id                  = TCP_MIB_TABLE_ID;
    ID->toi_entity.tei_instance = 0;

    copyInfo    = (MIB_TCPROW*)ptrsiInBuf->Buffer;
    *copyInfo   = *pTcpRow;

    ptrsiInBuf->BufferSize      = sizeof(TCPConnTableEntry);

    dwResult = TCPSetInformationEx((PVOID)ptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);


    return dwResult;
}

// ========================================================================

DWORD
AllocateAndGetUdpTableFromStack(
    OUT MIB_UDPTABLE  **ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags
    )
{
    DWORD           dwResult, dwCount, dwOutBufLen;
    MIB_UDPSTATS    UdpInfo;

    *ppUdpTable = NULL;

    //
    // Find out the number of entries the stack has. It returns this as part of
    // the Tcp Stats
    //

    dwResult = GetUdpStatsFromStack(&UdpInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetUdpTableFromStack: Couldnt get Udp Stats From stack. Error %d",
               dwResult);

        return dwResult;
    }

    dwCount     = UdpInfo.dwNumAddrs + OVERFLOW_COUNT;

    dwOutBufLen = SIZEOF_UDPTABLE(dwCount);

    *ppUdpTable = HeapAlloc(hHeap,
                            dwFlags,
                            dwOutBufLen);
    if(*ppUdpTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "AllocateAndGetUdpTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        return dwResult;
    }

    if(UdpInfo.dwNumAddrs is 0)
    {
        (*ppUdpTable)->dwNumEntries = 0;

        return NO_ERROR;
    }

    dwResult = GetUdpTableFromStack(*ppUdpTable,
                                    dwOutBufLen,
                                    bOrder);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetUdpTableFromStack: Error %d GetUdpTableFromStack",
               dwResult);
        HeapFree(hHeap, dwFlags, *ppUdpTable);
        *ppUdpTable = NULL;
    }

    return dwResult;
}

// ========================================================================

DWORD
GetUdpTableFromStack(
    OUT PMIB_UDPTABLE   pUdpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder
    )
{
    DWORD   dwInBufLen, dwOutBufLen, dwResult;
    BYTE    *Context;

    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CL_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = UDP_MIB_TABLE_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = dwSize - FIELD_OFFSET(MIB_UDPTABLE, table[0]);

    dwResult = TCPQueryInformationEx(AF_INET,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)(pUdpTable->table),
                                     &dwOutBufLen);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetUdpTableFromStack: Couldnt query TCP information. Error %d",
               dwResult);

        return dwResult;
    }

    pUdpTable->dwNumEntries = (dwOutBufLen / sizeof(MIB_UDPROW));

    //
    // Now sort the UDP connection table.  Keys are: local address, and local
    // port.
    //

    if((pUdpTable->dwNumEntries > 0) and bOrder)
    {
        qsort(pUdpTable->table,
              pUdpTable->dwNumEntries,
              sizeof(MIB_UDPROW),
              CompareUdpRow);
    }

    TraceLeave("GetUdpTableFromStack");

    return NO_ERROR;
}

// ========================================================================

DWORD
AllocateAndGetIpForwardTableFromStack(
    OUT MIB_IPFORWARDTABLE  **ppForwardTable,
    IN  BOOL                bOrder,
    IN  HANDLE              hHeap,
    IN  DWORD               dwFlags
    )
{
    DWORD       dwResult,dwCount,dwOutBufLen;
    MIB_IPSTATS IpInfo;
    DWORD       dwLoops;

    TraceEnter("AllocateAndGetIpForwardTableFromStack");

    *ppForwardTable = NULL;

    dwLoops = 0;

    while(dwLoops <= 1)
    {
        //
        // Find out the number of entries the stack has. It returns this as 
        // part of the IP Stats
        //

        dwResult = GetIpStatsFromStack(&IpInfo);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"Couldnt get Ip Stats From stack. Error %d",
                   dwResult);

            return dwResult;
        }

        dwCount = IpInfo.dwNumRoutes + ROUTE_OVERFLOW_COUNT + (dwLoops * 50);

        dwOutBufLen = SIZEOF_IPFORWARDTABLE(dwCount);

        *ppForwardTable = HeapAlloc(hHeap,
                                    dwFlags,
                                    dwOutBufLen);

        if(*ppForwardTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace1(ERR,
                   "AllocateAndGetIpForwardTableFromStack: Couldnt allocate memory. Error %d",
                   dwResult);

            return dwResult;
        }

        if(IpInfo.dwNumRoutes is 0)
        {
            (*ppForwardTable)->dwNumEntries = 0;

            TraceLeave("AllocateAndGetIPForwardTableFromStack");

            return NO_ERROR;
        }

        dwResult = GetIpForwardTableFromStack(*ppForwardTable,
                                              dwOutBufLen,
                                              bOrder);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "AllocateAndGetIpForwardTableFromStack: Error %d GetIpForwardTableFromStack",
                   dwResult);

            HeapFree(hHeap,
                     dwFlags,
                     *ppForwardTable);

            *ppForwardTable = NULL;
        }

        if(dwResult is ERROR_MORE_DATA)
        {
            dwLoops++;
        }
        else
        {
            break;
        }
    }

    return dwResult;
}

// ========================================================================

DWORD
GetIpForwardTableFromStack(
    OUT PMIB_IPFORWARDTABLE pForwardTable,
    IN  DWORD               dwSize,
    IN  BOOL                bOrder
    )
{
    DWORD        dwInBufLen, dwOutBufLen, dwNumRoutes;
    DWORD        i, dwCount, dwResult;
    UCHAR        *Context;
    TDIObjectID  *ID;
    MIB_IPSTATS  IpInfo;
    IPRouteEntry *pTempTable;

    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;

    //
    // How many routes can the input buffer hold?
    //

    dwNumRoutes = (dwSize - FIELD_OFFSET(MIB_IPFORWARDTABLE,table[0]))/sizeof(MIB_IPFORWARDROW);

    //
    // Find out the number of entries the stack has. It returns this as part of
    // the IP Stats
    //

    dwResult = GetIpStatsFromStack(&IpInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"Couldnt get Ip Stats From stack. Error %d",
               dwResult);

        return dwResult;
    }

    dwCount     = IpInfo.dwNumRoutes + ROUTE_OVERFLOW_COUNT;
    dwOutBufLen = dwCount * sizeof(IPRouteEntry);

    pTempTable  = HeapAlloc(g_hPrivateHeap,
                            0,
                            dwOutBufLen);

    if(pTempTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "Couldnt allocate memory for temporary table. Error %d",
               dwResult);

        return dwResult;
    }

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP_MIB_RTTABLE_ENTRY_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory(Context,
               CONTEXT_SIZE );


    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

    dwResult = TCPQueryInformationEx(AF_INET,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)pTempTable,
                                     &dwOutBufLen );

    if(dwResult isnot NO_ERROR)
    {
        HeapFree(g_hPrivateHeap,
                 0,
                 pTempTable);

        Trace1(ERR,"Couldnt query stack. Error %x",
               dwResult);

        TraceLeave("GetIpForwardTableFromStack");

        return dwResult;
    }

    dwCount = (dwOutBufLen / sizeof(IPRouteEntry));

    if(dwNumRoutes >= dwCount)
    {
        //
        // There is space for all the entries returned by the stack
        //

        pForwardTable->dwNumEntries = dwCount;
    }
    else
    {
        //
        // Take the first dwNumRoute entries
        //

        pForwardTable->dwNumEntries = dwNumRoutes;

        dwResult = ERROR_MORE_DATA;
    }


    for (i = 0; i < pForwardTable->dwNumEntries; i++ )
    {
        ConvertRouteToForward(&(pTempTable[i]),
                              &(pForwardTable->table[i]));
    }

    HeapFree(g_hPrivateHeap,
             0,
             pTempTable);

    if((pForwardTable->dwNumEntries > 0) and bOrder)
    {
        qsort(pForwardTable->table,
              pForwardTable->dwNumEntries,
              sizeof(MIB_IPFORWARDROW),
              CompareIpForwardRow);
    }

    TraceLeave("GetIPForwardTableFromStack");

    return dwResult;
}

// ========================================================================

DWORD
AllocateAndGetIpNetTableFromStack(
    OUT MIB_IPNETTABLE **ppNetTable,
    IN  BOOL           bOrder,
    IN  HANDLE         hHeap,
    IN  DWORD          dwFlags,
    IN  BOOL           bForceUpdate
    )
{
    DWORD   dwResult, dwOutBufLen, dwNetEntryCount;
    DWORD   dwCount;


    TraceEnter("AllocateAndGetIpNetTableFromStack");

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    *ppNetTable    = NULL;

    EnterCriticalSection(&g_ipNetLock);

    dwResult = GetArpEntryCount(&dwNetEntryCount);

    LeaveCriticalSection(&g_ipNetLock);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetIpNetTableFromStack: Couldnt query Information from stack. Error %x",
               dwResult);

        TraceLeave("AllocateAndGetIpNetTableFromStack");

        return dwResult;
    }

    //
    // This is generally a memory hog
    //

    dwCount     = dwNetEntryCount + (g_dwNumArpEntEntries) * OVERFLOW_COUNT;
    dwOutBufLen = SIZEOF_IPNETTABLE(dwCount);

    *ppNetTable = HeapAlloc(hHeap,
                            dwFlags,
                            dwOutBufLen);

    if(*ppNetTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "AllocateAndGetIpNetTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        TraceLeave("AllocateAndGetIpNetTableFromStack");

        return dwResult;
    }

    if(dwNetEntryCount is 0)
    {
        (*ppNetTable)->dwNumEntries = 0;

        TraceLeave("AllocateAndGetIpNetTableFromStack");

        return NO_ERROR;
    }

    dwResult = GetIpNetTableFromStack(*ppNetTable,
                                      dwOutBufLen,
                                      bOrder,
                                      bForceUpdate);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetIpNetTableFromStack: Error %d GetIpNetTableFromStack",
               dwResult);
        HeapFree(hHeap, dwFlags, *ppNetTable);
        *ppNetTable = NULL;
    }

    TraceLeave("AllocateAndGetIpNetTableFromStack");

    return dwResult;
}

// ========================================================================

DWORD
GetIpNetTableFromStack(
    OUT PMIB_IPNETTABLE pNetTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder,
    IN  BOOL            bForceUpdate
    )
{
    TDIObjectID *ID;
    PBYTE       pbyEnd, pbyStart, Context;
    DWORD       dwNumAdded,dwValidNetEntries;
    DWORD       dwInBufLen,dwOutBufLen;
    DWORD       dwResult, dwErr, i;

    TCP_REQUEST_QUERY_INFORMATION_EX    trqiInBuf;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    dwValidNetEntries = 0;

    dwErr = NO_ERROR;

    //
    // Now query the stack for the IpNet tables of each of the arp entities
    //

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity = AT_ENTITY;
    ID->toi_type              = INFO_TYPE_PROVIDER;
    ID->toi_class             = INFO_CLASS_PROTOCOL;
    ID->toi_id                = AT_MIB_ADDRXLAT_ENTRY_ID;

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

    pbyStart    = (PBYTE)(pNetTable->table);
    pbyEnd      = (PBYTE)((PBYTE)pNetTable + dwSize);

    EnterCriticalSection(&g_ipNetLock);

    if(bForceUpdate or
       (g_dwLastArpUpdateTime is 0) or
       ((GetCurrentTime() - g_dwLastArpUpdateTime) > ARP_CACHE_LIFE))
    {
        dwResult = UpdateAdapterToATInstanceMapping();

        if(dwResult isnot NO_ERROR)
        {
            LeaveCriticalSection(&g_ipNetLock);

            Trace1(ERR,
                   "GetIpNetTableFromStack: Couldnt update AT Map. Error %d",
                   dwResult);

            TraceLeave("GetIpNetTableFromStack");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    for(i = 0; i < g_dwNumArpEntEntries; i++ )
    {
        //
        // If the current buffer wont hold even one row, stop
        //

        dwOutBufLen = (DWORD)(pbyEnd - pbyStart);

        if(dwOutBufLen < sizeof(MIB_IPNETROW))
        {
            dwErr = ERROR_MORE_DATA;

            break;
        }

        ID->toi_entity.tei_instance = g_pdwArpEntTable[i];

        ZeroMemory(Context, CONTEXT_SIZE);

        dwResult = TCPQueryInformationEx(AF_INET,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         (PVOID)pbyStart,
                                         &dwOutBufLen);

        if (dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"Query to Arp Entity id %d for ARP Table failed. Error %d",
                   dwResult);

            dwErr = ERROR_MORE_DATA;

            continue;
        }

        dwNumAdded         = dwOutBufLen/(sizeof(MIB_IPNETROW));
        pbyStart          += dwOutBufLen;
        dwValidNetEntries += dwNumAdded;
    }

    pNetTable->dwNumEntries = dwValidNetEntries;

    //
    // Now sort the net table. Keys are IF index and address
    //

    if((dwValidNetEntries > 0) and bOrder)
    {
        qsort(pNetTable->table,
              dwValidNetEntries,
              sizeof(MIB_IPNETROW),
              CompareIpNetRow);
    }

    LeaveCriticalSection(&g_ipNetLock);

    TraceLeave("GetIpNetTableFromStack");

    return dwErr;
}

// ========================================================================

DWORD
GetIpStatsFromStackEx(
    OUT PMIB_IPSTATS pIpStats,
    IN  DWORD        dwFamily
    )
{
    DWORD       dwResult, dwInBufLen, dwOutBufLen;
    TDIObjectID *ID;
    BYTE        *Context;


    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;

    TraceEnter("GetIpStatsFromStackEx");

    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();
    if (((dwFamily == AF_INET) && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        return ERROR_NOT_SUPPORTED;
    }

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(MIB_IPSTATS);

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP_MIB_STATS_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory(Context, CONTEXT_SIZE);

    dwResult = TCPQueryInformationEx(dwFamily,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)pIpStats,
                                     &dwOutBufLen);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"Couldnt query stack. Error %d",
               dwResult);
        TraceLeave("GetIpStatsFromStackEx");

        return dwResult;
    }

    TraceLeave("GetIpStatsFromStackEx");

    return NO_ERROR;
}

// ========================================================================

DWORD
GetIpStatsFromStack(
    OUT PMIB_IPSTATS pIpStats
    )
{
    return GetIpStatsFromStackEx(pIpStats, AF_INET);
}

// ========================================================================

DWORD
SetIpStatsToStack(
    IN PMIB_IPSTATS pIpStats
    )
{
    TCP_REQUEST_SET_INFORMATION_EX    *ptrsiInBuf;
    TDIObjectID                       *ID;
    MIB_IPSTATS                        *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

#define REQ_SIZE    sizeof(TCP_REQUEST_SET_INFORMATION_EX) +    \
                    sizeof(MIB_IPSTATS) - 1

    BYTE    rgbyBuffer[REQ_SIZE + 4]; // +4 to avoid any alignment problems

    ptrsiInBuf  = (TCP_REQUEST_SET_INFORMATION_EX *)rgbyBuffer;

    dwInBufLen  = REQ_SIZE;

#undef REQ_SIZE

    TraceEnter("SetIpStatsToStack");

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ID = &ptrsiInBuf->ID;

    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_id                  = IP_MIB_STATS_ID;
    ID->toi_entity.tei_instance = 0;

    copyInfo    = (MIB_IPSTATS*)ptrsiInBuf->Buffer;
    *copyInfo   = *pIpStats;

    ptrsiInBuf->BufferSize = sizeof(IPSNMPInfo);

    dwResult = TCPSetInformationEx((PVOID)ptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);


    TraceLeave("SetIpStatsToStack");

    return dwResult;
}

// ========================================================================

DWORD
GetIcmpStatsFromStackEx(
    OUT PVOID     pIcmpStats,
    IN  DWORD     dwFamily
    )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetIcmpStatsFromStackEx");

    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();
    if (((dwFamily == AF_INET) && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        return ERROR_NOT_SUPPORTED;
    }

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;

    if (dwFamily == AF_INET) 
    {
        ID->toi_entity.tei_entity   = ER_ENTITY;
        ID->toi_id                  = ICMP_MIB_STATS_ID;

        dwOutBufLen = sizeof(MIB_ICMP);
    } 
    else
    {
        ID->toi_entity.tei_entity   = CL_NL_ENTITY;
        ID->toi_id                  = ICMP6_MIB_STATS_ID;

        dwOutBufLen = sizeof(ICMPv6SNMPInfo);
    }

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory(Context,CONTEXT_SIZE);

    dwResult = TCPQueryInformationEx(dwFamily,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)pIcmpStats,
                                     &dwOutBufLen);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"Couldnt query stack. Error %x",
               dwResult);
        TraceLeave("GetIcmpStatsFromStackEx");

        return dwResult;
    }

    TraceLeave("GetIcmpStatsFromStackEx");

    return NO_ERROR;
}

// ========================================================================

DWORD
GetIcmpStatsFromStack(
    OUT PMIB_ICMP pIcmpStats
    )
{
    return GetIcmpStatsFromStackEx(pIcmpStats, AF_INET);
}

// ========================================================================

DWORD
GetUdpStatsFromStackEx(
    OUT PMIB_UDPSTATS pUdpStats,
    IN  DWORD         dwFamily
    )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetUdpStatsFromStack");

    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();
    if (((dwFamily == AF_INET) && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        return ERROR_NOT_SUPPORTED;
    }

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(MIB_UDPSTATS);

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CL_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = UDP_MIB_STAT_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    dwResult = TCPQueryInformationEx(dwFamily,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)pUdpStats,
                                     &dwOutBufLen );

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"Couldnt query stack. Error %x",
               dwResult);
        TraceLeave("GetUdpStatsFromStack");

        return dwResult;
    }

    TraceLeave("GetUdpStatsFromStack");

    return NO_ERROR;
}

// ========================================================================

DWORD
GetUdpStatsFromStack(
    OUT PMIB_UDPSTATS pUdpStats
    )
{
    return GetUdpStatsFromStackEx(pUdpStats, AF_INET);
}

// ========================================================================

DWORD
GetTcpStatsFromStackEx(
    OUT PMIB_TCPSTATS pTcpStats,
    IN  DWORD         dwFamily
    )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetTcpStatsFromStack");

    if ((dwFamily != AF_INET) && (dwFamily != AF_INET6))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CheckTcpipState();
    if (((dwFamily == AF_INET) && !g_bIpConfigured) ||
        ((dwFamily == AF_INET6) && !g_bIp6Configured))
    {
        return ERROR_NOT_SUPPORTED;
    }

    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    dwOutBufLen = sizeof( MIB_TCPSTATS );

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CO_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = TCP_MIB_STAT_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory(Context,CONTEXT_SIZE);

    dwResult = TCPQueryInformationEx(dwFamily,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)pTcpStats,
                                     &dwOutBufLen );

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"Couldnt query stack. Error %x",
               dwResult);
        TraceLeave("GetTcpStatsFromStack");

        return dwResult;
    }

    TraceLeave("GetTcpStatsFromStack");

    return NO_ERROR;
}

// ========================================================================

DWORD
GetTcpStatsFromStack(
    OUT PMIB_TCPSTATS pTcpStats
    )
{
    return GetTcpStatsFromStackEx(pTcpStats, AF_INET);
}

// ========================================================================

DWORD
SetIpNetEntryToStack(
    IN MIB_IPNETROW *pNetRow,
    IN BOOL         bForceUpdate
    )
{
    TCP_REQUEST_SET_INFORMATION_EX  *ptrsiInBuf;
    TDIObjectID                     *ID;

    MIB_IPNETROW                    *copyInfo;
    DWORD                           dwInBufLen,dwOutBufLen,dwResult;
    DWORD                           dwInstance;

#define REQ_SIZE    sizeof(TCP_REQUEST_SET_INFORMATION_EX) +    \
                    sizeof(MIB_IPNETROW) - 1

    BYTE    rgbyBuffer[REQ_SIZE + 4]; // +4 to avoid any alignment problems

    ptrsiInBuf  = (TCP_REQUEST_SET_INFORMATION_EX *)rgbyBuffer;

    dwInBufLen  = REQ_SIZE;

#undef REQ_SIZE

    TraceEnter("SetIpNetEntryToStack");

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    EnterCriticalSection(&g_ipNetLock);

    if(bForceUpdate or
       (g_dwLastArpUpdateTime is 0) or
       ((GetCurrentTime() - g_dwLastArpUpdateTime) < ARP_CACHE_LIFE))
    {
        dwResult = UpdateAdapterToATInstanceMapping();

        if(dwResult isnot NO_ERROR)
        {
            LeaveCriticalSection(&g_ipNetLock);

            Trace1(ERR,"Couldnt update AT Map. Error %d",dwResult);
            TraceLeave("SetIpNetEntryToStack");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    dwInstance = GetATInstanceFromAdapter(pNetRow->dwIndex);

    if(dwInstance is INVALID_AT_INSTANCE)
    {
        dwResult = UpdateAdapterToATInstanceMapping();

        if(dwResult isnot NO_ERROR)
        {
            LeaveCriticalSection(&g_ipNetLock);

            Trace1(ERR,"Couldnt update AT Map. Error %d",dwResult);

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    LeaveCriticalSection(&g_ipNetLock);

    ID = &ptrsiInBuf->ID;

    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_entity.tei_entity   = AT_ENTITY;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = AT_MIB_ADDRXLAT_ENTRY_ID;
    ID->toi_entity.tei_instance = dwInstance;

    //
    // Since MIB_IPNETROW is a fixed size structure
    //

    copyInfo    = (MIB_IPNETROW*)ptrsiInBuf->Buffer;
    *copyInfo   = *pNetRow;
    dwOutBufLen = 0;

    ptrsiInBuf->BufferSize = sizeof(IPNetToMediaEntry);


    dwResult = TCPSetInformationEx((PVOID)ptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);


    TraceLeave("SetIpNetEntryToStack");

    return dwResult;
}

DWORD
FlushIpNetTableFromStack(
    IN DWORD    dwIfIndex
    )
{
#ifdef _WIN95_

    return ERROR_NOT_SUPPORTED;

#else

    DWORD status;
    DWORD requestBufferSize = sizeof(DWORD);
    DWORD OutBufLen= 0;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    status = TCPSendIoctl(g_hIPDriverHandle,
                          IOCTL_IP_FLUSH_ARP_TABLE,
                          &dwIfIndex,
                          &requestBufferSize,
                          NULL,
                          &OutBufLen);

#endif
    return(status);

}

DWORD
SetProxyArpEntryToStack(
    DWORD   dwAddress,
    DWORD   dwMask,
    DWORD   dwAdapterIndex,
    BOOL    bAddEntry,
    BOOL    bForceUpdate
    )
{
    DWORD           dwResult, dwATInstance, dwInBufLen, dwOutBufLen;
    ProxyArpEntry   *pEntry;
    TDIObjectID     *pID;

    PTCP_REQUEST_SET_INFORMATION_EX  ptrsiInBuf;

#define REQ_SIZE    sizeof(TCP_REQUEST_SET_INFORMATION_EX) +    \
                    sizeof(ProxyArpEntry) - 1

    BYTE    rgbyBuffer[REQ_SIZE + 4]; // +4 to avoid any alignment problems

    ptrsiInBuf  = (TCP_REQUEST_SET_INFORMATION_EX *)rgbyBuffer;

    dwInBufLen  = REQ_SIZE;

#undef REQ_SIZE

    TraceEnter("SetProxyArpEntryToStack");

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    EnterCriticalSection(&g_ipNetLock);

    if(bForceUpdate or
       (g_dwLastArpUpdateTime is 0) or
       ((GetCurrentTime() - g_dwLastArpUpdateTime) < ARP_CACHE_LIFE))
    {
        dwResult = UpdateAdapterToATInstanceMapping();

        if(dwResult isnot NO_ERROR)
        {
            LeaveCriticalSection(&g_ipNetLock);

            Trace1(ERR,"Couldnt update AT Map. Error %d",dwResult);

            TraceLeave("SetProxyArpEntryToStack");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    dwATInstance = GetATInstanceFromAdapter(dwAdapterIndex);

    if(dwATInstance is INVALID_IF_INSTANCE)
    {
        LeaveCriticalSection(&g_ipNetLock);

        Trace1(ERR,
               "SetProxyArpEntryToStacki: Couldnt get AT instance for %d",
               dwAdapterIndex);

        TraceLeave("SetProxyArpEntryToStack");

        return ERROR_INVALID_PARAMETER;
    }

    LeaveCriticalSection(&g_ipNetLock);

    pID = &ptrsiInBuf->ID;

    pID->toi_entity.tei_entity      = AT_ENTITY;
    pID->toi_entity.tei_instance    = dwATInstance;

    pID->toi_type   = INFO_TYPE_PROVIDER;
    pID->toi_class  = INFO_CLASS_IMPLEMENTATION;
    pID->toi_id     = AT_ARP_PARP_ENTRY_ID;

    //
    // Fill in the set entry, and pass it down.
    //

    pEntry = (ProxyArpEntry *)ptrsiInBuf->Buffer;

    pEntry->pae_status  = (bAddEntry ? PAE_STATUS_VALID : PAE_STATUS_INVALID);
    pEntry->pae_addr    = dwAddress;
    pEntry->pae_mask    = dwMask;

    ptrsiInBuf->BufferSize = sizeof(ProxyArpEntry);

    dwOutBufLen = 0;

    dwResult = TCPSetInformationEx((PVOID)ptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);


    TraceLeave("SetProxyArpEntryToStack");

    return dwResult;
}

// ========================================================================

DWORD
GetArpEntryCount(
    OUT PDWORD  pdwNumEntries
    )
{
    DWORD   dwResult, i;
    DWORD   dwInBufLen, dwOutBufLen;

    TCP_REQUEST_QUERY_INFORMATION_EX    trqiInBuf;
    TDIObjectID                         *ID;
    UCHAR                               *Context;
    AddrXlatInfo                        AXI;

    *pdwNumEntries = 0;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity = AT_ENTITY;
    ID->toi_type              = INFO_TYPE_PROVIDER;



    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

    for (i = 0; i < g_dwNumArpEntEntries; i++ )
    {
        //
        // First add up the AXI counts
        //

        ID->toi_class               = INFO_CLASS_PROTOCOL;
        ID->toi_id                  = AT_MIB_ADDRXLAT_INFO_ID;
        ID->toi_entity.tei_instance = g_pdwArpEntTable[i];

        dwOutBufLen = sizeof(AXI);

        ZeroMemory(Context, CONTEXT_SIZE);

        dwResult = TCPQueryInformationEx(AF_INET,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         &AXI,
                                         &dwOutBufLen);

        if (dwResult == ERROR_INVALID_FUNCTION)
        {
            Trace0(ERR, "GetArpEntryCount: ERROR_INVALID_FUNCTION, axi_count = 0");
            AXI.axi_count = 0;
        }
        else if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,"GetArpEntryCount: Couldnt query Information from stack. Error %x",
                   dwResult);

            return dwResult;
        }

        //
        // Increment the total number of entries
        //

        *pdwNumEntries += AXI.axi_count;
    }

    return NO_ERROR;
}

// ========================================================================

DWORD
AllocateAndGetArpEntTableFromStack(
    OUT PDWORD    *ppdwArpEntTable,
    OUT PDWORD    pdwNumEntries,
    IN  HANDLE    hHeap,
    IN  DWORD     dwAllocFlags,
    IN  DWORD     dwReAllocFlags
    )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    DWORD                              dwATType;
    UCHAR                              *Context;
    TDIObjectID                        *ID;
    TDIEntityID                        *pEntTable;
    DWORD                              dwNumEntities,dwCurrEntries;
    DWORD                              i,dwCount ;

    TraceEnter("GetArpEntTableFromStack");

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    *ppdwArpEntTable = NULL;
    *pdwNumEntries   = 0;

    pEntTable = GetTdiEntityCount(&dwNumEntities);
    if (!pEntTable)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Create a table that will hold 16 entries
    //

    dwCurrEntries = 16;
    *ppdwArpEntTable = HeapAlloc(hHeap,
                                 dwAllocFlags,
                                 dwCurrEntries*sizeof(DWORD));

    if(*ppdwArpEntTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,"GetArpEntTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        HeapFree(g_hPrivateHeap,0,pEntTable);
        return dwResult;
    }

    dwCount       = 0;

    Trace1(ERR, "Numberofentities %d \n", dwNumEntities);

    for(i = 0; i < dwNumEntities; i++)
    {
        //
        // See which ones are AT
        //

        if(pEntTable[i].tei_entity is AT_ENTITY)
        {
            //
            // Query the entity to see if it supports ARP
            //

            ID = &(trqiInBuf.ID);

            ID->toi_entity.tei_entity   = AT_ENTITY;
            ID->toi_class               = INFO_CLASS_GENERIC;
            ID->toi_type                = INFO_TYPE_PROVIDER;
            ID->toi_id                  = ENTITY_TYPE_ID;
            ID->toi_entity.tei_instance = pEntTable[i].tei_instance;

            Trace1(ERR,
               "Querying for instance %d \n", pEntTable[i].tei_instance);

            dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
            dwOutBufLen = sizeof(dwATType);

            Context = (BYTE *) &(trqiInBuf.Context[0]);
            ZeroMemory(Context,CONTEXT_SIZE);

            dwResult = TCPQueryInformationEx(AF_INET,
                                             &trqiInBuf,
                                             &dwInBufLen,
                                             (PVOID)&dwATType,
                                             &dwOutBufLen );

            if(dwResult is ERROR_INVALID_FUNCTION)
            {
                //
                // Doesnt support ARP
                //

                continue;
            }

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,"GetArpEntTableFromStack: Couldnt query information. Error %x",
                       dwResult);
                HeapFree(hHeap,0,*ppdwArpEntTable);
                HeapFree(g_hPrivateHeap,0,pEntTable);
                return dwResult;
            }

            if(dwATType is AT_ARP)
            {
                //
                // The entity is an AT_ENTITY that supports ARP. Add the instance
                // to the arp entity table. If the current count >= current size of
                // table, means we have run out of space, so reallocate and get double
                // the space
                //

                if(dwCount is dwCurrEntries)
                {
                    PDWORD pdwNewTable;
                    pdwNewTable = HeapReAlloc(hHeap,
                                              dwReAllocFlags,
                                              (PVOID)*ppdwArpEntTable,
                                              ((dwCurrEntries)<<1)*sizeof(DWORD));

                    if(pdwNewTable is NULL)
                    {
                        dwResult = GetLastError();

                        Trace1(ERR,"GetArpEntTableFromStack: Couldnt reallocate memory. Error %d",
                               dwResult);

                        HeapFree(hHeap,0,*ppdwArpEntTable);
                        HeapFree(g_hPrivateHeap,0,pEntTable);
                        return dwResult;
                    }
                    *ppdwArpEntTable = pdwNewTable;
                    dwCurrEntries = dwCurrEntries<<1;
                }

                (*ppdwArpEntTable)[dwCount] = pEntTable[i].tei_instance;

                dwCount++;
            }
        }
    }

    HeapFree(g_hPrivateHeap,0,pEntTable);

    *pdwNumEntries = dwCount;

    return NO_ERROR;
}

// ========================================================================

DWORD
SetIpForwardEntryToStack(
    IN PMIB_IPFORWARDROW pForwardRow
    )
{
    IPRouteEntry         route;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ConvertForwardToRoute((&route),pForwardRow);

    return SetIpRouteEntryToStack(&route);
}

// ========================================================================

DWORD
SetIpRouteEntryToStack(
    IN IPRouteEntry *pRoute
    )
{
    TDIObjectID *pObject;
    DWORD       dwOutBufLen, dwInBufLen, dwResult;

    TCP_REQUEST_SET_INFORMATION_EX  *ptrsiBuffer;
    IPRouteEntry                    *copyInfo;

#define REQ_SIZE    sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry) - 1

    BYTE    rgbyBuffer[REQ_SIZE + 4]; // +4 to avoid any alignment problems


    ptrsiBuffer = (TCP_REQUEST_SET_INFORMATION_EX *)rgbyBuffer;

    dwInBufLen  = REQ_SIZE;

#undef REQ_SIZE

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ptrsiBuffer->BufferSize = sizeof(IPRouteEntry);

    pObject                          = &ptrsiBuffer->ID;
    pObject->toi_id                  = IP_MIB_RTTABLE_ENTRY_ID;
    pObject->toi_type                = INFO_TYPE_PROVIDER;
    pObject->toi_class               = INFO_CLASS_PROTOCOL;
    pObject->toi_entity.tei_entity   = CL_NL_ENTITY;
    pObject->toi_entity.tei_instance = 0;

    dwOutBufLen = 0;

    copyInfo  = (IPRouteEntry *)ptrsiBuffer->Buffer;
    *copyInfo = *pRoute;

    dwResult = TCPSetInformationEx((PVOID)ptrsiBuffer,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);

    return dwResult;
}


DWORD
SetIpMultihopRouteEntryToStack(
    IN IPMultihopRouteEntry *RouteEntry
    )
{
    ULONG  inpbuflen;
    ULONG  outbuflen;

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    inpbuflen = sizeof(IPMultihopRouteEntry);

    if (RouteEntry->imre_numnexthops > 2)
    {
        inpbuflen += (RouteEntry->imre_numnexthops - 2) *
                        sizeof(IPRouteNextHopEntry);
    }

    if (IsBadReadPtr(RouteEntry, inpbuflen)) {
      return ERROR_INVALID_PARAMETER;
    }

    return (TCPSendIoctl(
             g_hIPDriverHandle,
             IOCTL_IP_SET_MULTIHOPROUTE,
             RouteEntry,
             &inpbuflen,
             NULL,
             &outbuflen
             ));
}


DWORD
GetBestInterfaceFromStack(
    DWORD   dwDestAddress,
    PDWORD  pdwBestIfIndex
    )
{
#ifdef _WIN95_
  return ERROR_NOT_SUPPORTED;
#else
    DWORD status;
    DWORD requestBufferSize = sizeof(DWORD);
    DWORD OutBufLen= sizeof(DWORD);

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    status = TCPSendIoctl(g_hIPGetDriverHandle,
                          IOCTL_IP_GET_BEST_INTERFACE,
                          &dwDestAddress,
                          &requestBufferSize,
                          pdwBestIfIndex,
                          &OutBufLen);

   return(status);

#endif
}
// ========================================================================
//* TCPQueryInformationEx
//
// Description: Get information from the stack.
//
// Parameters:  HANDLE hHandle: handle to the stack.
//              TDIObjectID *ID: pointer to TDIObjectID info.
//              void *Buffer: buffer to receive data from the stack.
//              ulong *Bufferlen: IN: tells stack size of available buffer,
//                                OUT: tells us how much data is available.
//              CONTEXT *Context: allows queries spanning more than one call.
//
// Returns:     int:
//
//*

int
TCPQueryInformationEx(
    DWORD Family,
    void *InBuf,
    ulong *InBufLen,
    void *OutBuf,
    ulong *OutBufLen
    )
{

#ifdef CHICAGO
    //
    // This section is obsolete code
    //
    DWORD result;

    if( ! pWsControl ) {
        OpenTCPDriver(AF_INET);
    }
    if( ! pWsControl || (Family != AF_INET)) {
        DEBUG_PRINT(("TCPQueryInformationEx: !pWsControl.\n"));
        return ERROR_NOT_SUPPORTED;
    }

    assert( pWsControl );
    result = (
        (*pWsControl)(
            IPPROTO_TCP,
            WSCNTL_TCPIP_QUERY_INFO,
            InBuf,
            InBufLen ,
            OutBuf,
            OutBufLen
        ) );

    if( result ){
      return ConvertTdiErrorToDosError(result);
    }

    return NO_ERROR;

#else

    NTSTATUS           Status;
    IO_STATUS_BLOCK    IoStatusBlock;
    HANDLE             hEvent;
    HANDLE             hDriver = (Family == AF_INET)? g_hTCPDriverGetHandle :
                                                      g_hTCP6DriverGetHandle;
    
    hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if( NULL == hEvent ) return GetLastError();

    Status = NtDeviceIoControlFile(hDriver,
                                   hEvent,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   InBuf,
                                   *InBufLen,
                                   OutBuf,
                                   *OutBufLen );

    if ( Status == STATUS_PENDING )
    {

        Status = NtWaitForSingleObject(hEvent, FALSE, NULL );

        Status = IoStatusBlock.Status;
    }

    CloseHandle(hEvent);

    if ( !NT_SUCCESS( Status ) )
    {
        Trace1(ERR,"Device IOCTL failed in TCPQuery %x",Status);
        *OutBufLen = 0;
        return ( RtlNtStatusToDosError(Status) );
    }

    //
    // Tell caller how much was written
    //

    *OutBufLen = (ULONG)IoStatusBlock.Information;

    return ( NO_ERROR );

#endif
}



// ========================================================================
//* TCPSendIoctl
//
// Description: Get information from the stack.
//
// Parameters:  HANDLE hHandle: handle to the stack.
//              TDIObjectID *ID: pointer to TDIObjectID info.
//              void *Buffer: buffer to receive data from the stack.
//              ulong *Bufferlen: IN: tells stack size of available buffer,
//                                OUT: tells us how much data is available.
//              CONTEXT *Context: allows queries spanning more than one call.
//
// Returns:     int:
//
//*

int
TCPSendIoctl( HANDLE hHandle,
              ulong Ioctl,
              void *InBuf,
              ulong *InBufLen,
              void *OutBuf,
              ulong *OutBufLen)
{

#ifdef CHICAGO
    // OVERLAPPED overlap;

    uint ok;

    ok = DeviceIoControl( hHandle, Ioctl,
                          InBuf, *InBufLen,
                          OutBuf, *OutBufLen, OutBufLen,
                          NULL // &overlap
    );

    if( !ok ){
        int err = GetLastError();
        DEBUG_PRINT(("TCPSendIoctl: DeviceIoControl err %d\n", err ));
        return err;
    }

    return NO_ERROR;

#else

    NTSTATUS           Status;
    IO_STATUS_BLOCK    IoStatusBlock;
    HANDLE             hEvent;

    hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if( NULL == hEvent ) return GetLastError();
    ZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    Status = NtDeviceIoControlFile(hHandle,
                                   hEvent,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   Ioctl,
                                   InBuf,
                                   *InBufLen,
                                   OutBuf,
                                   *OutBufLen );

    if ( Status == STATUS_PENDING )
    {
        Status = NtWaitForSingleObject( hEvent, FALSE, NULL );
        Status = IoStatusBlock.Status;
    }

    CloseHandle(hEvent);

    if ( !NT_SUCCESS( Status ) )
    {
        Trace1(ERR,"Device IOCTL failed in TCPSendIoctl %x",Status);
        if (OutBufLen)
            *OutBufLen = (ULONG)IoStatusBlock.Information;
        return ( RtlNtStatusToDosError(Status) );
    }

    //
    // Tell caller how much was written
    //
    if (OutBufLen)
      *OutBufLen = (ULONG)IoStatusBlock.Information;

    return ( NO_ERROR );

#endif

}

// ========================================================================
//* TCPSetInformationEx()
//
// Description: Send information to the stack
//
// Parameters:  HANDLE hHandle: handle to the stack.
//              TDIObjectID *ID: pointer to TDIObjectID info.
//              void *Buffer: buffer to receive data from the stack.
//              ulong Bufferlen: tells stack size of available buffer,
//
// Returns:     int:
//
//*

int
TCPSetInformationEx(
    void    *InBuf,
    ULONG   *InBufLen,
    void    *OutBuf,
    ULONG   *OutBufLen
    )
{

#ifdef CHICAGO
    DWORD result;

    if( ! pWsControl )
        OpenTCPDriver(AF_INET);
    if( ! pWsControl ){
        DEBUG_PRINT(("TCPQueryInformationEx: !pWsControl.\n"));
        return 0;
    }

    assert( pWsControl );

    result = (
            (*pWsControl)(
                IPPROTO_TCP,
                WSCNTL_TCPIP_SET_INFO,
                InBuf,
                InBufLen,
                OutBuf,
                OutBufLen
            ) );

    if( result ){
      return ConvertTdiErrorToDosError(result);
    }

    return NO_ERROR;

#else


    NTSTATUS           Status;
    IO_STATUS_BLOCK    IoStatusBlock;

    if(g_hTCPDriverSetHandle is NULL)
    {
        return ERROR_NETWORK_ACCESS_DENIED;
    }

    Status = NtDeviceIoControlFile(g_hTCPDriverSetHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_SET_INFORMATION_EX,
                                   InBuf,
                                   *InBufLen,
                                   OutBuf,
                                   *OutBufLen );


    if ( Status == STATUS_PENDING )
    {
        Status = NtWaitForSingleObject(g_hTCPDriverSetHandle, FALSE, NULL );
        Status = IoStatusBlock.Status;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return ( RtlNtStatusToDosError(Status) );
    }

    return ( NO_ERROR );

#endif
}

// ========================================================================
// SYNOPSIS: opens handles to tcpip driver.
//
//    returns
//            0 == NO_ERROR == STATUS_SUCCESS  on success.
//            err or 1                         on failure.
//
// - MohsinA, 02-Jul-97.
//

DWORD
OpenTCPDriver(
    IN DWORD dwFamily
    )
{

#ifdef CHICAGO
    int err = 0;

    if (dwFamily != AF_INET) {
        return ERROR_INVALID_PARAMETER;
    }

    hWsock = LoadLibrary(TEXT("wsock32.dll"));

    if(! hWsock ){
        err = GetLastError();
        DEBUG_PRINT(("RTStartup: can't load wsock32.dll, %d\n", err ));
        DEBUG_PRINT(("OpenTcp: !hWsock\n"));
        return err? err: 1;
    }

    pWsControl = (LPWSCONTROL) GetProcAddress(hWsock, "WsControl");

    if (! pWsControl ){
        err = GetLastError();
        DEBUG_PRINT((
            "RTStartup: GetProcAddress(wsock32,WsControl) failed %d\n",
                         GetLastError()));
        return err? err: 1;
    }

    // open the handle to VIP

    g_hIPDriverHandle = NULL;
    g_hIPGetDriverHandle = NULL;

#ifndef _WIN95_
    g_hIPDriverHandle = OsOpenVxdHandle( "VIP",  VIP_Device_ID  );

    if( ! g_hIPDriverHandle ){
        err = GetLastError();
        DEBUG_PRINT(("no ip handle, err %d\n", err ));
        return err? err : 1;
    }

    g_hIPGetDriverHandle = g_hIPDriverHandle;
#endif
    return NO_ERROR;

#else

    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    PWCHAR pwszDdDeviceName;
    HANDLE *pDriverGetHandle, *pDriverSetHandle;

    switch (dwFamily) {
    case AF_INET:
        pwszDdDeviceName = DD_TCP_DEVICE_NAME;
        pDriverGetHandle = &g_hTCPDriverGetHandle;
        pDriverSetHandle = &g_hTCPDriverSetHandle;
        break;
    case AF_INET6:
        pwszDdDeviceName = DD_TCPV6_DEVICE_NAME;
        pDriverGetHandle = &g_hTCP6DriverGetHandle;
        pDriverSetHandle = &g_hTCP6DriverSetHandle;
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&nameString, pwszDdDeviceName);

    InitializeObjectAttributes(&objectAttributes, &nameString,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(pDriverGetHandle,
                          GENERIC_EXECUTE,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0);

    if(status isnot STATUS_SUCCESS)
    {
        return ERROR_OPEN_FAILED;
    }

    RtlInitUnicodeString(&nameString, pwszDdDeviceName);

    InitializeObjectAttributes(&objectAttributes, &nameString,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);


    NtCreateFile(pDriverSetHandle,
                 GENERIC_WRITE,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0);

    OpenIPDriver(dwFamily);

    return NO_ERROR;
#endif
}

// ========================================================================

DWORD
CloseTCPDriver()
{

#ifdef CHICAGO

    if( hWsock )
        FreeLibrary( hWsock );
    hWsock     = NULL;
    pWsControl = NULL;

    if (g_hIPDriverHandle)
      OsCloseVxdHandle( g_hIPDriverHandle );

    g_hIPDriverHandle = NULL;

    g_hIPGetDriverHandle = NULL;

#else

    if(g_hTCPDriverGetHandle isnot NULL)
    {
        CloseHandle (g_hTCPDriverGetHandle) ;
    }

    if(g_hTCPDriverSetHandle isnot NULL)
    {
        CloseHandle (g_hTCPDriverSetHandle) ;
    }


    CloseIPDriver();

#endif

    return NO_ERROR ;
}

DWORD
CloseTCP6Driver()
{
    if(g_hTCP6DriverGetHandle isnot NULL)
    {
        CloseHandle (g_hTCP6DriverGetHandle) ;
    }

    if(g_hTCP6DriverSetHandle isnot NULL)
    {
        CloseHandle (g_hTCP6DriverSetHandle) ;
    }


    CloseIP6Driver();

    return NO_ERROR ;
}

#ifndef CHICAGO
DWORD
OpenIPDriver(
    IN DWORD dwFamily
    )
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    PWCHAR pwszDdDeviceName;
    LPCTSTR ptszWinDeviceName;
    HANDLE *pDriverHandle, *pGetDriverHandle, *pChangeHandle;

    switch (dwFamily) {
    case AF_INET:
        pwszDdDeviceName  = DD_IP_DEVICE_NAME;
        ptszWinDeviceName = TEXT ("\\\\.\\Ip");
        pDriverHandle     = &g_hIPDriverHandle;
        pGetDriverHandle  = &g_hIPGetDriverHandle;
        pChangeHandle     = &ChangeNotificationHandle;
        break;
    case AF_INET6:
        pwszDdDeviceName  = DD_IPV6_DEVICE_NAME;
        ptszWinDeviceName = TEXT ("\\\\.\\Ip6");;
        pDriverHandle     = &g_hIP6GetDriverHandle;
        pGetDriverHandle  = &g_hIP6GetDriverHandle;
        pChangeHandle     = &Change6NotificationHandle;
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&nameString, pwszDdDeviceName);
	
    InitializeObjectAttributes(&objectAttributes, &nameString,
			       OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(pGetDriverHandle,
                          GENERIC_EXECUTE,
                          &objectAttributes, &ioStatusBlock, NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF, 0, NULL, 0);

    if (status == STATUS_SUCCESS) {

      RtlInitUnicodeString(&nameString, pwszDdDeviceName);

      InitializeObjectAttributes(&objectAttributes, &nameString,
                                 OBJ_CASE_INSENSITIVE, NULL, NULL);

      NtCreateFile(pDriverHandle,
                   SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                   &objectAttributes, &ioStatusBlock, NULL,
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   FILE_OPEN_IF, 0, NULL, 0);

      *pChangeHandle = CreateFile(ptszWinDeviceName,
                                  GENERIC_EXECUTE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                  NULL);


    }

    return (NO_ERROR);

}

DWORD
CloseIPDriver()
{
    if(g_hIPDriverHandle isnot NULL)
    {
        CloseHandle (g_hIPDriverHandle) ;
    }

    if(g_hIPGetDriverHandle isnot NULL)
    {
        CloseHandle (g_hIPGetDriverHandle) ;
    }

    if (ChangeNotificationHandle isnot NULL)
    {
        CloseHandle (ChangeNotificationHandle);
    }

    return NO_ERROR ;
}

DWORD
CloseIP6Driver()
{
    if(g_hIP6DriverHandle isnot NULL)
    {
        CloseHandle (g_hIP6DriverHandle) ;
    }

    if(g_hIP6GetDriverHandle isnot NULL)
    {
        CloseHandle (g_hIP6GetDriverHandle) ;
    }

    if (Change6NotificationHandle isnot NULL)
      {
        CloseHandle (Change6NotificationHandle);
      }

    return NO_ERROR ;
}
#endif


DWORD
GetBestRouteFromStack(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSrcAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    )
{
    DWORD       dwResult;
    DWORD       dwInBufLen, dwOutBufLen;
    TDIObjectID *ID;
    BYTE        *Context;

    IPRouteEntry                        Route;
    PIPRouteLookupData                  pLookup;
    PTCP_REQUEST_QUERY_INFORMATION_EX   ptrqiInBuf;

#define REQ_SIZE    sizeof(TCP_REQUEST_QUERY_INFORMATION_EX) +  \
                    sizeof(IPRouteLookupData) - 1

    BYTE        rgbyBuffer[REQ_SIZE + 4]; // +4 to avoid any alignment problems


    ptrqiInBuf  = (PTCP_REQUEST_QUERY_INFORMATION_EX)rgbyBuffer;

    dwInBufLen  = REQ_SIZE;

#undef REQ_SIZE

    CheckTcpipState();
    if (!g_bIpConfigured)
    {
        return ERROR_NOT_SUPPORTED;
    }

    ID = &(ptrqiInBuf->ID);

    pLookup = (PIPRouteLookupData)(ptrqiInBuf->Context);

    pLookup->Version    = 1;
    pLookup->DestAdd    = dwDestAddr;
    pLookup->SrcAdd     = dwSrcAddr;

    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP_MIB_SINGLE_RT_ENTRY_ID;

    dwOutBufLen = sizeof(IPRouteEntry);

    dwResult = TCPQueryInformationEx(AF_INET,
                                     ptrqiInBuf,
                                     &dwInBufLen,
                                     &Route,
                                     &dwOutBufLen);

    ConvertRouteToForward(&Route, pBestRoute);

    return dwResult;
}

TDIEntityID*
GetTdiEntityCount(
    PULONG  pulNumEntities
    )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    UCHAR                              *Context;
    TDIObjectID                        *ID;
    TDIEntityID                        *pEntTable = NULL;

    TraceEnter("GetTdiEntityCount");

    *pulNumEntities = 0;

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(TDIEntityID) * MAX_TDI_ENTITIES;

    pEntTable = (TDIEntityID*)HeapAlloc(g_hPrivateHeap,0,dwOutBufLen);

    if (!pEntTable) {
      Trace1(ERR,"GetTdiEntityCount: Couldnt allocate memory of size %d",
             dwOutBufLen);
      return NULL;
    }

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = GENERIC_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_GENERIC;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = ENTITY_LIST_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory(Context, CONTEXT_SIZE);

    dwResult = TCPQueryInformationEx(AF_INET,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)pEntTable,
                                     &dwOutBufLen);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"GetTdiEntityCount: Couldnt query information. Error %x",
               dwResult);
        
        HeapFree(g_hPrivateHeap,0,pEntTable);
        return NULL;
    }


    //
    // Now we have all the TDI entities
    //

    *pulNumEntities = dwOutBufLen / sizeof(TDIEntityID);


    return pEntTable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\strdefs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    iphlpapi\strdefs.h

Abstract:

    #defines for string constants

Revision History:

    AmritanR    Created

--*/

#pragma once

#define STRING_RAS_SERVER_INTERFACE     10000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\vxd32.h ===
#ifdef CHICAGO

HANDLE
OsOpenVxdHandle(
    CHAR * VxdName,
    WORD   VxdId
    );
VOID
OsCloseVxdHandle(
    HANDLE VxdHandle
    );
INT
OsSubmitVxdRequest(
    HANDLE  VxdHandle,
    INT     OpCode,
    LPVOID  Param,
    INT     ParamLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\stackex.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    stackex.c

Abstract:

    Ex versions of GetTcpTableFromStack and GetUdpTableFromStack.
    These are used to get the owning process id associated with connections
    from the stack.

Author:

    Shaun Cox (shaunco) 19-Feb-2000

Revision History:

--*/

#include "inc.h"
#pragma hdrstop


int
TCPQueryInformationEx(
    DWORD Family,
    void *InBuf,
    ulong *InBufLen,
    void *OutBuf,
    ulong *OutBufLen
    );

DWORD
GetTcpExTableFromStack(
    OUT TCP_EX_TABLE    *pTcpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder,
    IN  DWORD           dwFamily
    )
{
    DWORD       dwInBufLen, dwOutBufLen, dwResult, dwEntryLen;
    TDIObjectID *ID;
    BYTE        *Context;
    int (_cdecl *pfnCompare)(CONST VOID *pvElem1, CONST VOID *pvElem2);

    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;

    CheckTcpipState();
    if (dwFamily == AF_INET) 
    {
        if (!g_bIpConfigured)
        {
            return ERROR_NOT_SUPPORTED;
        }
        dwEntryLen = sizeof(TCPConnTableEntryEx);
        pfnCompare = CompareTcpRow;
        dwOutBufLen = dwSize - FIELD_OFFSET(TCP_EX_TABLE, table[0]);
    } 
    else if (dwFamily == AF_INET6) 
    {
        if (!g_bIp6Configured)
        {
            return ERROR_NOT_SUPPORTED;
        }
        dwEntryLen = sizeof(TCP6ConnTableEntry);
        pfnCompare = CompareTcp6Row;
        dwOutBufLen = dwSize - FIELD_OFFSET(TCP6_EX_TABLE, table[0]);
    } 
    else 
    {
        return ERROR_INVALID_PARAMETER;
    }

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CO_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = TCP_EX_TABLE_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

    dwResult = TCPQueryInformationEx(dwFamily,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)(pTcpTable->table),
                                     &dwOutBufLen);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetTcpExTableFromStack: Couldnt query stack. Error %x",
               dwResult);

        return dwResult;
    }

    pTcpTable->dwNumEntries = (dwOutBufLen / dwEntryLen);

    if((pTcpTable->dwNumEntries > 0) and bOrder)
    {

        qsort(pTcpTable->table,
              pTcpTable->dwNumEntries,
              dwEntryLen,
              pfnCompare);

    }

    return NO_ERROR;
}

DWORD
AllocateAndGetTcpExTableFromStack(
    OUT TCP_EX_TABLE  **ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    )
{
    DWORD           dwResult, dwCount, dwOutBufLen;
    MIB_TCPSTATS    TcpInfo;
    DWORD           dwEntryLen;

    *ppTcpTable = NULL;

    //
    // Find out the number of entries the stack has. It returns this as part of
    // the Tcp Stats.  Also validate the dwFamily parameter.
    //

    dwResult = GetTcpStatsFromStackEx(&TcpInfo, dwFamily);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetTcpExTableFromStack: Couldnt get Tcp Stats From stack. Error %d",
               dwResult);

        return dwResult;
    }
    dwCount     = TcpInfo.dwNumConns + OVERFLOW_COUNT;

    if (dwFamily == AF_INET) 
    {
        dwEntryLen = sizeof(TCPConnTableEntryEx);
        dwOutBufLen = FIELD_OFFSET(TCP_EX_TABLE, table[0]) 
                        + (dwCount * dwEntryLen) 
                        + ALIGN_SIZE;
    } 
    else 
    {
        dwEntryLen = sizeof(TCP6ConnTableEntry);
        dwOutBufLen = FIELD_OFFSET(TCP6_EX_TABLE, table[0]) 
                        + (dwCount * dwEntryLen) 
                        + ALIGN_SIZE;
    }

    *ppTcpTable = HeapAlloc(hHeap, dwFlags, dwOutBufLen);
    if(*ppTcpTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "AllocateAndGetTcpExTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        return dwResult;
    }

    if(TcpInfo.dwNumConns is 0)
    {
        (*ppTcpTable)->dwNumEntries = 0;

        return NO_ERROR;
    }

    dwResult = GetTcpExTableFromStack(*ppTcpTable, dwOutBufLen, bOrder, 
                                      dwFamily);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetTcpExTableFromStack: Error %d GetTcpExTableFromStack",
               dwResult);
    }

    return dwResult;
}

DWORD
GetUdpExTableFromStack(
    OUT UDP_EX_TABLE    *pUdpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder,
    IN  DWORD           dwFamily
    )
{
    DWORD        dwInBufLen, dwOutBufLen, dwResult;
    BYTE         *Context;
    DWORD        dwEntryLen;
    int (__cdecl *pfnCompare)(CONST VOID *pvElem1, CONST VOID *pvElem2);

    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;

    CheckTcpipState();

    if (dwFamily == AF_INET) 
    {
        if (!g_bIpConfigured) 
        {
            return ERROR_NOT_SUPPORTED;
        }
        dwEntryLen = sizeof(UDPEntryEx);
        pfnCompare = CompareUdpRow;
    } 
    else if (dwFamily == AF_INET6) 
    {
        if (!g_bIp6Configured) 
        {
            return ERROR_NOT_SUPPORTED;
        }
        dwEntryLen = sizeof(UDP6ListenerEntry);
        pfnCompare = CompareUdp6Row;
    } 
    else 
    {
        return ERROR_INVALID_PARAMETER;
    }

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CL_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = UDP_EX_TABLE_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    dwInBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = dwSize - FIELD_OFFSET(UDP6_LISTENER_TABLE, table[0]);

    dwResult = TCPQueryInformationEx(dwFamily,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)(pUdpTable->table),
                                     &dwOutBufLen);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetUdpExTableFromStack: Couldnt query TCP information. Error %d",
               dwResult);

        return dwResult;
    }

    pUdpTable->dwNumEntries = (dwOutBufLen / dwEntryLen);

    //
    // Now sort the UDP connection table.  Keys are: local address, and local
    // port.
    //

    if((pUdpTable->dwNumEntries > 0) and bOrder)
    {
        qsort(pUdpTable->table,
              pUdpTable->dwNumEntries,
              dwEntryLen,
              pfnCompare);
    }

    TraceLeave("GetUdpExTableFromStack");

    return NO_ERROR;
}


DWORD
AllocateAndGetUdpExTableFromStack(
    OUT UDP_EX_TABLE  **ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    )
{
    DWORD               dwResult, dwCount, dwOutBufLen;
    MIB_UDPSTATS        UdpInfo;
    UDP6_LISTENER_TABLE **ppUdp6Table;

    *ppUdpTable = NULL;

    //
    // Find out the number of entries the stack has. It returns this as part of
    // the Tcp Stats.  Also validate the dwFamily parameter.
    //

    dwResult = GetUdpStatsFromStackEx(&UdpInfo, dwFamily);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetUdpExTableFromStack: Couldnt get Udp Stats From stack. Error %d",
               dwResult);

        return dwResult;
    }

    dwCount     = UdpInfo.dwNumAddrs + OVERFLOW_COUNT;
    if (dwFamily == AF_INET) 
    {
        dwOutBufLen = FIELD_OFFSET(UDP_EX_TABLE, table[0]) 
                        + (dwCount * sizeof(UDPEntryEx)) 
                        + ALIGN_SIZE;
    } 
    else 
    {
        dwOutBufLen = FIELD_OFFSET(UDP6_LISTENER_TABLE, table[0]) 
                        + (dwCount * sizeof(UDP6ListenerEntry)) 
                        + ALIGN_SIZE;
    }

    *ppUdpTable = HeapAlloc(hHeap, dwFlags, dwOutBufLen);
    if(*ppUdpTable is NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

        Trace1(ERR,
               "AllocateAndGetUdpExTableFromStack: Couldnt allocate memory. Error %d",
               dwResult);

        return dwResult;
    }

    if(UdpInfo.dwNumAddrs is 0)
    {
        (*ppUdpTable)->dwNumEntries = 0;

        return NO_ERROR;
    }

    dwResult = GetUdpExTableFromStack(*ppUdpTable, dwOutBufLen, bOrder,
                                      dwFamily);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AllocateAndGetUdpExTableFromStack: Error %d GetUdpExTableFromStack",
               dwResult);
    }

    return dwResult;
}

DWORD
GetBestInterfaceFromIpv6Stack(
    IN  LPSOCKADDR_IN6 pSockAddr,
    OUT PDWORD         pdwBestIfIndex
    )
{
    DWORD dwOutBufLen, dwInBufLen, dwResult;
    CHAR byBuffer[FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX, Context) +
                  sizeof(TDI_ADDRESS_IP6)];
    TCP_REQUEST_QUERY_INFORMATION_EX *ptrqiInBuf = (TCP_REQUEST_QUERY_INFORMATION_EX *)byBuffer;
    IP6RouteEntry Ire;
    TDIObjectID *ID;
    BYTE *Context;

    ID = &(ptrqiInBuf->ID);
    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP6_GET_BEST_ROUTE_ID;

    RtlCopyMemory((PVOID)ptrqiInBuf->Context, &pSockAddr->sin6_port,
                  TDI_ADDRESS_LENGTH_IP6);

    dwInBufLen = sizeof(byBuffer);
    dwOutBufLen = sizeof(Ire);

    dwResult = TCPQueryInformationEx(AF_INET6,
                                     ptrqiInBuf,
                                     &dwInBufLen,
                                     (PVOID)&Ire,
                                     &dwOutBufLen);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,"Couldn't query IPv6 stack. Error %d", dwResult);
        TraceLeave("GetBestInterfaceEx");

        return dwResult;
    }

    *pdwBestIfIndex = Ire.ire_IfIndex;

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\dll\str2addt.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    str2addt.h

Abstract:

    Code file for IP string-to-address translation routines.

Author:

    Dave Thaler (dthaler)   3-28-2001

Revision History:

    IPv4 conversion code originally from old winsock code
    IPv6 conversion code originally by Rich Draves (richdr)

--*/

//
// Define some versions of crt functions which are not affected by locale.
//
#define ISDIGIT(c)  (_istascii(c) && _istdigit(c))
#define ISLOWER(c)  (_istascii(c) && _istlower(c))
#define ISXDIGIT(c) (_istascii(c) && _istxdigit(c))

NTSTATUS
RtlIpv6StringToAddressExT (
    IN LPCTSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    )

/*++

Routine Description:

    Parsing a human-readable string to Address, port number and scope id. 

    The syntax is address%scope-id or [address%scope-id]:port, where 
    the scope-id and port are optional.
    Note that since the IPv6 address format uses a varying number
    of ':' characters, the IPv4 convention of address:port cannot
    be supported without the braces.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    Address - Receive address part (in6_addr) of this address.

    ScopeId - Receive scopeid of this address. If there is no scope id in
             the address string, 0 is returned. 

    Port - Receive port number of this address. If there is no port number 
          in the string, 0 is returned. Port is returned in network byte order.

Return Value:

    NT_STATUS - STATUS_SUCCESS if successful, NT error code if not.

--*/

{
    LPTSTR Terminator;
    ULONG TempScopeId;
    USHORT TempPort;
    TCHAR Ch;
    BOOLEAN ExpectBrace;

    //
    // Quick sanity checks.
    //
    if ((AddressString == NULL) ||
        (Address == NULL) ||
        (ScopeId == NULL) ||
        (Port == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    TempPort = 0;
    TempScopeId = 0;
    ExpectBrace = FALSE;
    if (*AddressString == _T('[')) {
        ExpectBrace = TRUE;
        AddressString++;
    }

    if (!NT_SUCCESS(RtlIpv6StringToAddressT(AddressString, 
                                            &Terminator, 
                                            Address))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We have parsed the address, check for a scope-id.
    //
    if (*Terminator == _T('%')) {
        Terminator++;
        Ch = *Terminator;
        if (!ISDIGIT(Ch)) {
            return STATUS_INVALID_PARAMETER;
        }
        while ((Ch != 0) && (Ch != _T(']'))) {
            if (!ISDIGIT(Ch)) {
                return STATUS_INVALID_PARAMETER;
            }
            TempScopeId = 10*TempScopeId + (Ch - _T('0'));
            Terminator++;
            Ch = *Terminator;
        }
        
    }

    //
    // When we come here, the current char should either be the
    // end of the string or ']' if expectbrace is true. 
    //
    if (*Terminator == _T(']')) {
        if (!ExpectBrace) {
            return STATUS_INVALID_PARAMETER;
        }
        ExpectBrace = FALSE;
        Terminator++;
        //
        // See if we have a port to parse.
        //
        if (*Terminator == _T(':')) {
            USHORT Base;
            Terminator++;
            Base = 10;
            if (*Terminator == _T('0')) {
                Base = 8;
                Terminator++;         
                if (*Terminator == _T('x')) {
                    Base = 16;
                    Terminator++;
                }
            }
            Ch = *Terminator;
            while (Ch != 0) {
                if (ISDIGIT(Ch) && (Ch - _T('0')) < Base) {
                    TempPort = (TempPort * Base) + (Ch - _T('0'));
                } else if (Base == 16 && ISXDIGIT(Ch)) {
                    TempPort = (TempPort << 4);
                    TempPort += Ch + 10 - (ISLOWER(Ch)? _T('a') : _T('A')); 
                } else {
                    return STATUS_INVALID_PARAMETER;
                }
                Terminator++;
                Ch = *Terminator;
            }
        }       
    }

    //
    // We finished parsing address, scope id and port number. We are expecting the
    // end of the string. 
    //
    if ((*Terminator != 0) || ExpectBrace) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now construct the address.
    //
    *Port = RtlUshortByteSwap(TempPort);
    *ScopeId = TempScopeId;
    return STATUS_SUCCESS;
} 

NTSTATUS
RtlIpv4StringToAddressExT (
    IN LPCTSTR AddressString,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    )

/*++

Routine Description:

    Parsing a human-readable string to in_addr and port number.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    Address - Receives the address (in_addr) itself.

    Port - Receives port number. 0 is returned if there is no port number.
           Port is returned in network byte order.  

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful, error code if not.

--*/

{
    LPTSTR Terminator;
    USHORT TempPort;
    
    if ((AddressString == NULL) ||
        (Address == NULL) ||
        (Port == NULL)) { 
        return STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(RtlIpv4StringToAddressT(AddressString, 
                                            FALSE, 
                                            &Terminator, 
                                            Address))) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if (*((ULONG*)Address) == INADDR_NONE) {
        return STATUS_INVALID_PARAMETER;
    }
    if (*Terminator == _T(':')) {
        TCHAR Ch;
        USHORT Base;
        Terminator++;
        TempPort = 0;
        Base = 10;
        if (*Terminator == _T('0')) {
            Base = 8;
            Terminator++;
            if (*Terminator == _T('x')) {
                Base = 16;
                Terminator++;
            }
        }
        while (Ch = *Terminator++) {
            if (ISDIGIT(Ch) && (USHORT)(Ch-_T('0')) < Base) {
                TempPort = (TempPort * Base) + (Ch - _T('0'));
            } else if (Base == 16 && ISXDIGIT(Ch)) {
                TempPort = TempPort << 4;
                TempPort += Ch + 10 - (ISLOWER(Ch) ? _T('a') : _T('A'));
            } else {
                return STATUS_INVALID_PARAMETER;
            }
        }
    } else if (*Terminator == 0) {
        TempPort = 0;
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    *Port = RtlUshortByteSwap(TempPort);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\common.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Contains all includes, definitions, types, prototypes for ipconfig

Author:

    Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth        Created
    20-May-97   MohsinA       NT50 PNP.
    31-Jul-97   MohsinA       Patterns.
    10-Mar-98   chunye        Renamed as common.h for ipcfgdll support.

--*/

#ifndef _COMMON_H_
#define _COMMON_H_ 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddtcp.h>

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <ipinfo.h>
#include <dhcpcapi.h>
#include <wscntl.h>
#include <assert.h>
#include <ipexport.h>

#include "debug.h"


//
// manifests
//

#define MAX_ALLOWED_ADAPTER_NAME_LENGTH (MAX_ADAPTER_NAME_LENGTH + 256)

#define STRLEN      strlen
#define STRICMP     _stricmp
#define STRNICMP    _strnicmp


//
// macros
//

#define NEW_MEMORY(size)    LocalAlloc(LMEM_FIXED, size)
#define NEW(thing) (thing *)LocalAlloc(LPTR, sizeof(thing))
#define ReleaseMemory(p)    LocalFree((HLOCAL)(p))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\debug.c ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name: debug.c

Abstract:  Debug functions

Author:     Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth  Created
    30-Apr-97   MoshinA Fixing for NT50.

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(DEBUG)

const char* if_type$(ulong type)
{
    switch (type) {
    case IF_TYPE_OTHER:                 return "other";
    case IF_TYPE_ETHERNET_CSMACD:       return "ethernet";
    case IF_TYPE_ISO88025_TOKENRING:    return "token ring";
    case IF_TYPE_FDDI:                  return "FDDI";
    case IF_TYPE_PPP:                   return "PPP";
    case IF_TYPE_SOFTWARE_LOOPBACK:     return "loopback";
    case IF_TYPE_SLIP:                  return "SLIP";
    }
                                        return "???";
}

const char* entity$(ulong entity)
{
    switch (entity) {
    case CO_TL_ENTITY:       return "CO_TL_ENTITY";
    case CL_TL_ENTITY:       return "CL_TL_ENTITY";
    case ER_ENTITY:          return "ER_ENTITY";
    case CO_NL_ENTITY:       return "CO_NL_ENTITY";
    case CL_NL_ENTITY:       return "CL_NL_ENTITY";
    case AT_ENTITY:          return "AT_ENTITY";
    case IF_ENTITY:          return "IF_ENTITY";

    }
                             return "*** UNKNOWN ENTITY ***";
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\icmptest\icmptest.c ===
#line 1 "manyicmp.c"
//================================================================================
//  Microsoft Confidential
//  Copyright (C) Microsoft Corporation 1997
//
//  Author: RameshV
//================================================================================

//================================================================================
//  Required headers
//================================================================================
#include "inc.h"
#pragma hdrstop

#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>
#include <winsock.h>

#include <stdio.h>
#include <stdlib.h>
#include <align.h>
#include <adt.h>
#include "adt.c"

//================================================================================
//  Required function, IMPORTED
//================================================================================
VOID
HandleIcmpResult(                        // Handle a processed ICMP packet.
    IPAddr          DestAddr,            // Attempted dest address
    BOOL            Status,              // Non-zero=> Dest reachable
    LPVOID          Context              // Whatever was passed to DoIcmpRe..
);


//================================================================================
//  Functions EXPORTED
//================================================================================
DWORD                                    // Win32 errors
DoIcmpRequest(                           // send icmp req. and process asynchro..
    IPAddr        DestAddr,              // Address to send ping to
    LPVOID        Context                // the parameter to above function..
);

DWORD                                    // Win32 errors
PingInit(                                // Initialize all globals..
    VOID
);

VOID
PingCleanup(                             // Free memory and close handles..
    VOID
);


//================================================================================
//  Some defines
//================================================================================
#define PING_TEST              // Yes, we are testing PING.
#define WAIT_TIME              5000
#define RCV_BUF_SIZE           0x2000
#define SEND_MESSAGE           "IcmpDhcpTest"
#define THREAD_KILL_TIME       INFINITE

#define MAX_PENDING_REQUESTS   100
#define NUM_RETRIES            3


#if     DBG
#define DhcpAssert(Condition)    do{                                 \
	if(!(Condition)) AssertFailed(#Condition, __FILE__, __LINE__); } \
	while(0)
#define ErrorPrint               printf
#else
#define DhcpAssert(Condition)
#define ErrorPrint               (void)
#endif


//================================================================================
//  Data structures  NOT EXPORTED
//================================================================================

//  The follwing is the structure that is passed back to the callback function
typedef struct st_apcContext {                 // struct passed to APC routine
    LIST_ENTRY       IcmpRepliesList;          // the chain of replies got is stored here
    LIST_ENTRY       IcmpRequestsList;         // The list that holds the icmp response
    PICMP_ECHO_REPLY Reply;                    // Icmp reply packet
    DWORD            ReplySize;                // The size of above buffer.
    IPAddr           DestinationAddress;       // Who are we try to ping?
    DWORD            Status;                   // Did we succeed? Also retry count.
    LPVOID           Context;                  // Dont know what this is goint to be
} APC_CONTEXT, *PAPC_CONTEXT;

// All globals are here.
LIST_ENTRY               IcmpRepliesList;      // Here is where the IcmpReplies are spooled
LIST_ENTRY               IcmpRequestsList;     // Here is where the
CRITICAL_SECTION         IcmpRepliesCritSect;  // To access the replies list
CRITICAL_SECTION         IcmpRequestsCritSect; // To access the requests list
HANDLE                   IcmpRepliesEvent;     // Signaled each time a reply is received
HANDLE                   IcmpRequestsEvent;    // Singaled whenever a request is received

HANDLE                   TerminateEvent;       // Quit everything being done.
CRITICAL_SECTION         OutputCritSect;       // To co-ordinate access to console output

HANDLE                   RequestsThreadHandle; // The handle of the thread that takes requests
HANDLE                   RepliesThreadHandle;  // The handle of the thread that takes replies

HANDLE                   IcmpHandle;           // Handle to do IcmpSendEcho2 etc.

PRODCONS                 IcmpProdConsSynchObj; // Producer/Consumer synchro.. object

BOOL                     Terminating = FALSE;  // Are we terminating?

#define LOCK_REPLIES_LIST()    EnterCriticalSection(&IcmpRepliesCritSect)
#define LOCK_REQUESTS_LIST()   EnterCriticalSection(&IcmpRequestsCritSect)
#define LOCK_OUTPUT()          EnterCriticalSection(&OutputCritSect)

#define UNLOCK_REPLIES_LIST()  LeaveCriticalSection(&IcmpRepliesCritSect)
#define UNLOCK_REQUESTS_LIST() LeaveCriticalSection(&IcmpRequestsCritSect)
#define UNLOCK_OUTPUT()        LeaveCriticalSection(&OutputCritSect)

//================================================================================
//  Assertion failure routine + allocation free routines
//================================================================================
VOID static _inline
AssertFailed(
    LPSTR    Condition,
    LPSTR    File,
    DWORD    Line
) {
    BYTE     Buf[1000];
    DWORD    RetVal;

    sprintf(Buf, "[%s:%d] %s", File, Line, Condition);
    RetVal = MessageBox(
        NULL,                                   // hWnd: NULL => default desktop
        Buf,                                    // Text to print
        "Assertion Failure",                    // Window caption
        MB_OK | MB_ICONSTOP                     // Message type
    );
}

LPVOID _inline
DhcpAllocateMemory(
    DWORD    Size
) {
    return LocalAlloc(LMEM_FIXED, Size);
}

VOID _inline
DhcpFreeMemory(
    LPVOID   Ptr
) {
    LocalFree(Ptr);
}

//================================================================================
//  Routines
//================================================================================

//--------------------------------------------------------------------------------
//  The following functions are on the replies side.  They handle the icmp reply
//  packet and take the necessary action depending on the status, etc.
//--------------------------------------------------------------------------------

VOID static
ApcRoutine(                                    // This is called when ping completes
    IN PVOID            Context,               // The above structure
    IN PIO_STATUS_BLOCK Ignored1,              // Unused param
    IN ULONG            Ignored2               // Unused param
) {
    BOOL   Status;
    PAPC_CONTEXT ApcContext = (PAPC_CONTEXT)Context;

    if( TRUE == Terminating ) {
        // Just free memory and quit?
        ASSERT( FALSE );
        DhcpFreeMemory(ApcContext);
        return;
    }

    // All we have to do is add it to the Replies List and signal the event
    LOCK_REPLIES_LIST();
    InsertTailList(&IcmpRepliesList, &ApcContext->IcmpRepliesList);
    UNLOCK_REPLIES_LIST();

    Status = SetEvent(IcmpRepliesEvent);
    ASSERT( FALSE != Status );
}

// The following function decides if the Destination is reachable or not.
BOOL static
DestReachable(                                  // Is destination reachable?
    IN PAPC_CONTEXT      ApcContext             // this has the info of sender etc..
) {
    DWORD nReplies, i;

    // First parse the packet.
    nReplies = IcmpParseReplies(ApcContext->Reply, ApcContext->ReplySize);

    // if no replies, then straight assume that destination is unreachable.
    if( 0 == nReplies ) {
        // If there was no reply, there is no way for us to reach this
        // So, we assume that the Dest is NOT reachable.
        // Reasons could be IP_REQ_TIMED_OUT or IP_BAD_DESTINATION etc..
        return FALSE;
    }

    // Now we check each reply to see if there is anything from the same dest
    // address we are looking for. And if the status is success. If the status
    // is not success, we actually do not check anything there. Potentially, it
    // could be IP_DEST_PORT_UNREACHABLE, in which case, the dest machine is up,
    // but for some reason we tried the wrong port..

    for( i = 0; i < nReplies; i ++ ) {
        if( ApcContext->DestinationAddress == ApcContext->Reply[i].Address ) {
            // hit the destination!

            ASSERT( IP_SUCCESS == ApcContext->Reply[i].Status );
            return TRUE;
        }

        ASSERT( IP_SUCCESS != ApcContext->Reply[i].Status);
    }

    // None of the replies were successful.
    return FALSE;
}

VOID static
HandleRepliesEvent(                       // Process all replies received
    VOID
) {
    PAPC_CONTEXT   ApcContext;
    PLIST_ENTRY    listEntry;
    BOOL           Status;

    LOCK_REPLIES_LIST();
    while( !IsListEmpty( &IcmpRepliesList ) ) {
        // retrive the first element in the list

        ApcContext = CONTAINING_RECORD(IcmpRepliesList.Flink, APC_CONTEXT, IcmpRepliesList);
        RemoveEntryList(&ApcContext->IcmpRepliesList);

        UNLOCK_REPLIES_LIST();

        Status = DestReachable(ApcContext);

        if( Status || NUM_RETRIES <= ApcContext->Status ) {
            StartConsumer(&IcmpProdConsSynchObj);
            HandleIcmpResult(
                ApcContext->DestinationAddress,
                Status,
                ApcContext->Context
            );

            DhcpFreeMemory(ApcContext);
            EndConsumer(&IcmpProdConsSynchObj);
        } else {
            // retry

            LOCK_REQUESTS_LIST();
            InsertTailList(&IcmpRequestsList, &ApcContext->IcmpRequestsList);
            UNLOCK_REQUESTS_LIST();

            Status = SetEvent(IcmpRequestsEvent);
            ASSERT( TRUE == Status );
        }

        LOCK_REPLIES_LIST();
    }
    UNLOCK_REPLIES_LIST();
}


//  This routine sleeps on a loop, and is woken up by the call back function when an ICMP
//  reply comes through.  On waking up, this routine processes ALL ICMP replies.
DWORD  static                                  // THREAD ENTRY
LoopOnIcmpReplies(                             // Loop on all the ICMP replies.
    LPVOID      Unused
) {
    DWORD  Status;
    HANDLE WaitHandles[2];

    WaitHandles[0] = TerminateEvent;
    WaitHandles[1] = IcmpRepliesEvent;

    while( TRUE ) {
        Status = WaitForMultipleObjects(
            sizeof(WaitHandles)/sizeof(WaitHandles[0]),
            WaitHandles,
            FALSE,
            INFINITE
        );


        if( WAIT_OBJECT_0 == Status ) break; // Termination
        if( 1+WAIT_OBJECT_0 == Status ) {
            HandleRepliesEvent();
            continue;
        }

        ASSERT( FALSE );
    }

    return ERROR_SUCCESS;
}

#define AlignSizeof(X)     ROUND_UP_COUNT(sizeof(X),ALIGN_WORST)

DWORD // exported
DoIcmpRequest(
    IPAddr        DestAddr,
    LPVOID        Context
) {
    PAPC_CONTEXT  pCtxt;
    LPBYTE        startAddress;
    DWORD         Status;
    BOOL          BoolStatus;

    // Create the context
    pCtxt = DhcpAllocateMemory(AlignSizeof(APC_CONTEXT) + RCV_BUF_SIZE);
    startAddress = (LPBYTE)pCtxt;
    if( NULL == pCtxt ) return GetLastError();

    // Now fill the context with all that we know.
    pCtxt->Reply = (PICMP_ECHO_REPLY)(startAddress + AlignSizeof(APC_CONTEXT));
    pCtxt->ReplySize = RCV_BUF_SIZE;
    pCtxt->DestinationAddress = DestAddr;
    pCtxt->Status = 0;
    pCtxt->Context = Context;


    // enqueue this guy.
    StartProducer(&IcmpProdConsSynchObj);

    LOCK_REQUESTS_LIST();
    InsertTailList(&IcmpRequestsList, &pCtxt->IcmpRequestsList);
    UNLOCK_REQUESTS_LIST();

    EndProducer(&IcmpProdConsSynchObj);

    // Signal the Requests loop.
    BoolStatus = SetEvent(IcmpRequestsEvent);
    ASSERT( TRUE == BoolStatus );

    return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------
//  The following functions handle the the end that sends ICMP echoes.
//--------------------------------------------------------------------------------
VOID  static
HandleRequestsEvent(                 // Process every request for ICMP echo.
    VOID
) {
    PAPC_CONTEXT   ApcContext;
    PLIST_ENTRY    listEntry;
    DWORD          Status;


    LOCK_REQUESTS_LIST();

    while( !IsListEmpty( &IcmpRequestsList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRequestsList.Flink, APC_CONTEXT, IcmpRequestsList);
        RemoveEntryList(&ApcContext->IcmpRequestsList);

        UNLOCK_REQUESTS_LIST();

        // Send an Icmp echo and return immediately..
        ApcContext->Status ++;
        Status = IcmpSendEcho2(
            IcmpHandle,              // The handle to register APC and send echo
            NULL,                    // No event
            ApcRoutine,              // The call back routine
            (LPVOID)ApcContext,      // The first parameter to the callback routine
            ApcContext->DestinationAddress, // The address being PING'ed
            SEND_MESSAGE,
            (WORD)strlen(SEND_MESSAGE),
            NULL,
            (LPVOID)ApcContext->Reply,
            ApcContext->ReplySize,
            WAIT_TIME
        );

        if( FALSE == Status )  Status = GetLastError();
        else Status = ERROR_SUCCESS;

        // Since we queued an APC, we expect an STATUS_PENDING.
        if( ERROR_SUCCESS != Status && ERROR_IO_PENDING != Status ) {
            ASSERT(FALSE);
            LOCK_OUTPUT();
            ErrorPrint("IcmpSendEcho2:GetLastError: %d\n", Status);
            UNLOCK_OUTPUT();
        }
        LOCK_REQUESTS_LIST();
    }
    UNLOCK_REQUESTS_LIST();
}


// This function handles the Requests.. For each one, it just sends an IcmpEcho
// asynchronously and returns back immediately.  When the APC routine is called,
// it would queue it up on the Replies list and then it would get processed...
DWORD  static                             // THREAD ENTRY
LoopOnIcmpRequests(                       // Process pending requests for echo
    LPVOID           Unused
) {
    DWORD  Status;
    HANDLE WaitHandles[2];

    WaitHandles[0] = TerminateEvent;
    WaitHandles[1] = IcmpRequestsEvent;

    while( TRUE ) {
        Status = WaitForMultipleObjectsEx(
            sizeof(WaitHandles)/sizeof(WaitHandles[0]), // # of handles
            WaitHandles,                                // array of handles
            FALSE,                                      // any one of them set
            INFINITE,                                   // wait forever
            TRUE                                        // allow APC's
        );

        if( WAIT_OBJECT_0 == Status ) break; // Termination
        if( WAIT_IO_COMPLETION == Status) continue;
        if( 1+WAIT_OBJECT_0 == Status ) {
            HandleRequestsEvent();
            continue;
        }

        ASSERT(FALSE);
    }
    return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------
//  Initialization, Cleanup routines.
//--------------------------------------------------------------------------------
DWORD // exported
PingInit(
    VOID
) {
    DWORD ThreadId, Status;

    // Initialize all data vars.
    IcmpRepliesEvent = IcmpRequestsEvent = TerminateEvent = NULL;
    RepliesThreadHandle = RequestsThreadHandle = NULL;
    IcmpHandle = NULL;

    // Open IcmpHandle..
    IcmpHandle = IcmpCreateFile();
    if( NULL == IcmpHandle ) return GetLastError();

    // Initialize Lists.
    InitializeListHead(&IcmpRepliesList);
    InitializeListHead(&IcmpRequestsList);

    // Initialize Critical Sections.
    InitializeCriticalSection(&IcmpRepliesCritSect);
    InitializeCriticalSection(&IcmpRequestsCritSect);
    InitializeCriticalSection(&OutputCritSect);

    // Create Events,
    IcmpRepliesEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( NULL == IcmpRepliesEvent ) return GetLastError();
    IcmpRequestsEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( NULL == IcmpRequestsEvent ) return GetLastError();
    TerminateEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == TerminateEvent ) return GetLastError();

    // Create producer-consumer synchronization object
    Status = InitializeProducerConsumer(
        &IcmpProdConsSynchObj,
        MAX_PENDING_REQUESTS,
        MAX_PENDING_REQUESTS
    );
    if( ERROR_SUCCESS != Status ) return Status;

    // Create Threads
    RepliesThreadHandle = CreateThread(
        (LPSECURITY_ATTRIBUTES)
        NULL,                // No security information
        0,                   // Stack size = same as default primary thread
        LoopOnIcmpReplies,   // The function to call
        NULL,                // No paramter needs to be passed to this function
        0,                   // Flags: just start this thread right away
        &ThreadId            // The return ThreadId value.
    );
    if( NULL == RepliesThreadHandle ) return GetLastError();

    RequestsThreadHandle = CreateThread(
        NULL,                // No security information
        0,                   // Stack size = same as default primary thread
        LoopOnIcmpRequests,  // The function to call
        NULL,                // No paramter needs to be passed to this function
        0,                   // Flags: just start this thread right away
        &ThreadId            // The return ThreadId value.
    );
    if( NULL == RequestsThreadHandle ) return GetLastError();

    return ERROR_SUCCESS;
}

VOID // exported
PingCleanup(
    VOID
) {
    DWORD               Status;
    BOOL                BoolStatus;
    PAPC_CONTEXT        ApcContext;
    PLIST_ENTRY         listEntry;

    // Kill the replies and reqeusts threads after waiting for a while.
    // Kill the Replies and Requests ThreadHandle 's.
    if( NULL != RepliesThreadHandle || NULL != RequestsThreadHandle ) {
        // ASSERT ( NULL != TerminateEvent )
        Terminating = TRUE;
        SetEvent(TerminateEvent);

        if( NULL != RepliesThreadHandle ) {
            Status = WaitForSingleObject(
                RepliesThreadHandle,
                THREAD_KILL_TIME
            );
            if( WAIT_OBJECT_0 != Status ) {
                //  did not succeed in stopping the thread..
                BoolStatus = TerminateThread(
                    RepliesThreadHandle,
                    0xFF
                );
                ASSERT(BoolStatus);
            }
            CloseHandle(RepliesThreadHandle);
        }

        if( NULL != RequestsThreadHandle ) {
            Status = WaitForSingleObject(
                RequestsThreadHandle,
                THREAD_KILL_TIME
            );
            if( WAIT_OBJECT_0 != Status ) {
                //  did not succeed in stopping the thread..
                BoolStatus = TerminateThread(
                    RequestsThreadHandle,
                    0xFF
                );
                ASSERT(BoolStatus);
            }
            CloseHandle(RequestsThreadHandle);
        }
    }

    // Close Event handles.
    CloseHandle(IcmpRepliesEvent);
    CloseHandle(IcmpRequestsEvent);
    CloseHandle(TerminateEvent);

    // Destroy producer consumer synchronization object
    DestroyProducerConsumer(&IcmpProdConsSynchObj);

    // Freeup all elements of lists..
    while( !IsListEmpty( &IcmpRepliesList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRepliesList.Flink, APC_CONTEXT, IcmpRepliesList);
        RemoveEntryList(&ApcContext->IcmpRepliesList);

        DhcpFreeMemory(ApcContext);
    }
    while( !IsListEmpty( &IcmpRequestsList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRequestsList.Flink, APC_CONTEXT, IcmpRequestsList);
        RemoveEntryList(&ApcContext->IcmpRequestsList);

        DhcpFreeMemory(ApcContext);
    }

    // Close Icmp handle
    CloseHandle(IcmpHandle);

    // Destroy critical sections
    DeleteCriticalSection(&IcmpRepliesCritSect);
    DeleteCriticalSection(&IcmpRequestsCritSect);
    DeleteCriticalSection(&OutputCritSect);
}

#ifdef PING_TEST
//--------------------------------------------------------------------------------
//  Test module.  This exercises the above functions.
//--------------------------------------------------------------------------------
DWORD SA, EA;
DWORD
TestPing(
    LPSTR      StartAddrString,
    LPSTR      EndAddrString
) {
    IPAddr i, StartAddr, EndAddr;
    DWORD  Status;
    BOOL   BoolStatus;
    HANDLE ThreadHandle;

    StartAddr = SA = inet_addr(StartAddrString);
    EndAddr = EA = inet_addr(EndAddrString);

    Status = PingInit();
    if( ERROR_SUCCESS != Status ) return Status;

    for( i = htonl(StartAddr); i <= htonl(EndAddr); i ++ ) {

        Status = DoIcmpRequest(ntohl(i), NULL);
        ASSERT( ERROR_SUCCESS == Status );
    }

    LOCK_OUTPUT();
    printf("Done\n");
    UNLOCK_OUTPUT();

    // Sleep for a while and then signal termination...
    Sleep(30000);
    // Give the threads time to die?
    PingCleanup();
    return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------
//  Main function.  Just does the test routine.
//--------------------------------------------------------------------------------
VOID _cdecl
main(
    int argc,
    char *argv[]
) {
    DWORD Status;
    if( argc != 3 ) {
        fprintf(stderr, "\nUsage: %s start-ip-addr end-ip-addr\n", argv[0]);
        exit(1);
    }

    Status = TestPing(argv[1], argv[2]);
    if( ERROR_SUCCESS != Status ) {
        fprintf(stderr, "Error: %d\n", Status);
    }
}
#endif PING_TEST

//--------------------------------------------------------------------------------
//  End of file.
//--------------------------------------------------------------------------------

// This will really be defined elsewhere.. until then.
VOID
HandleIcmpResult(                        // Handle a processed ICMP packet.
    IPAddr          DestAddr,            // Attempted dest address
    BOOL            Status,              // Non-zero=> Dest reachable
    LPVOID          Context              // Whatever was passed to DoIcmpRe..
) {

    LOCK_OUTPUT();
    printf("Ping[%s] does %s exist\n",
           inet_ntoa(*(struct in_addr *)&DestAddr),
           Status? "" : "not" );
    UNLOCK_OUTPUT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\debug.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name: debug.h

Abstract: Debug defines, macros, prototypes

Author: Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth  -- Created
    30-Apr-97   MohsinA -- Updating for NT50.
                           macros from "../common2/mdebug.h"

--*/

#if !defined(DEBUG)
#if DBG
#define DEBUG
#endif
#endif



#ifdef DBG

extern int   Debugging;
extern const char* if_type$(ulong);
extern const char* entity$(ulong);

extern  int   MyTrace;

#define DEBUG_PRINT(S) if( Debugging ){ printf S ; }else;
#define TRACE_PRINT(S) if( MyTrace   ){ printf S; }else{}

#else

#define DEBUG_PRINT(S) /* nothing */
#define TRACE_PRINT(S) /* nothing */

#define if_type$(x)    /* nothing */
#define entity$(x)     /* nothing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\adaptlst.c ===
/*++

Copyright (c) 1994-1997 Microsoft Corporation

Module Name: //KERNEL/RAZZLE3/src/sockets/tcpcmd/ipconfig/adaptlst.c

Abstract:

    This module contains functions for retrieving adapter information from
    TCP/IP device driver

    Contents:
        GetAdapterList
        GetAdapterList2
        AddIpAddress
        AddIpAddressString
        ConvertIpAddressToString
        CopyString
        (CleanDescription)

Author:

    Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth  Created
    30-Apr-97   MohsinA Cleaned Up.

--*/

#include "precomp.h"
#pragma hdrstop

#define OVERFLOW_COUNT  10

//
// prototypes
//

void CleanDescription(LPSTR);
extern PIP_ADAPTER_ORDER_MAP APIENTRY GetAdapterOrderMap();





//
// functions
//

/*******************************************************************************
 *
 *  GetAdapterList
 *
 *  Returns a linked list of IP_ADAPTER_INFO structures. The adapter info is
 *  queried from the TCP/IP stack. Only those instances corresponding to
 *  physical adapters are returned
 *
 *  This function only fills in the information in the IP_ADAPTER_INFO
 *  structure pertaining to the physical adapter (like MAC address, adapter
 *  type, etc.) and IP address info
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS Success - pointer to linked list of IP_ADAPTER_INFO structures,
 *                    0 terminated
 *          Failure - NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

PIP_ADAPTER_INFO GetAdapterList()
{

    TCP_REQUEST_QUERY_INFORMATION_EX req;
    TDIObjectID id;
    PIP_ADAPTER_INFO list = NULL, prev = NULL;
    PIP_ADAPTER_INFO this, UniList = NULL, tmp;
    UINT numberOfEntities;
    TDIEntityID* pEntity = NULL;
    TDIEntityID* entityList;
    UINT i;
    UINT j;
    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    PIP_ADAPTER_ORDER_MAP adapterOrderMap;
    PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pUniInfo=NULL;
    ULONG OutBufLen;

    //
    // get the list of entities supported by TCP/IP then make 2 passes on the
    // list. Pass 1 scans for IF_ENTITY's (interface entities perhaps?) which
    // describe adapter instances (physical and virtual). Once we have our list
    // of adapters, on pass 2 we look for CL_NL_ENTITY's (connection-less
    // network layer entities peut-etre?) which will give us the list of IP
    // addresses for the adapters we found in pass 1
    //

    entityList = GetEntityList(&numberOfEntities);
    if (!entityList) {

        DEBUG_PRINT(("GetAdapterList: failed to get entity list\n"));

        return NULL;
    }

    adapterOrderMap = GetAdapterOrderMap();
    if (!adapterOrderMap) {
        DEBUG_PRINT(("GetAdapterList: failed to get adapter order map\n"));
        ReleaseMemory(entityList);
        return NULL;
    }

    // ====================================================================
    // pass 1
    // ====================================================================

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(("Pass 1: Entity %lx [%s] Instance %ld\n",
                    pEntity->tei_entity,
                    entity$(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity == IF_ENTITY) {

            //
            // IF_ENTITY: this entity/instance describes an adapter
            //

            DWORD isMib;
            BYTE info[sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
            IFEntry* pIfEntry = (IFEntry*)info;
            int len;

            //
            // find out if this entity supports MIB requests
            //

            memset(&req, 0, sizeof(req));

            id.toi_entity = *pEntity;
            id.toi_class = INFO_CLASS_GENERIC;
            id.toi_type = INFO_TYPE_PROVIDER;
            id.toi_id = ENTITY_TYPE_ID;

            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(isMib);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&isMib,
                               &outputLen
                               );

            if (status != TDI_SUCCESS) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(ENTITY_TYPE_ID): status = %ld, outputLen = %ld\n",
                            status,
                            outputLen
                            ));

                // goto error_exit;
                continue;
            }
            if (isMib != IF_MIB) {

                //
                // entity doesn't support MIB requests - try another
                //

                DEBUG_PRINT(("GetAdapterList: Entity %lx, Instance %ld doesn't support MIB (%lx)\n",
                            id.toi_entity.tei_entity,
                            id.toi_entity.tei_instance,
                            isMib
                            ));

                continue;
            }

            //
            // MIB requests supported - query the adapter info
            //

            id.toi_class = INFO_CLASS_PROTOCOL;
            id.toi_id = IF_MIB_STATS_ID;

            memset(&req, 0, sizeof(req));
            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(info);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&info,
                               &outputLen
                               );
            if (status != TDI_SUCCESS && status != ERROR_MORE_DATA) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(IF_MIB_STATS_ID) returns %ld\n",
                            status
                            ));

                // goto error_exit;
                continue;
            }

#ifdef DBG
            if( MyTrace ){
                print_IFEntry( "GetAdapterList", pIfEntry );
            }
#endif

            //
            // we only want physical adapters
            //

            if (!IS_INTERESTING_ADAPTER(pIfEntry)) {

                DEBUG_PRINT(("GetAdapterList: ignoring adapter #%ld [%s]\n",
                            pIfEntry->if_index,
                            if_type$(pIfEntry->if_type)
                            ));

                continue;
            }

            //
            // got this adapter info ok. Create a new IP_ADAPTER_INFO and
            // fill in what we can
            //

            this = NEW(IP_ADAPTER_INFO);
            if (!this) {
                DEBUG_PRINT(("GetAdapterList: no mem for this IP_ADAPTER_INFO\n"));
                goto error_exit;
            }

            memset( this, 0, sizeof( IP_ADAPTER_INFO ) );

            len = (int) min(MAX_ADAPTER_DESCRIPTION_LENGTH,
                      (size_t)pIfEntry->if_descrlen);

            strncpy(this->Description, pIfEntry->if_descr, len);
            this->Description[len] = 0;

            //
            // if the last word of the description is " Adapter", remove it (its
            // redundant) and if the description is terminated with a period,
            // remove that too
            //

            //  CleanDescription(this->Description);

            len = (int) min(MAX_ADAPTER_ADDRESS_LENGTH,
                      (size_t)pIfEntry->if_physaddrlen);

            this->AddressLength = (BYTE)len;

            memcpy(this->Address, pIfEntry->if_physaddr, len);

            this->Index = (UINT)pIfEntry->if_index;
            this->Type = (UINT)pIfEntry->if_type;

            //
            // add this IP_ADAPTER_INFO to our list.
            // We build the list sorted according to the adapter order
            // specified for TCP/IP under its Linkage key.
            // In order to put this new entry in the right place in the list,
            // we determine its position in the adapter-order, store that
            // position in the (unused) 'ComboIndex' field, and then use that
            // index for comparison on subsequent insertions.
            // If this IP_ADAPTER_INFO doesn't appear in our list at all,
            // we put it at the end of the current list.
            //

            for (j = 0; j < adapterOrderMap->NumAdapters; j++) {
                if (adapterOrderMap->AdapterOrder[j] == this->Index) {
                    break;
                }
            }

            //
            // 'j' now contains the 'order' for the new entry.
            // Put the entry in the right place in the list.
            //

            this->ComboIndex = j;
            for (prev = NULL, this->Next = list;
                 this->Next;
                 prev = this->Next, this->Next = this->Next->Next) {
                if (this->ComboIndex >= this->Next->ComboIndex) {
                    continue;
                } else {
                    break;
                }
            }
            if (prev) { prev->Next = this; }
            if (list == this->Next) { list = this; }
        }
    }

    OutBufLen = sizeof(IP_UNIDIRECTIONAL_ADAPTER_ADDRESS) + MAX_UNI_ADAPTERS*sizeof(IPAddr);
    pUniInfo = MALLOC(OutBufLen);
    if(!pUniInfo) {
        printf("GetAdapterList: IP_UNIDIRECTIONAL_ADAPTER_ADDRESS resource failure= %ld\n",status);
        DEBUG_PRINT(("GetAdapterList: IP_UNIDIRECTIONAL_ADAPTER_ADDRESS resource failure= %ld\n",status));
        goto error_exit;
    }
    pUniInfo->NumAdapters = 0;
    status = GetUniDirectionalAdapterInfo(pUniInfo, &OutBufLen);

    if (status == ERROR_MORE_DATA) {
        OutBufLen = sizeof(IP_UNIDIRECTIONAL_ADAPTER_ADDRESS)+pUniInfo->NumAdapters*sizeof(IPAddr);
        pUniInfo = MALLOC(OutBufLen);
        if(!pUniInfo) {
            DEBUG_PRINT(("GetAdapterList: IP_UNIDIRECTIONAL_ADAPTER_ADDRESS resource failure= %ld\n",status));
            goto error_exit;
        }
        status = GetUniDirectionalAdapterInfo(pUniInfo, &OutBufLen);
    }
    if(status != NO_ERROR) {
        DEBUG_PRINT(("GetAdapterList: GetUniDirectionalAdapterInfo returned status= %ld\n",status));
        goto error_exit;

    }

    // ====================================================================
    // pass 2
    // ====================================================================

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(("Pass 2: Entity %lx [%s] Instance %ld\n",
                    pEntity->tei_entity,
                    entity$(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity == CL_NL_ENTITY) {

            IPSNMPInfo info;
            DWORD type;

            //
            // first off, see if this network layer entity supports IP
            //

            memset(&req, 0, sizeof(req));

            id.toi_entity = *pEntity;
            id.toi_class = INFO_CLASS_GENERIC;
            id.toi_type = INFO_TYPE_PROVIDER;
            id.toi_id = ENTITY_TYPE_ID;

            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(type);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&type,
                               &outputLen
                               );

            if (status != TDI_SUCCESS) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(ENTITY_TYPE_ID): status = %ld, outputLen = %ld\n",
                            status,
                            outputLen
                            ));

                // goto error_exit;
                continue;
            }
            if (type != CL_NL_IP) {

                //
                // nope, not IP - try next one
                //

                DEBUG_PRINT(("GetAdapterList: CL_NL_ENTITY #%ld not CL_NL_IP\n",
                            pEntity->tei_instance
                            ));

                continue;
            }

            //
            // okay, this NL provider supports IP. Let's get them addresses:
            // First we find out how many by getting the SNMP stats and looking
            // at the number of addresses supported by this interface
            //

            memset(&req, 0, sizeof(req));

            id.toi_class = INFO_CLASS_PROTOCOL;
            id.toi_id = IP_MIB_STATS_ID;

            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(info);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&info,
                               &outputLen
                               );
            if ((status != TDI_SUCCESS) || (outputLen != sizeof(info))) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(IP_MIB_STATS_ID): status = %ld, outputLen = %ld\n",
                            status,
                            outputLen
                            ));

                // goto error_exit;
                continue;
            }

            //
            // get the IP addresses & subnet masks
            //

            if (info.ipsi_numaddr) {

                //
                // this interface has some addresses. What are they?
                //

                LPVOID buffer;
                UINT numberOfAddresses;
                IPAddrEntry* pAddr;
                UINT i;

                outputLen = (info.ipsi_numaddr + OVERFLOW_COUNT) *
                            sizeof(IPAddrEntry);
                buffer = (LPVOID)NEW_MEMORY((size_t)outputLen);
                if (!buffer) {
                    DEBUG_PRINT(("GetAdapterList:NEW_MEMORY failed.\n" ));
                    goto error_exit;
                }

                memset(&req, 0, sizeof(req));

                id.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

                req.ID = id;

                inputLen = sizeof(req);

                status = WsControl(IPPROTO_TCP,
                                   WSCNTL_TCPIP_QUERY_INFO,
                                   (LPVOID)&req,
                                   &inputLen,
                                   (LPVOID)buffer,
                                   &outputLen
                                   );

                if (status != TDI_SUCCESS) {

                    //
                    // unexpected results - bail out
                    //

                    DEBUG_PRINT(("GetAdapterList: WsControl(IP_MIB_ADDRTABLE_ENTRY_ID): status = %ld, outputLen = %ld\n",
                                status,
                                outputLen
                                ));

                    // goto error_exit;
                    ReleaseMemory((void*)buffer);
                    continue;
                }

                //
                // now loop through this list of IP addresses, applying them
                // to the correct adapter
                //

                numberOfAddresses = min((UINT)(outputLen / sizeof(IPAddrEntry)),
                                        (UINT)info.ipsi_numaddr
                                        );

                DEBUG_PRINT(("GetAdapterList: %d IP addresses\n", numberOfAddresses));

                pAddr = (IPAddrEntry*)buffer;
                for (i = 0; i < numberOfAddresses; ++i, ++pAddr) {

                    PIP_ADAPTER_INFO pAdapterInfo;

                    DEBUG_PRINT(("GetAdapterList: IP address %d.%d.%d.%d, index %ld, context %ld\n",
                                ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
                                ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
                                ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
                                ((LPBYTE)&pAddr->iae_addr)[3] & 0xff,
                                pAddr->iae_index,
                                pAddr->iae_context
                                ));

                    for (pAdapterInfo = list; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next) {
                        if (pAdapterInfo->Index == (UINT)pAddr->iae_index) {

                            DEBUG_PRINT(("GetAdapterList: adding IP address %d.%d.%d.%d, index %d, context %d\n",
                                        ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
                                        ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
                                        ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
                                        ((LPBYTE)&pAddr->iae_addr)[3] & 0xff,
                                        pAddr->iae_index,
                                        pAddr->iae_context
                                        ));

                            //
                            // Append the IP address to the list.
                            // Note that this operation preserves the order
                            // of the IP address list returned by TCP/IP.
                            // This is important because that list contains
                            // entries listed in the *reverse* of the order
                            // specified for each adapter. A number of clients
                            // depend upon this fact when calling this and
                            // other API routines.
                            //

                            if (!AddIpAddress(&pAdapterInfo->IpAddressList,
                                              pAddr->iae_addr,
                                              pAddr->iae_mask,
                                              pAddr->iae_context
                                              )) {
                                ReleaseMemory((void*)buffer);
                                goto error_exit;
                            }

                            for (j = 0; j < pUniInfo->NumAdapters ; j++) {

                                if (pAddr->iae_index == pUniInfo->Address[j] ) {

                                    //
                                    // Use DhcpEnabled field as a temporary
                                    // storage to remember the type
                                    //
                                    pAdapterInfo->DhcpEnabled = IF_TYPE_RECEIVE_ONLY;
                                    break;
                                }

                            }
                            break;
                        }
                    }
                }
                ReleaseMemory((void*)buffer);
            }

            //
            // get the gateway server IP address(es)
            //

            if (info.ipsi_numroutes) {

                IPRouteEntry* routeTable;
                IPRouteEntry* pRoute;
                UINT numberOfRoutes;
                UINT i;
                int moreRoutes = TRUE;

                memset(&req, 0, sizeof(req));

                id.toi_id = IP_MIB_RTTABLE_ENTRY_ID;

                req.ID = id;

                inputLen = sizeof(req);
                outputLen = sizeof(IPRouteEntry) * info.ipsi_numroutes;
                routeTable = NULL;

                //
                // the route table may have grown since we got the SNMP stats
                //

                while (moreRoutes) {

                    DWORD previousOutputLen;

                    previousOutputLen = outputLen;
                    if (routeTable) {
                        ReleaseMemory((void*)routeTable);
                        routeTable = NULL;
                    }
                    routeTable = (IPRouteEntry*)NEW_MEMORY((size_t)outputLen);
                    if (!routeTable) {
                        goto error_exit;
                    }

                    status = WsControl(IPPROTO_TCP,
                                       WSCNTL_TCPIP_QUERY_INFO,
                                       (LPVOID)&req,
                                       &inputLen,
                                       (LPVOID)routeTable,
                                       &outputLen
                                       );
                    if (status != TDI_SUCCESS) {

                        //
                        // unexpected results - bail out
                        //

                        DEBUG_PRINT(("GetAdapterList: WsControl(IP_MIB_RTTABLE_ENTRY_ID): status = %ld, outputLen = %ld\n",
                                    status,
                                    outputLen
                                    ));

                        if (status == ERROR_MORE_DATA) {
                            TCP_REQUEST_QUERY_INFORMATION_EX    statsReq;
                            IPSNMPInfo                          statsInfo;
                            DWORD                               inLen;
                            DWORD                               outLen;

                            memset(&statsReq, 0, sizeof(statsReq));

                            id.toi_id = IP_MIB_STATS_ID;

                            statsReq.ID = id;

                            inLen = sizeof(statsReq);
                            outLen = sizeof(statsInfo);

                            status = WsControl( IPPROTO_TCP,
                                                WSCNTL_TCPIP_QUERY_INFO,
                                                (LPVOID)&statsReq,
                                                &inLen,
                                                (LPVOID)&statsInfo,
                                                &outLen);

                            if (status != TDI_SUCCESS || outLen != sizeof(statsInfo)) {
                                ReleaseMemory((void*)routeTable);
                                goto error_exit;
                            } else {
                                outputLen = sizeof(IPRouteEntry) * statsInfo.ipsi_numroutes;
                            }
                        } else {
                            ReleaseMemory((void*)routeTable);
                            goto error_exit;
                        }
                    }
                    if (outputLen <= previousOutputLen) {
                        moreRoutes = FALSE;
                    }
                }
                numberOfRoutes = (UINT)(outputLen / sizeof(IPRouteEntry));
                for (i = 0, pRoute = routeTable; i < numberOfRoutes; ++i, ++pRoute)
                {

                    //
                    // the gateway address has a destination of 0.0.0.0
                    //

                    if (pRoute->ire_dest == INADDR_ANY) {

                        PIP_ADAPTER_INFO pAdapterInfo = list;

                        for (; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next) {
                            if (pAdapterInfo->Index == (UINT)pRoute->ire_index) {
                                TRACE_PRINT(("GetAdapterList: gw=0x%08x.\n",
                                             pRoute->ire_nexthop ));
                                if (!AddIpAddress(&pAdapterInfo->GatewayList,
                                                  pRoute->ire_nexthop,

                                                  //
                                                  // gateway IP address doesn't
                                                  // have corresponding IP mask
                                                  //

                                                  INADDR_ANY,
                                                  0
                                                  )) {
                                    ReleaseMemory((void*)routeTable);
                                    goto error_exit;
                                }
                                // MohsinA, 22-Jul-97.
                                // break;
                            }
                        }
                    }
                }
                ReleaseMemory((void*)routeTable);
            }
        }
    }

    // ====================================================================

    ReleaseMemory((void*)entityList);
    ReleaseMemory(adapterOrderMap);

    //
    // If there are any unidirectional adapters
    // move them to the end of the list
    //

    tmp = list;

    if (pUniInfo->NumAdapters) {

        this = list;
        prev = NULL;

        while (this) {

            if (this->DhcpEnabled == IF_TYPE_RECEIVE_ONLY) {

                //
                // Remove "this" from the list
                //

                if (prev) {
                    prev->Next = this->Next;
                } else {
                    prev = this->Next;
                    list = this->Next;
                }
                tmp = this->Next;

                //
                // Restore DhcbEnabled
                //

                this->DhcpEnabled = FALSE;

                //
                // Chain this to list of TV adapters
                //

                this->Next = UniList;
                UniList =  this;
                this = tmp;

            } else {
                prev = this;
                this = this->Next;
            }
        }

        //
        // Insert UniList at the end.
        //
        if (prev) {
            prev->Next = UniList;
        } else {
            ASSERT(list == NULL);
            list = UniList;
        }

    }

    FREE(pUniInfo);

    return list;

  error_exit:

    DEBUG_PRINT(("GetAdapterList: <= failed\n"));

    if (entityList) {
        ReleaseMemory((void*)entityList);
    }
    if (adapterOrderMap) {
        ReleaseMemory(adapterOrderMap);
    }
    if (pUniInfo) {
        FREE(pUniInfo);
    }

    KillAdapterInfo(list);
    return NULL;
}



/*******************************************************************************
 *
 *  AddIpAddress
 *
 *  Adds an IP_ADDR_STRING to a list. If the input IP_ADDR_STRING is empty this
 *  is filled in, else a new IP_ADDR_STRING is allocated and chained to the
 *  input IP_ADDR_STRING
 *
 *  ENTRY   AddressList - pointer to IP_ADDR which may or may not already hold
 *                        an IP address
 *          Address     - IP address to add
 *          Mask        - corresponding IP subnet mask
 *          Context     - address context
 *
 *  EXIT    AddressList - updated with new info
 *
 *  RETURNS Success - 1
 *          Failure - 0
 *
 *  ASSUMES 1. INADDR_ANY (ulong 0) indicates inactive IP address
 *
 ******************************************************************************/

int AddIpAddress(PIP_ADDR_STRING AddressList, DWORD Address, DWORD Mask, DWORD Context)
{

    PIP_ADDR_STRING ipAddr;

    if (AddressList->IpAddress.String[0]) {
        for (ipAddr = AddressList; ipAddr->Next; ipAddr = ipAddr->Next) {
            ;
        }
        ipAddr->Next = NEW(IP_ADDR_STRING);
        if (!ipAddr->Next) {

            DEBUG_PRINT(("AddIpAddress: failed to allocate memory for IP_ADDR_STRING\n"));

            return FALSE;
        }
        ipAddr = ipAddr->Next;
    } else {
        ipAddr = AddressList;
    }
    ConvertIpAddressToString(Address, ipAddr->IpAddress.String);
    ConvertIpAddressToString(Mask, ipAddr->IpMask.String);
    ipAddr->Context = Context;
    ipAddr->Next = NULL;
    return TRUE;
}



/*******************************************************************************
 *
 *  AddIpAddressString
 *
 *  Same as AddIpAddress, except the arguments are already converted to strings
 *
 *  ENTRY   AddressList - pointer to IP_ADDR which may or may not already hold
 *                        an IP address
 *          Address     - IP address to add, as a string
 *          Mask        - corresponding IP subnet mask, as a string
 *
 *  EXIT    AddressList - updated with new info
 *
 *  RETURNS Success - 1
 *          Failure - 0
 *
 *  ASSUMES nothing
 *
 ******************************************************************************/

int AddIpAddressString(PIP_ADDR_STRING AddressList, LPSTR Address, LPSTR Mask)
{

    PIP_ADDR_STRING ipAddr;

    if (AddressList->IpAddress.String[0]) {
        for (ipAddr = AddressList; ipAddr->Next; ipAddr = ipAddr->Next) {
            if (!strncmp(ipAddr->IpAddress.String, Address, sizeof(ipAddr->IpAddress.String))) {
                return FALSE;
            }
        }
        if (!strncmp(ipAddr->IpAddress.String, Address, sizeof(ipAddr->IpAddress.String))) {
            return FALSE;
        }
        ipAddr->Next = NEW(IP_ADDR_STRING);
        if (!ipAddr->Next) {

            DEBUG_PRINT(("AddIpAddressString: failed to allocate memory for IP_ADDR_STRING\n"));

            return FALSE;
        }
        ipAddr = ipAddr->Next;
    } else {
        ipAddr = AddressList;
    }
    CopyString(ipAddr->IpAddress.String, sizeof(ipAddr->IpAddress.String), Address);
    CopyString(ipAddr->IpMask.String, sizeof(ipAddr->IpMask.String), Mask);
    return TRUE;
}



/*******************************************************************************
 *
 *  ConvertIpAddressToString
 *
 *  Converts a DWORD IP address or subnet mask to dotted decimal string
 *
 *  ENTRY   IpAddress   - IP Address to convert
 *          String      - pointer to place to store dotted decimal string
 *
 *  EXIT    String contains ASCII representation of IpAddress
 *
 *  RETURNS nothing
 *
 *  ASSUMES 1. IP address fits in a DWORD
 *
 ******************************************************************************/

VOID ConvertIpAddressToString(DWORD IpAddress, LPSTR String)
{

    IP_ADDRESS ipAddr;

    ipAddr.d = IpAddress;
    sprintf(String,
            "%d.%d.%d.%d",
            ipAddr.b[0],
            ipAddr.b[1],
            ipAddr.b[2],
            ipAddr.b[3]
            );
}



/*******************************************************************************
 *
 *  CopyString
 *
 *  Copies a string to a buffer. If the buffer would overflow, the string is
 *  truncated
 *
 *  ENTRY   Destination         - destination buffer to copy to
 *          DestinationLength   - size of Destination
 *          Source              - source string to copy
 *
 *  EXIT    Destination updated
 *
 *  RETURNS nothing
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID CopyString(LPSTR Destination, DWORD DestinationLength, LPSTR Source)
{

    DWORD maximumCharacters = min(DestinationLength - 1, STRLEN(Source));

    strncpy(Destination, Source, maximumCharacters);
    Destination[maximumCharacters] = '\0';
}



/*******************************************************************************
 *
 *  CleanDescription
 *
 *  Given an adapter description string retrieved from TCP/IP, remove the
 *  trailing substring " Adapter". If there is a trailing period, remove that
 *  too
 *
 *  ENTRY   String  - pointer to description string to clean up
 *
 *  EXIT    String  - possibly bits removed
 *
 *  RETURNS voidsville
 *
 *  ASSUMES
 *
 ******************************************************************************/

void CleanDescription(LPSTR String)
{

    int len = STRLEN(String);

    if (String[len - 1] == '.') {
        String[--len] = 0;
    }
    if (!STRICMP(String + len - (sizeof(" Adapter") - 1), " Adapter")) {
        len -= sizeof(" Adapter") - 1;
        String[len] = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\entity.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    entity.c

Abstract:

    This module contains functions to get the entity list from the TCP/IP
    device driver

    Contents:
        GetEntityList

Author:

    Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth
        Created

--*/

#include "precomp.h"
#pragma hdrstop

/*******************************************************************************
 *
 *  GetEntityList
 *
 *  Allocates a buffer for, and retrieves, the list of entities supported by the
 *  TCP/IP device driver
 *
 *  ENTRY   nothing
 *
 *  EXIT    EntityCount - number of entities in the buffer
 *
 *  RETURNS Success - pointer to allocated buffer containing list of entities
 *          Failure - NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

TDIEntityID* GetEntityList(UINT* EntityCount) {

    TCP_REQUEST_QUERY_INFORMATION_EX req;
    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    LPVOID buffer = NULL;
    TDIEntityID* pEntity = NULL;

    memset(&req, 0, sizeof(req));

    req.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    req.ID.toi_entity.tei_instance = 0;
    req.ID.toi_class = INFO_CLASS_GENERIC;
    req.ID.toi_type = INFO_TYPE_PROVIDER;
    req.ID.toi_id = ENTITY_LIST_ID;

    inputLen = sizeof(req);
    outputLen = sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;

    //
    // this is over-engineered - its very unlikely that we'll ever get >32
    // entities returned, never mind >64K's worth
    //

    do {

        DWORD previousOutputLen;

        previousOutputLen = outputLen;
        if (pEntity) {
            ReleaseMemory((void*)pEntity);
        }
        pEntity = (TDIEntityID*)NEW_MEMORY((size_t)outputLen);
        if (!pEntity) {

            DEBUG_PRINT(("GetEntityList: failed to allocate entity buffer (%ld bytes)\n",
                        outputLen
                        ));

            return NULL;
        }
        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)pEntity,
                           &outputLen
                           );
        if (status == NO_ERROR) {
            break;
        } else if (status == ERROR_INSUFFICIENT_BUFFER) {
            outputLen = previousOutputLen +
                        sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;
        } else {

            DEBUG_PRINT(("GetEntityList: WsControl(GENERIC_ENTITY) returns %ld, outputLen = %ld\n",
                        status,
                        outputLen
                        ));

            ReleaseMemory((void*)pEntity);
            return NULL;
        }

    } while ( TRUE );

    DEBUG_PRINT(("%d entities returned\n", (outputLen / sizeof(TDIEntityID))));

    *EntityCount = (UINT)(outputLen / sizeof(TDIEntityID));
    return pEntity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\ipcfginc.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    ipcfginc.h

Abstract:

    Contains all includes, definitions, types, prototypes for ipconfig

Author:

    Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth        Created
    20-May-97   MohsinA       NT50 PNP.
    31-Jul-97   MohsinA       Patterns.
    10-Mar-98   chunye        Renamed as ipcfginc.h for ipcfgdll support.

--*/

#ifndef _IPCFGINC_
#define _IPCFGINC_ 1


#include "common.h"
#include "iptypes.h"
#include "ipconfig.h"


//
// IS_INTERESTING_ADAPTER - TRUE if the type of this adapter (IFEntry) is NOT
// loopback. Loopback (corresponding to local host) is the only one we filter
// out right now
//

#define IS_INTERESTING_ADAPTER(p)   (!((p)->if_type == IF_TYPE_SOFTWARE_LOOPBACK))

//
// Alloc and Free used in adaptlst.c
//
#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

//
// Maxumum uni directional adapter that is supported
// by default
//
#define MAX_UNI_ADAPTERS 10

//
// iphlppai.dll roiutine to get unidirectional adapter info
//
extern
DWORD
GetUniDirectionalAdapterInfo(PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pIPIfInfo,
                             PULONG dwOutBufLen);


//
// types
//

#ifndef _AVOID_IP_ADDRESS
//
// IP_ADDRESS - access an IP address as a single DWORD or 4 BYTEs
//

typedef union {
    DWORD  d;
    BYTE   b[4];
} IP_ADDRESS, *PIP_ADDRESS, IP_MASK, *PIP_MASK;
#endif // _AVOID_IP_ADDRESS


//
// prototypes
//

//
// From ipconfig.c
//

BOOL  Initialize(PDWORD);
BOOL  LoadAndLinkDhcpFunctions(VOID);
VOID  Terminate(VOID);


//
// From entity.c
//

TDIEntityID* GetEntityList(UINT*);

//
// From adaptlst.c
//

PIP_ADAPTER_INFO   GetAdapterList(VOID);
INT                AddIpAddress(PIP_ADDR_STRING, DWORD, DWORD, DWORD);
INT                AddIpAddressString(PIP_ADDR_STRING, LPSTR, LPSTR);
INT                PrependIpAddress(PIP_ADDR_STRING, DWORD, DWORD, DWORD);
VOID               ConvertIpAddressToString(DWORD, LPSTR);
VOID               CopyString(LPSTR, DWORD, LPSTR);
VOID               KillAdapterInfo(PIP_ADAPTER_INFO);


//
// From wins.c
//

BOOL GetWinsServers(PIP_ADAPTER_INFO);


//
// In debug.c
//

#ifdef DBG

void print_IP_ADDRESS_STRING(char *message, IP_ADDRESS_STRING *s);
void print_IP_ADDR_STRING(char *message, PIP_ADDR_STRING s);
void print_IP_ADAPTER_INFO(char *message, IP_ADAPTER_INFO *s);
void print_FIXED_INFO(char *message, FIXED_INFO *s);
void print_IFEntry(char *message, struct IFEntry *s);

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\ipcfgmsg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ipcfgmsg.mc

Abstract:

    Contains internationalizable message text for IPCONFIG

Author:

    Richard L Firth (rfirth) 05-Mar-1994

Revision History:

    05-Mar-1994 rfirth    Created
    31-Jul-97   MohsinA   PNP patterns for NT50.

--*/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_IPCONFIG_BANNER
//
// MessageText:
//
//  
//  Windows NT IP Configuration
//  
//
#define MSG_IPCONFIG_BANNER              0x00002710L

//
// MessageId: MSG_HOST_NAME
//
// MessageText:
//
//  Host Name . . . . . . . . . : %0
//
#define MSG_HOST_NAME                    0x00002711L

//
// MessageId: MSG_DNS_SERVERS
//
// MessageText:
//
//  DNS Servers . . . . . . . . : %0
//
#define MSG_DNS_SERVERS                  0x00002712L

//
// MessageId: MSG_NODE_TYPE
//
// MessageText:
//
//  Node Type . . . . . . . . . : %1
//
#define MSG_NODE_TYPE                    0x00002713L

//
// MessageId: MSG_SCOPE_ID
//
// MessageText:
//
//  NetBIOS Scope ID. . . . . . : %1
//
#define MSG_SCOPE_ID                     0x00002714L

//
// MessageId: MSG_IP_ROUTING
//
// MessageText:
//
//  IP Routing Enabled. . . . . : %1
//
#define MSG_IP_ROUTING                   0x00002715L

//
// MessageId: MSG_PROXY
//
// MessageText:
//
//  WINS Proxy Enabled. . . . . : %1
//
#define MSG_PROXY                        0x00002716L

//
// MessageId: MSG_DNS_RESOLUTION
//
// MessageText:
//
//  NetBIOS Resolution Uses DNS : %1
//
#define MSG_DNS_RESOLUTION               0x00002717L

//
// MessageId: MSG_PHYSICAL_ADDRESS
//
// MessageText:
//
//  Physical Address. . . . . . : %1
//
#define MSG_PHYSICAL_ADDRESS             0x00002718L

//
// MessageId: MSG_DESCRIPTION
//
// MessageText:
//
//  Description . . . . . . . . : %1
//
#define MSG_DESCRIPTION                  0x00002719L

//
// MessageId: MSG_DHCP_ENABLED
//
// MessageText:
//
//  DHCP Enabled. . . . . . . . : %1
//
#define MSG_DHCP_ENABLED                 0x0000271AL

//
// MessageId: MSG_AUTOCONFIG_ENABLED
//
// MessageText:
//
//  Autoconfiguration Enabled . : %1
//
#define MSG_AUTOCONFIG_ENABLED           0x0000271BL

//
// MessageId: MSG_IP_ADDRESS
//
// MessageText:
//
//  IP Address. . . . . . . . . : %1
//
#define MSG_IP_ADDRESS                   0x0000271CL

//
// MessageId: MSG_AUTOCONFIG_ADDRESS
//
// MessageText:
//
//  Autoconfiguration IP Address: %1
//
#define MSG_AUTOCONFIG_ADDRESS           0x0000271DL

//
// MessageId: MSG_SUBNET_MASK
//
// MessageText:
//
//  Subnet Mask . . . . . . . . : %1
//
#define MSG_SUBNET_MASK                  0x0000271EL

//
// MessageId: MSG_DEFAULT_GATEWAY
//
// MessageText:
//
//  Default Gateway . . . . . . : %1
//
#define MSG_DEFAULT_GATEWAY              0x0000271FL

//
// MessageId: MSG_DHCP_SERVER
//
// MessageText:
//
//  DHCP Server . . . . . . . . : %1
//
#define MSG_DHCP_SERVER                  0x00002720L

//
// MessageId: MSG_WINS_SERVER_1
//
// MessageText:
//
//  Primary WINS Server . . . . : %1
//
#define MSG_WINS_SERVER_1                0x00002721L

//
// MessageId: MSG_WINS_SERVER_2
//
// MessageText:
//
//  Secondary WINS Server . . . : %1
//
#define MSG_WINS_SERVER_2                0x00002722L

//
// MessageId: MSG_LEASE_OBTAINED
//
// MessageText:
//
//  Lease Obtained. . . . . . . : %1
//
#define MSG_LEASE_OBTAINED               0x00002723L

//
// MessageId: MSG_LEASE_EXPIRES
//
// MessageText:
//
//  Lease Expires . . . . . . . : %1
//
#define MSG_LEASE_EXPIRES                0x00002724L

//
// MessageId: MSG_ERROR_STRING
//
// MessageText:
//
//  Error: %1
//
#define MSG_ERROR_STRING                 0x00002725L

//
// MessageId: MSG_ADAPTER
//
// MessageText:
//
//  %1adapter %2:
//  
//
#define MSG_ADAPTER                      0x00002726L

//
// MessageId: MSG_FATAL_ERROR
//
// MessageText:
//
//  Fatal error: %1
//  
//
#define MSG_FATAL_ERROR                  0x00002727L

//
// MessageId: MSG_INCORRECT_ARGS
//
// MessageText:
//
//  Error: Command line arguments conflict
//  
//
#define MSG_INCORRECT_ARGS               0x00002728L

//
// MessageId: MSG_UNRECOGNIZED_ARG
//
// MessageText:
//
//  Error: Unrecognized command line argument "%1"
//  
//
#define MSG_UNRECOGNIZED_ARG             0x00002729L

//
// MessageId: MSG_USAGE
//
// MessageText:
//
//  
//  USAGE:     ipconfig [/? | /all | /release [adapter] | /renew [adapter]]
//  
//     adapter    Full name or pattern with '*' and '?' to 'match',
//                * matches any character, ? matches one character.
//     Options
//         /?       Display this help message.
//         /all     Display full configuration information.
//         /release Release the IP address for the specified adapter.
//         /renew   Renew the IP address for the specified adapter.
//  
//  The default is to display only the IP address, subnet mask and
//  default gateway for each adapter bound to TCP/IP.
//  
//  For Release and Renew, if no adapter name is specified, then the IP address
//  leases for all adapters bound to TCP/IP will be released or renewed.
//  
//  Examples:
//      > ipconfig                       ... Show information.
//      > ipconfig /all                  ... Show detailed information
//      > ipconfig /renew                ... renew all adapters
//      > ipconfig /renew EL*            ... renew adapters named EL....
//      > ipconfig /release *ELINK?21*   ... release all matching adapters,
//                                           eg. ELINK-21, myELELINKi21adapter.
//
#define MSG_USAGE                        0x0000272AL

//
// MessageId: MSG_BNODE
//
// MessageText:
//
//  Broadcast%0
//
#define MSG_BNODE                        0x0000272BL

//
// MessageId: MSG_PNODE
//
// MessageText:
//
//  Peer-Peer%0
//
#define MSG_PNODE                        0x0000272CL

//
// MessageId: MSG_MNODE
//
// MessageText:
//
//  Mixed%0
//
#define MSG_MNODE                        0x0000272DL

//
// MessageId: MSG_HNODE
//
// MessageText:
//
//  Hybrid%0
//
#define MSG_HNODE                        0x0000272EL

//
// MessageId: MSG_IF_TYPE_OTHER
//
// MessageText:
//
//  Other %0
//
#define MSG_IF_TYPE_OTHER                0x0000272FL

//
// MessageId: MSG_IF_TYPE_ETHERNET
//
// MessageText:
//
//  Ethernet %0
//
#define MSG_IF_TYPE_ETHERNET             0x00002730L

//
// MessageId: MSG_IF_TYPE_TOKEN_RING
//
// MessageText:
//
//  Token Ring %0
//
#define MSG_IF_TYPE_TOKEN_RING           0x00002731L

//
// MessageId: MSG_IF_TYPE_FDDI
//
// MessageText:
//
//  FDDI %0
//
#define MSG_IF_TYPE_FDDI                 0x00002732L

//
// MessageId: MSG_IF_TYPE_PPP
//
// MessageText:
//
//  PPP %0
//
#define MSG_IF_TYPE_PPP                  0x00002733L

//
// MessageId: MSG_IF_TYPE_LOOPBACK
//
// MessageText:
//
//  Loopback %0
//
#define MSG_IF_TYPE_LOOPBACK             0x00002734L

//
// MessageId: MSG_IF_TYPE_SLIP
//
// MessageText:
//
//  SLIP %0
//
#define MSG_IF_TYPE_SLIP                 0x00002735L

//
// MessageId: MSG_YES
//
// MessageText:
//
//  Yes%0
//
#define MSG_YES                          0x00002736L

//
// MessageId: MSG_NO
//
// MessageText:
//
//  No%0
//
#define MSG_NO                           0x00002737L

//
// MessageId: MSG_INIT_FAILED
//
// MessageText:
//
//  Failed to initialize%0
//
#define MSG_INIT_FAILED                  0x00002738L

//
// MessageId: MSG_TCP_NOT_RUNNING
//
// MessageText:
//
//  TCP/IP is not running on this system%0
//
#define MSG_TCP_NOT_RUNNING              0x00002739L

//
// MessageId: MSG_REG_BINDINGS_ERROR
//
// MessageText:
//
//  Cannot access adapter bindings registry key%0
//
#define MSG_REG_BINDINGS_ERROR           0x0000273AL

//
// MessageId: MSG_REG_INCONSISTENT_ERROR
//
// MessageText:
//
//  Inconsistent registry contents%0
//
#define MSG_REG_INCONSISTENT_ERROR       0x0000273BL

//
// MessageId: MSG_TCP_BINDING_ERROR
//
// MessageText:
//
//  TCP/IP not bound to any adapters%0
//
#define MSG_TCP_BINDING_ERROR            0x0000273CL

//
// MessageId: MSG_MEMORY_ERROR
//
// MessageText:
//
//  Allocating memory%0
//
#define MSG_MEMORY_ERROR                 0x0000273DL

//
// MessageId: MSG_ALL
//
// MessageText:
//
//  all%0
//
#define MSG_ALL                          0x0000273EL

//
// MessageId: MSG_RELEASE
//
// MessageText:
//
//  Release%0
//
#define MSG_RELEASE                      0x0000273FL

//
// MessageId: MSG_RENEW
//
// MessageText:
//
//  Renew%0
//
#define MSG_RENEW                        0x00002740L

//
// MessageId: MSG_ADAPTER_NOT_FOUND
//
// MessageText:
//
//  Error: Adapter "%1" is not bound to TCP/IP
//
#define MSG_ADAPTER_NOT_FOUND            0x00002741L

//
// MessageId: MSG_NO_ADAPTERS_BOUND
//
// MessageText:
//
//  Error: No adapters bound to TCP/IP
//
#define MSG_NO_ADAPTERS_BOUND            0x00002742L

//
// MessageId: MSG_CANT_FIND_LIBRARY
//
// MessageText:
//
//  Fatal: Cannot find dynamic link library "%1"
//
#define MSG_CANT_FIND_LIBRARY            0x00002743L

//
// MessageId: MSG_CANT_FIND_ROUTINE
//
// MessageText:
//
//  Fatal: Cannot find function "%1" in library "%2"
//
#define MSG_CANT_FIND_ROUTINE            0x00002744L

//
// MessageId: MSG_ADAPTER_NAME_ERROR
//
// MessageText:
//
//  Error: The adapter name "%1" is invalid
//
#define MSG_ADAPTER_NAME_ERROR           0x00002745L

//
// MessageId: MSG_RELEASE_FAILED
//
// MessageText:
//
//  Error: %1: Releasing adapter "%2"
//
#define MSG_RELEASE_FAILED               0x00002746L

//
// MessageId: MSG_ACQUIRE_FAILED
//
// MessageText:
//
//  Error: %1: Renewing adapter "%2"
//
#define MSG_ACQUIRE_FAILED               0x00002747L

//
// MessageId: MSG_RELEASE_SUCCEEDED
//
// MessageText:
//
//  IP address %1 successfully released for adapter "%2"
//
#define MSG_RELEASE_SUCCEEDED            0x00002748L

//
// MessageId: MSG_RELEASE_OK
//
// MessageText:
//
//  IP address successfully released for adapter "%1"
//
#define MSG_RELEASE_OK                   0x00002749L

//
// MessageId: MSG_NO_DHCP_ENABLED
//
// MessageText:
//
//  Error: No adapters bound to TCP/IP are enabled for DHCP 
//
#define MSG_NO_DHCP_ENABLED              0x0000274AL

//
// MessageId: MSG_ADAPTER_NOT_DHCP
//
// MessageText:
//
//  Error: %1: Adapter "%2" is not enabled for DHCP
//
#define MSG_ADAPTER_NOT_DHCP             0x0000274BL

//
// MessageId: MSG_ACCESS_DENIED
//
// MessageText:
//
//  Access Denied%0
//
#define MSG_ACCESS_DENIED                0x0000274CL

//
// MessageId: MSG_SERVER_UNAVAILABLE
//
// MessageText:
//
//  DHCP Server Unavailable%0
//
#define MSG_SERVER_UNAVAILABLE           0x0000274DL

//
// MessageId: MSG_ALREADY_RELEASED
//
// MessageText:
//
//  IP Address for adapter %1 is already released
//
#define MSG_ALREADY_RELEASED             0x0000274EL

//
// MessageId: MSG_ADDRESS_CONFLICT
//
// MessageText:
//
//  The DHCP client obtained an address that is already in use on the network.
//
#define MSG_ADDRESS_CONFLICT             0x0000274FL

//
// MessageId: MSG_CANT_RELEASE_AUTOCONFIG_ADAPTER
//
// MessageText:
//
//  Adapter %1 was automatically configured and does not currently have a DHCP address.  The IP address for this adapter can not be released.
//
#define MSG_CANT_RELEASE_AUTOCONFIG_ADAPTER 0x00002750L

//
// MessageId: MSG_NO_DHCP_ADDRESS
//
// MessageText:
//
//  All adapters bound to DHCP have a DHCP address.  The addresses were automatically configured and can not be
//  released.
//
#define MSG_NO_DHCP_ADDRESS              0x00002751L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\ipconfig-x.c ===
// Dump structs of ipconfig.h
// Generated by pdbg on Wed May 21 14:23:06 1997
// ==================================================
// ipconfig.h:100

#include "precomp.h"

void
print_IP_ADDRESS_STRING( char* message, IP_ADDRESS_STRING * s )
{
    if(  message   ){
       DEBUG_PRINT(( "%s\n", message ));
    }
    if(  s == NULL ){
       DEBUG_PRINT(( "struct IP_ADDRESS_STRING is NULL.\n"));
       return;
    }
    DEBUG_PRINT(("struct IP_ADDRESS_STRING = {\n" ));
    DEBUG_PRINT(( "}; // struct IP_ADDRESS_STRING.\n"));
    return;
} /* print_IP_ADDRESS_STRING */

// ==================================================
// ipconfig.h:109

void
print_IP_ADDR_STRING( char* message, struct _IP_ADDR_STRING * s )
{
    if(  message   ){
       DEBUG_PRINT(( "%s\n", message ));
    }
    if(  s == NULL ){
       DEBUG_PRINT(( "struct _IP_ADDR_STRING is NULL.\n"));
       return;
    }
    DEBUG_PRINT(("struct _IP_ADDR_STRING = {\n" ));
    DEBUG_PRINT(("  Next               = 0x%p \n", s->Next ));
    DEBUG_PRINT(("  IpAddress          = 0x%08x \n", s->IpAddress ));
    DEBUG_PRINT(("  IpMask             = 0x%08x \n", s->IpMask ));
    DEBUG_PRINT(("  Context            = %d \n", s->Context ));
    DEBUG_PRINT(( "}; // struct _IP_ADDR_STRING.\n"));
    return;
} /* print_IP_ADDR_STRING */

// ==================================================
// ipconfig.h:121

void
print_IP_ADAPTER_INFO( char* message, struct _IP_ADAPTER_INFO * s )
{
    if(  message   ){
       DEBUG_PRINT(( "%s\n", message ));
    }
    if(  s == NULL ){
       DEBUG_PRINT(( "struct _IP_ADAPTER_INFO is NULL.\n"));
       return;
    }
    DEBUG_PRINT(("struct _IP_ADAPTER_INFO = {\n" ));
    DEBUG_PRINT(("  Next               = 0x%p \n", s->Next ));
    DEBUG_PRINT(("  AddressLength      = %d \n", s->AddressLength ));
    DEBUG_PRINT(("  Index              = %d \n", s->Index ));
    DEBUG_PRINT(("  Type               = %d \n", s->Type ));
    DEBUG_PRINT(("  DhcpEnabled        = %d \n", s->DhcpEnabled ));
    // DEBUG_PRINT(("  AutoconfigEnabled  = %d \n", s->AutoconfigEnabled ));
    // DEBUG_PRINT(("  AutoconfigActive   = %d \n", s->AutoconfigActive ));
    // DEBUG_PRINT(("  NodeType           = %d \n", s->NodeType ));
    DEBUG_PRINT(("  IpAddressList      = 0x%08x \n", s->IpAddressList ));
    DEBUG_PRINT(("  GatewayList        = 0x%08x \n", s->GatewayList ));
    DEBUG_PRINT(("  DhcpServer         = 0x%08x \n", s->DhcpServer ));
    DEBUG_PRINT(("  HaveWins           = 0x%08x \n", s->HaveWins ));
    DEBUG_PRINT(("  PrimaryWinsServer  = 0x%08x \n", s->PrimaryWinsServer ));
    DEBUG_PRINT(("  SecondaryWinsServer = 0x%08x \n", s->SecondaryWinsServer ));
    DEBUG_PRINT(("  LeaseObtained      = 0x%08x \n", s->LeaseObtained ));
    DEBUG_PRINT(("  LeaseExpires       = 0x%08x \n", s->LeaseExpires ));
    // DEBUG_PRINT(("  DnsServerList      = 0x%08x \n", s->DnsServerList ));
    DEBUG_PRINT(( "}; // struct _IP_ADAPTER_INFO.\n"));
    return;
} /* print_IP_ADAPTER_INFO */

// ==================================================
// ipconfig.h:147

void
print_FIXED_INFO( char* message, FIXED_INFO * s )
{
    if(  message   ){
       DEBUG_PRINT(( "%s\n", message ));
    }
    if(  s == NULL ){
       DEBUG_PRINT(( "struct FIXED_INFO is NULL.\n"));
       return;
    }
    DEBUG_PRINT(("struct FIXED_INFO = {\n" ));
    DEBUG_PRINT(("  DnsServerList      = 0x%08x \n", s->DnsServerList ));
    DEBUG_PRINT(("  NodeType           = %d \n", s->NodeType ));
    DEBUG_PRINT(("  EnableRouting      = %d \n", s->EnableRouting ));
    DEBUG_PRINT(("  EnableProxy        = %d \n", s->EnableProxy ));
    DEBUG_PRINT(("  EnableDns          = %d \n", s->EnableDns ));
    DEBUG_PRINT(( "}; // struct FIXED_INFO.\n"));
    return;
} /* print_FIXED_INFO */

// ==================================================
// Generated by MohsinA on Mon Mar 24 20:21:40 1997
// From //REDRUM/SLM/PROJ/NET/VXD/src/winsock2/util/memipcfg/debug.c

void
print_IFEntry( char* message, struct IFEntry * s )
{
    int i;

    if(  message   ){
       DEBUG_PRINT(( "%s\n", message ));
    }
    if(  s == NULL ){
       DEBUG_PRINT(( "struct IFEntry is NULL.\n"));
       return;
    }
    DEBUG_PRINT(("struct IFEntry = {\n" ));
    DEBUG_PRINT(("  if_index        =   %d  \n", s->if_index ));
    DEBUG_PRINT(("  if_type         =   %d    ", s->if_type ));

    switch( s->if_type ){
        case IF_TYPE_OTHER              : DEBUG_PRINT(("IF_TYPE_OTHER              ")); break;
        case IF_TYPE_ETHERNET_CSMACD    : DEBUG_PRINT(("IF_TYPE_ETHERNET_CSMACD    ")); break;
        case IF_TYPE_ISO88025_TOKENRING : DEBUG_PRINT(("IF_TYPE_ISO88025_TOKENRING ")); break;
        case IF_TYPE_FDDI               : DEBUG_PRINT(("IF_TYPE_FDDI               ")); break;
        case IF_TYPE_PPP                : DEBUG_PRINT(("IF_TYPE_PPP                ")); break;
        case IF_TYPE_SOFTWARE_LOOPBACK  : DEBUG_PRINT(("IF_TYPE_SOFTWARE_LOOPBACK  ")); break;
        case IF_TYPE_SLIP               : DEBUG_PRINT(("IF_TYPE_SLIP               ")); break;
    }
    DEBUG_PRINT(("\n"));

    DEBUG_PRINT(("  if_mtu             =   %d  \n", s->if_mtu ));
    DEBUG_PRINT(("  if_speed           =   %d  \n", s->if_speed ));
    DEBUG_PRINT(("  if_physaddrlen     =   %d  \n", s->if_physaddrlen ));
    DEBUG_PRINT(("  if_physaddr        =   " ));

    for( i = 0; i< MAX_PHYSADDR_SIZE; i++ ){
         DEBUG_PRINT(("%02x.", s->if_physaddr[i] ));
    }
    DEBUG_PRINT(("\n"));

    DEBUG_PRINT(("  if_adminstatus     = %d  \n", s->if_adminstatus ));
    DEBUG_PRINT(("  if_operstatus      = %d  \n", s->if_operstatus ));
    DEBUG_PRINT(("  if_lastchange      = %d  \n", s->if_lastchange ));
    DEBUG_PRINT(("  if_inoctets        = %d  \n", s->if_inoctets ));
    DEBUG_PRINT(("  if_inucastpkts     = %d  \n", s->if_inucastpkts ));
    DEBUG_PRINT(("  if_innucastpkts    = %d  \n", s->if_innucastpkts ));
    DEBUG_PRINT(("  if_indiscards      = %d  \n", s->if_indiscards ));
    DEBUG_PRINT(("  if_inerrors        = %d  \n", s->if_inerrors ));
    DEBUG_PRINT(("  if_inunknownprotos = %d \n", s->if_inunknownprotos ));
    DEBUG_PRINT(("  if_outoctets       = %d \n", s->if_outoctets ));
    DEBUG_PRINT(("  if_outucastpkts    = %d \n", s->if_outucastpkts ));
    DEBUG_PRINT(("  if_outnucastpkts   = %d \n", s->if_outnucastpkts ));
    DEBUG_PRINT(("  if_outdiscards     = %d \n", s->if_outdiscards ));
    DEBUG_PRINT(("  if_outerrors       = %d \n", s->if_outerrors ));
    DEBUG_PRINT(("  if_outqlen         = %d \n", s->if_outqlen ));
    DEBUG_PRINT(("  if_descrlen        = %d \n", s->if_descrlen ));
    DEBUG_PRINT(("  if_descr           = %s \n", s->if_descr ));
    DEBUG_PRINT(("}; // struct IFEntry.\n"));
    return;
} /* print_IFEntry */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\precomp.h ===
#include "ipcfginc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\ipconfig.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name: //KERNEL/RAZZLE3/src/sockets/tcpcmd/ipconfigext/ipcfgdll/ipconfig.c

    SYNOPSIS:  IPCFGDLL.DLL exports routines

Abstract:

Author:  Richard L Firth (rfirth) 05-Feb-1994

Revision History:

    05-Feb-1994 rfirth
        Created

    04-Mar-1994 rfirth
        * Pick non-Dhcp registry values if DHCP not enabled
        * TCP and IP have been consolidated

    27-Apr-1994 rfirth
        * added /release and /renew

    06-Aug-1994 rfirth
        * Get IP address values from TCP/IP stack, not registry

    30-Apr-97  MohsinA
        * Cleaning up for NT50.

    17-Jan-98  RameshV
        * Removed ScopeId display as new UI does not have this...
        * Made ReadRegistryIpAddrString read both MULTI_SZ and REG_SZ
        * Changed domainname and Dns server list from global to per-adapter
        * Display DhcpServer only if address is NOT autoconfigured..
        * AutoconfigEnabled is decided based on regval "AddressType"
        * Friendly names  stubs are used....
        * Error codes are converted first thru system library..

    06-Mar-98  chunye
        * Made this a DLL for support IPHLPAPI etc.
--*/

#include "precomp.h"
#include "ipcfgmsg.h"
#include <iprtrmib.h>
#include <ws2tcpip.h> // for in6addr_any
#include <ntddip.h>
#include <ntddip6.h>
#include <iphlpstk.h>
#include <nhapi.h>
#include <netconp.h>

//
// manifests
//

#define DEVICE_PREFIX       "\\Device\\"
#define TCPIP_DEVICE_PREFIX "\\Device\\Tcpip_"
const CHAR c_szDevice[] = "\\Device\\";
const CHAR c_szDeviceTcpip[] = "\\Device\\Tcpip_";
const WCHAR c_szDeviceNdiswanIp[] = L"\\Device\\NdiswanIp";

#define INITIAL_CAPABILITY  0x00000001
#define TCPIP_CAPABILITY    0x00000002
#define NETBT_CAPABILITY    0x00000004

#define STRING_ARRAY_DELIMITERS " \t,;"

#define MSG_NO_MESSAGE      0

#define KEY_TCP             1
#define KEY_NBT             2
#define KEY_TCP6            3

#define BNODE               BROADCAST_NODETYPE
#define PNODE               PEER_TO_PEER_NODETYPE
#define MNODE               MIXED_NODETYPE
#define HNODE               HYBRID_NODETYPE

#define MAX_FRIENDLY_NAME_LENGTH 80

#ifdef DBG
#define SET_DHCP_MODE 1
#define SET_AUTO_MODE 2
#endif


// ========================================================================
// macros
// ========================================================================

#define REG_OPEN_KEY(_hKey, _lpSubKey, _phkResult)  \
    RegOpenKeyEx(_hKey, _lpSubKey, 0, KEY_READ, _phkResult)

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_PTR(length, type) \
    ((ULONG_PTR)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP_PTR(length, type) \
    (ALIGN_DOWN_PTR(((ULONG_PTR)(length) + sizeof(type) - 1), type))

// ========================================================================
// types
// ========================================================================

typedef struct {
    DWORD Message;
    LPSTR String;
} MESSAGE_STRING, *PMESSAGE_STRING;

#define MAX_STRING_LIST_LENGTH  32  // arbitrary

// ========================================================================
// macros
// ========================================================================

// #define IS_ARG(c)           (((c) == '-') || ((c) == '/'))
// #define ReleaseMemory(p)    LocalFree((HLOCAL)(p))
// #define MAP_YES_NO(i)       ((i) ? MISC_MESSAGE(MI_YES) : MISC_MESSAGE(MI_NO))
#define ZERO_IP_ADDRESS(a)  !strcmp((a), "0.0.0.0")

// ========================================================================
// prototypes
// ========================================================================

BOOL   Initialize(PDWORD);
VOID   LoadMessages(VOID);
VOID   LoadMessageTable(PMESSAGE_STRING, UINT);
BOOL   ConvertOemToUnicode(LPSTR, LPWSTR);

BOOL   WriteRegistryDword(HKEY hKey, LPSTR szParameter, DWORD *pdwValue );
BOOL   WriteRegistryMultiString(HKEY, LPSTR, LPSTR);

static
BOOL   OpenAdapterKey(DWORD, const LPSTR, REGSAM, PHKEY);
BOOL   MyReadRegistryDword(HKEY, LPSTR, LPDWORD);
BOOL   ReadRegistryString(HKEY, LPSTR, LPSTR, LPDWORD);
BOOL   ReadRegistryOemString(HKEY, LPWSTR, LPSTR, LPDWORD);
BOOL   ReadRegistryIpAddrString(HKEY, LPSTR, PIP_ADDR_STRING);
BOOL   GetDnsServerList(PIP_ADDR_STRING);

LPSTR* GetBoundAdapterList(HKEY);
LPSTR  MapNodeType(UINT);
LPSTR  MapNodeTypeEx(UINT);
LPSTR  MapAdapterType(UINT);
LPSTR  MapAdapterTypeEx(UINT);
LPSTR  MapAdapterAddress(PIP_ADAPTER_INFO, LPSTR);
LPSTR  MapTime(PIP_ADAPTER_INFO, DWORD_PTR);
LPSTR  MapTimeEx(PPIP_ADAPTER_INFO, DWORD_PTR);
LPSTR  MapScopeId(PVOID);
VOID   KillFixedInfo(PFIXED_INFO);
VOID   KillPerAdapterInfo(PIP_PER_ADAPTER_INFO);
VOID   KillAdapterAddresses(PIP_ADAPTER_ADDRESSES);

VOID   Terminate(VOID);
LPVOID GrabMemory(DWORD);
VOID   DisplayMessage(BOOL, DWORD, ...);

BOOL   IsIncluded(DWORD Context, DWORD contextlist[], int len_contextlist);
BOOL   ReadRegistryList(HKEY Key, LPSTR ParameterName,
                        DWORD NumList[], int *MaxList);

DWORD  GetIgmpList(DWORD NTEAddr, DWORD *pIgmpList, PULONG dwOutBufLen);
DWORD WINAPI GetIpAddrTable(PMIB_IPADDRTABLE, PULONG, BOOL);

// ========================================================================
// data
// ========================================================================

HKEY TcpipLinkageKey    = INVALID_HANDLE_VALUE;
HKEY TcpipParametersKey = INVALID_HANDLE_VALUE;
HKEY NetbtParametersKey = INVALID_HANDLE_VALUE;
HKEY NetbtInterfacesKey = INVALID_HANDLE_VALUE;
// PHRLANCONNECTIONNAMEFROMGUIDORPATH HrLanConnectionNameFromGuid = NULL;
// HANDLE hNetMan = NULL;

//
// Note: The following variable caches whether IPv6 was installed and running
// at the time GetAdaptersAddresses() was called.  If multiple threads
// are calling GetAdaptersAddresses() during an install/uninstall, its
// value may change.  However, this is not really a problem.  The set of
// IPv6 DNS server addresses may or may not be present on an interface,
// but this is the same as the behavior of the set of IPv6 addresses, which
// doesn't use this variable.
//
BOOL bIp6DriverInstalled;

#ifdef DBG
UINT uChangeMode = 0;
#endif

#define FIELD_JUSTIFICATION_TEXT    "                          "

// ========================================================================
// MESSAGE_STRING arrays - contain internationalizable strings loaded from this
// module. If a load error occurs, we use the English language defaults
// ========================================================================

LPSTR NodeTypesEx[] = {
    "",
    "Broadcast",
    "Peer-Peer",
    "Mixed",
    "Hybrid"
};

MESSAGE_STRING NodeTypes[] =
{
    MSG_NO_MESSAGE,             TEXT(""),
    MSG_BNODE,                  TEXT("Broadcast"),
    MSG_PNODE,                  TEXT("Peer-Peer"),
    MSG_MNODE,                  TEXT("Mixed"),
    MSG_HNODE,                  TEXT("Hybrid")
};

#define NUMBER_OF_NODE_TYPES (sizeof(NodeTypes)/sizeof(NodeTypes[0]))

#define FIRST_NODE_TYPE 1
#define LAST_NODE_TYPE  4

LPSTR AdapterTypesEx[] = {
    "Other",
    "Ethernet",
    "Token Ring",
    "FDDI",
    "PPP",
    "Loopback",
    "SLIP"
};

MESSAGE_STRING AdapterTypes[] =
{
    MSG_IF_TYPE_OTHER,          TEXT("Other"),
    MSG_IF_TYPE_ETHERNET,       TEXT("Ethernet"),
    MSG_IF_TYPE_TOKEN_RING,     TEXT("Token Ring"),
    MSG_IF_TYPE_FDDI,           TEXT("FDDI"),
    MSG_IF_TYPE_PPP,            TEXT("PPP"),
    MSG_IF_TYPE_LOOPBACK,       TEXT("Loopback"),
    MSG_IF_TYPE_SLIP,           TEXT("SLIP")
};

#define NUMBER_OF_ADAPTER_TYPES (sizeof(AdapterTypes)/sizeof(AdapterTypes[0]))

MESSAGE_STRING MiscMessages[] =
{
    MSG_YES,                    TEXT("Yes"),
    MSG_NO,                     TEXT("No"),
    MSG_INIT_FAILED,            TEXT("Failed to initialize"),
    MSG_TCP_NOT_RUNNING,        TEXT("TCP/IP is not running on this system"),
    MSG_REG_BINDINGS_ERROR,     TEXT("Cannot access adapter bindings registry key"),
    MSG_REG_INCONSISTENT_ERROR, TEXT("Inconsistent registry contents"),
    MSG_TCP_BINDING_ERROR,      TEXT("TCP/IP not bound to any adapters"),
    MSG_MEMORY_ERROR,           TEXT("Allocating memory"),
    MSG_ALL,                    TEXT("all"),
    MSG_RELEASE,                TEXT("Release"),
    MSG_RENEW,                  TEXT("Renew"),
    MSG_ACCESS_DENIED,          TEXT("Access Denied"),
    MSG_SERVER_UNAVAILABLE,     TEXT("DHCP Server Unavailable"),
    MSG_ADDRESS_CONFLICT,       TEXT("The DHCP client obtained an address that is already in use on the network.")
};

#define NUMBER_OF_MISC_MESSAGES (sizeof(MiscMessages)/sizeof(MiscMessages[0]))

#define MISC_MESSAGE(i) MiscMessages[i].String
#define ADAPTER_TYPE(i) AdapterTypes[i].String
#define ADAPTER_TYPE_EX(i) AdapterTypesEx[i]

#define MI_IF_OTHER                 0
#define MI_IF_ETHERNET              1
#define MI_IF_TOKEN_RING            2
#define MI_IF_FDDI                  3
#define MI_IF_PPP                   4
#define MI_IF_LOOPBACK              5
#define MI_IF_SLIP                  6

#define MI_YES                      0
#define MI_NO                       1
#define MI_INIT_FAILED              2
#define MI_TCP_NOT_RUNNING          3
#define MI_REG_BINDINGS_ERROR       4
#define MI_REG_INCONSISTENT_ERROR   5
#define MI_TCP_BINDINGS_ERROR       6
#define MI_MEMORY_ERROR             7
#define MI_ALL                      8
#define MI_RELEASE                  9
#define MI_RENEW                    10
#define MI_ACCESS_DENIED            11
#define MI_SERVER_UNAVAILABLE       12
#define MI_ADDRESS_CONFLICT         13

//
// Debugging
//

#if defined(DEBUG)

BOOL Debugging = FALSE;
int  MyTrace     = 0;

#endif



// ========================================================================
// functions
// ========================================================================

BOOL
IpcfgdllInit(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{

    DWORD capability;

    switch (fdwReason) {

    case DLL_PROCESS_ATTACH:

        //        DisableThreadLibraryCalls(hInstDll);

        //
        // load all possible internationalizable strings
        //

        LoadMessages();

        //
        // what debug version is this?
        //

        DEBUG_PRINT(("IpcfgdllInit" __DATE__ " " __TIME__ "\n"));

        //
        // opens all the required registry keys
        //
        if (!Initialize(&capability)) {

            LPSTR str = NULL;

            //
            // exit if we couldn't open the registry services key or
            // IP or TCP keys.
            // We will continue if the NetBT key couldn't be opened
            //

            if (!(capability & INITIAL_CAPABILITY)) {

                str = MISC_MESSAGE(MI_INIT_FAILED);

            } else if (!(capability & TCPIP_CAPABILITY)) {

                str = MISC_MESSAGE(MI_TCP_NOT_RUNNING);

            }

            if (str) {

                //DisplayMessage(FALSE, MSG_ERROR_STRING, str);
                Terminate();
                return FALSE;

            }
        }

        break;

    case DLL_PROCESS_DETACH:

        Terminate();
        break;

    default:

        break;

    }

    return TRUE;
}



/*******************************************************************************
 *
 *  Initialize
 *
 *  Opens all the required registry keys
 *
 *  ENTRY   Capability
 *              Pointer to returned set of capabilities (bitmap)
 *
 *  EXIT    *Capability
 *              INITIAL_CAPABILITY
 *
 *              TCPIP_CAPABILITY
 *                  we could open the Tcpip\Linkage and Tcpip\Parameters keys
 *                  TcpipLinkageKey and TcpipParametersKey contain the open handles
 *
 *              NETBT_CAPABILITY
 *                  we could open the NetBT\Parameters key
 *                  NetbtInterfacesKey contains the open handle
 *
 *
 *  RETURNS TRUE = success
 *          FALSE = failure
 *
 *  ASSUMES
 *
 ******************************************************************************/

#define TCPIP_LINKAGE_KEY       "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Linkage"
#define TCPIP_PARAMS_KEY        "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\"
#define TCPIP_PARAMS_INTER_KEY  "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
#define TCPIP6_PARAMS_INTER_KEY "SYSTEM\\CurrentControlSet\\Services\\Tcpip6\\Parameters\\Interfaces\\"
#define NETBT_PARAMS_KEY        "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters"
#define NETBT_INTERFACE_KEY     "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces"
#define NETBT_ADAPTER_KEY       "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Adapters\\"

BOOL Initialize(PDWORD Capability)
{

    LONG err;
    char * name;

    *Capability = INITIAL_CAPABILITY;

    name = TCPIP_LINKAGE_KEY;
    TRACE_PRINT(("Initialize: RegOpenKey TcpipLinkageKey %s\n", name ));
    err = REG_OPEN_KEY(HKEY_LOCAL_MACHINE, name, &TcpipLinkageKey );

    if (err == ERROR_SUCCESS) {

        *Capability |= TCPIP_CAPABILITY;

        name = TCPIP_PARAMS_KEY;
        TRACE_PRINT(("Initialize: RegOpenKey TcpipParametersKey %s\n",
                     name ));
        err = REG_OPEN_KEY(HKEY_LOCAL_MACHINE, name, &TcpipParametersKey );

        if (err == ERROR_SUCCESS) {

            name = NETBT_INTERFACE_KEY;
            TRACE_PRINT(("Initialize: RegOpenKey NetbtInterfacesKey %s\n",
                         name ));
            err = REG_OPEN_KEY(HKEY_LOCAL_MACHINE, name, &NetbtInterfacesKey );

            if (err == ERROR_SUCCESS) {
                *Capability |= NETBT_CAPABILITY;
            } else {
                NetbtInterfacesKey = INVALID_HANDLE_VALUE;
            }
        } else {
            *Capability &= ~TCPIP_CAPABILITY;
            TcpipParametersKey = INVALID_HANDLE_VALUE;
        }
    } else {
        TcpipLinkageKey = INVALID_HANDLE_VALUE;
    }

    // =======================================================
    name = NETBT_PARAMS_KEY;
    TRACE_PRINT(("Initialize: RegOpenKey NetbtParametersKey %s.\n", name ));
    err = REG_OPEN_KEY(HKEY_LOCAL_MACHINE, name, &NetbtParametersKey );
    // ======================================================

    if( err != ERROR_SUCCESS ){
        DEBUG_PRINT(("Initialize: RegOpenKey %s failed, err=%d\n",
                     name, GetLastError() ));
    }

    TRACE_PRINT(("Initialize RegOpenKey ok: \n"
                 "  TcpipLinkageKey    = %p\n"
                 "  TcpipParametersKey = %p\n"
                 "  NetbtInterfacesKey = %p\n"
                 "  NetbtParametersKey = %p\n",
                 TcpipLinkageKey,
                 TcpipParametersKey,
                 NetbtInterfacesKey,
                 NetbtParametersKey
                 ));

    return err == ERROR_SUCCESS;
}



/*******************************************************************************
 *
 *  LoadMessages
 *
 *  Loads all internationalizable messages into the various tables
 *
 *  ENTRY
 *
 *  EXIT    AdapterTypes, MiscMessages updated
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 *  COHESION Temporal
 *
 ******************************************************************************/

VOID LoadMessages()
{
    LoadMessageTable(NodeTypes, NUMBER_OF_NODE_TYPES);
    LoadMessageTable(AdapterTypes, NUMBER_OF_ADAPTER_TYPES);
    LoadMessageTable(MiscMessages, NUMBER_OF_MISC_MESSAGES);
}



/*******************************************************************************
 *
 *  LoadMessageTable
 *
 *  Loads internationalizable strings into a table, replacing the default for
 *  each. If an error occurs, the English language default is left in place
 *
 *  ENTRY   Table
 *              Pointer to table containing message ID and pointer to string
 *
 *          MessageCount
 *              Number of messages in Table
 *
 *  EXIT    Table updated
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID LoadMessageTable(PMESSAGE_STRING Table, UINT MessageCount)
{

    LPSTR string;
    DWORD count;

    //
    // for all messages in a MESSAGE_STRING table, load the string from this
    // module, replacing the default string in the table (only there in case
    // we get an error while loading the string, so we at least have English
    // to fall back on)
    //

    while (MessageCount--) {
        if (Table->Message != MSG_NO_MESSAGE) {

            //
            // we really want LoadString here, but LoadString doesn't indicate
            // how big the string is, so it doesn't give us an opportunity to
            // allocate exactly the right buffer size. FormatMessage does the
            // right thing
            //

            count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_FROM_HMODULE,
                                  NULL, // use default hModule
                                  Table->Message,
                                  0,    // use default language
                                  (LPTSTR)&string,
                                  0,    // minimum size to allocate
                                  NULL  // no arguments for inclusion in strings
                                  );
            if (count) {

                //
                // Format message returned the string: replace the English
                // language default
                //

                Table->String = string;
            } else {

                DEBUG_PRINT(("FormatMessage(%d) failed: %d\n", Table->Message, GetLastError()));

                //
                // this is ok if there is no string (e.g. just %0) in the .mc
                // file
                //

                Table->String = "";
            }
        }
        ++Table;
    }
}


/*******************************************************************************
 *
 *  ConvertOemToUnicode
 *
 *  Title says it all. Required because DhcpAcquireParameters etc. require the
 *  adapter name to be UNICODE
 *
 *  ENTRY   OemString
 *              Pointer to ANSI/OEM string to convert
 *
 *          UnicodeString
 *              Pointer to place to store converted results
 *
 *  EXIT    UnicodeString contains converted string if successful
 *
 *  RETURNS TRUE - it worked
 *          FALSE - it failed
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ConvertOemToUnicode(LPSTR OemString, LPWSTR UnicodeString)
{

    OEM_STRING oString;
    UNICODE_STRING uString;

    RtlInitString(&oString, OemString);
    uString.Buffer = UnicodeString;
    uString.MaximumLength = (USHORT)RtlOemStringToUnicodeSize(&oString);
    if (NT_SUCCESS(RtlOemStringToUnicodeString(&uString, &oString, FALSE))) {
        return TRUE;
    }
    return FALSE;
}



/*******************************************************************************
 *
 *  GetFixedInfo
 *
 *  Retrieves the fixed information we wish to display by querying it from the
 *  various registry keys
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to allocated FIXED_INFO structure
 *
 *  ASSUMES
 *
 ******************************************************************************/

PFIXED_INFO GetFixedInfo()
{
    PFIXED_INFO fixedInfo = NEW(FIXED_INFO);

    TRACE_PRINT(("Entered GetFixedInfo\n"));

    if (fixedInfo) {

        DWORD length;
        BOOL ok;
        HKEY transientKey;

        length = sizeof(fixedInfo->HostName);
        ok = ReadRegistryOemString(TcpipParametersKey,
                                   L"Hostname",
                                   fixedInfo->HostName,
                                   &length
                                   );

        //
        // domain: first try Domain then DhcpDomain
        //

        length = sizeof(fixedInfo->DomainName);
        ok = ReadRegistryOemString(TcpipParametersKey,
                                   L"Domain",
                                   fixedInfo->DomainName,
                                   &length
                                   );
        if (!ok) {
            length = sizeof(fixedInfo->DomainName);
            ok = ReadRegistryOemString(TcpipParametersKey,
                                       L"DhcpDomain",
                                       fixedInfo->DomainName,
                                       &length
                                       );
        }

        //
        // DNS Server list: first try NameServer and then DhcpNameServer
        //

#if 0
        ok = ReadRegistryIpAddrString(TcpipParametersKey,
                                      TEXT("NameServer"),
                                      &fixedInfo->DnsServerList
                                      );
        if (ok) {
            TRACE_PRINT(("GetFixedInfo: NameServer %s\n",
                         fixedInfo->DnsServerList ));
        }

        if (!ok) {
            ok = ReadRegistryIpAddrString(TcpipParametersKey,
                                          TEXT("DhcpNameServer"),
                                          &fixedInfo->DnsServerList
                                          );
            if (ok) {
                TRACE_PRINT(("GetFixedInfo: DhcpNameServer %s\n",
                            fixedInfo->DnsServerList));
            }
        }
#else
        ok = GetDnsServerList(&fixedInfo->DnsServerList);
        if (ok) {
            TRACE_PRINT(("GetFixedInfo: DnsServerList %s\n",
                        fixedInfo->DnsServerList));
        }
#endif

        //
        // NodeType: static then DHCP
        //

        ok = MyReadRegistryDword(NetbtParametersKey,
                               TEXT("NodeType"),
                               &fixedInfo->NodeType
                               );
        if (!ok) {
            ok = MyReadRegistryDword(NetbtParametersKey,
                                   TEXT("DhcpNodeType"),
                                   &fixedInfo->NodeType
                                   );
        }

        //
        // ScopeId: static then DHCP
        //

        length = sizeof(fixedInfo->ScopeId);
        ok = ReadRegistryString(NetbtParametersKey,
                                TEXT("ScopeId"),
                                fixedInfo->ScopeId,
                                &length
                                );
        if (!ok) {
            length = sizeof(fixedInfo->ScopeId);
            ok = ReadRegistryString(NetbtParametersKey,
                                    TEXT("DhcpScopeId"),
                                    fixedInfo->ScopeId,
                                    &length
                                    );
        }
        ok = MyReadRegistryDword(TcpipParametersKey,
                               TEXT("IPEnableRouter"),
                               &fixedInfo->EnableRouting
                               );
        ok = MyReadRegistryDword(NetbtParametersKey,
                               TEXT("EnableProxy"),
                               &fixedInfo->EnableProxy
                               );
        ok = MyReadRegistryDword(NetbtParametersKey,
                               TEXT("EnableDNS"),
                               &fixedInfo->EnableDns
                               );
    }else{
        DEBUG_PRINT(("No memory for fixedInfo\n"));
    }

    TRACE_PRINT(("Exit GetFixedInfo @ %p\n", fixedInfo ));

    return fixedInfo;
}



/*******************************************************************************
 *
 *  GetAdapterNameToIndexInfo
 *
 *  Gets the mapping between IP if_index and AdapterName.
 *
 *  RETURNS  pointer to a PIP_INTERFACE_INFO structure that has been allocated.
 *
 ******************************************************************************/

PIP_INTERFACE_INFO GetAdapterNameToIndexInfo( VOID )
{
    PIP_INTERFACE_INFO pInfo;
    ULONG              dwSize, dwError;

    dwSize = 0; pInfo = NULL;

    while( 1 ) {

        dwError = GetInterfaceInfo( pInfo, &dwSize );
        if( (ERROR_INSUFFICIENT_BUFFER != dwError) && (ERROR_BUFFER_OVERFLOW != dwError) ) break;

        if( NULL != pInfo ) ReleaseMemory(pInfo);
        if( 0 == dwSize ) return NULL;

        pInfo = GrabMemory(dwSize);
        if( NULL == pInfo ) return NULL;

    }

    if( ERROR_SUCCESS != dwError || 0 == pInfo->NumAdapters ) {
        if( NULL != pInfo ) ReleaseMemory(pInfo);
        return NULL;
    }

    return pInfo;
}

/*******************************************************************************
 *
 *  GetAdapterInfo
 *
 *  Gets a list of all adapters to which TCP/IP is bound and reads the per-
 *  adapter information that we want to display. Most of the information now
 *  comes from the TCP/IP stack itself. In order to keep the 'short' names that
 *  exist in the registry to refer to the individual adapters, we read the names
 *  from the registry then match them to the adapters returned by TCP/IP by
 *  matching the IPInterfaceContext value with the adapter which owns the IP
 *  address with that context value
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to linked list of IP_ADAPTER_INFO structures
 *
 *  ASSUMES
 *
 ******************************************************************************/

PIP_ADAPTER_INFO GetAdapterInfo(VOID)
{

    PIP_ADAPTER_INFO adapterList;
    PIP_ADAPTER_INFO adapter;
    PIP_INTERFACE_INFO currentAdapterNames;
    LPSTR name;
    int i;

    HKEY key;

    TRACE_PRINT(("Entered GetAdapterInfo\n"));

    if (currentAdapterNames = GetAdapterNameToIndexInfo()) {
        if (adapterList = GetAdapterList()) {

            //
            // apply the short name to the right adapter info by comparing
            // the IPInterfaceContext value in the adapter\Parameters\Tcpip
            // section with the context values read from the stack for the
            // IP addresses
            //

            for (i = 0; i < currentAdapterNames->NumAdapters; ++i) {
                ULONG  dwLength;
                DWORD  dwIfIndex = currentAdapterNames->Adapter[i].Index;

                TRACE_PRINT(("currentAdapterNames[%d]=%ws (if_index 0x%lx)\n",
                             i, currentAdapterNames->Adapter[i].Name, dwIfIndex ));

                //
                // now search through the list of adapters, looking for the one
                // that has the IP address with the same index value as that
                // just read. When found, apply the short name to that adapter
                //

                for (adapter = adapterList;
                     adapter ;
                     adapter = adapter->Next
                )
                {

                    if( adapter->Index == dwIfIndex ) {

                        dwLength = wcslen(currentAdapterNames->Adapter[i].Name) + 1 - strlen(TCPIP_DEVICE_PREFIX);
                        dwLength = wcstombs(adapter->AdapterName,
                            currentAdapterNames->Adapter[i].Name + strlen(TCPIP_DEVICE_PREFIX),
                            dwLength);
                        if( -1 == dwLength ) {
                            adapter->AdapterName[0] = '\0';
                        }

                        break;
                    }

                }
            }
        }
        else
        {
            DEBUG_PRINT(("GetAdapterInfo: GetAdapterInfo gave NULL\n"));
        }
        ReleaseMemory(currentAdapterNames);

        //
        // now get the other pieces of info from the registry for each adapter
        //

        for (adapter = adapterList; adapter; adapter = adapter->Next) {

            TRACE_PRINT(("GetAdapterInfo: '%s'\n", adapter->AdapterName ));

            if (adapter->AdapterName[0] &&
                OpenAdapterKey(KEY_TCP, adapter->AdapterName, KEY_READ, &key)) {

                char dhcpServerAddress[4 * 4];
                DWORD addressLength;
                ULONG length;
                BOOL  ok;

                MyReadRegistryDword(key,
                                  TEXT("EnableDHCP"),
                                  &adapter->DhcpEnabled
                                  );

                TRACE_PRINT(("..'EnableDHCP' %d\n", adapter->DhcpEnabled ));

#ifdef DBG
                if ( uChangeMode )
                {
                    DWORD dwAutoconfigEnabled =
                        ( uChangeMode == SET_AUTO_MODE );

                    WriteRegistryDword(
                        key,
                        "IPAutoconfigurationEnabled",
                        &dwAutoconfigEnabled
                        );
                }
#endif

                if (adapter->DhcpEnabled) {
                    DWORD Temp;
                    MyReadRegistryDword(key,
                                      TEXT("LeaseObtainedTime"),
                                      &Temp
                                      );

                    adapter->LeaseObtained = Temp;

                    MyReadRegistryDword(key,
                                      TEXT("LeaseTerminatesTime"),
                                      &Temp
                                      );

                    adapter->LeaseExpires = Temp;
                }

                addressLength = sizeof( dhcpServerAddress );
                if (ReadRegistryString(key,
                                       TEXT("DhcpServer"),
                                       dhcpServerAddress,
                                       &addressLength
                )) {
                    AddIpAddressString(&adapter->DhcpServer,
                                       dhcpServerAddress,
                                       ""
                                       );
                }

                RegCloseKey(key);

            } else {

                DEBUG_PRINT(("Cannot OpenAdapterKey KEY_TCP '%s', gle=%d\n",
                             adapter->AdapterName,
                             GetLastError()));
            }

            //
            // get the info from the NetBT key - the WINS addresses
            //

            GetWinsServers(adapter);
        }

    } else {

        DEBUG_PRINT(("GetAdapterInfo: GetBoundAdapterList gave NULL\n"));
        adapterList = NULL;
    }

    TRACE_PRINT(("Exit GetAdapterInfo %p\n", adapterList));

    return adapterList;
}

/*******************************************************************************
 * AddIPv6UnicastAddressInfo
 *
 * This routine adds an IP_ADAPTER_UNICAST_ADDRESS entry for an IPv6 address
 * to a list of entries.
 *
 * ENTRY    IF   - IPv6 interface information
 *          ADE  - IPv6 address entry
 *          ppNext - Previous unicast entry's "next" pointer to update
 *
 * EXIT     Entry added and args updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv6UnicastAddressInfo(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, PIP_ADAPTER_UNICAST_ADDRESS **ppNext)
{
    DWORD dwErr = NO_ERROR;
    PIP_ADAPTER_UNICAST_ADDRESS pCurr;
    SOCKADDR_IN6 *pAddr;

    ASSERT(ADE->Type == ADE_UNICAST);

    pCurr = MALLOC(sizeof(IP_ADAPTER_UNICAST_ADDRESS));
    if (!pCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = MALLOC(sizeof(SOCKADDR_IN6));
    if (!pAddr) {
        FREE(pCurr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(pAddr, 0, sizeof(SOCKADDR_IN6));
    pAddr->sin6_family = AF_INET6;
    pAddr->sin6_scope_id = ADE->ScopeId;
    memcpy(&pAddr->sin6_addr, &ADE->This.Address, sizeof(ADE->This.Address));

    // Add address to linked list
    **ppNext = pCurr;
    *ppNext = &pCurr->Next;

    pCurr->Next = NULL;
    pCurr->Length = sizeof(IP_ADAPTER_UNICAST_ADDRESS);
    pCurr->ValidLifetime = ADE->ValidLifetime;
    pCurr->PreferredLifetime = ADE->PreferredLifetime;
    pCurr->LeaseLifetime = 0xFFFFFFFF;
    pCurr->Flags = 0;
    pCurr->Address.iSockaddrLength = sizeof(SOCKADDR_IN6);
    pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;
    pCurr->PrefixOrigin = ADE->PrefixConf;
    pCurr->SuffixOrigin = ADE->InterfaceIdConf;
    pCurr->DadState = ADE->DADState;

    // Only use DDNS on auto-configured addresses
    // (either auto-configured by the system or from an RA)
    // but NOT anonymous addresses.
    // Also do not use DDNS on link-local addresses
    // or the loopback address.
    if ((ADE->DADState == DAD_STATE_PREFERRED) &&
        (pCurr->SuffixOrigin != IpSuffixOriginRandom) &&
        !IN6_IS_ADDR_LOOPBACK(&ADE->This.Address) &&
        !IN6_IS_ADDR_LINKLOCAL(&ADE->This.Address)) {
        pCurr->Flags |= IP_ADAPTER_ADDRESS_DNS_ELIGIBLE;
    }

    return dwErr;
}

/*******************************************************************************
 * AddIPv6AnycastAddressInfo
 *
 * This routine adds an IP_ADAPTER_ANYCAST_ADDRESS entry for an IPv6 address
 * to a list of entries.
 *
 * ENTRY    IF   - IPv6 interface information
 *          ADE  - IPv6 address entry
 *          ppNext - Previous anycast entry's "next" pointer to update
 *
 * EXIT     Entry added and args updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv6AnycastAddressInfo(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, PIP_ADAPTER_ANYCAST_ADDRESS **ppNext)
{
    DWORD dwErr = NO_ERROR;
    PIP_ADAPTER_ANYCAST_ADDRESS pCurr;
    SOCKADDR_IN6 *pAddr;

    ASSERT(ADE->Type == ADE_ANYCAST);

    pCurr = MALLOC(sizeof(IP_ADAPTER_ANYCAST_ADDRESS));
    if (!pCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = MALLOC(sizeof(SOCKADDR_IN6));
    if (!pAddr) {
        FREE(pCurr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(pAddr, 0, sizeof(SOCKADDR_IN6));
    pAddr->sin6_family = AF_INET6;
    pAddr->sin6_scope_id = ADE->ScopeId;
    memcpy(&pAddr->sin6_addr, &ADE->This.Address, sizeof(ADE->This.Address));

    // Add address to linked list
    **ppNext = pCurr;
    *ppNext = &pCurr->Next;

    pCurr->Next = NULL;
    pCurr->Length = sizeof(IP_ADAPTER_ANYCAST_ADDRESS);
    pCurr->Flags = 0;
    pCurr->Address.iSockaddrLength = sizeof(SOCKADDR_IN6);
    pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;

    return dwErr;
}

/*******************************************************************************
 * AddIPv6MulticastAddressInfo
 *
 * This routine adds an IP_ADAPTER_MULTICAST_ADDRESS entry for an IPv6 address
 * to a list of entries.
 *
 * ENTRY    IF   - IPv6 interface information
 *          ADE  - IPv6 address entry
 *          ppNext - Previous multicast entry's "next" pointer to update
 *
 * EXIT     Entry added and args updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv6MulticastAddressInfo(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, PIP_ADAPTER_MULTICAST_ADDRESS **ppNext)
{
    DWORD dwErr = NO_ERROR;
    PIP_ADAPTER_MULTICAST_ADDRESS pCurr;
    SOCKADDR_IN6 *pAddr;

    ASSERT(ADE->Type == ADE_MULTICAST);

    pCurr = MALLOC(sizeof(IP_ADAPTER_MULTICAST_ADDRESS));
    if (!pCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = MALLOC(sizeof(SOCKADDR_IN6));
    if (!pAddr) {
        FREE(pCurr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(pAddr, 0, sizeof(SOCKADDR_IN6));
    pAddr->sin6_family = AF_INET6;
    pAddr->sin6_scope_id = ADE->ScopeId;
    memcpy(&pAddr->sin6_addr, &ADE->This.Address, sizeof(ADE->This.Address));

    // Add address to linked list
    **ppNext = pCurr;
    *ppNext = &pCurr->Next;

    pCurr->Next = NULL;
    pCurr->Length = sizeof(IP_ADAPTER_MULTICAST_ADDRESS);
    pCurr->Flags = 0;
    pCurr->Address.iSockaddrLength = sizeof(SOCKADDR_IN6);
    pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;

    return dwErr;
}

/*******************************************************************************
 * AddIPv6AddressInfo
 *
 * This routine adds an IP_ADAPTER_UNICAST_ADDRESS entry for an IPv6 address
 * to a list of entries.
 *
 * ENTRY    IF     - IPv6 interface information
 *          ADE    - IPv6 address entry
 *          arg1   - Previous unicast entry's "next" pointer to update
 *          arg2   - Previous anycast entry's "next" pointer to update
 *          arg3   - Previous multicast entry's "next" pointer to update
 *          Flags  - Flags specified by application
 *          Family - Address family constraint (for DNS server addresses)
 *
 * EXIT     Entry added and args updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv6AddressInfo(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, PVOID arg1, PVOID arg2, PVOID arg3, DWORD Flags, DWORD Family)
{
    switch (ADE->Type) {
    case ADE_UNICAST:
        if (Flags & GAA_FLAG_SKIP_UNICAST) {
            return NO_ERROR;
        }
        return AddIPv6UnicastAddressInfo(IF, ADE,
                                         (PIP_ADAPTER_UNICAST_ADDRESS**)arg1);
    case ADE_ANYCAST:
        if (Flags & GAA_FLAG_SKIP_ANYCAST) {
            return NO_ERROR;
        }
        return AddIPv6AnycastAddressInfo(IF, ADE,
                                         (PIP_ADAPTER_ANYCAST_ADDRESS**)arg2);
    case ADE_MULTICAST:
        if (Flags & GAA_FLAG_SKIP_MULTICAST) {
            return NO_ERROR;
        }
        return AddIPv6MulticastAddressInfo(IF, ADE,
                                         (PIP_ADAPTER_MULTICAST_ADDRESS**)arg3);
    default:
        ASSERT(0);
    }
    return NO_ERROR;
}


/*******************************************************************************
 * ForEachIPv6Address
 *
 * This routine walks a set of IPv6 addresses and invokes a given function
 * on each one.
 *
 * ENTRY    IF     - IPv6 interface information
 *          func   - Function to invoke on each address
 *          arg1   - Argument to pass to func
 *          arg2   - Argument to pass to func
 *          arg3   - Argument to pass to func
 *          Flags  - Flags to pass to func
 *          Family - Address family constraint (for DNS server addresses)
 *
 * EXIT     Nothing
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD ForEachIPv6Address(IPV6_INFO_INTERFACE *IF, DWORD (*func)(IPV6_INFO_INTERFACE *,IPV6_INFO_ADDRESS *, PVOID, PVOID, PVOID, DWORD, DWORD), PVOID arg1, PVOID arg2, PVOID arg3, DWORD Flags, DWORD Family)
{
    IPV6_QUERY_ADDRESS Query;
    IPV6_INFO_ADDRESS ADE;
    u_int BytesReturned, BytesIn;
    DWORD dwErr;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    for (;;) {
        BytesIn = sizeof Query;
        BytesReturned = sizeof ADE;

        dwErr = WsControl( IPPROTO_IPV6,
                           IOCTL_IPV6_QUERY_ADDRESS,
                           &Query, &BytesIn,
                           &ADE, &BytesReturned);

        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {

            dwErr = (*func)(IF, &ADE, arg1, arg2, arg3, Flags, Family);
            if (dwErr != NO_ERROR) {
                return dwErr;
            }
        }

        if (IN6_ADDR_EQUAL(&ADE.Next.Address, &in6addr_any))
            break;
        Query = ADE.Next;
    }

    return NO_ERROR;
}

/*******************************************************************************
 * MapIpv4AddressToName
 *
 * This routine finds the name and description of the adapter which
 * has a given IPv4 address on it.
 *
 * ENTRY    pAdapterInfo - Buffer obtained from GetAdaptersInfo
 *          Ipv4Address  - IPv4 address to search for
 *          pDescription - Where to place a pointer to the description text
 *
 * EXIT     pDescription updated, if found
 *
 * RETURNS  Adapter name, or NULL if not found
 *
 ******************************************************************************/

LPSTR
MapIpv4AddressToName(IP_ADAPTER_INFO *pAdapterInfo, DWORD Ipv4Address, PCHAR *pDescription)
{
    IP_ADAPTER_INFO *pAdapter;
    IP_ADDR_STRING  *pAddr;

    for (pAdapter = pAdapterInfo;
         pAdapter != NULL;
         pAdapter = pAdapter->Next) {

        for (pAddr = &pAdapter->IpAddressList; pAddr; pAddr=pAddr->Next) {
            if (inet_addr(pAddr->IpAddress.String) == Ipv4Address) {
                *pDescription = pAdapter->Description;
                return pAdapter->AdapterName;
            }
        }
    }

    return NULL;
}

#define GUID_FORMAT_A   "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"

/*******************************************************************************
 * ConvertGuidToStringA
 *
 * This routine converts a GUID to a character string.
 *
 * ENTRY    pGuid     - Contains the GUID to translate.
 *          pszBuffer - Space for storing the string.  
 *                      Must be >= 39 * sizeof(CHAR).
 *
 * EXIT     pszBuffer updated
 *
 * RETURNS  Whatever sprintf returns
 *
 ******************************************************************************/

DWORD
ConvertGuidToStringA(GUID *pGuid, PCHAR pszBuffer)
{
    return sprintf(pszBuffer,
                   GUID_FORMAT_A,
                   pGuid->Data1,
                   pGuid->Data2,
                   pGuid->Data3,
                   pGuid->Data4[0],
                   pGuid->Data4[1],
                   pGuid->Data4[2],
                   pGuid->Data4[3],
                   pGuid->Data4[4],
                   pGuid->Data4[5],
                   pGuid->Data4[6],
                   pGuid->Data4[7]);
}

/*******************************************************************************
 * ConvertStringToGuidA
 *
 * This routine converts a character string to a GUID.
 *
 * ENTRY    pszGuid   - Contains the string to translate
 *          pGuid     - Space for storing the GUID
 *
 * EXIT     pGuid updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD
ConvertStringToGuidA(PCHAR pszGuid, GUID *pGuid)
{
    UNICODE_STRING  Temp;
    WCHAR wszGuid[40+1];

    MultiByteToWideChar(CP_ACP, 0, pszGuid, -1, wszGuid, 40);

    RtlInitUnicodeString(&Temp, wszGuid);
    if(RtlGUIDFromString(&Temp, pGuid) != STATUS_SUCCESS)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

/*******************************************************************************
 * MapGuidToAdapterName
 *
 * This routine gets an adapter name and description, given a GUID.
 *
 * ENTRY    pAdapterInfo    - Buffer obtained from GetAdaptersInfo
 *          Guid            - GUID of the adapter
 *          pwszDescription - Buffer in which to place description text.
 *                            Must be at least MAX_ADAPTER_DESCRIPTION_LENGTH
 *                            WCHAR's long.
 *
 * EXIT     pwszDescription buffer filled in, if found
 *
 * RETURNS  Adapter name, or NULL if not found
 *
 ******************************************************************************/

LPSTR
MapGuidToAdapterName(IP_ADAPTER_INFO *pAdapterInfo, GUID *Guid, PWCHAR pwszDescription)
{
    IP_ADAPTER_INFO *pAdapter;
    CHAR  szGuid[40];

    ConvertGuidToStringA(Guid, szGuid);

    for (pAdapter = pAdapterInfo;
         pAdapter != NULL;
         pAdapter = pAdapter->Next) {

        if (!strcmp(szGuid, pAdapter->AdapterName)) {
            MultiByteToWideChar(CP_ACP, 0, pAdapter->Description, -1,
                                pwszDescription, 
                                MAX_ADAPTER_DESCRIPTION_LENGTH);
            return pAdapter->AdapterName;
        }
    }

    pwszDescription[0] = L'\0';
    return NULL;
}

/*******************************************************************************
 * AddDnsServerAddressInfo
 *
 * This routine adds an IP_ADAPTER_DNS_SERVER_ADDRESS entry for an address
 * to a list of entries.
 *
 * ENTRY    IF     - interface information
 *          Addr   - Address in sockaddr format
 *          AddrLen- Size of sockaddr
 *          pFirst - First DNS server entry
 *          ppNext - Previous DNS server entry's "next" pointer to update
 *
 * EXIT     Entry added and args updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddDnsServerAddressInfo(PIP_ADAPTER_DNS_SERVER_ADDRESS **ppNext, LPSOCKADDR Addr, ULONG AddrLen)
{
    DWORD dwErr = NO_ERROR;
    PIP_ADAPTER_DNS_SERVER_ADDRESS pCurr;
    LPSOCKADDR pAddr;

    pCurr = MALLOC(sizeof(IP_ADAPTER_DNS_SERVER_ADDRESS));
    if (!pCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = MALLOC(AddrLen);
    if (!pAddr) {
        FREE(pCurr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(pAddr, Addr, AddrLen);

    // Add address to linked list
    **ppNext = pCurr;
    *ppNext = &pCurr->Next;

    pCurr->Next = NULL;
    pCurr->Length = sizeof(IP_ADAPTER_DNS_SERVER_ADDRESS);
    pCurr->Address.iSockaddrLength = AddrLen;
    pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;

    return dwErr;
}

/*******************************************************************************
 * GetAdapterDnsServers
 *
 * This routine reads a list of DNS server addresses from a registry key.
 *
 * ENTRY    TcpipKey - Registry key to look under
 *          pCurr    - Interface entry to add servers to
 *
 * EXIT     Entry updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD
GetAdapterDnsServers(HKEY TcpipKey, PIP_ADAPTER_ADDRESSES pCurr)
{
    DWORD Size, Type, dwErr, i;
    CHAR Servers[800], *Str;
    PIP_ADAPTER_DNS_SERVER_ADDRESS pD, *ppDNext;
    ADDRINFO hints, *ai;
    static LONG Initialized = FALSE;

    if (InterlockedExchange(&Initialized, TRUE) == FALSE) {
        WSADATA WsaData;

        dwErr = WSAStartup(MAKEWORD(2, 0), &WsaData);
        if (NO_ERROR != dwErr) {
            return dwErr;
        }
    } 

    //
    // Read DNS Server addresses.
    //
    Size = sizeof(Servers);
    ZeroMemory(Servers, Size);
    dwErr = RegQueryValueExA(TcpipKey, (LPSTR)"NameServer", NULL, &Type,
                             (LPBYTE)Servers, &Size);
    if (NO_ERROR != dwErr) {
        if (ERROR_FILE_NOT_FOUND != dwErr) {
            return dwErr;
        }
        Size = 0;
        Type = REG_SZ;
    }

    if (REG_SZ != Type) {
        return ERROR_INVALID_DATA;
    }
    if ((0 == Size) || (0 == strlen(Servers))) {
        Size = sizeof(Servers);
        dwErr = RegQueryValueExA(TcpipKey, (LPSTR)"DhcpNameServer", NULL,
                                 &Type, (LPBYTE)Servers, &Size);
        if (NO_ERROR != dwErr) {
            if (ERROR_FILE_NOT_FOUND != dwErr) {
                return dwErr;
            }
            Size = 0;
            Type = REG_SZ;
        }
    }

    //
    // If there are any DNS Servers, convert them to sockaddrs
    //
    ZeroMemory(&hints, sizeof(hints));
    hints.ai_flags = AI_NUMERICHOST;
    ppDNext = &pCurr->FirstDnsServerAddress;
    while (*ppDNext) {
        ppDNext = &(*ppDNext)->Next;
    }
    if ((0 != Size) && strlen(Servers)) {
        for (i = 0; i < Size; i ++) {
            if (Servers[i] == ' ' || Servers[i] == ','
                || Servers[i] == ';') {
                Servers[i] = '\0';
            }
        }
        Servers[Size] = '\0';

        for (Str = (LPSTR)Servers;
             *Str != '\0';
             Str += strlen(Str) + 1)
        {
            if (getaddrinfo(Str, NULL, &hints, &ai) == NO_ERROR) {
                AddDnsServerAddressInfo(&ppDNext, ai->ai_addr, ai->ai_addrlen);
            }
        }
    }

    return NO_ERROR;
}

/*******************************************************************************
 * GetAdapterDnsInfo
 *
 * This routine reads DNS configuration information for an interface.
 *
 * ENTRY    dwFamily - Address family constraint
 *          name     - Adapter name
 *          pCurr    - Interface entry to update
 *          AppFlags - Flags controlling what fields to skip, if any
 *
 * EXIT     Entry updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD
GetAdapterDnsInfo(DWORD dwFamily, char *name, PIP_ADAPTER_ADDRESSES pCurr, DWORD AppFlags)
{
    WCHAR Buffer[MAX_DOMAIN_NAME_LEN+1];
    DWORD dwErr = NO_ERROR, Size, Type, Value;
    DWORD DnsSuffixSize = sizeof(Buffer);
    HKEY TcpipKey = NULL;
    PIP_ADAPTER_DNS_SERVER_ADDRESS DnsServerAddr;
    LPSOCKADDR_IN6 Sockaddr;

    Buffer[0] = L'\0';
    pCurr->DnsSuffix = NULL;
    pCurr->Flags = IP_ADAPTER_DDNS_ENABLED;

    if (name == NULL) {
        //
        // If we couldn't find an adapter name, just use the default settings.
        // 
        goto Done;
    } 

    do {
        if (!OpenAdapterKey(KEY_TCP, name, KEY_READ, &TcpipKey)) {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        //
        // Get DnsSuffix for the interface
        //
        Size = DnsSuffixSize;
        dwErr = RegQueryValueExW(TcpipKey, (LPWSTR)L"Domain", NULL, &Type,
                                 (LPBYTE)Buffer, &Size );
        if (NO_ERROR != dwErr) {
            if (ERROR_FILE_NOT_FOUND != dwErr) {
                break;
            }

            Size = 0;
            Type = REG_SZ;
        }

        if (REG_SZ != Type) {
            dwErr = ERROR_INVALID_DATA;
            break;
        }
        if ((0 == Size) || (0 == wcslen(Buffer))) {
            Size = DnsSuffixSize;
            dwErr = RegQueryValueExW(TcpipKey, (LPWSTR)L"DhcpDomain", NULL,
                                     &Type, (LPBYTE)Buffer, &Size );
            if (NO_ERROR != dwErr) {
                if (ERROR_FILE_NOT_FOUND != dwErr) {
                    break;
                }

                Size = 0;
                Buffer[0] = L'\0';
            }
        }

        if (MyReadRegistryDword(TcpipKey, "RegistrationEnabled",
                &Value) && (Value == 0)) {
            pCurr->Flags &= ~IP_ADAPTER_DDNS_ENABLED;
        }
        if (MyReadRegistryDword(TcpipKey,
                "RegisterAdapterName", &Value)
                && Value) {
            pCurr->Flags |= IP_ADAPTER_REGISTER_ADAPTER_SUFFIX;
        }

        //
        // Now attempt to read the DnsServers list
        //
        if (!(AppFlags & GAA_FLAG_SKIP_DNS_SERVER)) {
            if ((dwFamily != AF_INET) && bIp6DriverInstalled) {
                //
                // First look for IPv6 servers.
                //
                HKEY Tcpip6Key = NULL;
    
                if (OpenAdapterKey(KEY_TCP6, name, KEY_READ, &Tcpip6Key)) {
                    GetAdapterDnsServers(Tcpip6Key, pCurr);
                    RegCloseKey(Tcpip6Key);
                } 
    
                if (pCurr->FirstDnsServerAddress == NULL) {
                    //
                    // None are configured, so use the default list of
                    // well-known addresses.
                    //
                    SOCKADDR_IN6 Addr;
                    PIP_ADAPTER_DNS_SERVER_ADDRESS *ppDNext;
                    BYTE i;
    
                    ZeroMemory(&Addr, sizeof(Addr));
    
                    Addr.sin6_family = AF_INET6;
                    Addr.sin6_addr.s6_words[0] = 0xC0FE;
                    Addr.sin6_addr.s6_words[3] = 0xFFFF;
    
                    ppDNext = &pCurr->FirstDnsServerAddress;
                    while (*ppDNext) {
                        ppDNext = &(*ppDNext)->Next;
                    }
                    for (i=1; i<=3; i++) {
                        Addr.sin6_addr.s6_bytes[15] = i;
                        AddDnsServerAddressInfo(&ppDNext, (LPSOCKADDR)&Addr, sizeof(Addr));
                    }
                }
    
                // Now we need to go through any non-global IPv6 DNS server 
                // addresses and fill in the scope id.
                for (DnsServerAddr = pCurr->FirstDnsServerAddress;
                     DnsServerAddr;
                     DnsServerAddr = DnsServerAddr->Next) {
            
                    if (DnsServerAddr->Address.lpSockaddr->sa_family != AF_INET6)
                        continue;
                
                    Sockaddr = (LPSOCKADDR_IN6)DnsServerAddr->Address.lpSockaddr;
                    if (IN6_IS_ADDR_LINKLOCAL(&Sockaddr->sin6_addr))
                        Sockaddr->sin6_scope_id = pCurr->ZoneIndices[ADE_LINK_LOCAL];
                    else if (IN6_IS_ADDR_SITELOCAL(&Sockaddr->sin6_addr))
                        Sockaddr->sin6_scope_id = pCurr->ZoneIndices[ADE_SITE_LOCAL];
                }
            }

            if (dwFamily != AF_INET6) {
                //
                // Finally, add IPv4 servers.
                //
                GetAdapterDnsServers(TcpipKey, pCurr);
            }
        }

    } while (FALSE);

    if (TcpipKey) {
        RegCloseKey(TcpipKey);
    }

Done:
    pCurr->DnsSuffix = MALLOC((wcslen(Buffer)+1) * sizeof(WCHAR));
    if (pCurr->DnsSuffix) {
        wcscpy(pCurr->DnsSuffix, Buffer);
    }

    return dwErr;
}

/*******************************************************************************
 * NewIpAdapter
 *
 * This routine allocates an IP_ADAPTER_ADDRESSES entry and appends it to
 * a list of such entries.
 *
 * ENTRY    ppCurr       - Location in which to return new entry
 *          ppNext       - Previous entry's "next" pointer to update
 *          name         - Adapter name
 *          Ipv4IfIndex  - IPv4 Interface index
 *          Ipv6IfIndex  - IPv6 Interface index
 *          AppFlags     - Flags controlling what fields to skip, if any
 *          IfType       - IANA ifType value
 *          Mtu          - Maximum transmission unit
 *          PhysAddr     - MAC address
 *          PhysAddrLen  - Byte count of PhysAddr 
 *          Description  - Adapter description
 *          FriendlyName - User-friendly interface name
 *          Family       - Address family constraint for DNS servers
 *
 * EXIT     ppCurr and ppNext updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD NewIpAdapter(PIP_ADAPTER_ADDRESSES *ppCurr, PIP_ADAPTER_ADDRESSES **ppNext, char *AdapterName, char *NameForDnsInfo, UINT Ipv4IfIndex, UINT Ipv6IfIndex, DWORD AppFlags, DWORD IfType, SIZE_T Mtu, BYTE *PhysAddr, DWORD PhysAddrLen, PWCHAR Description, PWCHAR FriendlyName, DWORD *ZoneIndices, DWORD Family)
{
    DWORD i;

    *ppCurr = MALLOC(sizeof(IP_ADAPTER_ADDRESSES));
    if (!*ppCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(*ppCurr, sizeof(IP_ADAPTER_ADDRESSES));
    (*ppCurr)->AdapterName = MALLOC(strlen(AdapterName)+1);
    if (!(*ppCurr)->AdapterName) {
        goto Fail;
    }
    (*ppCurr)->Description = MALLOC((wcslen(Description)+1) * sizeof(WCHAR));
    if (!(*ppCurr)->Description) {
        goto Fail;
    }
    (*ppCurr)->FriendlyName = MALLOC((wcslen(FriendlyName)+1) * sizeof(WCHAR));
    if (!(*ppCurr)->FriendlyName) {
        goto Fail;
    }

    (*ppCurr)->Next = NULL;
    (*ppCurr)->Length = sizeof(IP_ADAPTER_ADDRESSES);
    strcpy((*ppCurr)->AdapterName, AdapterName);
    (*ppCurr)->IfIndex = Ipv4IfIndex;
    (*ppCurr)->Ipv6IfIndex = Ipv6IfIndex;
    (*ppCurr)->FirstUnicastAddress = NULL;
    (*ppCurr)->FirstAnycastAddress = NULL;
    (*ppCurr)->FirstMulticastAddress = NULL;
    (*ppCurr)->FirstDnsServerAddress = NULL;
    (*ppCurr)->OperStatus = IfOperStatusUp;

    CopyMemory((*ppCurr)->ZoneIndices, ZoneIndices, ADE_GLOBAL * sizeof(DWORD));
    (*ppCurr)->ZoneIndices[ADE_GLOBAL] = 0;
    (*ppCurr)->ZoneIndices[ADE_LARGEST_SCOPE] = 0;

    //(*ppCurr)->Mtu = Mtu;	"dword should be enough for MTU"
    (*ppCurr)->Mtu = (DWORD)Mtu;

    (*ppCurr)->IfType = IfType;
    (*ppCurr)->PhysicalAddressLength = PhysAddrLen;
    memcpy((*ppCurr)->PhysicalAddress, PhysAddr, PhysAddrLen);
    wcscpy((*ppCurr)->Description, Description);
    wcscpy((*ppCurr)->FriendlyName, FriendlyName);

    GetAdapterDnsInfo(Family, 
                      (NameForDnsInfo != NULL)? NameForDnsInfo : AdapterName, 
                      *ppCurr, AppFlags);
    if ((*ppCurr)->DnsSuffix == NULL) {
        goto Fail;
    }

    **ppNext = *ppCurr;
    *ppNext = &(*ppCurr)->Next;

    return NO_ERROR;

Fail:
    if ((*ppCurr)->AdapterName) {
        FREE((*ppCurr)->AdapterName);
    }
    if ((*ppCurr)->FriendlyName) {
        FREE((*ppCurr)->FriendlyName);
    }
    if ((*ppCurr)->Description) {
        FREE((*ppCurr)->Description);
    }
    FREE(*ppCurr);
    return ERROR_NOT_ENOUGH_MEMORY;
}

/*******************************************************************************
 * FindOrCreateIpAdapter
 *
 * This routine finds an existing IP_ADAPTER_ADDRESSES entry (if any), or 
 * creates a new one and appends it to a list of such entries.
 *
 * ENTRY    pFirst       - Pointer to start of list to search
 *          ppCurr       - Location in which to return new entry
 *          ppNext       - Previous entry's "next" pointer to update
 *          name         - Adapter name
 *          Ipv4IfIndex  - IPv4 Interface index
 *          Ipv6IfIndex  - IPv6 Interface index
 *          AppFlags     - Flags controlling what fields to skip, if any
 *          IfType       - IANA ifType value
 *          Mtu          - Maximum transmission unit
 *          PhysAddr     - MAC address
 *          PhysAddrLen  - Byte count of PhysAddr
 *          Description  - Adapter description
 *          FriendlyName - User-friendly interface name
 *          Family       - Address family constraint (for DNS servers)
 *
 * EXIT     ppCurr and ppNext updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD FindOrCreateIpAdapter(PIP_ADAPTER_ADDRESSES pFirst, PIP_ADAPTER_ADDRESSES *ppCurr, PIP_ADAPTER_ADDRESSES **ppNext, char *AdapterName, char *NameForDnsInfo, UINT Ipv4IfIndex, UINT Ipv6IfIndex, DWORD AppFlags, DWORD IfType, SIZE_T Mtu, BYTE *PhysAddr, DWORD PhysAddrLen, PWCHAR Description, PWCHAR FriendlyName, DWORD *ZoneIndices, DWORD Family)
{
    PIP_ADAPTER_ADDRESSES pIf;
    DWORD dwErr;

    // Look for an existing entry for the GUID.
    for (pIf = pFirst; pIf; pIf = pIf->Next) {
        if (!strcmp(AdapterName, pIf->AdapterName)) {
            if (Ipv4IfIndex != 0) {
                ASSERT(pIf->IfIndex == 0);
                pIf->IfIndex = Ipv4IfIndex;
            }
            if (Ipv6IfIndex != 0) {
                ASSERT(pIf->Ipv6IfIndex == 0);
                pIf->Ipv6IfIndex = Ipv6IfIndex;

                CopyMemory(pIf->ZoneIndices, ZoneIndices, 
                           ADE_GLOBAL * sizeof(DWORD));
            }
            *ppCurr = pIf;
            return NO_ERROR;
        }
    }

    return NewIpAdapter(ppCurr, ppNext, AdapterName, NameForDnsInfo, 
                        Ipv4IfIndex, Ipv6IfIndex, AppFlags, IfType, Mtu, 
                        PhysAddr, PhysAddrLen, Description, FriendlyName, 
                        ZoneIndices, Family);
}

__inline int IN6_IS_ADDR_6TO4(const struct in6_addr *a)
{
    return ((a->s6_bytes[0] == 0x20) && (a->s6_bytes[1] == 0x02));
}

__inline int IN6_IS_ADDR_ISATAP(const struct in6_addr *a)
{
    return (((a->s6_words[4] & 0xfffd) == 0) && (a->s6_words[5] == 0xfe5e));
}

//
// This array is used to convert from an internal IPv6 interface type value,
// as defined in ntddip6.h, to an IANA ifType value as defined in ipifcons.h.
//
DWORD
IPv6ToMibIfType[] = {
    IF_TYPE_SOFTWARE_LOOPBACK,
    IF_TYPE_ETHERNET_CSMACD,
    IF_TYPE_FDDI,
    IF_TYPE_TUNNEL,
    IF_TYPE_TUNNEL,
    IF_TYPE_TUNNEL,
    IF_TYPE_TUNNEL,
    IF_TYPE_TUNNEL
};
#define NUM_IPV6_IFTYPES (sizeof(IPv6ToMibIfType)/sizeof(DWORD))

/*******************************************************************************
 * AddIPv6Prefix
 *
 * This routine adds an IP_ADAPTER_PREFIX entry for an IPv6 prefix
 * to a list of entries.
 *
 * ENTRY    Addr     - IPv6 prefix (network byte order)
 *          MaskLen  - IPv6 prefix length
 *          arg1     - Initial prefix entry, for duplicate avoidance
 *          arg2     - Previous prefix entry's "next" pointer to update
 *
 * EXIT     Entry added and arg2 updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv6Prefix(IN6_ADDR *Addr, DWORD MaskLen, PVOID arg1, PVOID arg2)
{
    PIP_ADAPTER_PREFIX pFirst = *(PIP_ADAPTER_PREFIX*)arg1;
    PIP_ADAPTER_PREFIX **ppNext = (PIP_ADAPTER_PREFIX**)arg2;
    PIP_ADAPTER_PREFIX pCurr;
    LPSOCKADDR_IN6 pAddr;

    // Check if already in the list
    for (pCurr = pFirst; pCurr; pCurr = pCurr->Next) {
        if ((pCurr->PrefixLength == MaskLen) &&
            (pCurr->Address.lpSockaddr->sa_family == AF_INET6) &&
            IN6_ADDR_EQUAL(&((LPSOCKADDR_IN6)pCurr->Address.lpSockaddr)->sin6_addr, Addr)) {
            return NO_ERROR;
        }
    }

    pCurr = MALLOC(sizeof(IP_ADAPTER_PREFIX));
    if (!pCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = MALLOC(sizeof(SOCKADDR_IN6));
    if (!pAddr) {
        FREE(pCurr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(pAddr, 0, sizeof(SOCKADDR_IN6));
    pAddr->sin6_family = AF_INET6;
    pAddr->sin6_addr = *Addr;

    // Add address to linked list
    **ppNext = pCurr;
    *ppNext = &pCurr->Next;

    pCurr->Length = sizeof(IP_ADAPTER_PREFIX);
    pCurr->Flags = 0;
    pCurr->Next = NULL;
    pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;
    pCurr->Address.iSockaddrLength = sizeof(SOCKADDR_IN6);
    pCurr->PrefixLength = MaskLen;

    return NO_ERROR;
}

/*******************************************************************************
 * AddIPv6AutoAddressInfo
 *
 * This routine adds an IP_ADAPTER_UNICAST_ADDRESS entry for an IPv6 address
 * on an "automatic tunnel" interface to a list of entries.
 *
 * ENTRY    IF     - IPv6 interface information
 *          ADE    - IPv6 address entry
 *          arg1   - Previous entry's "next" pointer to update
 *          arg2   - Adapter info structure
 *          arg3   - "First" entry pointer to update
 *          Flags  - flags specified by application
 *          Family - Address family constraint (for DNS)
 *
 * EXIT     Entry added and arg1 updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv6AutoAddressInfo(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, PVOID arg1, PVOID arg2, PVOID arg3, DWORD Flags, DWORD Family)
{
    PIP_ADAPTER_ADDRESSES **ppNext = (PIP_ADAPTER_ADDRESSES**)arg1;
    IP_ADAPTER_INFO        *pAdapterInfo = (IP_ADAPTER_INFO *)arg2;
    PIP_ADAPTER_ADDRESSES   pCurr, *ppFirst = (PIP_ADAPTER_ADDRESSES*)arg3;
    PIP_ADAPTER_UNICAST_ADDRESS    *pNextUnicastAddr;
    PIP_ADAPTER_ANYCAST_ADDRESS    *pNextAnycastAddr;
    PIP_ADAPTER_MULTICAST_ADDRESS  *pNextMulticastAddr;
    PIP_ADAPTER_PREFIX             *pNextPrefix;
    CHAR szGuid[80];
    char *NameForDnsInfo, *pszDescription;
    DWORD Ipv4Address, dwErr, dwIfType;
    WCHAR wszFriendlyName[MAX_FRIENDLY_NAME_LENGTH+1], *pwszDescription;
    ULONG PrefixLength = 64;
    IN6_ADDR Prefix;

    if (ADE->Type != ADE_UNICAST) {
        return NO_ERROR;
    }

    ConvertGuidToStringA(&IF->This.Guid, szGuid);

    //
    // We need the GUID ("NameForDnsInfo") of an interface which we
    // can use to find additional relevant configuration information.
    // For IPv6 pseudo-interfaces, we'll extract the IPv4 address, and
    // find the GUID of the interface it's on, and use that, which assumes
    // that configuration information (e.g. the DNS server to use) will
    // still apply.
    //
    if (IF->Type == IPV6_IF_TYPE_TUNNEL_6TO4) {
        if (IN6_IS_ADDR_6TO4(&ADE->This.Address)) {
            // Extract IPv4 address from middle of IPv6 address
            memcpy(&Ipv4Address, &ADE->This.Address.s6_bytes[2], sizeof(Ipv4Address));
        } else {
            return NO_ERROR;
        }
        pwszDescription = L"6to4 Tunneling Pseudo-Interface";
    } else {
        if (IN6_IS_ADDR_V4COMPAT(&ADE->This.Address) ||
            IN6_IS_ADDR_ISATAP(&ADE->This.Address)) {

            // Extract IPv4 address from last 4 bytes of IPv6 address
            memcpy(&Ipv4Address, &ADE->This.Address.s6_bytes[12], sizeof(Ipv4Address));
        } else {
            return NO_ERROR;
        }
        pwszDescription = L"Automatic Tunneling Pseudo-Interface";

        if (IN6_IS_ADDR_V4COMPAT(&ADE->This.Address)) {
            PrefixLength = 96;
        }
    }

    // Look for an existing interface with same physical address and index.
    for (pCurr = *ppFirst; pCurr; pCurr = pCurr->Next) {
        if ((pCurr->Ipv6IfIndex == ADE->This.IF.Index) &&
            (*(DWORD*)pCurr->PhysicalAddress == Ipv4Address)) {
            break;
        }
    }

    if (pCurr == NULL) {
        // Add an interface
        NameForDnsInfo = MapIpv4AddressToName(pAdapterInfo, Ipv4Address, 
                                              &pszDescription);
        if (NameForDnsInfo == NULL) {
            return NO_ERROR;
        }

        wcscpy(wszFriendlyName, pwszDescription);

        dwIfType = (IF->Type < NUM_IPV6_IFTYPES)? IPv6ToMibIfType[IF->Type] 
                                                : MIB_IF_TYPE_OTHER;

        dwErr =  NewIpAdapter(&pCurr, ppNext, szGuid, NameForDnsInfo, 
                              0, ADE->This.IF.Index, Flags, dwIfType, 
                              IF->LinkMTU, (BYTE*)&Ipv4Address, 
                              sizeof(Ipv4Address), pwszDescription, 
                              wszFriendlyName, IF->ZoneIndices, Family);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        // 6to4 and automatic tunneling interfaces don't support multicast 
        // today.
        pCurr->Flags |= IP_ADAPTER_NO_MULTICAST;

        if (*ppFirst == NULL) {
            *ppFirst = pCurr;
        }
    }

    // Add the address to the interface
    pNextUnicastAddr = &pCurr->FirstUnicastAddress;
    while (*pNextUnicastAddr) {
        pNextUnicastAddr = &(*pNextUnicastAddr)->Next;
    }

    pNextAnycastAddr = &pCurr->FirstAnycastAddress;
    while (*pNextAnycastAddr) {
        pNextAnycastAddr = &(*pNextAnycastAddr)->Next;
    }

    pNextMulticastAddr = &pCurr->FirstMulticastAddress;
    while (*pNextMulticastAddr) {
        pNextMulticastAddr = &(*pNextMulticastAddr)->Next;
    }

    dwErr = AddIPv6AddressInfo(IF, ADE, &pNextUnicastAddr, &pNextAnycastAddr,
                               &pNextMulticastAddr, Flags, Family);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    // Add the prefix to the interface
    if (Flags & GAA_FLAG_INCLUDE_PREFIX) {
        ZeroMemory(&Prefix, sizeof(Prefix));
        CopyMemory(&Prefix, &ADE->This.Address, PrefixLength / 8);
        pNextPrefix = &pCurr->FirstPrefix;
        while (*pNextPrefix) {
            pNextPrefix = &(*pNextPrefix)->Next;
        }
        dwErr = AddIPv6Prefix(&Prefix, PrefixLength, &pCurr->FirstPrefix, 
                              &pNextPrefix);
    }

    return dwErr;
}

/*******************************************************************************
 * GetString
 *
 * This routine reads a string value from the registry.
 *
 * ENTRY    hKey     - Handle to registry key
 *          lpName   - Name of value to read
 *          pwszBuff - Buffer in which to place value read
 *          ulBytes  - Size of buffer
 *
 * EXIT     pwszBuff filled in
 *
 * RETURNS  TRUE on success, FALSE on failure
 *
 ******************************************************************************/

BOOL
GetString(HKEY hKey, LPCWSTR lpName, PWCHAR pwszBuff, SIZE_T ulBytes)
{
    DWORD dwErr, dwType;
    ULONG ulSize, ulValue;
    WCHAR buff[NI_MAXHOST];

    ulSize = sizeof(ulValue);
    dwErr = RegQueryValueExW(hKey, lpName, NULL, &dwType, (PBYTE)pwszBuff,
                             (LPDWORD)&ulBytes);

    if (dwErr != ERROR_SUCCESS) {
        return FALSE;
    }

    if (dwType != REG_SZ) {
        return FALSE;
    }

    return TRUE;
}

BOOL MapAdapterNameToFriendlyName(GUID *Guid, char *name, PWCHAR pwszFriendlyName, ULONG ulNumChars)
{
    DWORD dwErr, dwTemp;

    dwTemp = ulNumChars;

    //
    // The following call can be time-consuming the first time it is called.
    // If the caller doesn't need the friendly name, it should use the
    // GAA_FLAG_SKIP_FRIENDLY_NAME flag, in which case we won't get called.
    //
    dwErr = HrLanConnectionNameFromGuidOrPath(Guid, NULL, pwszFriendlyName, 
                                              &dwTemp);
    if (dwErr == NO_ERROR) {
        return TRUE;
    }

    dwTemp = ulNumChars;

    dwErr = NhGetInterfaceNameFromDeviceGuid(Guid, pwszFriendlyName, &dwTemp, 
                                             TRUE, FALSE );
    if (dwErr == NO_ERROR) {
        return TRUE;
    }

    MultiByteToWideChar(CP_ACP, 0, name, -1, pwszFriendlyName, ulNumChars);

    return FALSE;
}

#define KEY_TCPIP6_IF L"System\\CurrentControlSet\\Services\\Tcpip6\\Parameters\\Interfaces"

VOID MapIpv6AdapterNameToFriendlyName(GUID *Guid, char *name, PWCHAR pwszFriendlyName, ULONG ulBytes)
{
    DWORD dwErr;
    HKEY  hInterfaces = NULL, hIf = NULL;
    CHAR  szGuid[40];

    if (MapAdapterNameToFriendlyName(Guid, name, pwszFriendlyName, 
                                       ulBytes/sizeof(WCHAR))) {
        return;
    }

    dwErr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, KEY_TCPIP6_IF, 0, GENERIC_READ,
                          &hInterfaces);
    if (dwErr != NO_ERROR) {
        goto Fail;
    }

    dwErr = RegOpenKeyEx(hInterfaces, name, 0, GENERIC_READ, &hIf);
    if (dwErr != NO_ERROR) {
        goto Fail;
    }

    if (GetString(hIf, L"FriendlyName", pwszFriendlyName, ulBytes)) {
        goto Cleanup;
    }

Fail:
    ConvertGuidToStringA(Guid, szGuid);
    MultiByteToWideChar(CP_ACP, 0, szGuid, -1,
                        pwszFriendlyName, ulBytes / sizeof(WCHAR));
    
Cleanup:
    if (hInterfaces) {
        RegCloseKey(hInterfaces);
    }
    if (hIf) {
        RegCloseKey(hIf);
    }
}

IN6_ADDR Ipv6LinkLocalPrefix = { 0xfe, 0x80 };

/*******************************************************************************
 * ForEachIPv6Prefix
 *
 * This routine walks the IPv6 routing table and invokes a given function
 * on each prefix on a given interface.
 *
 * ENTRY    Ipv6IfIndex - IPv6 interface index
 *          func - Function to invoke on each address
 *          arg1 - Argument to pass to func
 *          arg2 - Argument to pass to func
 *
 * EXIT     Nothing
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD ForEachIPv6Prefix(ULONG Ipv6IfIndex, DWORD (*func)(IN6_ADDR *, DWORD, PVOID, PVOID), PVOID arg1, PVOID arg2)
{
    IPV6_QUERY_ROUTE_TABLE Query, NextQuery;
    IPV6_INFO_ROUTE_TABLE RTE;
    DWORD BytesIn, BytesReturned, dwCount = 0;
    ULONG MaskLen, dwErr = NO_ERROR;
    BOOL SawLinkLocal = FALSE;

    ZeroMemory(&NextQuery, sizeof(NextQuery));

    for (;;) {
        Query = NextQuery;

        BytesIn = sizeof Query;
        BytesReturned = sizeof RTE;
        dwErr = WsControl(IPPROTO_IPV6, 
                          IOCTL_IPV6_QUERY_ROUTE_TABLE,
                          &Query, &BytesIn,
                          &RTE, &BytesReturned);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        NextQuery = RTE.Next;
        RTE.This = Query;

        // Skip if it's not an onlink prefix for this interface.
        if ((RTE.This.Neighbor.IF.Index == Ipv6IfIndex) &&
            !IN6_IS_ADDR_MULTICAST(&RTE.This.Prefix)) {

            if (IN6_IS_ADDR_LINKLOCAL(&RTE.This.Prefix)) {
                // This interface has link-local addresses
                // (the 6to4 interface, for example, does not).
                SawLinkLocal = TRUE;
            }

            if ((RTE.Type != RTE_TYPE_SYSTEM) && 
                IN6_IS_ADDR_UNSPECIFIED(&RTE.This.Neighbor.Address)) {

                dwErr = func(&RTE.This.Prefix, RTE.This.PrefixLength, 
                             arg1, arg2);
                if (dwErr != NO_ERROR) {
                    return dwErr;
                }
            }
        }

        if (NextQuery.Neighbor.IF.Index == 0) {
            break;
        }
    }

    if (SawLinkLocal) {
        dwErr = func(&Ipv6LinkLocalPrefix, 64, arg1, arg2);
    }

    return dwErr;
}

//
// This array is used to convert from an internal IPv6 media status value,
// as defined in ntddip6.h, to a MIB ifOperStatus value as defined in 
// iptypes.h.
//
DWORD
IPv6ToMibOperStatus[] = {
    IfOperStatusDown, // IPV6_IF_MEDIA_STATUS_DISCONNECTED
    IfOperStatusUp,   // IPV6_IF_MEDIA_STATUS_RECONNECTED
    IfOperStatusUp,   // IPV6_IF_MEDIA_STATUS_CONNECTED
};
#define NUM_IPV6_MEDIA_STATUSES (sizeof(IPv6ToMibOperStatus)/sizeof(DWORD))

#define IPV6_LOOPBACK_NAME L"Loopback Pseudo-Interface"
#define IPV6_TEREDO_NAME L"Teredo Tunneling Pseudo-Interface"

/*******************************************************************************
 * AddIPv6InterfaceInfo
 *
 * This routine adds an IP_ADAPTER_ADDRESSES entry for an IPv6 interface
 * to a list of such entries.
 *
 * ENTRY    IF           - IPv6 interface information
 *          arg1         - Previous entry's "next" pointer to update
 *          arg2         - Pointer to start of interface list
 *          pAdapterInfo - Additional adapter information
 *          Flags        - Flags specified by application
 *          Family       - Address family constraint (for DNS servers)
 *
 * EXIT     Entry added and arg1 updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv6InterfaceInfo(IPV6_INFO_INTERFACE *IF, PVOID arg1, PVOID arg2, IP_ADAPTER_INFO *pAdapterInfo, DWORD Flags, DWORD Family)
{
    DWORD dwErr = NO_ERROR;
    PIP_ADAPTER_ADDRESSES **ppNext = (PIP_ADAPTER_ADDRESSES**)arg1;
    PIP_ADAPTER_ADDRESSES pFirst = *(PIP_ADAPTER_ADDRESSES*)arg2;
    PIP_ADAPTER_ADDRESSES pCurr;
    PIP_ADAPTER_UNICAST_ADDRESS *pNextUnicastAddr;
    PIP_ADAPTER_ANYCAST_ADDRESS *pNextAnycastAddr;
    PIP_ADAPTER_MULTICAST_ADDRESS *pNextMulticastAddr;
    PIP_ADAPTER_PREFIX *pNextPrefix;
    char *NameForDnsInfo = NULL, *pszDescription;
    u_char *LinkLayerAddress;
    DWORD Ipv4Address, dwIfType;
    WCHAR wszDescription[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
    WCHAR wszFriendlyName[MAX_FRIENDLY_NAME_LENGTH + 1];
    CHAR AdapterName[MAX_ADAPTER_NAME_LENGTH + 1];

    LinkLayerAddress = (u_char *)(IF + 1);

    ConvertGuidToStringA(&IF->This.Guid, AdapterName);

    //
    // Get a description and adapter name.
    //
    switch (IF->Type) {
    case IPV6_IF_TYPE_TUNNEL_6TO4:
        wcscpy(wszDescription, L"6to4 Pseudo-Interface");
        NameForDnsInfo = AdapterName;
        pCurr = NULL;
        dwErr = ForEachIPv6Address(IF, AddIPv6AutoAddressInfo,
                                   ppNext, pAdapterInfo, (PVOID)&pCurr, Flags,
                                   Family);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        //
        // Ensure that there exists an entry for the 6to4 interface.
        //
        if (pCurr == NULL) {
            dwErr = NewIpAdapter(&pCurr, ppNext, AdapterName,
                                 NameForDnsInfo, 0, IF->This.Index, Flags,
                                 IF_TYPE_TUNNEL, IF->LinkMTU,
                                 LinkLayerAddress, IF->LinkLayerAddressLength,
                                 wszDescription, wszDescription,
                                 IF->ZoneIndices, Family);
        }

        return dwErr;

    case IPV6_IF_TYPE_TUNNEL_AUTO:
        wcscpy(wszDescription, L"Automatic Tunneling Pseudo-Interface");
        NameForDnsInfo = AdapterName;
        pCurr = NULL;
        dwErr = ForEachIPv6Address(IF, AddIPv6AutoAddressInfo,
                                   ppNext, pAdapterInfo, (PVOID)&pCurr, Flags,
                                   Family);

        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        //
        // Ensure that there exists an entry for the ISATAP interface.
        //
        if (pCurr == NULL) {
            dwErr = NewIpAdapter(&pCurr, ppNext, AdapterName,
                                 NameForDnsInfo, 0, IF->This.Index, Flags,
                                 IF_TYPE_TUNNEL, IF->LinkMTU,
                                 LinkLayerAddress, IF->LinkLayerAddressLength,
                                 wszDescription, wszDescription,
                                 IF->ZoneIndices, Family);
        }

        return dwErr;

    case IPV6_IF_TYPE_TUNNEL_6OVER4:
        wcscpy(wszDescription, L"6over4 Pseudo-Interface");
        memcpy(&Ipv4Address, LinkLayerAddress, sizeof(Ipv4Address));
        NameForDnsInfo = MapIpv4AddressToName(pAdapterInfo, Ipv4Address, &pszDescription);
        if (NameForDnsInfo == NULL) {
            //
            // IPv4 address does not exist, so just use the interface GUID.
            //
            NameForDnsInfo = AdapterName;
        }
        break;

    case IPV6_IF_TYPE_TUNNEL_V6V4:
        wcscpy(wszDescription, L"Configured Tunnel Interface");
        memcpy(&Ipv4Address, LinkLayerAddress, sizeof(Ipv4Address));
        NameForDnsInfo = MapIpv4AddressToName(pAdapterInfo, Ipv4Address, &pszDescription);
        if (NameForDnsInfo == NULL) {
            //
            // IPv4 address does not exist, so just use the interface GUID.
            //
            NameForDnsInfo = AdapterName;
        }
        break;

    case IPV6_IF_TYPE_TUNNEL_TEREDO:
        wcscpy(wszDescription, IPV6_TEREDO_NAME);
        NameForDnsInfo = AdapterName;
        break;
        
    case IPV6_IF_TYPE_LOOPBACK:
        wcscpy(wszDescription, IPV6_LOOPBACK_NAME);
        NameForDnsInfo = AdapterName;
        break;

    default:
        NameForDnsInfo = MapGuidToAdapterName(pAdapterInfo,
                                              &IF->This.Guid,
                                              wszDescription);
        if (NameForDnsInfo != NULL) {
            strcpy(AdapterName, NameForDnsInfo);
        }
    }

    if (Flags & GAA_FLAG_SKIP_FRIENDLY_NAME) {
        wszFriendlyName[0] = L'\0';
    } else if (IF->Type == IPV6_IF_TYPE_TUNNEL_TEREDO) {
        //
        // The Teredo interface does not have a friendly name.
        //
        wcscpy(wszFriendlyName, IPV6_TEREDO_NAME);
    } else if (IF->Type == IPV6_IF_TYPE_LOOPBACK) {
        //
        // The IPv6 loopback interface will not have a friendly name,
        // so use the same string as the description we set above.
        //
        wcscpy(wszFriendlyName, IPV6_LOOPBACK_NAME);
    } else {
        MapIpv6AdapterNameToFriendlyName(&IF->This.Guid, AdapterName, 
                                         wszFriendlyName, 
                                         sizeof(wszFriendlyName));
    }

    dwIfType = (IF->Type < NUM_IPV6_IFTYPES)? IPv6ToMibIfType[IF->Type] 
                                            : MIB_IF_TYPE_OTHER;

    dwErr = FindOrCreateIpAdapter(pFirst, &pCurr, ppNext, AdapterName, 
                                  NameForDnsInfo, 0, IF->This.Index, Flags, 
                                  dwIfType, IF->LinkMTU, LinkLayerAddress, 
                                  IF->LinkLayerAddressLength, wszDescription, 
                                  wszFriendlyName, IF->ZoneIndices, Family);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (IF->OtherStatefulConfig != 0) {
        pCurr->Flags |= IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG;
    }

    pCurr->OperStatus = (IF->MediaStatus < NUM_IPV6_MEDIA_STATUSES)
                            ? IPv6ToMibOperStatus[IF->MediaStatus] 
                            : IfOperStatusUnknown;

    // Add addresses
    pNextUnicastAddr = &pCurr->FirstUnicastAddress;
    while (*pNextUnicastAddr) {
        pNextUnicastAddr = &(*pNextUnicastAddr)->Next;
    }

    pNextAnycastAddr = &pCurr->FirstAnycastAddress;
    while (*pNextAnycastAddr) {
        pNextAnycastAddr = &(*pNextAnycastAddr)->Next;
    }

    pNextMulticastAddr = &pCurr->FirstMulticastAddress;
    while (*pNextMulticastAddr) {
        pNextMulticastAddr = &(*pNextMulticastAddr)->Next;
    }

    dwErr = ForEachIPv6Address(IF, AddIPv6AddressInfo, &pNextUnicastAddr,
                               &pNextAnycastAddr, &pNextMulticastAddr, Flags,
                               Family);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    // Add prefixes
    if (Flags & GAA_FLAG_INCLUDE_PREFIX) {
        pNextPrefix = &pCurr->FirstPrefix;
        while (*pNextPrefix) {
            pNextPrefix = &(*pNextPrefix)->Next;
        }

        dwErr = ForEachIPv6Prefix(IF->This.Index, AddIPv6Prefix, 
                                  &pCurr->FirstPrefix, &pNextPrefix);
    }

    return dwErr;
}

#define MAX_LINK_LEVEL_ADDRESS_LENGTH   64

/*******************************************************************************
 * ForEachIPv6Interface
 *
 * This routine walks a set of IPv6 interfaces and invokes a given function
 * on each one.
 *
 * ENTRY    func         - Function to invoke on each interface
 *          arg1         - Argument to pass to func
 *          arg2         - Argument to pass to func
 *          pAdapterInfo - List of adapter information
 *          Flags        - Flags to pass to func
 *          Family       - Address family constraint (for DNS servers)
 *
 * EXIT     Nothing
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD ForEachIPv6Interface(DWORD (*func)(IPV6_INFO_INTERFACE *, PVOID, PVOID, IP_ADAPTER_INFO *, DWORD, DWORD), PVOID arg1, PVOID arg2, IP_ADAPTER_INFO *pAdapterInfo, DWORD Flags, DWORD Family)
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned, BytesIn;
    DWORD dwErr;

    InfoSize = sizeof *IF + 2 * MAX_LINK_LEVEL_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MALLOC(InfoSize);
    if (IF == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Query.Index = (u_int) -1;

    for (;;) {
        BytesIn = sizeof Query;
        BytesReturned = InfoSize;

        dwErr = WsControl( IPPROTO_IPV6,
                           IOCTL_IPV6_QUERY_INTERFACE,
                           &Query, &BytesIn,
                           IF, &BytesReturned);

        if (dwErr != NO_ERROR) {
            if (dwErr == ERROR_FILE_NOT_FOUND) {
                // IPv6 is not installed
                dwErr = NO_ERROR;
            }
            break;
        }

        if (Query.Index != (u_int) -1) {

            if ((BytesReturned < sizeof *IF) ||
                (IF->Length < sizeof *IF) ||
                (BytesReturned != IF->Length +
                 ((IF->LocalLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0) +
                 ((IF->RemoteLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0))) {

                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            dwErr = (*func)(IF, arg1, arg2, pAdapterInfo, Flags, Family);
            if (dwErr != NO_ERROR) {
                break;
            }
        }

        if (IF->Next.Index == (u_int) -1)
            break;
        Query = IF->Next;
    }

    FREE(IF);

    return dwErr;
}

//
// IPv4 equivalents of some standard IN6_* macros
//
#define IN_IS_ADDR_LOOPBACK(x)  (*(x) == INADDR_LOOPBACK)
#define IN_IS_ADDR_LINKLOCAL(x) ((*(x) & 0x0000ffff) == 0x0000fea9)

/*******************************************************************************
 * AddIPv4MulticastAddressInfo
 *
 * This routine adds an IP_ADAPTER_MULTICAST_ADDRESS entry for an IPv4 address
 * to a list of entries.
 *
 * ENTRY    IF     - interface information
 *          Addr   - IPv4 address
 *          pFirst - First multicast entry
 *          ppNext - Previous multicast entry's "next" pointer to update
 *
 * EXIT     Entry added and args updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv4MulticastAddressInfo(IP_ADAPTER_INFO *IF, DWORD Addr, PIP_ADAPTER_MULTICAST_ADDRESS *pFirst, PIP_ADAPTER_MULTICAST_ADDRESS **ppNext)
{
    DWORD dwErr = NO_ERROR;
    PIP_ADAPTER_MULTICAST_ADDRESS pCurr;
    SOCKADDR_IN *pAddr;

    for (pCurr=*pFirst; pCurr; pCurr=pCurr->Next) {
        pAddr = (SOCKADDR_IN *)pCurr->Address.lpSockaddr;
        if (pAddr->sin_family == AF_INET
         && pAddr->sin_addr.s_addr == Addr) {
            return NO_ERROR;
        }
    }

    pCurr = MALLOC(sizeof(IP_ADAPTER_MULTICAST_ADDRESS));
    if (!pCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = MALLOC(sizeof(SOCKADDR_IN));
    if (!pAddr) {
        FREE(pCurr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(pAddr, 0, sizeof(SOCKADDR_IN));
    pAddr->sin_family = AF_INET;
    pAddr->sin_addr.s_addr = Addr;

    // Add address to linked list
    **ppNext = pCurr;
    *ppNext = &pCurr->Next;

    pCurr->Next = NULL;
    pCurr->Length = sizeof(IP_ADAPTER_MULTICAST_ADDRESS);
    pCurr->Flags = 0;
    pCurr->Address.iSockaddrLength = sizeof(SOCKADDR_IN);
    pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;

    return dwErr;
}


/*******************************************************************************
 * AddIPv4UnicastAddressInfo
 *
 * This routine adds an IP_ADAPTER_UNICAST_ADDRESS entry for an IPv4 address
 * to a list of entries.
 *
 * ENTRY    IF   - IPv4 interface information
 *          ADE  - IPv4 address entry
 *          arg1 - Previous unicast entry's "next" pointer to update
 *          arg2 - Initial multicast entry, for duplicate avoidance
 *          arg3 - Previous multicast entry's "next" pointer to update
 *          AppFlags - Flags specified by application
 *
 * EXIT     Entry added and arg1 updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv4UnicastAddressInfo(IP_ADAPTER_INFO *IF, MIB_IPADDRROW *ADE, PVOID arg1, PVOID arg2, PVOID arg3, PVOID arg4, DWORD AppFlags)
{
    PIP_ADAPTER_UNICAST_ADDRESS **ppNext = (PIP_ADAPTER_UNICAST_ADDRESS**)arg1;
    PIP_ADAPTER_UNICAST_ADDRESS pCurr;
    SOCKADDR_IN *pAddr;
    DWORD Address, *pIfFlags = (DWORD *)arg4;
    time_t Curtime;
    DWORD dwStatus = NO_ERROR, i;

    Address = ADE->dwAddr;
    if (!Address) {
        // Do nothing if address is 0.0.0.0
        return NO_ERROR;
    }

    if ((Address & 0x000000FF) == 0) {
        //
        // An address in 0/8 isn't a real IP address, it's a fake one that 
        // the IPv4 stack sticks on a receive-only adapter.
        //
        (*pIfFlags) |= IP_ADAPTER_RECEIVE_ONLY;
        return NO_ERROR;
    }

    if (!(AppFlags & GAA_FLAG_SKIP_UNICAST)) {
        pCurr = MALLOC(sizeof(IP_ADAPTER_UNICAST_ADDRESS));
        if (!pCurr) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pAddr = MALLOC(sizeof(SOCKADDR_IN));
        if (!pAddr) {
            FREE(pCurr);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memset(pAddr, 0, sizeof(SOCKADDR_IN));
        pAddr->sin_family = AF_INET;
        memcpy(&pAddr->sin_addr, &Address, sizeof(Address));

        // Add address to linked list
        **ppNext = pCurr;
        *ppNext = &pCurr->Next;

        time(&Curtime);

        pCurr->Next = NULL;
        pCurr->Length = sizeof(IP_ADAPTER_UNICAST_ADDRESS);
        pCurr->LeaseLifetime = (ULONG)(IF->LeaseExpires - Curtime);
        pCurr->ValidLifetime = pCurr->PreferredLifetime = pCurr->LeaseLifetime;
        pCurr->Flags = 0;
        pCurr->Address.iSockaddrLength = sizeof(SOCKADDR_IN);
        pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;

        pCurr->PrefixOrigin =  IpPrefixOriginManual;
        pCurr->SuffixOrigin =  IpSuffixOriginManual;
        if (IF->DhcpEnabled) {
            if (IN_IS_ADDR_LINKLOCAL(&Address)) {
                pCurr->PrefixOrigin = IpPrefixOriginWellKnown;
                pCurr->SuffixOrigin = IpSuffixOriginRandom;
            } else {
                pCurr->PrefixOrigin = IpPrefixOriginDhcp;
                pCurr->SuffixOrigin = IpSuffixOriginDhcp;
            }
        }
        pCurr->DadState = IpDadStatePreferred;

        if ((pCurr->DadState == IpDadStatePreferred) &&
            (pCurr->SuffixOrigin != IpSuffixOriginRandom) &&
            !IN_IS_ADDR_LOOPBACK(&Address) &&
            !IN_IS_ADDR_LINKLOCAL(&Address)) {
            pCurr->Flags |= IP_ADAPTER_ADDRESS_DNS_ELIGIBLE;
        }

        if (ADE->wType & MIB_IPADDR_TRANSIENT) {
            pCurr->Flags |= IP_ADAPTER_ADDRESS_TRANSIENT;
        }
    }

    // Now add any new multicast addresses
    if (!(AppFlags & GAA_FLAG_SKIP_MULTICAST)) {
        DWORD *pIgmpList = NULL;
        DWORD dwTotal, dwOutBufLen = 0;

        dwStatus = GetIgmpList(Address, pIgmpList, &dwOutBufLen);

        if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {
            pIgmpList = MALLOC(dwOutBufLen);
            if (!pIgmpList) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            dwStatus = GetIgmpList(Address, pIgmpList, &dwOutBufLen);
        }

        if (dwStatus != NO_ERROR) {
            if (pIgmpList) {
                FREE(pIgmpList);
            }
            return dwStatus;
        }

        dwTotal = dwOutBufLen/sizeof(Address);

        for (i=0; (i<dwTotal) && (dwStatus == NO_ERROR); i++) {
            dwStatus = AddIPv4MulticastAddressInfo(IF, pIgmpList[i],
                                    (PIP_ADAPTER_MULTICAST_ADDRESS *)arg2,
                                    (PIP_ADAPTER_MULTICAST_ADDRESS **)arg3);
        }

        if (pIgmpList) {
            FREE(pIgmpList);
        }
    }

    return dwStatus;
}

/*******************************************************************************
 * ForEachIPv4Address
 *
 * This routine walks a set of IPv4 addresses and invokes a given function
 * on each one.
 *
 * ENTRY    IF   - IPv4 interface information
 *          func - Function to invoke on each address
 *          arg1 - Argument to pass to func
 *          arg2 - Argument to pass to func
 *          arg3 - Argument to pass to func
 *          Flags - Flags to pass to func
 *          pIpAddrTable - IPv4 address table with per-address flags
 *
 * EXIT     Nothing
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD ForEachIPv4Address(IP_ADAPTER_INFO *IF, DWORD (*func)(IP_ADAPTER_INFO *,PMIB_IPADDRROW, PVOID, PVOID, PVOID, PVOID, DWORD), PVOID arg1, PVOID arg2, PVOID arg3, PVOID arg4, DWORD Flags, PMIB_IPADDRTABLE pIpAddrTable)
{
    DWORD dwErr, i;
    PMIB_IPADDRROW ADE;

    for (i=0; i<pIpAddrTable->dwNumEntries; i++) {
        ADE = &pIpAddrTable->table[i];
        if (ADE->dwIndex != IF->Index) {
            continue;
        }

        dwErr = (*func)(IF, ADE, arg1, arg2, arg3, arg4, Flags);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }
    }

    return NO_ERROR;
}

DWORD
MaskToMaskLen(
    DWORD dwMask
    )
{
    register int i;

    for (i=0; i<32 && !(dwMask & (1<<i)); i++);

    return 32-i;
}

/*******************************************************************************
 * AddIPv4Prefix
 *
 * This routine adds an IP_ADAPTER_PREFIX entry for an IPv4 prefix
 * to a list of entries.
 *
 * ENTRY    IF       - IPv4 interface information
 *          Addr     - IPv4 prefix (network byte order)
 *          MaskLen  - IPv4 prefix length
 *          arg1     - Initial prefix entry, for duplicate avoidance
 *          arg2     - Previous prefix entry's "next" pointer to update
 *
 * EXIT     Entry added and arg2 updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv4Prefix(DWORD Addr, DWORD MaskLen, PVOID arg1, PVOID arg2)
{
    PIP_ADAPTER_PREFIX pFirst = *(PIP_ADAPTER_PREFIX*)arg1;
    PIP_ADAPTER_PREFIX **ppNext = (PIP_ADAPTER_PREFIX**)arg2;
    PIP_ADAPTER_PREFIX pCurr;
    LPSOCKADDR_IN pAddr;

    // Check if already in the list
    for (pCurr = pFirst; pCurr; pCurr = pCurr->Next) {
        if ((pCurr->PrefixLength == MaskLen) &&
            (pCurr->Address.lpSockaddr->sa_family == AF_INET) &&
            (((LPSOCKADDR_IN)pCurr->Address.lpSockaddr)->sin_addr.s_addr == Addr)) {
            return NO_ERROR;
        }
    }

    pCurr = MALLOC(sizeof(IP_ADAPTER_PREFIX));
    if (!pCurr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = MALLOC(sizeof(SOCKADDR_IN));
    if (!pAddr) {
        FREE(pCurr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(pAddr, 0, sizeof(SOCKADDR_IN));
    pAddr->sin_family = AF_INET;
    pAddr->sin_addr.s_addr = Addr;

    // Add address to linked list
    **ppNext = pCurr;
    *ppNext = &pCurr->Next;
    
    pCurr->Length = sizeof(IP_ADAPTER_PREFIX);
    pCurr->Flags = 0;
    pCurr->Next = NULL;
    pCurr->Address.lpSockaddr = (LPSOCKADDR)pAddr;
    pCurr->Address.iSockaddrLength = sizeof(SOCKADDR_IN);
    pCurr->PrefixLength = MaskLen;

    return NO_ERROR;
}

/*******************************************************************************
 * ForEachIPv4Prefix
 *
 * This routine walks a set of IPv4 prefixes and invokes a given function
 * on each one.
 *
 * ENTRY    IF   - IPv4 interface information
 *          func - Function to invoke on each address
 *          arg1 - Argument to pass to func
 *          arg2 - Argument to pass to func
 *
 * EXIT     Nothing
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD ForEachIPv4Prefix(IP_ADAPTER_INFO *IF, DWORD (*func)(DWORD, DWORD, PVOID, PVOID), PVOID arg1, PVOID arg2)
{
    PIP_ADDR_STRING Prefix;
    DWORD Addr, Mask, MaskLen, dwErr;
    
    for (Prefix = &IF->IpAddressList; Prefix; Prefix = Prefix->Next) {
        if (Prefix->IpAddress.String[0] == '\0') {
            continue;
        }
        Mask = inet_addr(Prefix->IpMask.String);
        Addr = inet_addr(Prefix->IpAddress.String) & Mask;
        MaskLen = MaskToMaskLen(ntohl(Mask));

        dwErr = func(Addr, MaskLen, arg1, arg2);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }
    }

    return NO_ERROR;
}


//
// This array is used to convert from an internal IPv4 oper status value,
// as defined in ipifcons.h, to a MIB ifOperStatus value as defined in
// iptypes.h.
//
DWORD
IPv4ToMibOperStatus[] = {
    IfOperStatusDown,    // IF_OPER_STATUS_NON_OPERATIONAL
    IfOperStatusDown,    // IF_OPER_STATUS_UNREACHABLE
    IfOperStatusDormant, // IF_OPER_STATUS_DISCONNECTED
    IfOperStatusDormant, // IF_OPER_STATUS_CONNECTING
    IfOperStatusUp,      // IF_OPER_STATUS_CONNECTED
    IfOperStatusUp,      // IF_OPER_STATUS_OPERATIONAL
};
#define NUM_IPV4_OPER_STATUSES (sizeof(IPv4ToMibOperStatus)/sizeof(DWORD))

/*******************************************************************************
 * AddIPv4InterfaceInfo
 *
 * This routine adds an IP_ADAPTER_ADDRESSES entry for an IPv4 interface
 * to a list of such entries.
 *
 * ENTRY    IF         - IPv4 interface information
 *          arg1       - Previous entry's "next" pointer to update
 *          arg2       - Pointer to start of interface list
 *          Flags      - Flags controlling what fields to skip, if any
 *          Family     - Address family constraint (for DNS server addresses)
 *          pAddrTable - IPv4 address table
 *
 * EXIT     Entry added and arg updated
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD AddIPv4InterfaceInfo(IP_ADAPTER_INFO *IF, PVOID arg1, PVOID arg2, DWORD Flags, DWORD Family, PMIB_IPADDRTABLE pAddrTable)
{
    DWORD dwErr = NO_ERROR, i;
    PIP_ADAPTER_ADDRESSES **ppNext = (PIP_ADAPTER_ADDRESSES**)arg1;
    PIP_ADAPTER_ADDRESSES pFirst = *(PIP_ADAPTER_ADDRESSES*)arg2;
    PIP_ADAPTER_ADDRESSES pCurr;
    PIP_ADAPTER_UNICAST_ADDRESS *pNextUAddr;
    PIP_ADAPTER_MULTICAST_ADDRESS *pNextMAddr;
    PIP_ADAPTER_PREFIX *pNextPrefix;
    WCHAR wszDescription[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
    WCHAR wszFriendlyName[MAX_FRIENDLY_NAME_LENGTH + 1];
    MIB_IFROW IfEntry;
    GUID Guid;
    DWORD ZoneIndices[ADE_NUM_SCOPES];

    MultiByteToWideChar(CP_ACP, 0, IF->Description, -1,
                        wszDescription, MAX_ADAPTER_DESCRIPTION_LENGTH);

    //
    // Get information which isn't in IP_ADAPTER_INFO.
    //
    dwErr = GetIfEntryFromStack(&IfEntry, IF->Index, FALSE);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (ConvertStringToGuidA(IF->AdapterName, &Guid) != NO_ERROR) {
        ZeroMemory(&Guid, sizeof(Guid));
    }

    //
    // Fill in some dummy zone indices.
    //
    ZoneIndices[0] = ZoneIndices[1] = ZoneIndices[2] = ZoneIndices[3] = IF->Index;
    for (i=ADE_ADMIN_LOCAL; i<ADE_NUM_SCOPES; i++) {
        ZoneIndices[i] = 1;
    } 

    if (Flags & GAA_FLAG_SKIP_FRIENDLY_NAME) {
        wszFriendlyName[0] = L'\0';
    } else {
        MapAdapterNameToFriendlyName(&Guid, IF->AdapterName, wszFriendlyName, 
                                     MAX_FRIENDLY_NAME_LENGTH);
    }

    dwErr = FindOrCreateIpAdapter(pFirst, &pCurr, ppNext, IF->AdapterName, 
                         IF->AdapterName, IF->Index, 0, Flags,
                         IF->Type, IfEntry.dwMtu, IF->Address, 
                         IF->AddressLength, wszDescription, wszFriendlyName,
                         ZoneIndices, Family);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    pCurr->OperStatus = (IfEntry.dwOperStatus < NUM_IPV4_OPER_STATUSES)
                            ? IPv4ToMibOperStatus[IfEntry.dwOperStatus] 
                            : IfOperStatusUnknown;
    if (IF->DhcpEnabled) {
        pCurr->Flags |= IP_ADAPTER_DHCP_ENABLED;
    }

    // Add addresses
    pNextUAddr = &pCurr->FirstUnicastAddress;
    pNextMAddr = &pCurr->FirstMulticastAddress;
    dwErr = ForEachIPv4Address(IF, AddIPv4UnicastAddressInfo, &pNextUAddr,
                               pNextMAddr, &pNextMAddr, &pCurr->Flags,
                               Flags, pAddrTable);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    // Add prefixes
    if (Flags & GAA_FLAG_INCLUDE_PREFIX) {
        pNextPrefix = &pCurr->FirstPrefix;
        dwErr = ForEachIPv4Prefix(IF, AddIPv4Prefix, &pCurr->FirstPrefix, 
                                  &pNextPrefix);
    }

    return dwErr;
}

IP_ADAPTER_INFO IPv4LoopbackInterfaceInfo = {
    NULL,                        // Next
    1,                           // ComboIndex
    "MS TCP Loopback interface", // AdapterName
    "MS TCP Loopback interface", // Description
    0,                           // Address Length
    {0},                         // Address
    1,                           // Index
    MIB_IF_TYPE_LOOPBACK,        // Type
    FALSE,                       // DhcpEnabled
    NULL,                        // CurrentIpAddress,
    {NULL},                      // IpAddressList,
    {NULL},                      // GatewayList,
    {NULL},                      // DhcpServer,
    FALSE,                       // HaveWins 
    {NULL},                      // PrimaryWinsServer,
    {NULL},                      // SecondaryWinsServer,
    0,                           // LeaseObtained
    0                            // LeaseExpires
};

/*******************************************************************************
 * ForEachIPv4Interface
 *
 * This routine walks a set of IPv4 interfaces and invokes a given function
 * on each one.
 *
 * ENTRY    func         - Function to invoke on each interface
 *          arg1         - Argument to pass to func
 *          arg2         - Argument to pass to func
 *          pAdapterInfo - List of IPv4 interfaces
 *          Flags        - Flags to pass to func
 *          Family       - Address family constraint (for DNS server addresses)
 *
 * EXIT     Nothing
 *
 * RETURNS  Error status
 *
 ******************************************************************************/

DWORD ForEachIPv4Interface(DWORD (*func)(IP_ADAPTER_INFO *, PVOID, PVOID, DWORD, DWORD, PMIB_IPADDRTABLE), PVOID arg1, PVOID arg2, IP_ADAPTER_INFO *pAdapterInfo, DWORD Flags, DWORD Family, PMIB_IPADDRTABLE pIpAddrTable)
{
    PIP_ADAPTER_INFO IF;
    DWORD dwErr;

    //
    // The IPv4 loopback interface is missing from the pAdapterInfo list,
    // so we special case it here.
    //
    dwErr = (*func)(&IPv4LoopbackInterfaceInfo, arg1, arg2, Flags, Family, 
                    pIpAddrTable);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    for (IF=pAdapterInfo; IF; IF=IF->Next) {
        dwErr = (*func)(IF, arg1, arg2, Flags, Family, pIpAddrTable);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }
    }

    return NO_ERROR;
}

DWORD GetAdapterAddresses(ULONG Family, DWORD Flags, PIP_ADAPTER_ADDRESSES *pAddresses)
{
    IP_ADAPTER_INFO *pAdapterInfo = NULL;
    PIP_ADAPTER_ADDRESSES adapterList, *pCurr;
    DWORD dwErr = NO_ERROR;
    PMIB_IPADDRTABLE pIpAddrTable = NULL;

    TRACE_PRINT(("Entered GetAdapterAddresses\n"));

    pAdapterInfo = GetAdapterInfo();

    *pAddresses = adapterList = NULL;
    pCurr = &adapterList;
    //
    // If we want to return IPv6 DNS servers, find out now whether the
    // IPv6 stack is installed.
    //
    if ((Family != AF_INET) && !(Flags & GAA_FLAG_SKIP_DNS_SERVER)) {
        IPV6_GLOBAL_PARAMETERS Params;
        u_int BytesReturned = sizeof(Params);
        DWORD InputBufferLength = 0;

        dwErr = WsControl(IPPROTO_IPV6,
                          IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS,
                          NULL, &InputBufferLength,
                          &Params, &BytesReturned);

        bIp6DriverInstalled = (dwErr == NO_ERROR);
        dwErr = NO_ERROR;
    }

    if ((Family == AF_UNSPEC) || (Family == AF_INET)) {
        DWORD dwSize = 0;

        //
        // GetAdapterInfo alone isn't sufficient since it doesn't get
        // per-address flags whereas GetIpAddrTable does.
        // GetIpAddrTable doesn't get per-interface info however,
        // so this is why we have to do both.  We use pAdapterInfo
        // for per-interface info and pIpAddrTable for
        // per-address info.
        //
        dwErr = GetIpAddrTable(NULL, &dwSize, TRUE);
        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {
            pIpAddrTable = MALLOC(dwSize);
            if (!pIpAddrTable) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            dwErr = GetIpAddrTable(pIpAddrTable, &dwSize, TRUE);
        }
        if (dwErr != NO_ERROR) {
            goto Cleanup;
        }

        dwErr = ForEachIPv4Interface(AddIPv4InterfaceInfo, &pCurr, &adapterList,
                    pAdapterInfo, Flags, Family, pIpAddrTable);
        if (dwErr != NO_ERROR) {
            goto Cleanup;
        }
    }
    if ((Family == AF_UNSPEC) || (Family == AF_INET6)) {
        dwErr = ForEachIPv6Interface(AddIPv6InterfaceInfo, &pCurr, &adapterList,
                    pAdapterInfo, Flags, Family);
        if (dwErr != NO_ERROR) {
            goto Cleanup;
        }
    }
    *pAddresses = adapterList;

Cleanup:
    if (pIpAddrTable) {
        FREE(pIpAddrTable);
    }
    if (pAdapterInfo) {
        KillAdapterInfo(pAdapterInfo);
    }

    TRACE_PRINT(("Exit GetAdapterAddresses %p\n", adapterList));

    return dwErr;
}



/*******************************************************************************
 *
 *  InternalGetPerAdapterInfo
 *
 *  Gets per-adapter special information.
 *
 *  ENTRY   IfIndex
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to the IP_PER_ADAPTER_INFO structure
 *
 *  ASSUMES
 *
 ******************************************************************************/

PIP_PER_ADAPTER_INFO InternalGetPerAdapterInfo(ULONG IfIndex)
{

    PIP_ADAPTER_INFO adapterList;
    PIP_ADAPTER_INFO adapter;
    PIP_PER_ADAPTER_INFO perAdapterInfo = NULL;
    HKEY key;
    BOOL ok;

    TRACE_PRINT(("Entered GetPerAdapterList\n"));

    if ((adapterList = GetAdapterInfo()) != NULL) {

        //
        // scan the adapter list and find one that matches IfIndex
        //

        for (adapter = adapterList; adapter; adapter = adapter->Next) {

            TRACE_PRINT(("GetPerAdapterInfo: '%s'\n", adapter->AdapterName));

            if (adapter->Index == IfIndex &&
                adapter->AdapterName[0] &&
                OpenAdapterKey(KEY_TCP, adapter->AdapterName, KEY_READ, &key)) {

                //
                // found the right adapter so let's fill up the perAdapterInfo
                //

                perAdapterInfo = NEW(IP_PER_ADAPTER_INFO);
                if (perAdapterInfo == NULL) {

                    DEBUG_PRINT(("GetPerAdapterInfo: no memory for perAdapterInfo\n"));
                    KillAdapterInfo(adapterList);
                    RegCloseKey(key);
                    return NULL;
                }

                ZeroMemory(perAdapterInfo, sizeof(IP_PER_ADAPTER_INFO));

                if (!MyReadRegistryDword(key,
                                       TEXT("IPAutoconfigurationEnabled"),
                                       &perAdapterInfo->AutoconfigEnabled)) {

                    //
                    // autoconfig is enabled if no regval exists for this
                    // adapter
                    //

                    perAdapterInfo->AutoconfigEnabled = TRUE;
                    TRACE_PRINT(("IPAutoconfigurationEnabled not read\n"));
                }

                TRACE_PRINT(("IPAutoconfigurationEnableda = %d\n",
                             perAdapterInfo->AutoconfigEnabled));

                if (perAdapterInfo->AutoconfigEnabled) {

                    MyReadRegistryDword(key,
                                      TEXT("AddressType"),
                                      &perAdapterInfo->AutoconfigActive);

                    TRACE_PRINT(("AddressType !%s\n",
                                 perAdapterInfo->AutoconfigActive));
                }

                //
                // DNS Server list: first NameServer and then DhcpNameServer
                //

                ok = ReadRegistryIpAddrString(key,
                                              TEXT("NameServer"),
                                              &perAdapterInfo->DnsServerList);
                if (ok) {
                    TRACE_PRINT(("GetPerAdapterInfo: DhcpNameServer %s\n",
                                 perAdapterInfo->DnsServerList));
                }

                if (!ok) {

                    ok = ReadRegistryIpAddrString(key,
                                                  TEXT("DhcpNameServer"),
                                                  &perAdapterInfo->DnsServerList);
                    if (ok) {
                        TRACE_PRINT(("GetPerAdapterInfo: DhcpNameServer %s\n",
                                     perAdapterInfo->DnsServerList));
                    }
                }

                //
                // we are done so let's exit the loop
                //

                RegCloseKey(key);
                break;

            } else {
                DEBUG_PRINT(("Cannot OpenAdapterKey KEY_TCP '%s', gle=%d\n",
                             adapter->AdapterName,
                             GetLastError()));
            }
        }

        KillAdapterInfo(adapterList);
    } else {
        DEBUG_PRINT(("GetPerAdapterInfo: GetAdapterInfo returns NULL\n"));
    }

    TRACE_PRINT(("Exit GetPerAdapterInfo %p\n", perAdapterInfo));

    return perAdapterInfo;
}



/*******************************************************************************
 *
 *  OpenAdapterKey
 *
 *  Opens one of the 3 per-adapter registry keys:
 *     Tcpip\\Parameters"\<adapter>
 *  or NetBT\Adapters\<Adapter>
 *  or Tcpip6\Paramters\<adapter>
 *
 *  ENTRY   KeyType - KEY_TCP or KEY_NBT or KEY_TCP6
 *          Name    - pointer to adapter name to use
 *          Key     - pointer to returned key
 *
 *  EXIT    Key updated
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *  HISTORY:     MohsinA, 16-May-97. Fixing for PNP.
 *
 ******************************************************************************/

static
BOOL OpenAdapterKey(DWORD KeyType, const LPSTR Name, REGSAM Access, PHKEY Key)
{

    LONG err;
    CHAR keyName[MAX_ADAPTER_NAME_LENGTH + sizeof(TCPIP_PARAMS_INTER_KEY)];

    switch (KeyType) {
    case KEY_TCP:

        //
        // open the handle to this adapter's TCPIP parameter key
        //

        strcpy(keyName, TCPIP_PARAMS_INTER_KEY );
        strcat(keyName, Name);
        break;

    case KEY_TCP6:

        //
        // open the handle to this adapter's TCPIP6 parameter key
        //

        strcpy(keyName, TCPIP6_PARAMS_INTER_KEY );
        strcat(keyName, Name);
        break;

    case KEY_NBT:

        //
        // open the handle to the NetBT\Adapters\<Adapter> handle
        //

        strcpy(keyName, NETBT_ADAPTER_KEY );
        strcat(keyName, Name);
        break;

    default:
        return FALSE;
    }

    TRACE_PRINT(("OpenAdapterKey: %s\n", keyName ));

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, Access, Key );

    if( err != ERROR_SUCCESS ){
        DEBUG_PRINT(("OpenAdapterKey: RegOpenKey %s, err=%d\n",
                     keyName, GetLastError() ));
    }else{
        TRACE_PRINT(("Exit OpenAdapterKey: %s ok\n", keyName ));
    }

    return (err == ERROR_SUCCESS);
}



BOOL WriteRegistryDword(HKEY hKey, LPSTR szParameter, DWORD *pdwValue )
{
    DWORD dwResult;

    TRACE_PRINT(("WriteRegistryDword: %s %d\n", szParameter, *pdwValue ));

    dwResult = RegSetValueEx(
                    hKey,
                    szParameter,
                    0,
                    REG_DWORD,
                    (CONST BYTE *) pdwValue,
                    sizeof( *pdwValue )
                    );

    return ( ERROR_SUCCESS == dwResult );
}

BOOL WriteRegistryMultiString(HKEY hKey,
                         LPSTR szParameter,
                         LPSTR szValue
                         )
{
    DWORD dwResult;
    LPSTR psz;

    for (psz = szValue; *psz; psz += lstrlen(szValue) + 1) { }

    dwResult = RegSetValueEx(
                    hKey,
                    szParameter,
                    0,
                    REG_MULTI_SZ,
                    (CONST BYTE *) szValue,
                    (DWORD)(psz - szValue) + 1
                    );

    return ( ERROR_SUCCESS == dwResult );
}



/*******************************************************************************
 *
 *  MyReadRegistryDword
 *
 *  Reads a registry value that is stored as a DWORD
 *
 *  ENTRY   Key             - open registry key where value resides
 *          ParameterName   - name of value to read from registry
 *          Value           - pointer to returned value
 *
 *  EXIT    *Value = value read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL MyReadRegistryDword(HKEY Key, LPSTR ParameterName, LPDWORD Value)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;

    valueLength = sizeof(*Value);
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)Value,
                          &valueLength
                          );
    if ((err == ERROR_SUCCESS) && (valueType == REG_DWORD) && (valueLength == sizeof(DWORD))) {

        DEBUG_PRINT(("MyReadRegistryDword(%s): val = %d, type = %d, len = %d\n",
                    ParameterName,
                    *Value,
                    valueType,
                    valueLength
                    ));

    } else {

        DEBUG_PRINT(("MyReadRegistryDword(%p,%s): err = %d\n",
                     Key, ParameterName, err));

        err = !ERROR_SUCCESS;
    }

    return (err == ERROR_SUCCESS);
}



// ========================================================================
// Was DWORD IPInterfaceContext, now CHAR NTEContextList[][].
// Reads in a REG_MULTI_SZ and converts it into a list of numbers.
// MohsinA, 21-May-97.
// ========================================================================

// max length of REG_MULTI_SZ.

#define MAX_VALUE 5002

BOOL
ReadRegistryList(HKEY Key, LPSTR ParameterName,
                      DWORD NumList[], int *MaxList
)
{

    LONG  err;
    DWORD valueType;
    BYTE  Value[MAX_VALUE];
    DWORD valueLength = MAX_VALUE;
    int   i = 0, k = 0;

    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL,
                          &valueType,
                          &Value[0],
                          &valueLength
                          );

    if( (        err == ERROR_SUCCESS)   &&
        (  valueType == REG_MULTI_SZ )   &&
        ((valueLength+2) <  MAX_VALUE)
    ){
        TRACE_PRINT(("ReadRegistryList %s ok\n", ParameterName ));
        Value[MAX_VALUE-1] = '\0';
        Value[MAX_VALUE-2] = '\0';

        while( (i < MAX_VALUE) && Value[i] && (k < (*MaxList))  ){
            NumList[k] = strtoul( &Value[i], NULL, 0 );
            TRACE_PRINT(("    NumList[%d] = '%s' => %d\n",
                         k, &Value[i], NumList[k] ));
            k++;
            i += strlen( &Value[i] ) + 1;
        }
        assert( (i < MAX_VALUE) && !Value[i] && (k < MaxList) );
        *MaxList = k;
    }
    else
    {
        *MaxList = 0;
        DEBUG_PRINT(("ReadRegistryList %s failed\n", ParameterName ));
        err = !ERROR_SUCCESS;
    }

    return (err == ERROR_SUCCESS);
}

BOOL
IsIncluded( DWORD Context, DWORD contextlist[], int len_contextlist )
{
    int i;

    for( i = 0; i < len_contextlist; i++ )
    {
        if( Context == contextlist[i] ){
            return TRUE;
        }
    }

    return FALSE;
}



/*******************************************************************************
 *
 *  ReadRegistryString
 *
 *  Reads a registry value that is stored as a string
 *
 *  ENTRY   Key             - open registry key
 *          ParameterName   - name of value to read from registry
 *          String          - pointer to returned string
 *          Length          - IN: length of String buffer. OUT: length of returned string
 *
 *  EXIT    String contains string read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryString(HKEY Key, LPSTR ParameterName, LPSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;

    *String = '\0';
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)String,
                          Length
                          );

    if (err == ERROR_SUCCESS) {

        ASSERT(valueType == REG_SZ || valueType == REG_MULTI_SZ);

        DEBUG_PRINT(("ReadRegistryString(%s): val = \"%s\", type = %d, len = %d\n",
                    ParameterName,
                    String,
                    valueType,
                    *Length
                    ));

    } else {

        DEBUG_PRINT(("ReadRegistryString(%s): err = %d\n", ParameterName, err));

    }

    return ((err == ERROR_SUCCESS) && (*Length > sizeof('\0')));
}



/*******************************************************************************
 *
 *  ReadRegistryOemString
 *
 *  Reads a registry value as a wide character string
 *
 *  ENTRY   Key             - open registry key
 *          ParameterName   - name of value to read from registry
 *          String          - pointer to returned string
 *          Length          - IN: length of String buffer. OUT: length of returned string
 *
 *  EXIT    String contains string read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryOemString(HKEY Key, LPWSTR ParameterName, LPSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    *String = '\0';
    err = RegQueryValueExW(Key,
                           ParameterName,
                           NULL, // reserved
                           &valueType,
                           NULL,
                           &valueLength
                           );
    if ((err == ERROR_SUCCESS) && (valueType == REG_SZ)) {
        if ((valueLength <= *Length) && (valueLength > sizeof(L'\0'))) {

            UNICODE_STRING unicodeString;
            OEM_STRING oemString;
            LPWSTR str = (LPWSTR)GrabMemory(valueLength);

            if (!str) {
                return  FALSE;
            }

            //
            // read the UNICODE string into allocated memory
            //

            err = RegQueryValueExW(Key,
                                   ParameterName,
                                   NULL,
                                   &valueType,
                                   (LPBYTE)str,
                                   &valueLength
                                   );
            if (err == ERROR_SUCCESS) {

                NTSTATUS Status;

                //
                // convert the UNICODE string to OEM character set
                //

                RtlInitUnicodeString(&unicodeString, str);
                Status = RtlUnicodeStringToOemString(&oemString, &unicodeString, TRUE);

                if (NT_SUCCESS(Status)) {
                    strcpy(String, oemString.Buffer);
                    RtlFreeOemString(&oemString);
                } else {
                    err = !ERROR_SUCCESS;
                }

                DEBUG_PRINT(("ReadRegistryOemString(%ws): val = \"%s\", len = %d\n",
                            ParameterName,
                            String,
                            valueLength
                            ));

            } else {

                DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                            ParameterName,
                            err,
                            valueType,
                            valueLength
                            ));

            }
            ReleaseMemory(str);
        } else {

            DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                        ParameterName,
                        err,
                        valueType,
                        valueLength
                        ));

            err = !ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                    ParameterName,
                    err,
                    valueType,
                    valueLength
                    ));

        err = !ERROR_SUCCESS;
    }
    return (err == ERROR_SUCCESS);
}



/*******************************************************************************
 *
 *  ReadRegistryIpAddrString
 *
 *  Reads zero or more IP addresses from a space-delimited string in a registry
 *  parameter and converts them to a list of IP_ADDR_STRINGs
 *
 *  ENTRY   Key             - registry key
 *          ParameterName   - name of value entry under Key to read from
 *          IpAddr          - pointer to IP_ADDR_STRING to update
 *
 *  EXIT    IpAddr updated if success
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryIpAddrString(HKEY Key, LPSTR ParameterName, PIP_ADDR_STRING IpAddr)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;
    LPBYTE valueBuffer;

    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                          );
    if ((err == ERROR_SUCCESS)) {
        if((valueLength > 1) && (valueType == REG_SZ)
           || (valueLength > 2) && (valueType == REG_MULTI_SZ) ) {
            valueBuffer = GrabMemory(valueLength);
            if (!valueBuffer) {
                return  FALSE;
            }
            err = RegQueryValueEx(Key,
                                  ParameterName,
                                  NULL, // reserved
                                  &valueType,
                                  valueBuffer,
                                  &valueLength
            );
            if ((err == ERROR_SUCCESS) && (valueLength > 1)) {

                UINT stringCount;
                LPSTR stringPointer = valueBuffer;
                LPSTR *stringAddress;
                UINT i;

                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): \"%s\", len = %d\n",
                             ParameterName,
                             valueBuffer,
                             valueLength
                ));

                stringAddress = GrabMemory(valueLength / 2 * sizeof(LPSTR));

                if (stringAddress) {
                    if( REG_SZ == valueType ) {
                        stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                        stringAddress[0] = stringPointer;
                        stringCount = 1;
                        while (stringPointer = strpbrk(stringPointer, STRING_ARRAY_DELIMITERS)) {
                            *stringPointer++ = '\0';
                            stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                            stringAddress[stringCount] = stringPointer;
                            if (*stringPointer) {
                                ++stringCount;
                            }
                        }

                        for (i = 0; i < stringCount; ++i) {
                            AddIpAddressString(IpAddr, stringAddress[i], "");
                        }
                    } else if( REG_MULTI_SZ == valueType ) {
                        stringCount = 0;
                        while(strlen(stringPointer)) {
                            AddIpAddressString(IpAddr, stringPointer, "");
                            stringPointer += 1+strlen(stringPointer);
                            stringCount ++;
                        }
                        if( 0 == stringCount ) err = ERROR_PATH_NOT_FOUND;
                    } else {
                        err = ERROR_PATH_NOT_FOUND;
                    }
                    ReleaseMemory(stringAddress);
                } else {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {

                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, len = %d\n",
                             ParameterName,
                             err,
                             valueLength
                ));

                err = ERROR_PATH_NOT_FOUND;
            }
            ReleaseMemory(valueBuffer);
        } else {

            DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, type = %d, len = %d\n",
                         ParameterName,
                         err,
                         valueType,
                         valueLength
            ));

            err = ERROR_PATH_NOT_FOUND;
        }
    }
    return (err == ERROR_SUCCESS);
}



/*******************************************************************************
 *
 *  GetBoundAdapterList
 *
 *  Gets a list of names of all adapters bound to a protocol (TCP/IP). Returns
 *  a pointer to an array of pointers to strings - basically an argv list. The
 *  memory for the strings is concatenated to the array and the array is NULL
 *  terminated. If Elnkii1 and IbmTok2 are bound to TCP/IP then this function
 *  will return:
 *
 *          ---> addr of string1   \
 *               addr of string2    \
 *               NULL                > allocated as one block
 *     &string1: "Elnkii1"          /
 *     &string2: "IbmTok2"         /
 *
 *  ENTRY   BindingsSectionKey
 *              - Open registry handle to a linkage key (e.g. Tcpip\Linkage)
 *
 *  EXIT
 *
 *  RETURNS pointer to argv[] style array, or NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR* GetBoundAdapterList(HKEY BindingsSectionKey)
{

    LONG err;
    DWORD valueType;
    PBYTE valueBuffer;
    DWORD valueLength;
    LPSTR* resultBuffer;
    LPSTR* nextResult;
    int len;
    DWORD resultLength;
    LPSTR nextValue;
    LPSTR variableData;
    DWORD numberOfBindings;

    //
    // get required size of value buffer
    //

    valueLength = 0;
    err = RegQueryValueEx(BindingsSectionKey,
                          TEXT("Bind"),
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        return NULL;
    }
    if (valueType != REG_MULTI_SZ) {
        return NULL;
    }
    if (!valueLength) {
        return NULL;
    }
    valueBuffer = (PBYTE)GrabMemory(valueLength);
    if (!valueBuffer) {
        return NULL;
    }
    err = RegQueryValueEx(BindingsSectionKey,
                          TEXT("Bind"),
                          NULL, // reserved
                          &valueType,
                          valueBuffer,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        DEBUG_PRINT(("GetBoundAdapterList: RegQueryValueEx 'Bind' failed\n"));
        ReleaseMemory(valueBuffer);
        return NULL;
    }
    resultLength = sizeof(LPSTR);   // the NULL at the end of the list
    numberOfBindings = 0;
    nextValue = (LPSTR)valueBuffer;
    while (len = strlen(nextValue)) {
        resultLength += sizeof(LPSTR) + len + 1;
        if (!_strnicmp(nextValue, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            resultLength -= sizeof(DEVICE_PREFIX) - 1;
        }
        nextValue += len + 1;
        ++numberOfBindings;
    }
    resultBuffer = (LPSTR*)GrabMemory(resultLength);
    if (!resultBuffer) {
        return  NULL;
    }
    nextValue = (LPSTR)valueBuffer;
    nextResult = resultBuffer;
    variableData = (LPSTR)(((LPSTR*)resultBuffer) + numberOfBindings + 1);
    while (numberOfBindings--) {

        LPSTR adapterName;

        adapterName = nextValue;
        if (!_strnicmp(adapterName, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            adapterName += sizeof(DEVICE_PREFIX) - 1;
        }
        *nextResult++ = variableData;
        strcpy(variableData, adapterName);
        TRACE_PRINT(("GetBoundAdapterList: adapterName=%s\n", adapterName ));
        while (*variableData) {
            ++variableData;
        }
        ++variableData;
        while (*nextValue) {
            ++nextValue;
        }
        ++nextValue;
    }
    *nextResult = NULL;
    ReleaseMemory(valueBuffer);
    return resultBuffer;
}



/*******************************************************************************
 *
 *  MapNodeType
 *
 *  Converts node type to descriptive string
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS pointer to string
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR MapNodeType(UINT Parm)
{

    DWORD dwParm = LAST_NODE_TYPE + 1;

    //
    // 1, 2, 4, 8 => log2(n) + 1 [1, 2, 3, 4]
    //

    switch (Parm) {
    case 0:

        //
        // according to JStew value of 0 will be treated as BNode (default)
        //

    case BNODE:
        dwParm = 1;
        break;

    case PNODE:
        dwParm = 2;
        break;

    case MNODE:
        dwParm = 3;
        break;

    case HNODE:
        dwParm = 4;
        break;
    }
    if ((dwParm >= FIRST_NODE_TYPE) && (dwParm <= LAST_NODE_TYPE)) {
        return NodeTypes[dwParm].String;
    }

    //
    // if no node type is defined then we default to Hybrid
    //

    return NodeTypes[LAST_NODE_TYPE].String;
}



/*******************************************************************************
 *
 *  MapNodeTypeEx
 *
 *  Converts node type to descriptive string
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS pointer to string
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR MapNodeTypeEx(UINT Parm)
{

    DWORD dwParm = LAST_NODE_TYPE + 1;
    LPSTR Buf;

    Buf = GrabMemory(10);

    if (!Buf) {
        return  NULL;
    }

    //
    // 1, 2, 4, 8 => log2(n) + 1 [1, 2, 3, 4]
    //
    switch (Parm) {
    case 0:

        //
        // according to JStew value of 0 will be treated as BNode (default)
        //

    case BNODE:
        dwParm = 1;
        break;

    case PNODE:
        dwParm = 2;
        break;

    case MNODE:
        dwParm = 3;
        break;

    case HNODE:
        dwParm = 4;
        break;
    }
    if ((dwParm >= FIRST_NODE_TYPE) && (dwParm <= LAST_NODE_TYPE)) {
        strcpy(Buf, NodeTypesEx[dwParm]);
        return Buf;
    }

    //
    // if no node type is defined then we default to Hybrid
    //
    strcpy(Buf, NodeTypesEx[LAST_NODE_TYPE]);
    return Buf;
}



/*******************************************************************************
 *
 *  MapAdapterType
 *
 *  Returns a string describing the type of adapter, based on the type retrieved
 *  from TCP/IP
 *
 *  ENTRY   type    - type of adapter
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to mapped type or pointer to NUL string
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR MapAdapterType(UINT type)
{
    switch (type) {
    case IF_TYPE_OTHER:
        return ADAPTER_TYPE(MI_IF_OTHER);    // ?

    case IF_TYPE_ETHERNET_CSMACD:
        return ADAPTER_TYPE(MI_IF_ETHERNET);

    case IF_TYPE_ISO88025_TOKENRING:
        return ADAPTER_TYPE(MI_IF_TOKEN_RING);

    case IF_TYPE_FDDI:
        return ADAPTER_TYPE(MI_IF_FDDI);

    case IF_TYPE_PPP:
        return ADAPTER_TYPE(MI_IF_PPP);

    case IF_TYPE_SOFTWARE_LOOPBACK:
        return ADAPTER_TYPE(MI_IF_LOOPBACK);

    case IF_TYPE_SLIP:
        return ADAPTER_TYPE(MI_IF_SLIP);
    }
    return "";
}



/*******************************************************************************
 *
 *  MapAdapterTypeEx
 *
 *  Returns a string describing the type of adapter, based on the type retrieved
 *  from TCP/IP
 *
 *  ENTRY   type    - type of adapter
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to mapped type or pointer to NUL string
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR MapAdapterTypeEx(UINT type)
{
    LPSTR    Buf;

    Buf = GrabMemory(12);

    if (!Buf) {
        return  NULL;
    }

    switch (type) {
    case IF_TYPE_OTHER:
        strcpy(Buf, ADAPTER_TYPE_EX(MI_IF_OTHER));    // ?
        return Buf;

    case IF_TYPE_ETHERNET_CSMACD:
        strcpy(Buf, ADAPTER_TYPE_EX(MI_IF_ETHERNET));
        return Buf;

    case IF_TYPE_ISO88025_TOKENRING:
        strcpy(Buf, ADAPTER_TYPE_EX(MI_IF_TOKEN_RING));
        return Buf;

    case IF_TYPE_FDDI:
        strcpy(Buf, ADAPTER_TYPE_EX(MI_IF_FDDI));
        return Buf;

    case IF_TYPE_PPP:
        strcpy(Buf, ADAPTER_TYPE_EX(MI_IF_PPP));
        return Buf;

    case IF_TYPE_SOFTWARE_LOOPBACK:
        strcpy(Buf, ADAPTER_TYPE_EX(MI_IF_LOOPBACK));
        return Buf;

    case IF_TYPE_SLIP:
        strcpy(Buf, ADAPTER_TYPE_EX(MI_IF_SLIP));
        return Buf;
    }
    strcpy(Buf, "");
    return Buf;
}



/*******************************************************************************
 *
 *  MapAdapterAddress
 *
 *  Converts the binary adapter address retrieved from TCP/IP into an ASCII
 *  string. Allows for various conversions based on adapter type. The only
 *  mapping we do currently is basic 6-byte MAC address (e.g. 02-60-8C-4C-97-0E)
 *
 *  ENTRY   pAdapterInfo    - pointer to IP_ADAPTER_INFO containing address info
 *          Buffer          - pointer to buffer where address will be put
 *
 *  EXIT    Buffer  - contains converted address
 *
 *  RETURNS pointer to Buffer
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR MapAdapterAddress(PIP_ADAPTER_INFO pAdapterInfo, LPSTR Buffer)
{

    LPSTR format;
    int separator;
    int len;
    int i;
    LPSTR pbuf = Buffer;
    UINT mask;

    len = min((int)pAdapterInfo->AddressLength, sizeof(pAdapterInfo->Address));

    switch (pAdapterInfo->Type) {
    case IF_TYPE_ETHERNET_CSMACD:
    case IF_TYPE_ISO88025_TOKENRING:
    case IF_TYPE_FDDI:
        format = "%02X";
        mask = 0xff;
        separator = TRUE;
        break;

    default:
        format = "%02x";
        mask = 0xff;
        separator = TRUE;
        break;
    }
    for (i = 0; i < len; ++i) {
        pbuf += sprintf(pbuf, format, pAdapterInfo->Address[i] & mask);
        if (separator && (i != len - 1)) {
            pbuf += sprintf(pbuf, "-");
        }
    }
    return Buffer;
}



/*******************************************************************************
 *
 *  MapTime
 *
 *  Converts IP lease time to more human-sensible string
 *
 *  ENTRY   AdapterInfo - pointer to IP_ADAPTER_INFO owning time variable
 *          TimeVal - DWORD (time_t) time value (number of milliseconds since
 *                    virtual year dot)
 *
 *  EXIT    static buffer updated
 *
 *  RETURNS pointer to string
 *
 *  ASSUMES 1.  The caller realizes this function returns a pointer to a static
 *              buffer, hence calling this function a second time, but before
 *              the results from the previous call have been used, will destroy
 *              the previous results
 *
 ******************************************************************************/

LPSTR MapTime(PIP_ADAPTER_INFO AdapterInfo, DWORD_PTR TimeVal)
{

    struct tm* pTime;
    static char timeBuf[128];
    static char oemTimeBuf[256];

    if (pTime = localtime(&TimeVal)) {

        SYSTEMTIME systemTime;
        char* pTimeBuf = timeBuf;
        int n;

        systemTime.wYear = pTime->tm_year + 1900;
        systemTime.wMonth = pTime->tm_mon + 1;
        systemTime.wDayOfWeek = (WORD)pTime->tm_wday;
        systemTime.wDay = (WORD)pTime->tm_mday;
        systemTime.wHour = (WORD)pTime->tm_hour;
        systemTime.wMinute = (WORD)pTime->tm_min;
        systemTime.wSecond = (WORD)pTime->tm_sec;
        systemTime.wMilliseconds = 0;
        n = GetDateFormat(0, DATE_LONGDATE, &systemTime, NULL, timeBuf, sizeof(timeBuf));
        timeBuf[n - 1] = ' ';
        GetTimeFormat(0, 0, &systemTime, NULL, &timeBuf[n], sizeof(timeBuf) - n);

        //
        // we have to convert the returned ANSI string to the OEM charset
        //
        //

        if (CharToOem(timeBuf, oemTimeBuf)) {
            return oemTimeBuf;
        }

        return timeBuf;
    }
    return "";
}



/*******************************************************************************
 *
 *  MapTimeEx
 *
 *  Converts IP lease time to more human-sensible string
 *
 *  ENTRY   AdapterInfo - pointer to IP_ADAPTER_INFO owning time variable
 *          TimeVal - DWORD (time_t) time value (number of milliseconds since
 *                    virtual year dot)
 *
 *  EXIT    buffer allocated
 *
 *  RETURNS pointer to string
 *
 *  ASSUMES 1.  The caller realizes this function returns a pointer to a static
 *              buffer, hence calling this function a second time, but before
 *              the results from the previous call have been used, will destroy
 *              the previous results
 *
 ******************************************************************************/

LPSTR MapTimeEx(PIP_ADAPTER_INFO AdapterInfo, DWORD_PTR TimeVal)
{
    LPSTR   rettime, rettimeBuf;

    rettimeBuf = GrabMemory(128);
    if (!rettimeBuf) {
        return  NULL;
    }

    rettime = MapTime(AdapterInfo, TimeVal);

    if (strcmp(rettime, "") == 0) {
        rettimeBuf[0] = '\0';
    }
    else {
        strcpy(rettimeBuf, rettime);
    }
    return rettimeBuf;
}



/*******************************************************************************
 *
 *  MapScopeId
 *
 *  Converts scope id value. Input is a string. If it is "*" then this denotes
 *  that the scope id is really a null string, so we return an empty string.
 *  Otherwise, the input string is returned
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS pointer to string
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR MapScopeId(PVOID Param)
{
    return !strcmp((LPSTR)Param, "*") ? "" : (LPSTR)Param;
}



/*******************************************************************************
 *
 *  Terminate
 *
 *  Cleans up - closes the registry handles, ready for process exit
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID Terminate()
{

    //
    // this function probably isn't even necessary - I'm sure the system will
    // clean up these handles if we just fall out
    //

    if (NetbtParametersKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(NetbtParametersKey);
    }
    if (NetbtInterfacesKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(NetbtInterfacesKey);
    }
    if (TcpipParametersKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(TcpipParametersKey);
    }
    if (TcpipLinkageKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(TcpipLinkageKey);
    }

}



/*******************************************************************************
 *
 *  GrabMemory
 *
 *  Allocates memory. Exits with a fatal error if LocalAlloc fails, since on NT
 *  I don't expect this ever to occur
 *
 *  ENTRY   size
 *              Number of bytes to allocate
 *
 *  EXIT
 *
 *  RETURNS pointer to allocated memory
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPVOID GrabMemory(DWORD size)
{

    LPVOID p;

    p = (LPVOID)LocalAlloc(LMEM_FIXED, size);
    if (!p) {
        return NULL;
    }
    return p;
}



/*******************************************************************************
 *
 *  DisplayMessage
 *
 *  Outputs a message retrieved from the string resource attached to the exe.
 *  Mainly for internationalizable reasons
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID DisplayMessage(BOOL Tabbed, DWORD MessageId, ...)
{

    va_list argptr;
    char messageBuffer[2048];
    int count;

    va_start(argptr, MessageId);
    count = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                          NULL,    // use default hModule
                          MessageId,
                          0,       // use default Language
                          messageBuffer,
                          sizeof(messageBuffer),
                          &argptr
                          );

    if (count == 0) {
        DEBUG_PRINT(("DisplayMessage: GetLastError() returns %d\n", GetLastError()));
    }

    va_end(argptr);
    if (Tabbed) {
        putchar('\t');
    }
    printf(messageBuffer);
}



/*******************************************************************************
 *
 *  KillFixedInfo
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID KillFixedInfo(PFIXED_INFO Info)
{

    PIP_ADDR_STRING p;
    PIP_ADDR_STRING next;

    for (p = Info->DnsServerList.Next; p != NULL; p = next) {
        next = p->Next;
        ReleaseMemory(p);
    }
    ReleaseMemory(Info);
}



/*******************************************************************************
 *
 *  KillAdapterInfo
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID KillAdapterInfo(PIP_ADAPTER_INFO Info)
{
    PIP_ADDR_STRING p;
    PIP_ADDR_STRING next;
    PIP_ADAPTER_INFO CurrAdapter;
    PIP_ADAPTER_INFO NextAdapter;

    for (CurrAdapter=Info; CurrAdapter != NULL; CurrAdapter = NextAdapter) {
        for (p = CurrAdapter->IpAddressList.Next; p != NULL; p = next) {
            next = p->Next;
            ReleaseMemory(p);
        }
        for (p = CurrAdapter->GatewayList.Next; p != NULL; p = next) {
            next = p->Next;
            ReleaseMemory(p);
        }
        for (p = CurrAdapter->SecondaryWinsServer.Next; p != NULL; p = next) {
            next = p->Next;
            ReleaseMemory(p);
        }
        NextAdapter = CurrAdapter->Next;
        ReleaseMemory(CurrAdapter);
    }
}

VOID KillAdapterAddresses(PIP_ADAPTER_ADDRESSES Info)
{
    PIP_ADAPTER_UNICAST_ADDRESS pU;
    PIP_ADAPTER_UNICAST_ADDRESS nextU;
    PIP_ADAPTER_ANYCAST_ADDRESS pA;
    PIP_ADAPTER_ANYCAST_ADDRESS nextA;
    PIP_ADAPTER_MULTICAST_ADDRESS pM;
    PIP_ADAPTER_MULTICAST_ADDRESS nextM;
    PIP_ADAPTER_DNS_SERVER_ADDRESS pD;
    PIP_ADAPTER_DNS_SERVER_ADDRESS nextD;
    PIP_ADAPTER_PREFIX pP;
    PIP_ADAPTER_PREFIX nextP;
    PIP_ADAPTER_ADDRESSES CurrAdapter;
    PIP_ADAPTER_ADDRESSES NextAdapter;

    for (CurrAdapter=Info; CurrAdapter != NULL; CurrAdapter = NextAdapter) {
        FREE(CurrAdapter->Description);
        FREE(CurrAdapter->FriendlyName);
        FREE(CurrAdapter->DnsSuffix);
        FREE(CurrAdapter->AdapterName);

        for (pU = CurrAdapter->FirstUnicastAddress; pU != NULL; pU = nextU) {
            FREE(pU->Address.lpSockaddr);
            nextU = pU->Next;
            FREE(pU);
        }
        for (pA = CurrAdapter->FirstAnycastAddress; pA != NULL; pA = nextA) {
            FREE(pA->Address.lpSockaddr);
            nextA = pA->Next;
            FREE(pA);
        }
        for (pM = CurrAdapter->FirstMulticastAddress; pM != NULL; pM = nextM) {
            FREE(pM->Address.lpSockaddr);
            nextM = pM->Next;
            FREE(pM);
        }
        for (pD = CurrAdapter->FirstDnsServerAddress; pD != NULL; pD = nextD) {
            FREE(pD->Address.lpSockaddr);
            nextD = pD->Next;
            FREE(pD);
        }
        for (pP = CurrAdapter->FirstPrefix; pP != NULL; pP = nextP) {
            FREE(pP->Address.lpSockaddr);
            nextP = pP->Next;
            FREE(pP);
        }
        NextAdapter = CurrAdapter->Next;

        FREE(CurrAdapter);
    }
}



/*******************************************************************************
 *
 *  KillPerAdapterInfo
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID KillPerAdapterInfo(PIP_PER_ADAPTER_INFO Info)
{

    PIP_ADDR_STRING p;
    PIP_ADDR_STRING next;

    for (p = Info->DnsServerList.Next; p != NULL; p = next) {
        next = p->Next;
        ReleaseMemory(p);
    }
    ReleaseMemory(Info);
}



/*******************************************************************************
 *
 *  GetIPAddrStringLen
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
GetIPAddrStringLen(PIP_ADDR_STRING pIPAddrString)
{
    PIP_ADDR_STRING Curr=pIPAddrString->Next;
    int len = 0;

    while (Curr != NULL) {
        Curr=Curr->Next;
        len++;
    }
    return len;
}



/*******************************************************************************
 *
 *  GetSizeofFixedInfo
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
GetSizeofFixedInfo(PFIXED_INFO pFixedInfo)
{
    return (sizeof(FIXED_INFO) + (GetIPAddrStringLen(&pFixedInfo->DnsServerList) * sizeof(IP_ADDR_STRING)));
}



/*******************************************************************************
 *
 *  GetFixedInfoEx
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
GetFixedInfoEx(PFIXED_INFO pFixedInfo, PULONG pOutBufLen)
{

    PFIXED_INFO getinfo;
    PIP_ADDR_STRING DnsServerList, CurrDnsServerList;
    uint len;

    if (pOutBufLen == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    getinfo = GetFixedInfo();

    try {

        if (!pFixedInfo || (*pOutBufLen < GetSizeofFixedInfo(getinfo)) ) {
            *pOutBufLen = GetSizeofFixedInfo(getinfo);
            KillFixedInfo(getinfo);
            return ERROR_BUFFER_OVERFLOW;
        }

        ZeroMemory(pFixedInfo, *pOutBufLen);
        CopyMemory(pFixedInfo, getinfo, sizeof(FIXED_INFO));

        DnsServerList = getinfo->DnsServerList.Next;
        CurrDnsServerList = &pFixedInfo->DnsServerList;
        CurrDnsServerList->Next = NULL;
        len = sizeof(FIXED_INFO);

        while (DnsServerList != NULL) {
            CurrDnsServerList->Next = (PIP_ADDR_STRING)((ULONG_PTR)pFixedInfo + len);
            CopyMemory(CurrDnsServerList->Next, DnsServerList, sizeof(IP_ADDR_STRING));
            CurrDnsServerList = CurrDnsServerList->Next;
            DnsServerList = DnsServerList->Next;
            len = len + sizeof(IP_ADDR_STRING);
        }

        KillFixedInfo(getinfo);
        return ERROR_SUCCESS;
    }

    except (EXCEPTION_EXECUTE_HANDLER) {

        // printf("Exception %d \n", GetExceptionCode());
        return ERROR_INVALID_PARAMETER;
    }
}



/*******************************************************************************
 *
 *  GetSizeofAdapterInfo
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
GetSizeofAdapterInfo(PIP_ADAPTER_INFO pAdapterInfo)
{
    DWORD size = 0;

    while (pAdapterInfo != NULL) {
        size += sizeof(IP_ADAPTER_INFO) +
                (GetIPAddrStringLen(&pAdapterInfo->IpAddressList) *
                 sizeof(IP_ADDR_STRING)) +
                (GetIPAddrStringLen(&pAdapterInfo->GatewayList) *
                 sizeof(IP_ADDR_STRING)) +
                (GetIPAddrStringLen(&pAdapterInfo->SecondaryWinsServer) *
                 sizeof(IP_ADDR_STRING));
        pAdapterInfo = pAdapterInfo->Next;
    }
    return size;
}



/*******************************************************************************
 * GetSizeofAdapterAddresses
 *
 * This routine determines how much memory is used by data organized in a set
 * of IP_ADAPTER_ADDRESSES information.
 *
 * ENTRY    pAdapterInfo - information to get total size for
 *
 * EXIT
 *
 * RETURNS  amount of memory used
 *
 ******************************************************************************/

DWORD GetSizeofAdapterAddresses(PIP_ADAPTER_ADDRESSES pAdapterInfo)
{
    DWORD size = 0;
    PIP_ADAPTER_UNICAST_ADDRESS pUAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS pAAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS pMAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS pDAddress;
    PIP_ADAPTER_PREFIX pPrefix;

    while (pAdapterInfo != NULL) {
        size += sizeof(IP_ADAPTER_ADDRESSES);
        size += (wcslen(pAdapterInfo->FriendlyName)+1) * sizeof(WCHAR);
        size += (wcslen(pAdapterInfo->Description)+1) * sizeof(WCHAR);
        size += (wcslen(pAdapterInfo->DnsSuffix)+1) * sizeof(WCHAR);
        size += (strlen(pAdapterInfo->AdapterName)+1);

        size = ALIGN_UP(size, PVOID);
        for ( pUAddress = pAdapterInfo->FirstUnicastAddress;
              pUAddress;
              pUAddress = pUAddress->Next) {
            size += sizeof(IP_ADAPTER_UNICAST_ADDRESS) + ALIGN_UP(pUAddress->Address.iSockaddrLength, PVOID);
        }
        for ( pAAddress = pAdapterInfo->FirstAnycastAddress;
              pAAddress;
              pAAddress = pAAddress->Next) {
            size += sizeof(IP_ADAPTER_ANYCAST_ADDRESS) + ALIGN_UP(pAAddress->Address.iSockaddrLength, PVOID);
        }
        for ( pMAddress = pAdapterInfo->FirstMulticastAddress;
              pMAddress;
              pMAddress = pMAddress->Next) {
            size += sizeof(IP_ADAPTER_MULTICAST_ADDRESS) + ALIGN_UP(pMAddress->Address.iSockaddrLength, PVOID);
        }
        for ( pDAddress = pAdapterInfo->FirstDnsServerAddress;
              pDAddress;
              pDAddress = pDAddress->Next) {
            size += sizeof(IP_ADAPTER_DNS_SERVER_ADDRESS) + ALIGN_UP(pDAddress->Address.iSockaddrLength, PVOID);
        }
        for ( pPrefix = pAdapterInfo->FirstPrefix;
              pPrefix;
              pPrefix = pPrefix->Next) {
            size += sizeof(IP_ADAPTER_PREFIX) + ALIGN_UP(pPrefix->Address.iSockaddrLength, PVOID);
        }
        pAdapterInfo = pAdapterInfo->Next;
    }
    return size;
}

/*******************************************************************************
 *
 *  GetSizeofPerAdapterInfo
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
GetSizeofPerAdapterInfo(PIP_PER_ADAPTER_INFO pPerAdapterInfo)
{
    return (sizeof(IP_PER_ADAPTER_INFO) + (GetIPAddrStringLen(&pPerAdapterInfo->DnsServerList) * sizeof(IP_ADDR_STRING)));
}



/*******************************************************************************
 *
 *  GetAdapterInfoEx
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
GetAdapterInfoEx(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen)
{

    PIP_ADAPTER_INFO getinfo, orginfoptr, CurrAdapterInfo;
    PIP_ADDR_STRING IpAddressList, CurrIpAddressList;
    PIP_ADDR_STRING GatewayList, CurrGatewayList;
    PIP_ADDR_STRING SecondaryWinsServer, CurrSecondaryWinsServer;
    uint len;

    if (pOutBufLen == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    getinfo = GetAdapterInfo();

    if (getinfo == NULL) {
        return ERROR_NO_DATA;
    }

    orginfoptr = getinfo;

    try {
        if (!pAdapterInfo || (*pOutBufLen < GetSizeofAdapterInfo(getinfo)) ) {
            *pOutBufLen = GetSizeofAdapterInfo(getinfo);
            KillAdapterInfo(getinfo);
            return ERROR_BUFFER_OVERFLOW;
        }

        ZeroMemory(pAdapterInfo, *pOutBufLen);

        CurrAdapterInfo = pAdapterInfo;

        while (getinfo != NULL) {
            // pAdapterInfo->Next = (PIP_ADAPTER_INFO)((uint)pAdapterInfo + len);

            // copy the adapter info structure
            CopyMemory(CurrAdapterInfo, getinfo, sizeof(IP_ADAPTER_INFO));

            // copy the IPAddressList & GatewayList
            IpAddressList = getinfo->IpAddressList.Next;
            CurrIpAddressList = &CurrAdapterInfo->IpAddressList;
            CurrIpAddressList->Next = NULL;
            len = sizeof(IP_ADAPTER_INFO);

            while (IpAddressList != NULL) {
                CurrIpAddressList->Next = (PIP_ADDR_STRING)((ULONG_PTR)CurrAdapterInfo + len);
                CopyMemory(CurrIpAddressList->Next, IpAddressList, sizeof(IP_ADDR_STRING));
                CurrIpAddressList = CurrIpAddressList->Next;
                IpAddressList = IpAddressList->Next;
                len = len + sizeof(IP_ADDR_STRING);
            }

            GatewayList = getinfo->GatewayList.Next;
            CurrGatewayList = &CurrAdapterInfo->GatewayList;
            CurrGatewayList->Next = NULL;

            while (GatewayList != NULL) {
                CurrGatewayList->Next = (PIP_ADDR_STRING) ((ULONG_PTR)CurrAdapterInfo + len);
                CopyMemory(CurrGatewayList->Next, GatewayList, sizeof(IP_ADDR_STRING));
                CurrGatewayList = CurrGatewayList->Next;
                GatewayList = GatewayList->Next;
                len = len + sizeof(IP_ADDR_STRING);
            }

            SecondaryWinsServer = getinfo->SecondaryWinsServer.Next;
            CurrSecondaryWinsServer = &CurrAdapterInfo->SecondaryWinsServer;
            CurrSecondaryWinsServer->Next = NULL;

            while (SecondaryWinsServer != NULL) {
                CurrSecondaryWinsServer->Next =
                    (PIP_ADDR_STRING) ((ULONG_PTR)CurrAdapterInfo + len);
                CopyMemory(CurrSecondaryWinsServer->Next,
                           SecondaryWinsServer, sizeof(IP_ADDR_STRING));
                CurrSecondaryWinsServer = CurrSecondaryWinsServer->Next;
                SecondaryWinsServer = SecondaryWinsServer->Next;
                len = len + sizeof(IP_ADDR_STRING);
            }

            pAdapterInfo = CurrAdapterInfo;
            CurrAdapterInfo->Next = (PIP_ADAPTER_INFO)((ULONG_PTR)CurrAdapterInfo + len);
            CurrAdapterInfo = CurrAdapterInfo->Next;
            getinfo = getinfo->Next;
        }

        pAdapterInfo->Next = NULL;
        KillAdapterInfo(orginfoptr);
        return ERROR_SUCCESS;
    } except (EXCEPTION_EXECUTE_HANDLER) {

        // printf("Exception %d \n", GetExceptionCode());
        KillAdapterInfo(orginfoptr);
        return ERROR_INVALID_PARAMETER;
    }
}

DWORD
GetAdapterAddressesEx(ULONG Family, DWORD Flags, PIP_ADAPTER_ADDRESSES pAdapterInfo, PULONG pOutBufLen)
{

    PIP_ADAPTER_ADDRESSES getinfo, orginfoptr, CurrAdapterInfo;
    PIP_ADAPTER_UNICAST_ADDRESS SrcUAddress, *pDestUAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS SrcAAddress, *pDestAAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS SrcMAddress, *pDestMAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS SrcDAddress, *pDestDAddress;
    ULONG_PTR pDestBuffer;
    uint len;
    DWORD dwErr;

    if (pOutBufLen == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = GetAdapterAddresses(Family, Flags, &getinfo);
    if (dwErr != NO_ERROR) {
        if (getinfo) {
            KillAdapterAddresses(getinfo);
        }
        return dwErr;
    }

    if (getinfo == NULL) {
        return ERROR_NO_DATA;
    }

    orginfoptr = getinfo;

    try {
        if (!pAdapterInfo || (*pOutBufLen < GetSizeofAdapterAddresses(getinfo)) ) {
            *pOutBufLen = GetSizeofAdapterAddresses(getinfo);
            KillAdapterAddresses(getinfo);
            return ERROR_BUFFER_OVERFLOW;
        }

        ZeroMemory(pAdapterInfo, *pOutBufLen);

        CurrAdapterInfo = pAdapterInfo;

        while (getinfo != NULL) {
            // pAdapterInfo->Next = (PIP_ADAPTER_ADDRESSES)((uint)pAdapterInfo + len);

            // copy the adapter info structure
            CopyMemory(CurrAdapterInfo, getinfo, sizeof(IP_ADAPTER_ADDRESSES));
            pDestBuffer = (ULONG_PTR)CurrAdapterInfo + sizeof(IP_ADAPTER_ADDRESSES);

            CurrAdapterInfo->FriendlyName = (PWCHAR)pDestBuffer;
            wcscpy(CurrAdapterInfo->FriendlyName, getinfo->FriendlyName);
            pDestBuffer += (wcslen(CurrAdapterInfo->FriendlyName)+1) * sizeof(WCHAR);

            CurrAdapterInfo->Description = (PWCHAR)pDestBuffer;
            wcscpy(CurrAdapterInfo->Description, getinfo->Description);
            pDestBuffer += (wcslen(CurrAdapterInfo->Description)+1) * sizeof(WCHAR);

            CurrAdapterInfo->DnsSuffix = (PWCHAR)pDestBuffer;
            wcscpy(CurrAdapterInfo->DnsSuffix, getinfo->DnsSuffix);
            pDestBuffer += (wcslen(CurrAdapterInfo->DnsSuffix)+1) * sizeof(WCHAR);

            CurrAdapterInfo->AdapterName = (PCHAR)pDestBuffer;
            strcpy(CurrAdapterInfo->AdapterName, getinfo->AdapterName);
            pDestBuffer += (strlen(CurrAdapterInfo->AdapterName)+1);

            pDestBuffer = ALIGN_UP_PTR(pDestBuffer, PVOID);

            // copy the address lists
            if (!(Flags & GAA_FLAG_SKIP_UNICAST)) {
                SrcUAddress = getinfo->FirstUnicastAddress;
                pDestUAddress = &CurrAdapterInfo->FirstUnicastAddress;
                while (SrcUAddress != NULL) {
                    *pDestUAddress = (PIP_ADAPTER_UNICAST_ADDRESS)pDestBuffer;

                    // copy address structure
                    CopyMemory((PVOID)pDestBuffer, SrcUAddress,
                               sizeof(IP_ADAPTER_UNICAST_ADDRESS));
                    pDestBuffer += sizeof(IP_ADAPTER_UNICAST_ADDRESS);

                    (*pDestUAddress)->Address.lpSockaddr = (LPSOCKADDR)pDestBuffer;

                    // copy sockaddr
                    CopyMemory((PVOID)pDestBuffer, SrcUAddress->Address.lpSockaddr,
                               SrcUAddress->Address.iSockaddrLength);
                    pDestBuffer += SrcUAddress->Address.iSockaddrLength;
                    pDestBuffer = ALIGN_UP_PTR(pDestBuffer, PVOID);

                    pDestUAddress = &(*pDestUAddress)->Next;
                    SrcUAddress = SrcUAddress->Next;
                }
            }

            if (!(Flags & GAA_FLAG_SKIP_ANYCAST)) {
                SrcAAddress = getinfo->FirstAnycastAddress;
                pDestAAddress = &CurrAdapterInfo->FirstAnycastAddress;
                while (SrcAAddress != NULL) {
                    *pDestAAddress = (PIP_ADAPTER_ANYCAST_ADDRESS)pDestBuffer;

                    // copy address structure
                    CopyMemory((PVOID)pDestBuffer, SrcAAddress,
                               sizeof(IP_ADAPTER_ANYCAST_ADDRESS));
                    pDestBuffer += sizeof(IP_ADAPTER_ANYCAST_ADDRESS);

                    (*pDestAAddress)->Address.lpSockaddr = (LPSOCKADDR)pDestBuffer;

                    // copy sockaddr
                    CopyMemory((PVOID)pDestBuffer, SrcAAddress->Address.lpSockaddr,
                               SrcAAddress->Address.iSockaddrLength);
                    pDestBuffer += SrcAAddress->Address.iSockaddrLength;
                    pDestBuffer = ALIGN_UP_PTR(pDestBuffer, PVOID);

                    pDestAAddress = &(*pDestAAddress)->Next;
                    SrcAAddress = SrcAAddress->Next;
                }
            }

            if (!(Flags & GAA_FLAG_SKIP_MULTICAST)) {
                SrcMAddress = getinfo->FirstMulticastAddress;
                pDestMAddress = &CurrAdapterInfo->FirstMulticastAddress;
                while (SrcMAddress != NULL) {
                    *pDestMAddress = (PIP_ADAPTER_MULTICAST_ADDRESS)pDestBuffer;

                    // copy address structure
                    CopyMemory((PVOID)pDestBuffer, SrcMAddress,
                               sizeof(IP_ADAPTER_MULTICAST_ADDRESS));
                    pDestBuffer += sizeof(IP_ADAPTER_MULTICAST_ADDRESS);

                    (*pDestMAddress)->Address.lpSockaddr = (LPSOCKADDR)pDestBuffer;

                    // copy sockaddr
                    CopyMemory((PVOID)pDestBuffer, SrcMAddress->Address.lpSockaddr,
                               SrcMAddress->Address.iSockaddrLength);
                    pDestBuffer += SrcMAddress->Address.iSockaddrLength;
                    pDestBuffer = ALIGN_UP_PTR(pDestBuffer, PVOID);

                    pDestMAddress = &(*pDestMAddress)->Next;
                    SrcMAddress = SrcMAddress->Next;
                }
            }

            if (!(Flags & GAA_FLAG_SKIP_DNS_SERVER)) {
                SrcDAddress = getinfo->FirstDnsServerAddress;
                pDestDAddress = &CurrAdapterInfo->FirstDnsServerAddress;
                while (SrcDAddress != NULL) {
                    *pDestDAddress = (PIP_ADAPTER_DNS_SERVER_ADDRESS)pDestBuffer;

                    // copy address structure
                    CopyMemory((PVOID)pDestBuffer, SrcDAddress,
                               sizeof(IP_ADAPTER_DNS_SERVER_ADDRESS));
                    pDestBuffer += sizeof(IP_ADAPTER_DNS_SERVER_ADDRESS);

                    (*pDestDAddress)->Address.lpSockaddr = (LPSOCKADDR)pDestBuffer;

                    // copy sockaddr
                    CopyMemory((PVOID)pDestBuffer, SrcDAddress->Address.lpSockaddr,
                               SrcDAddress->Address.iSockaddrLength);
                    pDestBuffer += SrcDAddress->Address.iSockaddrLength;
                    pDestBuffer = ALIGN_UP_PTR(pDestBuffer, PVOID);

                    pDestDAddress = &(*pDestDAddress)->Next;
                    SrcDAddress = SrcDAddress->Next;
                }
            }

            if (Flags & GAA_FLAG_INCLUDE_PREFIX) {
                PIP_ADAPTER_PREFIX SrcPrefix, *pDestPrefix;

                SrcPrefix = getinfo->FirstPrefix;
                pDestPrefix = &CurrAdapterInfo->FirstPrefix;
                while (SrcPrefix != NULL) {
                    *pDestPrefix = (PIP_ADAPTER_PREFIX)pDestBuffer;

                    // copy structure
                    CopyMemory((PVOID)pDestBuffer, SrcPrefix,
                               sizeof(IP_ADAPTER_PREFIX));
                    pDestBuffer += sizeof(IP_ADAPTER_PREFIX);
    
                    (*pDestPrefix)->Address.lpSockaddr = (LPSOCKADDR)pDestBuffer;
    
                    // copy sockaddr
                    CopyMemory((PVOID)pDestBuffer, SrcPrefix->Address.lpSockaddr,
                               SrcPrefix->Address.iSockaddrLength);
                    pDestBuffer += SrcPrefix->Address.iSockaddrLength;
                    pDestBuffer = ALIGN_UP_PTR(pDestBuffer, PVOID);

                    pDestPrefix = &(*pDestPrefix)->Next;
                    SrcPrefix = SrcPrefix->Next;
                }
            }

            pAdapterInfo = CurrAdapterInfo;
            CurrAdapterInfo->Next = (PIP_ADAPTER_ADDRESSES)pDestBuffer;
            CurrAdapterInfo = CurrAdapterInfo->Next;
            getinfo = getinfo->Next;
        }

        pAdapterInfo->Next = NULL;
        KillAdapterAddresses(orginfoptr);
        return ERROR_SUCCESS;
    }

    except (EXCEPTION_EXECUTE_HANDLER) {

        // printf("Exception %d \n", GetExceptionCode());
        KillAdapterAddresses(orginfoptr);
        return ERROR_INVALID_PARAMETER;
    }
}



/*******************************************************************************
 *
 *  GetPerAdapterInfoEx
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
GetPerAdapterInfoEx(ULONG IfIndex,
                    PIP_PER_ADAPTER_INFO pPerAdapterInfo,
                    PULONG pOutBufLen
                    )

{

    PIP_PER_ADAPTER_INFO getinfo;
    PIP_ADDR_STRING DnsServerList, CurrDnsServerList;
    UINT len;

    if (pOutBufLen == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    getinfo = InternalGetPerAdapterInfo(IfIndex);

    if (getinfo == NULL) {
        return ERROR_NO_DATA;
    }

    try {

        if (!pPerAdapterInfo ||
            *pOutBufLen < GetSizeofPerAdapterInfo(getinfo)) {

            *pOutBufLen = GetSizeofPerAdapterInfo(getinfo);
            KillPerAdapterInfo(getinfo);
            return ERROR_BUFFER_OVERFLOW;
        }

        ZeroMemory(pPerAdapterInfo, *pOutBufLen);
        CopyMemory(pPerAdapterInfo, getinfo, sizeof(IP_PER_ADAPTER_INFO));

        DnsServerList = getinfo->DnsServerList.Next;
        CurrDnsServerList = &pPerAdapterInfo->DnsServerList;
        CurrDnsServerList->Next = NULL;
        len = sizeof(IP_PER_ADAPTER_INFO);

        while (DnsServerList != NULL) {
            CurrDnsServerList->Next = (PIP_ADDR_STRING)((ULONG_PTR)pPerAdapterInfo + len);
            CopyMemory(CurrDnsServerList->Next, DnsServerList, sizeof(IP_ADDR_STRING));
            CurrDnsServerList = CurrDnsServerList->Next;
            DnsServerList = DnsServerList->Next;
            len = len + sizeof(IP_ADDR_STRING);
        }

        KillPerAdapterInfo(getinfo);
        return ERROR_SUCCESS;
    }

    except (EXCEPTION_EXECUTE_HANDLER) {

        // printf("Exception %d \n", GetExceptionCode());
        return ERROR_INVALID_PARAMETER;
    }
}



/*******************************************************************************
 *
 *  ReleaseAdapterIpAddress
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL
ReleaseAdapterIpAddress(PIP_ADAPTER_INFO adapterInfo)
{

    WCHAR wAdapter[MAX_ALLOWED_ADAPTER_NAME_LENGTH + 1];
    DWORD status;

    //
    // check adapter pointer and name
    //

    if (adapterInfo == NULL || strcmp(adapterInfo->AdapterName, "") == 0) {
        return FALSE;
    }

    //
    // don't bother releasing if the address is already released (0.0.0.0).
    //

    if (ZERO_IP_ADDRESS(adapterInfo->IpAddressList.IpAddress.String)) {
        return FALSE;
    }

    //
    // convert adapter name to unicode and call DhcpReleaseParameters
    //

    ConvertOemToUnicode(adapterInfo->AdapterName, wAdapter);

    status = DhcpReleaseParameters(wAdapter);
    TRACE_PRINT(("DhcpReleaseParameters(%ws) returns %d\n",
                 wAdapter, status));

    return status == ERROR_SUCCESS;
}


/*******************************************************************************
 *
 *  RenewAdapterIpAddress
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL
RenewAdapterIpAddress(PIP_ADAPTER_INFO adapterInfo)
{

    WCHAR wAdapter[MAX_ALLOWED_ADAPTER_NAME_LENGTH + 1];
    DWORD status;

    //
    // check adapter pointer and name
    //

    if (adapterInfo == NULL || strcmp(adapterInfo->AdapterName, "") == 0) {
        return FALSE;
    }

    //
    // convert adapter name to unicode and call DhcpAcquireParameters
    //

    ConvertOemToUnicode(adapterInfo->AdapterName, wAdapter);

    status = DhcpAcquireParameters(wAdapter);
    TRACE_PRINT(("DhcpAcquireParameters(%ws) returns %d\n",
                 wAdapter, status));

    return status == ERROR_SUCCESS;
}

/*******************************************************************************
 *
 *  SetAdapterIpAddress
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD APIENTRY
SetAdapterIpAddress(LPSTR AdapterName,
                    BOOL EnableDHCP,
                    ULONG IPAddress,
                    ULONG SubnetMask,
                    ULONG DefaultGateway
                    )
{
    DWORD dwEnableDHCP;
    DWORD dwDHCPEnabled;
    IP_ADDR_STRING IpAddrString;
    HKEY key;
    WCHAR Name[MAX_ADAPTER_NAME_LENGTH + 1];
    CHAR String[20];
    DWORD status;

    if (!OpenAdapterKey(KEY_TCP, AdapterName, KEY_ALL_ACCESS, &key)) {
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // We cannot handle netcards with multiple addresses,
    // so check for that case up front
    //

    ZeroMemory(&IpAddrString, sizeof(IpAddrString));
    if (!ReadRegistryIpAddrString(key, "IPAddress", &IpAddrString)) {
        return ERROR_CAN_NOT_COMPLETE;
    }

    if (IpAddrString.Next) {
        PIP_ADDR_STRING p;
        for (p = IpAddrString.Next; p != NULL; p = IpAddrString.Next) {
            IpAddrString.Next = p->Next;
            ReleaseMemory(p);
        }
        return ERROR_TOO_MANY_NAMES;
    }

    //
    // If we're setting a static address, check to see if the adapter
    // currently has a static or DHCP address.
    //

    if (!EnableDHCP) {
        if (!MyReadRegistryDword(key, "EnableDHCP", &dwDHCPEnabled)) {

            //
            // If an error occurs assume that DHCP was NOT enabled.
            //

            dwDHCPEnabled = FALSE;
        }
    }

    //
    // Update the address, mask, and gateway in the registry
    //

    dwEnableDHCP = !!EnableDHCP;
    WriteRegistryDword(key, "EnableDHCP", &dwEnableDHCP);

    if (EnableDHCP) { IPAddress = SubnetMask = DefaultGateway = 0; }

    ZeroMemory(String, sizeof(String));
    lstrcpy(String, inet_ntoa(*(struct in_addr*)&IPAddress));
    WriteRegistryMultiString(key, "IPAddress", String);

    ZeroMemory(String, sizeof(String));
    lstrcpy(String, inet_ntoa(*(struct in_addr*)&SubnetMask));
    WriteRegistryMultiString(key, "SubnetMask", String);

    ZeroMemory(String, sizeof(String));
    if (DefaultGateway) {
        lstrcpy(String, inet_ntoa(*(struct in_addr*)&DefaultGateway));
    }
    WriteRegistryMultiString(key, "DefaultGateway", String);
    RegCloseKey(key);

    //
    // Notify DHCP of the change
    //

    mbstowcs(Name, AdapterName, MAX_ADAPTER_NAME_LENGTH);
    if (EnableDHCP) {
        status = DhcpNotifyConfigChange(NULL, Name, FALSE, 0, 0, 0,
                                              DhcpEnable
                                              );
    }
    else {
        //
        // If the netcard previously had a static address we need
        // to remove it before setting the new address.
        //

        if (!dwDHCPEnabled) {
            DhcpNotifyConfigChange(NULL, Name, TRUE, 0, 0, 0,
                                         IgnoreFlag
                                         );
        }

        status = DhcpNotifyConfigChange(NULL, Name, TRUE, 0,
                                              IPAddress, SubnetMask,
                                              DhcpDisable
                                              );
    }
    return status;
}



/*******************************************************************************
 *
 *  GetDnsServerList
 *
 *  Gets DNS server List
 *
 *  ENTRY
 *
 *  EXIT
 *
 *  RETURNS
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL
GetDnsServerList(PIP_ADDR_STRING IpAddr)
{

    PIP_ADAPTER_INFO        adapterList;
    PIP_ADAPTER_INFO        adapter;
    PIP_PER_ADAPTER_INFO    perAdapterInfo = NULL;
    LONG                    err = ERROR_PATH_NOT_FOUND;
    HKEY                    key;
    BOOL                    ok;

    TRACE_PRINT(("Entered GetDnsServerList\n"));

    if ((adapterList = GetAdapterInfo()) != NULL) {

        //
        // scan the adapter list and try to insert DNS names to IpAddr
        //

        for (adapter = adapterList; adapter; adapter = adapter->Next) {

            if (adapter->AdapterName[0] &&
                OpenAdapterKey(KEY_TCP, adapter->AdapterName, KEY_READ, &key)) {

                //
                // DNS Server list: first NameServer and then DhcpNameServer
                //

                ok = ReadRegistryIpAddrString(key,
                                              TEXT("NameServer"),
                                              IpAddr);

                if (!ok) {

                    ok = ReadRegistryIpAddrString(key,
                                                  TEXT("DhcpNameServer"),
                                                  IpAddr);

                }

                if (ok) {
                    err = ERROR_SUCCESS;
                }

                RegCloseKey(key);

            } else {
                DEBUG_PRINT(("Cannot OpenAdapterKey KEY_TCP '%s', gle=%d\n",
                             adapter->AdapterName,
                             GetLastError()));
            }
        }

        KillAdapterInfo(adapterList);
    } else {
        DEBUG_PRINT(("GetDnsServerList: GetAdapterInfo returns NULL\n"));
    }

    TRACE_PRINT(("Exit GetDnsServerList\n"));

    return (err == ERROR_SUCCESS);
}




/*******************************************************************************
 * GetAdapterOrderMap
 *
 * This routine builds an array which maps interface indices to their
 * respective adapter orderings.
 *
 * ENTRY    nothing
 *
 * EXIT     nothing
 *
 * RETURNS  IP_ADAPTER_ORDER_MAP
 *
 ******************************************************************************/

PIP_ADAPTER_ORDER_MAP APIENTRY GetAdapterOrderMap()
{
    LPWSTR AdapterOrder = NULL;
    LPWSTR Adapter;
    PIP_ADAPTER_ORDER_MAP AdapterOrderMap = NULL;
    DWORD dwErr;
    DWORD dwType;
    DWORD dwSize;
    DWORD i;
    DWORD j;
    PIP_INTERFACE_INFO InterfaceInfo = NULL;

    do {

        //
        // Retrieve the 'Bind' REG_MULTI_SZ from the Tcpip\Linkage key.
        // This string-list tells us the current adapter order,
        // with each entry being of the form \Device\{GUID}.
        //

        dwSize = 0;
        dwErr = RegQueryValueExW(TcpipLinkageKey, L"Bind", NULL, &dwType,
                                  NULL, &dwSize);
        if (dwErr != NO_ERROR || dwType != REG_MULTI_SZ) { break; }
        AdapterOrder = (LPWSTR)GrabMemory(dwSize);
        if (!AdapterOrder) { break; }
        dwErr = RegQueryValueExW(TcpipLinkageKey, L"Bind", NULL, &dwType,
                                  (LPBYTE)AdapterOrder, &dwSize);
        if (dwErr != NO_ERROR || dwType != REG_MULTI_SZ) { break; }

        //
        // Retrieve the IP interface information from TCP/IP.
        // This information tells us the interface index
        // for each adapter GUID,
        //

        dwSize = 0;
        dwErr = GetInterfaceInfo(NULL, &dwSize);
        if (dwErr != ERROR_INSUFFICIENT_BUFFER &&
            dwErr != ERROR_BUFFER_OVERFLOW) {
            break;
        }
        InterfaceInfo = GrabMemory(dwSize);
        if (!InterfaceInfo) { break; }
        dwErr = GetInterfaceInfo(InterfaceInfo, &dwSize);
        if (dwErr != NO_ERROR) { break; }

        //
        // Construct a mapping from the interfaces in 'InterfaceInfo'
        // to their positions in 'AdapterOrder'. In other words,
        // construct an array of interface indices in which location i
        // contains the index of the interface which is in location i
        // in 'AdapterOrder'.
        //

        AdapterOrderMap =
            GrabMemory(FIELD_OFFSET(IP_ADAPTER_ORDER_MAP,
                       AdapterOrder[InterfaceInfo->NumAdapters]));
        if (!AdapterOrderMap) { break; }

        for (i = 0, Adapter = AdapterOrder;
             *Adapter && i < (DWORD)InterfaceInfo->NumAdapters;
             Adapter += lstrlenW(Adapter) + 1) {

            //
            // See if this is the NdiswanIp device, which corresponds to
            // all Ndiswan interfaces. To implement adapter ordering
            // for Ndiswan interfaces, we store their indices
            // into successive locations in the adapter-order map
            // based on the location of the string '\Device\NdiswanIp'
            // in the adapter-order list.
            //

            if (lstrcmpiW(c_szDeviceNdiswanIp, Adapter) == 0) {

                //
                // This is the \Device\NdiswanIp entry, so list all Ndiswan
                // interfaces in the adapter-order map now.
                // Unfortunately, 'InterfaceInfo' does not tell us the type
                // of each interface. In order to figure out which interfaces
                // are Ndiswan interfaces, we enumerate all interfaces (again)
                // and look for entries whose type is 'IF_TYPE_PPP'.
                //

                PMIB_IFTABLE IfTable;
                dwErr = AllocateAndGetIfTableFromStack(&IfTable, FALSE,
                                                       GetProcessHeap(), 0,
                                                       FALSE);
                if (dwErr == NO_ERROR) {
                    for (j = 0;
                         j < IfTable->dwNumEntries &&
                         i < (DWORD)InterfaceInfo->NumAdapters; j++) {
                        if (IfTable->table[j].dwType == IF_TYPE_PPP) {
                            AdapterOrderMap->AdapterOrder[i++] =
                                IfTable->table[j].dwIndex;
                        }
                    }
                    HeapFree(GetProcessHeap(), 0, IfTable);
                }
                continue;
            }

            //
            // Now handle all other interfaces by matching the GUID
            // in 'Adapter' to the GUID of an interface in 'InterfaceInfo'.
            // We then store the index of the interface found, if any,
            // in the next location in 'AdapterOrderMap'.
            //

            for (j = 0; j < (DWORD)InterfaceInfo->NumAdapters; j++) {
                if (lstrcmpiW(InterfaceInfo->Adapter[j].Name +
                              sizeof(c_szDeviceTcpip) - 1,
                              Adapter + sizeof(c_szDevice) - 1) == 0) {
                    AdapterOrderMap->AdapterOrder[i++] =
                        InterfaceInfo->Adapter[j].Index;
                    break;
                }
            }
        }
        AdapterOrderMap->NumAdapters = i;
        ReleaseMemory(InterfaceInfo);
        ReleaseMemory(AdapterOrder);
        return AdapterOrderMap;

    } while(FALSE);
    if (InterfaceInfo) { ReleaseMemory(InterfaceInfo); }
    if (AdapterOrder) { ReleaseMemory(AdapterOrder); }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\wsctrl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wsctrl.c

Abstract:

    Functions to talk to TCP/IP device driver

    Contents:
        WsControl

Author:

    Richard L Firth (rfirth) 6-Aug-1994

Revision History:

    rfirth 6-Aug-1994
        Created

--*/

#include "precomp.h"
#include "ntddip6.h"
#pragma hdrstop

extern CRITICAL_SECTION g_stateLock;
HANDLE TcpipDriverHandle = INVALID_HANDLE_VALUE;
HANDLE Ip6DriverHandle = INVALID_HANDLE_VALUE;

DWORD
Ip6Control(
    DWORD   Request,
    LPVOID  InputBuffer,
    LPDWORD InputBufferLength,
    LPVOID  OutputBuffer,
    LPDWORD OutputBufferLength
)
{

    BOOL ok;
    DWORD bytesReturned;
    HANDLE Handle;

    if (Ip6DriverHandle == INVALID_HANDLE_VALUE) {
        Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                             0,      // access mode
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,   // security attributes
                             OPEN_EXISTING,
                             0,      // flags & attributes
                             NULL);  // template file
        EnterCriticalSection(&g_stateLock);
        if (Ip6DriverHandle == INVALID_HANDLE_VALUE) {
            if (Handle == INVALID_HANDLE_VALUE) {
                LeaveCriticalSection(&g_stateLock);
                return GetLastError();
            } else {
                Ip6DriverHandle = Handle;
            }
        } else {
            CloseHandle(Handle);
        }
        LeaveCriticalSection(&g_stateLock);
    }

    ok = DeviceIoControl(Ip6DriverHandle,
                         Request,
                         InputBuffer,
                         *InputBufferLength,
                         OutputBuffer,
                         *OutputBufferLength,
                         &bytesReturned,
                         NULL
                         );
    if (!ok) {
        *OutputBufferLength = bytesReturned;
        return GetLastError();
    }

    *OutputBufferLength = bytesReturned;

    return NO_ERROR;
}

/*******************************************************************************
 *
 *  WsControl
 *
 *  ENTRY   Protocol            - ignored
 *          Request             - ignored
 *          InputBuffer         - pointer to request buffer
 *          InputBufferLength   - pointer to DWORD: IN = request buffer length
 *          OutputBuffer        - pointer to output buffer
 *          OutputBufferLength  - pointer to DWORD: IN = length of output buffer;
 *                                OUT = length of returned data
 *
 *  EXIT    OutputBuffer - contains queried info if successful
 *          OutputBufferLength - contains number of bytes in OutputBuffer if
 *          successful
 *
 *  RETURNS Success = STATUS_SUCCESS/NO_ERROR
 *          Failure = Win32 error code
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
WsControl(
    DWORD   Protocol,
    DWORD   Request,
    LPVOID  InputBuffer,
    LPDWORD InputBufferLength,
    LPVOID  OutputBuffer,
    LPDWORD OutputBufferLength
)
{

    BOOL ok;
    DWORD bytesReturned;
    HANDLE Handle;

    UNREFERENCED_PARAMETER(Request);

    if (Protocol == IPPROTO_IPV6) {
        return Ip6Control(Request, 
                          InputBuffer, 
                          InputBufferLength,
                          OutputBuffer,
                          OutputBufferLength);
    }

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {

        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK iosb;
        UNICODE_STRING string;
        NTSTATUS status;

        RtlInitUnicodeString(&string, DD_TCP_DEVICE_NAME);

        InitializeObjectAttributes(&objectAttributes,
                                   &string,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );
        status = NtCreateFile(&Handle,
                              SYNCHRONIZE | GENERIC_EXECUTE,
                              &objectAttributes,
                              &iosb,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              FILE_SYNCHRONOUS_IO_NONALERT,
                              NULL,
                              0
                              );
        EnterCriticalSection(&g_stateLock);
        if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {
            if (!NT_SUCCESS(status)) {
                LeaveCriticalSection(&g_stateLock);
                return RtlNtStatusToDosError(status);
            } else {
                TcpipDriverHandle = Handle;
            }
        } else {
            NtClose(Handle);
        }
        LeaveCriticalSection(&g_stateLock);
    }

    ok = DeviceIoControl(TcpipDriverHandle,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         InputBuffer,
                         *InputBufferLength,
                         OutputBuffer,
                         *OutputBufferLength,
                         &bytesReturned,
                         NULL
                         );
    if (!ok) {
        *OutputBufferLength = bytesReturned;
        return GetLastError();
    }

    *OutputBufferLength = bytesReturned;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\ipconfig.h ===
#ifndef __IPCONFIG_H__
#define __IPCONFIG_H__

//
// Define API decoration for direct importing of DLL references.
//

PFIXED_INFO
WINAPI
GetFixedInfo(VOID);

DWORD
WINAPI
GetFixedInfoEx(PFIXED_INFO, PULONG);

PIP_ADAPTER_INFO
WINAPI
GetAdapterInfo(VOID);

DWORD
WINAPI
GetAdapterInfoEx(PIP_ADAPTER_INFO, PULONG);

PIP_PER_ADAPTER_INFO
WINAPI
GetPerAdapterInfo(ULONG);

DWORD
WINAPI
GetPerAdapterInfoEx(ULONG, PIP_PER_ADAPTER_INFO, PULONG);

BOOL
WINAPI
ReleaseAdapterIpAddress(PIP_ADAPTER_INFO);

BOOL
WINAPI
RenewAdapterIpAddress(PIP_ADAPTER_INFO);

LPSTR
WINAPI
MapNodeType(UINT);

LPSTR
WINAPI
MapNodeTypeEx(UINT);

LPSTR
WINAPI
MapAdapterType(UINT);

LPSTR
WINAPI
MapAdapterTypeEx(UINT);

LPSTR
WINAPI
MapTime(PIP_ADAPTER_INFO, DWORD_PTR);

LPSTR
WINAPI
MapTimeEx(PIP_ADAPTER_INFO, DWORD_PTR);

LPSTR
WINAPI
MapAdapterAddress(PIP_ADAPTER_INFO, LPSTR);

LPSTR
WINAPI
MapScopeId(PVOID);

//
// defined in IPHLPAPI.H -- but can't include that because of clash of 
// definitions 
// of IP_ADDR_STRING etc (in iptypes.h which is included by iphlpapi.h ).
//
DWORD
WINAPI
GetInterfaceInfo(
    IN PIP_INTERFACE_INFO pIfTable,
    OUT PULONG            dwOutBufLen
    );


#endif // __IPCONFIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\routetab\entry.c ===
//==========================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    entry.c
//
// History:
//      t-abolag    06-21-95    Created.
//
// entry point for Routing Table API set
//==========================================================================

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctype.h>

#ifndef CHICAGO

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#endif

#include <windows.h>
#include <winsock.h>
#include <string.h>

#include <errno.h>
#include <process.h>
#include <malloc.h>
#include <io.h>
#include <winsvc.h>

#include "ipinfo.h"
#include "llinfo.h"
#include "ntddtcp.h"
#include "tdiinfo.h"
#include "dhcpcapi.h"

#include "routetab.h"
#include "rtdefs.h"

BOOL
WINAPI
LIBMAIN(
    IN  HINSTANCE hInstance,
    IN  DWORD dwReason,
    IN  LPVOID lpvUnused
    )
{

    BOOL bError = TRUE;

    switch(dwReason) {

        case DLL_PROCESS_ATTACH: {

            DEBUG_PRINT(("LIBMAIN: DLL_PROCESS_ATTACH\n"));

            //
            // we have no per-thread initialization,
            // so disable DLL_THREAD_{ATTACH,DETACH} calls
            //

            DisableThreadLibraryCalls(hInstance);


            //
            // initialize globals and background thread
            //

            bError = RTStartup((HMODULE)hInstance);

            break;
        }

        case DLL_PROCESS_DETACH: {

            //
            // if the background thread is around, tell it to clean up;
            // otherwise clean up ourselves
            //

            bError = RTShutdown((HMODULE)hInstance);

            break;
        }
    }

    DEBUG_PRINT(("LIBMAIN: <= %d\n", bError ));

    return bError;
}



//----------------------------------------------------------------------------
// Function:    RTStartup
//
// Handles initialization for DLL-wide data
//----------------------------------------------------------------------------

BOOL
RTStartup(
    HMODULE hmodule
    )
{

    HANDLE hThread;
    DWORD dwErr, dwThread;
    SECURITY_ATTRIBUTES saAttr;
    SECURITY_DESCRIPTOR sdDesc;
    CHAR szModule[MAX_PATH + 1];

    g_prtcfg = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*g_prtcfg));

    if (g_prtcfg == NULL){
        DEBUG_PRINT(("RTStartup: !HeapAlloc \n"));
        return FALSE;
    }
    
    do {

        //
        // We do a loadlibrary to increment the reference count
        // on this library, so that when the library is unloaded
        // by the application, our address-space doesn't disappear.
        // Instead, we signal the thread and then we cleanup
        // and call FreeLibraryAndExitThread to unload the DLL completely
        //

        GetModuleFileName(hmodule, szModule, MAX_PATH);

        hmodule = LoadLibrary(szModule);

        if (!hmodule) {
            DEBUG_PRINT(("RTStartup: !loadlibrary %s\n", szModule ));
            return FALSE;
        }


        //
        // Create the event signalled to tell the update thread to exit
        //

        g_rtCfg.hUpdateThreadExit = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (g_rtCfg.hUpdateThreadExit == NULL) {
            DEBUG_PRINT(("RTStartup: !CreateEvent \n"));
            break;
        }


        //
        // Create the mutex which protects our tables
        //

        g_rtCfg.hRTMutex = CreateMutex(NULL, FALSE, NULL);

        if (g_rtCfg.hRTMutex == NULL) { break; }


        //
        // Load interface table now before any API functions are called
        //

        dwErr = RTGetTables(
                    &g_rtCfg.lpIfTable, &g_rtCfg.dwIfCount,
                    &g_rtCfg.lpIPAddressTable, &g_rtCfg.dwIPAddressCount
                    );

        if (dwErr != 0) {
            DEBUG_PRINT(("RTStartup: !RTGetTables \n"));
            break;
        }



        //
        // Try to create the DHCP event in case DHCP service or DHCP API
        // has not created it; use the security attributes struct
        // because DHCP will. Omitting this code will cause DHCP
        // to fail to open the event if the interfaces are statically
        // configured (in which case the DHCP client would not be running);
        //

#if (WINVER >= 0x500)
    g_rtCfg.hDHCPEvent = DhcpOpenGlobalEvent();
#else
        saAttr.nLength = sizeof(saAttr);
        saAttr.bInheritHandle = FALSE;

        InitializeSecurityDescriptor(&sdDesc, SECURITY_DESCRIPTOR_REVISION);

        if (SetSecurityDescriptorDacl(&sdDesc, TRUE, NULL, FALSE)) {
            saAttr.lpSecurityDescriptor = &sdDesc;
        }
        else {
            saAttr.lpSecurityDescriptor = NULL;
        }

        g_rtCfg.hDHCPEvent =
            CreateEvent(&saAttr, TRUE, FALSE, STR_DHCPNEWIPADDR);
#endif

        if (g_rtCfg.hDHCPEvent != NULL) {

            //
            // Start up the thread which updates the interface table
            // if IP addresses are changed
            //

            hThread = CreateThread(
                        NULL, 0, (LPTHREAD_START_ROUTINE)RTUpdateThread,
                        (LPVOID)hmodule, 0, &dwThread
                        );

            if (hThread == NULL) {
                DEBUG_PRINT(("RTStartup: !CreateThread  \n"));
                break;
            }

            g_rtCfg.dwUpdateThreadStarted = 1;

            CloseHandle(hThread);
        }

        return TRUE;

    } while(FALSE);


    //
    // If we reach here, something went wrong;
    // clean up and decrement the DLL reference count.
    //

    RTCleanUp();

    if (hmodule) {
        FreeLibrary(hmodule);
    }

    return FALSE;
}




//----------------------------------------------------------------------------
// Function:    RTShutdown
//
// Handles DLL-unload-time cleanup.
//----------------------------------------------------------------------------

BOOL
RTShutdown(
    HMODULE hmodule
    )
{


    //
    // If the background thread exists, allow it to clean up;
    // otherwise, handle cleanup ourselves.
    //

    if (g_rtCfg.dwUpdateThreadStarted) {

        //
        // Tell the thread to exit
        //

        SetEvent(g_rtCfg.hUpdateThreadExit);
    }
    else {

        //
        // Do the cleanup ourselves
        //

        RTCleanUp();

        FreeLibrary(hmodule);
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    RTCleanUp
//
// This is called to free up resources used by the DLL.
//----------------------------------------------------------------------------

VOID
RTCleanUp(
    )
{

    //
    // Free memory for the interface table
    //

    if (g_rtCfg.lpIfTable != NULL) {
        HeapFree(GetProcessHeap(), 0, g_rtCfg.lpIfTable);
    }


    //
    // Free memory for the address table
    //

    if (g_rtCfg.lpIPAddressTable != NULL) {
        HeapFree(GetProcessHeap(), 0, g_rtCfg.lpIPAddressTable);
    }


    //
    // Close the event on which we receive IP-address-change notifications
    //

    if (g_rtCfg.hDHCPEvent != NULL) { CloseHandle(g_rtCfg.hDHCPEvent); }


    //
    // Close the mutex protecting our tables
    //

    if (g_rtCfg.hRTMutex != NULL) { CloseHandle(g_rtCfg.hRTMutex); }


    //
    // Close the handle signalled to tell the update-thread to exit
    //

    if (g_rtCfg.hUpdateThreadExit != NULL) {
        CloseHandle(g_rtCfg.hUpdateThreadExit);
    }


    //
    // Close our handle to the TCP/IP driver
    //

    if (g_rtCfg.hTCPHandle != NULL) { CloseHandle(g_rtCfg.hTCPHandle); }


    HeapFree(GetProcessHeap(), 0, g_prtcfg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\iphlpapi\lib\wins.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wins.c

Abstract:

    Functions to retrieve info from NetBT device driver

    Contents:
        GetWinsServers

Author:

    Richard L Firth (rfirth) 6-Aug-1994

Revision History:

    rfirth 6-Aug-1994
        Created

--*/

#include "precomp.h"
#include <nbtioctl.h>

//
// seems that if WINS addresses not specified, NetBT reports 127.0.0.0 so if
// this value is returned, we won't display them
//

#define LOCAL_WINS_ADDRESS  0x0000007f  // 127.0.0.0

#define BYTE_SWAP(w)    (HIBYTE(w) | (LOBYTE(w) << 8))
#define WORD_SWAP(d)    (BYTE_SWAP(HIWORD(d)) | (BYTE_SWAP(LOWORD(d)) << 16))

/*******************************************************************************
 *
 *  GetWinsServers
 *
 *  Gets the primary and secondary WINS addresses for a particular adapter from
 *  NetBT
 *
 *  ENTRY   AdapterInfo - pointer to ADAPTER_INFO
 *
 *  EXIT    AdapterInfo.PrimaryWinsServer and AdapterInfo.SecondaryWinsServer
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES 1.
 *          2. We have already got the Node Type for this adapter
 *
 ******************************************************************************/

BOOL GetWinsServers(PIP_ADAPTER_INFO AdapterInfo)
{

    HANDLE h;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK iosb;
    STRING name;
    UNICODE_STRING uname;
    NTSTATUS status;
    DWORD i;
    tWINS_NODE_INFO winsInfo;
    char path[MAX_PATH];

    //
    // default the 'have WINS' status of this adapter
    //

    AdapterInfo->HaveWins = FALSE;

    strcpy(path, "\\Device\\NetBT_Tcpip_");
    strcat(path, AdapterInfo->AdapterName);

    RtlInitString(&name, path);
    status = RtlAnsiStringToUnicodeString(&uname, &name, TRUE);
    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: RtlAnsiStringToUnicodeString(name=%s) failed, err=%d\n",
                     name, GetLastError() ));
        return FALSE;
    }

    InitializeObjectAttributes(
        &objAttr,
        &uname,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        (PSECURITY_DESCRIPTOR)NULL
        );

    status = NtCreateFile(&h,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objAttr,
                          &iosb,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0
                          );

    RtlFreeUnicodeString(&uname);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtCreateFile(path=%s) failed, err=%d\n",
                     path, GetLastError() ));
        return FALSE;
    }

    status = NtDeviceIoControlFile(h,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &iosb,
                                   IOCTL_NETBT_GET_WINS_ADDR,
                                   NULL,
                                   0,
                                   (PVOID)&winsInfo,
                                   sizeof(winsInfo)
                                   );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(h, TRUE, NULL);
        if (NT_SUCCESS(status)) {
            status = iosb.Status;
        }
    }

    NtClose(h);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtDeviceIoControlFile failed, err=%d\n",
                     GetLastError() ));

        return FALSE;
    }

    //
    // for some reason, NetBT returns the addresses in low-byte order. We have
    // to swap them
    //

    for (i = 0; i < RTL_NUMBER_OF(winsInfo.AllNameServers); i++) {
        winsInfo.AllNameServers[i] =
            RtlUlongByteSwap(winsInfo.AllNameServers[i]);
    }

    DEBUG_PRINT(("GetWinsServers: Primary Address = %d.%d.%d.%d\n",
                ((LPBYTE)&winsInfo.AllNameServers[0])[0],
                ((LPBYTE)&winsInfo.AllNameServers[0])[1],
                ((LPBYTE)&winsInfo.AllNameServers[0])[2],
                ((LPBYTE)&winsInfo.AllNameServers[0])[3]
                ));

    DEBUG_PRINT(("GetWinsServers: Secondary Address = %d.%d.%d.%d\n",
                ((LPBYTE)&winsInfo.AllNameServers[1])[0],
                ((LPBYTE)&winsInfo.AllNameServers[1])[1],
                ((LPBYTE)&winsInfo.AllNameServers[1])[2],
                ((LPBYTE)&winsInfo.AllNameServers[1])[3]
                ));

    //
    // if we get 127.0.0.0 back then convert it to the NULL address. See
    // ASSUMES in function header
    //

    if (winsInfo.AllNameServers[0] == LOCAL_WINS_ADDRESS) {
        winsInfo.AllNameServers[0] = 0;
    } else {
        AdapterInfo->HaveWins = TRUE;
    }
    AddIpAddress(&AdapterInfo->PrimaryWinsServer,
                 winsInfo.AllNameServers[0],
                 0,
                 0
                 );

    //
    // same with secondary
    //

    if (winsInfo.AllNameServers[1] == LOCAL_WINS_ADDRESS) {
        winsInfo.AllNameServers[1] = 0;
    } else {
        AdapterInfo->HaveWins = TRUE;
    }
    AddIpAddress(&AdapterInfo->SecondaryWinsServer,
                 winsInfo.AllNameServers[1],
                 0,
                 0
                 );

    //
    // Append any remaining addresses.
    //

    for (i = 0; i < winsInfo.NumOtherServers; i++) {
        if (winsInfo.Others[i] != LOCAL_WINS_ADDRESS) {
            AddIpAddress(&AdapterInfo->SecondaryWinsServer,
                         winsInfo.Others[i],
                         0,
                         0
                         );
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\routetab\routetab.h ===
/*
 *============================================================================
 * Copyright (c) 1994-95, Microsoft Corp.
 *
 * File:    routetab.h
 *
 * Contains declarations for the Routing Table functions
 * The functions declared here and exported by the Routing Table DLL
 * are the following:
 *
 *      AddRoute
 *      DeleteRoute
 *      GetRouteTable
 *      FreeRouteTable
 *      GetInterfaceTable
 *      FreeInterfaceTable
 *      SetAddrChangeNotifyEvent
 *
 * The structures required by these functions are also declared here:
 *
 *      IPROUTING_ENTRY
 *      IPINTERFACE_ENTRY
 *
 * Routes can be added to and deleted from the IP routing table by other
 * means. Therefore, it is necessary for any protocol using these functions
 * to reload the routing tables periodically.
 *============================================================================
 */

#ifndef _ROUTETAB_H_
#define _ROUTETAB_H_



/*
 *---------------------------------------------------------------
 * Any one of these values can be passed as the route entry type
 * when calling the AddRoute() function.
 *---------------------------------------------------------------
 */
#define IRE_TYPE_OTHER      1
#define IRE_TYPE_INVALID    2
#define IRE_TYPE_DIRECT     3
#define IRE_TYPE_INDIRECT   4



/*
 *-------------------------------------------------------------
 * Any one of these values can be passed as the protocol type
 * when calling AddRoute() or DeleteRoute()
 *-------------------------------------------------------------
 */
#define IRE_PROTO_OTHER     1
#define IRE_PROTO_LOCAL     2
#define IRE_PROTO_NETMGMT   3
#define IRE_PROTO_ICMP      4
#define IRE_PROTO_EGP       5
#define IRE_PROTO_GGP       6
#define IRE_PROTO_HELLO     7
#define IRE_PROTO_RIP       8
#define IRE_PROTO_IS_IS     9
#define IRE_PROTO_ES_IS     10
#define IRE_PROTO_CISCO     11
#define IRE_PROTO_BBN       12
#define IRE_PROTO_OSPF      13
#define IRE_PROTO_BGP       14



/*
 *-------------------------------------------------------------
 * This value may be passed as the metric to functions which
 * require a metric, in cases where the metric is irrelevant
 *-------------------------------------------------------------
 */
#define IRE_METRIC_UNUSED   0xffffffff


/*
 *-------------------------------------------------------------
 * These constants are used in the definition of IF_ENTRY
 *-------------------------------------------------------------
 */
#define MAX_PHYSADDR_SIZE       8
#define	MAX_IFDESCR_LEN			256

/*
 *-------------------------------------------------------------
 * Any of these values may appear in the if_type field of
 * the IF_ENTRY structure
 *-------------------------------------------------------------
 */
#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


/*
 *-------------------------------------------------------------
 * This structure is used by GetIfTable() to return
 * information about the physical network interfaces
 * on the system
 *-------------------------------------------------------------
 */
typedef struct _IF_ENTRY {
    DWORD       ife_index;
    DWORD       ife_type;
    DWORD       ife_mtu;
    DWORD       ife_speed;
    DWORD       ife_physaddrlen;
    BYTE        ife_physaddr[MAX_PHYSADDR_SIZE];
    DWORD       ife_adminstatus;
    DWORD       ife_operstatus;
    DWORD       ife_lastchange;
    DWORD       ife_inoctets;
    DWORD       ife_inucastpkts;
    DWORD       ife_innucastpkts;
    DWORD       ife_indiscards;
    DWORD       ife_inerrors;
    DWORD       ife_inunknownprotos;
    DWORD       ife_outoctets;
    DWORD       ife_outucastpkts;
    DWORD       ife_outnucastpkts;
    DWORD       ife_outdiscards;
    DWORD       ife_outerrors;
    DWORD       ife_outqlen;
    DWORD       ife_descrlen;
    BYTE        ife_descr[MAX_IFDESCR_LEN];
} IF_ENTRY, *LPIF_ENTRY;



/*
 *-------------------------------------------------------------
 * This structure is used by GetIPAddressTable() to return
 * information about logical IP interfaces on the system
 *-------------------------------------------------------------
 */
typedef struct _IPADDRESS_ENTRY {
    DWORD       iae_address;          /* IP address of this entry  */
    DWORD       iae_index;            /* index of interface for this entry */
    DWORD       iae_netmask;          /* subnet mask of this entry */
    DWORD       iae_bcastaddr;
    DWORD       iae_reasmsize;
    USHORT      iae_context;
    USHORT      iae_pad;
} IPADDRESS_ENTRY, *LPIPADDRESS_ENTRY;



/*
 *-------------------------------------------------------------
 * This structure is used by GetRouteTable() to return
 * information about routing table entries.
 *-------------------------------------------------------------
 */
typedef struct _IPROUTE_ENTRY {
    DWORD       ire_dest;       /* destination IP addr, network order */
    DWORD       ire_index;      /* route entry index                  */
    DWORD       ire_metric1;    /* destination metric, host order     */
    DWORD       ire_metric2;    /* unused                             */
    DWORD       ire_metric3;    /* unused                             */
    DWORD       ire_metric4;    /* unused                             */
    DWORD       ire_nexthop;    /* next hop IP addr, network order    */
    DWORD       ire_type;       /* routing type for this entry        */
    DWORD       ire_proto;      /* routing protocol for this entry    */
    DWORD       ire_age;        /* age of this entry                  */
    DWORD       ire_mask;       /* network mask, network order        */
    DWORD       ire_metric5;    /* unused                             */
#ifndef CHICAGO
    DWORD       ire_context;    /* unused                             */
#endif
} IPROUTE_ENTRY, *LPIPROUTE_ENTRY;



/*
 *------------------------------------------------------------------
 * Function:    GetIfEntry
 *
 * Parameters:
 *      DWORD   dwIfIndex       index of interface to retrieve
 *      LPIF_ENTRY
 *              lpIfEntry       pointer to an IF_ENTRY
 *                              which receives the interface entry
 *
 * This function fills the supplied interface entry pointer with
 * with the interface information corresponding to the physical network
 * interface in the system with index dwIfIndex.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
GetIfEntry(
    IN DWORD dwIfIndex,
    OUT LPIF_ENTRY lpIfEntry
    );



/*
 *------------------------------------------------------------------
 * Function:    GetIPAddressTable
 *
 * Parameters:
 *      LPIPADDRESS_ENTRY
 *             *lplpAddrTable     pointer to an LPIPADDRESS_ENTRY
 *                                which receives the IP address table
 *      LPDWORD lpdwAddrCount     pointer to a DWORD which receives
 *                                the number of addresses in the table
 *
 * This function allocates and fills in an array of address entry
 * structures corresponding to the logical IP interfaces in
 * the system. It also stores the number of entries in the array
 * in the DWORD pointed to by lpdwAddrCount.
 *
 * Call FreeIPAddressTable to free the memory allocated for the
 * address table.
 *
 * If the function fails, it sets *lpdwAddrCount to zero and
 * *lplpAddrTable to NULL.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
GetIPAddressTable(
    OUT LPIPADDRESS_ENTRY *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
    );



/*
 *------------------------------------------------------------------
 * Function:    FreeIPAddressTable
 *
 * Parameters:
 *      LPIPADDRESS_ENTRY
 *              lpAddrTable       the address table to be freed.
 *
 * This function frees the memory allocated for an address table.
 * It returns 0 if successful and non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
FreeIPAddressTable(
    IN LPIPADDRESS_ENTRY lpAddrTable
    );



/*
 *------------------------------------------------------------------
 * Function:    GetRouteTable
 *
 * Parameters:
 *      LPIPROUTE_ENTRY
 *              *lplpRouteTable   pointer to an LPIPROUTE_ENTRY
 *                                which receives the routing table
 *      DWORD   *lpdwRouteCount   pointer to a DWORD which receives
 *                                the number of routing entries
 *
 * This function allocates and fills in an array of routing table
 * entries from the Tcpip driver. It also sets the number of
 * entries in the array in the DWORD pointed to by lpdwRouteCount.
 *
 * In the IPROUTE_ENTRY structure, the only metric used by
 * the Tcpip stack is IPROUTE_ENTRY.ire_metric1; the other metric
 * fields should be ignored.
 *
 * Call FreeRouteTable to free the memory allocated for the
 * routing table.
 *
 * If the function fails, it sets *lpdwRouteCount to zero and
 * *lplpRouteTable to NULL.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
GetRouteTable(
    OUT LPIPROUTE_ENTRY *lplpRouteTable,
    OUT LPDWORD lpdwRouteCount
    );



/*
 *------------------------------------------------------------------
 * Function:    FreeRouteTable
 *
 * Parameters:
 *      LPIPROUTE_ENTRY
 *              lpRouteTable    the routing table to be freed.
 *
 * This function frees the memory allocated for a routing table.
 * It returns 0 if successful and non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
FreeRouteTable(
    IN LPIPROUTE_ENTRY lpRouteTable
    );



/*
 *------------------------------------------------------------------
 * Function:    AddRoute
 *
 * Parameters:
 *      DWORD dwProtocol        protocol of specified route
 *      DWORD dwType            type of specified route
 *      DWORD dwIndex           index of interface on which to add
 *      DWORD dwDestVal         destination IP addr (network order)
 *      DWORD dwMaskVal         destination subnet mask, or zero
 *                              if no subnet (network order)
 *      DWORD dwGateVal         next hop IP addr (network order)
 *      DWORD dwMetric          metric
 *
 * This function adds a new route (or updates an existing route)
 * for the specified protocol, on the specified interface.
 * (See above for values which can be used as protocol numbers,
 * as well as values which can be used as route entry types.)
 * If the route identified by dwIndex.dwDestVal.dwMaskVal.dwGateVal
 * already exists, it is updated with the specified protocol,
 * type, and metric.
 * The TCP stack will return an error on an attempt to add a route
 * whose destination is destination is longer than its mask.
 * In other words, this function fails if (dwDestVal & ~dwMaskVal)
 * is non-zero.
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
AddRoute(
    IN DWORD dwProtocol,
    IN DWORD dwType,
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal,
    IN DWORD dwMetric
    );


/*
 *------------------------------------------------------------------
 * Function:    DeleteRoute
 *
 * Parameters:
 *      DWORD   dwIndex         index of interface from which to delete
 *      DWORD   dwDestVal       destination IP addr (network order)
 *      DWORD   dwMaskVal       subnet mask (network order)
 *      DWORD   dwGateVal       next hop IP addr (network order)
 *
 * This function deletes a route to the specified destination.
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
DeleteRoute(
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal
    );

/*
 *------------------------------------------------------------------
 * Function:    RefreshAddresses
 *
 * Parameters:
 *      none
 *
 * This function queries the TCPIP stack for the current Address table and Interface
 * Entry table, updating routetab's local copy of those tables.s
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
RefreshAddresses();


/*
 *------------------------------------------------------------------
 * Function:    SetAddrChangeNotifyEvent
 *
 * Parameters:
 *      HANDLE  hEvent      the event to be signalled if the
 *                          IP address of a local interface changes
 *
 * This function sets the event to be signalled if any IP address
 * for any interfaces is changed either via DHCP client activity
 * or manually in the Network Control Panel. This notification is
 * optional.
 *
 * If hEvent is NULL, address change notification is disabled.
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
SetAddrChangeNotifyEvent(
    HANDLE hEvent
    );


/*
 *------------------------------------------------------------------
 * Function:    ReloadIPAddressTable
 *
 * Parameters:
 *      LPIPADDRESS_ENTRY
 *             *lplpAddrTable     pointer to an LPIPADDRESS_ENTRY
 *                                which receives the IP address table
 *      LPDWORD lpdwAddrCount     pointer to a DWORD which receives
 *                                the number of addresses in the table
 *
 * This function first queries the TCP/IP stack to rebuild its
 * IP interface and IP address tables.
 * Then this function allocates and fills in an array of address entry
 * structures corresponding to the logical IP interfaces in
 * the system. It also stores the number of entries in the array
 * in the DWORD pointed to by lpdwAddrCount.
 *
 * Call FreeIPAddressTable to free the memory allocated for the
 * address table.
 *
 * If the function fails, it sets *lpdwAddrCount to zero and
 * *lplpAddrTable to NULL.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
ReloadIPAddressTable(
    OUT LPIPADDRESS_ENTRY *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
    );


#ifdef DBG
#define DEBUG_PRINT(S) printf S
#define TRACE_PRINT(S) if( trace ){ printf S; }else{}
#else
#define DEBUG_PRINT(S) /* nothing */
#define TRACE_PRINT(S) /* nothing */
#endif


#endif /* _ROUTETAB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\routetab\routetab.c ===
//============================================================================
// Copyright (c) 1994-95, Microsoft Corp.
//
// File:    routetab.c
//
// History:
//      t-abolag    6/20/95     Adapted from RIP code.
//
// Contains API entries for the Routing Table functions
//============================================================================



#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctype.h>

#ifndef CHICAGO

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#endif

#include <windows.h>
#include <winsock.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <winsvc.h>
#include "ipinfo.h"
#include "llinfo.h"
#include "ntddtcp.h"
#include "tdiinfo.h"

#include "routetab.h"
#include "rtdefs.h"

#include <assert.h>

#ifdef CHICAGO

#include <wscntl.h>

LPWSCONTROL pWsControl = NULL;
HANDLE      hWsock     = NULL;

#endif


GLOBAL_STRUCT g_rtCfg;


DWORD
APIENTRY
GetIfEntry(
    IN DWORD dwIfIndex,
    OUT LPIF_ENTRY lpIfEntry
    )
{
    DWORD dwErr;
    LPIF_ENTRY lpIf, lpIfEnd;

    if (lpIfEntry == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    RT_LOCK();

    dwErr = ERROR_INVALID_PARAMETER;

    lpIfEnd = g_rtCfg.lpIfTable + g_rtCfg.dwIfCount;
    for (lpIf = g_rtCfg.lpIfTable; lpIf < lpIfEnd; lpIf++) {
        if (lpIf->ife_index == dwIfIndex) {
            CopyMemory(lpIfEntry, lpIf, sizeof(IF_ENTRY));
            dwErr = 0;
            break;
        }
    }

    RT_UNLOCK();

    return dwErr;
}



DWORD
APIENTRY
GetIPAddressTable(
    OUT LPIPADDRESS_ENTRY *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
    )
{
    DWORD dwErr, dwCount;
    LPIPADDRESS_ENTRY lpAddresses;

    if (lpdwAddrCount == NULL || lplpAddrTable == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    RT_LOCK();

    dwCount = g_rtCfg.dwIPAddressCount;
    lpAddresses = (LPIPADDRESS_ENTRY)HeapAlloc(
                                        GetProcessHeap(), 0,
                                        dwCount * sizeof(IPADDRESS_ENTRY)
                                        );
    if (lpAddresses == NULL) {
        *lpdwAddrCount = 0;
        *lplpAddrTable = NULL;
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        CopyMemory(lpAddresses, g_rtCfg.lpIPAddressTable,
                   dwCount * sizeof(IPADDRESS_ENTRY));

        *lpdwAddrCount = dwCount;
        *lplpAddrTable = lpAddresses;
        dwErr = 0;
    }

    RT_UNLOCK();

    return dwErr;
}



DWORD
APIENTRY
ReloadIPAddressTable(
    OUT LPIPADDRESS_ENTRY *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
    )
{

    DWORD dwErr, dwCount;
    LPIPADDRESS_ENTRY lpAddresses;


    if (lpdwAddrCount == NULL || lplpAddrTable == NULL) {
        return ERROR_INVALID_PARAMETER;
    }


    do
    {
        RT_LOCK();

        if (g_rtCfg.lpIfTable != NULL) {

            HeapFree(GetProcessHeap(), 0, g_rtCfg.lpIfTable);

            g_rtCfg.lpIfTable = NULL;
        }

        if (g_rtCfg.lpIPAddressTable != NULL) {

            HeapFree(GetProcessHeap(), 0, g_rtCfg.lpIPAddressTable);

            g_rtCfg.lpIPAddressTable = NULL;
        }


        //
        // reload the tables
        //

        dwErr = RTGetTables(
                    &g_rtCfg.lpIfTable, &g_rtCfg.dwIfCount,
                    &g_rtCfg.lpIPAddressTable, &g_rtCfg.dwIPAddressCount
                );


        if (dwErr != 0) {

            RT_UNLOCK();
            break;
        }



        dwCount = g_rtCfg.dwIPAddressCount;
        lpAddresses = (LPIPADDRESS_ENTRY)HeapAlloc(
                                            GetProcessHeap(), 0,
                                            dwCount * sizeof(IPADDRESS_ENTRY)
                                        );
        if (lpAddresses == NULL) {

            *lpdwAddrCount = 0;
            *lplpAddrTable = NULL;
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }

        else {

            CopyMemory(lpAddresses, g_rtCfg.lpIPAddressTable,
                       dwCount * sizeof(IPADDRESS_ENTRY));

            *lpdwAddrCount = dwCount;
            *lplpAddrTable = lpAddresses;
            dwErr = 0;
        }

        RT_UNLOCK();

    } while (FALSE);

    return dwErr;
}

/*
 *------------------------------------------------------------------
 * Function:    FreeIPAddressTable
 *
 * Parameters:
 *      LPIPADDRESS_ENTRY
 *              lpAddrTable       the address table to be freed.
 *
 * This function frees the memory allocated for an address table.
 * It returns 0 if successful and non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
FreeIPAddressTable(
    IN LPIPADDRESS_ENTRY lpAddrTable
    )
{
    if (lpAddrTable != NULL) {
        HeapFree(GetProcessHeap(), 0, lpAddrTable);
        return 0;
    }
    else {
        return ERROR_INVALID_PARAMETER;
    }
}


/*
 *------------------------------------------------------------------
 * Function:    GetRouteTable
 *
 * Parameters:
 *      LPIPROUTE_ENTRY
 *              *lplpRouteTable   pointer to an LPIPROUTE_ENTRY
 *                                which receives the routing table
 *      LPDWORD  lpdwRouteCount   pointer to a DWORD which receives
 *                                the number of routing entries
 *
 * This function allocates and fills in an array of routing table
 * entries from the Tcpip driver. It also sets the number of
 * entries in the array in the DWORD pointed to by lpdwRouteCount.
 *
 * In the IPROUTE_ENTRY structure, the only metric used by
 * the Tcpip stack is IPROUTE_ENTRY.ire_metric1; the other metric
 * fields should be ignored.
 *
 * Call FreeRouteTable to free the memory allocated for the
 * routing table.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
GetRouteTable(
    OUT LPIPROUTE_ENTRY *lplpRouteTable,
    OUT LPDWORD lpdwRouteCount
    )
{
    ULONG_PTR *lpContext;
    IPSNMPInfo ipsiInfo;
    TDIObjectID *lpObject;

    DWORD dwRouteCount;
    LPIPROUTE_ENTRY lpRouteEntryTable;

    DWORD dwErr, dwInSize, dwOutSize;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;


    // first get route count
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = sizeof(IPSNMPInfo);

    lpContext = trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = IP_MIB_STATS_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    RT_LOCK();
    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  &ipsiInfo, &dwOutSize);
    RT_UNLOCK();
    if (dwErr != NO_ERROR || ipsiInfo.ipsi_numroutes == 0) {
        return dwErr;
    }

    dwRouteCount = ipsiInfo.ipsi_numroutes;

    // now get route table
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = dwRouteCount * sizeof(IPROUTE_ENTRY);
    lpRouteEntryTable = HeapAlloc(GetProcessHeap(), 0, dwOutSize);

    lpObject->toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    RT_LOCK();
    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  lpRouteEntryTable, &dwOutSize);
    RT_UNLOCK();
    if (dwErr != NO_ERROR) {
        HeapFree(GetProcessHeap(), 0, lpRouteEntryTable);
        return dwErr;
    }

    *lpdwRouteCount = dwRouteCount;
    *lplpRouteTable = lpRouteEntryTable;

    return 0;
}



/*
 *------------------------------------------------------------------
 * Function:    FreeRouteTable
 *
 * Parameters:
 *      LPIPROUTE_ENTRY
 *              lpRouteTable    the routing table to be freed.
 *
 * This function frees the memory allocated for a routing table.
 * It returns 0 if successful and non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
FreeRouteTable(
    IN LPIPROUTE_ENTRY lpRouteTable
    )
{
    if (lpRouteTable != NULL) {
        HeapFree(GetProcessHeap(), 0, lpRouteTable);
        return 0;
    }
    else {
        return ERROR_INVALID_PARAMETER;
    }
}





/*
 *------------------------------------------------------------------
 * Function:    SetAddrChangeNotifyEvent
 *
 * Parameters:
 *      HANDLE  hEvent      the event to be signalled if the
 *                          IP address of a local interface changes
 *
 * This function sets the event to be signalled if any IP address
 * for any interfaces is changed either via DHCP client activity
 * or manually in the Network Control Panel. This notification is
 * optional.
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
SetAddrChangeNotifyEvent(
    HANDLE hEvent
    )
{
    RT_LOCK();

    g_rtCfg.hUserNotifyEvent = hEvent;

    RT_UNLOCK();

    return 0;
}



DWORD UpdateRoute(DWORD dwProtocol, DWORD dwType, DWORD dwIndex,
                  DWORD dwDestVal, DWORD dwMaskVal, DWORD dwGateVal,
                  DWORD dwMetric, BOOL bAddRoute)
{
    TDIObjectID *lpObject;
    IPRouteEntry *lpentry;

    DWORD dwErr, dwInSize, dwOutSize;

    TCP_REQUEST_SET_INFORMATION_EX *lptrsiBuffer;
    BYTE buffer[sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry)];

    lptrsiBuffer = (TCP_REQUEST_SET_INFORMATION_EX *)buffer;

    lptrsiBuffer->BufferSize = sizeof(IPRouteEntry);

    lpObject = &lptrsiBuffer->ID;
    lpObject->toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    lpentry = (IPRouteEntry *)lptrsiBuffer->Buffer;
    lpentry->ire_dest = dwDestVal;
    lpentry->ire_mask = dwMaskVal;
    lpentry->ire_index = dwIndex;
    lpentry->ire_metric1 = dwMetric;
    lpentry->ire_metric2 =
    lpentry->ire_metric3 =
    lpentry->ire_metric4 =
    lpentry->ire_metric5 = IRE_METRIC_UNUSED;
    lpentry->ire_nexthop = dwGateVal;
    lpentry->ire_type = (bAddRoute ? dwType : IRE_TYPE_INVALID);
    lpentry->ire_proto = dwProtocol;
    lpentry->ire_age = 0;

    dwOutSize = 0;
    dwInSize = sizeof(TCP_REQUEST_SET_INFORMATION_EX) +
               sizeof(IPRouteEntry) - 1;

    RT_LOCK();

    dwErr = TCPSetInformationEx((LPVOID)lptrsiBuffer, &dwInSize,
                                NULL, &dwOutSize);

    RT_UNLOCK();

    return dwErr;
}


/*
 *------------------------------------------------------------------
 * Function:    AddRoute
 *
 * Parameters:
 *      DWORD dwProtocol        protocol of specified route
 *      DWORD dwType            type of specified route
 *      DWORD dwDestVal         destination IP addr (network order)
 *      DWORD dwMaskVal         destination subnet mask, or zero
 *                              if no subnet (network order)
 *      DWORD dwGateVal         next hop IP addr (network order)
 *      DWORD dwMetric          metric
 *
 * This function adds a new route (or updates an existing route)
 * for the specified protocol, on the specified interface.
 * (See above for values which can be used as protocol numbers,
 * as well as values which can be used as route entry types.)
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */

DWORD
APIENTRY
AddRoute(
    IN DWORD dwProtocol,
    IN DWORD dwType,
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal,
    IN DWORD dwMetric
    )
{
    return UpdateRoute(dwProtocol, dwType, dwIndex, dwDestVal,
                       dwMaskVal, dwGateVal, dwMetric, TRUE);
}


/*
 *------------------------------------------------------------------
 * Function:    DeleteRoute
 *
 * Parameters:
 *      DWORD   dwIndex         index of interface to delete from
 *      DWORD   dwDestVal       destination IP addr (network order)
 *      DWORD   dwMaskVal       subnet mask (network order)
 *      DWORD   dwGateVal       next hop IP addr (network order)
 *
 * This function deletes a route for the specified protocol.
 * See comments for AddRoute() for information on the use of
 * the argument dwMaskVal.
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
DeleteRoute(
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal
    )
{
    return UpdateRoute(IRE_PROTO_OTHER, IRE_TYPE_INVALID, dwIndex, dwDestVal,
                       dwMaskVal, dwGateVal, IRE_METRIC_UNUSED, FALSE);
}

/*
 *------------------------------------------------------------------
 * Function:    RefreshAddresses
 *
 * Parameters:
 *
 * This function is added for RSVP
 *
 * This function prods this code into refreshing its address tables with
 * the IP stack, just as if it had received a DHCP event notification.
 * This is needed because address change notifications coming through winsock
 * can arrive before the DHCP event has been set, which would normally cause
 * routetab to refresh its addresses.s
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
APIENTRY
RefreshAddresses(
    )
{
    DWORD   Error;

    Error = RTGetTables( &g_rtCfg.lpIfTable, &g_rtCfg.dwIfCount,
                         &g_rtCfg.lpIPAddressTable, &g_rtCfg.dwIPAddressCount );

    return( Error );

}


//------------------------------------------------------------------
// Function:    OpenTcp
//
// Parameters:
//      none.
//
// Opens the handle to the Tcpip driver.
//------------------------------------------------------------------

DWORD OpenTcp()
{
#ifdef CHICAGO

    WSADATA wsaData;


    hWsock = LoadLibrary(TEXT("wsock32.dll"));
    if(! hWsock ){
        DEBUG_PRINT(("RTStartup: can't load wsock32.dll, %d\n",
                     GetLastError()));
        DEBUG_PRINT(("OpenTcp: !hWsock\n"));
        return 1;
    }

    pWsControl = (LPWSCONTROL) GetProcAddress(hWsock, "WsControl");

    if (! pWsControl ){
        DEBUG_PRINT((
            "RTStartup: GetProcAddress(wsock32,WsControl) failed %d\n",
                         GetLastError()));
        return 1;
    }

    if (WSAStartup(MAKEWORD(1, 1), &wsaData)) {
        DEBUG_PRINT((
            "RTStartup: error %d initializing Windows Sockets.",
            WSAGetLastError()));

        return 1;
    }

    return 0;

#else

    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;

    // Open the ip stack for setting routes and parps later.
    //
    // Open a Handle to the TCP driver.
    //
    RtlInitUnicodeString(&nameString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes, &nameString,
			                   OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(&g_rtCfg.hTCPHandle,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
		                  &objectAttributes, &ioStatusBlock, NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF, 0, NULL, 0);

    return (status == STATUS_SUCCESS ? 0 : ERROR_OPEN_FAILED);

#endif

}

//---------------------------------------------------------------------
// Function:        TCPQueryInformationEx
//
// Parameters:
//      TDIObjectID *ID            The TDI Object ID to query
//      void        *Buffer        buffer to contain the query results
//      LPDWORD     *BufferSize    pointer to the size of the buffer
//                                 filled in with the amount of data.
//      UCHAR       *Context       context value for the query. should
//                                 be zeroed for a new query. It will be
//                                 filled with context information for
//                                 linked enumeration queries.
//
// Returns:
//      An NTSTATUS value.
//
//  This routine provides the interface to the TDI QueryInformationEx
//      facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------
DWORD TCPQueryInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                            LPVOID lpvOutBuffer, LPDWORD lpdwOutSize)
{
#ifdef CHICAGO
    DWORD result;

    if( ! pWsControl )
        OpenTcp();
    if( ! pWsControl ){
        DEBUG_PRINT(("TCPQueryInformationEx: !pWsControl.\n"));
        return 0;
    }

    assert( pWsControl );
    result = (
            (*pWsControl)(
                IPPROTO_TCP,
                WSCNTL_TCPIP_QUERY_INFO,
                lpvInBuffer,  // InBuf,
                lpdwInSize ,  // InBufLen,
                lpvOutBuffer, // OutBuf,
                lpdwOutSize   // OutBufLen
            ) );
    return result;
#else

    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (g_rtCfg.hTCPHandle == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(g_rtCfg.hTCPHandle, // Driver handle
                                   NULL,                // Event
                                   NULL,                // APC Routine
                                   NULL,                // APC context
                                   &isbStatusBlock,     // Status block
                                   IOCTL_TCP_QUERY_INFORMATION_EX,  // Control
                                   lpvInBuffer,         // Input buffer
                                   *lpdwInSize,         // Input buffer size
                                   lpvOutBuffer,        // Output buffer
                                   *lpdwOutSize);       // Output buffer size

    if (status == STATUS_PENDING) {
	    status = NtWaitForSingleObject(g_rtCfg.hTCPHandle, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;
#endif
}




//---------------------------------------------------------------------------
// Function:        TCPSetInformationEx
//
// Parameters:
//
//      TDIObjectID *ID         the TDI Object ID to set
//      void      *lpvBuffer    data buffer containing the information
//                              to be set
//      DWORD     dwBufferSize  the size of the data buffer.
//
//  This routine provides the interface to the TDI SetInformationEx
//  facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------------
DWORD TCPSetInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                          LPVOID lpvOutBuffer, LPDWORD lpdwOutSize)
{
#ifdef CHICAGO
    DWORD    result;

    if( ! pWsControl )
        OpenTcp();
    if( ! pWsControl ){
        DEBUG_PRINT(("TCPSetInformationEx: !pWsControl \n"));
        return 0;
    }
    assert( pWsControl );

    result = (
        (*pWsControl)(
            IPPROTO_TCP,
            WSCNTL_TCPIP_SET_INFO,
            lpvInBuffer,  // InBuf,
            lpdwInSize,   // InBufLen,
            lpvOutBuffer, // OutBuf,
            lpdwOutSize   // OutBufLen
        ) );
    return result;

#else

    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (g_rtCfg.hTCPHandle == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(g_rtCfg.hTCPHandle, // Driver handle
                                   NULL,                // Event
                                   NULL,                // APC Routine
                                   NULL,                // APC context
                                   &isbStatusBlock,     // Status block
                                   IOCTL_TCP_SET_INFORMATION_EX,    // Control
                                   lpvInBuffer,         // Input buffer
                                   *lpdwInSize,         // Input buffer size
                                   lpvOutBuffer,        // Output buffer
                                   *lpdwOutSize);       // Output buffer size

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(g_rtCfg.hTCPHandle, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;

#endif
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\routetab\rtdefs.h ===
//==========================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    rtdefs.h
//
//==========================================================================


#ifndef _RTDEFS_H_
#define _RTDEFS_H_



#define STR_ROUTETAB            "ROUTETAB.DLL"
#define STR_DHCPNEWIPADDR       "DHCPNEWIPADDRESS"

#define POS_EXITEVENT           0
#define POS_DHCPEVENT           1
#define POS_LASTEVENT           2


#define RT_LOCK()       WaitForSingleObject(g_rtCfg.hRTMutex, INFINITE)
#define RT_UNLOCK()     ReleaseMutex(g_rtCfg.hRTMutex)


#define CLASS_A_MASK    0x000000FFL
#define CLASS_B_MASK    0x0000FFFFL
#define CLASS_C_MASK    0x00FFFFFFL
#define CLASS_SHIFT     5          // Make C generate hyper-optimized case
#define CLA0            0          // It takes the same arg; you mask it off, 
#define CLA1            1          // shift, and then do a case statment with 
#define CLA2            2          // some code having more than one label.
#define CLA3            3          // Values for class A 
#define CLB0            4
#define CLB1            5          // B 
#define CLC             6          // C
#define CLI             7          // Illegal 


// typedef to avoid globals name clash
typedef struct _GLOBAL_STRUCT {
    DWORD                   dwIfCount;
    LPIF_ENTRY              lpIfTable;
    DWORD                   dwIPAddressCount;
    LPIPADDRESS_ENTRY       lpIPAddressTable;
    HANDLE                  hRTMutex;
    HANDLE                  hDHCPEvent;
    HANDLE                  hUpdateThreadExit;
    DWORD                   dwUpdateThreadStarted;
    HANDLE                  hUserNotifyEvent;
    HANDLE                  hTCPHandle;
} GLOBAL_STRUCT, *LPGLOBAL_STRUCT;


extern GLOBAL_STRUCT    *g_prtcfg;
#define g_rtCfg         (*g_prtcfg)

DWORD
RTUpdateThread(
    LPVOID lpvParam
    );

BOOL
RTStartup(
    HMODULE hmodule
    );
BOOL
RTShutdown(
    HMODULE hmodule
    );
VOID
RTCleanUp(
    );


DWORD
RTGetTables(
    LPIF_ENTRY *lplpIfTable,
    LPDWORD lpdwIfCount,
    LPIPADDRESS_ENTRY *lplpAddrTable,
    LPDWORD lpdwAddrCount
    );

DWORD
RTGetIfTable(
    LPIF_ENTRY *lplpIfTable,
    LPDWORD lpdwIfCount
    );

DWORD
RTGetAddrTable(
    LPIPADDRESS_ENTRY *lplpAddrTable,
    LPDWORD lpdwAddrCount
    );

DWORD
OpenTcp(
    );

DWORD
TCPSetInformationEx(
    LPVOID lpvInBuffer,
    LPDWORD lpdwInSize,
    LPVOID lpvOutBuffer,
    LPDWORD lpdwOutSize
    );

DWORD
TCPQueryInformationEx(
    LPVOID lpvInBuffer,
    LPDWORD lpdwInSize,
    LPVOID lpvOutBuffer,
    LPDWORD lpdwOutSize
    );

#endif  // _RTDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\routetab\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
PASCAL FAR
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (PASCAL FAR * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\routetab\rtquery.c ===
//==========================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    rtquery.c
//
// test program for routing table api
//==========================================================================

#include <windows.h>
#include <winsock.h>
#include <stdio.h>
#include <stdlib.h>

#include "routetab.h"

#define MAX_COMMAND 32

#define STR_QUIT        "quit"
#define STR_ADD         "add"
#define STR_DELETE      "delete"
#define STR_ROUTES      "routelist"
#define STR_ADDRESSES   "addrlist"
#define STR_IFSTATS     "ifstats"

#define POS_ADDR_EVENT  0
#define POS_CONS_EVENT  1
#define POS_LAST_EVENT  2


void DoAddRoute();
void DoDeleteRoute();
void DoListRoutes();
void DoListAddresses();
void DoIfStats();
void PrintInstructions();
DWORD ProcessCommand();


void _cdecl main() {
    DWORD dwErr;
    HANDLE hStdout;
    HANDLE hEvents[POS_LAST_EVENT];

    hEvents[POS_CONS_EVENT] = GetStdHandle(STD_INPUT_HANDLE);
    hEvents[POS_ADDR_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);
    SetAddrChangeNotifyEvent(hEvents[POS_ADDR_EVENT]);

    PrintInstructions();

    while(TRUE) {
        printf("\nrtquery> ");
//        dwErr = WaitForMultipleObjects(POS_LAST_EVENT, hEvents,
//                                       TRUE, INFINITE);
//        if (dwErr == (WAIT_OBJECT_0 + POS_CONS_EVENT)) {
            dwErr = ProcessCommand();
            if (dwErr != 0) { break; }
//        }
//        else
//        if (dwErr == (WAIT_OBJECT_0 + POS_ADDR_EVENT)) {
//            printf("\n****an IP address has changed****");
//            DoListInterfaces();
//        }
    }

    CloseHandle(hEvents[POS_ADDR_EVENT]);
    return;
}


DWORD ProcessCommand() {
    DWORD dwErr;
    CHAR szCommand[MAX_COMMAND];
    scanf("%s", szCommand);

    dwErr = 0;
    if (_stricmp(szCommand, STR_ADD) == 0) {
        DoAddRoute();
    }
    else
    if (_stricmp(szCommand, STR_DELETE) == 0) {
        DoDeleteRoute();
    }
    else
    if (_stricmp(szCommand, STR_ROUTES) == 0) {
        DoListRoutes();
    }
    else
    if (_stricmp(szCommand, STR_ADDRESSES) == 0) {
        DoListAddresses();
    }
    else
    if (_stricmp(szCommand, STR_IFSTATS) == 0) {
        DoIfStats();
    }
    else
    if (_stricmp(szCommand, STR_QUIT) == 0) {
        dwErr = 1;
    }
    else {
        CHAR szUnusedLine[256];
        fgets(szUnusedLine, 256, stdin);

        PrintInstructions();
    }

    return dwErr;
}


void DoAddRoute() {
    DWORD dwErr, dwIndex, dwType, dwDest, dwMask, dwGate, dwMetric;
    CHAR szDest[MAX_COMMAND], szMask[MAX_COMMAND], szGate[MAX_COMMAND];

    scanf("%d %d %s %s %s %d", &dwIndex, &dwType,
          szDest, szMask, szGate, &dwMetric);
    dwDest = inet_addr(szDest);
    dwMask = inet_addr(szMask);
    dwGate = inet_addr(szGate);

    dwErr = AddRoute(IRE_PROTO_RIP, dwType, dwIndex, dwDest,
                     dwMask, dwGate, dwMetric);
    printf("\nreturn value: %x", dwErr);
}


void DoDeleteRoute() {
    DWORD dwErr, dwIndex, dwDest, dwMask, dwGate;
    CHAR szDest[MAX_COMMAND], szMask[MAX_COMMAND], szGate[MAX_COMMAND];
    
    scanf("%d %s %s %s", &dwIndex, szDest, szMask, szGate);
    dwDest = inet_addr(szDest);
    dwMask = inet_addr(szMask);
    dwGate = inet_addr(szGate);

    dwErr = DeleteRoute(dwIndex, dwDest, dwMask, dwGate);
    printf("\nreturn value: %x", dwErr);
}


void DoListRoutes() {
    struct in_addr addr;
    DWORD dwErr, dwCount;
    LPIPROUTE_ENTRY lpTable, lpentry, lpend;

    dwErr = GetRouteTable(&lpTable, &dwCount);

    if (dwErr == 0 && lpTable != NULL) {
        printf("ROUTE TABLE CONTENTS:");
        printf("\n%-10s%-18s%-18s%-18s%-10s", "index", "address",
                                         "subnet mask",
                                         "next hop",
                                         "metric");

        lpend = lpTable + dwCount;
        for (lpentry = lpTable; lpentry < lpend; lpentry++) {
            printf("\n%-10d", lpentry->ire_index);

            addr.s_addr = lpentry->ire_dest;
            printf("%-18s", inet_ntoa(addr));

            addr.s_addr = lpentry->ire_mask;
            printf("%-18s", inet_ntoa(addr));

            addr.s_addr = lpentry->ire_nexthop;
            printf("%-18s", inet_ntoa(addr));

            printf("%-10d", lpentry->ire_metric1);

        }

        FreeRouteTable(lpTable);
    }
    printf("\nreturn value: %x", dwErr);
}


void DoListAddresses() {
    struct in_addr addr;
    DWORD dwErr, dwCount;
    LPIPADDRESS_ENTRY lpTable, lpentry, lpend;

    dwErr = GetIPAddressTable(&lpTable, &dwCount);
    if (dwErr == 0 && lpTable != NULL) {
        printf("ADDRESS TABLE CONTENTS:");
        printf("\n%-10s%-18s%-18s", "index", "address", "subnet mask");

        lpend = lpTable + dwCount;
        for (lpentry = lpTable; lpentry < lpend; lpentry++) {
            printf("\n%-10d", lpentry->iae_index);
            addr.s_addr = lpentry->iae_address;
            printf("%-18s", inet_ntoa(addr));
            addr.s_addr = lpentry->iae_netmask;
            printf("%-18s", inet_ntoa(addr));
        }

        FreeIPAddressTable(lpTable);
    }

    printf("\nreturn value: %x", dwErr);
}


void DoIfStats() {
    INT i;
    IF_ENTRY ife;
    LPSTR lpszAddr;
    DWORD dwErr, dwIndex;
    LPBYTE lpbAddr, lpbAddrEnd;
    CHAR szHexDigits[] = "0123456789ABCDEF";
    CHAR szType[32], szAddr[64], szAstatus[16], szOstatus[16];

    scanf("%d", &dwIndex);
    dwErr = GetIfEntry(dwIndex, &ife);
    if (dwErr == 0) {
        switch(ife.ife_type) {
            case IF_TYPE_OTHER:
                strcpy(szType, "OTHER"); break;
            case IF_TYPE_ETHERNET:
                strcpy(szType, "ETHERNET"); break;
            case IF_TYPE_TOKENRING:
                strcpy(szType, "TOKENRING"); break;
            case IF_TYPE_FDDI:
                strcpy(szType, "FDDI"); break;
            case IF_TYPE_PPP:
                strcpy(szType, "PPP"); break;
            case IF_TYPE_LOOPBACK:
                strcpy(szType, "LOOPBACK"); break;
            case IF_TYPE_SLIP:
                strcpy(szType, "SLIP"); break;
        }
        switch(ife.ife_adminstatus) {
            case IF_STATUS_UP:
                strcpy(szAstatus, "up"); break;
            case IF_STATUS_DOWN:
                strcpy(szAstatus, "down"); break;
            case IF_STATUS_TESTING:
                strcpy(szAstatus, "testing"); break;
        }
        switch(ife.ife_operstatus) {
            case IF_STATUS_UP:
                strcpy(szOstatus, "up"); break;
            case IF_STATUS_DOWN:
                strcpy(szOstatus, "down"); break;
            case IF_STATUS_TESTING:
                strcpy(szOstatus, "testing"); break;
        }
        lpszAddr = szAddr;
        lpbAddrEnd = ife.ife_physaddr + ife.ife_physaddrlen;
        for (lpbAddr = ife.ife_physaddr; lpbAddr < lpbAddrEnd; lpbAddr++) {
            *lpszAddr++ = szHexDigits[*lpbAddr / 16];
            *lpszAddr++ = szHexDigits[*lpbAddr % 16];
            *lpszAddr++ = '-';
        }
        if (lpszAddr > szAddr) { *(--lpszAddr) = '\0'; }

        printf("\nstatistics for interface %d: ", dwIndex);
        printf("\n\tdescription:            %s", ife.ife_descr);
        printf("\n\ttype:                   %s", szType);
        printf("\n\tphysical address:       %s", szAddr);
        printf("\n\toperational status:     %s", szOstatus);
        printf("\n\tadministrative status:  %s", szAstatus);
    }
    printf("\nreturn value: %x", dwErr);
}


void PrintInstructions() {
    printf("\nRouting Table Query Test Program");

    printf("\n\tCommands:");
    printf("\n\t\tadd <index> <type> <address> <netmask> <gateway> <metric>");
    printf("\n\t\tdelete <index> <address> <netmask> <gateway>");
    printf("\n\t\troutelist");
    printf("\n\t\taddrlist");
    printf("\n\t\tifstats <index>");
    printf("\n\t\tquit");

    printf("\n\n\tRoute types for 'add' command:");
    printf("\n\t\tDIRECT==3, INDIRECT==4");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\apis\routetab\update.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: update.c
//
// History:
//      Abolade Gbadegesin  July-24-1995    Created
//
// Routing table update thread
//============================================================================



#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctype.h>


#ifndef CHICAGO

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#endif

#include <windows.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <winsvc.h>
#include "ipinfo.h"
#include "llinfo.h"
#include "ntddtcp.h"
#include "tdiinfo.h"

#include "routetab.h"
#include "rtdefs.h"


#define POS_DHCP    0
#define POS_EXIT    1
#define POS_LAST    2


//----------------------------------------------------------------------------
// Function:    RTUpdateThread
//
// This is the main function for the background thread which is responsible
// for updating our tables of interfaces and addresses whenever DHCP
// notifies us of an address change.
//----------------------------------------------------------------------------

DWORD
RTUpdateThread(
    LPVOID lpvParam
    )
{

    DWORD dwErr;
    HMODULE hmodule;
    HANDLE hEvents[POS_LAST];


    //
    // Save the module-handle, which is passed to us
    // as the thread-parameter
    //

    hmodule = (HMODULE)lpvParam;


    //
    // set up the event array for waiting
    //

    hEvents[POS_DHCP] = g_rtCfg.hDHCPEvent;
    hEvents[POS_EXIT] = g_rtCfg.hUpdateThreadExit;


    while(TRUE) {

        dwErr = WaitForMultipleObjects(POS_LAST, hEvents, FALSE, INFINITE);


        //
        // wait returned, find out why
        //

        if (dwErr == POS_EXIT) { break; }
        else
        if (dwErr == POS_DHCP) {

            //
            // an IP address changed.
            // we reload the interface table and IP address table
            // and signal the attached application
            //

            RT_LOCK();

            if (g_rtCfg.lpIfTable != NULL) {

                HeapFree(GetProcessHeap(), 0, g_rtCfg.lpIfTable);

                g_rtCfg.lpIfTable = NULL;
            }

            if (g_rtCfg.lpIPAddressTable != NULL) {

                HeapFree(GetProcessHeap(), 0, g_rtCfg.lpIPAddressTable);

                g_rtCfg.lpIPAddressTable = NULL;
            }


            //
            // reload the tables
            //

            dwErr = RTGetTables(
                        &g_rtCfg.lpIfTable, &g_rtCfg.dwIfCount,
                        &g_rtCfg.lpIPAddressTable, &g_rtCfg.dwIPAddressCount
                        );


            if (dwErr != 0) { RT_UNLOCK(); break; }


            //
            // signal the application if it has requested notification
            //

            if (g_rtCfg.hUserNotifyEvent != NULL) {
                SetEvent(g_rtCfg.hUserNotifyEvent);
            }

            RT_UNLOCK();
        }
    }



    //
    // Clean up the resources we're using
    //

    RTCleanUp();


    //
    // Unload the library and exit; this call never returns
    //

    FreeLibraryAndExitThread(hmodule, 0);

    return 0;
}


DWORD
RTGetTables(
    LPIF_ENTRY*         lplpIfTable,
    LPDWORD             lpdwIfCount,
    LPIPADDRESS_ENTRY*  lplpAddrTable,
    LPDWORD             lpdwAddrCount
    )
{

    ULONG_PTR *lpContext;
    IPSNMPInfo ipsiInfo;
    TDIObjectID *lpObject;

    DWORD dwErr, dwInSize, dwOutSize;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;


    //
    // first get interface and address count
    //

    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = sizeof(IPSNMPInfo);

    lpContext = trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = IP_MIB_STATS_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  &ipsiInfo, &dwOutSize);
    if (dwErr != NO_ERROR || ipsiInfo.ipsi_numaddr == 0) {
        return dwErr;
    }

    // save the interface and address counts
    //
    *lpdwIfCount = ipsiInfo.ipsi_numif;
    *lpdwAddrCount = ipsiInfo.ipsi_numaddr;

    // now get the interface table and address table
    //
    dwErr = RTGetIfTable(lplpIfTable, lpdwIfCount);
    if (dwErr == 0) {
        dwErr = RTGetAddrTable(lplpAddrTable, lpdwAddrCount);
    }

    return dwErr;
}


DWORD
RTGetIfTable(
    LPIF_ENTRY* lplpIfTable,
    LPDWORD     lpdwIfCount
    )
{

    LPIF_ENTRY lpIfTable, lpif;

    ULONG_PTR *lpContext;
    TDIObjectID *lpObject;

    DWORD dwErr, dwi, dwInSize, dwOutSize;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;

    if (*lpdwIfCount == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    lpContext = trqiBuffer.Context;

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = IF_MIB_STATS_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = IF_ENTITY;

    lpIfTable = HeapAlloc(GetProcessHeap(), 0,
                          *lpdwIfCount * sizeof(IF_ENTRY));
    if (lpIfTable == NULL) {
        *lpdwIfCount = 0;
        *lplpIfTable = NULL;
        return GetLastError();
    }

    lpif = lpIfTable;
    for (dwi = 0; dwi < *lpdwIfCount; dwi++) {
        dwOutSize = sizeof(IF_ENTRY);
        lpObject->toi_entity.tei_instance = dwi;
        ZeroMemory(lpContext, CONTEXT_SIZE);
        dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                      lpif, &dwOutSize);
        if (dwErr == NO_ERROR) {
            ++lpif;
        }
    }

    *lpdwIfCount = (DWORD)(lpif - lpIfTable);
    if (*lpdwIfCount == 0) {
        *lpdwIfCount = 0;
        *lplpIfTable = NULL;
        HeapFree(GetProcessHeap(), 0, lpIfTable);
        return ERROR_INVALID_PARAMETER;
    }

    *lplpIfTable = lpIfTable;

    return 0;
}


DWORD
RTGetAddrTable(
    LPIPADDRESS_ENTRY*  lplpAddrTable,
    LPDWORD             lpdwAddrCount
    )
{

    ULONG_PTR *lpContext;
    TDIObjectID *lpObject;

    LPIPADDRESS_ENTRY lpAddrTable;
    DWORD dwErr, dwInSize, dwOutSize;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;


    if (*lpdwAddrCount == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = *lpdwAddrCount * sizeof(IPADDRESS_ENTRY);

    lpAddrTable = HeapAlloc(GetProcessHeap(), 0, dwOutSize);
    if (lpAddrTable == NULL) {
        *lpdwAddrCount = 0;
        *lplpAddrTable = NULL;
        return GetLastError();
    }

    lpContext = trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  lpAddrTable, &dwOutSize);
    if (dwErr != NO_ERROR) {
        *lpdwAddrCount = 0;
        *lplpAddrTable = NULL;
        HeapFree(GetProcessHeap(), 0, lpAddrTable);
        return dwErr;
    }

    *lpdwAddrCount = dwOutSize / sizeof(IPADDRESS_ENTRY);
    *lplpAddrTable = lpAddrTable;

    return 0;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\common2\mdebug.h ===
//
// SYNOPSIS: One debug statememt in time can save nine.
// Last modified Time-stamp: <25-Nov-96 17:49>
// History:
//     MohsinA, 14-Nov-96.
//

#ifdef DBG
#define DEBUG_PRINT(S) printf S
#define TRACE_PRINT(S) if( trace ){ printf S; }else{}
#else
#define DEBUG_PRINT(S) /* nothing */
#define TRACE_PRINT(S) /* nothing */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\common2\debug.c ===
//   Name:  Mohsin Ahmed
//   Email: MohsinA@microsoft.com
//   Date:  Mon Nov 04 13:53:46 1996
//   File:  s:/tcpcmd/common2/debug.c
//   Synopsis: Win95 Woes, don't have ntdll.dll on win95.

#include <windows.h>
#define MAX_DEBUG_OUTPUT 1024

void DbgPrint( char * format, ... )
{
    va_list args;
    char    out[MAX_DEBUG_OUTPUT];
    int     cch=0;

    // cch = wsprintf( out, MODULE_NAME ":"  );

    va_start( args, format );
    wvsprintf( out + cch, format, args );
    va_end( args );

    OutputDebugString(  out );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\common2\util.c ===
//*****************************************************************************
//
// Name:    util.c
//
// Description: Utility routines for the common library.
//
// History:
//  01/21/94  JayPh   Created.
//  26-Nov-96 MohsinA io.h,fcntl.h for CR-LF fix.
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1994-2000 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************


//
// Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include "common2.h"


//*****************************************************************************
//
// Name:    InetEqual
//
// Description: Compares to ip addresses to determine whether they are equal.
//
// Parameters:  uchar *Inet1: pointer to array of uchars.
//      uchar *Inet2: pointer to array of uchars.
//
// Returns: ulong: TRUE if the addresses are equal, FALSE otherwise.
//
// History:
//  12/16/93  JayPh Created.
//
//*****************************************************************************

ulong InetEqual( uchar *Inet1, uchar *Inet2 )
{
    if ( ( Inet1[0] == Inet2[0] ) && ( Inet1[1] == Inet2[1] ) &&
         ( Inet1[2] == Inet2[2] ) && ( Inet1[3] == Inet2[3] ) )
    {
        return TRUE;
    }
    return FALSE;
}


//*****************************************************************************
//
// Name:    PutMsg
//
// Description: Reads a message resource, formats it in the current language
//      and displays the message.
//
// Parameters:  ulong Handle: device to display message on.
//      ulong MsgNum: ID of the message resource.
//
// Returns: ulong: number of characters displayed.
//
// History:
//  01/05/93   JayPh    Created.
//  25-Nov-96. MohsinA, CR-CR-LF => CR-LF  = 0d0a = \r\n.
//
//*****************************************************************************

ulong
PutMsg(ulong Handle, ulong MsgNum, ... )
{
    ulong     msglen;
    uchar    *vp;
    va_list   arglist;
    FILE *    pfile;

    va_start( arglist, MsgNum );
    msglen = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                            | FORMAT_MESSAGE_FROM_HMODULE
                            // | FORMAT_MESSAGE_MAX_WIDTH_MASK
                            ,
                            NULL,
                            MsgNum,
                            0L,     // Default country ID.
                            (LPTSTR)&vp,
                            0,
                            &arglist );
    if ( msglen == 0 )
    {
        return ( 0 );
    }

    pfile = (Handle == 2) ? stderr : stdout;
    _setmode( _fileno(pfile), O_BINARY );

    // Convert vp to oem
    CharToOemBuff((LPCTSTR)vp,(LPSTR)vp,strlen(vp));
    
    fprintf( pfile, "%s", vp );

    LocalFree( vp );

    return ( msglen );
}


//*****************************************************************************
//
// Name:    LoadMsg
//
// Description: Reads and formats a message resource and returns a pointer
//      to the buffer containing the formatted message.  It is the
//      responsibility of the caller to free the buffer.
//
// Parameters:  ulong MsgNum: ID of the message resource.
//
// Returns: uchar *: pointer to the message buffer, NULL if error.
//
// History:
//  01/05/93  JayPh Created.
//
//*****************************************************************************

uchar *LoadMsg( ulong MsgNum, ... )
{
    ulong     msglen;
    uchar    *vp;
    va_list   arglist;

    va_start( arglist, MsgNum );
    msglen = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_HMODULE,
                    NULL,
                    MsgNum,
                    0L,     // Default country ID.
                    (LPTSTR)&vp,
                    0,
                    &arglist );
    if ( msglen == 0 )
    {
        return(0);
    }

    return ( vp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\common2\common2.h ===
//*****************************************************************************
//
// Name:	snmpinfo.h
//
// Description:	
//
// History:
//  01/13/94  JayPh	Created.
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1994 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************


//
// Include Files
//

#include "ipexport.h"
#include "ipinfo.h"
#include "llinfo.h"
#include "tcpinfo.h"


//
// Definitions
//

#define MAX_ID_LENGTH		50

// Table Types

#define TYPE_IF             0
#define TYPE_IP             1
#define TYPE_IPADDR         2
#define TYPE_ROUTE          3
#define TYPE_ARP            4
#define TYPE_ICMP           5
#define TYPE_TCP            6
#define TYPE_TCPCONN        7
#define TYPE_UDP            8
#define TYPE_UDPCONN        9
#define TYPE_IP6           10
#define TYPE_TCP6          11
#define TYPE_TCP6CONN      12
#define TYPE_UDP6          13
#define TYPE_UDP6LISTENER  14
#define TYPE_ICMP6         15
#define TYPE_MAX           TYPE_ICMP6


//
// Structure Definitions
//

typedef struct _GenericTable {
    LIST_ENTRY  ListEntry;
} GenericTable;

typedef struct _IfEntry {
    LIST_ENTRY  ListEntry;
    IFEntry     Info;
} IfEntry;

typedef struct _IpEntry {
    LIST_ENTRY  ListEntry;
    IPSNMPInfo  Info;
} IpEntry;

typedef struct _IpAddrEntry {
    LIST_ENTRY   ListEntry;
    IPAddrEntry  Info;
} IpAddrEntry;

typedef struct _RouteEntry {
    LIST_ENTRY    ListEntry;
    IPRouteEntry  Info;
} RouteEntry;

typedef struct _ArpEntry {
    LIST_ENTRY         ListEntry;
    IPNetToMediaEntry  Info;
} ArpEntry;

typedef struct _IcmpEntry {
    LIST_ENTRY  ListEntry;
    ICMPStats   InInfo;
    ICMPStats   OutInfo;
} IcmpEntry;

typedef struct _Icmp6Entry {
    LIST_ENTRY    ListEntry;
    ICMPv6Stats   InInfo;
    ICMPv6Stats   OutInfo;
} Icmp6Entry;

typedef struct _TcpEntry {
    LIST_ENTRY  ListEntry;
    TCPStats    Info;
} TcpEntry;

typedef struct _TcpConnEntry {
    LIST_ENTRY         ListEntry;
    TCPConnTableEntry  Info;
} TcpConnEntry;

typedef struct _Tcp6ConnEntry {
    LIST_ENTRY         ListEntry;
    TCP6ConnTableEntry Info;
} Tcp6ConnEntry;

typedef struct _UdpEntry {
    LIST_ENTRY  ListEntry;
    UDPStats    Info;
} UdpEntry;

typedef struct _UdpConnEntry {
    LIST_ENTRY  ListEntry;
    UDPEntry    Info;
} UdpConnEntry;

typedef struct _Udp6ListenerEntry {
    LIST_ENTRY        ListEntry;
    UDP6ListenerEntry Info;
} Udp6ListenerEntry;


//
// Function Prototypes
//

ulong InitSnmp( void );
void *GetTable( ulong Type, ulong *pResult );
void FreeTable( GenericTable *pList );
ulong MapSnmpErrorToNt( ulong ErrCode );
ulong InetEqual( uchar *Inet1, uchar *Inet2 );
ulong PutMsg(ulong Handle, ulong MsgNum, ... );
uchar *LoadMsg( ulong MsgNum, ... );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\ipconfig\display.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    display.c

Abstract:

    format the network info for display

--*/

#include <precomp.h>

#define STATIC_BUFFER_LENGTH 100

LCID GetSupportedUserLocale(void);

DWORD
NodeTypeMap[][2] = {
    NodeTypeUnknown, MSG_NODE_TYPE_UNKNOWN,
    NodeTypeBroadcast, MSG_NODE_TYPE_BROADCAST,
    NodeTypeMixed, MSG_NODE_TYPE_MIXED,
    NodeTypeHybrid, MSG_NODE_TYPE_HYBRID,
    NodeTypePeerPeer, MSG_NODE_TYPE_PEER_PEER
};

DWORD
IfTypeMap[][2] = {
    IfTypeUnknown, MSG_IF_TYPE_UNKNOWN,
    IfTypeOther, MSG_IF_TYPE_OTHER,
    IfTypeEthernet, MSG_IF_TYPE_ETHERNET,
    IfTypeTokenring, MSG_IF_TYPE_TOKENRING,
    IfTypeFddi, MSG_IF_TYPE_FDDI,
    IfTypeLoopback, MSG_IF_TYPE_LOOPBACK,
    IfTypePPP, MSG_IF_TYPE_PPP,
    IfTypeSlip, MSG_IF_TYPE_SLIP,
    IfTypeTunnel, MSG_IF_TYPE_TUNNEL,
    IfType1394, MSG_IF_TYPE_OTHER
};

DWORD
InternalErrorMap[][2] = {
    GlobalHostNameFailure, MSG_FAILURE_HOST_NAME,
    GlobalDomainNameFailure, MSG_FAILURE_DOM_NAME,
    GlobalEnableRouterFailure, MSG_FAILURE_ENABLE_ROUTER,
    GlobalEnableDnsFailure, MSG_FAILURE_ENABLE_DNS,
    GlobalIfTableFailure, MSG_FAILURE_IF_TABLE,
    GlobalIfInfoFailure, MSG_FAILURE_IF_INFO,
    GlobalAddrTableFailure, MSG_FAILURE_ADDR_TABLE,
    GlobalRouteTableFailure, MSG_FAILURE_ROUTE_TABLE,
    InterfaceUnknownType, MSG_FAILURE_UNKNOWN_IF,
    InterfaceUnknownFriendlyName, MSG_FAILURE_UNKNOWN_NAME,
    InterfaceUnknownMediaStatus, MSG_FAILURE_UNKNOWN_MEDIA_STATUS,
    InterfaceUnknownTcpipDevice, MSG_FAILURE_UNKNOWN_TCPIP_DEVICE,
    InterfaceOpenTcpipKeyReadFailure, MSG_FAILURE_OPEN_KEY,
    InterfaceDhcpValuesFailure, MSG_FAILURE_DHCP_VALUES,
    InterfaceDnsValuesFailure, MSG_FAILURE_DNS_VALUES,
    InterfaceWinsValuesFailure, MSG_FAILURE_WINS_VALUES,
    InterfaceAddressValuesFailure, MSG_FAILURE_ADDRESS_VALUES,
    InterfaceRouteValuesFailure, MSG_FAILURE_ROUTE_VALUES,
    NoSpecificError, MSG_FAILURE_NO_SPECIFIC,
};

#define Dimension(X) (sizeof(X)/sizeof(X[0]))

DWORD
MapNodeType(
    IN DWORD NodeType
    )
{
    DWORD i;
    for( i = 0; i < Dimension(NodeTypeMap); i ++ )
        if( NodeTypeMap[i][0] == NodeType ) return NodeTypeMap[i][1];

    return MSG_NODE_TYPE_UNKNOWN;
}

static DWORD 
MapIfType(
    IN DWORD IfType
    )
{
    DWORD i;
    for( i = 0; i < Dimension(IfTypeMap); i ++ )
        if( IfTypeMap[i][0] == IfType ) return IfTypeMap[i][1];

    return MSG_IF_TYPE_UNKNOWN;
}

DWORD
MapInternalError(
    IN DWORD InternalError
    )
{
    DWORD i;
    for( i = 0; i < Dimension(InternalErrorMap); i ++ )
        if( InternalErrorMap[i][0] == InternalError ) {
            return InternalErrorMap[i][1];
        }

    return 0;
}

DWORD
DumpMessage(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN ULONG MsgId,
    ...
    )
{
    va_list ArgPtr;
    ULONG Count;

    va_start(ArgPtr, MsgId);
    Count = wcslen(Buffer);
    Buffer += Count; BufSize -= Count;
    
    Count = FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE, NULL, // use default module
        MsgId, 0 /* default language */, Buffer, BufSize, &ArgPtr );

    if( Count == 0 ) return GetLastError();
    return NO_ERROR;
}

DWORD
DumpMessageError(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN ULONG MsgId,
    IN ULONG_PTR Error,
    IN PVOID Arg OPTIONAL
    )
{
    va_list ArgPtr;
    ULONG Count;
    WCHAR ErrorString[200];
    
    Count = FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM, NULL, // use default Module
        (ULONG)Error, 0 /* default language */, ErrorString, 200,
        NULL );
    if( 0 == Count ) swprintf((LPWSTR)ErrorString, (LPWSTR)L"0x%lx.", Error);

    Error = (ULONG_PTR)ErrorString;

    return DumpMessage( Buffer, BufSize, MsgId, Error, Arg );
}

DWORD
DumpErrorMessage(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN ULONG InternalError,
    IN ULONG Win32Error
    )
{
    ULONG Count;
    WCHAR ErrorString[200];
    
    Count = FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM, NULL, // use default Module
        Win32Error, 0 /* default language */, ErrorString, 200,
        NULL );
    if( 0 == Count ) swprintf((LPWSTR)ErrorString, (LPWSTR)L"0x%lx.", Win32Error);

    return DumpMessage(
        Buffer, BufSize, MapInternalError(InternalError),
        (LPWSTR)ErrorString );
}

LPWSTR
MapIp(
    IN DWORD IpAddress, // network order
    IN LPWSTR Buffer
    )
{
    LPSTR Ip = inet_ntoa( *(struct in_addr*)&IpAddress);

    if( NULL == Ip ) wcscpy(Buffer, (LPWSTR)L"0.0.0.0" );
    else {
        MultiByteToWideChar(
            CP_ACP, 0, Ip, -1, Buffer, STATIC_BUFFER_LENGTH );
    }

    return Buffer;
}

LPWSTR
MapIpv6(
    IN LPSOCKADDR_IN6 SockAddr,
    IN LPWSTR Buffer
    )
{
    DWORD BufferLength = STATIC_BUFFER_LENGTH;
    DWORD Error;
    static DWORD Initialized = FALSE;

    if (!Initialized) {
        WSADATA WsaData;
        WSAStartup(MAKEWORD(2,0), &WsaData);
        Initialized = TRUE;
    }

    Error = WSAAddressToStringW((LPSOCKADDR)SockAddr,
                                sizeof(SOCKADDR_IN6),
                                NULL,
                                Buffer,
                                &BufferLength);

    if (Error != NO_ERROR) {
        Error = WSAGetLastError();
        wcscpy(Buffer, L"?");
    }

    return Buffer;
}

DWORD
GetCommandArgConstants(
    IN OUT PCMD_ARGS Args
    )
{
    DWORD Error, i;
    struct _local_struct {
        LPWSTR *Str;
        DWORD MsgId;
    } Map[] = {
        &Args->All, MSG_CMD_ALL,
        &Args->Renew, MSG_CMD_RENEW,
        &Args->Release, MSG_CMD_RELEASE,
        &Args->FlushDns, MSG_CMD_FLUSHDNS,
        &Args->DisplayDns, MSG_CMD_DISPLAYDNS,
        &Args->Register, MSG_CMD_REGISTER,
        &Args->ShowClassId, MSG_CMD_SHOWCLASSID,
        &Args->SetClassId, MSG_CMD_SETCLASSID,
        &Args->Debug, MSG_CMD_DEBUG,
        &Args->Usage, MSG_CMD_USAGE,
        &Args->UsageErr, MSG_CMD_USAGE_ERR,
        NULL, 0
    };

    i = 0;
    while( Map[i].Str ) {
        Error = FormatMessageW(
            FORMAT_MESSAGE_FROM_HMODULE |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL, // use default module
            Map[i].MsgId, 0 /* default language */,
            (LPVOID)Map[i].Str, 0, NULL );
        if( 0 == Error ) return GetLastError();
        i ++;
    }

    return NO_ERROR;
}
        

DWORD
FormatTime(
    IN FILETIME *Time,
    IN LPWSTR TimeStr,
    IN ULONG TimeStrSize
    )
{
    DWORD Count;
    FILETIME FileTime;
    SYSTEMTIME SysTime;

    FileTimeToLocalFileTime( Time, &FileTime );
    FileTimeToSystemTime( &FileTime, &SysTime );

    Count = GetDateFormat(
        GetSupportedUserLocale(), DATE_LONGDATE, &SysTime, NULL,
        TimeStr, TimeStrSize );

    if( Count == 0 ) return GetLastError();
    if( Count == TimeStrSize ) return ERROR_INSUFFICIENT_BUFFER;


    TimeStr+= Count-1;
    TimeStrSize -= Count;
    *TimeStr++ = L' ';
 
    Count = GetTimeFormat(
        GetSupportedUserLocale(), 0, &SysTime, NULL, TimeStr,
        TimeStrSize );

    if( Count == 0 ) return GetLastError();

    return NO_ERROR;
}

VOID
FormatPerInterfaceInfo(
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize, // in WCHARs
    IN PINTERFACE_NETWORK_INFO IfInfo,
    IN BOOL fVerbose,
    IN BOOL fDebug
    )
{
    LPWSTR Str;
    WCHAR Phys[STATIC_BUFFER_LENGTH];
    DWORD i, MsgId, Addr, Error, HeaderDisplayed;

    //
    // Skip tunnels with no addresses.
    //

    if (!fVerbose && (IfInfo->IfType == IfTypeTunnel) && 
        (IfInfo->nIpv6Addresses == 0) && (IfInfo->nIpAddresses == 0))
        return;
    
    if( NULL != IfInfo->ConnectionName && 
        IfInfo->ConnectionName[0] != L'\0')
        Str = IfInfo->ConnectionName;
    else
        Str = IfInfo->DeviceGuidName;

    //
    // adapter title
    //
    
    DumpMessage(
        Buffer, BufSize, MapIfType(IfInfo->IfType), Str );
    if( fDebug ) {
        DumpMessage(
            Buffer, BufSize, MSG_DEVICE_GUID,
            IfInfo->DeviceGuidName );
    }

    //
    // media status
    //
    
    if( IfInfo->MediaDisconnected ) {
        DumpMessage(
            Buffer, BufSize, MSG_MEDIA_DISCONNECTED );
    }

    //
    // domain name
    //
    
    if( fDebug || !IfInfo->MediaDisconnected ) {
        DumpMessage(
            Buffer, BufSize, MSG_DOMAIN_NAME, IfInfo->DnsSuffix );
    }

    if( fVerbose ) {

        //
        // card name
        //
        
        Str = IfInfo->FriendlyName;
        if( NULL != Str ) {
            DumpMessage(
                Buffer, BufSize, MSG_FRIENDLY_NAME, Str );
        }

        //
        // mac address
        //
        
        Str = (LPWSTR)Phys;
        if( IfInfo->PhysicalNameLength ) {
            for( i = 0; i < IfInfo->PhysicalNameLength; i ++ ) {
                swprintf(Str, (LPWSTR) L"%02X-", (UCHAR)IfInfo->PhysicalName[i] );
                Str += 3;
            }

            Str --; *Str = L'\0';

            DumpMessage(
                Buffer, BufSize, MSG_PHYSICAL_ADDRESS, (LPWSTR)Phys );
        }

        // 
        // dhcp and autoconfig enabled status
        //
        
        if( !IfInfo->MediaDisconnected ) {
            MsgId = MSG_DHCP_DISABLED + IfInfo->EnableDhcp;

            DumpMessage( Buffer, BufSize, MsgId );

            if( IfInfo->EnableDhcp ) {
                MsgId = MSG_AUTOCONFIG_DISABLED + IfInfo->EnableAutoconfig;

                DumpMessage( Buffer, BufSize, MsgId );
            }
        }
    }

    if( IfInfo->MediaDisconnected && !fDebug ) return;

    //
    // ip address and mask
    //
    
    if( IfInfo->IpAddress && IfInfo->nIpAddresses ) {
        for( i = IfInfo->nIpAddresses-1; i > 0; i -- ) {
            DumpMessage(
                Buffer, BufSize, MSG_IP_ADDRESS, 
                MapIp(IfInfo->IpAddress[i], (LPWSTR) Phys) );

            if( IfInfo->nIpMasks <= i ) Addr = 0;
            else Addr = IfInfo->IpMask[i];

            DumpMessage(
                Buffer, BufSize, MSG_SUBNET_MASK,
                MapIp(Addr, (LPWSTR) Phys ));
        }

        if( IfInfo->AutoconfigActive ) MsgId = MSG_AUTO_ADDRESS;
        else MsgId = MSG_IP_ADDRESS;

        DumpMessage(
            Buffer, BufSize, MsgId,
            MapIp(*IfInfo->IpAddress, (LPWSTR) Phys) );

        if( NULL != IfInfo->IpMask ) Addr = *IfInfo->IpMask;
        else Addr = 0;
        
        DumpMessage(
            Buffer, BufSize, MSG_SUBNET_MASK,
            MapIp(Addr, (LPWSTR) Phys) );
    }
    if( IfInfo->Ipv6Address && IfInfo->nIpv6Addresses ) {
        for( i = 0; i < IfInfo->nIpv6Addresses; i ++ ) {
            DumpMessage(
                Buffer, BufSize, MSG_IP_ADDRESS, 
                MapIpv6(&IfInfo->Ipv6Address[i], (LPWSTR) Phys) );
        }
    }

    //
    // default gateways
    //
    HeaderDisplayed = FALSE;
    for( i = 0; i < IfInfo->nRouters; i ++ ) {
        if (!HeaderDisplayed) {
            DumpMessage(
                Buffer, BufSize, MSG_DEFAULT_GATEWAY,
                MapIp( IfInfo->Router[i], (LPWSTR)Phys));
            HeaderDisplayed = TRUE;
        } else {
            DumpMessage(
                Buffer, BufSize, MSG_ADDITIONAL_ENTRY,
                MapIp( IfInfo->Router[i], (LPWSTR)Phys) );
        }
    }
    for( i = 0; i < IfInfo->nIpv6Routers; i ++ ) {
        if (!HeaderDisplayed) {
            DumpMessage(
                Buffer, BufSize, MSG_DEFAULT_GATEWAY,
                MapIpv6( &IfInfo->Ipv6Router[i], (LPWSTR)Phys));
            HeaderDisplayed = TRUE;
        } else {
            DumpMessage(
                Buffer, BufSize, MSG_ADDITIONAL_ENTRY,
                MapIpv6( &IfInfo->Ipv6Router[i], (LPWSTR)Phys) );
        }
    }
    if (!HeaderDisplayed) {
        DumpMessage(Buffer, BufSize, MSG_DEFAULT_GATEWAY, L"");
    }

    //
    // dhcp classid
    //
    
    if( NULL != IfInfo->DhcpClassId ) {
        DumpMessage(
            Buffer, BufSize, MSG_DHCP_CLASS_ID,
            IfInfo->DhcpClassId );
    }

    if( !fVerbose ) return;

    //
    // dhcp server and dns servers
    //
    
    if( IfInfo->EnableDhcp && !IfInfo->AutoconfigActive ) {
        DumpMessage(
            Buffer, BufSize, MSG_DHCP_SERVER,
            MapIp( IfInfo->DhcpServer, (LPWSTR)Phys) );
    }

    HeaderDisplayed = FALSE;
    if( IfInfo->nDnsServers && IfInfo->DnsServer) {
        DumpMessage(
            Buffer, BufSize, MSG_DNS_SERVERS,
            MapIp( IfInfo->DnsServer[0], (LPWSTR)Phys) );
        HeaderDisplayed = TRUE;
        for( i = 1; i < IfInfo->nDnsServers; i ++ ) {
            DumpMessage(
                Buffer, BufSize, MSG_ADDITIONAL_ENTRY,
                MapIp( IfInfo->DnsServer[i], (LPWSTR)Phys) );
        }
    }
    if( IfInfo->nIpv6DnsServers && IfInfo->Ipv6DnsServer) {
        for( i = 0; i < IfInfo->nIpv6DnsServers; i ++ ) {
            if (!HeaderDisplayed) {
                DumpMessage(
                    Buffer, BufSize, MSG_DNS_SERVERS,
                    MapIpv6( &IfInfo->Ipv6DnsServer[i], (LPWSTR)Phys) );
                HeaderDisplayed = TRUE;
            } else {
                DumpMessage(
                    Buffer, BufSize, MSG_ADDITIONAL_ENTRY,
                    MapIpv6( &IfInfo->Ipv6DnsServer[i], (LPWSTR)Phys) );
            }
        }
    }

    //
    // wins info
    //
    
    if( IfInfo->nWinsServers && IfInfo->WinsServer ) {
        DumpMessage(
            Buffer, BufSize, MSG_WINS_SERVER_1,
            MapIp( IfInfo->WinsServer[0], (LPWSTR)Phys) );
    }

    if( IfInfo->nWinsServers > 1 && IfInfo->WinsServer ) {
        DumpMessage(
            Buffer, BufSize, MSG_WINS_SERVER_2,
            MapIp( IfInfo->WinsServer[1], (LPWSTR)Phys) );
        for( i = 2; i < IfInfo->nWinsServers; i ++ ) {
            DumpMessage(
                Buffer, BufSize, MSG_ADDITIONAL_ENTRY,
                MapIp( IfInfo->WinsServer[i], (LPWSTR)Phys) );
        }
    }
    
    if( !IfInfo->EnableNbtOverTcpip ) {
        DumpMessage(
            Buffer, BufSize, MSG_NETBIOS_DISABLED );
    }

    if( IfInfo->EnableDhcp && !IfInfo->AutoconfigActive
        && IfInfo->nIpAddresses && IfInfo->IpAddress &&
        IfInfo->IpAddress[0] ) {

        WCHAR TimeString[STATIC_BUFFER_LENGTH];

        Error = FormatTime(
            (FILETIME *)(&IfInfo->LeaseObtainedTime), (LPWSTR)TimeString, STATIC_BUFFER_LENGTH);
        if( NO_ERROR == Error ) {
            DumpMessage(
                Buffer, BufSize, MSG_LEASE_OBTAINED, TimeString );
        }

        Error = FormatTime(
            (FILETIME *)(&IfInfo->LeaseExpiresTime), (LPWSTR)TimeString, STATIC_BUFFER_LENGTH);
        if( NO_ERROR == Error ) {
            DumpMessage(
                Buffer, BufSize, MSG_LEASE_EXPIRES, TimeString );
        }
    }
        
}

#define MIN_XTRA_SPACE 1000

DWORD
FormatNetworkInfo(
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize, // in WCHARs
    IN PNETWORK_INFO NetInfo,
    IN DWORD Win32Error,
    IN DWORD InternalError,
    IN BOOL fVerbose,
    IN BOOL fDebug
    )
{
    DWORD i;
    LPWSTR Str;
    
    if( Win32Error || InternalError ) {
        DumpErrorMessage(
            Buffer, BufSize, InternalError, Win32Error );

        if( !fDebug ) return NO_ERROR;
    }

    if( NULL == NetInfo ) return NO_ERROR;

    if( fDebug ) fVerbose = TRUE;

    //
    // dump globals
    //
    
    if( fVerbose ) {
        DumpMessage(
            Buffer, BufSize, MSG_HOST_NAME, NetInfo->HostName );
        DumpMessage(
            Buffer, BufSize, MSG_PRIMARY_DNS_SUFFIX,
            NetInfo->DomainName );
        DumpMessage(
            Buffer, BufSize, MapNodeType(NetInfo->NodeType) );
        DumpMessage(
            Buffer, BufSize, MSG_ROUTING_DISABLED +
            NetInfo->EnableRouting );
        if (NetInfo->EnableProxy) {
            DumpMessage(
                Buffer, BufSize, MSG_WINS_PROXY_ENABLED);
        } else {
            DumpMessage(
                Buffer, BufSize, MSG_WINS_PROXY_DISABLED);
        }

        if( NULL != NetInfo->SuffixSearchList ) {
            DumpMessage(
                Buffer, BufSize, MSG_DNS_SUFFIX_LIST,
                NetInfo->SuffixSearchList );
            Str = NetInfo->SuffixSearchList;
            Str += wcslen(Str); Str++;
            
            while( wcslen(Str) ) {
                DumpMessage(
                    Buffer, BufSize, MSG_ADDITIONAL_ENTRY, Str );
                Str += wcslen(Str); Str ++;
            }
        }
    }

    //
    // dump per interface stuff
    //

    for( i = 0; i < NetInfo->nInterfaces; i++ ) {
        if( NULL != NetInfo->IfInfo &&
            NULL != NetInfo->IfInfo[i] ) {
            FormatPerInterfaceInfo(
                Buffer, BufSize, NetInfo->IfInfo[i], fVerbose, fDebug );
        }
    }

    if( wcslen(Buffer) + MIN_XTRA_SPACE > BufSize ) {
        return ERROR_MORE_DATA;
    }

    return NO_ERROR;
}

/*******************************************************************************
 *
 *
 *  GetSupportedUserLocale
 *
 *  If LOCALE_USER_DEFAULT is not supported in the console it will return
 *  English US (409)
 *
 *******************************************************************************/
LCID GetSupportedUserLocale(void)
{
    LCID lcid = GetUserDefaultLCID();
    if (
        (PRIMARYLANGID(lcid) == LANG_ARABIC) ||
        (PRIMARYLANGID(lcid) == LANG_HEBREW) ||
        (PRIMARYLANGID(lcid) == LANG_THAI)   ||
        (PRIMARYLANGID(lcid) == LANG_HINDI)  ||
        (PRIMARYLANGID(lcid) == LANG_TAMIL)  ||
        (PRIMARYLANGID(lcid) == LANG_FARSI)
        )
    {
        lcid = MAKELCID (MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT); // 0x409;
    }
    return lcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\common\tcpcmd.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpcmd.h

Abstract:

    Common header file for all tcpcmd programs.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

#ifndef TCPCMD_INCLUDED
#define TCPCMD_INCLUDED

#ifndef WIN16
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif // WIN16

#define NOGDI
#define NOMINMAX
#include <windef.h>
#include <winbase.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#ifndef WIN16
#endif // WIN16
#include <direct.h>
#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <nls.h>

//
// global variable declarations
//
extern int   optind;
extern int   opterr;
extern char *optarg;


//
// function prototypes
//

char *
GetFileFromPath(
        char *);

HANDLE
OpenStream(
        char *);

int
lwccmp(
        char *,
        char *);

long
netnumber(
        char *);

long
hostnumber(
        char *);

void
blkfree(
        char **);

struct sockaddr_storage *
resolve_host(
        char *,
        int *);

int
resolve_port(
        char *,
        char *);

char *
tempfile(
        char *);

char *
udp_alloc(
        unsigned int);

void
udp_close(
        SOCKET);

void
udp_free(
        char *);

SOCKET
udp_open(
        int,
        int *);

int
udp_port(void);

int
udp_port_used(
        int,
        int);

int
udp_read(
        SOCKET,
        char *,
        int,
        struct sockaddr_storage *,
        int *,
        int);

int
udp_write(
        SOCKET,
        char *,
        int,
        struct sockaddr_storage *,
        int);

void
gate_ioctl(
        HANDLE,
        int,
        int,
        int,
        long,
        long);

void
get_route_table(void);

int
tcpcmd_send(
    SOCKET  s,        // socket descriptor
    char          *buf,      // data buffer
    int            len,      // length of data buffer
    int            flags     // transmission flags
    );

void
s_perror(
        char *yourmsg,  // your message to be displayed
        int  lerrno     // errno to be converted
        );


void fatal(char *    message);

#ifndef WIN16
struct netent *getnetbyname(IN char *name);
unsigned long inet_network(IN char *cp);
#endif // WIN16

#define perror(string)  s_perror(string, (int)GetLastError())

#define HZ              1000
#define TCGETA  0x4
#define TCSETA  0x10
#define ECHO    17
#define SIGPIPE 99

#define MAX_RETRANSMISSION_COUNT 8
#define MAX_RETRANSMISSION_TIME 8    // in seconds


// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
__inline
ULONG
FASTCALL
net_long(
    ULONG x)
{
    register ULONG byteswapped;

    byteswapped = ((x & 0x00ff00ff) << 8) | ((x & 0xff00ff00) >> 8);

    return (byteswapped << 16) | (byteswapped >> 16);
}

#endif //TCPCMD_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\common2\snmpinfo.c ===
//*****************************************************************************
//
// Name:        snmpinfo.c
//
// Description: Provides functions to read tables of data from snmp.
//
// Used by:     netstat.exe, arp.exe, route.exe
//
// History:
//  01/12/94  JayPh     Created.
//  18-Feb-97 MohsinA   Fixing.
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1994 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

// #define DEBUG

//
// Include Files
//

#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <stdio.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#include "ipexport.h"
#include "llinfo.h"
#include "ipinfo.h"
#include "tcpinfo.h"
#include "common2.h"
#include "mdebug.h"
#include "iprtrmib.h"
#include "ntddip.h"
#include "iphlpstk.h"

ulong verbose = 0;

//
// Definitions
//

#define MGMTAPI_DLL             "mgmtapi.dll"
#define INETMIB1_DLL            "inetmib1.dll"

#define MAX_ID_LENGTH           50
#define MAX_RETRY_COUNT         10

// Interface ID values

#define ID_IF_INDEX             1
#define ID_IF_DESC              2
#define ID_IF_TYPE              3
#define ID_IF_MTU               4
#define ID_IF_SPEED             5
#define ID_IF_PHYSADDR          6
#define ID_IF_ADMINSTATUS       7
#define ID_IF_OPERSTATUS        8
#define ID_IF_LASTCHANGE        9
#define ID_IF_INOCTETS          10
#define ID_IF_INUCASTPKTS       11
#define ID_IF_INNUCASTPKTS      12
#define ID_IF_INDISCARDS        13
#define ID_IF_INERRORS          14
#define ID_IF_INUKNOWNPROTOS    15
#define ID_IF_OUTOCTETS         16
#define ID_IF_OUTUCASTPKTS      17
#define ID_IF_OUTNUCASTPKTS     18
#define ID_IF_OUTDISCARDS       19
#define ID_IF_OUTERRORS         20
#define ID_IF_OUTQLEN           21

// IP ID Values

#define ID_IP_FORWARDING        1
#define ID_IP_DEFAULTTTL        2
#define ID_IP_INRECEIVES        3
#define ID_IP_INHDRERRORS       4
#define ID_IP_INADDRERRORS      5
#define ID_IP_FORWDATAGRAMS     6
#define ID_IP_INUNKNOWNPROTOS   7
#define ID_IP_INDISCARDS        8
#define ID_IP_INDELIVERS        9
#define ID_IP_OUTREQUESTS       10
#define ID_IP_OUTDISCARDS       11
#define ID_IP_OUTNOROUTES       12
#define ID_IP_REASMTIMEOUTS     13
#define ID_IP_REASMREQDS        14
#define ID_IP_REASMOKS          15
#define ID_IP_REASMFAILS        16
#define ID_IP_FRAGOKS           17
#define ID_IP_FRAGFAILS         18
#define ID_IP_FRAGCREATES       19
#define ID_IP_ADDRTABLE         20
#define ID_IP_ROUTETABLE        21
#define ID_IP_ARPTABLE          22
#define ID_IP_ROUTINGDISCARDS   23

// IPAddr ID Values

#define ID_IPADDR_ADDR          1
#define ID_IPADDR_INDEX         2
#define ID_IPADDR_MASK          3
#define ID_IPADDR_BCASTADDR     4
#define ID_IPADDR_REASMSIZE     5

// Route ID values

#define ID_ROUTE_DEST           1
#define ID_ROUTE_IFINDEX        2
#define ID_ROUTE_METRIC1        3
#define ID_ROUTE_METRIC2        4
#define ID_ROUTE_METRIC3        5
#define ID_ROUTE_METRIC4        6
#define ID_ROUTE_NEXTHOP        7
#define ID_ROUTE_TYPE           8
#define ID_ROUTE_PROTO          9
#define ID_ROUTE_AGE            10
#define ID_ROUTE_MASK           11
#define ID_ROUTE_METRIC5        12

// ARP ID Values

#define ID_ARP_IFINDEX          1
#define ID_ARP_PHYSADDR         2
#define ID_ARP_NETADDR          3
#define ID_ARP_TYPE             4

// ICMP ID Values

#define ID_ICMP_INMSGS                  1
#define ID_ICMP_INERRORS                2
#define ID_ICMP_INDESTUNREACHES         3
#define ID_ICMP_INTIMEEXCDS             4
#define ID_ICMP_INPARMPROBS             5
#define ID_ICMP_INSRCQUENCHS            6
#define ID_ICMP_INREDIRECTS             7
#define ID_ICMP_INECHOS                 8
#define ID_ICMP_INECHOREPS              9
#define ID_ICMP_INTIMESTAMPS            10
#define ID_ICMP_INTIMESTAMPREPS         11
#define ID_ICMP_INADDRMASKS             12
#define ID_ICMP_INADDRMASKREPS          13
#define ID_ICMP_OUTMSGS                 14
#define ID_ICMP_OUTERRORS               15
#define ID_ICMP_OUTDESTUNREACHES        16
#define ID_ICMP_OUTTIMEEXCDS            17
#define ID_ICMP_OUTPARMPROBS            18
#define ID_ICMP_OUTSRCQUENCHS           19
#define ID_ICMP_OUTREDIRECTS            20
#define ID_ICMP_OUTECHOS                21
#define ID_ICMP_OUTECHOREPS             22
#define ID_ICMP_OUTTIMESTAMPS           23
#define ID_ICMP_OUTTIMESTAMPREPS        24
#define ID_ICMP_OUTADDRMASKS            25
#define ID_ICMP_OUTADDRMASKREPS         26

// TCP ID Values

#define ID_TCP_RTOALGORITHM     1
#define ID_TCP_RTOMIN           2
#define ID_TCP_RTOMAX           3
#define ID_TCP_MAXCONN          4
#define ID_TCP_ACTIVEOPENS      5
#define ID_TCP_PASSIVEOPENS     6
#define ID_TCP_ATTEMPTFAILS     7
#define ID_TCP_ESTABRESETS      8
#define ID_TCP_CURRESTABS       9
#define ID_TCP_INSEGS           10
#define ID_TCP_OUTSEGS          11
#define ID_TCP_RETRANSSEGS      12
#define ID_TCP_CONNTABLE        13
#define ID_TCP_INERRS           14
#define ID_TCP_OUTRSTS          15

// TCP CONN ID Values

#define ID_TCPCONN_STATE        1
#define ID_TCPCONN_LOCALADDR    2
#define ID_TCPCONN_LOCALPORT    3
#define ID_TCPCONN_REMOTEADDR   4
#define ID_TCPCONN_REMOTEPORT   5

// TCP New CONN ID Values (both IPv4 and IPv6)

#define ID_TCPNEWCONN_LOCALADDRTYPE  1
#define ID_TCPNEWCONN_LOCALADDR      2
#define ID_TCPNEWCONN_LOCALPORT      3
#define ID_TCPNEWCONN_REMOTEADDRTYPE 4
#define ID_TCPNEWCONN_REMOTEADDR     5
#define ID_TCPNEWCONN_REMOTEPORT     6
#define ID_TCPNEWCONN_STATE          7

// UDP ID Values

#define ID_UDP_INDATAGRAMS      1
#define ID_UDP_NOPORTS          2
#define ID_UDP_INERRORS         3
#define ID_UDP_OUTDATAGRAMS     4
#define ID_UDP_CONNTABLE        5

// UDP CONN ID Values

#define ID_UDPCONN_LOCALADDR    1
#define ID_UDPCONN_LOCALPORT    2

// UDP LISTENER ID Values (both IPv4 and IPv6)

#define ID_UDPLISTENER_LOCALADDRTYPE 1
#define ID_UDPLISTENER_LOCALADDR     2
#define ID_UDPLISTENER_LOCALPORT     3

//
// Structure Definitions
//

typedef struct _OIDdef {
    ulong  Length;
    ulong  Val[MAX_ID_LENGTH];
    ulong  EntElemOffset;
    ulong  BackOffset;
} OIDdef;


//
// Local Function Prototypes
//

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size );
void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );
void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );
void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid );
void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid );
void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid );
void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );
void SaveData_TCP6CONN( GenericTable    *pEntry,
                        RFC1157VarBind   item,
                        OIDdef          *pOid );
void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );
void SaveData_UDP6LISTENER( GenericTable    *pEntry,
                            RFC1157VarBind   item,
                            OIDdef          *pOid );

//
// Global Variables
//

// These are used to create object id's

OIDdef PreambleDef   = { 6, { 1,  3,  6, 1, 2, 1 },  0, 0 };
OIDdef IfInfoDef     = { 4, { 2,  2,  1, 1       },  9, 2 };
OIDdef IPInfoDef     = { 2, { 4,  1              },  7, 1 };
OIDdef IPAddrInfoDef = { 4, { 4,  20, 1, 1       },  9, 2 };
OIDdef RouteInfoDef  = { 4, { 4,  21, 1, 1       },  9, 2 };
OIDdef ARPInfoDef    = { 4, { 4,  22, 1, 1       },  9, 2 };
OIDdef ICMPInfoDef   = { 2, { 5,  1,             },  7, 1 };
OIDdef TCPConnDef    = { 4, { 6, 13,  1, 1       },  9, 2 };
OIDdef UDPConnDef    = { 4, { 7,  5,  1, 1       },  9, 2 };

//
// In the current MIB drafts, the TCP/UDP stats are combined for both IPv4 
// and IPv6.  As a result, we can't query the MIB objects any more if
// we want to show separate stats for IPv4 vs IPv6.
//
// OIDdef TCPInfoDef    = { 2, { 6,  1              },  7, 1 };
// OIDdef UDPInfoDef    = { 2, { 7,  1              },  7, 1 };

OIDdef TCP6ConnDef   = { 4, { 6, 19,  1, 1       },  9, 2 };
OIDdef UDP6ListenerDef={ 4, { 7,  7,  1, 1       },  9, 2 };

// These are used to hold the addresses of the functions we use in inetmib1.dll

FARPROC   gQueryAddr;
FARPROC   gInitAddr;

//
// From //ORVILLE/RAZZLE/src/net/snmp/agent/mgmtapi/mgmtapi.c
// See  //ORVILLE/RAZZLE/src/public/sdk/inc/snmp.h
//          SNMP_FUNC_TYPE is WINAPI.
//
// These pointer to functions are imported from mgmtapi.dll (available
// on nt server only with snmp service, but can be copied).
// - MohsinA, 11-Mar-97.
//

BOOL (SNMP_FUNC_TYPE * pSnmpMgrOidToStr )( IN  AsnObjectIdentifier *oid,
                                            OUT LPSTR           *string );


//
// Exported Functions
//

//*****************************************************************************
//
// Name:        InitSnmp
//
// Description: Set up to use inetmib1.dll.  Load the DLL, and get addresses
//              for the interesting procedures.
//              NOTE: This function must be called before calling GetTable().
//
// Parameters:  void.
//
// Returns:     ulong: NO_ERROR if successful, error code otherwise.
//
// History:
//  12/20/93  JayPh     Created.
//
//*****************************************************************************

ulong InitSnmp( void )
{
    HANDLE                     hExtension;
    ulong                      TimeZeroReference;
    HANDLE                     hPollForTrapEvent;
    AsnObjectIdentifier        SupportedView;
    HANDLE                     mgmtapi_dll;
    CHAR                       Path[MAX_PATH + 1 + max(sizeof(MGMTAPI_DLL),
                                                       sizeof(INETMIB1_DLL))
                                             + 2];
    CHAR                      *FileName;

    TimeZeroReference = (ulong)time( (time_t *)0 );

    if (GetSystemDirectory(Path, MAX_PATH) == 0) {
        return GetLastError();
    }
    FileName = Path + strlen(Path);

    // Load the management apis, only on servers, but useful for
    // figuring out snmp jargon.

    if( verbose ){
        strcpy( FileName, "\\" MGMTAPI_DLL );
        mgmtapi_dll = LoadLibraryA( Path );
        if( mgmtapi_dll ){
            pSnmpMgrOidToStr
            = (LPVOID) GetProcAddress( mgmtapi_dll, "SnmpMgrOidToStr" );
        }
        if( !mgmtapi_dll || !pSnmpMgrOidToStr ){
            DEBUG_PRINT((
                "InitSnmp: mgmtapi.dll:pSnmpMgrOidToStr() not found.\n"
            ));
        }
    }



    // Load inetmib1.dll and get proc address for SnmpExtensionQuery

    strcpy( FileName, "\\" INETMIB1_DLL );
    hExtension = LoadLibraryA( Path );
    if ( hExtension == NULL )
    {
        DEBUG_PRINT(("InitSnmp: cannot load inetmib1.dll\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    gInitAddr = GetProcAddress( hExtension, "SnmpExtensionInit" );
    if ( gInitAddr == NULL )
    {
        DEBUG_PRINT(("InitSnmp: inetmib1.dll:SnmpExtensionInit missing.\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    gQueryAddr = GetProcAddress( hExtension, "SnmpExtensionQuery" );
    if ( gQueryAddr == NULL )
    {
        DEBUG_PRINT(("InitSnmp: inetmib1.dll:SnmpExtensionQuery missing.\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    // Initialize the extension DLL

    (*gInitAddr)( TimeZeroReference, &hPollForTrapEvent, &SupportedView );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        GetTable
//
// Description: Gets a consistent table from snmp.  Consistency is achieved by
//              reading the table, reading the table a second time and
//              comparing the two.  If they match, we are done.  If they don't
//              match, we read the table again and compare again.  Repeating
//              until we have a match, or our retry count exceeds a threshold.
//
// Parameters:  ulong Type: type of table to get.
//              ulong *pResult: pointer to location to receive the result code.
//
// Returns:     void *: NULL if some error, otherwise pointer to table.
//
// History:
//  01/12/94  JayPh     Created.
//  18-Feb-97 MohsinA   Removed while loop and pList1.
//*****************************************************************************

void *GetTable( ulong Type, ulong *pResult )
{
    GenericTable   *pList2;
    ulong   Result;
    ulong   RetryCount = 0;
    ulong   Size;

    if( verbose ){
        fprintf(stderr, "GetTable: type = %d\n", Type );
    }

    if ( Type > TYPE_MAX )
    {
        *pResult = ERROR_INVALID_PARAMETER;
        return ( NULL );
    }

    // Allocate memory for the list heads

    switch ( Type )
    {
    case TYPE_IF:
        Size = sizeof( IfEntry ) + MAX_IFDESCR_LEN;
        break;

    case TYPE_IP:
    case TYPE_IP6:
        Size = sizeof( IpEntry );
        break;

    case TYPE_IPADDR:
        Size = sizeof( IpAddrEntry );
        break;

    case TYPE_ROUTE:
        Size = sizeof( RouteEntry );
        break;

    case TYPE_ARP:
        Size = sizeof( ArpEntry );
        break;

    case TYPE_ICMP:
        Size = sizeof( IcmpEntry );
        break;

    case TYPE_ICMP6:
        Size = sizeof( Icmp6Entry );
        break;

    case TYPE_TCP:
    case TYPE_TCP6:
        Size = sizeof( TcpEntry );
        break;

    case TYPE_TCPCONN:
        Size = sizeof( TcpConnEntry );
        break;

    case TYPE_TCP6CONN:
        Size = sizeof( Tcp6ConnEntry );
        break;

    case TYPE_UDP:
    case TYPE_UDP6:
        Size = sizeof( UdpEntry );
        break;

    case TYPE_UDPCONN:
        Size = sizeof( UdpConnEntry );
        break;

    case TYPE_UDP6LISTENER:
        Size = sizeof( Udp6ListenerEntry );
        break;

    }

    // Don't need pList1 - MohsinA, 18-Feb-97.

    pList2 = (GenericTable *)SNMP_malloc( Size );
    if ( pList2 == NULL )
    {
        *pResult = ERROR_NOT_ENOUGH_MEMORY;
        return ( NULL );
    }

    InitializeListHead( &pList2->ListEntry );

    // Read the table into List2

    Result = ReadTable( pList2, Type, Size );
    if ( Result != NO_ERROR )
    {
        FreeTable( pList2 );
        *pResult = Result;
        return ( NULL );
    }


    // Useless while loop removed. - MohsinA, 18-Feb-97.

    *pResult = NO_ERROR;
    return ( pList2 );
}


//*****************************************************************************
//
// Name:        FreeTable
//
// Description: Free all entries in the list, including the list head.
//
// Parameters:  GenericTable *pList: pointer to head of list.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void FreeTable( GenericTable *pList )
{
    GenericTable  *pTmp;
    LIST_ENTRY    *pTmpList;

    while ( !IsListEmpty( &pList->ListEntry ) )
    {
        pTmpList = RemoveHeadList( &pList->ListEntry );
        pTmp = CONTAINING_RECORD( pTmpList,
                                  GenericTable,
                                  ListEntry );
        SNMP_free( pTmp );
    }

    SNMP_free( pList );
}


//*****************************************************************************
//
// Name:        MapSnmpErrorToNt
//
// Description: Given an Snmp error, return the 'equivalent' Nt error.
//
// Parameters:  ulong ErrCode: Snmp error code.
//
// Returns:     ulong: Nt error code.
//
// History:
//  01/05/93    JayPh   Created.
//
//*****************************************************************************

ulong MapSnmpErrorToNt( ulong ErrCode )
{
    switch ( ErrCode )
    {
    case SNMP_ERRORSTATUS_NOERROR:
        return ( NO_ERROR );

    case SNMP_ERRORSTATUS_TOOBIG:
        return ( ERROR_INVALID_PARAMETER );

    case SNMP_ERRORSTATUS_NOSUCHNAME:
        return ( ERROR_INVALID_PARAMETER );

    case SNMP_ERRORSTATUS_BADVALUE:
        return ( ERROR_INVALID_PARAMETER );

    case SNMP_ERRORSTATUS_READONLY:
        return ( ERROR_INVALID_ACCESS );

    case SNMP_ERRORSTATUS_GENERR:
        return ( ERROR_INVALID_PARAMETER );

    }
    return ( ERROR_INVALID_PARAMETER );
}


//
// Internal Functions
//

//*****************************************************************************
//
// Name:        ReadTable
//
// Description: Queries the MIB and builds a table representing the data we are
//              interested in.
//
// Parameters:  GenericTable *pList: address of uninitialized head of the entry
//                      list.
//              ulong Type: type of table we want.
//              ulong Size: size of a table entry.
//
// Returns:     ulong: NO_ERROR if no error, and table is built.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size )
{
    AsnInteger          GetNextReq = ASN_RFC1157_GETNEXTREQUEST;
    RFC1157VarBind      item;
    RFC1157VarBindList  VarBinds = { &item, 1 };
    AsnObjectIdentifier oidBackup;
    AsnInteger          ErrorStatus = 0;
    AsnInteger          ErrorIndex = 0;
    ulong              *pId;
    GenericTable       *pTable;
    ulong               LastField = 0;
    uchar              *pTmp;
    ulong               i;
    OIDdef             *pOid;
    ulong               BreakLoop = FALSE;

    if( verbose ){
        fprintf(stderr,"ReadTable: type = %d\n", Type);
    }

    switch (Type) {
    case TYPE_IP6: {
        IpEntry *pIp = (IpEntry*)pList;

        // IPStats are the same, but not in contiguous MIB oids,
        // so it's non-trivial to get them from the MIB in this
        // structure.  Instead, rather than going the long way
        // around, we can just get them directly here.

        return GetIpStatsFromStackEx((PMIB_IPSTATS)&pIp->Info, AF_INET6);
        }
    case TYPE_ICMP6: {
        Icmp6Entry *pIcmp = (Icmp6Entry*)pList;

        return GetIcmpStatsFromStackEx((PVOID)&pIcmp->InInfo, AF_INET6);
        }
    case TYPE_TCP: {
        TcpEntry *pTcp = (TcpEntry*)pList;
        
        // TCP stats for IPv4-only aren't in the MIB, so get them
        // directly from the stack.
        
        return GetTcpStatsFromStackEx((PMIB_TCPSTATS)&pTcp->Info, AF_INET);
        }
    case TYPE_TCP6: {
        TcpEntry *pTcp = (TcpEntry*)pList;
        
        // TCP stats for IPv6-only aren't in the MIB, so get them
        // directly from the stack.
        
        return GetTcpStatsFromStackEx((PMIB_TCPSTATS)&pTcp->Info, AF_INET6);
        }
    case TYPE_UDP: {
        UdpEntry *pUdp = (UdpEntry*)pList;

        // UDP stats for IPv4-only aren't in the MIB, so get them
        // directly from the stack.

        return GetUdpStatsFromStackEx((PMIB_UDPSTATS)&pUdp->Info, AF_INET);
        }
    case TYPE_UDP6: {
        UdpEntry *pUdp = (UdpEntry*)pList;

        // UDP stats for IPv6-only aren't in the MIB, so get them
        // directly from the stack.

        return GetUdpStatsFromStackEx((PMIB_UDPSTATS)&pUdp->Info, AF_INET6);
        }
    }

    // Walk SNMP database, building local table.

    pId = (ulong *)SNMP_malloc( (sizeof( ulong ) * MAX_ID_LENGTH) );
    if ( pId == NULL )
    {
        return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    item.name.ids = pId;

    // Build OID from preamble and table-specific suffix

    // Copy preamble

    for ( i = 0; i < PreambleDef.Length; i++ )
    {
        *pId++ = PreambleDef.Val[i];
    }

    // Get pointer to table-specific info

    switch ( Type )
    {
    case TYPE_IF:
        pOid = &IfInfoDef;
        break;

    case TYPE_IP:
        pOid = &IPInfoDef;
        break;

    case TYPE_IPADDR:
        pOid = &IPAddrInfoDef;
        break;

    case TYPE_ROUTE:
        pOid = &RouteInfoDef;
        break;

    case TYPE_ARP:
        pOid = &ARPInfoDef;
        break;

    case TYPE_ICMP:
        pOid = &ICMPInfoDef;
        break;

    case TYPE_TCPCONN:
        pOid = &TCPConnDef;
        break;

    case TYPE_TCP6CONN:
        pOid = &TCP6ConnDef;
        break;

    case TYPE_UDPCONN:
        pOid = &UDPConnDef;
        break;

    case TYPE_UDP6LISTENER:
        pOid = &UDP6ListenerDef;
        break;

    }

    // Copy table-specific info

    for ( i = 0; i < pOid->Length; i++ )
    {
        *pId++ = pOid->Val[i];
    }

    item.name.idLength = PreambleDef.Length + pOid->Length;
    item.value.asnType = ASN_NULL;

    pTable = pList;

    // Walk the mib until the table-specific termination condition is met.

    while( 1 )
    {
        // Get next

        (*gQueryAddr)( GetNextReq, &VarBinds, &ErrorStatus, &ErrorIndex );

        if( verbose )
        {
            int   q;

            fprintf(stderr,"value=%8d oid= ", item.value.asnValue.number );

            //
            // Print the object name, use mgmtapi.dll.
            //

            if( pSnmpMgrOidToStr ){
                LPSTR String = NULL;
                int   err;
                err = (* pSnmpMgrOidToStr )( &item.name, &String );
                if( SNMPAPI_ERROR != err ){
                    fprintf(stderr," %s ", String );
                }
                SnmpUtilMemFree( String );
            }

            if( !pSnmpMgrOidToStr || (verbose > 1) ){

                //
                // Print the oid, in ``1.3.6.1.2.1'' style.
                //

                for ( q = 0; q < (int) item.name.idLength; q++ ){

                    // Must align the output to read huge tables.

                    if( q < 6 ){
                        fprintf( stderr,"%d.", item.name.ids[q]);
                    }else if( q < 9 ){
                        fprintf( stderr,"%2d.", item.name.ids[q]);
                    }else{
                        fprintf( stderr,"%3d.", item.name.ids[q]);
                    }
                }
            }
            fprintf(stderr,"\n");

        }


        if ( ErrorStatus != 0 )
        {
            SnmpUtilVarBindFree( &item );
            return ( MapSnmpErrorToNt( ErrorStatus ) );
        }

        // We want to break out of this while loop if the defining part of the
        // OID changes

        if ( item.name.idLength < ( PreambleDef.Length + pOid->Length ) )
        {
            break;
        }

        for ( i = PreambleDef.Length;
              i < PreambleDef.Length + pOid->Length - pOid->BackOffset;
              i++ )
        {
            if ( item.name.ids[i] != pOid->Val[i - PreambleDef.Length] )
            {
                BreakLoop = TRUE;
                break;
            }
        }

        if ( BreakLoop )
        {
            break;
        }

        // We want to ignore certain entries.  EG: the TCP statistics will also
        // return the TCP connection table, which we don't want (there is a
        // separate Type code for that).

        switch ( Type )
        {
        case TYPE_IP:
            if ( ( item.name.ids[pOid->EntElemOffset] == ID_IP_ADDRTABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ROUTETABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ARPTABLE ) )
            {
                continue;
            }
            break;

        case TYPE_TCP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_TCP_CONNTABLE )
            {
                continue;
            }
            break;

        case TYPE_UDP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_UDP_CONNTABLE )
            {
                continue;
            }
            break;

        case TYPE_TCP6CONN:
            if ( item.name.ids[10] != 2 )
            {
                // ignore non-IPv6 entries
                continue;
            }
            break;

        case TYPE_UDP6LISTENER:
            if ( item.name.ids[10] != 2 )
            {
                // ignore non-IPv6 entries
                continue;
            }
            break;
        }

        // Entry handling:
        //
        // There are 3 cases to consider:
        // 1. If the list is empty, OR at the end of the list AND the
        //    CurrField == LastField.
        //   Then add a new entry to the list.
        // 2. CurrField != LastField.
        //   Then reset pointer to start of the list.
        // 3. Otherwise
        //   Then go to next entry in the list.

        if ( ( pTable == pList ) ||
             ( ( pTable->ListEntry.Flink == &pList->ListEntry ) &&
               ( item.name.ids[pOid->EntElemOffset] == LastField ) ) )
        {
            // Add new entry to table

            pTable = (GenericTable *)SNMP_malloc( Size );
            if ( pTable == NULL )
            {
                SnmpUtilVarBindFree( &item );
                return ( ERROR_NOT_ENOUGH_MEMORY );
            }

            InsertTailList( &pList->ListEntry, &pTable->ListEntry );
        }
        else if ( item.name.ids[pOid->EntElemOffset] != LastField )
        {
            // Reset pointer to start of list

            pTable = CONTAINING_RECORD( pList->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }
        else
        {
            // Move pointer to next entry in list

            pTable = CONTAINING_RECORD( pTable->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }

        LastField = item.name.ids[pOid->EntElemOffset];

        // Save info in our list.  pTable points to desired entry.

        switch ( Type )
        {
        case TYPE_IF:
            SaveData_IF( pTable, item, pOid );
            break;

        case TYPE_IP:
            SaveData_IP( pTable, item, pOid );
            break;

        case TYPE_IPADDR:
            SaveData_IPAddr( pTable, item, pOid );
            break;

        case TYPE_ROUTE:
            SaveData_ROUTE( pTable, item, pOid );
            break;

        case TYPE_ARP:
            SaveData_ARP( pTable, item, pOid );
            break;

        case TYPE_ICMP:
            SaveData_ICMP( pTable, item, pOid );
            break;

        case TYPE_TCP:
        case TYPE_TCP6:
            SaveData_TCP( pTable, item, pOid );
    