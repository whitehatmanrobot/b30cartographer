nKeyEx(
                    HKEY_LOCAL_MACHINE,
                    pszKey,
                    0,
                    KEY_READ,
                    &hKey
                    );
        // if the call succeeded or we were not checking the policy, break the loop
        if (lStatus == ERROR_SUCCESS || !fPolicy)
            break;

        // being at this point, this means we were checking for the policy parameters.
        // If and only if the policy is not defined (registry key is missing) we
        // reset the error, mark 'fPolicy already tried' and go back into the loop
        if (lStatus == ERROR_FILE_NOT_FOUND)
        {
            lStatus = ERROR_SUCCESS;
            fPolicy = FALSE;
        }
    } while (lStatus == ERROR_SUCCESS);

    // validate return code
    if (lStatus == ERROR_SUCCESS) {
        
        // call routine to load managers into global list 
        LoadManagers(hKey, &g_PermittedManagers);

        // close key
        RegCloseKey(hKey);

        // at this point consider success (errors localized at particular managers were logged already)
        fOk = TRUE;
    } 
    else
        // it doesn't matter how the values are, the key has to exist,
        // so mark as bFirstCall in order to log an event if this is not true.
        bFirstCall = TRUE;
    
    if (!fOk) {
        
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing PermittedManagers subkey.\n",
            lStatus
            ));

        // report an error only if on first call (service initialization)
        // otherwise, due to registry operations through regedit, the event log
        // might be flooded with records
        if (bFirstCall)
            // report event
            ReportSnmpEvent(
                SNMP_EVENT_INVALID_REGISTRY_KEY, 
                1, 
                &pszKey, 
                lStatus
                );
    }

    return fOk;
}


BOOL
UnloadPermittedManagers(
    )

/*++

Routine Description:

    Destroys list of permitted managers.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // call common routine with global list
    return UnloadManagers(&g_PermittedManagers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\snmpmgmt.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgmt.h

Abstract:

    Contains functions for handling/updating
	snmp management variables (defined in RFC1213)

Environment:

    User Mode - Win32

Revision History:

    30-Mar-1998 FlorinT
--*/
#include <snmputil.h>
#include "snmpmgmt.h"

SNMP_MGMTVARS snmpMgmtBase;	// instance of the service management variables

/*++
	Initializes the management variable arrays.
--*/
void mgmtInit()
{
	int i;

	for (i=0; i<NC_MAX_COUNT; i++)
    {
        snmpMgmtBase.AsnCounterPool[i].asnType = ASN_COUNTER32;
		snmpMgmtBase.AsnCounterPool[i].asnValue.counter = 0;
    }
	for (i=0; i<NI_MAX_COUNT; i++)
    {
        snmpMgmtBase.AsnIntegerPool[i].asnType = ASN_INTEGER;
		snmpMgmtBase.AsnIntegerPool[i].asnValue.number = 0;
    }
    for (i=0; i<NO_MAX_COUNT; i++)
    {
        snmpMgmtBase.AsnObjectIDs[i].asnType = ASN_OBJECTIDENTIFIER;
        snmpMgmtBase.AsnObjectIDs[i].asnValue.object.idLength = 0;
        snmpMgmtBase.AsnObjectIDs[i].asnValue.object.ids = NULL;
    }

    // particular case: default the IsnmpEnableAuthenTraps to TRUE
    snmpMgmtBase.AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue.number = 1;

    // particular case: default the IsnmpNameResolutionRetries to 0
    snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number = 0;

    // particular case: default the OsnmpSysObjectID to the hard coded value given by SvcGetEnterpriseOID
    mgmtOSet(OsnmpSysObjectID, SnmpSvcGetEnterpriseOID(), TRUE);
}

/*++
	Releases any memory that has been allocated for the management variables
--*/
void mgmtCleanup()
{
    int i;

    for (i=0; i<NO_MAX_COUNT; i++)
    {
        SnmpUtilOidFree(&(snmpMgmtBase.AsnObjectIDs[i].asnValue.object));
    }
}

/*++
	Increment the specified Counter variable
Returns:
	ERROR_SUCCESS on success;
	ERROR_INVALID_INDEX if index out of range;
	ERROR_ARITHMETIC_OVERFLOW if overflowing the MAXINT value.
--*/
int mgmtCTick(int index)
{
	AsnCounter	oldValue;

	if (index < 0 || index >= NC_MAX_COUNT)
		return ERROR_INVALID_INDEX	;

	oldValue = snmpMgmtBase.AsnCounterPool[index].asnValue.counter;
	snmpMgmtBase.AsnCounterPool[index].asnValue.counter++;
	return snmpMgmtBase.AsnCounterPool[index].asnValue.counter > oldValue ? ERROR_SUCCESS : ERROR_ARITHMETIC_OVERFLOW;
}

/*++
	Add a value to a counter
Returns:
	ERROR_SUCCESS on success;
	ERROR_INVALID_INDEX if index out of range;
	ERROR_ARITHMETIC_OVERFLOW if overflowing the MAXINT value.
--*/
int  mgmtCAdd(int index, AsnCounter value)
{
    AsnCounter  oldValue;

    if (index < 0 || index >= NC_MAX_COUNT)
        return ERROR_INVALID_INDEX;

    oldValue = snmpMgmtBase.AsnCounterPool[index].asnValue.counter;
    snmpMgmtBase.AsnCounterPool[index].asnValue.counter += value;
    return snmpMgmtBase.AsnCounterPool[index].asnValue.counter > oldValue ? ERROR_SUCCESS : ERROR_ARITHMETIC_OVERFLOW;
}

/*++
	Set the value of a certain AsnInteger mgmt variable
Returns:
	ERROR_SUCCESS on success;
	ERROR_INVALID_INDEX if index out of range;
--*/
int mgmtISet(int index, AsnInteger value)
{
	if (index < 0 || index > NI_MAX_COUNT)
		return ERROR_INVALID_INDEX;
	snmpMgmtBase.AsnIntegerPool[index].asnValue.number = value;
	return ERROR_SUCCESS;
}

/*++
    Set the value of a certain AsnObjectIdentifier mgmt variable
Returns:
    ERROR_SUCCESS on success;
    ERROR_INVALID_INDEX if index out of range;
    other WinErr if smth else went wrong
Remarks:
    If bAlloc = TRUE, the variable is moved (no mem is allocated) to the management variable
    If bAlloc = FALSE the value of the input variable is copied (and mem is allocated) to the mgmt variable
---*/
int mgmtOSet(int index, AsnObjectIdentifier *pValue, BOOL bAlloc)
{
    AsnObjectIdentifier oldObject;

    if (index < 0 || index > NO_MAX_COUNT)
        return ERROR_INVALID_INDEX;
    if (pValue == NULL)
        return ERROR_INVALID_PARAMETER;

    // make a backup of the original object. If something goes wrong, the original object will not be free-ed.
    oldObject.idLength = snmpMgmtBase.AsnObjectIDs[index].asnValue.object.idLength;
    oldObject.ids = snmpMgmtBase.AsnObjectIDs[index].asnValue.object.ids;

    if (bAlloc)
    {
        // the object is to be copied and mem is to be allocated
        if (SnmpUtilOidCpy(&(snmpMgmtBase.AsnObjectIDs[index].asnValue.object), pValue) != SNMPAPI_NOERROR)
            return GetLastError();
    }
    else
    {
        // the object is to be moved, no mem will be allocated
        snmpMgmtBase.AsnObjectIDs[index].asnValue.object.idLength = pValue->idLength;
        snmpMgmtBase.AsnObjectIDs[index].asnValue.object.ids = pValue->ids;
    }

    // everything went fine, so release the memory for the previous value
    SnmpUtilOidFree(&oldObject);

    return ERROR_SUCCESS;
}

/*++
    Updates the MIB counters for the IN_errStatus or OUT_errStatus value
Returns:
    void
--*/
void mgmtUtilUpdateErrStatus(UINT flag, DWORD errStatus)
{
    UINT index;

    switch(errStatus)
    {
    case SNMP_ERRORSTATUS_TOOBIG:
        index = flag == IN_errStatus ? CsnmpInTooBigs : CsnmpOutTooBigs;
        break;

    case SNMP_ERRORSTATUS_NOSUCHNAME:
        index = flag == IN_errStatus ? CsnmpInNoSuchNames : CsnmpOutNoSuchNames;
        break;

    case SNMP_ERRORSTATUS_BADVALUE:
        index = flag == IN_errStatus ? CsnmpInBadValues : CsnmpOutBadValues;
        break;

    case SNMP_ERRORSTATUS_READONLY:
        if (flag != IN_errStatus)
            return;
        index = CsnmpInReadOnlys;
        break;

    case SNMP_ERRORSTATUS_GENERR:
        index = flag == IN_errStatus ? CsnmpInGenErrs : CsnmpOutGenErrs;
        break;

    default:
        return;
    }

    mgmtCTick(index);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\snmppdus.c ===
/*

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmppdus.c

Abstract:

    Contains routines for manipulating SNMP PDUs.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "snmppdus.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define BERERR  ((LONG)-1)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
DoLenLen(
    LONG lLen
    )

/*

Routine Description:

    Calculates number of bytes required to encode length.

Arguments:

    lLen - length of interest.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine len length 
    if (0x80 > lLen) return (1);
    if (0x100 > lLen) return (2);
    if (0x10000 > lLen) return (3);
    if (0x1000000 > lLen) return (4);
    
    SNMPDBG((
        SNMP_LOG_ERROR,
        "SNMP: SVC: length field too large.\n"
        ));

    // failure
    return BERERR; 
}


LONG
FindLenInt(
    AsnInteger32 nValue
    )

/*

Routine Description:

    Calculates length of integer.

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // negative?
    if (nValue < 0) {

        // determine length of negative int
        if ((ULONG)0x80 >= -nValue) return (1);
        if ((ULONG)0x8000 >= -nValue) return (2);
        if ((ULONG)0x800000 >= -nValue) return (3);

    } else {

        // determine length of positive int
        if ((ULONG)0x80 > nValue) return (1);
        if ((ULONG)0x8000 > nValue) return (2);
        if ((ULONG)0x800000 > nValue) return (3);
    }    
    
    // default
    return (4);
}


LONG
FindLenIntEx(
    AsnInteger32 nValue
    )

/*

Routine Description:

    Calculates length of integer (including type and lenlen).

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // negative?
    if (nValue < 0) {

        // determine length of negative int
        if ((ULONG)0x80 >= -nValue) return (3);
        if ((ULONG)0x8000 >= -nValue) return (4);
        if ((ULONG)0x800000 >= -nValue) return (5);

    } else {

        // determine length of positive int
        if ((ULONG)0x80 > nValue) return (3);
        if ((ULONG)0x8000 > nValue) return (4);
        if ((ULONG)0x800000 > nValue) return (5);
    }    
    
    // default
    return (6);
}


LONG 
FindLenUInt(
    AsnUnsigned32 nValue
    )

/*

Routine Description:

    Calculates encoded length of unsigned integer.

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{   
    // determine length of unsigned int
    if ((ULONG)0x80 > nValue) return (1);
    if ((ULONG)0x8000 > nValue) return (2);
    if ((ULONG)0x800000 > nValue) return (3);
    if ((ULONG)0x80000000 > nValue) return (4);

    // default
    return (5);
}



LONG 
FindLenUIntEx(
    AsnUnsigned32 nValue
    )

/*

Routine Description:

    Calculates encoded length of unsigned integer (including type and lenlen).

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{   
    // determine length of unsigned int
    if ((ULONG)0x80 > nValue) return (3);
    if ((ULONG)0x8000 > nValue) return (4);
    if ((ULONG)0x800000 > nValue) return (5);
    if ((ULONG)0x80000000 > nValue) return (6);

    // default
    return (7);
}


LONG
FindLenCntr64(
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Calculates encoded length of 64-bit counter.

Arguments:

    pCntr64 - counter data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // retrieve 64-bit unsigned value
    ULONGLONG nValue = pCntr64->QuadPart;

    // determine length of unsigned int
    if ((ULONGLONG)0x80 > nValue) return (1);
    if ((ULONGLONG)0x8000 > nValue) return (2);
    if ((ULONGLONG)0x800000 > nValue) return (3);
    if ((ULONGLONG)0x80000000 > nValue) return (4);
    if ((ULONGLONG)0x8000000000 > nValue) return (5);
    if ((ULONGLONG)0x800000000000 > nValue) return (6);
    if ((ULONGLONG)0x80000000000000 > nValue) return (7);
    if ((ULONGLONG)0x8000000000000000 > nValue) return (8);

    // default
    return (9);
}


LONG
FindLenCntr64Ex(
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Calculates encoded length of 64-bit counter (including type and lenlen).

Arguments:

    pCntr64 - counter data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // retrieve 64-bit unsigned value
    ULONGLONG nValue = pCntr64->QuadPart;

    // determine length of unsigned int
    if ((ULONGLONG)0x80 > nValue) return (3);
    if ((ULONGLONG)0x8000 > nValue) return (4);
    if ((ULONGLONG)0x800000 > nValue) return (5);
    if ((ULONGLONG)0x80000000 > nValue) return (6);
    if ((ULONGLONG)0x8000000000 > nValue) return (7);
    if ((ULONGLONG)0x800000000000 > nValue) return (8);
    if ((ULONGLONG)0x80000000000000 > nValue) return (9);
    if ((ULONGLONG)0x8000000000000000 > nValue) return (10);

    // default
    return (11);
}


LONG
FindLenOctets(
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Calculates length of octet string.

Arguments:

    pOctets - pointer to octet string.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // return size
    return pOctets->length;
}


LONG
FindLenOctetsEx(
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Calculates length of octet string (including type and lenlen).

Arguments:

    pOctets - pointer to octet string.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;

    // calculate bytes needed to encode 
    lLenLen = DoLenLen(pOctets->length);

    // return total size
    return (lLenLen != BERERR)
                ? (pOctets->length + lLenLen + 1)
                : BERERR
                ; 
}


LONG 
FindLenOid(
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Calculates length of object identifier.

Arguments:

    pOid - pointer object identifier.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lDataLen;

    // first two 
    lDataLen = 1;

    // assume first two oids present
    for (i = 2; i < pOid->idLength; i++) {

        if (0x80 > pOid->ids[i]) {         
            lDataLen += 1;
        } else if (0x4000 > pOid->ids[i]) {   
            lDataLen += 2;
        } else if (0x200000 > pOid->ids[i]) {  
            lDataLen += 3;
        } else if (0x10000000 > pOid->ids[i]) {     
            lDataLen += 4;
        } else {
            lDataLen += 5;
        }
    } 

    // return size
    return (pOid->idLength >= 2) ? lDataLen : BERERR;
} 


LONG 
FindLenOidEx(
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Calculates length of object identifier (including type and lenlen).

Arguments:

    pOid - pointer object identifier.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lLenLen;
    LONG lDataLen;

    // first two 
    lDataLen = 1;

    // assume first two oids present
    for (i = 2; i < pOid->idLength; i++) {

        if (0x80 > pOid->ids[i]) {         
            lDataLen += 1;
        } else if (0x4000 > pOid->ids[i]) {   
            lDataLen += 2;
        } else if (0x200000 > pOid->ids[i]) {  
            lDataLen += 3;
        } else if (0x10000000 > pOid->ids[i]) {     
            lDataLen += 4;
        } else {
            lDataLen += 5;
        }
    } 

    // calculate len length
    lLenLen = DoLenLen(lDataLen);

    // return total size
    return ((lLenLen != BERERR) &&
            (pOid->idLength >= 2))
                ? (lDataLen + lLenLen + 1)
                : BERERR
                ;
} 


LONG 
FindLenAsnAny(
    AsnAny * pAny       
    )

/*

Routine Description:

    Find length of variable binding value.

Arguments:

    pAny - pointer to variable binding value.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine syntax
    switch (pAny->asnType) {
    
    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return FindLenOctets(&pAny->asnValue.string);

    case ASN_OBJECTIDENTIFIER:
       
        return FindLenOid(&pAny->asnValue.object);
    
    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        return (0);
    
    case ASN_INTEGER32:

        return FindLenInt(pAny->asnValue.number);
    
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return FindLenUInt(pAny->asnValue.unsigned32);

    case ASN_COUNTER64:

        return FindLenCntr64(&pAny->asnValue.counter64);
    } 

    return BERERR;
} 


LONG 
FindLenAsnAnyEx(
    AsnAny * pAny       
    )

/*

Routine Description:

    Find length of variable binding value (including type and lenlen).

Arguments:

    pAny - pointer to variable binding value.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine syntax
    switch (pAny->asnType) {
    
    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return FindLenOctetsEx(&pAny->asnValue.string);

    case ASN_OBJECTIDENTIFIER:
       
        return FindLenOidEx(&pAny->asnValue.object);
    
    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        return (2);
    
    case ASN_INTEGER32:

        return FindLenIntEx(pAny->asnValue.number);
    
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return FindLenUIntEx(pAny->asnValue.unsigned32);

    case ASN_COUNTER64:

        return FindLenCntr64Ex(&pAny->asnValue.counter64);
    } 

    return BERERR;
} 


LONG 
FindLenVarBind(
    SnmpVarBind * pVb
    )

/*

Routine Description:

    Find length of variable binding.

Arguments:

    pVb - pointer to variable binding.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;
    LONG lOidLen;
    LONG lValueLen;

    // determine length of name
    lOidLen = FindLenOidEx(&pVb->name);
    
    // determine length of value
    lValueLen = FindLenAsnAnyEx(&pVb->value);

    // return total size
    return ((lOidLen != BERERR) &&
            (lValueLen != BERERR)) 
                ? (lOidLen + lValueLen)
                : BERERR
                ;    
} 


LONG 
FindLenVarBindEx(
    SnmpVarBind * pVb
    )

/*

Routine Description:

    Find length of variable binding (including type and lenlen).

Arguments:

    pVb - pointer to variable binding.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;
    LONG lOidLen;
    LONG lValueLen;

    // determine length of name
    lOidLen = FindLenOidEx(&pVb->name);
    
    // determine length of value
    lValueLen = FindLenAsnAnyEx(&pVb->value);

    // determine length of varbind length
    lLenLen = DoLenLen(lOidLen + lValueLen);

    // return total size
    return ((lLenLen != BERERR) &&
            (lOidLen != BERERR) &&
            (lValueLen != BERERR)) 
                ? (lOidLen + lValueLen + lLenLen + 1)
                : BERERR
                ;    
} 


LONG 
FindLenVarBindList(
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Find length of variable binding list.

Arguments:

    pVbl - pointer to variable binding list.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lVbLen = 0;
    LONG lVblLen = 0;

    // process each variable binding in the list
    for (i = 0; (lVbLen != BERERR) && (i < pVbl->len); i++) {

        // determine length of variable binding
        lVbLen = FindLenVarBindEx(&pVbl->list[i]);

        // add to total
        lVblLen += lVbLen;
    }

    // return total size
    return (lVbLen != BERERR) 
                ? lVblLen 
                : BERERR
                ;
}


LONG 
FindLenVarBindListEx(
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Find length of variable binding list (including type and lenlen).

Arguments:

    pVbl - pointer to variable binding list.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lVbLen = 0;
    LONG lVblLen = 0;
    LONG lLenLen;

    // process each variable binding in the list
    for (i = 0; (lVbLen != BERERR) && (i < pVbl->len); i++) {

        // determine length of variable binding
        lVbLen = FindLenVarBindEx(&pVbl->list[i]);

        // add to total
        lVblLen += lVbLen;
    }

    // determine list length 
    lLenLen = DoLenLen(lVblLen);

    // return total size
    return ((lVbLen != BERERR) &&
            (lLenLen != BERERR))
                ? (lVblLen + lLenLen + 1)
                : BERERR
                ;
}


VOID 
AddNull(
    LPBYTE * ppByte, 
    INT      nType
    )

/*

Routine Description:

    Adds null into stream.

Arguments:

    ppByte - pointer to pointer to current stream.

    nType - exact syntax.

Return Values:

    None.

*/

{
    // encode actual syntax 
    *(*ppByte)++ = (BYTE)(0xFF & nType);
    *(*ppByte)++ = 0x00;
}


VOID
AddLen(
    LPBYTE * ppByte, 
    LONG     lLenLen, 
    LONG     lDataLen
    )

/*

Routine Description:

    Adds data length field to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    lLenLen - length of data length.

    lDataLen - actual data length.

Return Values:

    None.

*/

{
    LONG i;
    if (lLenLen == 1) {
        *(*ppByte)++ = (BYTE)lDataLen;
    } else {
        *(*ppByte)++ = (BYTE)(0x80 + lLenLen - 1);
        for (i = 1; i < lLenLen; i++) {
            *(*ppByte)++ = (BYTE)((lDataLen >>
                (8 * (lLenLen - i - 1))) & 0xFF);
        } 
    } 
} 


LONG
AddInt(
    LPBYTE *     ppByte, 
    INT          nType, 
    AsnInteger32 nInteger32
    )

/*

Routine Description:

    Adds integer to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of integer.

    nInteger32 - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG lLenLen;

    // determine length of integer
    lDataLen = FindLenInt(nInteger32);

    // lenlen
    lLenLen = 1;  

    // encode nType of integer
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // encode length of integer
    AddLen(ppByte, lLenLen, lDataLen);

    // add encoded integer
    for (i = 0; i < lDataLen; i++) {
       *(*ppByte)++ = (BYTE)(nInteger32 >> 
            (8 * ((lDataLen - 1) - i) & 0xFF));
    }

    return (0);
}


LONG 
AddUInt(
    LPBYTE *      ppByte, 
    INT           nType, 
    AsnUnsigned32 nUnsigned32
    )

/*

Routine Description:

    Adds unsigned integer to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of integer.

    nUnsigned32 - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG lLenLen;

    // determine length of integer
    lDataLen = FindLenUInt(nUnsigned32);

    // < 127 octets 
    lLenLen = 1; 

    // encode actual syntax
    *(*ppByte)++ = (BYTE)(0xFF & nType);
    
    // encode data length
    AddLen(ppByte, lLenLen, lDataLen);

    // analyze length
    if (lDataLen == 5) {

        // put 00 in first octet 
        *(*ppByte)++ = (BYTE)0;

        // encode unsigned integer
        for (i = 1; i < lDataLen; i++) {
            *(*ppByte)++ = (BYTE)(nUnsigned32 >>
                (8 * ((lDataLen - 1) - i) & 0xFF));
        }
    
    } else {

        // encode unsigned integer
        for (i = 0; i < lDataLen; i++) {
            *(*ppByte)++ = (BYTE)(nUnsigned32 >>
                (8 * ((lDataLen - 1) - i) & 0xFF));
        }
    } 

    return (0);
}


LONG 
AddCntr64(
    LPBYTE *       ppByte, 
    INT            nType, 
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Adds 64-bit counter to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of counter.

    pCntr64 - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG lLenLen;

    // determine length of counter64
    lDataLen = FindLenCntr64(pCntr64);

    // < 127 octets 
    lLenLen = 1; 

    // encode actual syntax        
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // encode data length
    AddLen(ppByte, lLenLen, lDataLen);

    // adjust lDataLen
    if (lDataLen == 9) {
        // put 00 in first octet 
        *(*ppByte)++ = (BYTE)0;
        lDataLen--;
    }

    // encode counter data
    for (i = lDataLen; i > 4; i--) {
        *(*ppByte)++ = (BYTE)(pCntr64->HighPart >>
            (8 * (i - 5) & 0xFF));
    }
    for (; i > 0; i--) {
        *(*ppByte)++ = (BYTE)(pCntr64->LowPart >>
            (8 * (i - 1) & 0xFF));
    }

    return (0);
}


LONG 
AddOctets(
    LPBYTE *         ppByte, 
    INT              nType, 
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Adds octet string to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of string.

    pOctets - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lLenLen;
    LONG lDataLen;

    // determine oid length
    if ((lDataLen = FindLenOctets(pOctets)) == BERERR)
        return BERERR;

    // calculate octet string length
    if ((lLenLen = DoLenLen(lDataLen)) == BERERR)
        return BERERR;

    // encode actual syntax 
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // encode octet string length
    AddLen(ppByte, lLenLen, lDataLen);

    // usless copy avoided
    if (*ppByte != pOctets->stream)
    {
        // encode actual octets    
        for (i = 0; i < pOctets->length; i++)
            *(*ppByte)++ = pOctets->stream[i];
    }
    else
    {
        (*ppByte) += pOctets->length;
    }

    return (0);
}


LONG 
AddOid(
    LPBYTE * ppByte, 
    INT      nType, 
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Adds object identifier to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of object identifier.

    pOid - pointer to object identifier.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lLenLen = 0;
    LONG lDataLen;

    // determine oid length
    if ((lDataLen = FindLenOid(pOid)) == BERERR)
        return BERERR;

    // calculate number of bytes required for length
    if ((lLenLen = DoLenLen(lDataLen)) == BERERR)
        return BERERR;

    // add syntax to stream
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // add object identifier length
    AddLen(ppByte, lLenLen, lDataLen);

    // add first subid
    if (pOid->idLength < 2)
       *(*ppByte)++ = (BYTE)(pOid->ids[0] * 40);
    else
       *(*ppByte)++ = (BYTE)((pOid->ids[0] * 40) + pOid->ids[1]);

    // walk remaining subidentifiers
    for (i = 2; i < pOid->idLength; i++) {

        if (pOid->ids[i] < 0x80) {

            // 0 - 0x7f 
            *(*ppByte)++ = (BYTE)pOid->ids[i];

        } else if (pOid->ids[i] < 0x4000) {

            // 0x80 - 0x3fff 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);

        } else if (pOid->ids[i] < 0x200000) {
   
            // 0x4000 - 0x1FFFFF 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 14) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);
      
        } else if (pOid->ids[i] < 0x10000000) {
      
            // 0x200000 - 0xFFfffff 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 21) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 14) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);

        } else {
      
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 28) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 21) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 14) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);
        }
    } 

    return (0);
}


LONG 
AddAsnAny(
    LPBYTE * ppByte, 
    AsnAny * pAny
    )

/*

Routine Description:

    Adds variable binding value to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pAny - variable binding value.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine syntax        
    switch (pAny->asnType) {

    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return AddUInt(
                ppByte, 
                (INT)pAny->asnType, 
                pAny->asnValue.unsigned32
                );

    case ASN_INTEGER32:

        return AddInt(
                ppByte, 
                (INT)pAny->asnType, 
                pAny->asnValue.number
                );

    case ASN_OBJECTIDENTIFIER:

        return AddOid(
                ppByte, 
                (INT)pAny->asnType,
                &pAny->asnValue.object
                );

    case ASN_COUNTER64:

        return AddCntr64(
                ppByte, 
                (INT)pAny->asnType,
                &pAny->asnValue.counter64
                );

    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return AddOctets(
                ppByte, 
                (INT)pAny->asnType,
                &pAny->asnValue.string
                );

    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        AddNull(ppByte, (INT)pAny->asnType);
        return (0);
    }
    
    return BERERR;
}


LONG 
AddVarBind(
    LPBYTE *      ppByte, 
    SnmpVarBind * pVb 
    )

/*

Routine Description:

    Adds variable binding to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pVb - pointer to variable binding.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;
    LONG lDataLen;

    // determine actual length of varbind data
    if ((lDataLen = FindLenVarBind(pVb)) == BERERR)
       return BERERR;

    // determine length of varbind data length
    if ((lLenLen = DoLenLen(lDataLen)) == BERERR)
       return BERERR;

    // encode as sequence
    *(*ppByte)++ = ASN_SEQUENCE;

    // encode data length    
    AddLen(ppByte, lLenLen, lDataLen);

    // encode variable binding name
    if (AddOid(ppByte, ASN_OBJECTIDENTIFIER, &pVb->name) == BERERR)
        return BERERR;

    // encode variable binding value
    if (AddAsnAny(ppByte, &pVb->value) == BERERR)
        return BERERR;

    return (0);
}


LONG 
AddVarBindList(
    LPBYTE *          ppByte, 
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Adds variable binding list to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pVbl - pointer to variable binding list.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;

    // add each variable binding 
    for (i = 0; i < pVbl->len; i++) {
        if (AddVarBind(ppByte, &pVbl->list[i]) == BERERR)
            return BERERR;
    }

    return (0);
}


LONG
ParseLength(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte
    )

/*

Routine Description:

    Parse length from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lLenLen;
    LONG lDataLen;

    lDataLen = (LONG)*(*ppByte)++;

    if (lDataLen < 0x80)
       return (lDataLen);

    // check for long form
    lLenLen = lDataLen & 0x7f;

    // validate long form 
    if ((lLenLen > 4) || (lLenLen < 1)) 
       return BERERR;

    lDataLen = 0L;

    for (i = 0; i < lLenLen; i++) {
       lDataLen = (lDataLen << 8) + *(*ppByte)++;
    }

    if (*ppByte > pLastByte)
       return BERERR;

    return (lDataLen);
}


LONG 
ParseType(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte
    )

/*

Routine Description:

    Parse type from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    SHORT nType = *(*ppByte)++;

    if (*ppByte > pLastByte)
       return BERERR;

    switch (nType) {

    case ASN_INTEGER32:
    case ASN_OCTETSTRING:
    case ASN_OBJECTIDENTIFIER:
    case ASN_SEQUENCE:
    case ASN_IPADDRESS:
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_OPAQUE:
    case ASN_UNSIGNED32:
    case ASN_COUNTER64:
    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:
    case SNMP_PDU_GET:
    case SNMP_PDU_GETNEXT:
    case SNMP_PDU_RESPONSE:
    case SNMP_PDU_SET:
    case SNMP_PDU_V1TRAP:
    case SNMP_PDU_GETBULK:
    case SNMP_PDU_INFORM:
    case SNMP_PDU_TRAP:
        break;

    default:
        nType = BERERR;
        break;
    }
    
    return (LONG)(SHORT)(nType);
} 


BOOL 
ParseNull(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte
    )

/*

Routine Description:

    Parse null from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG lDataLen;

    if (!(ParseType(ppByte, pLastByte)))
        return (FALSE);
    
    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);
    
    if (lDataLen != 0)
        return (FALSE);
    
    if (*ppByte > pLastByte)
        return (FALSE);
    
    return (TRUE);
} 


BOOL 
ParseSequence(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte, 
    LONG *   plDataLen
    )

/*

Routine Description:

    Parse sequence from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    plDataLen - pointer to receive sequence length.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG lDataLen;

    if ((ParseType(ppByte, pLastByte)) != ASN_SEQUENCE)
        return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if (*ppByte > pLastByte)
        return (FALSE);

    if (plDataLen)
        *plDataLen = lDataLen;

    return (TRUE);
} 


BOOL 
ParseInt(
    LPBYTE *       ppByte, 
    LPBYTE         pLastByte, 
    AsnInteger32 * pInteger32
    )

/*

Routine Description:

    Parse integer from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pInteger32 - pointer to receive integer.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lSign;
    LONG lDataLen;

    if (ParseType(ppByte, pLastByte) == BERERR)
       return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
       return (FALSE);

    if (lDataLen > 4)
       return (FALSE);

    lSign = ((*(*ppByte) & 0x80) == 0x00) ? 0x00 : 0xFF;

    *pInteger32 = 0;

    for (i = 0; i < lDataLen; i++)
       *pInteger32 = (*pInteger32 << 8) + (UINT)*(*ppByte)++;

    // sign-extend upper bits
    for (i = lDataLen; i < 4; i++)
       *pInteger32 = *pInteger32 + (lSign << i * 8);

    if (*ppByte > pLastByte)
       return (FALSE);

    return (TRUE);
}


BOOL 
ParseUInt(
    LPBYTE *        ppByte, 
    LPBYTE          pLastByte, 
    AsnUnsigned32 * pUnsigned32
    )

/*

Routine Description:

    Parse unsigned integer from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pUnsigned32 - pointer to receive integer.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;

    if (ParseType(ppByte, pLastByte) == BERERR)
       return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
       return (FALSE);

    if ((lDataLen > 5) || ((lDataLen > 4) && (*(*ppByte) != 0x00)))
       return (FALSE);

    // leading null octet?
    if (*(*ppByte) == 0x00)  {
       (*ppByte)++;          // if so, skip it
       lDataLen--;           // and don't count it
    }

    *pUnsigned32 = 0;

    for (i = 0; i < lDataLen; i++)
       *pUnsigned32 = (*pUnsigned32 << 8) + (UINT)*(*ppByte)++;

    if (*ppByte > pLastByte)
       return (FALSE);

    return (TRUE);
} 


BOOL
ParseCntr64(
    LPBYTE *       ppByte, 
    LPBYTE         pLastByte,
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Parse 64-bit counter from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pCntr64 - pointer to receive counter.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG nType;

    // initialize
    pCntr64->HighPart = 0L;
    pCntr64->LowPart = 0L;

    if ((nType = ParseType(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if (nType != ASN_COUNTER64)
        return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if ((lDataLen > 9) || ((lDataLen > 8) && (*(*ppByte) != 0x00)))
        return (FALSE);

    // leading null octet?
    if (*(*ppByte) == 0x00) { 
       (*ppByte)++;          // if so, skip it
       lDataLen--;           // and don't count it
    }

    for (i = 0; i < lDataLen; i++) {
        pCntr64->HighPart = (pCntr64->HighPart << 8) +
            (pCntr64->LowPart >> 24);
        pCntr64->LowPart = (pCntr64->LowPart << 8) +
            (unsigned long) *(*ppByte)++;
    }

    if (*ppByte > pLastByte) 
       return (FALSE);

    return TRUE;
} 


BOOL
ParseOctets(
    LPBYTE *         ppByte, 
    LPBYTE           pLastByte, 
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Parse octet string from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pOctets - pointer to receive string.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG errCode;
    // initialize
    pOctets->length  = 0;
    pOctets->stream  = NULL;
    pOctets->dynamic = FALSE;

    if (ParseType(ppByte, pLastByte) == BERERR)
        return (FALSE);

    // make sure no conversion to UINT is done before testing
    // (pOctets->length is UINT)
    if ((errCode = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    pOctets->length = (UINT)errCode;

    // avoid wrapping around on machines with 4-byte pointers
    if ((((*ppByte) + pOctets->length) < *ppByte) || 
        ((*ppByte) + pOctets->length) > pLastByte)
        return (FALSE);

    // validate length
    if (pOctets->length) {

        // point into buffer
        pOctets->stream = *ppByte;  // WARNING! WARNING!
    }

    *ppByte += pOctets->length;

    return (TRUE);
} 


BOOL 
ParseOid(
    LPBYTE *              ppByte, 
    LPBYTE                pLastByte, 
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Parse object identifier from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pOid - pointer to receive oid.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG nType;

    // initialize
    pOid->idLength = 0;
    pOid->ids = NULL;

    if ((nType = ParseType(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if (nType != ASN_OBJECTIDENTIFIER)
        return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);


    if (lDataLen <= 0) //--ft 03/02/98 removed trailing "|| lDataLen > SNMP_MAX_OID_LEN)"
    {                  // check is done in the while loop below
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ParseOid: lDataLen <= 0, lDataLen=%d.\n",
            lDataLen
            ));
        return (FALSE); 
    }
    
    // BUG# 486089
    // the ((lDataLen + 2) * sizeof(UINT)) expression might cause overflow in 
    // SnmpUtilMemAlloc below. adding one more check to limit its max. value.
    if ( lDataLen > (pLastByte - (*ppByte)) )
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ParseOid: invalid lDataLen=%d, pLastByte=%p,  *ppByte=%p.\n",
            lDataLen, pLastByte, *ppByte
            ));
        return (FALSE);
    }

    pOid->ids = SnmpUtilMemAlloc((DWORD)((lDataLen + 2) * sizeof(UINT)));

    if (pOid->ids == NULL)
        return (FALSE);

    // pOid->ids array space is pre-zero'd via SnmpUtilMemAlloc()
    while (lDataLen && (pOid->idLength < SNMP_MAX_OID_LEN))
    {
        pOid->ids[pOid->idLength] =
            (pOid->ids[pOid->idLength] << 7) | (*(*ppByte) & 0x7F);
        if ((*(*ppByte)++ & 0x80) == 0)
        {   // on the last octet of this sub-id
            if (pOid->idLength == 0)  // check for first sub-id
            {                         // ASN.1/BER packs two into it
                pOid->ids[1] = pOid->ids[0];
                pOid->ids[0] /= 40;
                if (pOid->ids[0] > 2)
                    pOid->ids[0] = 2;
                pOid->ids[1] -= (pOid->ids[0] * 40);
                pOid->idLength++; // extra bump
            }
            pOid->idLength++; // increment the count on sub-id
        }
        lDataLen--; // note: *ppByte is incremented in the if statement above
    } // end_while (lDataLen)

    // BUG 506192
    // Invalid OID BER of the form like "06 07 FF FF FF FF FF FF FF"
    // causes pOid->idLength becomes 0. Each subidentifier should be
    // encoded as a non-negative integer using as few 7-bit blocks as possible.
    // The blocks are packed in octets with the first bit of each octet equal
    // to 1 except for the last octet of each subidentifier. The example above
    // does not have the last octet. Added the (0 == pOid->idLength) test below.
    if (lDataLen || (0 == pOid->idLength)) 
    {
        // the above while loop is terminated without finishing the parsing of the stream
        SnmpUtilMemFree(pOid->ids);
        pOid->ids = NULL;
        pOid->idLength = 0;
        return (FALSE);
    }

    return (TRUE);
} 


BOOL
ParseAsnAny(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte, 
    AsnAny * pAny
    )

/*

Routine Description:

    Parse variable binding value from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pAny - pointer to variable binding value.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    // determine asn type
    switch (pAny->asnType) {
   
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return ParseUInt(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.unsigned32
                );

    case ASN_INTEGER32:

        return ParseInt(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.number
                );

    case ASN_OBJECTIDENTIFIER:

        return ParseOid(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.object
                );

    case ASN_COUNTER64:

        return ParseCntr64(
                ppByte, 
                pLastByte,
                &pAny->asnValue.counter64
                );

    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return ParseOctets(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.string
                );

    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        return ParseNull(ppByte, pLastByte);
    } 

    return (FALSE);
}


BOOL
ParseVarBind(
    LPBYTE *      ppByte, 
    LPBYTE        pLastByte,
    SnmpVarBind * pVb
    )

/*

Routine Description:

    Parse variable binding from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pVb - pointer to variable binding.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    if (!(ParseSequence(ppByte, pLastByte, NULL)))
        return (FALSE);

    if (!(ParseOid(ppByte, pLastByte, &pVb->name)))
        return (FALSE);

    pVb->value.asnType = (UINT)*(*ppByte);

    if (!(ParseAsnAny(ppByte, pLastByte, &pVb->value)))
    {
        // free memory allocated by ParseOid
        SnmpUtilOidFree(&pVb->name);
        return (FALSE);
    }

    return TRUE;    
}


BOOL
ParseVarBindList(
    LPBYTE *          ppByte, 
    LPBYTE            pLastByte,
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Parse variable binding from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pVbl - pointer to variable binding list.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    SnmpVarBind Vb;
    SnmpVarBind * pVb = NULL;

    // initialize
    pVbl->list = NULL;
    pVbl->len = 0;

    // loop while data is left
    while (*ppByte < pLastByte) {
        
        if (!(ParseVarBind(ppByte, pLastByte, &Vb)))
            return (FALSE);

        // copy pointer
        pVb = pVbl->list;

        // attempt to allocate new variable binding
        pVb = SnmpUtilMemReAlloc(pVb, (pVbl->len + 1) * sizeof(SnmpVarBind));

        // validate
        if (pVb == NULL) 
        {
            SnmpUtilVarBindFree(&Vb);
            return FALSE;
        }
        // update varbind
        pVb[pVbl->len] = Vb;

        // update list
        pVbl->list = pVb;
        pVbl->len++;            
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures (based on snmp\manager\winsnmp\dll\wsnmp_bn.c)          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
typedef UNALIGNED LONG* PUALONG;

BOOL
BuildMessage(
    AsnInteger32      nVersion,
    AsnOctetString *  pCommunity,
    PSNMP_PDU         pPdu,
    PBYTE             pMessage,
    PDWORD            pMessageSize
    )

/*

Routine Description:

    Builds outgoing SNMP PDU based on structure.

Arguments:

    nVersion - SNMP version.

    pCommunity - pointer to community string.

    pPdu - pointer to PDU data structure.

    pMessage - pointer to buffer in which to build message.

    pMessageSize - pointer to receive size of message.

Return Values:

    Returns true if successful.

*/

{
    LONG nVbDataLength;
    LONG nVbLenLength; 
    LONG nVbTotalLength;
    LONG nPduDataLength; 
    LONG nPduLenLength;
    LONG nPduTotalLength;
    LONG nMsgDataLength; 
    LONG nMsgLenLength;
    LONG nMsgTotalLength;    
    LONG nMsgAvailLength;
    LONG nTmpDataLength;

    LPBYTE tmpPtr = pMessage;

    // determine bytes available
    nMsgAvailLength = *pMessageSize;

    // find length of variable bindings list
    if ((nVbDataLength = FindLenVarBindList(&pPdu->Vbl)) == BERERR)
        return FALSE; 

    // find length of length of variable bindings    
    if ((nVbLenLength = DoLenLen(nVbDataLength)) == BERERR)
        return FALSE; 

    // calculate total bytes required to encode varbinds
    nVbTotalLength = 1 + nVbLenLength + nVbDataLength;

    // determine pdu nType
    switch (pPdu->nType) {

    case SNMP_PDU_GET:
    case SNMP_PDU_GETNEXT:
    case SNMP_PDU_RESPONSE:
    case SNMP_PDU_SET:
    case SNMP_PDU_GETBULK:
    case SNMP_PDU_INFORM:
    case SNMP_PDU_TRAP:

        // calculate bytes required to encode pdu entries
        nPduDataLength = FindLenIntEx(pPdu->Pdu.NormPdu.nRequestId)
                       + FindLenIntEx(pPdu->Pdu.NormPdu.nErrorStatus)
                       + FindLenIntEx(pPdu->Pdu.NormPdu.nErrorIndex)
                       + nVbTotalLength;
        break;

    case SNMP_PDU_V1TRAP:

        // calculate bytes required to encode pdu entries
        nPduDataLength = FindLenIntEx(pPdu->Pdu.TrapPdu.nGenericTrap)
                       + FindLenIntEx(pPdu->Pdu.TrapPdu.nSpecificTrap)
                       + FindLenUIntEx(pPdu->Pdu.TrapPdu.nTimeticks)
                       + nVbTotalLength;
        
        // find oid length
        if ((nTmpDataLength = 
                FindLenOidEx(&pPdu->Pdu.TrapPdu.EnterpriseOid)) == BERERR)
            return FALSE; 

        // add EnterpriseOid oid length
        nPduDataLength += nTmpDataLength;

        // find address length
        if ((nTmpDataLength = 
                FindLenOctetsEx(&pPdu->Pdu.TrapPdu.AgentAddr)) == BERERR)
            return FALSE; 

        // add agent address length
        nPduDataLength += nTmpDataLength;
        break;

    default:
        return FALSE; 
    }

    // find length of pdu length
    if ((nPduLenLength = DoLenLen(nPduDataLength)) == BERERR)
        return FALSE; 

    // calculate total bytes required to encode pdu
    nPduTotalLength = 1 + nPduLenLength + nPduDataLength;

    // find length of message data
    nMsgDataLength = FindLenUIntEx(nVersion)
                   + FindLenOctetsEx(pCommunity)
                   + nPduTotalLength;

    // find length of message data length
    nMsgLenLength = DoLenLen(nMsgDataLength);

    // calculate total bytes required to encode message
    nMsgTotalLength = 1 + nMsgLenLength + nMsgDataLength;

    // record bytes required
    *pMessageSize = nMsgTotalLength;

    // make sure message fits in buffer
    if (nMsgTotalLength <= nMsgAvailLength) {
        LONG oldLength; // the length of the request PDU
        LONG delta;     // difference between the request PDU length and the responce PDU length
        BYTE *newStream;// new location for the community stream inside the response PDU.

        // encode message as asn sequence        
        *tmpPtr++ = ASN_SEQUENCE;

        // the pointer to the community string points either directly in the incoming buffer 
        // (for req PDUs) or in the TRAP_DESTINATION_LIST_ENTRY for the outgoing traps.
        // In the first case, when building the outgoing message on the same buffer as the
        // incoming message, we need to take care to no overwrite the community name (in case
        // the length field is larger than for the initial message). Hence, in this case only
        // we shift the community name with a few octets, as many as the difference between the
        // encodings of the two lengths (the length of the outgoing response - the length of the
        // incoming request).
        if (pPdu->nType != SNMP_PDU_V1TRAP)
        {
            // here tmpPtr points exactly to the length of the request pdu  
            oldLength = *(PUALONG)tmpPtr; // bug# 176433
            // compute the offset the community stream should be shifted with
            delta = nMsgLenLength - ((oldLength & 0x80) ? (oldLength & 0x7f) + 1 : 1);
            newStream = pCommunity->stream + delta;
            // pCommunity->stream is shifted regardles memory regions overlapp
            memmove(newStream, pCommunity->stream, pCommunity->length);
            // make old community to point to the new location
            pCommunity->stream = newStream;
        }

        // encode global message information
        AddLen(&tmpPtr, nMsgLenLength, nMsgDataLength);
        AddUInt(&tmpPtr, ASN_INTEGER32, nVersion);
        AddOctets(&tmpPtr, ASN_OCTETSTRING, pCommunity);

        // encode pdu header information
        *tmpPtr++ = (BYTE)pPdu->nType;
        AddLen(&tmpPtr, nPduLenLength, nPduDataLength);        

        // determine pdu nType
        switch (pPdu->nType) {

        case SNMP_PDU_RESPONSE:
        case SNMP_PDU_TRAP:

            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.NormPdu.nRequestId);
            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.NormPdu.nErrorStatus);
            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.NormPdu.nErrorIndex);
            break;

        case SNMP_PDU_V1TRAP:

            if (AddOid(
                    &tmpPtr, 
                    ASN_OBJECTIDENTIFIER,        
                    &pPdu->Pdu.TrapPdu.EnterpriseOid)== BERERR)
                return FALSE; 

            if (AddOctets(
                    &tmpPtr, 
                    ASN_IPADDRESS, 
                    &pPdu->Pdu.TrapPdu.AgentAddr) == BERERR)
                return FALSE; 

            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.TrapPdu.nGenericTrap);
            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.TrapPdu.nSpecificTrap);
            AddUInt(&tmpPtr, ASN_TIMETICKS, pPdu->Pdu.TrapPdu.nTimeticks);
            break;

        case SNMP_PDU_GET:
        case SNMP_PDU_GETNEXT:
        case SNMP_PDU_SET:
        case SNMP_PDU_INFORM:
        case SNMP_PDU_GETBULK:
        default:
            return FALSE; 
        } 

        // encode variable bindings
        *tmpPtr++ = ASN_SEQUENCE;

        AddLen(&tmpPtr, nVbLenLength, nVbDataLength);

        if (AddVarBindList(&tmpPtr, &pPdu->Vbl) == BERERR)
            return FALSE; 

        // success
        return TRUE; 
    }

    // failure
    return FALSE;
}

BOOL
ParseMessage(
    AsnInteger32 *   pVersion,
    AsnOctetString * pCommunity,
    PSNMP_PDU        pPdu,
    PBYTE            pMessage,
    DWORD            dwMessageSize
    )

/*

Routine Description:

    Parses incoming SNMP PDU into structure.

Arguments:

    pVersion - pointer to receive SNMP version.

    pCommunity - pointer to receive community string.

    pPdu - pointer to receive remaining PDU data.

    pMessage - pointer to message to parse.

    dwMessageSize - number of bytes in message.

Return Values:

    Returns true if successful.

*/

{
    LONG lLength;
    LPBYTE pByte;
    LPBYTE pLastByte;

    // initialize community
    pCommunity->stream = NULL;
    pCommunity->length = 0;

    // initialize vbl
    pPdu->Vbl.len = 0;
    pPdu->Vbl.list = NULL;

    // validate pointer
    if (!(pByte = pMessage))  
        goto cleanup;

    // set limit based on packet size
    pLastByte = pByte + dwMessageSize;

    // decode asn sequence message wrapper     
    if (!(ParseSequence(&pByte, pLastByte, &lLength)))
        goto cleanup;

    // check for packet fragments
    if (pLastByte < (pByte + lLength))
        goto cleanup;

    // re-adjust based on data
    pLastByte = pByte + lLength;
    
    // decode snmp version
    if (!(ParseUInt(&pByte, pLastByte, pVersion)))
        goto cleanup;

    // validate snmp version
    if ((*pVersion != SNMP_VERSION_1) && 
        (*pVersion != SNMP_VERSION_2C)) 
    {
        // register version mismatch into the management structure
        mgmtCTick(CsnmpInBadVersions);

        goto cleanup;
    }

    // decode community string
    if (!(ParseOctets(&pByte, pLastByte, pCommunity)))
        goto cleanup;

    // decode nType of incoming pdu
    if ((pPdu->nType = ParseType(&pByte, pLastByte)) == BERERR)
        goto cleanup;

    // decode length of incoming pdu
    if ((lLength = ParseLength(&pByte, pLastByte)) == BERERR)
        goto cleanup;

    // validate length
    if (pByte + lLength > pLastByte)
        goto cleanup;

    // determine pdu nType
    switch (pPdu->nType) {

    case SNMP_PDU_GET:                                                          
    case SNMP_PDU_GETNEXT:                                                      
    case SNMP_PDU_SET:                                                          

        // decode the pdu header information
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.NormPdu.nRequestId)))    
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.NormPdu.nErrorStatus)))  
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.NormPdu.nErrorIndex)))   
            goto cleanup;                                                           

        // update the management counters for the incoming errorStatus coding
        mgmtUtilUpdateErrStatus(IN_errStatus, pPdu->Pdu.NormPdu.nErrorStatus);

        // no reason here to have any ErrorStatus and ErrorIndex.
        // initialize error status variables to NOERROR
        pPdu->Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOERROR;
        pPdu->Pdu.NormPdu.nErrorIndex  = 0;

        break;                                                                      
                                                                                   
    case SNMP_PDU_GETBULK:                                                      

        // decode the getbulk pdu header information
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.BulkPdu.nRequestId)))    
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.BulkPdu.nNonRepeaters)))  
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.BulkPdu.nMaxRepetitions)))   
            goto cleanup;                                                           

        // see if value needs to be adjusted
        if (pPdu->Pdu.BulkPdu.nNonRepeaters < 0) {

            // adjust non-repeaters to zero
            pPdu->Pdu.BulkPdu.nNonRepeaters = 0;    
        }

        // see if value needs to be adjusted
        if (pPdu->Pdu.BulkPdu.nMaxRepetitions < 0) {

            // adjust max-repetitions to zero
            pPdu->Pdu.BulkPdu.nMaxRepetitions = 0;
        }

        // initialize status information
        pPdu->Pdu.BulkPdu.nErrorStatus = SNMP_ERRORSTATUS_NOERROR;
        pPdu->Pdu.BulkPdu.nErrorIndex  = 0;

        break;                                                                      
                                                                                   
    case SNMP_PDU_INFORM:                                                       
    case SNMP_PDU_RESPONSE:                                                     
    case SNMP_PDU_TRAP:                                                         
    case SNMP_PDU_V1TRAP:                                                       
    default:                                                                    
        goto cleanup;
    } 

    // parse over sequence
    if (!(ParseSequence(&pByte, pLastByte, NULL)))                            
        goto cleanup;                                                           

    // parse variable binding list
    if (!(ParseVarBindList(&pByte, pLastByte, &pPdu->Vbl)))
        goto cleanup;                                                           

    // success
    return TRUE;

cleanup:

    // cleanup community string    
    SnmpUtilOctetsFree(pCommunity);

    // cleanup any allocated varbinds 
    SnmpUtilVarBindListFree(&pPdu->Vbl);

    // failure
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\startup.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    startup.c

Abstract:

    Contains routines for starting SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "startup.h"
#include "network.h"
#include "registry.h"
#include "snmpthrd.h"
#include "regthrd.h"
#include "trapthrd.h"
#include "args.h"
#include "mem.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE g_hAgentThread = NULL;
HANDLE g_hRegistryThread = NULL; // Used to track registry changes
CRITICAL_SECTION g_RegCriticalSectionA;
CRITICAL_SECTION g_RegCriticalSectionB;
CRITICAL_SECTION g_RegCriticalSectionC; // protect the generation of trap from 
                                        // registry changes


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadWinsock(
    )

/*++

Routine Description:

    Startup winsock.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    WSADATA WsaData;
    WORD wVersionRequested = MAKEWORD(2,0);
    INT nStatus;
    
    // attempt to startup winsock    
    nStatus = WSAStartup(wVersionRequested, &WsaData);

    // validate return code
    if (nStatus == SOCKET_ERROR) {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d starting winsock.\n",
            WSAGetLastError()
            ));

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}

BOOL
UnloadWinsock(
    )

/*++

Routine Description:

    Shutdown winsock.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    INT nStatus;

    // cleanup
    nStatus = WSACleanup();

    // validate return code
    if (nStatus == SOCKET_ERROR) {
            
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d stopping winsock.\n",
            WSAGetLastError()
            ));

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
StartupAgent(
    )

/*++

Routine Description:

    Performs essential initialization of master agent.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    DWORD dwThreadId = 0;
	DWORD regThreadId = 0;
    INT nCSOk = 0;          // counts the number of CS that were successfully initialized

	// initialize management variables
    mgmtInit();

    // initialize list heads
    InitializeListHead(&g_Subagents);
    InitializeListHead(&g_SupportedRegions);
    InitializeListHead(&g_ValidCommunities);
    InitializeListHead(&g_TrapDestinations);
    InitializeListHead(&g_PermittedManagers);
    InitializeListHead(&g_IncomingTransports);
    InitializeListHead(&g_OutgoingTransports);

    __try
    {
        InitializeCriticalSection(&g_RegCriticalSectionA); nCSOk++;
        InitializeCriticalSection(&g_RegCriticalSectionB); nCSOk++;
        InitializeCriticalSection(&g_RegCriticalSectionC); nCSOk++;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        if (nCSOk == 1)
            DeleteCriticalSection(&g_RegCriticalSectionA);
        if (nCSOk == 2)
        {
            DeleteCriticalSection(&g_RegCriticalSectionA);
            DeleteCriticalSection(&g_RegCriticalSectionB);
        }
        // nCSOk can't be 3 as far as we are here

        fOk = FALSE;
    }
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Initialize critical sections...%s\n", fOk? "Ok" : "Failed"));


	fOk = fOk &&
          (g_hRegistryEvent = CreateEvent(NULL, FALSE, TRUE, NULL)) != NULL;


    g_dwUpTimeReference = SnmpSvcInitUptime();
    // retreive system uptime reference
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Getting system uptime...%d\n", g_dwUpTimeReference));

    // allocate essentials
    fOk = fOk && AgentHeapCreate();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Creating agent heap...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk && LoadWinsock();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Winsock stack...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk && LoadIncomingTransports();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Incoming transports...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk && LoadOutgoingTransports();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Outgoing transports...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk &&
            // attempt to start main thread
          (g_hAgentThread = CreateThread(
                               NULL,               // lpThreadAttributes
                               0,                  // dwStackSize
                               ProcessSnmpMessages,
                               NULL,               // lpParameter
                               CREATE_SUSPENDED,   // dwCreationFlags
                               &dwThreadId
                               )) != NULL;
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Starting ProcessSnmpMessages thread...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk &&
           // attempt to start registry listener thread
          (g_hRegistryThread = CreateThread(
                               NULL,
                               0,
                               ProcessRegistryMessage,
                               NULL,
                               CREATE_SUSPENDED,
                               &regThreadId)) != NULL;
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Starting ProcessRegistryMessages thread...%s\n", fOk? "Ok" : "Failed"));

    return fOk;        
}


BOOL
ShutdownAgent(
    )

/*++

Routine Description:

    Performs final cleanup of master agent.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    DWORD dwStatus;

    // make sure shutdown signalled
    fOk = SetEvent(g_hTerminationEvent);

    if (!fOk) {
                    
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d signalling termination.\n",
            GetLastError()
            ));
    }

    // check if thread created
    if ((g_hAgentThread != NULL) && (g_hRegistryThread != NULL)) {
        HANDLE hEvntArray[2];

        hEvntArray[0] = g_hAgentThread;
        hEvntArray[1] = g_hRegistryThread;

        dwStatus = WaitForMultipleObjects(2, hEvntArray, TRUE, SHUTDOWN_WAIT_HINT);

        // validate return status
        if ((dwStatus != WAIT_OBJECT_0) &&
            (dwStatus != WAIT_OBJECT_0 + 1) &&
            (dwStatus != WAIT_TIMEOUT)) {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for thread(s) termination.\n",
                GetLastError()
                ));
        }
    } else if (g_hAgentThread != NULL) {

        // wait for pdu processing thread to terminate
        dwStatus = WaitForSingleObject(g_hAgentThread, SHUTDOWN_WAIT_HINT);

        // validate return status
        if ((dwStatus != WAIT_OBJECT_0) &&
            (dwStatus != WAIT_TIMEOUT)) {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for main thread termination.\n",
                GetLastError()
                ));
        }
    } else if (g_hRegistryThread != NULL) {

        // wait for registry processing thread to terminate
        dwStatus = WaitForSingleObject(g_hRegistryThread, SHUTDOWN_WAIT_HINT);

        // validate return status
        if ((dwStatus != WAIT_OBJECT_0) &&
            (dwStatus != WAIT_TIMEOUT)) {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for registry thread termination.\n",
                GetLastError()
                ));
        }
    }

    // unload incoming transports
    UnloadIncomingTransports();

    // unload outgoing transports
    UnloadOutgoingTransports();

    // unload registry info
    UnloadRegistryParameters();

    // unload the winsock stack
    UnloadWinsock();

    // cleanup the internal management buffers
    mgmtCleanup();

    // nuke private heap
    AgentHeapDestroy();

    // clean up critical section resources
    DeleteCriticalSection(&g_RegCriticalSectionA);
    DeleteCriticalSection(&g_RegCriticalSectionB);
    DeleteCriticalSection(&g_RegCriticalSectionC);

    ReportSnmpEvent(
        SNMP_EVENT_SERVICE_STOPPED,
        0,
        NULL,
        0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\snmpthrd.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpthrd.c

Abstract:

    Contains routines for master agent network thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <tchar.h>
#include <stdio.h>
#include "globals.h"
#include "contexts.h"
#include "regions.h"
#include "snmpmgrs.h"
#include "trapmgrs.h"
#include "trapthrd.h"
#include "network.h"
#include "varbinds.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT g_nTransactionId = 0;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MAX_IPX_ADDR_LEN    64
#define MAX_COMMUNITY_LEN   255

#define ERRMSG_TRANSPORT_IP     _T("IP")
#define ERRMSG_TRANSPORT_IPX    _T("IPX")


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPSTR
AddrToString(
    struct sockaddr * pSockAddr
    )

/*++

Routine Description:

    Converts sockaddr to display string.

Arguments:

    pSockAddr - pointer to socket address.

Return Values:

    Returns pointer to string.

--*/

{
    static CHAR ipxAddr[MAX_IPX_ADDR_LEN];

    // determine family
    if (pSockAddr->sa_family == AF_INET) {

        struct sockaddr_in * pSockAddrIn;

        // obtain pointer to protocol specific structure
        pSockAddrIn = (struct sockaddr_in * )pSockAddr;

        // forward to winsock conversion function
        return inet_ntoa(pSockAddrIn->sin_addr);

    } else if (pSockAddr->sa_family == AF_IPX) {

        struct sockaddr_ipx * pSockAddrIpx;

        // obtain pointer to protocol specific structure
        pSockAddrIpx = (struct sockaddr_ipx * )pSockAddr;

        // transfer ipx address to static buffer
        sprintf(ipxAddr, 
            "%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x",
            (BYTE)pSockAddrIpx->sa_netnum[0],
            (BYTE)pSockAddrIpx->sa_netnum[1],
            (BYTE)pSockAddrIpx->sa_netnum[2],
            (BYTE)pSockAddrIpx->sa_netnum[3],
            (BYTE)pSockAddrIpx->sa_nodenum[0],
            (BYTE)pSockAddrIpx->sa_nodenum[1],
            (BYTE)pSockAddrIpx->sa_nodenum[2],
            (BYTE)pSockAddrIpx->sa_nodenum[3],
            (BYTE)pSockAddrIpx->sa_nodenum[4],
            (BYTE)pSockAddrIpx->sa_nodenum[5]
            );

        // return addr
        return ipxAddr;
    }

    // failure
    return NULL;
}


LPSTR
CommunityOctetsToString(
    AsnOctetString  *pAsnCommunity,
    BOOL            bUnicode
    )

/*++

Routine Description:

    Converts community octet string to display string.

Arguments:

    pAsnCommunity - pointer to community octet string.

Return Values:

    Returns pointer to string.

--*/

{
    static CHAR Community[MAX_COMMUNITY_LEN+1];
    LPSTR pCommunity = Community;

    // terminate string
    *pCommunity = '\0';

    // validate pointer
    if (pAsnCommunity != NULL)
    {
        DWORD nChars = 0;
    
        // determine number of characters to transfer
        nChars = min(pAsnCommunity->length, MAX_COMMUNITY_LEN);

        if (bUnicode)
        {
            WCHAR wCommunity[MAX_COMMUNITY_LEN+1];

            // tranfer memory into buffer
            memset(wCommunity, 0, nChars+sizeof(WCHAR));
            memcpy(wCommunity, pAsnCommunity->stream, nChars);
            SnmpUtilUnicodeToAnsi(&pCommunity, wCommunity, FALSE);
        }
        else
        {
            memcpy(Community, pAsnCommunity->stream, nChars);
            Community[nChars] = '\0';
        }
    }

    // success
    return pCommunity;
}


LPSTR
StaticUnicodeToString(
    LPWSTR wszUnicode
    )

/*++

Routine Description:

    Converts null terminated UNICODE string to static LPSTR

Arguments:

    pOctets - pointer to community octet string.

Return Values:

    Returns pointer to string.

--*/

{
    static CHAR szString[MAX_COMMUNITY_LEN+1];
    LPSTR       pszString = szString;

    // terminate string
    *pszString = '\0';

    // validate pointer
    if (wszUnicode != NULL)
    {
        WCHAR wcBreak;
        BOOL  bNeedBreak;

        bNeedBreak = (wcslen(wszUnicode) > MAX_COMMUNITY_LEN);

        if (bNeedBreak)
        {
            wcBreak = wszUnicode[MAX_COMMUNITY_LEN];
            wszUnicode[MAX_COMMUNITY_LEN] = L'\0';
        }

        SnmpUtilUnicodeToAnsi(&pszString, wszUnicode, FALSE);

        if (bNeedBreak)
            wszUnicode[MAX_COMMUNITY_LEN] = wcBreak;
    }

    // success
    return pszString;
}


LPDWORD
RefErrStatus(
    PSNMP_PDU pPdu
    )

    /*++

Routine Description:

    Returns address of the Error Code in a PDU data structure

Arguments:

    pPdu - PDU to check

Return Values:

    Returns Error Code address, returns NULL if no Error Code

--*/

{
    switch (pPdu->nType) {

        case SNMP_PDU_GET:                                                          
        case SNMP_PDU_GETNEXT:                                                      
        case SNMP_PDU_SET:
            return &pPdu->Pdu.NormPdu.nErrorStatus;
            break;
        
        case SNMP_PDU_GETBULK:
            return &pPdu->Pdu.BulkPdu.nErrorStatus;
            break;

        default:
            return NULL;
            break;
    }
}


BOOL
ValidateContext(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Checks access rights of given context.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if manager allowed access.

--*/

{
    BOOL fAccessOk = TRUE;
    BOOL fOk = FALSE;
    PCOMMUNITY_LIST_ENTRY pCLE = NULL;
    AsnOctetString unicodeCommunity;
    LPWSTR         pUnicodeName;

    if (pNLE->Community.length != 0)
    {
        unicodeCommunity.length = pNLE->Community.length * sizeof(WCHAR);
        unicodeCommunity.stream = SnmpUtilMemAlloc(unicodeCommunity.length);
        unicodeCommunity.dynamic = TRUE;

        if (unicodeCommunity.stream == NULL)
            return FALSE;

        fAccessOk = (MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        pNLE->Community.stream,
                        pNLE->Community.length,
                        (LPWSTR)(unicodeCommunity.stream),
                        unicodeCommunity.length) != 0);
    }
    else
    {
        unicodeCommunity.length = 0;
        unicodeCommunity.stream = NULL;
        unicodeCommunity.dynamic = FALSE;
    }
        
    // search for community string
    if (fAccessOk && FindValidCommunity(&pCLE, &unicodeCommunity)) 
    {
        // check access per pdu type
        if (pNLE->Pdu.nType == SNMP_PDU_SET) {
        
            // check flags for write privileges
            fAccessOk = (pCLE->dwAccess >= SNMP_ACCESS_READ_WRITE);

        } else {

            // check flags for read privileges
            fAccessOk = (pCLE->dwAccess >= SNMP_ACCESS_READ_ONLY);
        }

        if (!fAccessOk) {

            // Community does not have the right access
            // RefErrStatus returns a pointer to the ErrorStatus field from the SNMP_PDU structure.
            // It returns NULL if the PDU is in fact SNMP_TRAP_PDU. This doesn't happen here as far
            // as ValidateContext is called only after ParseMessage() which is filtering out
            // SNMP_TRAP_PDU.
            *RefErrStatus(&pNLE->Pdu) = SNMP_ERRORSTATUS_NOSUCHNAME;

            // register wrong operation for specified community into management structure
            mgmtCTick(CsnmpInBadCommunityUses);
            fOk = TRUE;
        }
    }
    else
    {
        fAccessOk = FALSE;

        // register community name failure into the management structure
        mgmtCTick(CsnmpInBadCommunityNames);
    }

    // see if access attempt should be logged
	if (!fAccessOk && snmpMgmtBase.AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue.number) {

        // send authentication trap
        GenerateAuthenticationTrap();        
    }
        
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: %s request from community %s.\n",
        fAccessOk 
            ? "accepting"
            : "rejecting"
            ,
        CommunityOctetsToString(&(pNLE->Community), FALSE)
        ));

    SnmpUtilOctetsFree(&unicodeCommunity);

    return (fOk || fAccessOk);
}


BOOL
ValidateManager(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Checks access rights of given manager.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if manager allowed access.

--*/

{
    BOOL fAccessOk = FALSE;
    PMANAGER_LIST_ENTRY pMLE = NULL;

    fAccessOk = IsManagerAddrLegal((struct sockaddr_in *)&pNLE->SockAddr) &&
                (FindManagerByAddr(&pMLE, &pNLE->SockAddr) ||
                 IsListEmpty(&g_PermittedManagers)
                );

    if (!fAccessOk &&
        snmpMgmtBase.AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue.number)
        GenerateAuthenticationTrap();

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: %s request from %s.\n",
        fAccessOk 
            ? "accepting"
            : "rejecting"
            ,
        AddrToString(&pNLE->SockAddr)
        ));

    return fAccessOk;
}


BOOL
ProcessSnmpMessage(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Parse SNMP message and dispatch to subagents.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // decode request
    if (ParseMessage(
            &pNLE->nVersion,
            &pNLE->Community,
            &pNLE->Pdu,
            pNLE->Buffer.buf,
            pNLE->dwBytesTransferred
            )) {

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: %s request, community %s, %d variable(s).\n",
            PDUTYPESTRING(pNLE->Pdu.nType),
            CommunityOctetsToString(&(pNLE->Community), FALSE),
            pNLE->Pdu.Vbl.len
            ));        
        
        // validate context 
        if (ValidateContext(pNLE)) {

            // process varbinds 
            // RefErrStatus returns a pointer to the ErrorStatus field from SNMP_PDU structure.
            // The return value is NULL only if SNMP_PDU is in fact an SNMP_TRAP_PDU. Which is
            // not the case here, as far as it would have been filtered out by ParseMessage().
            if ((*RefErrStatus(&pNLE->Pdu) != SNMP_ERRORSTATUS_NOERROR) ||
                (ProcessVarBinds(pNLE))) {

                // initialize buffer length
                pNLE->Buffer.len = NLEBUFLEN;

                // reset pdu type to response
                pNLE->Pdu.nType = SNMP_PDU_RESPONSE;
                
                // encode response
                fOk = BuildMessage(
                        pNLE->nVersion,
                        &pNLE->Community,
                        &pNLE->Pdu,
                        pNLE->Buffer.buf,
                        &pNLE->Buffer.len
                        );
            }
        }
    }
    else {

        // register BER decoding failure into the management structures
        mgmtCTick(CsnmpInASNParseErrs);
    }

    // release pdu
    UnloadPdu(pNLE);

    return fOk; 
}         


void CALLBACK
RecvCompletionRoutine(
    IN  DWORD           dwStatus,
    IN  DWORD           dwBytesTransferred,
    IN  LPWSAOVERLAPPED pOverlapped,
    IN  DWORD           dwFlags
    )

/*++

Routine Description:

    Callback for completing asynchronous reads.

Arguments:

    Status - completion status for the overlapped operation.

    BytesTransferred - number of bytes transferred.

    pOverlapped - pointer to overlapped structure.

    Flags - receive flags.

Return Values:

    None.

--*/

{
    PNETWORK_LIST_ENTRY pNLE; 

    EnterCriticalSection(&g_RegCriticalSectionA);

    // retreive pointer to network list entry from overlapped structure
    pNLE = CONTAINING_RECORD(pOverlapped, NETWORK_LIST_ENTRY, Overlapped);

    // copy receive completion information
    pNLE->nTransactionId = ++g_nTransactionId;
    pNLE->dwBytesTransferred = dwBytesTransferred;
    pNLE->dwStatus = dwStatus;
    pNLE->dwFlags = dwFlags;
        
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: --- transaction %d begin ---\n",
        pNLE->nTransactionId
        ));        
        
    // validate status
    if (dwStatus == NOERROR) {

        // register incoming packet into the management structure
        mgmtCTick(CsnmpInPkts);

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: received %d bytes from %s.\n",
            pNLE->dwBytesTransferred,
            AddrToString(&pNLE->SockAddr)
            ));        
        
        // check manager address
        if (ValidateManager(pNLE)) {

            // process snmp message 
            if (ProcessSnmpMessage(pNLE)) {

                // synchronous send
                dwStatus = WSASendTo(
                              pNLE->Socket,
                              &pNLE->Buffer,
                              1,
                              &pNLE->dwBytesTransferred,
                              pNLE->dwFlags,
                              &pNLE->SockAddr,
                              pNLE->SockAddrLenUsed,
                              NULL,
                              NULL
                              );

                // register outgoing packet into the management structure
                mgmtCTick(CsnmpOutPkts);
                // register outgoing Response PDU
                mgmtCTick(CsnmpOutGetResponses);

                // validate return code
                if (dwStatus != SOCKET_ERROR) {

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: SVC: sent %d bytes to %s.\n",
                        pNLE->dwBytesTransferred,
                        AddrToString(&pNLE->SockAddr)
                        ));

                } else {
                    
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SVC: error %d sending response.\n",
                        WSAGetLastError()
                        ));
                }
            }
        }

    } else {
    
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d receiving snmp request.\n",
            dwStatus
            ));
    }

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: --- transaction %d end ---\n",
        pNLE->nTransactionId
        ));        

    LeaveCriticalSection(&g_RegCriticalSectionA);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
ProcessSnmpMessages(
    PVOID pParam
    )

/*++

Routine Description:

    Thread procedure for processing SNMP PDUs.

Arguments:

    pParam - unused.

Return Values:

    Returns true if successful.

--*/

{
    DWORD dwStatus;
    PLIST_ENTRY pLE;
    PNETWORK_LIST_ENTRY pNLE;
    
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Registry Parameters.\n"
        ));

    // fire cold start trap
    GenerateColdStartTrap();

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: starting pdu processing thread.\n"
        ));

    ReportSnmpEvent(
        SNMP_EVENT_SERVICE_STARTED,
        0,
        NULL,
        0);

    // loop
    for (;;)
    {
        // obtain pointer to first transport
        pLE = g_IncomingTransports.Flink;

        // loop through incoming transports
        while (pLE != &g_IncomingTransports)
        {
            // retreive pointer to network list entry from link
            pNLE = CONTAINING_RECORD(pLE, NETWORK_LIST_ENTRY, Link);

            // make sure recv is not pending
            if (pNLE->dwStatus != WSA_IO_PENDING)
            {
                // reset completion status
                pNLE->dwStatus = WSA_IO_PENDING;

                // intialize address structure size 
                pNLE->SockAddrLenUsed = pNLE->SockAddrLen;

                // initialize buffer length
                pNLE->Buffer.len = NLEBUFLEN;

                // re-initialize
                pNLE->dwFlags = 0;

                // post receive buffer
                dwStatus = WSARecvFrom(
                                pNLE->Socket,
                                &pNLE->Buffer,
                                1, // dwBufferCount
                                &pNLE->dwBytesTransferred,
                                &pNLE->dwFlags,
                                &pNLE->SockAddr,
                                &pNLE->SockAddrLenUsed,
                                &pNLE->Overlapped,
                                RecvCompletionRoutine
                                );

                // handle network failures
                if (dwStatus == SOCKET_ERROR)
                {
                    // retrieve last error
                    dwStatus = WSAGetLastError();

                    // if WSA_IO_PENDING everything is ok, just waiting for incoming traffic. Otherwise...
                    if (dwStatus != WSA_IO_PENDING)
                    {
                        // WSAECONNRESET means the last 'WSASendTo' (the one from RecvCompletionRoutine) failed
                        // most probably because the manager closed the socket (so we got back 'unreacheable destination port')
                        if (dwStatus == WSAECONNRESET)
                        {
                            SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: SVC: Benign error %d posting receive buffer. Retry...\n",
                                dwStatus
                                ));

                            // just go one more time and setup the port. It shouldn't ever loop continuously
                            // and hence hog the CPU..
                            pNLE->dwStatus = ERROR_SUCCESS;
                            continue;
                        }
                        else
                        {
                            // prepare the event log insertion string
                            LPTSTR pMessage = (pNLE->SockAddr.sa_family == AF_INET) ?
                                                ERRMSG_TRANSPORT_IP :
                                                ERRMSG_TRANSPORT_IPX;

                            // another error occurred. We don't know how to handle it so it is a fatal
                            // error for this transport. Will shut it down.
                            SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: SVC: Fatal error %d posting receive buffer. Skip transport.\n",
                                dwStatus
                                ));

                            ReportSnmpEvent(
                                SNMP_EVNT_INCOMING_TRANSPORT_CLOSED,
                                1,
                                &pMessage,
                                dwStatus);

                            // first step next with the pointer
                            pLE = pLE->Flink;

                            // delete this transport from the incoming transports list
                            UnloadTransport(pNLE);

                            // go on further
                            continue;
                        }
                    }
                }
            }

            pLE = pLE->Flink;
        }

        // we might want to shut the service down if no incoming transport remains.
        // we might as well consider letting the service up in order to keep sending outgoing traps.
        // for now, keep the service up (code below commented)
        //if (IsListEmpty(&g_IncomingTransports))
        //{
        //    ReportSnmpEvent(...);
        //    ProcessControllerRequests(SERVICE_CONTROL_STOP);
        //}

        // wait for incoming requests or indication of process termination 
        dwStatus = WaitForSingleObjectEx(g_hTerminationEvent, INFINITE, TRUE);

        // validate return code
        if (dwStatus == WAIT_OBJECT_0) {
                
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: exiting pdu processing thread.\n"
                ));

            // success
            return NOERROR;

        } else if (dwStatus != WAIT_IO_COMPLETION) {

            // retrieve error
            dwStatus = GetLastError();
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for request.\n",
                dwStatus
                ));
            
            // failure
            return dwStatus;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\subagnts.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    subagnts.c

Abstract:

    Contains definitions for manipulating subagent structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "subagnts.h"
#include "regions.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindSubagent(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                 pPathname
    )

/*++

Routine Description:

    Locates subagent in list.

Arguments:

    ppSLE - pointer to receive pointer to entry.

    pPathname - pointer to pathname to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PSUBAGENT_LIST_ENTRY pSLE;

    // initialize
    *ppSLE = NULL;

    // obtain pointer to head
    pLE = g_Subagents.Flink;

    // process all entries in list
    while (pLE != &g_Subagents) {

        // retrieve pointer to trap destination structure
        pSLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);

        // compare pathname string with entry
        if (!strcmp(pSLE->pPathname, pPathname)) {

            // transfer
            *ppSLE = pSLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
AddSubagentRegion(
    PSUBAGENT_LIST_ENTRY  pSLE,
    AsnObjectIdentifier * pPrefixOid
    )

/*++

Routine Description:

    Adds subagent supported region to structure.

Arguments:

    pSLE - pointer to subagent structure.

    pPrefixOid - pointer to supported region.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMIB_REGION_LIST_ENTRY pRLE = NULL;

    // allocate region
    if (AllocRLE(&pRLE)) {

        // save pointer
        pRLE->pSLE = pSLE;

        // copy prefix to structure
        SnmpUtilOidCpy(&pRLE->PrefixOid, pPrefixOid);

        // copy prefix as temporary limit
        SnmpUtilOidCpy(&pRLE->LimitOid, pPrefixOid);

        // modify limit oid to be one past the prefix
        ++pRLE->LimitOid.ids[pRLE->LimitOid.idLength - 1];
        
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: %s supports %s.\n",
            pSLE->pPathname,
            SnmpUtilOidToA(&pRLE->PrefixOid)
            ));

        // attach to mib region to subagent structure
        InsertTailList(&pSLE->SupportedRegions, &pRLE->Link);

        // success
        fOk = TRUE;
    }

    return fOk;
}

BOOL
OfferInternalMgmtVariables(
    PSUBAGENT_LIST_ENTRY pSLE
    )
/*++

Routine Description:

    if the subagent is willing to monitor the SNMP service
    this function is offering it a pointer to the internal
    management variables

Arguments:

    pSLE - pointer to subagent structure.

Return Values:

    Returns true anyway.

--*/
{
    if (pSLE->pfnSnmpExtensionMonitor != NULL)
    {
       __try {

            // attempt to initialize agent
            (*pSLE->pfnSnmpExtensionMonitor)(&snmpMgmtBase);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: exception 0x%08lx offering internals to %s.\n",
                GetExceptionCode(),
                pSLE->pPathname
                ));

            // failure
            return FALSE;
        }
    }
    
    return TRUE;
}


BOOL
LoadSubagentRegions(
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Loads subagent supported regions.

Arguments:

    pSLE - pointer to subagent structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    HANDLE hSubagentTrapEvent = NULL;
    AsnObjectIdentifier PrefixOid = { 0, NULL };

    __try {

        // attempt to initialize agent
        if ((*pSLE->pfnSnmpExtensionInit)(
                        g_dwUpTimeReference,    
                        &hSubagentTrapEvent,
                        &PrefixOid
                        )) {

            // store subagent trap event handle
            pSLE->hSubagentTrapEvent = hSubagentTrapEvent;

            // add subagent region to list entry
            fOk = AddSubagentRegion(pSLE, &PrefixOid);

            // check to see if subagent supports additional regions
            if (fOk && (pSLE->pfnSnmpExtensionInitEx != NULL)) {    

                BOOL fMoreRegions = TRUE;

                // get other regions
                while (fOk && fMoreRegions) {
    
                    // retrieve next supported region
                    fMoreRegions = (*pSLE->pfnSnmpExtensionInitEx)(
                                                &PrefixOid
                                                );

                    // validate
                    if (fMoreRegions) {

                        // add subagent region to list entry
                        fOk = AddSubagentRegion(pSLE, &PrefixOid);
                    }
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx loading %s.\n",
            GetExceptionCode(),
            pSLE->pPathname
            ));

        // failure
        fOk = FALSE;
    }
    
    return fOk;
}


BOOL
LoadSubagent(
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Loads subagent dll and initializes.

Arguments:

    pSLE - pointer to subagent structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;    

    // attempt to load subagent library - we use the altered search path flag so that
    // the subagent can load DLLs that live in its directory
    pSLE->hSubagentDll = LoadLibraryExA(pSLE->pPathname, 0, LOAD_WITH_ALTERED_SEARCH_PATH);

    // validate handle
    if (pSLE->hSubagentDll != NULL) {

        // load primary initialization routine
        pSLE->pfnSnmpExtensionInit = (PFNSNMPEXTENSIONINIT)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_INIT
                );

        // load secondary initialization routine
        pSLE->pfnSnmpExtensionInitEx = (PFNSNMPEXTENSIONINITEX)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_INIT_EX
                );

                // load secondary initialization routine
        pSLE->pfnSnmpExtensionClose = (PFNSNMPEXTENSIONCLOSE)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_CLOSE
                );

        // load the extension monitor routine
        pSLE->pfnSnmpExtensionMonitor = (PFNSNMPEXTENSIONMONITOR)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_MONITOR
                );

        // load snmpv1-based subagent request routine
        pSLE->pfnSnmpExtensionQuery = (PFNSNMPEXTENSIONQUERY)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_QUERY
                );

        // load snmpv2-based subagent request routine
        pSLE->pfnSnmpExtensionQueryEx = (PFNSNMPEXTENSIONQUERYEX)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_QUERY_EX
                );

        // load snmpv1-based subagent trap routine
        pSLE->pfnSnmpExtensionTrap = (PFNSNMPEXTENSIONTRAP)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_TRAP
                );

        // validate subagent agent entry points
        if ((pSLE->pfnSnmpExtensionInit != NULL) &&
           ((pSLE->pfnSnmpExtensionQuery != NULL) ||
            (pSLE->pfnSnmpExtensionQueryEx != NULL))) {

            // load supported regions
            if (fOk = LoadSubagentRegions(pSLE)) // !!intentional assignement!!
            {
                // offering internal management variables;
                fOk = OfferInternalMgmtVariables(pSLE);
            }
        }

    }
    else
    {
        DWORD errCode = GetLastError();
        LPTSTR pPathname;

#ifdef UNICODE
        SnmpUtilUTF8ToUnicode(&pPathname, pSLE->pPathname, TRUE);
#else
        pPathname = pSLE->pPathname;
#endif
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d loading subagent.\n",
            errCode
            ));

        ReportSnmpEvent(
            SNMP_EVENT_INVALID_EXTENSION_AGENT_DLL,
            1,
            &pPathname,
            errCode);

#ifdef UNICODE
        SnmpUtilMemFree(pPathname);
#endif
    }

    return fOk;
}


BOOL
AddSubagentByDll(
    LPSTR pPathname,
    UCHAR uchInitFlags
    )

/*++

Routine Description:

    Adds subagent to list.

Arguments:

    pPathname - pointer to subagent's dll path.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY pSLE = NULL;
    
    // attempt to locate in list    
    if (FindSubagent(&pSLE, pPathname)) {
                    
        SNMPDBG((
            SNMP_LOG_WARNING, 
            "SNMP: SVC: duplicate entry for %s.\n",
            pPathname
            ));
        
        // success
        fOk = TRUE;

    } else {

        // allocate subagent structure
        if (AllocSLE(&pSLE, pPathname, uchInitFlags)) {
                        
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: processing subagent %s.\n",
                pPathname
                ));

            // initialize subagent
            if (LoadSubagent(pSLE)) {

                // insert into valid communities list
                InsertTailList(&g_Subagents, &pSLE->Link);

                // success
                fOk = TRUE;
            } 
            
            // cleanup
            if (!fOk) {

                // release
                FreeSLE(pSLE);
            }
        }
    }

    return fOk;
}


BOOL
AddSubagentByKey(
    LPTSTR pKey
    )

/*++

Routine Description:

    Adds subagent to list.

Arguments:

    pKey - pointer to subagent's registry key path.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    CHAR szName[MAX_PATH];
    CHAR szValue[MAX_PATH];
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY pSLE = NULL;

    // open registry subkey    
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS) {
        
        // initialize
        dwIndex = 0;

        // initialize buffer sizes
        dwNameSize  = sizeof(szName);
        dwValueSize = sizeof(szValue);

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) {

            // read next value
            lStatus = RegEnumValueA(
                        hKey, 
                        dwIndex, 
                        szName, 
                        &dwNameSize,
                        NULL, 
                        &dwValueType, 
                        szValue, 
                        &dwValueSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {
            
                // check to see if value is pathname
                if (!_stricmp(szName, REG_VALUE_SUBAGENT_PATH)) {
    
                    DWORD dwRequired;
                    CHAR szExpanded[MAX_PATH];
                    
                    // expand environment strings in path
                    dwRequired = ExpandEnvironmentStringsA(
                                    szValue,
                                    szExpanded,
                                    sizeof(szExpanded)
                                    );

                    // load subagent library - no flags set
                    fOk = AddSubagentByDll(szExpanded, 0);
            
                    break; // bail...
                }

                // initialize buffer sizes
                dwNameSize  = sizeof(szName);
                dwValueSize = sizeof(szValue);

                // next
                dwIndex++;
            
            } else if (lStatus == ERROR_NO_MORE_ITEMS) {

                // failure
                fOk = FALSE; 
            }
        }

        // release handle
        RegCloseKey(hKey);
    }
    else
    {
        // the registry key for this subagent could not be located.
        ReportSnmpEvent(
            SNMP_EVENT_INVALID_EXTENSION_AGENT_KEY,
            1,
            &pKey,
            lStatus);
    }

    return fOk;    
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocSLE(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                  pPathname,
    UCHAR                  uchInitFlags
    )

/*++

Routine Description:

    Allocates trap destination structure and initializes.

Arguments:

    ppSLE - pointer to receive pointer to entry.

    pPathname - pointer to subgent's dll path.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY pSLE = NULL;

    // attempt to allocate structure
    pSLE = AgentMemAlloc(sizeof(SUBAGENT_LIST_ENTRY));

    // validate
    if (pSLE != NULL) {

        // allocate memory for trap destination string
        pSLE->pPathname = AgentMemAlloc(strlen(pPathname)+1);

        // validate
        if (pSLE->pPathname != NULL) {

            // transfer trap destination string
            strcpy(pSLE->pPathname, pPathname);

            // set the initial flags value
            pSLE->uchFlags = uchInitFlags;

            // initialize list of supported regions
            InitializeListHead(&pSLE->SupportedRegions);

            // success
            fOk = TRUE;
        } 

        // cleanup        
        if (!fOk) {

            // release 
            FreeSLE(pSLE);

            // re-init
            pSLE = NULL;            
        }
    }

    // transfer
    *ppSLE = pSLE;

    return fOk;
}


BOOL 
FreeSLE(
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Releases subagent structure.

Arguments:

    pSLE - pointer to list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pSLE != NULL) {

        SNMPDBG((  
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: unloading %s.\n",
            pSLE->pPathname
            ));

        // release manager structures
        UnloadRegions(&pSLE->SupportedRegions);

        // validate subagent dll handle    
        if (pSLE->hSubagentDll != NULL) {

            __try {
                if (pSLE->pfnSnmpExtensionClose != NULL)
                    (*pSLE->pfnSnmpExtensionClose)();

                // unload subagent
                FreeLibrary(pSLE->hSubagentDll);

            } __except (EXCEPTION_EXECUTE_HANDLER) {
        
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: exception 0x%08lx unloading %s.\n",
                    GetExceptionCode(),
                    pSLE->pPathname
                    ));
            }
        }

        // release string
        AgentMemFree(pSLE->pPathname);

        // release structure
        AgentMemFree(pSLE);
    }

    return TRUE;
}


BOOL
LoadSubagents(
    )

/*++

Routine Description:

    Constructs list of subagents.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    TCHAR szName[MAX_PATH];
    TCHAR szValue[MAX_PATH];
    LPTSTR pszKey = REG_KEY_EXTENSION_AGENTS;
    BOOL fOk = FALSE;
        
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading subagents.\n"
        ));
    
    // open registry subkey    
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // initialize
        dwIndex = 0;

        // initialize buffer sizes
        dwNameSize  = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
        dwValueSize = sizeof(szValue); // size in number of bytes

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) {

            // read next value
            lStatus = RegEnumValue(
                        hKey, 
                        dwIndex, 
                        szName, 
                        &dwNameSize,
                        NULL, 
                        &dwValueType, 
                        (LPBYTE)szValue, 
                        &dwValueSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {

                // add subagent to list 
                AddSubagentByKey(szValue);
                    
                // re-initialize buffer sizes
                dwNameSize  = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
                dwValueSize = sizeof(szValue); // size in number of bytes

                // next
                dwIndex++;

            } else if (lStatus == ERROR_NO_MORE_ITEMS) {

                // success
                fOk = TRUE; 
            }
        }
    } 
    
    if (!fOk) {
        
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing Subagents subkey.\n",
            lStatus
            ));
        
        // report event
        ReportSnmpEvent(
            SNMP_EVENT_INVALID_REGISTRY_KEY, 
            1, 
            &pszKey, 
            lStatus
            );
    }

    return fOk;
}


BOOL
UnloadSubagents(
    )

/*++

Routine Description:

    Destroys list of subagents.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PSUBAGENT_LIST_ENTRY pSLE;

    // process entries until list is empty
    while (!IsListEmpty(&g_Subagents)) {

        // extract next entry from head of list
        pLE = RemoveHeadList(&g_Subagents);

        // retrieve pointer to community structure
        pSLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);
 
        // release
        FreeSLE(pSLE);
    }

    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\varbinds.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    varbinds.c

Abstract:

    Contains routines for manipulating varbinds.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "varbinds.h"
#include "query.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadVarBind(
    PNETWORK_LIST_ENTRY pNLE,
    UINT                iVb
    )

/*++

Routine Description:

    Creates varbind list entry from varbind structure.

Arguments:

    pNLE - pointer to network list entry.

    iVb - index of variable binding.

Return Values:

    Returns true if successful.

--*/

{
    SnmpVarBind * pVb;
    PVARBIND_LIST_ENTRY pVLE = NULL;
    PMIB_REGION_LIST_ENTRY pRLE = NULL;
    BOOL fAnyOk;
    BOOL fOk;

    // allocate list entry
    if (fOk = AllocVLE(&pVLE)) {

        // save varbind list index
        pVLE->nErrorIndex = iVb + 1;    

        // retrieve varbind pointer
        pVb = &pNLE->Pdu.Vbl.list[iVb];

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: variable %d name %s.\n",
            pVLE->nErrorIndex,
            SnmpUtilOidToA(&pVb->name)
            ));    

        // initialize type of resolved variable
        pVLE->ResolvedVb.value.asnType = ASN_NULL;

        // copy varbind name to working structure
        SnmpUtilOidCpy(&pVLE->ResolvedVb.name, &pVb->name);

        // see if specific object asked for
        fAnyOk = ((pNLE->Pdu.nType == SNMP_PDU_GETNEXT) ||
                  (pNLE->Pdu.nType == SNMP_PDU_GETBULK));

        // attempt to lookup variable name in supported regions
        if (FindSupportedRegion(&pRLE, &pVb->name, fAnyOk)) {

            // save pointer to region
            pVLE->pCurrentRLE = pRLE;

            // structure has been initialized
            pVLE->nState = VARBIND_INITIALIZED;

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: variable %d assigned to %s.\n",
                pVLE->nErrorIndex,
                pVLE->pCurrentRLE->pSLE->pPathname
                ));    

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: variable %d state '%s'.\n",
                pVLE->nErrorIndex,
                VARBINDSTATESTRING(pVLE->nState)
                ));    

            // see if this is a getnext request
            if (pNLE->Pdu.nType == SNMP_PDU_GETNEXT) {    

                // only need single rep
                pVLE->nMaxRepetitions = 1;

            } else if (pNLE->Pdu.nType == SNMP_PDU_GETBULK) {

                // see if this non-repeater which is in bounds
                if (pNLE->Pdu.Pdu.BulkPdu.nNonRepeaters > (int)iVb) {

                    // only need single rep
                    pVLE->nMaxRepetitions = 1;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d max repetitions %d.\n",
                        pVLE->nErrorIndex,
                        pVLE->nMaxRepetitions
                        ));    

                // see if max-repetitions is non-zero
                } else if (pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions > 0) {

                    // set max-repetitions to value in getbulk pdu
                    pVLE->nMaxRepetitions = pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d max repetitions %d.\n",
                        pVLE->nErrorIndex,
                        pVLE->nMaxRepetitions
                        ));    

                } else {

                    // modify state to resolved 
                    pVLE->nState = VARBIND_RESOLVED;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d value NULL.\n",
                        pVLE->nErrorIndex
                        ));    
                }

            } else if (pNLE->Pdu.nType == SNMP_PDU_SET) {

                // copy varbind value to working structure
                SnmpUtilAsnAnyCpy(&pVLE->ResolvedVb.value, &pVb->value);

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d value %s.\n",
                    pVLE->nErrorIndex,
                    "<TBD>"
                    ));    
            }
    
        } else {

            // null pointer to region
            pVLE->pCurrentRLE = NULL;
            
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: variable %d unable to be assigned.\n",
                pVLE->nErrorIndex
                ));    

            // getbulk            
            if (fAnyOk) {

                // modify state to resolved 
                pVLE->nState = VARBIND_RESOLVED;

                // set the exception in the variable's type field
                pVLE->ResolvedVb.value.asnType = SNMP_EXCEPTION_ENDOFMIBVIEW;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d value ENDOFMIBVIEW.\n",
                    pVLE->nErrorIndex
                    ));    

            } else if (pNLE->Pdu.nType == SNMP_PDU_GET) {

                // modify state to resolved 
                pVLE->nState = VARBIND_RESOLVED;

                // set the exception in the variable's type field
                pVLE->ResolvedVb.value.asnType = SNMP_EXCEPTION_NOSUCHOBJECT;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d value NOSUCHOBJECT.\n",
                    pVLE->nErrorIndex
                    ));    

            } else {

                // modify state to resolved
                //pVLE->nState = VARBIND_ABORTED;
                pVLE->nState = VARBIND_RESOLVED;

                // save error status in network list entry
                pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOTWRITABLE;
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d error %s.\n",
                    pVLE->nErrorIndex,
                    SNMPERRORSTRING(pNLE->Pdu.Pdu.NormPdu.nErrorStatus)
                    ));    
                
                // failure
                //fOk = FALSE;
            }
        }

        // add to existing varbind list
        InsertTailList(&pNLE->Bindings, &pVLE->Link);
    }
    
    return fOk;
}


BOOL
LoadVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Creates list of varbind entries from varbind structure.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    UINT iVb;
    BOOL fOk = TRUE;
    
    // process each varbind in list
    for (iVb = 0; (fOk && (iVb < pNLE->Pdu.Vbl.len)); iVb++) {

        // load individual varbind
        fOk = LoadVarBind(pNLE, iVb);
    }

    return fOk;
}


BOOL
UnloadVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Destroys list of varbind entries.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;

    // process each varbind entry
    while (!IsListEmpty(&pNLE->Bindings)) {

        // point to first varbind
        pLE = RemoveHeadList(&pNLE->Bindings);

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

        // release
        FreeVLE(pVLE);
    }    

    return TRUE;
}


BOOL
ValidateVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Updates error status based on query results and version.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;

    // see if error has already report during processing
    if (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR) {
        
        // point to first varbind
        pLE = pNLE->Bindings.Flink;

        // process each varbind entry
        while (pLE != &pNLE->Bindings) {

            // retrieve pointer to varbind entry from link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

            // see if varbind has been resolved
            if (pVLE->nState != VARBIND_RESOLVED) {       

                SNMPDBG((
                    SNMP_LOG_WARNING,
                    "SNMP: SVC: variable %d unresolved.\n",
                    pVLE->nErrorIndex
                    ));

                // report internal error has occurred
                pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                break; // bail...
            
            } else if (pNLE->nVersion == SNMP_VERSION_1) {
        
                // report error if exceptions are present instead of values
                if ((pVLE->ResolvedVb.value.asnType == SNMP_EXCEPTION_NOSUCHOBJECT) ||
                    (pVLE->ResolvedVb.value.asnType == SNMP_EXCEPTION_NOSUCHINSTANCE) ||
                    (pVLE->ResolvedVb.value.asnType == SNMP_EXCEPTION_ENDOFMIBVIEW)) {
                        
                    SNMPDBG((
                        SNMP_LOG_WARNING,
                        "SNMP: SVC: variable %d unresolved in SNMPv1.\n",
                        pVLE->nErrorIndex
                        ));

                    // report that variable could not be found
                    pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
                    pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                    break; // bail...
                }
            }

            // next entry
            pLE = pLE->Flink;
        }    
    }

    // see if this is first version
    if (pNLE->nVersion == SNMP_VERSION_1) {

        // adjust status code
        switch (pNLE->Pdu.Pdu.NormPdu.nErrorStatus) {

        case SNMP_ERRORSTATUS_NOERROR:
        case SNMP_ERRORSTATUS_TOOBIG:
        case SNMP_ERRORSTATUS_NOSUCHNAME:
        case SNMP_ERRORSTATUS_BADVALUE:
        case SNMP_ERRORSTATUS_READONLY:
        case SNMP_ERRORSTATUS_GENERR:
            break;

        case SNMP_ERRORSTATUS_NOACCESS:
        case SNMP_ERRORSTATUS_NOCREATION:
        case SNMP_ERRORSTATUS_NOTWRITABLE:
        case SNMP_ERRORSTATUS_AUTHORIZATIONERROR:
        case SNMP_ERRORSTATUS_INCONSISTENTNAME:
            pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;

        case SNMP_ERRORSTATUS_WRONGTYPE:
        case SNMP_ERRORSTATUS_WRONGLENGTH:
        case SNMP_ERRORSTATUS_WRONGENCODING:
        case SNMP_ERRORSTATUS_WRONGVALUE:
        case SNMP_ERRORSTATUS_INCONSISTENTVALUE:
            pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_BADVALUE;
            break;

        case SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE:
        case SNMP_ERRORSTATUS_COMMITFAILED:
        case SNMP_ERRORSTATUS_UNDOFAILED:
        default:
            pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
            break;
        }
    }

    return (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR);
}


BOOL
UpdateVarBindsFromResolvedVb(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Updates varbinds with results containing single varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
    
    // point to first varbind
    pLE = pNLE->Bindings.Flink;

    // process each varbind entry
    while (pLE != &pNLE->Bindings) {

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: variable %d resolved name %s.\n",
            pVLE->nErrorIndex,
            SnmpUtilOidToA(&pVLE->ResolvedVb.name)
            ));    

        // release memory for original varbind
        SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[pVLE->nErrorIndex - 1]);

        // copy resolved varbind structure into pdu varbindlist
        SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[pVLE->nErrorIndex - 1], 
                           &pVLE->ResolvedVb
                           );

        // next entry
        pLE = pLE->Flink;
    }

    // success
    return TRUE;
}


BOOL
UpdateVarBindsFromResolvedVbl(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Updates varbinds with results containing multiple varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    UINT nRepeaters;
    UINT nNonRepeaters;
    UINT nMaxRepetitions;
    UINT nIterations;
    UINT nVarBindsLast;
    UINT nVarBinds = 0;
    SnmpVarBind * pVarBind;
    PVARBIND_LIST_ENTRY pVLE;
    PLIST_ENTRY pLE1;
    PLIST_ENTRY pLE2;

    // retrieve getbulk parameters from pdu
    nNonRepeaters   = pNLE->Pdu.Pdu.BulkPdu.nNonRepeaters;
    nMaxRepetitions = pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions;
    nRepeaters      = (pNLE->Pdu.Vbl.len >= nNonRepeaters)
                         ? (pNLE->Pdu.Vbl.len - nNonRepeaters)
                         : 0
                         ;

    // see if we need to expand size of varbind list
    if ((nRepeaters > 0) && (nMaxRepetitions > 1)) {
    
        UINT nMaxVarBinds;
        SnmpVarBind * pVarBinds;

        // calculate maximum number of varbinds possible
        nMaxVarBinds = nNonRepeaters + (nMaxRepetitions * nRepeaters);
    
        // reallocate varbind list to fit maximum
        pVarBinds = SnmpUtilMemReAlloc(pNLE->Pdu.Vbl.list, 
                                       nMaxVarBinds * sizeof(SnmpVarBind)
                                       );

        // validate pointer
        if (pVarBinds == NULL) {    
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: Could not re-allocate varbind list.\n"
                ));

            return FALSE; // bail...
        }

        // restore varbind pointer
        pNLE->Pdu.Vbl.list = pVarBinds;
    }

    // point to first varbind
    pLE1 = pNLE->Bindings.Flink;

    // process each varbind entry
    while (pLE1 != &pNLE->Bindings) {

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE1, VARBIND_LIST_ENTRY, Link);

        // see if this is non-repeater
        if (pVLE->nMaxRepetitions == 1) {

            // release memory for original varbind
            SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[nVarBinds]);

            // copy resolved varbind into pdu structure
            SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[nVarBinds++],
                               &pVLE->ResolvedVb
                               );

        } else {

            //
            // finished processing non-repeaters 
            //

            break;
        }

        // next entry
        pLE1 = pLE1->Flink;
    }

    // initialize
    nIterations = 0;

    // store
    pLE2 = pLE1; 

    // process any repeaters until max
    while (nIterations < nMaxRepetitions) {

        // restore
        pLE1 = pLE2;        

        // process each varbind entry
        while (pLE1 != &pNLE->Bindings) {

            // retrieve pointer to varbind entry from link
            pVLE = CONTAINING_RECORD(pLE1, VARBIND_LIST_ENTRY, Link);

            // see if value stored in default
            if (pVLE->ResolvedVbl.len == 0) {

                // release memory for original varbind 
                SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[nVarBinds]);

                // copy resolved varbind into pdu varbind list
                SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[nVarBinds],
                                   &pVLE->ResolvedVb
                                   );

                // increment
                nVarBinds++;

            // see if value available in this iteration
            } else if (pVLE->ResolvedVbl.len > nIterations) {

                // release memory for original varbind 
                SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[nVarBinds]);

                // copy resolved varbind into pdu varbind list
                SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[nVarBinds],
                                   &pVLE->ResolvedVbl.list[nIterations]
                                   );

                // increment
                nVarBinds++;
            }

            // next entry
            pLE1 = pLE1->Flink;
        }
    
        // increment
        nIterations++;
    }

    // save new varbind count
    pNLE->Pdu.Vbl.len = nVarBinds;

    // success
    return TRUE;
}


BOOL
UpdatePdu(
    PNETWORK_LIST_ENTRY pNLE,
    BOOL                fOk
    )

/*++

Routine Description:

    Updates pdu with query results.

Arguments:

    pNLE - pointer to network list entry.

    fOk - true if process succeeded to this point.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;

    // validate
    if (fOk) {
        
        // make sure varbinds valid
        fOk = ValidateVarBinds(pNLE);

        // validate
        if (fOk) {

            // see if pdu type is getnext or getbulk
            if (pNLE->Pdu.nType != SNMP_PDU_GETBULK) {

                // update varbinds with single result
                fOk = UpdateVarBindsFromResolvedVb(pNLE);

            } else {

                // update varbinds with multiple results
                fOk = UpdateVarBindsFromResolvedVbl(pNLE);
            }
        }
    }

    // trap internal errors that have not been accounted for as of yet
    if (!fOk && (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR)) {

        // report status that was determined above
        pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
        pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = 0;
    }

    if (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR)
    {
        switch(pNLE->Pdu.nType)
        {
        case SNMP_PDU_GETNEXT:
        case SNMP_PDU_GETBULK:
        case SNMP_PDU_GET:
            // update counter for successful GET-NEXT GET-BULK
            mgmtCAdd(CsnmpInTotalReqVars, pNLE->Pdu.Vbl.len);
            break;
        case SNMP_PDU_SET:
            // update counter for successful SET
            mgmtCAdd(CsnmpInTotalSetVars, pNLE->Pdu.Vbl.len);
            break;
        }
    }
    else
    {
        // update here counters for all OUT errors
        mgmtUtilUpdateErrStatus(OUT_errStatus, pNLE->Pdu.Pdu.NormPdu.nErrorStatus);
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocVLE(
    PVARBIND_LIST_ENTRY * ppVLE
    )

/*++

Routine Description:

    Allocates varbind structure and initializes.

Arguments:

    ppVLE - pointer to receive pointer to entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PVARBIND_LIST_ENTRY pVLE = NULL;

    // attempt to allocate structure
    pVLE = AgentMemAlloc(sizeof(VARBIND_LIST_ENTRY));

    // validate
    if (pVLE != NULL) {

        // success
        fOk = TRUE;
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate varbind entry.\n"
            ));
    }    

    // transfer
    *ppVLE = pVLE;

    return fOk;
}


BOOL 
FreeVLE(
    PVARBIND_LIST_ENTRY pVLE
    )

/*++

Routine Description:

    Releases varbind structure.

Arguments:

    pVLE - pointer to list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pVLE != NULL) {

        // release current varbind
        SnmpUtilVarBindFree(&pVLE->ResolvedVb);

        // release current varbind list
        SnmpUtilVarBindListFree(&pVLE->ResolvedVbl);

        // release structure
        AgentMemFree(pVLE);
    }

    return TRUE;
}


BOOL
ProcessVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Creates list of varbind entries from varbind structure.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // validate type before processing
    if ((pNLE->Pdu.nType == SNMP_PDU_SET) ||
        (pNLE->Pdu.nType == SNMP_PDU_GET) ||
        (pNLE->Pdu.nType == SNMP_PDU_GETNEXT) ||
        (pNLE->Pdu.nType == SNMP_PDU_GETBULK)) {

        // initialize varbinds
        if (LoadVarBinds(pNLE)) {

            // process queries 
            fOk = ProcessQueries(pNLE);
        }

        // transfer results 
        UpdatePdu(pNLE, fOk);
    
        // unload varbinds
        UnloadVarBinds(pNLE);

        // update management counters for accepted and processed requests
        switch(pNLE->Pdu.nType)
        {
        case SNMP_PDU_GET:
            mgmtCTick(CsnmpInGetRequests);
            break;
        case SNMP_PDU_GETNEXT:
        case SNMP_PDU_GETBULK:
            mgmtCTick(CsnmpInGetNexts);
            break;
        case SNMP_PDU_SET:
            mgmtCTick(CsnmpInSetRequests);
            break;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ignoring unknown pdu type %d.\n",
            pNLE->Pdu.nType
            ));
    }

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\trapthrd.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapthrd.c

Abstract:

    Contains routines for trap processing thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "trapthrd.h"
#include "subagnts.h"
#include "snmppdus.h"
#include "trapmgrs.h"
#include "snmpmgrs.h"
#include "network.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static SnmpVarBindList g_NullVbl = { NULL, 0 };


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadWaitObjects(
    DWORD * pnWaitObjects,
    PHANDLE * ppWaitObjects,
    PSUBAGENT_LIST_ENTRY ** pppNLEs
    )

/*++

Routine Description:

    Loads arrays with necessary wait object information.

Arguments:

    pnWaitObjects - pointer to receive count of wait objects.

    ppWaitObjects - pointer to receive wait object handles.

    pppNLEs - pointer to receive array of associated subagents pointers.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PSUBAGENT_LIST_ENTRY pNLE;
    PSUBAGENT_LIST_ENTRY * ppNLEs = NULL;
    PHANDLE pWaitObjects = NULL;
    DWORD nWaitObjects = 2;
    BOOL fOk = FALSE;

    EnterCriticalSection(&g_RegCriticalSectionB);
    
    // point to first subagent
    pLE = g_Subagents.Flink;

    // process each subagent
    while (pLE != &g_Subagents) {

        // retreive pointer to subagent list entry from link
        pNLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);

        // check for subagent trap event
        if (pNLE->hSubagentTrapEvent != NULL) {
        
            // increment        
            nWaitObjects++;
        }            

        // next entry
        pLE = pLE->Flink;
    }
    
    // attempt to allocate array of subagent pointers
    ppNLEs = AgentMemAlloc(nWaitObjects * sizeof(PSUBAGENT_LIST_ENTRY));
        
    // validate pointers
    if (ppNLEs != NULL) {

        // attempt to allocate array of event handles
        pWaitObjects = AgentMemAlloc(nWaitObjects * sizeof(HANDLE));

        // validate pointer
        if (pWaitObjects != NULL) {

            // success
            fOk = TRUE;

        } else {
                
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not allocate handle array.\n"
                ));

            // release array
            AgentMemFree(ppNLEs);
    
            // re-init
            ppNLEs = NULL;
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate subagent pointers.\n"
            ));
    }
    
    if (fOk) {
    
        // initialize
        DWORD dwIndex = 0;

        // point to first subagent
        pLE = g_Subagents.Flink;

        // process each subagent and check for overflow
        while ((pLE != &g_Subagents) && (dwIndex < nWaitObjects - 1)) {

            // retreive pointer to subagent list entry from link
            pNLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);

            // check for subagent trap event
            if (pNLE->hSubagentTrapEvent != NULL) {
            
                // copy subagent trap event handle
                pWaitObjects[dwIndex] = pNLE->hSubagentTrapEvent;

                // copy subagent pointer
                ppNLEs[dwIndex] = pNLE;

                // next
                dwIndex++;
            }            

            // next entry
            pLE = pLE->Flink;
        }

        // copy registry update event into second last entry
        pWaitObjects[dwIndex++] = g_hRegistryEvent;

        // copy termination event into last entry
        pWaitObjects[dwIndex++] = g_hTerminationEvent;

        // validate number of items
        if (dwIndex != nWaitObjects) {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: updating number of events from %d to %d.\n",
                nWaitObjects,
                dwIndex
                ));

            // use latest number
            nWaitObjects = dwIndex;
        }
    }

    // transfer wait object information 
    *pnWaitObjects = fOk ? nWaitObjects : 0;
    *ppWaitObjects = pWaitObjects;
    *pppNLEs = ppNLEs;

    LeaveCriticalSection(&g_RegCriticalSectionB);

    return fOk;
}


BOOL
UnloadWaitObjects(
    PHANDLE pWaitObjects,
    PSUBAGENT_LIST_ENTRY * ppNLEs
    )

/*++

Routine Description:

    Loads arrays with necessary wait object information.

Arguments:

    pWaitObjects - pointer to wait object handles.

    ppNLEs - pointer to array of associated subagents pointers.

Return Values:

    Returns true if successful.

--*/

{
    // release array
    AgentMemFree(pWaitObjects);

    // release array
    AgentMemFree(ppNLEs);
    
    return TRUE;
}


BOOL
GenerateExtensionTrap(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32          nGenericTrap,
    AsnInteger32          nSpecificTrap,
    AsnTimeticks          nTimeStamp,
    SnmpVarBindList *     pVbl
    )

/*

Routine Description:

    Generates trap for subagent.

Arguments:

    pEnterpriseOid - pointer to EnterpriseOid OID.

    nGenericTrap - generic trap identifier.

    nSpecificTrap - EnterpriseOid specific trap identifier.

    nTimeStamp - timestamp to include in trap.

    pVbl - pointer to optional variables.

Return Values:

    Returns true if successful.

*/

{
    SNMP_PDU Pdu;
    BOOL fOk = FALSE;

    // note this is in older format
    Pdu.nType = SNMP_PDU_V1TRAP;

    // validate pointer 
    if (pVbl != NULL) {

        // copy varbinds 
        Pdu.Vbl = *pVbl;

    } else {

        // initialize
        Pdu.Vbl.len = 0;
        Pdu.Vbl.list = NULL;
    }

    // validate enterprise oid
    if ((pEnterpriseOid != NULL) &&
        (pEnterpriseOid->ids != NULL) &&
        (pEnterpriseOid->idLength != 0)) {

        // transfer specified enterprise oid
        Pdu.Pdu.TrapPdu.EnterpriseOid = *pEnterpriseOid;

    } else {

        // transfer microsoft enterprise oid 
        // Note: transfer the AsnObjectIdentifier structure as a whole, but no new memory is allocated
        // for the 'ids' buffer. Hence, Pdu....EnterpriseOid should not be 'SnmpUtilFreeOid'!!
        Pdu.Pdu.TrapPdu.EnterpriseOid = snmpMgmtBase.AsnObjectIDs[OsnmpSysObjectID].asnValue.object;
    }    

    // make sure that the system uptime is consistent by overriding
    Pdu.Pdu.TrapPdu.nTimeticks = nTimeStamp ? SnmpSvcGetUptime() : 0;

    // transfer the remaining parameters 
    Pdu.Pdu.TrapPdu.nGenericTrap  = nGenericTrap;
    Pdu.Pdu.TrapPdu.nSpecificTrap = nSpecificTrap;

    // initialize agent address structure
    Pdu.Pdu.TrapPdu.AgentAddr.dynamic = FALSE;
    Pdu.Pdu.TrapPdu.AgentAddr.stream  = NULL;
    Pdu.Pdu.TrapPdu.AgentAddr.length  = 0;

    // send trap to managers
    return GenerateTrap(&Pdu);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessSubagentEvents(
    )

/*++

Routine Description:

    Processes subagent trap events.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY * ppNLEs = NULL;
    PHANDLE pWaitObjects = NULL;
    DWORD nWaitObjects = 0;
    DWORD dwIndex;

    // attempt to load waitable objects into array
    if (LoadWaitObjects(&nWaitObjects, &pWaitObjects, &ppNLEs)) {

        // loop
        for (;;) {

            // subagent event or termination 
            dwIndex = WaitForMultipleObjects(
                            nWaitObjects,
                            pWaitObjects,
                            FALSE,
                            INFINITE
                            );

            // check for process termination event first 
            // note: g_hTerminationEvent is a manual reset event
            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hTerminationEvent, 0)) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: shutting down trap thread.\n"
                    ));
                
                break; // bail...

            // check for registry update event next
            } else if (dwIndex == (WAIT_OBJECT_0 + nWaitObjects - 2)) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: recalling LoadWaitObjects.\n"
                    ));
                
                if (!LoadWaitObjects(&nWaitObjects, &pWaitObjects, &ppNLEs))
                    break;

            // check for subagent trap notification event
            } else if (dwIndex < (WAIT_OBJECT_0 + nWaitObjects - 1)) {

                AsnObjectIdentifier EnterpriseOid;
                AsnInteger          nGenericTrap;
                AsnInteger          nSpecificTrap;
                AsnInteger          nTimeStamp;
                SnmpVarBindList     Vbl;

                PFNSNMPEXTENSIONTRAP pfnSnmpExtensionTrap;

                // retrieve pointer to subagent trap entry point
                pfnSnmpExtensionTrap = ppNLEs[dwIndex]->pfnSnmpExtensionTrap;
                                
                // validate function pointer                    
                if (pfnSnmpExtensionTrap != NULL) {            

                    __try {

                        // loop until false is returned
                        while ((*pfnSnmpExtensionTrap)(
                                    &EnterpriseOid,
                                    &nGenericTrap,
                                    &nSpecificTrap,
                                    &nTimeStamp,
                                    &Vbl)) {
                                    
                            // send extension trap                                
                            GenerateExtensionTrap(
                                &EnterpriseOid,
                                nGenericTrap,
                                nSpecificTrap,
                                nTimeStamp,
                                &Vbl
                                );

                            SnmpUtilVarBindListFree(&Vbl);
                            
                            // check for process termination event while we are in this while loop 
                            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hTerminationEvent, 0)) 
                            {
                
                                SNMPDBG((
                                    SNMP_LOG_TRACE,
                                    "SNMP: SVC: shutting down trap thread in \"while((*pfnSnmpExtensionTrap)\" loop.\n"
                                    ));
                
                                break; // bail...
                            }
                        }
                    
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: exception 0x%08lx polling %s.\n",
                            GetExceptionCode(),
                            ppNLEs[dwIndex]->pPathname
                            ));
                    }
                }
            }            
        }
    
        // release memory for wait objects
        UnloadWaitObjects(pWaitObjects, ppNLEs);
    }

    return fOk;
}


BOOL
GenerateTrap(
    PSNMP_PDU pPdu
    )

/*

Routine Description:

    Generates trap for agent.

Arguments:

    pPdu - pointer to initialized TRAP or TRAPv1 PDU.

Return Values:

    Returns true if successful.

*/

{
    BOOL fOk = TRUE;
    PLIST_ENTRY pLE1;
    PLIST_ENTRY pLE2;
    PLIST_ENTRY pLE3;
    PNETWORK_LIST_ENTRY pNLE;
    PMANAGER_LIST_ENTRY pMLE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE;
    AsnOctetString CommunityOctets;
    DWORD dwStatus;
    DWORD dwIPAddr;

    EnterCriticalSection(&g_RegCriticalSectionC);
    // obtain first trap destination
    pLE1 = g_TrapDestinations.Flink;

    // process each trap destination
    while (pLE1 != &g_TrapDestinations) {

        // retrieve pointer to outgoing transport structure
        pTLE = CONTAINING_RECORD(pLE1, TRAP_DESTINATION_LIST_ENTRY, Link);

        // copy community string into octet structure
        CommunityOctets.length  = strlen(pTLE->pCommunity);
        CommunityOctets.stream  = pTLE->pCommunity;
        CommunityOctets.dynamic = FALSE;

        // obtain first manager
        pLE2 = pTLE->Managers.Flink;

        // process each receiving manager
        while (pLE2 != &pTLE->Managers) {

            // retrieve pointer to next manager
            pMLE = CONTAINING_RECORD(pLE2, MANAGER_LIST_ENTRY, Link);
            
            // refresh addr 
            UpdateMLE(pMLE);

            // don't send traps to addresses that are DEAD or NULL
            if (pMLE->dwAge == MGRADDR_DEAD || 
                !IsValidSockAddr(&pMLE->SockAddr))
            {
                pLE2 = pLE2->Flink;
                continue;
            }
        
            // obtain first outgoing transport
            pLE3 = g_OutgoingTransports.Flink;

            // process each outgoing transport
            while (pLE3 != &g_OutgoingTransports) {

                // retrieve pointer to outgoing transport structure
                pNLE = CONTAINING_RECORD(pLE3, NETWORK_LIST_ENTRY, Link);

                // initialize buffer length
                pNLE->Buffer.len = NLEBUFLEN;

                // can only send on same protocol
                if (pNLE->SockAddr.sa_family != pMLE->SockAddr.sa_family)
                {
                    pLE3 = pLE3->Flink;
                    continue;
                }

                // modify agent address
                if (pNLE->SockAddr.sa_family == AF_INET) 
                {

                    struct sockaddr_in * pSockAddrIn;
                    DWORD                szSockToBind;

                    // see if the trap destination address is valid and if the
                    // card to use for sending the trap could be determined
                    if (WSAIoctl(pNLE->Socket,
                             SIO_ROUTING_INTERFACE_QUERY,
                             &pMLE->SockAddr,
                             sizeof(pMLE->SockAddr),
                             &pNLE->SockAddr,
                             sizeof(pNLE->SockAddr),
                             &szSockToBind,
                             NULL,
                             NULL) == SOCKET_ERROR)
                    {
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: cannot determine interface to use for trap destination %s [err=%d].\n",
                            inet_ntoa(((struct sockaddr_in *)&pMLE->SockAddr)->sin_addr),
                            WSAGetLastError()
                            ));
                        // if we can't determine on what interface the trap will be sent from, just bail.
                        pLE3 = pLE3->Flink;
                        continue;
                    }
                    
                    // obtain pointer to protocol specific structure
                    pSockAddrIn = (struct sockaddr_in * )&pNLE->SockAddr;

                    // copy agent address into temp buffer
                    dwIPAddr = pSockAddrIn->sin_addr.s_addr;

                    // initialize agent address structure
                    pPdu->Pdu.TrapPdu.AgentAddr.dynamic = FALSE;
                    pPdu->Pdu.TrapPdu.AgentAddr.stream  = (LPBYTE)&dwIPAddr;
                    pPdu->Pdu.TrapPdu.AgentAddr.length  = sizeof(dwIPAddr);

                } else {

                    // re-initialize agent address structure
                    pPdu->Pdu.TrapPdu.AgentAddr.dynamic = FALSE;
                    pPdu->Pdu.TrapPdu.AgentAddr.stream  = NULL;
                    pPdu->Pdu.TrapPdu.AgentAddr.length  = 0;
                }

                // build message
                if (BuildMessage(
                        SNMP_VERSION_1,
                        &CommunityOctets,
                        pPdu,
                        pNLE->Buffer.buf,
                        &pNLE->Buffer.len
                        )) {
                                
                    // synchronous send
                    dwStatus = WSASendTo(
                                  pNLE->Socket,
                                  &pNLE->Buffer,
                                  1,
                                  &pNLE->dwBytesTransferred,
                                  pNLE->dwFlags,
                                  &pMLE->SockAddr,
                                  pMLE->SockAddrLen,
                                  NULL,
                                  NULL
                                  );
                            
                    // register outgoing packet into the management structure
                    mgmtCTick(CsnmpOutPkts);
                    // retister outgoing trap into the management structure
                    mgmtCTick(CsnmpOutTraps);

                    // validate return code
                    if (dwStatus == SOCKET_ERROR) {
                        
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: error code %d on sending trap to %s.\n",
                            WSAGetLastError(),
                            pTLE->pCommunity
                            ));
                    }
                }    

                // next entry
                pLE3 = pLE3->Flink;
            }

            // next entry
            pLE2 = pLE2->Flink;
        }

        // next entry
        pLE1 = pLE1->Flink;                
    }
    LeaveCriticalSection(&g_RegCriticalSectionC);

    return fOk;
}


BOOL
GenerateColdStartTrap(
    )

/*

Routine Description:

    Generates cold start trap.

Arguments:

    None.

Return Values:

    Returns true if successful.

*/

{
    // generate cold start
    return GenerateExtensionTrap(
                NULL,   // pEnterpriseOid
                SNMP_GENERICTRAP_COLDSTART,
                0,      // nSpecificTrapId
                0,      // nTimeStamp
                &g_NullVbl
                );    
}


BOOL
GenerateAuthenticationTrap(
    )

/*

Routine Description:

    Generates authentication trap.

Arguments:

    None.

Return Values:

    Returns true if successful.

*/

{
    // generate cold start
    return GenerateExtensionTrap(
                NULL,   // pEnterpriseOid
                SNMP_GENERICTRAP_AUTHFAILURE,
                0,      // nSpecificTrapId
                SnmpSvcGetUptime(),
                &g_NullVbl
                );    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\trapmgrs.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapmgrs.c

Abstract:

    Contains routines for manipulating trap destination structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "snmpmgrs.h"
#include "trapmgrs.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindTrapDestination(
    PTRAP_DESTINATION_LIST_ENTRY * ppTLE,
    LPSTR                          pCommunity
    )

/*++

Routine Description:

    Locates valid trap destination in list.

Arguments:

    ppTLE - pointer to receive pointer to entry.

    pCommunity - pointer to trap destination to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE;

    // initialize
    *ppTLE = NULL;

    // obtain pointer to list head
    pLE = g_TrapDestinations.Flink;

    // process all entries in list
    while (pLE != &g_TrapDestinations) {

        // retrieve pointer to trap destination structure
        pTLE = CONTAINING_RECORD(pLE, TRAP_DESTINATION_LIST_ENTRY, Link);

        // compare trap destination string with entry
        if (!strcmp(pTLE->pCommunity, pCommunity)) {

            // transfer
            *ppTLE = pTLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
AddTrapDestination(
    HKEY   hKey,
    LPWSTR pwCommunity
    )

/*++

Routine Description:

    Adds trap destination to list.

Arguments:

    hKey - trap destination subkey.

    pwCommunity - pointer to trap destination to add.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hSubKey;
    LONG lStatus;
    BOOL fOk = FALSE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE = NULL;
    LPSTR pCommunity = NULL;

    // open registry subkey    
    lStatus = RegOpenKeyExW(
                hKey,
                pwCommunity,
                0,
                KEY_READ,
                &hSubKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS &&
        SnmpUtilUnicodeToUTF8(
            &pCommunity,
            pwCommunity,
            TRUE) == 0) {

        // attempt to locate in list    
        if (FindTrapDestination(&pTLE, pCommunity)) {
                            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: updating trap destinations for %s.\n",
                pCommunity
                ));
            
            // load associated managers
            LoadManagers(hSubKey, &pTLE->Managers);

            // success
            fOk = TRUE;

        } else {

            // allocate trap destination structure
            if (AllocTLE(&pTLE, pCommunity)) {
                                
                SNMPDBG((
                    SNMP_LOG_TRACE, 
                    "SNMP: SVC: adding trap destinations for %s.\n",
                    pCommunity
                    ));

                // load associated managers
                if (LoadManagers(hSubKey, &pTLE->Managers)) {

                    // insert into valid communities list
                    InsertTailList(&g_TrapDestinations, &pTLE->Link);

                    // success
                    fOk = TRUE;
                }

                // cleanup
                if (!fOk) {

                    // release
                    FreeTLE(pTLE);
                }
            }
        }

        // release subkey
        RegCloseKey(hSubKey);

        SnmpUtilMemFree(pCommunity);
    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocTLE(
    PTRAP_DESTINATION_LIST_ENTRY * ppTLE,
    LPSTR                          pCommunity 
    )

/*++

Routine Description:

    Allocates trap destination structure and initializes.

Arguments:

    ppTLE - pointer to receive pointer to entry.

    pCommunity - pointer to trap destination string.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE = NULL;

    // attempt to allocate structure
    pTLE = AgentMemAlloc(sizeof(TRAP_DESTINATION_LIST_ENTRY));

    // validate
    if (pTLE != NULL) {

        // allocate memory for trap destination string
        pTLE->pCommunity = AgentMemAlloc(strlen(pCommunity)+1);

        // validate
        if (pTLE->pCommunity != NULL) {

            // transfer trap destination string
            strcpy(pTLE->pCommunity, pCommunity);

            // initialize list of managers
            InitializeListHead(&pTLE->Managers);

            // success
            fOk = TRUE;
        } 

        // cleanup        
        if (!fOk) {

            // release 
            FreeTLE(pTLE);

            // re-init
            pTLE = NULL;            
        }
    }

    // transfer
    *ppTLE = pTLE;

    return fOk;
}


BOOL 
FreeTLE(
    PTRAP_DESTINATION_LIST_ENTRY pTLE
    )

/*++

Routine Description:

    Releases trap destination structure.

Arguments:

    pTLE - pointer to trap destination list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pTLE != NULL) {

        // release manager structures
        UnloadManagers(&pTLE->Managers);

        // release string
        AgentMemFree(pTLE->pCommunity);

        // release structure
        AgentMemFree(pTLE);
    }

    return TRUE;
}


BOOL
LoadTrapDestinations(
    BOOL bFirstCall
    )

/*++

Routine Description:

    Constructs list of trap destinations.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    WCHAR wszName[MAX_PATH];
    BOOL  fPolicy;
    LPTSTR pszKey;
    BOOL fOk = FALSE;
        
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading trap destinations.\n"
        ));

#ifdef _POLICY
    // we need to provide precedence to the parameters set through the policy
    fPolicy = TRUE;
#else
    fPolicy = FALSE;
#endif

    do
    {
        // if the policy is to be enforced, check the policy registry location first
        pszKey = fPolicy ? REG_POLICY_TRAP_DESTINATIONS : REG_KEY_TRAP_DESTINATIONS;

        // open registry subkey    
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    pszKey,
                    0,
                    KEY_READ,
                    &hKey
                    );
        // if the call succeeded or we were not checking the policy, break the loop
        if (lStatus == ERROR_SUCCESS || !fPolicy)
            break;

        // being at this point, this means we were checking for the policy parameters.
        // If and only if the policy is not defined (registry key is missing) we
        // reset the error, mark 'fPolicy already tried' and go back into the loop
        if (lStatus == ERROR_FILE_NOT_FOUND)
        {
            lStatus = ERROR_SUCCESS;
            fPolicy = FALSE;
        }
    } while (lStatus == ERROR_SUCCESS);

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // initialize
        dwIndex = 0;

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) {

            // read next value
            lStatus = RegEnumKeyW(
                        hKey, 
                        dwIndex, 
                        wszName, 
                        sizeof(wszName) / sizeof(wszName[0])
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {

                // add trap destination to list 
                if (AddTrapDestination(hKey, wszName)) {

                    // next
                    dwIndex++;

                } else {

                    // reset status to reflect failure
                    lStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            
            } else if (lStatus == ERROR_NO_MORE_ITEMS) {

                // success
                fOk = TRUE; 
            }
        }
    }
    else
        // it doesn't matter how the values are, the key has to exist,
        // so mark as bFirstCall in order to log an event if this is not true.
        bFirstCall = TRUE;    
    
    if (!fOk) {
        
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing TrapDestinations subkey.\n",
            lStatus
            ));

        // log an event only if on first call (service initialization)
        // otherwise, due to registry operations through regedit, the event log
        // might get flooded with records
        if (bFirstCall)
            // report event
            ReportSnmpEvent(
                SNMP_EVENT_INVALID_REGISTRY_KEY, 
                1, 
                &pszKey, 
                lStatus
                );
    }

    return fOk;
}


BOOL
UnloadTrapDestinations(
    )

/*++

Routine Description:

    Destroys list of trap destinations.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE;

    // process entries until list is empty
    while (!IsListEmpty(&g_TrapDestinations)) {

        // extract next entry from head of list
        pLE = RemoveHeadList(&g_TrapDestinations);

        // retrieve pointer to trap destination structure
        pTLE = CONTAINING_RECORD(pLE, TRAP_DESTINATION_LIST_ENTRY, Link);
 
        // release
        FreeTLE(pTLE);
    }

    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\contexts.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    contexts.h

Abstract:

    Contains definitions for manipulating SNMP community structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _CONTEXTS_H_
#define _CONTEXTS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _COMMUNITY_LIST_ENTRY {

    LIST_ENTRY     Link;
    DWORD          dwAccess;     
    AsnOctetString Community;

} COMMUNITY_LIST_ENTRY, *PCOMMUNITY_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocCLE(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    LPWSTR                  pCommunity
    );

BOOL 
FreeCLE(
    PCOMMUNITY_LIST_ENTRY pCLE
    );

BOOL
FindValidCommunity(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    AsnOctetString *        pCommunity
    );

BOOL
LoadValidCommunities(
    BOOL    bFirstCall
    );

BOOL
UnloadValidCommunities(
    );

#endif // _CONTEXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\args.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    args.h

Abstract:

    Contains definitions for processing command line arguments.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _ARGS_H_
#define _ARGS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _CMD_LINE_ARGUMENTS {

    UINT nLogType;
    UINT nLogLevel;
    BOOL fBypassCtrlDispatcher;

} CMD_LINE_ARGUMENTS, *PCMD_LINE_ARGUMENTS;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessArguments(
    DWORD  NumberOfArgs,
    LPSTR ArgumentPtrs[]
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFINE_ARGUMENT(x) \
    (x ## _ARGUMENT)

#define IS_ARGUMENT(x,y) \
    (!_strnicmp(((LPSTR)(x)),DEFINE_ARGUMENT(y),strlen(DEFINE_ARGUMENT(y))))

#define DWORD_ARGUMENT(x,y) \
    (atoi(&((LPSTR)(x))[strlen(DEFINE_ARGUMENT(y))]))

#define DEBUG_ARGUMENT      "/debug"
#define LOGTYPE_ARGUMENT    "/logtype:"
#define LOGLEVEL_ARGUMENT   "/loglevel:"

#define INVALID_ARGUMENT    0xffffffff

#endif // _ARGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\mem.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.h

Abstract:

    Contains memory allocation routines for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _MEM_H_
#define _MEM_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AgentHeapCreate(
    );

BOOL
AgentHeapDestroy(
    );

LPVOID
AgentMemAlloc(
    UINT nBytes
    );

VOID
AgentMemFree(
    LPVOID pMem
    );

#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\network.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    network.h

Abstract:

    Contains definitions for manipulating transport structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _NETWORK_H_
#define _NETWORK_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "snmppdus.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _NETWORK_LIST_ENTRY {

    LIST_ENTRY      Link;
    SOCKET          Socket;
    struct sockaddr SockAddr;
    INT             SockAddrLen;
    INT             SockAddrLenUsed;
    WSAOVERLAPPED   Overlapped;
    DWORD           dwStatus;
    DWORD           dwBytesTransferred;
    DWORD           dwFlags;
    WSABUF          Buffer;
    LIST_ENTRY      Bindings;
    LIST_ENTRY      Queries;
    SNMP_PDU        Pdu;
    UINT            nVersion;
    UINT            nTransactionId;
    AsnOctetString  Community;

} NETWORK_LIST_ENTRY, *PNETWORK_LIST_ENTRY;

#define NLEBUFLEN   8192


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
IsValidSockAddr(
    struct sockaddr *pAddress
    );

BOOL
AllocNLE(
    PNETWORK_LIST_ENTRY * ppNLE
    );

BOOL 
FreeNLE(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
LoadIncomingTransports(
    );

BOOL
UnloadTransport(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
UnloadIncomingTransports(
    );

BOOL
LoadOutgoingTransports(
    );

BOOL
UnloadOutgoingTransports(
    );

BOOL
UnloadPdu(
    PNETWORK_LIST_ENTRY pNLE
    );

#endif // _NETWORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\globals.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Contains global definitions for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _GLOBALS_H_
#define _GLOBALS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <windef.h>
#include <winsvc.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <wsipx.h>
#include <snmputil.h>
#include "snmpevts.h"
#include "args.h"
#include "mem.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#define SHUTDOWN_WAIT_HINT 5000


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern DWORD  g_dwUpTimeReference;
extern HANDLE g_hTerminationEvent;
extern HANDLE g_hRegistryEvent;

extern HANDLE g_hDefaultRegNotifier;
extern HKEY   g_hDefaultKey;
extern HANDLE g_hPolicyRegNotifier;
extern HKEY   g_hPolicyKey;

extern LIST_ENTRY g_Subagents;
extern LIST_ENTRY g_SupportedRegions;
extern LIST_ENTRY g_ValidCommunities;
extern LIST_ENTRY g_TrapDestinations;
extern LIST_ENTRY g_PermittedManagers;
extern LIST_ENTRY g_IncomingTransports;
extern LIST_ENTRY g_OutgoingTransports;

extern CRITICAL_SECTION g_RegCriticalSectionA;
extern CRITICAL_SECTION g_RegCriticalSectionB;
extern CRITICAL_SECTION g_RegCriticalSectionC;

extern CMD_LINE_ARGUMENTS g_CmdLineArguments;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Registry definitions                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#define REG_POLICY_ROOT               \
    TEXT("SOFTWARE\\Policies")

#define REG_POLICY_PARAMETERS         \
    TEXT("SOFTWARE\\Policies\\SNMP\\Parameters")

#define REG_POLICY_VALID_COMMUNITIES  \
    REG_POLICY_PARAMETERS TEXT("\\ValidCommunities")

#define REG_POLICY_TRAP_DESTINATIONS  \
    REG_POLICY_PARAMETERS TEXT("\\TrapConfiguration")

#define REG_POLICY_PERMITTED_MANAGERS \
    REG_POLICY_PARAMETERS TEXT("\\PermittedManagers")

#define REG_KEY_SNMP_PARAMETERS     \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters")

#define REG_KEY_EXTENSION_AGENTS    \
    REG_KEY_SNMP_PARAMETERS TEXT("\\ExtensionAgents")

#define REG_KEY_VALID_COMMUNITIES   \
    REG_KEY_SNMP_PARAMETERS TEXT("\\ValidCommunities")

#define REG_KEY_TRAP_DESTINATIONS   \
    REG_KEY_SNMP_PARAMETERS TEXT("\\TrapConfiguration")

#define REG_KEY_PERMITTED_MANAGERS  \
    REG_KEY_SNMP_PARAMETERS TEXT("\\PermittedManagers")

#define REG_KEY_MIB2 \
    REG_KEY_SNMP_PARAMETERS TEXT("\\RFC1156Agent")


#define REG_VALUE_SUBAGENT_PATH     "Pathname"
#define REG_VALUE_AUTH_TRAPS        TEXT("EnableAuthenticationTraps")
#define REG_VALUE_MGRRES_COUNTER    TEXT("NameResolutionRetries")
#define REG_VALUE_SYS_OBJECTID      TEXT("sysObjectID")

#define MAX_VALUE_NAME_LEN          256
#define MAX_VALUE_DATA_LEN          256


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define PDUTYPESTRING(nPduType) \
            ((nPduType == SNMP_PDU_GETNEXT) \
                ? "getnext" \
                : (nPduType == SNMP_PDU_GETBULK) \
                    ? "getbulk" \
                    : (nPduType == SNMP_PDU_GET) \
                        ? "get" \
                        : (nPduType == SNMP_PDU_SET) \
                            ? "set" \
                            : "unknown")

#define SNMPERRORSTRING(nErr) \
            ((nErr == SNMP_ERRORSTATUS_NOERROR) \
              ? "NOERROR" \
              : (nErr == SNMP_ERRORSTATUS_GENERR) \
               ? "GENERR" \
               : (nErr == SNMP_ERRORSTATUS_NOSUCHNAME) \
                ? "NOSUCHNAME" \
                : (nErr == SNMP_ERRORSTATUS_NOTWRITABLE) \
                 ? "NOTWRITABLE" \
                 : (nErr == SNMP_ERRORSTATUS_TOOBIG) \
                  ? "TOOBIG" \
                  : (nErr == SNMP_ERRORSTATUS_BADVALUE) \
                   ? "BADVALUE" \
                   : (nErr == SNMP_ERRORSTATUS_READONLY) \
                    ? "READONLY" \
                    : (nErr == SNMP_ERRORSTATUS_WRONGTYPE) \
                     ? "WRONGTYPE" \
                     : (nErr == SNMP_ERRORSTATUS_WRONGLENGTH) \
                      ? "WRONGLENGTH" \
                      : (nErr == SNMP_ERRORSTATUS_WRONGENCODING) \
                       ? "WRONGENCODING" \
                       : (nErr == SNMP_ERRORSTATUS_WRONGVALUE) \
                        ? "WRONGVALUE" \
                        : (nErr == SNMP_ERRORSTATUS_NOCREATION) \
                         ? "NOCREATION" \
                         : (nErr == SNMP_ERRORSTATUS_INCONSISTENTVALUE) \
                          ? "INCONSISTENTVALUE" \
                          : (nErr == SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE) \
                           ? "RESOURCEUNAVAILABLE" \
                           : (nErr == SNMP_ERRORSTATUS_COMMITFAILED) \
                            ? "COMMITFAILED" \
                            : (nErr == SNMP_ERRORSTATUS_UNDOFAILED) \
                             ? "UNDOFAILED" \
                             : (nErr == SNMP_ERRORSTATUS_AUTHORIZATIONERROR) \
                              ? "AUTHORIZATIONERROR" \
                              : (nErr == SNMP_ERRORSTATUS_NOACCESS) \
                               ? "NOACCESS" \
                               : (nErr == SNMP_ERRORSTATUS_INCONSISTENTNAME) \
                                ? "INCONSISTENTNAME" \
                                : "unknown")
 
 



























































































#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\service.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    service.h

Abstract:

    Contains service definitions for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _SERVICE_H_
#define _SERVICE_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service name                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_SERVICE                TEXT("SNMP")

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP log level limits (must be consistent with SNMP_LOG_ contants)        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOGLEVEL_MINIMUM       0  
#define SNMP_LOGLEVEL_MAXIMUM       20 

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP log type limits (must be consistent with SNMP_OUTPUT_ contants)      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOGTYPE_MINIMUM        0   
#define SNMP_LOGTYPE_MAXIMUM        10  

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service parameter offsets (used in control handler)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_SERVICE_CONTROL_BASE   128
#define SNMP_SERVICE_LOGLEVEL_BASE  SNMP_SERVICE_CONTROL_BASE
#define SNMP_SERVICE_LOGTYPE_BASE   \
    (SNMP_SERVICE_LOGLEVEL_BASE + SNMP_LOGLEVEL_MAXIMUM + 1)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service parameter macro definitions                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define IS_LOGLEVEL(x) \
    (((x) >= (SNMP_SERVICE_LOGLEVEL_BASE + SNMP_LOGLEVEL_MINIMUM)) && \
     ((x) <= (SNMP_SERVICE_LOGLEVEL_BASE + SNMP_LOGLEVEL_MAXIMUM)))

#define IS_LOGTYPE(x) \
    (((x) >= (SNMP_SERVICE_LOGTYPE_BASE + SNMP_LOGTYPE_MINIMUM)) && \
     ((x) <= (SNMP_SERVICE_LOGTYPE_BASE + SNMP_LOGTYPE_MAXIMUM)))

#define IS_LOGLEVEL_VALID(x) \
    (((x) >= SNMP_LOGLEVEL_MINIMUM) && ((x) <= SNMP_LOGLEVEL_MAXIMUM))

#define IS_LOGTYPE_VALID(x) \
    (((x) >= SNMP_LOGTYPE_MINIMUM) && ((x) <= SNMP_LOGTYPE_MAXIMUM))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service status definitions                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define NO_WAIT_HINT    0
#define SNMP_WAIT_HINT  30000


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service debug string macro definitions                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOGLEVEL_STRING(x) \
    (((x) == SNMP_LOG_SILENT) \
        ? "SILENT" \
        : ((x) == SNMP_LOG_FATAL) \
            ? "FATAL" \
            : ((x) == SNMP_LOG_ERROR) \
                ? "ERROR" \
                : ((x) == SNMP_LOG_WARNING) \
                    ? "WARNING" \
                    : ((x) == SNMP_LOG_TRACE) \
                        ? "TRACE" \
                        : ((x) == SNMP_LOG_VERBOSE) \
                            ? "VERBOSE" \
                            : "UNKNOWN" \
                            )

#define SNMP_LOGTYPE_STRING(x) \
    (((x) == SNMP_OUTPUT_TO_CONSOLE) \
        ? "CONSOLE" \
        : ((x) == SNMP_OUTPUT_TO_LOGFILE) \
            ? "LOGFILE" \
            : ((x) == SNMP_OUTPUT_TO_EVENTLOG) \
                ? "EVENTLOG" \
                : ((x) == SNMP_OUTPUT_TO_DEBUGGER) \
                    ? "DEBUGGER" \
                    : "UNKNOWN" \
                    )

#define SERVICE_STATUS_STRING(x) \
    (((x) == SERVICE_STOPPED) \
        ? "STOPPED" \
        : ((x) == SERVICE_START_PENDING) \
              ? "START PENDING" \
              : ((x) == SERVICE_STOP_PENDING) \
                    ? "STOP PENDING" \
                    : ((x) == SERVICE_RUNNING) \
                          ? "RUNNING" \
                          : ((x) == SERVICE_CONTINUE_PENDING) \
                                ? "CONTINUE PENDING" \
                                : ((x) == SERVICE_PAUSE_PENDING) \
                                      ? "PAUSE PENDING" \
                                      : ((x) == SERVICE_PAUSED) \
                                            ? "PAUSED" \
                                            : "UNKNOWN" \
                                            )

#define SERVICE_CONTROL_STRING(x) \
    (((x) == SERVICE_CONTROL_STOP) \
        ? "STOP" \
        : ((x) == SERVICE_CONTROL_PAUSE) \
            ? "PAUSE" \
            : ((x) == SERVICE_CONTROL_CONTINUE) \
                ? "CONTINUE" \
                : ((x) == SERVICE_CONTROL_INTERROGATE) \
                    ? "INTERROGATE" \
                    : ((x) == SERVICE_CONTROL_SHUTDOWN) \
                        ? "SHUTDOWN" \
                        : "CONFIGURE" \
                        )

#endif // _SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\regthrd.h ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    regthrd.h

Abstract:

    Contains routines for thread listening to registry changes.

Environment:

    User Mode - Win32

Revision History:

    Rajat Goel -- 24 Feb 1999
        - Creation

--*/

#ifndef _REGTHRD_H_
#define _REGTHRD_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
ProcessRegistryMessage(
	LPVOID lpParam
	);

#endif // _REGTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\regions.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    regions.h

Abstract:

    Contains definitions for manipulating MIB region structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _REGIONS_H_
#define _REGIONS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "subagnts.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _MIB_REGION_LIST_ENTRY {

    AsnObjectIdentifier             PrefixOid;
    AsnObjectIdentifier             LimitOid;
    LIST_ENTRY                      Link;      
    PSUBAGENT_LIST_ENTRY            pSLE;
    struct _MIB_REGION_LIST_ENTRY * pSubagentRLE;

} MIB_REGION_LIST_ENTRY, *PMIB_REGION_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocRLE(
    PMIB_REGION_LIST_ENTRY * ppRLE    
    );

BOOL 
FreeRLE(
    PMIB_REGION_LIST_ENTRY pRLE    
    );

BOOL
FindFirstOverlappingRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    PMIB_REGION_LIST_ENTRY pNewRLE
    );

BOOL
FindSupportedRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    AsnObjectIdentifier *    pPrefixOid,
    BOOL                     fAnyOk
    );

BOOL    
UnloadRegions(
    PLIST_ENTRY pListHead
    );

BOOL
LoadSupportedRegions(
    );

BOOL
UnloadSupportedRegions(
    );

#endif // _REGIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\registry.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Contains definitions for manipulating registry parameters.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadRegistryParameters(
    );

BOOL
LoadScalarParameters(
    );

INT
InitRegistryNotifiers(
    );

INT
WaitOnRegNotification(
    );

BOOL
UnloadRegistryParameters(
    );

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\snmpmgmt.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgmt.h

Abstract:

    Contains the definitions of service management variables (as defined in RFC1213)

Environment:

    User Mode - Win32

Revision History:

    30-Mar-1998 FlorinT
--*/

#ifndef _SNMPMIB_H
#define _SNMPMIB_H

#include <snmp.h>

// defines the number of AsnCounters in the SNMP_MGMTVARS.AsnCounterPool[]
#define NC_MAX_COUNT				27

// indices in the SNMP_MGMTVARS.AsnCounterPool[]
#define CsnmpInPkts                 0
#define CsnmpOutPkts                1

#define CsnmpInBadVersions          2
#define CsnmpInBadCommunityNames    3
#define CsnmpInBadCommunityUses     4
#define CsnmpInASNParseErrs         5

#define CsnmpInTooBigs              6
#define CsnmpInNoSuchNames          7
#define CsnmpInBadValues            8
#define CsnmpInReadOnlys            9
#define CsnmpInGenErrs              10

#define CsnmpInTotalReqVars         11
#define CsnmpInTotalSetVars         12
#define CsnmpInGetRequests          13
#define CsnmpInGetNexts             14
#define CsnmpInSetRequests          15
#define CsnmpInGetResponses         16
#define CsnmpInTraps                17

#define CsnmpOutTooBigs             18
#define CsnmpOutNoSuchNames         19
#define CsnmpOutBadValues           20
#define CsnmpOutGenErrs             21

#define CsnmpOutGetRequests         22
#define CsnmpOutGetNexts            23
#define CsnmpOutSetRequests         24
#define CsnmpOutGetResponses        25
#define CsnmpOutTraps               26

// defines the number of AsnIntegers in the SNMP_MGMTVARS.AsnIntegerPool[]
#define NI_MAX_COUNT				2

// indices in the SNMP_MGMTVARS.AsnIntegerPool[]
#define IsnmpEnableAuthenTraps		0
#define IsnmpNameResolutionRetries	1

// defines the number of AsnObjects in the SNMP_MGMTVARS.AsnObjectIDs[]
#define NO_MAX_COUNT                1

 // indices in the SNMP_MGMTVARS.AsnObjectIDs[]
#define OsnmpSysObjectID            0

// flag for mgmtUtilUpdate* functions
#define IN_errStatus                0
#define OUT_errStatus               1

typedef struct _snmp_mgmtvars
{
  AsnAny    	AsnCounterPool[NC_MAX_COUNT];	// storage place for management counters.
  AsnAny    	AsnIntegerPool[NI_MAX_COUNT];	// storage place for management integers.
  AsnAny        AsnObjectIDs[NO_MAX_COUNT];     // storage place for management obj IDs.
} SNMP_MGMTVARS, *PSNMP_MGMTVARS;

extern SNMP_MGMTVARS snmpMgmtBase;

void mgmtInit();
void mgmtCleanup();
int  mgmtCTick(int index);
int  mgmtCAdd(int index, AsnCounter value);
int  mgmtISet(int index, AsnInteger value);
int  mgmtOSet(int index, AsnObjectIdentifier *pValue, BOOL bAlloc);

// utility functions
void mgmtUtilUpdateErrStatus(UINT flag, DWORD errStatus);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\snmpmgrs.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgrs.h

Abstract:

    Contains definitions for manipulating managers structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _SNMPMGRS_H_
#define _SNMPMGRS_H_


#include "snmpmgmt.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MGRADDR_ALIVE	-1
#define MGRADDR_DEAD	0
#define MGRADDR_DYING	16

typedef struct _MANAGER_LIST_ENTRY {

    LIST_ENTRY      Link;
    struct sockaddr SockAddr;
    INT             SockAddrLen;
    LPSTR           pManager;
    BOOL            fDynamicName;
    DWORD           dwLastUpdate;
    AsnInteger      dwAge;

} MANAGER_LIST_ENTRY, *PMANAGER_LIST_ENTRY;

#define DEFAULT_NAME_TIMEOUT    0x0036EE80  // one hour timeout


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocMLE(
    PMANAGER_LIST_ENTRY * ppMLE,
    LPSTR                pManager
    );

BOOL
FreeMLE(
    PMANAGER_LIST_ENTRY pMLE
    );

BOOL
UpdateMLE(
    PMANAGER_LIST_ENTRY pMLE
    );

BOOL
AddManager(
    PLIST_ENTRY pListHead,
    LPSTR       pManager
    );

BOOL
FindManagerByName(
    PMANAGER_LIST_ENTRY * ppMLE,
    PLIST_ENTRY           pListHead,
    LPSTR                 pManager
    );    

BOOL
IsManagerAddrLegal(
    struct sockaddr_in *  pAddr
    );

BOOL
FindManagerByAddr(
    PMANAGER_LIST_ENTRY * ppMLE,
    struct sockaddr *     pAddr
    );    

BOOL
LoadManagers(
    HKEY        hKey,
    PLIST_ENTRY pListHead
    );

BOOL
UnloadManagers(
    PLIST_ENTRY pListHead
    );

BOOL
LoadPermittedManagers(
    BOOL bFirstCall
    );

BOOL
UnloadPermittedManagers(
    );

#endif // _SNMPMGRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\query.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    query.h

Abstract:

    Contains definitions for querying subagents.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _QUERY_H_
#define _QUERY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "subagnts.h"
#include "network.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _QUERY_LIST_ENTRY {

    LIST_ENTRY           Link;
    LIST_ENTRY           SubagentVbs;
    SnmpVarBindList      SubagentVbl;
    AsnOctetString       ContextInfo;
    UINT                 nSubagentVbs;
    UINT                 nErrorStatus;
    UINT                 nErrorIndex;
    PSUBAGENT_LIST_ENTRY pSLE;

} QUERY_LIST_ENTRY, *PQUERY_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessQueries(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
LoadQueries(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
UnloadQueries(
    PNETWORK_LIST_ENTRY pNLE
    );

#endif // _QUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\snmppdus.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmppdus.h

Abstract:

    Contains definitions for manipulating SNMP PDUs.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

#ifndef _SNMPPDUS_H_
#define _SNMPPDUS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _NORMAL_PDU {

    AsnInteger32 nRequestId;
    AsnInteger32 nErrorStatus;
    AsnInteger32 nErrorIndex;

} NORMAL_PDU, *PNORMAL_PDU;

typedef struct _BULK_PDU {

    AsnInteger32 nRequestId;
    AsnInteger32 nErrorStatus;
    AsnInteger32 nErrorIndex;
    AsnInteger32 nNonRepeaters;
    AsnInteger32 nMaxRepetitions;

} BULK_PDU, *PBULK_PDU;

typedef struct _TRAP_PDU {

    AsnObjectIdentifier EnterpriseOid;
    AsnIPAddress        AgentAddr;
    AsnInteger32        nGenericTrap;
    AsnInteger32        nSpecificTrap;
    AsnTimeticks        nTimeticks;

} TRAP_PDU, *PTRAP_PDU;

typedef struct _SNMP_PDU {

    UINT            nType;
    SnmpVarBindList Vbl;
    union {
        TRAP_PDU   TrapPdu;
        BULK_PDU   BulkPdu;
        NORMAL_PDU NormPdu;
    } Pdu;

} SNMP_PDU, *PSNMP_PDU;

#define SNMP_VERSION_1  0
#define SNMP_VERSION_2C 1


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
BuildMessage(
    AsnInteger32      nVersion,
    AsnOctetString *  pCommunity,
    PSNMP_PDU         pPdu,
    PBYTE             pMessage,
    PDWORD            pMessageSize
    );

BOOL
ParseMessage(
    AsnInteger32 *   pVersion,
    AsnOctetString * pCommunity,
    PSNMP_PDU        pPdu,
    PBYTE            pMessage,
    DWORD            dwMessageSize
    );

#endif // _SNMPPDUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\snmpthrd.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpthrd.h

Abstract:

    Contains definitions for master agent network thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

#ifndef _SNMPTHRD_H_
#define _SNMPTHRD_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPSTR
CommunityOctetsToString(
    AsnOctetString  *pAsnCommunity,
    BOOL            bUnicode
    );

LPSTR
StaticUnicodeToString(
    LPWSTR wszUnicode
    );

DWORD
WINAPI
ProcessSnmpMessages(
    LPVOID lpParam
    );

#endif // _SNMPTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\startup.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    startup.h

Abstract:

    Contains definitions for starting SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _STARTUP_H_
#define _STARTUP_H_

extern HANDLE g_hAgentThread;
extern HANDLE g_hRegistryThread;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
StartupAgent(
    );

BOOL
ShutdownAgent(
    );

#endif // _STARTUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\genmsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MSG_BAD_TRAP_INDEX
//
// MessageText:
//
//  No trap sent.
//  %1!s!
//
#define MSG_BAD_TRAP_INDEX               0x80000000L

//
// MessageId: MSG_BAD_TRAP_VARIABLE_COUNT
//
// MessageText:
//
//  Trap was sent with no arguments.
//  %1!s!
//
#define MSG_BAD_TRAP_VARIABLE_COUNT      0x80000001L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\trapmgrs.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapmgrs.h

Abstract:

    Contains definitions for manipulating trap destination structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _TRAPMGRS_H_
#define _TRAPMGRS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _TRAP_DESTINATION_LIST_ENTRY {

    LIST_ENTRY Link;
    LIST_ENTRY Managers;
    LPSTR      pCommunity;

} TRAP_DESTINATION_LIST_ENTRY, *PTRAP_DESTINATION_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocTLE(
    PTRAP_DESTINATION_LIST_ENTRY * ppTLE,
    LPSTR                          pCommunity    
    );

BOOL
FreeTLE(
    PTRAP_DESTINATION_LIST_ENTRY pTLE
    );

BOOL
LoadTrapDestinations(
    BOOL bFirstCall
    );

BOOL
UnloadTrapDestinations(
    );

#endif // _TRAPMGRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\varbinds.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    varbinds.h

Abstract:

    Contains definitions for manipulating varbinds.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _VARBINDS_H_
#define _VARBINDS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "regions.h"
#include "network.h"
#include "snmppdus.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _VARBIND_LIST_ENTRY {

    LIST_ENTRY             Link;
    LIST_ENTRY             QueryLink;
    SnmpVarBind            ResolvedVb;        
    SnmpVarBindList        ResolvedVbl;
    UINT                   nState;
    UINT                   nErrorIndex;  
    UINT                   nMaxRepetitions;
    PMIB_REGION_LIST_ENTRY pCurrentRLE;

} VARBIND_LIST_ENTRY, *PVARBIND_LIST_ENTRY;
                                            
#define VARBIND_UNINITIALIZED          0 // varbind info invalid
#define VARBIND_INITIALIZED            1 // varbind info valid
#define VARBIND_RESOLVING              2 // involved in query now
#define VARBIND_PARTIALLY_RESOLVED     3 // subsequent query needed
#define VARBIND_RESOLVED               4 // completed successfully
#define VARBIND_ABORTED                5 // completed unsuccessfully

#define VARBINDSTATESTRING(nState) \
            ((nState == VARBIND_INITIALIZED) \
                ? "initialized" \
                : (nState == VARBIND_PARTIALLY_RESOLVED) \
                    ? "partially resolved" \
                    : (nState == VARBIND_RESOLVED) \
                        ? "resolved" \
                        : (nState == VARBIND_RESOLVING) \
                            ? "resolving" \
                            : (nState == VARBIND_UNINITIALIZED) \
                                ? "uninitialized" \
                                : "aborted")


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
UnloadVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
AllocVLE(
    PVARBIND_LIST_ENTRY * ppVLE
    );

BOOL 
FreeVLE(
    PVARBIND_LIST_ENTRY pVLE
    );

#endif // _VARBINDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\subagnts.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    subagnts.h

Abstract:

    Contains definitions for manipulating subagent structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _SUBAGNTS_H_
#define _SUBAGNTS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// flag values to be used in _SUBAGENT_LIST_ENTRY:uchFlags
#define FLG_SLE_KEEP    0x01

typedef struct _SUBAGENT_LIST_ENTRY {
    
    LIST_ENTRY              Link;          
    LIST_ENTRY              SupportedRegions;
    PFNSNMPEXTENSIONINIT    pfnSnmpExtensionInit;
    PFNSNMPEXTENSIONINITEX  pfnSnmpExtensionInitEx;
    PFNSNMPEXTENSIONCLOSE   pfnSnmpExtensionClose;
    PFNSNMPEXTENSIONMONITOR pfnSnmpExtensionMonitor;
    PFNSNMPEXTENSIONQUERY   pfnSnmpExtensionQuery;
    PFNSNMPEXTENSIONQUERYEX pfnSnmpExtensionQueryEx;
    PFNSNMPEXTENSIONTRAP    pfnSnmpExtensionTrap;
    HANDLE                  hSubagentTrapEvent;
    HANDLE                  hSubagentDll;
    UCHAR                   uchFlags;
    LPSTR                   pPathname;

} SUBAGENT_LIST_ENTRY, *PSUBAGENT_LIST_ENTRY;

#define SNMP_EXTENSION_INIT     "SnmpExtensionInit"
#define SNMP_EXTENSION_INIT_EX  "SnmpExtensionInitEx"
#define SNMP_EXTENSION_CLOSE    "SnmpExtensionClose"
#define SNMP_EXTENSION_MONITOR  "SnmpExtensionMonitor"
#define SNMP_EXTENSION_QUERY    "SnmpExtensionQuery"
#define SNMP_EXTENSION_QUERY_EX "SnmpExtensionQueryEx"
#define SNMP_EXTENSION_TRAP     "SnmpExtensionTrap"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindSubagent(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                  pPathname
    );

BOOL
AddSubagentByDll(
    LPSTR pPathname,
    UCHAR uchInitFlags
    );

BOOL
AllocSLE(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                  pPathname,
    UCHAR                  uchInitFlags
    );

BOOL
FreeSLE(
    PSUBAGENT_LIST_ENTRY pSLE
    );

BOOL
LoadSubagents(
    );

BOOL
UnloadSubagents(
    );

#endif // _SUBAGNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\gennt.c ===
/*
 *  gennt.c v0.14  May 15, 1996 
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the generic logic for
 *    processing the SNMP request.  It is table driven.  No user modification
 *    should be done.
 *
 *  Functions:
 *
 *    ResolveVarBind()
 *    FindClass()
 *    ResolveGetNext()
 *
 *  Author:
 *    Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *      2/17/95
 *
 *  Revision History:
 * 	6/22/95  krw0001  FindClass - modify to stop checking for valid variable - we only care about valid
 *								class.
 *								Rewrite ResolveGetNext
 *  6/26/95  ags      FindClass - stop checking for valid variable
 *                              Rewrite ResolveGetNext
 *  7/31/95  ags      SNMP_oidfree works with CRTDLL.lib, hence use them.
 *  2/14/96  ags   v0.11    one fix for the getnext bug found by Cindy
 *  3/19/96  kff   v0.12    modified for trap support
 *  4/19/96  ags   v0.13    Modified to get rid of trap.c in case of no traps.
 *  5/15/96  cs    v0.14    Modified FindClass in the backward walkthru to tighten
 *                      up the verification
 */


#include <windows.h>
#include <malloc.h>
#include <stdio.h>

#include <snmp.h>

#include "mib.h"
#include "mib_xtrn.h"
#include "smint.h"

extern DWORD dwTimeZero ;

UINT
SnmpUtilOidMatch(AsnObjectIdentifier *pOid1, AsnObjectIdentifier *pOid2)
{
    unsigned long int nScan = min(pOid1->idLength, pOid2->idLength);
    unsigned long int i;

    for (i = 0; i < nScan; i++)
    {
        if (pOid1->ids[i] != pOid2->ids[i])
            break;
    }

    return i;
}



/*
 *  ResolveVarBind
 *
 *    Resolves a single variable binding.  Modifies the variable value pair
 *    on a GET or a GET-NEXT.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    PduAction                  type of request - get, set, or getnext
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
ResolveVarBind( IN OUT RFC1157VarBind *VarBind , // Variable Binding to resolve
                IN UINT PduAction )              // Action specified in PDU

{
    unsigned long int cindex ;  // index into the class info table
    unsigned long int vindex ;  // index into the class's var table
    UINT instance_array[ MAX_STRING_LEN ] ;
    UINT status ;
    UINT result ;               // SNMP PDU error status
    AsnObjectIdentifier instance ;
    InstanceName native_instance ;

    instance.ids = instance_array ;

    // Determine which class the VarBind is for

    status = FindClass( VarBind, &cindex ) ;
    if ( status )
    {
        if ( PduAction != MIB_ACTION_GETNEXT )
        {
            // Check for valid variable as this is a get or set

            CHECK_VARIABLE( VarBind, cindex, vindex, status ) ;
            if ( !status )
                return SNMP_ERRORSTATUS_NOSUCHNAME ;

            // Check for valid instance

            status = ( *class_info[ cindex ].FindInstance )
                     ( (ObjectIdentifier *)&(VarBind->name) ,
                       (ObjectIdentifier *)&instance ) ;
            if ( status != SNMP_ERRORSTATUS_NOERROR )
                return status ;

            // Check for access

            CHECK_ACCESS( cindex, vindex, PduAction, status ) ;
            if ( !status )
            {
                if ( PduAction == MIB_ACTION_SET )
                    return SNMP_ERRORSTATUS_NOTWRITABLE ;
                else
                    return SNMP_ERRORSTATUS_GENERR ;
            }

            // Ok to do the get or set

            if ( PduAction == MIB_ACTION_GET )
            {
                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex].SMIGet )
                         ( VarBind , cindex, vindex, &native_instance ) ;
            }
            else
            {
                if ( VarBind->value.asnType !=
                     class_info[ cindex ].variable[ vindex ].type )
                    return SNMP_ERRORSTATUS_BADVALUE ;

                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex ].SMISet )
                         ( VarBind, cindex, vindex, &native_instance ) ;
            }
        }
        else  // This is a GETNEXT
        {
            //
            //  Call ResolveGetNext() to determine which class, variable, and
            //  instance to do a Get on.
            //

            status = ResolveGetNext( VarBind, &cindex, &vindex, &instance ) ;
            if ( status == SUCCESS )
            {
                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex ].SMIGet )
                         ( VarBind, cindex, vindex, &native_instance ) ;
            }
            else
                return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    }
    else
    {
        //
        // No class found, but its a GETNEXT.. we need to find the class that has the longest
        // with the requested oid and forward the request to it
        //

        if (PduAction == MIB_ACTION_GETNEXT)
        {
            unsigned long int ci;               // index into the class info table
            unsigned long int nLongestMatch;    // max number of ids that matched between names
            unsigned long int nCurrentMatch;    // matching number of IDs at the current iteration

            // scan the class_info table, relying on the fact that the table is ordered
            // ordered ascendingly on the class OID.
            for (ci = 0, nLongestMatch = 0; ci < CLASS_TABLE_MAX; ci++)
            {
                // pick up the number of matching ids between the VarBind and the class name..
                nCurrentMatch = SnmpUtilOidMatch(&VarBind->name, class_info[ci].oid);

                // store in cindex the first class with the highest match number
                if (nCurrentMatch > nLongestMatch)
                {
                    cindex = ci;
                    nLongestMatch = nCurrentMatch;
                }
            }


            // only if VarBind name is longer than the match number we need to look
            // for an even better match
            if (VarBind->name.idLength > nLongestMatch)
            {
                for (;cindex < CLASS_TABLE_MAX; cindex++)
                {
                    // make sure we don't go over the range with the longest Match
                    if (SnmpUtilOidMatch(&VarBind->name, class_info[cindex].oid) != nLongestMatch)
                        break;

                    // if the class matches entirely into the VarBind name, check if the first ID
                    // that follows in VarBind name is inside the range supported by the class
                    if (class_info[cindex].oid->idLength == nLongestMatch)
                    {
                        // this is a hack - we rely the var_index is always 1 more than number of ids in
                        // the class_info name. Since VarBind has already a name longer than nLongestMatch
                        // no buffer overrun happens here.
                        // if the VarBind name is in the right range, then we found the class - just break the loop
                        // (don't forget, var_index is '1' based)
                        if(VarBind->name.ids[class_info[cindex].var_index - 1] <= class_info[cindex].max_index)
                            break;
                    }
                    else
                    {
                        // the VarBind name is longer than the IDs that match, the class_info name is the same
                        // the first ID that follows in both names can't be equal, so we can break the loop if
                        // the VarBind name is just in front of it.
                        if (VarBind->name.ids[nLongestMatch] < class_info[cindex].oid->ids[nLongestMatch])
                            break;
                    }

                }
            }

            if (cindex < CLASS_TABLE_MAX )
                   vindex = class_info[cindex].min_index ;
            else
                   return SNMP_ERRORSTATUS_NOSUCHNAME ;

 			SNMP_oidfree( &VarBind->name ) ;
            SNMP_oidcpy( &VarBind->name ,
                         class_info[ cindex ].variable[ vindex ].oid ) ;
            status = ResolveGetNext( VarBind, &cindex, &vindex, &instance ) ;
            if ( status == SUCCESS )
            {
                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex ].SMIGet )
                         ( VarBind, cindex, vindex, &native_instance ) ;
            }
        }
        else
            return SNMP_ERRORSTATUS_NOSUCHNAME ;
    }

    ( *class_info[ cindex ].FreeInstance )( &native_instance ) ;
    return result ;

} /* end of ResolveVarBind() */



/*
 *  FindClass
 *
 *    This routine determines the class by walking the class_info table
 *    backwards and comparing the class oids.  The table is walked
 *    backwards because it assumes that the classes are listed in
 *    increasing order.  For example,
 *
 *    Group Name              Group Identifier
 *
 *    group1                  1.3.6.1.4.1.36.2.78
 *    table1                  1.3.6.1.4.1.36.2.78.9
 *    table2                  1.3.6.1.4.1.36.2.78.10
 *
 *    We need to look for the longest exact match on the oid thus we
 *    walk the table backwards.
 *
 *  Arguments:
 *
 *     VarBind                 Variable value pair
 *     class                   Index into the class_info
 *
 *  Return Codes:
 *
 *     SUCCESS                 Class is valid, return index into class_info
 *     FAILURE                 Invalid class
 *
 */

UINT
FindClass( IN RFC1157VarBind *VarBind ,
           IN OUT UINT *cindex )
{
    int index ;
    UINT status, vindex ;
    UINT length ;

    for ( index = CLASS_TABLE_MAX - 1 ; index >= 0 ; index-- )
    {
        if ( class_info[ index ].table )
            // skip over the entry code -- kkf, why?
//            length = class_info[ index ].var_index - 2 ;
            length = class_info[ index ].var_index - 1 ;
        else
            length = class_info[ index ].var_index - 1 ;
        status = SNMP_oidncmp( &VarBind->name ,
                               class_info[ index ].oid ,
                               length ) ;

        // if the oid don't match the class or it is shorter than the
        // class go on to the next one.
        // If the oid requested is shorter than the class we can't stop
        // otherwise we'll point to a wrong (longest match) class.
        if (status != 0 ||
            VarBind->name.idLength < class_info[ index ].var_index)
            continue;

        vindex = VarBind->name.ids[ class_info[ index ].var_index - 1 ] ;
        // cs - added the vindex verification to make sure that the varbind
        // oid definitely belongs in this class (fixed partial table oids)
		
        if ( vindex >= class_info[ index ].min_index &&
             vindex <= class_info[ index ].max_index)
        {
            *cindex = index ;
            return SUCCESS ;
        }
    }

	//  Failed to match by walking list backwards (longest match)
	//  so OID supplied is shorter than expected (e.g., partial OID supplied)
	//  Try matching by forward walking...
	for (index = 0; index < CLASS_TABLE_MAX; index++ ) {
		status = SNMP_oidncmp( &VarBind->name ,
		                       class_info[ index ].oid ,
							   VarBind->name.idLength ) ;
		if ( status == 0 ) {
			*cindex = index ;
			return SUCCESS ;
		}
	}

    return FAILURE ;

} /* end of FindClass() */



/*
 *   ResolveGetNext
 *
 *     Determines the class, the variable and the instance that the
 *     GetNext request is to be performed on.  This is a recursive
 *     routine.  The input arguments VarBind and class may be modified
 *     as part of the resolution.
 *
 *     The rules for getnext are:
 *       1. No instance and no variable specified so return the first
 *          variable for the first instance.
 *       2. No instance specified but a variable is specified so return
 *          the variable for the first instance.
 *       3. An instance and a variable are specified
 *              Follow 3a,4b for  Non Tables
 *              Follow 3b, 4b, 5b for  Tables
 *
 *       3a.Return the next	variable for the instance.
 *       4a.An instance and a variable are specified but the variable is the
 *          last variable in the group so return the first variable for the
 *          next group.
 *          If there is no next group return FAILURE.
 *
 *       3b. Return the variable for the next instance ( walk down the column).
 *       4b. Reached the bottom of the column, start at the top of next column.
 *       5b. An instance and a variable are specified but it is the last 
 *          variable and the last instace so roll to the next group (class).
 *          If there is no next group return FAILURE.
 *
 *  Arguments:
 *
 *     VarBind                 Variable value pair
 *     cindex                  Index into the class_info
 *     vindex                  address to specify variable for the get
 *
 *  Return Codes:
 *
 *     SUCCESS                 Able to resolve the request to a class, variable
 *                             and instance
 *     FAILURE                 Unable to resolve the request within this  MIB
 *
 */

UINT
ResolveGetNext( IN OUT RFC1157VarBind *VarBind ,
                IN OUT UINT *cindex ,
                IN OUT UINT *vindex ,
                OUT AsnObjectIdentifier *instance )
                {
    UINT status ;
    access_mode_t tmpAccess ;

	
	/*
	 * We've come in with a pointer to the class, to start with
     * Do we have a variable specified?
     */
	
	*vindex = 0 ;
	if (VarBind->name.idLength < class_info[ *cindex ].var_index )  {
        /*
       	 * No variable specified. so pick the first variable (if it exists)
       	 * to start the search for a valid variable.
         * If not roll over to the next class.
    	 * Instnace is 0 for non Tables, and the first instance for Tables.
         */

	    if ( class_info[ *cindex ].min_index <= class_info[ *cindex ].max_index)   {

            *vindex = class_info[ *cindex ].min_index ;
            goto StartSearchAt;
        } else  {
            goto BumpClass;
        }

    } else {
        /*
         * Yes, a variable is specified.
         * If it is below min_index, start testing for a valid variable at the min_index.
         * If it is ablove max_index roll over to the next class.
         * If we change the variable, Instance is reset to the first (or the only) Instance.
         */
        *vindex = VarBind->name.ids[ class_info[ *cindex ].var_index - 1 ] ;
		
		if ( *vindex < class_info[ *cindex ].min_index) {
            *vindex = class_info[ *cindex ].min_index ;
            goto StartSearchAt;
		}
		
		if ( *vindex > class_info[ *cindex ].max_index)
            goto BumpClass;
        /*
         * A valid variable for this class is specified. Table & NonTable are treated
         * differently.
         * In case of Non Tables:
         *      if instance is specified, we start the serach for a valid variable at the
         *              next variable.
         *      if no instnace is specified, we start search at the specified variable.
         *
         * In case of Tables:
         * We may have
         *      a. No Instance              start at the 1st Instance
         *      b. Partial instance         start at the 1st Instance
         *      c. Invalid instance         start at the 1st Instance
         *      d. Valid Instance           start at the next Instance
		 * All these cases will be handled by the FindNextInstance
	     * Hence first check that access of the given vaiable, if it is readable
         * get the Next Instance. If not start the search for a valid variable at the next
         * variable.
         */

        if ( class_info[ *cindex ].table == NON_TABLE ) {
            /* test for the Instance */
			if ( VarBind->name.idLength > class_info[ *cindex ].var_index)
                (*vindex)++ ;

            goto StartSearchAt;
        } else {
            /* Start Table case */
            tmpAccess =  class_info[ *cindex ].variable[ *vindex ].access_mode ;
            if ( ( tmpAccess == NSM_READ_ONLY ) || (tmpAccess == NSM_READ_WRITE) ) {
                /*
                 * readable Variable,  walk down the column
                 */
                status = ( *class_info[ *cindex ].FindNextInstance )
					    ( (ObjectIdentifier *)&(VarBind->name) ,
					    (ObjectIdentifier *)instance ) ;
			
			    if (status == SNMP_ERRORSTATUS_NOERROR) { 		   	
                    SNMP_oidfree ( &VarBind->name ) ;
				    SNMP_oidcpy ( &VarBind->name,
				                class_info[*cindex ].variable[*vindex].oid ) ;
				    SNMP_oidappend ( &VarBind->name, instance );
				    return SUCCESS ;                   
                    /* we are all done   */
                }
            }
            /*
             * Either at end of the column, or variable specified is non Readable.
             * Hence we need to move to the next column,
             * This means we start at the 1st instnace.
             */
            (*vindex)++ ;
            goto StartSearchAt;
            /* End Table case */
        }
        /* end of variable specified case */
    }
StartSearchAt:
    /*
     * We have a start variable in *vindex.
     * At this point we are moving to the next column in case of a Table
     * Hence if we can't find an NextInstance ( empty Table), move to the
     * next class.
     */
     status = FAILURE;
     while ( *vindex <= class_info[ *cindex ].max_index)  {

        tmpAccess =  class_info[ *cindex ].variable[ *vindex ].access_mode ;
        if ( ( tmpAccess == NSM_READ_ONLY ) || (tmpAccess == NSM_READ_WRITE) ) {
            status = SUCCESS;
            break;
        } else  {
            (*vindex)++;
        }
     }

     if ( status == SUCCESS) {
        /*
         * we hava a valid variable, get the instance
         */
        SNMP_oidfree ( &VarBind->name ) ;
		SNMP_oidcpy ( &VarBind->name, class_info[ *cindex ].variable[*vindex ].oid );

		if ( class_info[ *cindex ].table == NON_TABLE) {
		
		    instance->ids[ 0 ] = 0 ;
			instance->idLength = 1 ;
			SNMP_oidappend ( &VarBind->name, instance );
			return SUCCESS ;

        } else {

            status = ( *class_info[ *cindex ].FindNextInstance )
					    ( (ObjectIdentifier *)&(VarBind->name) ,
					    (ObjectIdentifier *)instance ) ;
			
			if (status == SNMP_ERRORSTATUS_NOERROR) { 		   	
		        SNMP_oidappend ( &VarBind->name, instance );
				return SUCCESS ;
            }
        }
     }

/*
 * Come here to move on to the next class
 */

BumpClass:
    {
	    (*cindex)++ ;
		if ( *cindex >= CLASS_TABLE_MAX)
			return FAILURE ;
		SNMP_oidfree( &VarBind->name );
		SNMP_oidcpy ( &VarBind->name, class_info[ *cindex ].oid );
		status = ResolveGetNext( VarBind, cindex, vindex, instance) ;
		return status ;
	}
	
	// This oughtn't to happen
	return FAILURE ;
} /* end of ResolveGetNext() */


#ifndef TRAPS
//
// If there are no traps, TrapInit() is still needed. 
// If there are traps, all this code appears in 
// generated file trap.c
//

UINT number_of_traps = 0 ;

trap_t
    trap_info[] = {
        { NULL, 0, 0, 0, NULL }
} ;

extern
trap_t trap_info[] ;

extern
UINT number_of_traps ;

extern HANDLE hEnabledTraps ;
extern HANDLE hTrapQMutex ;

/*
 *  TrapInit
 *
 *    This routine initializes the trap handle.
 *
 *  Arguments:
 *
 *    hPollForTrapEvent    handle for traps - this is used to coordinate
 *                         between the Extendible Agent and this Extension
 *                         Agent.
 *                             - NULL indicates no traps
 *                             - value from CreateEvent() indicates traps
 *                               are implemented and the Extendible agent
 *                               must poll for them
 *
 *  Return Code:
 *
 *    SUCCESS     Successful initialization
 *    FAILURE     Unable to initialize
 *
 |=========================================================================
 | There are no Traps associated with the HostMIB.  Consequently this
 | routine is taken over and used to create a handle to a timer rather
 | than an event.
 |
 | We want to be entered at "SnmpExtensionTrap()" (in "HOSTMIB.C") on
 | a periodic interval.  When entered, we won't really do any trap processing,
 | instead we'll refresh the cached information associated with SNMP
 | attribute "hrProcessorLoad" (in "HRPROCES.C") thru a call to function
 | "hrProcessLoad_Refresh()" (also in "HRPROCES.C").
 |
 | So the contents of this standard function is replaced.  (Note that the
 | "hTrapQMutex" is no longer created).
 */

VOID
TrapInit( IN OUT HANDLE *hPollForTrapEvent )
{
#if 0
    // The default value for traps is NULL indicating NO traps.

    *hPollForTrapEvent = NULL ;
    hTrapQMutex = NULL ;

    // Call to CreateEvent uses the default security descriptor (therefore
    // the handle is not inheritable), flags auto reset (no call to ResetEvent()
    // required), flags no signal to be sent at the initial state, and does
    // not specify a name for this event.
    //
    // If the CreateEvent() fails the value returned is NULL so traps
    // are not enabled.  Otherwise the setting of this event with will cause
    // the Extendible Agent to call this Extension Agent's SnmpExtensionTrap
    // routine to collect any traps.

    *hPollForTrapEvent = CreateEvent( NULL ,   // Address of security attrib
                                      FALSE ,  // Flag for manual-reset event
                                      FALSE ,  // Flag for initial state 
                                      NULL ) ; // Address of event-object name

    //
    // Save the handle in a global variable for use later in setting a trap.
    //

    hEnabledTraps = *hPollForTrapEvent ;

    //
    //  Create Mutex for assuring single thread access to enque/dequeue on trap_q
    hTrapQMutex = CreateMutex( NULL,  // Address of security attrib
                               FALSE, // Mutex is not initially owned
			       NULL ) ; // Mutex is unnamed

    return ;
#endif
/*
|========================
| Special HostMIB code:
*/
LARGE_INTEGER   due_time;       /* When the timer first goes off */
LONG            period;         /* Frequency: every minute       */
BOOL            waitable;       /* Status from SetWaitable()     */


    *hPollForTrapEvent = NULL ;

    /* Attempt the creation of a waitable timer . . . */
    *hPollForTrapEvent = CreateWaitableTimer(NULL,      // Security
                                             FALSE,     // = Auto-resetting
                                             NULL       // = No name
                                             );

    /*
    | Set a negative due time to mean "relative": We want it to go off
    | in 30 seconds.  Ticks are 100 ns or 1/10th of a millionth of a second.
    |
    */
    due_time.QuadPart = 10000000 * (-30);

    /*
    | Set the period in milliseconds to 1 minute.
    */
    period = 1000 * 60;

    /* If we actually managed to create it, start it */
    if (*hPollForTrapEvent != NULL) {

        waitable = 
            SetWaitableTimer(*hPollForTrapEvent,    // Handle to timer
                             &due_time,             // "Due Time" to go off
                             period,                // Length of period in ms.
                             NULL,                  // no completion routine
                             NULL,                  // no arg to comp. routine
                             FALSE                  // no power-resume in NT
                             );
        }

} /* end of TrapInit() */

#endif /* #ifndef TRAPS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\inc\trapthrd.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapthrd.h

Abstract:

    Contains definitions for trap processing thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _TRAPTHRD_H_
#define _TRAPTHRD_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "snmppdus.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessSubagentEvents(
    );

BOOL
GenerateTrap(
    PSNMP_PDU pPdu
    );

BOOL
GenerateColdStartTrap(
    );

BOOL
GenerateAuthenticationTrap(
    );

#endif // _TRAPTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\gennt.h ===
/*
 *  gennt.h v0.15   March 21, 1996
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    Agent.
 *
 *    This module contains the definitions for the table driven SNMP dlls.
 *
 *  Author:
 *     Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *     2/17/95
 *
 *  Revision History:
 *  v0.11   11/15/95  ags  added mib-2 definitions.
 *  v0.12   Feb 14, 1996  ags  changed SMIGet/SetBoolean to SMIGet/SetNSMBoolean
 *  v0.13   Mar 12, 1996  kkf  revised trap_control_block so that VarBindList
 *                        is built prior to queuing to the trap_queue
 *  v0.14   Mar 19, 1996  kkf  fixed numerous trap related bugs
 *  v0.15   Mar 22, 1996  kkf  fixed mib-2 code definition (should be 1 not 2)
 *
 */

#ifndef gennt_h
#define gennt_h

// Necessary includes.

#include <snmp.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>


// MIB function actions.

#define MIB_ACTION_GET         ASN_RFC1157_GETREQUEST
#define MIB_ACTION_SET         ASN_RFC1157_SETREQUEST
#define MIB_ACTION_GETNEXT     ASN_RFC1157_GETNEXTREQUEST

typedef enum
    { NSM_READ_ONLY, NSM_WRITE_ONLY, NSM_READ_WRITE, NSM_NO_ACCESS } access_mode_t ;

typedef enum
{
    NON_TABLE = 0 ,
    TABLE = 1
} table_type_t ;

typedef int (* PF)() ;
typedef void (* PFV)() ;

//
//  The variable structure is used to construct the variable table.
//  Each variable is represented by an entry in the table.  The table
//  driven design indexes into the table to access information specific
//  to the variable, such as its oid, access, get and set routines.
//  "Holes" in the sequence of variables are represented by NULL entries.
//

typedef struct variable
{
    AsnObjectIdentifier *oid ;
    BYTE type ;
    access_mode_t access_mode ;
    PF VarGet ;
    PF VarSet ;
    PF SMIGet ;
    PF SMISet ;
} variable_t ;

//
//  The class structure is used to construct the class_info table.  It
//  is this table that represents the groups composing the mib view of
//  this dll.  The table driven design uses this table in conjuction
//  with the variable tables to process the SNMP requests.
//

typedef struct class
{
    table_type_t table ;
    AsnObjectIdentifier *oid ;
    unsigned long int var_index ;
    unsigned long int min_index ;
    unsigned long int max_index ;
    PF FindInstance ;
    PF FindNextInstance ;
    PF ConvertInstance ;
    PFV FreeInstance ;
    variable_t *variable ;
} class_t ;

//
//  The trap structure is used to construct the trap_info table.  It
//  is this table that represents the trap for this mib view.  The
//  table driven design uses this table to process the trap.  A event
//  is sent to tell the Extendible Agent to call this dll's SnmpExtensionTrap
//  routine to "collect" a trap.  This routine dequeues a trap from the
//  trap queue and then indexes into the trap_info table to fill in the
//  trap information for the trap pdu.
//

typedef struct trap_variable
{
    AsnObjectIdentifier *oid ;
    PF SMIBuild ;
} tvt_t ;

typedef struct trap
{
    AsnObjectIdentifier *oid ;  /* enterprise OID */
    AsnInteger type ;		/* SNMP_GENERICTRAP_ENTERSPECIFIC */
    AsnInteger specific ;	/* trap value */
    UINT number_of_variables ;
    tvt_t *variables ;
} trap_t ;

typedef struct q_hdr
{
    char *lifo_a ;
    char *fifo_a ;
} q_hdr_t ;

typedef struct trap_control_block
{
    q_hdr_t chain_q ;
    AsnObjectIdentifier enterprise ;
    AsnInteger genericTrap ;
    AsnInteger specificTrap ;
    AsnTimeticks timeStamp ;
    RFC1157VarBindList varBindList ;
} tcb_t ;

//
// Definitions of the oid sequence : 1.3.6.1.4.1.36.2 also described as:
//    iso.memberbody.dod.internet.mib.private.dec.ema
//

#define ISO_CODE 1
#define ISO 1
#define ISO_SEQ ISO_CODE
#define ISO_LENGTH 1

#define ORG_CODE 3
#define ORG 3
#define ORG_SEQ ISO_SEQ, ORG_CODE
#define ORG_LENGTH ( ISO_LENGTH + 1 )

#define DOD_CODE 6
#define DOD 6
#define DOD_SEQ ORG_SEQ, DOD_CODE
#define DOD_LENGTH ( ORG_LENGTH + 1 )

#define INTERNET_CODE 1
#define INTERNET 1
#define INTERNET_SEQ DOD_SEQ, INTERNET_CODE
#define INTERNET_LENGTH ( DOD_LENGTH + 1 )

#define DIRECTORY_CODE 1
#define DIRECTORY 1
#define DIRECTORY_SEQ INTERNET_SEQ, DIRECTORY_CODE
#define DIRECTORY_LENGTH ( INTERNET_LENGTH + 1 )

#define MGMT_CODE 2
#define MGMT 2
#define MGMT_SEQ INTERNET_SEQ, MGMT_CODE
#define MGMT_LENGTH ( INTERNET_LENGTH + 1 )

#define EXPERIMENTAL_CODE 3
#define EXPERIMENTAL 3
#define EXPERIMENTAL_SEQ INTERNET_SEQ, EXPERIMENTAL_CODE
#define EXPERIMENTAL_LENGTH ( INTERNET_LENGTH + 1 )

#define PRIVATE_CODE 4
#define PRIVATE 4
#define PRIVATE_SEQ INTERNET_SEQ, PRIVATE_CODE
#define PRIVATE_LENGTH ( INTERNET_LENGTH + 1 )

#define ENTERPRISES_CODE 1
#define ENTERPRISES 1
#define ENTERPRISES_SEQ PRIVATE_SEQ, ENTERPRISES_CODE
#define ENTERPRISES_LENGTH ( PRIVATE_LENGTH + 1 )

#define DEC_CODE 36
#define DEC 36
#define DEC_SEQ ENTERPRISES_SEQ, DEC_CODE
#define DEC_LENGTH ( ENTERPRISES_LENGTH + 1 )

#define EMA_CODE 2
#define EMA 2
#define EMA_SEQ DEC_SEQ, EMA_CODE
#define EMA_LENGTH ( DEC_LENGTH + 1 )

#define MIB_2_CODE 1
#define MIB_2 2
#define MIB_2_SEQ MGMT_SEQ, MIB_2_CODE
#define MIB_2_LENGTH ( MGMT_LENGTH + 1 )


//
//  Macros
//

#define SUCCESS  1
#define FAILURE  0

#define CHECK_VARIABLE( VarBind, cindex, vindex, status )                   \
{                                                                           \
    if ( VarBind->name.idLength > class_info[ cindex ].var_index )          \
    {                                                                       \
        vindex = VarBind->name.ids[ class_info[ cindex ].var_index - 1 ] ;  \
        if ( ( vindex >= class_info[ cindex ].min_index ) &&                \
             ( vindex <= class_info[ cindex ].max_index ) )                 \
            status = SUCCESS ;                                              \
        else                                                                \
            status = FAILURE ;                                              \
    }                                                                       \
    else                                                                    \
        status = FAILURE ;                                                  \
}


#define CHECK_ACCESS( cindex, vindex, PduAction, status )           \
{                                                                   \
    access_mode_t tmp ;                                             \
                                                                    \
    tmp = class_info[ cindex ].variable[ vindex ].access_mode ;     \
    if ( PduAction == MIB_ACTION_SET )                              \
    {                                                               \
        if ( ( tmp == NSM_WRITE_ONLY ) || ( tmp == NSM_READ_WRITE ) )       \
            status = SUCCESS ;                                      \
        else                                                        \
            status = FAILURE ;                                      \
    }                                                               \
    else                                                            \
    {                                                               \
        if ( ( tmp == NSM_READ_ONLY ) || ( tmp == NSM_READ_WRITE ) )        \
            status = SUCCESS ;                                      \
        else                                                        \
            status = FAILURE ;                                      \
    }                                                               \
}

//
//  These macros are used by the trap logic.  There is only one queue
//  used by the generic code - a trap queue.  These macros can be used
//  elsewhere.  The macros assume that the queue structure is the first
//  element in the queue entry structure.
//
#define QUEUE_ENTER( queue_head, entry )             \
{                                                    \
    q_hdr_t *old_chain ;                             \
                                                     \
    old_chain = (q_hdr_t *)(queue_head.lifo_a) ;     \
    entry->chain_q.lifo_a = queue_head.lifo_a ;      \
    queue_head.lifo_a = (char *)entry ;              \
    entry->chain_q.fifo_a = NULL ;                   \
    if ( old_chain == NULL )                         \
        queue_head.fifo_a = (char *)entry ;          \
    else                                             \
        old_chain->fifo_a = (char *)entry ;          \
}

#define QUEUE_REMOVE( queue_head, entry )                  \
{                                                          \
    q_hdr_t *dequeue_chain ;                               \
    q_hdr_t *prev_chain ;                                  \
                                                           \
    dequeue_chain = (q_hdr_t *)(queue_head.fifo_a) ;       \
    entry = (tcb_t *)dequeue_chain ;                       \
    if ( dequeue_chain != NULL )                           \
    {                                                      \
        prev_chain = (q_hdr_t *)(dequeue_chain->fifo_a) ;  \
        queue_head.fifo_a = (char *)prev_chain ;           \
        if ( prev_chain != NULL )                          \
            prev_chain->lifo_a = NULL ;                    \
        else                                               \
            queue_head.lifo_a = NULL ;                     \
    }                                                      \
}

//
// Function Prototypes
//

UINT UserMibInit(
        IN OUT HANDLE *hPollForTrapEvent ) ;

void TrapInit(
        IN OUT HANDLE *hPollForTrapEvent ) ;

UINT ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind , // Variable Binding to resolve
	    IN UINT PduAction ) ;            // Action specified in PDU

UINT FindClass(
        IN RFC1157VarBind *VarBind,      // Variable Binding
        IN OUT UINT *cindex ) ;          // Index into class_info table

UINT ResolveGetNext(
        IN OUT RFC1157VarBind *VarBind,  // Variable Binding
        IN OUT UINT *cindex,             // Class Info table index
        IN OUT UINT *vindex ,            // Variable table index
        OUT AsnObjectIdentifier *instance ) ;

void SetupTrap(
		IN OUT tcb_t **entryBlock ,
		IN int trapIndex ) ;

UINT AddTrapVar(
		IN tcb_t *entry ,
		IN int trapIndex ,
		IN int varIndex ,
		IN AsnObjectIdentifier *instance ,
		IN char *value ) ;

void PostTrap(
		IN tcb_t *entry ,
		IN int trapIndex ) ;

//
// Externals
//

extern UINT SMIGetInteger() ;
extern UINT SMIGetNSMBoolean() ;
extern UINT SMIGetBIDTEnum() ;
extern UINT SMIGetOctetString() ;
extern UINT SMIGetObjectId() ;
extern UINT SMIGetCounter() ;
extern UINT SMIGetGauge() ;
extern UINT SMIGetTimeTicks() ;
extern UINT SMIGetIpAddress() ;
extern UINT SMIGetDispString() ;
extern UINT SMISetInteger() ;
extern UINT SMISetBIDTEnum() ;
extern UINT SMISetOctetString() ;
extern UINT SMISetObjectId() ;
extern UINT SMISetCounter() ;
extern UINT SMISetGauge() ;
extern UINT SMISetTimeTicks() ;
extern UINT SMISetIpAddress() ;
extern UINT SMISetDispString() ;
extern UINT SMIBuildInteger() ;
extern UINT SMISetNSMBoolean() ;
extern UINT SMIBuildBIDTEnum() ;
extern UINT SMIBuildOctetString() ;
extern UINT SMIBuildObjectId() ;
extern UINT SMIBuildCounter() ;
extern UINT SMIBuildGauge() ;
extern UINT SMIBuildTimeTicks() ;
extern UINT SMIBuildIpAddress() ;
extern UINT SMIBuildDispString() ;
extern void SMIFree() ;

extern q_hdr_t trap_q ;
extern HANDLE hEnabledTraps ;
extern HANDLE hTrapQMutex ;

// Microsoft MIB Specifics.

#define MAX_STRING_LEN            255

#endif /* gennt_h */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\heswinen.c ===
/*
 *  HrSWInstalledEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWInstalledEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:49:12 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>
#include <winsock.h>      /* For htons()           */

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions           */
#include <regstr.h>       /* For Registry-lookup on software     */
#include <winreg.h>       /* For Registry-lookup on software     */
#include <objbase.h>      /* For CoFileTimeToDosDateTime()       */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
BOOL Gen_SingleDevices( void );


/* AddSWInstalled - Add a row to HrSWInstalled Table */
BOOL AddSWInstalled( HKEY sw_key,  FILETIME *ft);


#if defined(CACHE_DUMP)

/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */
static void
debug_print_hrswinstalled(
                        CACHEROW     *row  /* Row in hrSWInstalled table */
                        );
#endif

/*
|==============================================================================
| Create the list-head for the HrSWInstalled table cache.
|
| (This macro is defined in "HMCACHE.H").
*/
static CACHEHEAD_INSTANCE(hrSWInstalled_cache, debug_print_hrswinstalled);


/*
|==============================================================================
| hrSWInstalledTable Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
*/
#define HRIN_INDEX    0    // hrSWInstalledIndex
#define HRIN_NAME     1    // hrSWInstalledName
#define HRIN_DATE     2    // hrSWInstalledDate
                      //-->Add more here, change count below!
#define HRIN_ATTRIB_COUNT 3



/*
 *  GetHrSWInstalledIndex
 *    A unique value for each piece of software installed on the host.  This
 *    value shall be in the range from 1 to the number of piece
 *
 *    Gets the value for HrSWInstalledIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledIndex
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "A unique value for each piece of software installed on the host.  This value
 | shall be in the range from 1 to the number of pieces of software installed on
 | the host."
 |
 |============================================================================
 | 1.3.6.1.2.1.25.6.3.1.1.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledIndex
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledIndex(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWInstalled_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrSWInstalledIndex" value from this entry
*/
*outvalue = row->attrib_list[HRIN_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledIndex() */


/*
 *  GetHrSWInstalledName
 *    A textual description of this installed piece of software, including the
 *    manufacturer, revision, the name by which it is commonl
 *
 *    Gets the value for HrSWInstalledName.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledName
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE (0..64))
 |
 | "A textual description of this installed piece of software, including the
 | manufacturer, revision, the name by which it is commonly known, and
 | optionally, its serial number."
 |
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs, we use the Registry sub-key name.
 |
 | 1.3.6.1.2.1.25.6.3.1.2.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledName
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledName(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWInstalled_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrSWInstalledName" value from this entry
*/
outvalue->string = row->attrib_list[HRIN_NAME].u.string_value;

/* "Truncate" here to meet RFC as needed*/
if ((outvalue->length = strlen(outvalue->string)) > 64) {
    outvalue->length = 64;
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledName() */


/*
 *  GetHrSWInstalledID
 *    The product ID of this installed piece of software.
 *
 *    Gets the value for HrSWInstalledID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledID
 |
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 |
 | "The product ID of this installed piece of software."
 |
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs we don't know the ProductID as an OID, so we
 |    return the ProductID for "unknown": { 0.0 }
 |
 | 1.3.6.1.2.1.25.6.3.1.3.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledID
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledID(
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0"
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledID() */


/*
 *  GetHrSWInstalledType
 *    The type of this software.
 *
 *    Gets the value for HrSWInstalledType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledType
 |
 |  ACCESS         SYNTAX
 | read-only       INTEGER {unknown(1),operatingSystem(2),deviceDriver(3),
 |                          application(4)}
 |
 | "The type of this software."
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs we presume that all uninstallable software is
 |    an application.  That is the only type we return.
 |
 | 1.3.6.1.2.1.25.6.3.1.4.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledType
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledType(
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

*outvalue = 4;  // 4 = "application"

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledType() */


/*
 *  GetHrSWInstalledDate
 *    The last-modification date of this application as it would appear in a
 *    directory listing.
 *
 *    Gets the value for HrSWInstalledDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledDate
 |
 |  ACCESS         SYNTAX
 |  read-only      DateAndTime
 |
 | "The last-modification date of this application as it would appear in a
 |  directory listing."
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs we use the date of the last write into the
 |    Registry key associated with the application.
 |
 | 1.3.6.1.2.1.25.6.3.1.5.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledDate
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledDate(
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWInstalled_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrSWInstalledDate" value from this entry
*/
outvalue->string = row->attrib_list[HRIN_DATE].u.string_value;
outvalue->length = 8;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledDate() */


/*
 *  HrSWInstalledEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWINSTALLEDENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWINSTALLEDENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWINSTALLEDENTRY_VAR_INDEX ] ;

        /*
        | For hrSWInstalledTable, the instance arc(s) is a single arc, and
        | it must correctly select an entry in the hrSWInstalled Table cache.
        | Check that here.
        */
	if ( FindTableRow(tmp_instance, &hrSWInstalled_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledEntryFindInstance() */



/*
 *  HrSWInstalledEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSWINSTALLEDENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSWINSTALLEDENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrSWInstalled_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledEntryFindNextInstance() */



/*
 *  HrSWInstalledEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWInstalledEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrSWInstalledEntryConvertInstance() */




/*
 *  HrSWInstalledEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWInstalledEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrSWInstalledTable */
} /* end of HrSWInstalledEntryFreeInstance() */

/*
| End of Generated Code
*/


/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table */
/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table */
/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table */

BOOL
Gen_HrSWInstalled_Cache(
                        void
                        )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrSWInstalled table,
|       "hrSWInstalled_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to
|       populate the cache for the HrSWInstalled table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
| DISCUSSION:
|
| This implementation of this entire group is rather problematical without the
| creation of a standard.  It certainly appears that many software manufacturers
| dutifully register SOMETHING in the Registry when software is installed,
| however there appears to be no rhyme nor reason to the information put into
| the Registry in leaves below the manufacturers name.  Consequently, for
| installed application software, there is no easy, reliable way of mapping
| the Registry information into entries in this table.
|
| It is clear that some consistent scheme seems to be currently implemented for
| Microsoft software, however the details of extracting it from the Registry
| (and whether or not all information needed for full population of entries in
| this table is available) is not documented.
|
| Proper implementation of "hrSWInstalled" requires the creation and
| promulgation of a standard for registering ISD software (presumably in the
| Registry).  Information in "hrSWInstalled" includes attributes with
| values of Object Identifiers.  Webenable Inc. is prepared to work with
| Microsoft in establishing a standard for registering software in a fashion
| that allows proper implementation of the "hrSWInstalled" table.
|
| Resolution:
|      Report only logo 95 compliant software initially.
|
|============================================================================
|
| 1.3.6.1.2.1.25.6.1.0....
|                | |
|                | *hrSWInstalledLastChange
|                *-hrSWInstalled
|
| 1.3.6.1.2.1.25.6.2.0....
|                | |
|                | *hrSWInstalledLastUpdateTime
|                *-hrSWInstalled
|
| 1.3.6.1.2.1.25.6.3.1....
|                | | |
|                | | *-hrSWInstalledEntry
|                | *-hrSWInstalledTable
|                *-hrSWInstalled
|
*/

#define SUBKEY_LEN 64   // Long enough for short key-name of software
{
HKEY     subkey;                        /* Handle of subkey for uninstall software */
DWORD    index;                         /* Index counter for enumerating subkeys   */
LONG     enum_status=ERROR_SUCCESS;     /* Status from subkey enumeration          */
CHAR     subkey_name[SUBKEY_LEN];       /* Subkey name returned here               */
DWORD    subkey_len=SUBKEY_LEN;         /* Subkey name buffer size                 */
FILETIME keytime;                       /* Time subkey was last written to         */
BOOL     add_status;                    /* Status from add-row operation           */
HKEY     sw_key;                        /* Handle of software key for value enum   */


if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,    // hkey - currently open
                 REGSTR_PATH_UNINSTALL, // subkey to open
                 0,                     // options
                 KEY_READ,              // Security access mask
                 &subkey
                 ) == ERROR_SUCCESS) {

    /* Enumerate the keys using the Uninstall subkey */
    for (index = 0; enum_status != ERROR_NO_MORE_ITEMS; index += 1) {

        subkey_len=SUBKEY_LEN;

        enum_status = RegEnumKeyEx(subkey,      // Enumerating this key
                                   index,       // next subkey index
                                   subkey_name, // Buffer to rcv subkey name
                                   &subkey_len, // Buffer size
                                   NULL,        // Reserved
                                   NULL,        // Class name buffer
                                   NULL,        // Class buffer size
                                   &keytime     // Time of last write to subkey
                                   );

        /* Skip if we didn't open OK */
        if (enum_status != ERROR_SUCCESS) {
            continue;
            }


        /* Now try for the software itself */
        if (RegOpenKeyEx(subkey,                // hkey - currently open
                         subkey_name,           // subkey to open
                         0,                     // options
                         KEY_READ,              // Security access mask
                         &sw_key
                         ) == ERROR_SUCCESS) {

            /* Now Enumerate the Values of this key */
            add_status =
                AddSWInstalled(sw_key,   // Key to obtain DisplayName
                               &keytime  // Date and Time installed
                               );
            RegCloseKey(sw_key);

            /* If something blew down below, bail out */
            if (add_status == FALSE) {

                RegCloseKey(subkey);
                return ( FALSE );
                }
            }
        }

        RegCloseKey(subkey);
    }

#if defined(CACHE_DUMP)
PrintCache(&hrSWInstalled_cache);
#endif

/* hrSWInstalled cache initialized */
return ( TRUE );
}


/* UTCDosDateTimeToLocalSysTime - converts UTC msdos date and time to local SYSTEMTIME structure */
/* UTCDosDateTimeToLocalSysTime - converts UTC msdos date and time to local SYSTEMTIME structure */
/* UTCDosDateTimeToLocalSysTime - converts UTC msdos date and time to local SYSTEMTIME structure */
void UTCDosDateTimeToLocalSysTime(WORD msdos_date, WORD msdos_time, LPSYSTEMTIME pSysTime)
{
    SYSTEMTIME utcSysTime;

    utcSysTime.wYear = (msdos_date >> 9) + 1980;
    utcSysTime.wMonth = ((msdos_date >> 5) & 0x0F);
    utcSysTime.wDay = (msdos_date & 0x1F);
    utcSysTime.wDayOfWeek = 0;
    utcSysTime.wHour = (msdos_time >> 11);
    utcSysTime.wMinute = ((msdos_time >> 5) & 0x3F);
    utcSysTime.wSecond = ((msdos_time & 0x1F) * 2);
    utcSysTime.wMilliseconds = 0;

    if (!SystemTimeToTzSpecificLocalTime(
             NULL,           // [in]  use active time zone
             &utcSysTime,    // [in]  utc system time
             pSysTime))      // [out] local time 
    {
        // if the utc time could not be converted to local time,
        // just return the utc time
        memcpy(&utcSysTime, pSysTime, sizeof(SYSTEMTIME));
    }
}


/* AddSWInstalled - Add a row to HrSWInstalled Table */
/* AddSWInstalled - Add a row to HrSWInstalled Table */
/* AddSWInstalled - Add a row to HrSWInstalled Table */

BOOL
AddSWInstalled(
               HKEY         sw_key,
               FILETIME    *ft
               )
/*
|  EXPLICIT INPUTS:
|
|       "sw_key" - an opened key for a piece of software whose Values we
|        must enumerate looking for "DisplayName"
|
|       "ft" - This is the time that the key was last written, and we
|       take it as the time the software was installed.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrSWInstalled table,
|       "hrSWInstalled_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|     The Gen_SWInstalled_cache() function has been invoked to populate
|     the cache, and this function is called when it has found another
|     piece of software for which a row-entry needs to be placed into
|     the cache.
|
|  OTHER THINGS TO KNOW:
|
*/

#define VALUE_LEN 32         // Long enough for "UninstallString"
#define VALUE_DATA_LEN 128   // Long enough for a long "casual" name
{
DWORD    index;                         /* Index counter for enumerating subkeys   */
LONG     enum_status=ERROR_SUCCESS;     /* Status from subkey enumeration          */
CHAR     value_name[VALUE_LEN];         /* Value name returned here                */
DWORD    value_len;                     /* Value name buffer size                  */
DWORD    value_type;                    /* Type code for value string              */
CHAR     value_data[VALUE_DATA_LEN];    /* Value's value returned here          */
DWORD    value_data_len;                /* Value's value buffer length resides here*/

static                                  /* NOTE: "static" is a 'must'              */
ULONG    table_index=0;                 /* HrDeviceTable index counter             */
CACHEROW *row;                          /* --> Cache structure for row-being built */
WORD     msdos_date;                    /* Conversion area for software date/time  */
WORD     msdos_time;                    /* Conversion area for software date/time  */
char    *octet_string;                  /* Alias for building DateAndTime          */
UINT     i;                             /* Loop index                              */


/*
| Now go a-lookin' for "DisplayName", the value whose data will give us
| the name of the installed software.
|
| For each Value associated with this software's key . . .
*/
for (index = 0; enum_status != ERROR_NO_MORE_ITEMS; index += 1) {

    /* Make sure these cells continues to reflect the buffer size */
    value_len = VALUE_LEN;
    value_data_len = VALUE_DATA_LEN;

    enum_status = RegEnumValue(sw_key,        // Key whose values we're enuming
                               index,         // index of next value
                               value_name,    // Value name buffer
                               &value_len,    // length of Value name buffer
                               NULL,          // reserved
                               &value_type,   // type of value data
                               value_data,    // Buffer for value's data
                               &value_data_len// Length of data buffer
                               );

    /* Only if we managed to fetch this key do we try to recognize it */
    if (enum_status == ERROR_SUCCESS) {

        /* If the value we just read is for "DisplayName" */
        if ( strcmp(value_name, REGSTR_VAL_UNINSTALLER_DISPLAYNAME) == 0) {

            /*
            | Get a row-entry created.
            */
            if ((row = CreateTableRow( HRIN_ATTRIB_COUNT ) ) == NULL) {
                return ( FALSE );       // Out of memory
                }

            /*
            | Set up the cached hrSWInstalled attributes in the new row
            */

            /* =========== hrSWInstalledIndex ==========*/
            row->attrib_list[HRIN_INDEX].attrib_type = CA_NUMBER;
            row->attrib_list[HRIN_INDEX].u.unumber_value = (table_index += 1) ;


            /* =========== hrSWInstalledName ==========*/
            row->attrib_list[HRIN_NAME].attrib_type = CA_STRING;
            if ( (row->attrib_list[HRIN_NAME].u.string_value
                  = ( LPSTR ) malloc(value_data_len + 1)) == NULL) {
                return ( FALSE );       /* out of memory */
                }
            strcpy(row->attrib_list[HRIN_NAME].u.string_value, value_data);


            /* =========== hrSWInstalledDate ==========
            |
            | Here's the deal on this one.  We've got a 64-bit FILETIME
            | representation of when the Registry entry was made for the
            | software. We're taking this as the install time of the software.
            |
            | So we convert to MS-DOS time, then to DateAndTime (in the
            | 8-octet form) below:
            |========================== From RFC1514 ========================
            |
            |    DateAndTime ::= OCTET STRING (SIZE (8 | 11))
            |    --     A date-time specification for the local time of day.
            |    --     This data type is intended to provide a consistent
            |    --     method of reporting date information.
            |    --
            |    --         field  octets  contents                  range
            |    --         _____  ______  ________                  _____
            |    --           1      1-2   year                      0..65536
            |    --                           (in network byte order)
            |    --           2       3    month                     1..12
            |    --           3       4    day                       1..31
            |    --           4       5    hour                      0..23
            |    --           5       6    minutes                   0..59
            |    --           6       7    seconds                   0..60
            |    --                        (use 60 for leap-second)
            |    --           7       8    deci-seconds              0..9
            |    --           8       9    direction from UTC        "+" / "-"
            |    --                        (in ascii notation)
            |    --           9      10    hours from UTC            0..11
            |    --          10      11    minutes from UTC          0..59
            |    --
            |    --         Note that if only local time is known, then
            |    --         timezone information (fields 8-10) is not present.
            |
            |    MS-DOS records file dates and times as packed 16-bit values.
            |    An MS-DOS date has the following format:
            |    Bits	Contents
            |    ----   --------
            |    0-4	Days of the month (1-31).
            |    5-8	Months (1 = January, 2 = February, and so forth).
            |    9-15	Year offset from 1980 (add 1980 to get actual year).
            |
            |    An MS-DOS time has the following format:
            |    Bits	Contents
            |    ----   --------
            |    0-4	Seconds divided by 2.
            |    5-10	Minutes (0-59).
            |    11-15	Hours (0-23 on a 24-hour clock).
            |
            */
            row->attrib_list[HRIN_DATE].attrib_type = CA_STRING;
            if ( (row->attrib_list[HRIN_DATE].u.string_value
                        = octet_string = ( LPSTR ) malloc(8)) == NULL) {
                return ( FALSE );       /* out of memory */
                }
            for (i=0; i < 8; i += 1) octet_string[i] = '\0';

            if (CoFileTimeToDosDateTime(ft, &msdos_date, &msdos_time) == TRUE) {
                SYSTEMTIME localInstTime;
                USHORT year;

                UTCDosDateTimeToLocalSysTime(msdos_date, msdos_time, &localInstTime);

                year = htons(localInstTime.wYear);
                octet_string[0] = (year & 0xFF);
                octet_string[1] = (year >> 8);
                octet_string[2] = (char)localInstTime.wMonth;
                octet_string[3] = (char)localInstTime.wDay;
                octet_string[4] = (char)localInstTime.wHour;
                octet_string[5] = (char)localInstTime.wMinute;
                octet_string[6] = (char)localInstTime.wSecond;
                octet_string[7] = (char)localInstTime.wMilliseconds / 10;
                }

            /*
            | The other standard hrSWInstalled attributes are currently
            | "hardwired" in the Get functions.
            */

            /*
            | Now insert the filled-in CACHEROW structure into the
            | cache-list for the hrDeviceTable.
            */
            if (AddTableRow(row->attrib_list[HRIN_INDEX].u.unumber_value,  /* Index */
                            row,                                           /* Row   */
                            &hrSWInstalled_cache                           /* Cache */
                            ) == FALSE) {
                return ( FALSE );       /* Internal Logic Error! */
                }

            /*
            | Break from the Enumeration loop on the values, we've found
            | the one we want.
            */
            break;
            }
        }
    }  /* for */

/* Add succeeded */
return ( TRUE );
}


#if defined(CACHE_DUMP)


/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */
/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */
/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */

static void
debug_print_hrswinstalled(
                        CACHEROW     *row  /* Row in hrSWInstalled table */
                        )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{
UINT    i;

if (row == NULL) {
    fprintf(OFILE, "=========================\n");
    fprintf(OFILE, "hrSWInstalled Table Cache\n");
    fprintf(OFILE, "=========================\n");
    return;
    }

fprintf(OFILE, "hrSWInstalledIndex . . . . %d\n",
        row->attrib_list[HRIN_INDEX].u.unumber_value);

fprintf(OFILE, "hrSWInstalledName  . . . . %s\n",
        row->attrib_list[HRIN_NAME].u.string_value);

fprintf(OFILE, "hrSWInstalledDate  . . . . ");
for (i = 0; i < 8; i += 1) {
    fprintf(OFILE, "%2.2x ",row->attrib_list[HRIN_DATE].u.string_value[i]);
    }
fprintf(OFILE, "\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hmcache.h ===
/*
 *  File HMCACHE.H
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module is contains definitions pertaining to the HostMIB
 *    cacheing mechanism.
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V1.0 - 04/17/97  D. D. Burns     Original Creation
 */

#ifndef hmcache_h
#define hmcache_h


/*
|==============================================================================
| Debug Cache Dump Support
|
|    Define "CACHE_DUMP" to get function "PrintCache" defined to enable
|    debug-dumping of any cache for which a debug_print function is defined
|    (in a CACHEHEAD_INSTANCE() macro that defines the list-head of the cache).
|
|    Define "DUMP_FILE" to specify where the dump file is generated.  All
|    opens on this file are for "append", so you must explicitly delete the
|    file if you want to start fresh.  All entries are time-stamped, so any
|    confusion is your own, though.
|
|    NOTE 1: After defining "CACHE_DUMP", grep the sources to see what caches
|            "PrintCache()" may be being invoked on and where.  Typically
|            all caches are dumped immediately after they are built.  The
|            cache for hrSWRun(Perf) table is re-built if it is older than
|            "CACHE_MAX_AGE" (defined in "HRSWRUNE.C") when a request for
|            something in the tables served by the cache comes in.  So it
|            may also be dumped after each (re-)build.
|
|    NOTE 2: Define "PROC_CACHE" to get a periodic dump to "PROC_FILE" of
|            the hrProcessorLoad-specific cache.  This dump occurs on a
|            1-minute timer and will rapidly use up disk space if left
|            running for any long period.  This cache and dump is special
|            to the "hrProcessorLoad" variable in hrProcessor sub-table.
|            (Opens on this file are also for "append").
*/
//#define CACHE_DUMP 1
#define DUMP_FILE \
    "c:\\nt\\private\\net\\snmp\\subagent\\hostmib\\HostMib_Cache.dmp"

//#define PROC_CACHE 1
#define PROC_FILE \
    "c:\\nt\\private\\net\\snmp\\subagent\\hostmib\\Processor_Cache.dmp"


#if defined(CACHE_DUMP) || defined(PROC_CACHE)
#include <stdio.h>
#include <time.h>
#endif

/*
|==============================================================================
| hrStorage Attribute Defines
|
|    Each attribute defined for hrStorage table is associated with one of the
|    #defines below.  These symbols are used as C indices into the list of
|    attributes within a cached-row.
|
|    These symbols are globally accessible so that logic that builds hrFSTable
|    can "peek" at values stored in the hrStorageTable cache.
*/
#define HRST_INDEX 0    // hrStorageIndex
#define HRST_TYPE  1    // hrStorageType
#define HRST_DESCR 2    // hrStorageDescr
#define HRST_ALLOC 3    // hrStorageAllocationUnits
#define HRST_SIZE  4    // hrStorageSize
#define HRST_USED  5    // hrStorageUsed
#define HRST_FAILS 6    // hrStorageAllocationFailures
                   //-->Add more here, change count below!
#define HRST_ATTRIB_COUNT 7


/*
|==============================================================================
| hrFSTable Attribute Defines
|
|    Each attribute defined for hrFSTable is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
|    These symbols are globally accessible so that logic that builds 
|    hrPartition can "peek" at values stored in the hrFSEntry Table cache.
*/
#define HRFS_INDEX    0    // hrFSIndex
#define HRFS_MOUNTPT  1    // hrFSMountPoint
#define HRFS_RMOUNTPT 2    // hrFSRemoteMountPoint
#define HRFS_TYPE     3    // hrFSType
#define HRFS_ACCESS   4    // hrFSAccess
#define HRFS_BOOTABLE 5    // hrFSBootable
#define HRFS_STORINDX 6    // hrFSStorageIndex
#define HRFS_LASTFULL 7    // hrFSLastFullBackupDate
#define HRFS_LASTPART 8    // hrFSLastPartialBackupDate
                      //-->Add more here, change count below!
#define HRFS_ATTRIB_COUNT 9


/*
|==============================================================================
| hrSWRun(Perf) Table Attribute Defines
|
|    Each attribute defined for hrSWRun Table and hrSWRunPerf Table is 
|    associated with one of the #defines below.  These symbols are used as 
|    C indices into the array of attributes within a cached-row.
|
|    These symbols are globally accessible so that logic for hrSWRunPerf table
|    (in "HRSWPREN.C") can reference these as well as logic for hrSWRun table
|    (in "HRSWRUNE.C") since both tables share the same cache.
|
|    Note that "HrSWRunID" is not cached.
*/
#define HRSR_INDEX    0    // HrSWRunIndex
#define HRSR_NAME     1    // HrSWRunName
#define HRSR_PATH     2    // HrSWRunPath
#define HRSR_PARAM    3    // HRSWRunParameters
#define HRSR_TYPE     4    // HrSWRunType
#define HRSR_STATUS   5    // HrSWRunStatus
#define HRSP_CPU      6    // HrSWRunPerfCPU - Performance
#define HRSP_MEM      7    // HrSWRunPerfMem - Performance
                      //-->Add more here, change count below!
#define HRSR_ATTRIB_COUNT 8


/*
|==============================================================================
| These structures are used in the implementation of an in-memory cache
| for the Host Resources MIB subagent.  For a broad overview of the cache
| scheme, see the documentation at the front of "HMCACHE.C".
|==============================================================================
*/


/*
|==============================================================================
| ATTRIB_TYPE
|
|     This enumerated type lists the data-type of a value of an attribute
|     stored in an instance of a ATTRIB structure (one of typically many
|     in a CACHEROW structure for a given table row).
|
|     "CA_STRING"
|       The value is a null-terminated string sitting in 'malloc'ed storage
|       within an ATTRIB structure.
|
|     "CA_NUMBER"
|       The value is a binary numeric value stored directly in the ATTRIB
|       structure.  No additional malloc storage is associated with this
|       type.
|
|     "CA_COMPUTED"
|       The value is not stored in the ATTRIB structure at all, but is
|       dynamic and is computed and returned by the support subagent
|       "get" function.
|
|     "CA_CACHE"
|       The value is a pointer to a CACHEHEAD structure that describes
|       another cache.  The CACHEHEAD structure is in 'malloc'ed storage.
|       This is used for "multiply-indexed" tables.
|
| Note that the instance of this enumerated type (in ATTRIB below) is mainly
| of use in debugging and memory management (when we get to the point where 
| cached-rows may be freed).  Generally the "Get" function that is going to
| reach into the cache is already going to be coded according to what is
| there, and may not even look to see what "type" the value is.
|==============================================================================
*/
typedef
    enum {
        CA_UNKNOWN,     /* Not yet set               */
        CA_STRING,      /* ('malloc'ed storage)      */
        CA_NUMBER,      /* (no 'malloc'ed storage)   */
        CA_COMPUTED,    /* (no 'malloc'ed storage)   */
        CA_CACHE        /* ('malloc'ed storage)      */
        } ATTRIB_TYPE;



/*
|==============================================================================
| ATTRIB
|
|     An array of these structures is logically allocated inside each 
|     instance of a CACHEROW structure.
|
|     An instance of this structure describes the value of one attribute
|     in the cache (in general; in the "CA_COMPUTED" case there is no value
|     present, the GET function "knows" what to do).
|==============================================================================
*/
typedef
    struct {

        ATTRIB_TYPE     attrib_type;    /* STRING, NUMBER, (COMPUTED) */

        union {
            LPSTR       string_value;   /* CA_STRING (malloc)   */
            ULONG       unumber_value;  /* CA_NUMBER (unsigned) */
            LONG        number_value;   /* CA_NUMBER (signed)   */
            void       *cache;          /* CA_CACHE  (malloc)   */
            } u;
            
        } ATTRIB;



/*
|==============================================================================
| CACHEROW
|
|     An instance of this structure occurs for each row in a table.  Instances
|     are strung on a list maintained by a CACHEHEAD structure (below), ordered
|     by the value of "index".
|
|     The "attrib_list[]" array storage is malloc'ed to the appropriate size
|     at the time an instance of this structure is created.  The indices into
|     this array are #DEFINED symbols, all according to the table definition
|     of the attributes in the table.  Typically the #defines are placed in
|     the source module that implements the table.
|
|     The internal arrangement of this structure (and underlying structures)
|     is meant to be such that function "DestroyTableRow()" can release all
|     storage for an instance of this structure without "knowing" the #DEFINE
|     index symbols above (or anything else).
|==============================================================================
*/
typedef
    struct rc_tag{

        ULONG           index;          /* SNMP index of table              */
        struct rc_tag   *next;          /* Next in the cache list           */

        /*
        | Contents of this table row:
        */
        ULONG           attrib_count;   /* # of elements in "attrib_list"[] */
        ATTRIB         *attrib_list;    /* --> array of attributes          */

        } CACHEROW;



/*
|==============================================================================
| CACHEHEAD
|
|     An instance of this structure (created by the macro CACHEHEAD_INSTANCE)
|     occurs for each SNMP "table" cached.
|
|     All CACHEROW elements of the list are ordered by their index values
|     as they are inserted by general function "AddTableRow()".
|
|     See documentation in "HMCACHE.C".
|
|NOTE: If you modify this structure or the macro that initializes static
|      instances of it, be sure to add/change code in "HRPARTIT.C" where
|      instances in dynamic (malloc) memory are created.
|==============================================================================
*/
typedef
    struct {

        ULONG           list_count;     /* (Mainly for ease of debugging) */
        CACHEROW        *list;          /* The row list itself            */
        void            (*print_row)(); /* Debug Print-A-Row function     */
        } CACHEHEAD;

#if defined(CACHE_DUMP)
#define CACHEHEAD_INSTANCE(name,debug_print)       \
        CACHEHEAD  name={ 0, NULL, debug_print };
#else
#define CACHEHEAD_INSTANCE(name,debug_print)       \
        CACHEHEAD  name={ 0, NULL, NULL };
#endif


/*
|==============================================================================
| HMCACHE.C - Function Prototypes
*/

/* CreateTableRow - Create a CACHEROW structure for attributes in a table */
CACHEROW *
CreateTableRow(
               ULONG attribute_count
              );

/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */
void
DestroyTable(
             CACHEHEAD *cache   /* Cache whose rows are to be Released */
             );

/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */
void
DestroyTableRow(
                CACHEROW *row   /* Row to be Released */
                );

/* AddTableRow - Adds a specific "row" into a cached "table" */
BOOL
AddTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEROW   *row,           /* Row to be added to .. */
             CACHEHEAD  *cache          /* this cache            */
              );

/* FindTableRow - Finds a specific "row" in a cached "table" */
CACHEROW *
FindTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEHEAD  *cache          /* Table cache to search */
              );

/* FindNextTableRow - Finds Next row after a specific "row" in a cache */
CACHEROW *
FindNextTableRow(
                 ULONG      index,          /* Index for row desired */
                 CACHEHEAD  *cache          /* Table cache to search */
                 );

/* GetNextTableRow - Gets Next row after a specific "row" or NULL if none */
#define GetNextTableRow(row) row->next


/* ======  DEBUG DUMP SUPPORT ====== */
#if defined(CACHE_DUMP)
/* PrintCache - Dumps for debugging the contents of a cache */
void
PrintCache(
           CACHEHEAD  *cache          /* Table cache to dump */
           );

/* Debug Print Output channel used by PrintCache &  "Print-A-Row" functions*/
#define OFILE Ofile
extern FILE *Ofile;
#endif


/*
|==============================================================================
| Function Prototypes for cache-related function found in other modules:
*/

/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */
BOOL Gen_Hrstorage_Cache( void );       /* "HRSTOENT.C"                      */
extern CACHEHEAD hrStorage_cache;       /* This cache is globally accessible */

/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */
BOOL Gen_HrFSTable_Cache( void );       /* "HRFSENTR.C"                      */
extern CACHEHEAD hrFSTable_cache;       /* This cache is globally accessible */

/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */
BOOL Gen_HrDevice_Cache( void );        /* "HRDEVENT.C"                      */
extern CACHEHEAD hrDevice_cache;        /* This cache is globally accessible */
extern ULONG InitLoadDev_index;         /* From hrDevice for hrSystem        */

/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table        */
BOOL Gen_HrSWInstalled_Cache( void );   /* "HESWINEN.C"                      */

/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table      */
BOOL Gen_HrSWRun_Cache( void );         /* "HRSWRUNE.C"                      */
extern CACHEHEAD hrSWRunTable_cache;    /* Globally accessible for ref from  */
                                        /* "HRSWPREN.C"                      */
extern ULONG SWOSIndex;                 /* From "HRSWRUNE.C" for "HRSWRUN.C" */

/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */
BOOL hrSWRunCache_Refresh( void );
/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */
BOOL hrStorageCache_hrFSTableCache_Refresh( void );

#endif /* hmcache_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hostmsmi.h ===
/*
 *  mibtsmi.nth  v0.10
 *  hostmsmi.h
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the user defined type definitions.
 *
 *  Author:
 *
 *	David Burns @ Webenable Inc
 *
 *  Date:
 *
 *	Thu Nov 07 16:38:31 1996
 *
 *  Revision History:
 *      generated with v0.10 stub
 *
 */

#if !defined(_HOSTMSMI_H_)
#define _HOSTMSMI_H_

#include <snmp.h>
#include "smint.h"
/*
 *    Boolean ::= INTEGER a truth value
 */
typedef enum
{
    true = 1 ,
    false = 2
} Boolean ;
/*
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 */
typedef Integer KBytes ;
/*
 *    INThrDeviceStatus ::= INTEGER 
 */
typedef enum
{
    unknown0 = 1 ,
    running0 = 2 ,
    warning0 = 3 ,
    testing0 = 4 ,
    down0 = 5
} INThrDeviceStatus ;
/*
 *    INThrPrinterStatus ::= INTEGER 
 */
typedef enum
{
    other1 = 1 ,
    unknown1 = 2 ,
    idle1 = 3 ,
    printing1 = 4 ,
    warmup1 = 5
} INThrPrinterStatus ;
/*
 *    INTAccess ::= INTEGER 
 */
typedef enum
{
    readWrite = 1 ,
    readOnly = 2
} INTAccess ;
/*
 *    INThrDiskStorageMedia ::= INTEGER 
 */
typedef enum
{
    other = 1 ,
    unknown = 2 ,
    hardDisk = 3 ,
    floppyDisk = 4 ,
    opticalDiskROM = 5 ,
    opticalDiskWORM = 6 , /* Write once Read Many */
    opticalDiskRW = 7 ,
    ramDisk = 8
} INThrDiskStorageMedia ;
/*
 *    INTSWType ::= INTEGER 
 */
typedef enum
{
    unknown2 = 1 ,
    operatingSystem2 = 2 ,
    deviceDriver2 = 3 ,
    application2 = 4
} INTSWType ;
/*
 *    INThrSWRunStatus ::= INTEGER 
 */
typedef enum
{
    running = 2 ,
    runnable = 2 , /* waiting for resource (CPU, memory, IO) */
    notRunnable = 3 , /* loaded but waiting for event */
    invalid = 4 /* not loaded */
} INThrSWRunStatus ;
/*
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 */
typedef OctetString DateAndTime ;
/*
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 */
typedef OctetString InternationalDisplayString ;
/*
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 */
typedef ObjectIdentifier ProductID ;
#endif /*_HOSTMSMI_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hmcache.c ===
/*
*
*
*  Facility:
*
*    SNMP Extension Agent
*
*  Abstract:
*  
*    This module contains support functions for the creation and
*    maintenance of the in-memory cache for the HostMIB Subagent.
*
*
*  Author:
*
*    D. D. Burns @ WebEnable, Inc.
*
*
*  Revision History:
*
*    V1.00 - 04/17/97  D. D. Burns     Original Creation
*
*
*/


/*
Host-MIB Cache Overview
-----------------------

This module contains functions that create, maintain and allow for searching
data structures that are used to implement a cache of HOST-MIB information.

Typically, a cache is created on a "per-table" basis and is formed as a
linked-list of CACHEROW structures (all cache structures are defined in
"HMCACHE.H"), one CACHEROW structure for each logical "row" in the table.

The list-head of each cache is a CACHEHEAD structure and is instantiated in
the source module for the functions that service the attributes in that
table (so the CACHEHEAD structure for the cache for the "hrStorage" table is
in module "HRSTOENT.C").

Caches are created at start-up time by special cache-creation functions (coded
to the specs for each table) in each of the "table" source modules.  Those
cache-creation functions (plus the associated "get" and "set" functions) use
the general cache manipulation functions in this module.

For example, a typical cache looks like this:

      HrStorage Table Cache
        "hrStorage_cache"
      (statically allocated
         in "HRSTOENT.C")...

       *============*
       |  CACHEHEAD |
       |  "list"....|--*          ..(Malloced as a single instance in function
       *============*  |          .  "CreateTableRow")
                       V          .
                      *================*                ..(Malloced as an
                      |    CACHEROW    |                . array in function
                   *--|...."next"      |                . "CreateTableRow()")
                   |  |    "index".....|--> "1"         .
                   |  | "attrib_list"..|--> *===============*
                   |  *================*    |    ATTRIB     |
                   |                        | "attrib_type".|-->CA_NUMBER
                   |                        | "u.unumber"...|-->"4"
                   |                        +---------------+
                   |                        |    ATTRIB     |
                   |                        | "attrib_type".|-->CA_STRING
                   |                        | "u.string"....|-->"<string>"
                   |                        +---------------+
                   |                        |    ATTRIB     |
                   |                        | "attrib_type".|-->CA_CACHE
                   |                        |   "u.cache"...|------*
                   |                        +---------------+      |
                   |                                .              |
                   |  *=================*           .              |
                   *->|    CACHEROW     |           .              |
                   *--|...."next"       |                   *============*
                   |  |    "index"......|-->"2"             |  CACHEHEAD |
                   |  |  "attrib_list"..|-->                |  "list"....|--*
                   |  *=================*                   *============*  |
                   V                                         (For doubly    |
                                                              indexed       V
                                                              tables)

The general cache manipulation functions in this module include:

Name                    Purpose
----                    -------
CreateTableRow          Creates an instance of a CACHEROW with a given
                        attribute count.  (This function does not link the
                        instance into any list, it merely mallocs storage).

AddTableRow             Given an index value, a CACHEROW instance (created by
                        "CreateTableRow()" above) and a CACHEHEAD, this
                        function links the CACHEROW instance into the list
                        described by CACHEHEAD in the proper place given the
                        index value.

         These two functions above are used to populate the cache 
         (typically at startup time).

Name                    Purpose
----                    -------
FindTableRow            Given an index value and a CACHEHEAD, this function
                        returns a pointer to the CACHEROW instance in the
                        CACHEHEAD cache that has the given index.  This 
                        function is used to find a given cache entry (ie table
                        "row") in service for a "get" or "set" routine.

FindNextTableRow        Given an index value and a CACHEHEAD, this function
                        returns a pointer to the CACHEROW instance in the
                        CACHEHEAD cache that IMMEDIATELY FOLLOWS the given
                        index.  This function is used to find a given cache
                        entry (ie table "row") in service for "get-next"
                        situations.

GetNextTableRow         Given a CACHEROW row (obtained using either of the
                        routines above), this gets the next entry regardless
                        of index (or NULL if the given row is the last row).
                        (Implemented as a macro in "HMCACHE.H").

RemoveTableRow          Given an index value and a CACHEHEAD, this function
                        unlinks the CACHEROW instance from the cache list
                        described by CACHEHEAD. (TBD in support of PNP)

DestroyTable            Given a pointer to a CACHEHEAD, this function releases
                        every row-instance in the cache (through calls to
                        "DestroyTableRow()" below).  This function presumes
                        that the CACHEHEAD itself is statically allocated.

DestroyTableRow         Given an instance of an (unlinked) CACHEROW, this
                        function releases the storage associated with it.


For Debugging:
Name                    Purpose
----                    -------
PrintCache              Prints a dump on an output file in ASCII of the 
                        contents of a specified cache.  Only works for caches
                        for which a "print-row" function is defined and
                        referenced in the CACHEHEAD structure for the cache.
*/



/*
| INCLUDES:
*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>      /* for debug printf */
#include <time.h>       /* for debug support */
#include <malloc.h>

#include "hmcache.h"

/*
|==============================================================================
| Debug File Channel
|
*/
#if defined(CACHE_DUMP) || defined(PROC_CACHE)
FILE *Ofile;
#endif




/* CreateTableRow - Create a CACHEROW structure for attributes in a table */
/* CreateTableRow - Create a CACHEROW structure for attributes in a table */
/* CreateTableRow - Create a CACHEROW structure for attributes in a table */

CACHEROW *
CreateTableRow(
               ULONG attribute_count
              )

/*
|  EXPLICIT INPUTS:
|
|       "attribute_count" indicates how much storage to allocate for the
|       array of attributes for this row.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to allocated storage containing an
|       image of a CACHEROW structure.  Enough storage for each attribute
|       in the row has been allocated within array "attrib_list[]" and the
|       count of these elements has been stored in the CACHEROW structure.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the caches for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code for each table to create one CACHEROW
|       structure for each row needed in the table.
|
|       With the advent of PNP, this function can be called after startup
|       time to add rows to an existing table.
|
|       (Note: The actual insertion of an instance returned by this function
|              into a cache table list is done by function "AddTableRow()" ).
|
|  OTHER THINGS TO KNOW:
|
|       "DestroyTableRow()" deallocates storage associated with any instance
|       of a CACHEROW structure created by this function.
|
*/
{
CACHEROW        *new=NULL;      /* New CACHEROW instance to be created */
ULONG           i;              /* handy-dandy Index                   */


/* Create the main CACHEROW structure to be returned . . . */
if ( (new = (CACHEROW *) malloc(sizeof(CACHEROW))) == NULL) {

    /* "Not Enough Storage" */
    return (NULL);
    }

/*
| Now try to allocate enough storage for the array of attributes in this row
*/
if ( (new->attrib_list = (ATTRIB *) malloc(sizeof(ATTRIB) * attribute_count))
    == NULL) {

    /* "Not Enough Storage" */
    free( new ) ;       /* Blow off the CACHEROW we won't be returning */
    return (NULL);
    }

/* Indicate how big this array is so DestroyTableRow() can do the right thing*/
new->attrib_count = attribute_count;

/* Zap each array entry so things are clean */
for (i = 0; i < attribute_count; i += 1) {
    new->attrib_list[i].attrib_type = CA_UNKNOWN;
    new->attrib_list[i].u.string_value = NULL;
    }


new->index = 0;         /* No legal index yet        */
new->next = NULL;       /* Not in the cache list yet */


/* Return the newly allocated CACHEROW structure for further population */
return ( new ) ;
}

/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */
/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */
/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */

void
DestroyTable(
             CACHEHEAD *cache   /* Cache whose rows are to be Released */
             )

/*
|  EXPLICIT INPUTS:
|
|       "cache" is the CACHEHEAD instance of a table for which all rows are
|       to be released.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       Function returns, the CACHEHEAD is set to reflect an empty cache.
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the caches for each table in the MIB is
|       populated with rows for each row in the table.  "CreateTableRow" is
|       invoked by the start-up code for each table to create one CACHEROW
|       structure for each row needed in the table.
|
|       With the advent of PNP, this function can be called after startup
|       time to delete all storage associated with such a cache.
|
|
|  OTHER THINGS TO KNOW:
|
|       This function may be recursively invoked through the call to
|       "DestroyTable()" inside "DestroyTableRow()".
|
|       This function may be safely invoked on an "empty" cache-head.
|
|       This function doesn't attempt to release storage associated with
|       the CACHEHEAD structure itself.
|
|  DOUBLE NOTE:
|       This function simply releases storage.  You can't go calling this
|       function willy-nilly on just any cache without taking into
|       consideration the semantics of what maybe being blown away. For
|       instance, some tables in Host MIB contain attributes whose values
|       are indices into other tables.  If a table is destroyed and rebuilt,
|       clearly the references to the rebuilt table must be refreshed in
|       some manner.
*/
{

/*
| If an old copy of the cache exists, blow it away now
*/
while (cache->list != NULL) {

    CACHEROW    *row_to_go;

    /* Pick up the row to blow away */
    row_to_go = cache->list;

    /* Change the cache-head to point to the next row (if any) */
    cache->list = GetNextTableRow(row_to_go);

    DestroyTableRow(row_to_go);
    }

/* Show no entries in the cache */
cache->list_count = 0;
}

/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */
/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */
/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */

void
DestroyTableRow(
                CACHEROW *row   /* Row to be Released */
                )

/*
|  EXPLICIT INPUTS:
|
|       "row" is the instance of a row to be released.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       Function returns.
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the caches for each table in the MIB is
|       populated with rows for each row in the table.  "CreateTableRow" is
|       invoked by the start-up code for each table to create one CACHEROW
|       structure for each row needed in the table.
|
|       With the advent of PNP, this function can be called after startup
|       time to delete storage associated with rows being replaced in an
|       existing table.
|
|       (Note: The actual deletion of an row instance from a cache table list
|              must be done before this function is called).
|
|  OTHER THINGS TO KNOW:
|
|       "CreateTableRow()" creates an instance of what this function
|       "destroys".
|
|       This function may be recursively invoked through the call to
|       "DestroyTable()" in the event we are release a row that contains
|       an attribute "value" that is really another table (in the case
|       of a multiply-indexed attribute).
|
|  DOUBLE NOTE:
|       This function simply releases storage.  You can't go calling this
|       function willy-nilly on just any cache without taking into
|       consideration the semantics of what maybe being blown away. For
|       instance, some tables in Host MIB contain attributes whose values
|       are indices into other tables.  If a row is destroyed, clearly the
|       references to the row must be refreshed in some manner.
*/
{
CACHEROW        *new=NULL;      /* New CACHEROW instance to be created */
ULONG           i;              /* handy-dandy Index                   */


/* Zap storage associated each attribute entry (if any) */
for (i = 0; i < row->attrib_count; i += 1) {

    /* Blow off storage for attribute values that have malloc-ed storage */
    switch (row->attrib_list[i].attrib_type) {

        case CA_STRING:
            free( row->attrib_list[i].u.string_value );
            break;


        case CA_CACHE:
            /* Release the contents of the entire cache */
            DestroyTable( row->attrib_list[i].u.cache );

            /* Free the storage containing the cache
            free ( row->attrib_list[i].u.cache );
            break;

        
        case CA_NUMBER:
        case CA_COMPUTED:
        case CA_UNKNOWN:
            /* No malloced storage associated with these types */
        default:
           break;
        }
    }


/* Free the storage associated with the array of attributes */
free( row->attrib_list);

/* Free the storage for the row itself */
free( row );
}

/* AddTableRow - Adds a specific "row" into a cached "table" */
/* AddTableRow - Adds a specific "row" into a cached "table" */
/* AddTableRow - Adds a specific "row" into a cached "table" */

BOOL
AddTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEROW   *row,           /* Row to be added to .. */
             CACHEHEAD  *cache          /* this cache            */
              )

/*
|  EXPLICIT INPUTS:
|
|       "index" is index inserted into "row" before the
|       "row" is added to "cache".
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the row was successfully
|       added to the cache for the table.
|
|     On Failure:
|       Function returns FALSE, indicating that the row already
|       existed.
|
|  THE BIG PICTURE:
|
|       At startup time the subagent is busy populating the cache for
|       each table.  The rows in any cached table are inserted into
|       the cache by this function.
|
|  OTHER THINGS TO KNOW:
|
|       Code in this function presumes that the list (cache) is in sorted index
|       order.
|
|       Any change of organization of the linked list that constitutes the
|       cache will impact this function and "Find(Next)TableRow()".
|
*/
{
CACHEROW       **index_row;     /* Used for searching cache              */
                                /* NOTE: It always points at a cell that */
                                /*       points to the next list element */
                                /*       (if any is on the list).        */


/* Whip down the list until there is no "next" or "next" is "bigger" . . . */
for ( index_row = &cache->list;
      *index_row != NULL;
      index_row = &((*index_row)->next)
     ) {

    /* If this row MATCHES the to-be-inserted row: Error! */
    if ((*index_row)->index == index) {
        return ( FALSE );
        }

    /*
    | If next cache entry is "Greater Than" new index, then
    | "index_row" points to the cell that should be changed to insert
    | the new entry.
    */
    if ((*index_row)->index > index) {
        break;
        }

    /* Otherwise we should try for a "next" entry in the list */
    }


/*
| When we fall thru here "index_row" contains the address of the cell to
| change to add the new row into the cache (might be in the list-head, 
| might be in a list-entry)
*/
row->next = *index_row;   /* Put cache-list "next" into new row element */
*index_row = row;         /* Insert new row into the list               */

row->index = index;       /* Stick the index into the row entry itself  */

cache->list_count += 1;   /* Count another entry on the cache list      */


/* Successful insertion */
return (TRUE);
}

/* FindTableRow - Finds a specific "row" in a cached "table" */
/* FindTableRow - Finds a specific "row" in a cached "table" */
/* FindTableRow - Finds a specific "row" in a cached "table" */

CACHEROW *
FindTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEHEAD  *cache          /* Table cache to search */
              )

/*
|  EXPLICIT INPUTS:
|
|       "index" indicates which table row entry is desired
|       "cache" indicates the cache list to search for the desired row.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to the instance of a CACHEROW structure
|       for the desired row.
|
|     On any Failure:
|       Function returns NULL (indicating "no such entry" or "cache empty").
|
|  THE BIG PICTURE:
|
|       As the subagent runs, the "get" functions for the attributes that do
|       not "compute" their values dynamically must lookup cached values.
|
|       This function can be used by any "get" function that knows the
|       CACHEHEAD for it's table to find a specific row containing an
|       attribute value to be returned.
|
|  OTHER THINGS TO KNOW:
|
|       Code in this function presumes that the list is in sorted index
|       order (hence it gives up once encountering an entry whose index
|       is "too big").
|
|       Any change of organization of the linked list that constitutes the
|       cache will impact this function and "AddTableRow()".
|
*/
{
CACHEROW        *row=NULL;   /* Row instance to be returned, initially none */


/* Whip down the list until there is no next . . */
for ( row = cache->list; row != NULL; row = row->next ) {

    /* If this is "It": Return it */
    if (row->index == index) {
        return ( row );
        }

    /* If this is "Greater Than IT", it's not in the list: Return NULL */
    if (row->index > index) {
        return ( NULL );
        }

    /* Otherwise we should try for a "next" entry in the list */
    }


/*
| If we fall thru here we didn't find the desired entry because the cache
| list is either empty or devoid of the desired row.
*/
return (NULL);

}

/* FindNextTableRow - Finds Next row after a given "index" in a cache */
/* FindNextTableRow - Finds Next row after a given "index" in a cache */
/* FindNextTableRow - Finds Next row after a given "index" in a cache */

CACHEROW *
FindNextTableRow(
                 ULONG      index,          /* Index for row desired */
                 CACHEHEAD  *cache          /* Table cache to search */
                 )

/*
|  EXPLICIT INPUTS:
|
|       "index" indicates which table row entry AFTER WHICH the NEXT is
|               desired.  The "index" row need not exist (could be before
|               the first row or a missing row "in the middle", but
|               it may not specify a row that would be after the
|               last in the table.
|
|       "cache" indicates the cache list to search for the desired row.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to the instance of a CACHEROW structure
|       for the desired NEXT row.
|
|     On any Failure:
|       Function returns NULL (indicating "no such entry", "cache empty" or
|                              "end-of-cache" reached).
|
|  THE BIG PICTURE:
|
|       As the subagent runs, the "get-next" functions for the attributes 
|       that do not "compute" their values dynamically must lookup cached 
|       values.
|
|       This function can be used by any "FindNextInstance" function that
|       knows the CACHEHEAD for it's table to find the NEXT row following a
|       specific row containing an attribute value to be returned.
|
|  OTHER THINGS TO KNOW:
|
|       To get the first entry in a table, supply an ("illegal") index of 0.
|
|       Any change of organization of the linked list that constitutes the
|       cache will impact this function, "FindTableRow()" and "AddTableRow()".
|
*/
{
CACHEROW        *row=NULL;   /* Row instance to be returned, initially none */


/*
| If there is a non-empty cache and the input "index" is less than
| the first entry in the cache, simply return the first entry.
*/
if (   cache->list != NULL         /* If there is a non-empty cache . . . */
    && index < cache->list->index  /* AND index is LESS THAN first entry  */
    ) {

    /* Return the first entry in the table */
    return (cache->list);
    }

/* Whip down the list until there is no next . . */
for ( row = cache->list; row != NULL; row = row->next ) {

    /* If "index" specifies THIS ROW . . . */
    if (row->index == index) {
        return ( row->next );   /* Return NEXT (or NULL if no "next") */
        }

    /* If this is "Greater Than IT", "index" is not in the list */
    if (row->index > index) {
        return ( row  );        /* Return CURRENT, it is Greater than "index"*/
        }

    /* Otherwise we should try for a "next" entry in the list */
    }

/*
| If we fall thru here then the cache is empty or the "index" specifies
| a row after the last legal row.
*/
return (NULL);
}


#if defined(CACHE_DUMP)

/* PrintCache - Dumps for debugging the contents of a cache */
/* PrintCache - Dumps for debugging the contents of a cache */
/* PrintCache - Dumps for debugging the contents of a cache */

void
PrintCache(
           CACHEHEAD  *cache          /* Table cache to dump */
           )

/*
|  EXPLICIT INPUTS:
|
|       "cache" indicates the cache whose contents is to be dumped.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns.  It may be called recursively by a "Print-Row"
|       function.
|
|
|  THE BIG PICTURE:
|
|     For debugging only.
|
|  OTHER THINGS TO KNOW:
|
|     Define "CACHE_DUMP" at the top of "HMCACHE.H" to enable this debug
|     support.  You can change the file into which output goes by modifying
|     "DUMP_FILE", also in "HMCACHE.H".
|
*/

#define DO_CLOSE  \
   { if ((open_count -= 1) == 0) { fclose(OFILE); } }

{
CACHEROW        *row;                   /* Row instance to dump. */
UINT            i;                      /* Element counter       */
time_t          ltime;                  /* For debug message     */
static
UINT            open_count=0;         /* We can be called recursively */

/* Avoid a recursive open */
if (open_count == 0) {

    /* Open the debug log file */
    if ((Ofile=fopen(DUMP_FILE, "a+")) == NULL) {
        return;
        }

    /*
    | Put a time stamp into the debug file because we're opening for append.
    */
    time( &ltime);
    fprintf(OFILE, "=============== Open for appending: %s\n", ctime( &ltime ));
    }

open_count += 1;

if (cache == NULL) {
    fprintf(OFILE, "Call to PrintCache with NULL CACHEHEAD pointer.\n");

    DO_CLOSE;
    return;
    }

if (cache->print_row == NULL) {
    fprintf(OFILE,
            "Call to PrintCache with NULL CACHEHEAD Print-Routine pointer.\n");

    DO_CLOSE;
    return;
    }

/* Print a Title */
cache->print_row(NULL);

fprintf(OFILE, "Element Count: %d\n", cache->list_count);

/* For every row in the cache . . . */
for (row = cache->list, i = 0; row != NULL; row = row->next, i += 1) {

    fprintf(OFILE, "\nElement #%d, Internal Index %d,  at 0x%x:\n",
            i, row->index, row);

    cache->print_row(row);
    }

fprintf(OFILE, "======== End of Cache ========\n\n");

DO_CLOSE;

}

#endif  // defined(CACHE_DUMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hostmib.c ===
/*
 *  gendll.c v0.11   March 14, 1996
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995, 1996 DIGITAL EQUIPMENT CORPORATION              *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for plugging into the Windows NT Extendible
 *    Agent.  It contains the dll's main routine and the three exported SNMP
 *    routines.
 *
 *  Functions:
 *
 *    DllMain()
 *    SnmpExtensionInit()
 *    SnmpExtensionTrap()
 *    SnmpExtensionQuery()
 *
 *  Author:
 *    Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *    2/17/95
 *
 *  Revision History:
 *    6/26/95 KKF, register using Subroot_oid
 *    7/31/95 ags  readded above code + uncommented calls to SNMP_oidfree
 *    3/14/96 kkf, modified SNMPExtensionTrap
 */



// General notes:
//
// Microsoft's Extendible Agent for Windows NT is implemented by dynamically
// linking to Extension Agent DLLs that implement portions of the MIB.  These
// Extension Agents are configured in the Windows NT Registration Database.
// When the Extendible Agent Service is started, it queries the registry to
// determine which Extension Agent DLLs have been installed and need to be
// loaded and initialized.  The Extendible Agent invokes various DLL entry
// points (examples follow in this file) to request MIB queries and obtain
// Extension Agent generated traps.


// Necessary includes.

#include <windows.h>
#include <malloc.h>
#include <stdio.h>

#include <snmp.h>

//
// The file mib.h is a user supplied header file (could be from a code
// generator).  This file should contain the definition, macros, forward
// declarations, etc.  The file mib_xtrn.h contains the external
// declarations for the variable tables and classes composing this MIB.
//

#include "mib.h"
#include "mib_xtrn.h"


// Extension Agent DLLs need access to the elapsed time that the agent has
// been active.  This is implemented by initializing the Extension Agent
// with a time zero reference, and allowing the agent to compute elapsed
// time by subtracting the time zero reference from the current system time.
// This example Extension Agent implements this reference with dwTimeZero.

DWORD dwTimeZero = 0 ;
extern DWORD dwTimeZero ;

//
// Trap Queue
//

q_hdr_t trap_q = { NULL, NULL } ;

extern q_hdr_t trap_q ;  // make it global
HANDLE hTrapQMutex ;
extern HANDLE hTrapQMutex ;
HANDLE hEnabledTraps ;
extern HANDLE hEnabledTraps ;



/*
 *  DllMain
 *
 *    This is a standard Win32 DLL entry point.  See the Win32 SDK for more
 *    information on its arguments and their meanings.  This example DLL does
 *    not perform any special actions using this mechanism.
 *
 *  Arguments:
 *
 *  Results:
 *
 *  Side Effects:
 *
 */

BOOL WINAPI
DllMain( HANDLE hDll ,
         DWORD  dwReason ,
         LPVOID lpReserved )
{

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH :
        case DLL_PROCESS_DETACH :
        case DLL_THREAD_ATTACH :
        case DLL_THREAD_DETACH :
        default :
            break ;

    }

    return TRUE ;

} /* end of DllMain() (the DllEntryPoint) */



/*
 *  SnmpExtensionInit
 *
 *    Extension Agent DLLs provide the following entry point to coordinate the
 *    initializations of the Extension Agent and the Extendible Agent.  The
 *    Extendible Agent provides the Extension Agent with a time zero reference;
 *    and the Extension Agent provides the Extendible Agent with an Event
 *    handle for communicating occurence of traps, and an object identifier
 *    representing the root of the MIB subtree that the Extension Agent
 *    supports.
 *
 *    Traps support is determined by the user in the UserMibInit() routine.
 *    If a valid handle from CreateEvent() is returned in the argument
 *    hPollForTrapEvent, then traps have been implemented and the SNMP
 *    Extendible Agent will poll this Extension Agent to retrieve the traps
 *    upon notification through the SetEvent() routine.  Polling is done
 *    through the SnmpExtensionTrap() routine.  If NULL is returned in the
 *    argument hPollForTrapEvent, there are no traps.
 *
 *  Arguments:
 *
 *  Results:
 *
 */

BOOL WINAPI
SnmpExtensionInit( IN DWORD dwTimeZeroReference ,
                   OUT HANDLE *hPollForTrapEvent ,
                   OUT AsnObjectIdentifier *supportedView )
{

    // Record the time reference provided by the Extendible Agent.

    dwTimeZero = dwTimeZeroReference ;


    // Indicate the MIB view supported by this Extension Agent, an object
    // identifier representing the sub root of the MIB that is supported.

    *supportedView = Subroot_oid ; // NOTE! structure copy
//    *supportedView = *(class_info[ 0 ].oid) ; // NOTE! structure copy

    // Call the User's initialization routine

    if ( !UserMibInit( hPollForTrapEvent ) )
        return FALSE ;

    // Indicate that Extension Agent initialization was successful.

    return TRUE ;

} /* end of SnmpExtensionInit() */



/*
 *  SnmpExtensionTrap
 *
 *    Extension Agent DLLs provide the following entry point to communicate
 *    traps to the Extendible Agent.  The Extendible Agent will query this
 *    entry point when the trap Event (supplied at initialization time) is
 *    asserted, which indicates that zero or more traps may have occured.
 *    The Extendible Agent will repetedly call this entry point until FALSE
 *    is returned, indicating that all outstanding traps have been processed.
 *
 *  Arguments:
 *
 *  Results:
 *
 |=========================================================================
 | There are no Traps associated with the HostMIB.  Consequently this
 | routine is taken over and used to refresh the cached information
 | associated with SNMP attribute "hrProcessorLoad" (in "HRPROCES.C") thru
 | a call to function "hrProcessLoad_Refresh()" (also in "HRPROCES.C").
 |
 | This function is being entered because a timer has expired that was
 | initialized by code in "TrapInit()" (in "GENNT.C").  The timer automatically
 | resets itself.
 |
 | All the standard generated code is subsumed by a simple call to
 | "hrProcessLoad_Refresh()".
 */

BOOL WINAPI
SnmpExtensionTrap( OUT AsnObjectIdentifier *enterprise ,
                   OUT AsnInteger *genericTrap ,
                   OUT AsnInteger *specificTrap ,
                   OUT AsnTimeticks *timeStamp ,
                   OUT RFC1157VarBindList *variableBindings )
{
#if 0
    tcb_t *entry ;

    // Traps are process by processing the traps on the trap queue.
    // The Extendible Agent will call this routine upon the receipt of
    // the event on the handle passed back in the SnmpExtensionInit routine.
    // The Extendible Agent calls this return back as long as this routine
    // returns true.

    // acquire mutex for trap_q
    WaitForSingleObject( hTrapQMutex, INFINITE ) ;

    // Dequeue a trap entry

    QUEUE_REMOVE( trap_q, entry ) ;

    // release the mutex for trap_q
    ReleaseMutex( hTrapQMutex ) ;

    if (entry == NULL)
       return FALSE ;

    *enterprise = entry->enterprise ;  // note structure copy
    *genericTrap = entry->genericTrap ;
    *specificTrap = entry->specificTrap ;
    *timeStamp = entry->timeStamp ;
    *variableBindings = entry->varBindList ; // note structure copy
    free(entry) ;
    return TRUE ;
#endif

/*
|========================
| Special HostMIB code:
*/
    /* Re-fetch CPU statistics from kernel */
    hrProcessLoad_Refresh();

    /* Don't call again until the timer goes off again */
    return FALSE;

} /* end of SnmpExtensionTrap() */



/*
 *  SnmpExtensionQuery
 *
 *    Extension Agent DLLs provide the following entry point to resolve queries
 *    for MIB variables in their supported MIB view (supplied at initialization
 *    time).  The requestType is Get/GetNext/Set.
 *
 *  Arguments:
 *
 *  Results:
 *
 */


BOOL WINAPI
SnmpExtensionQuery( IN BYTE requestType ,
                    IN OUT RFC1157VarBindList *variableBindings ,
                    OUT AsnInteger *errorStatus ,
                    OUT AsnInteger *errorIndex )
{
    UINT index ;
    UINT *tmp ;
    UINT status ;


    // Iterate through the variable bindings list to resolve individual
    // variable bindings.

    for ( index = 0 ; index < variableBindings->len ; index++ )
    {
        *errorStatus = ResolveVarBind( &variableBindings->list[ index ] ,
                                       requestType ) ;


        // Test and handle case where Get Next past end of MIB view supported
        // by this Extension Agent occurs.  Special processing is required to
        // communicate this situation to the Extendible Agent so it can take
        // appropriate action, possibly querying other Extension Agents.

        if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
             requestType == MIB_ACTION_GETNEXT )
        {
            *errorStatus = SNMP_ERRORSTATUS_NOERROR ;

            // Modify variable binding of such variables so the OID points
            // just outside the MIB view supported by this Extension Agent.
            // The Extendible Agent tests for this, and takes appropriate
            // action.

            SNMP_oidfree( &variableBindings->list[ index ].name ) ;
            status = SNMP_oidcpy( &variableBindings->list[ index ].name, &Subroot_oid  ) ;
            if ( !status )
            {
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
            }
            else
            {
                tmp = variableBindings->list[ index ].name.ids ;
                (tmp[ SUBROOT_LENGTH - 1 ])++ ;
            }
        }


        // If an error was indicated, communicate error status and error
        // index to the Extendible Agent.  The Extendible Agent will ensure
        // that the origional variable bindings are returned in the response
        // packet.

        if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
        {
            *errorIndex = index + 1 ;
            goto Exit ;
        }
    }

Exit:

    // Indicate that Extension Agent processing was sucessfull.

    return SNMPAPI_NOERROR ;

} /* end of SnmpExtensionQuery() */

/* end of gendll.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hostmsmi.c ===
/*
 * mibtsmi.ntc v0.10
 *  hostmsmi.c
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the SMI envelopes around the callout to the
 *    developer's get and set routines.  Note that the developer can modify
 *    these routines to valid that the types actually conform to contraints
 *    for a given type.
 *
 *  Functions:
 *
 *    SMIGetxxx() and SMISetxxx() for each user defined type.
 *
 *  Author:
 *
 *	David Burns @ Webenable Inc
 *
 *  Date:
 *
 *	Thu Nov 07 16:38:30 1996
 *
 *  Revision History:
 *      generated with v0.10 stub
 *
 *      May 15, 1997 - To Microsoft: 4 changes of "malloc" to "SNMP_malloc"
 */

#include <snmp.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>

#include "smint.h"
#include "hostmsmi.h"
#include "mib.h"
#include "mib_xtrn.h"

/*
 *  SMIGetBoolean
 *    Boolean ::= INTEGER a truth value
 *    
 *    Encompasses the callouts to variables for the data type Boolean
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Boolean outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetBoolean() */

/*
 *  SMISetBoolean
 *    Boolean ::= INTEGER a truth value
 *    
 *    Encompasses the callouts to variables for the data type Boolean
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Boolean *invalue ;
    Boolean outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (Boolean *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetBoolean() */

/*
 *  SMIBuildBoolean
 *    Boolean ::= INTEGER a truth value
 *    
 *    Places the variable of datatype Boolean into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildBoolean() */


/*
 *  SMIGetKBytes
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 *    
 *    Encompasses the callouts to variables for the data type KBytes
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    KBytes outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetKBytes() */

/*
 *  SMISetKBytes
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 *    
 *    Encompasses the callouts to variables for the data type KBytes
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    KBytes *invalue ;
    KBytes outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (KBytes *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetKBytes() */

/*
 *  SMIBuildKBytes
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 *    
 *    Places the variable of datatype KBytes into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildKBytes() */


/*
 *  SMIGetINThrDeviceStatus
 *    INThrDeviceStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDeviceStatus
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDeviceStatus outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrDeviceStatus() */

/*
 *  SMISetINThrDeviceStatus
 *    INThrDeviceStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDeviceStatus
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDeviceStatus *invalue ;
    INThrDeviceStatus outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrDeviceStatus *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrDeviceStatus() */

/*
 *  SMIBuildINThrDeviceStatus
 *    INThrDeviceStatus ::= INTEGER 
 *    
 *    Places the variable of datatype INThrDeviceStatus into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrDeviceStatus() */


/*
 *  SMIGetINThrPrinterStatus
 *    INThrPrinterStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrPrinterStatus
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrPrinterStatus outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrPrinterStatus() */

/*
 *  SMISetINThrPrinterStatus
 *    INThrPrinterStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrPrinterStatus
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrPrinterStatus *invalue ;
    INThrPrinterStatus outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrPrinterStatus *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrPrinterStatus() */

/*
 *  SMIBuildINThrPrinterStatus
 *    INThrPrinterStatus ::= INTEGER 
 *    
 *    Places the variable of datatype INThrPrinterStatus into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrPrinterStatus() */


/*
 *  SMIGetINTAccess
 *    INTAccess ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTAccess
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTAccess outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINTAccess() */

/*
 *  SMISetINTAccess
 *    INTAccess ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTAccess
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTAccess *invalue ;
    INTAccess outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INTAccess *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINTAccess() */

/*
 *  SMIBuildINTAccess
 *    INTAccess ::= INTEGER 
 *    
 *    Places the variable of datatype INTAccess into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINTAccess() */


/*
 *  SMIGetINThrDiskStorageMedia
 *    INThrDiskStorageMedia ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDiskStorageMedia
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDiskStorageMedia outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrDiskStorageMedia() */

/*
 *  SMISetINThrDiskStorageMedia
 *    INThrDiskStorageMedia ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDiskStorageMedia
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDiskStorageMedia *invalue ;
    INThrDiskStorageMedia outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrDiskStorageMedia *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrDiskStorageMedia() */

/*
 *  SMIBuildINThrDiskStorageMedia
 *    INThrDiskStorageMedia ::= INTEGER 
 *    
 *    Places the variable of datatype INThrDiskStorageMedia into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrDiskStorageMedia() */


/*
 *  SMIGetINTSWType
 *    INTSWType ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTSWType
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTSWType outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINTSWType() */

/*
 *  SMISetINTSWType
 *    INTSWType ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTSWType
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTSWType *invalue ;
    INTSWType outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INTSWType *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINTSWType() */

/*
 *  SMIBuildINTSWType
 *    INTSWType ::= INTEGER 
 *    
 *    Places the variable of datatype INTSWType into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINTSWType() */


/*
 *  SMIGetINThrSWRunStatus
 *    INThrSWRunStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrSWRunStatus
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrSWRunStatus outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrSWRunStatus() */

/*
 *  SMISetINThrSWRunStatus
 *    INThrSWRunStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrSWRunStatus
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrSWRunStatus *invalue ;
    INThrSWRunStatus outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrSWRunStatus *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrSWRunStatus() */

/*
 *  SMIBuildINThrSWRunStatus
 *    INThrSWRunStatus ::= INTEGER 
 *    
 *    Places the variable of datatype INThrSWRunStatus into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrSWRunStatus() */


/*
 *  SMIGetDateAndTime
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 *    
 *    Encompasses the callouts to variables for the data type DateAndTime
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmio.c v 0.5
 */

UINT
SMIGetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    DateAndTime outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;  // dummy holder for future use

    outvalue.string = stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.string.length = outvalue.length ;
        VarBind->value.asnValue.string.stream =
//            malloc( outvalue.length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
            SNMP_malloc( outvalue.length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    outvalue.string ,
                    outvalue.length ) ;
            VarBind->value.asnType = ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    return result ;
} /* end of SMIGetDateAndTime() */

/*
 *  SMISetDateAndTime
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 *    
 *    Encompasses the callouts to variables for the data type DateAndTime
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result  = SNMP_ERRORSTATUS_NOERROR ;
    DateAndTime invalue ;
    DateAndTime outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;   // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result;
} /* end of SMISetDateAndTime() */

/*
 *  SMIBuildDateAndTime
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 *    
 *    Places the variable of datatype DateAndTime into a Variable Binding
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      invalue                   address of the data
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue )
{
    OctetString *svalue = (OctetString *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    VarBind->value.asnValue.string.length = svalue->length ;
    VarBind->value.asnValue.string.stream =
//        malloc( svalue->length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
        SNMP_malloc( svalue->length * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.string.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.string.stream ,
                svalue->string ,
                svalue->length ) ;
        VarBind->value.asnType = ASN_OCTETSTRING ;
        VarBind->value.asnValue.string.dynamic = TRUE ;
    }
    return status ;
} /* end of SMIBuildDateAndTime() */


/*
 *  SMIGetInternationalDisplayString
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 *    
 *    Encompasses the callouts to variables for the data type InternationalDisplayString
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmio.c v 0.5
 */

UINT
SMIGetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    InternationalDisplayString outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;  // dummy holder for future use

    outvalue.string = stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.string.length = outvalue.length ;
        VarBind->value.asnValue.string.stream =
//            malloc( outvalue.length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
            SNMP_malloc( outvalue.length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    outvalue.string ,
                    outvalue.length ) ;
            VarBind->value.asnType = ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    return result ;
} /* end of SMIGetInternationalDisplayString() */

/*
 *  SMISetInternationalDisplayString
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 *    
 *    Encompasses the callouts to variables for the data type InternationalDisplayString
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result  = SNMP_ERRORSTATUS_NOERROR ;
    InternationalDisplayString invalue ;
    InternationalDisplayString outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;   // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result;
} /* end of SMISetInternationalDisplayString() */

/*
 *  SMIBuildInternationalDisplayString
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 *    
 *    Places the variable of datatype InternationalDisplayString into a Variable Binding
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      invalue                   address of the data
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue )
{
    OctetString *svalue = (OctetString *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    VarBind->value.asnValue.string.length = svalue->length ;
    VarBind->value.asnValue.string.stream =
//        malloc( svalue->length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
        SNMP_malloc( svalue->length * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.string.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.string.stream ,
                svalue->string ,
                svalue->length ) ;
        VarBind->value.asnType = ASN_OCTETSTRING ;
        VarBind->value.asnValue.string.dynamic = TRUE ;
    }
    return status ;
} /* end of SMIBuildInternationalDisplayString() */


/*
 *  SMIGetProductID
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 *    
 *    Encompasses the callouts to variables for the data type ProductID
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmib.c v 0.5
 */

UINT
SMIGetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    UINT status ;
    ProductID outvalue ;
    Access_Credential access ;  // dummy holder for future use

    memset( &outvalue, '\0', sizeof( ProductID ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        status = SNMP_oidcpy( &VarBind->value.asnValue.object, &outvalue ) ;
        if ( !status )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            if ( outvalue.idLength != 0 )
                SnmpUtilOidFree( &outvalue ) ;
            VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;
        }
    }
    return result ;
} /* end of SMIGetProductID() */

/*
 *  SMISetProductID
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 *    
 *    Encompasses the callouts to variables for the data type ProductID
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    ProductID *invalue ;
    ProductID outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (ProductID *)&VarBind->value.asnValue.object ;
    memset( &outvalue, '\0', sizeof( ProductID ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    if ( outvalue.idLength != 0 )
        SnmpUtilOidFree( &outvalue ) ;
    return result ;
} /* end of SMISetProductID() */


/*
 *  SMIBuildProductID
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 *    
 *    Encompasses the callouts to variables for the data type ProductID
 *
 *  Arguments:
 *	VarBind                   pointer to the variable value pair
 *      invalue                   address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue )
{
    AsnObjectIdentifier *svalue = (AsnObjectIdentifier *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;
    UINT sts = TRUE ;

    sts = SNMP_oidcpy( &VarBind->value.asnValue.object ,
                       (AsnObjectIdentifier *)svalue ) ;
    if (!sts)
        status = SNMP_ERRORSTATUS_GENERR ;
    else
        VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;

    return status ;

} /* end of SMIBuildProductID() */


/* end of hostmsmi.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrdevent.c ===
/*
 *  HrDeviceEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrDeviceEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:41:55 1996
 *
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file     */
#include "HMCACHE.H"      /* Cache-related definitions           */
#include "HRDEVENT.H"     /* HrDevice Table  related definitions */
#include <stdio.h>        /* for sprintf                         */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
BOOL
Gen_SingleDevices( void );


#if defined(CACHE_DUMP)

/* debug_print_hrdevice - Prints a Row from HrDevice */
static void
debug_print_hrdevice(
                     CACHEROW     *row  /* Row in hrDiskStorage table */
                     );
#endif


/*
|==============================================================================
| Create the list-head for the HrDevice table cache.
|
| This list-head is globally accessible so the logic that loads the "sub" 
| tables can scan this cache for matches (among other reasons).
|
| (This macro is defined in "HMCACHE.H").
*/
CACHEHEAD_INSTANCE(hrDevice_cache, debug_print_hrdevice);


/*
|==============================================================================
| Initial Load Device
|
| This number is the index into hrDevice table for the entry that corresponds
| to the disk from which the system was initially loaded.
|
| This static location serves as "cache" for the value of 
| "HrSystemInitialLoadDevice" (serviced by code in "HRSYSTEM.C").
|
| It is initialized by function "Gen_Fixed_disks()" in module "HRDISKST.C"
| which is called by way of "Gen_HrDiskStorage_Cache()" invoked from this
| module.  It is during the scan of the fixed disks that we discover from which
| one the system booted.
*/
ULONG   InitLoadDev_index=0;


/*
 *  GetHrDeviceIndex
 *    A unique value for each device contained by the host.  The value for 
 *    each device must remain constant at least from one re-initi
 *    
 *    Gets the value for HrDeviceIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "A unique value for each device contained by the host.  The value for each
 | device must remain constant at least from one re-initialization of the agent
 | to the next re-initialization."
 | 
 | DISCUSSION:
 | 
 | As mentioned in the discussion for this table, all entries for this table
 | are derived from a local cache built at start-up time.  As a consequence the
 | maximum value of this attribute is fixed at SNMP service start-time.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.1.<instance>
 |                | | | |
 |                | | | *hrDeviceIndex
 |                | | *hrDeviceEntry
 |                | *hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDeviceIndex" value from this entry
*/
*outvalue = row->attrib_list[HRDV_INDEX].u.unumber_value;


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceIndex() */


/*
 *  GetHrDeviceType
 *    An indication of the type of device.
 *    
 *    Gets the value for HrDeviceType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceType
 | 
 |  ACCESS         SYNTAX
 |  read-only      OBJECT IDENTIFIER
 | 
 |   "An indication of the type of device.
 | 
 |   If this value is `hrDeviceProcessor { hrDeviceTypes3 }'
 |   then an entry exists in the hrProcessorTable
 |   which corresponds to this device.
 | 
 |   If this value is `hrDeviceNetwork { hrDeviceTypes 4}',
 |   then an entry exists in the hrNetworkTable
 |   which corresponds to this device.
 | 
 |   If this value is `hrDevicePrinter { hrDeviceTypes 5}',
 |   then an entry exists in the hrPrinterTable
 |   which corresponds to this device.
 | 
 |   If this value is `hrDeviceDiskStorage {hrDeviceTypes 6 }',
 |   then an entry exists in the
 |   hrDiskStorageTable which corresponds to this
 |   device."
 | 
 | DISCUSSION:
 | 
 | The list of registered device types (i.e. values that can be used in the
 | hrDeviceType attribute) are:
 | 
 |    hrDeviceOther             OBJECT IDENTIFIER ::= { hrDeviceTypes 1 }
 |    hrDeviceUnknown           OBJECT IDENTIFIER ::= { hrDeviceTypes 2 }
 |    hrDeviceProcessor         OBJECT IDENTIFIER ::= { hrDeviceTypes 3 }
 |    hrDeviceNetwork           OBJECT IDENTIFIER ::= { hrDeviceTypes 4 }
 |    hrDevicePrinter           OBJECT IDENTIFIER ::= { hrDeviceTypes 5 }
 |    hrDeviceDiskStorage       OBJECT IDENTIFIER ::= { hrDeviceTypes 6 }
 |    hrDeviceVideo             OBJECT IDENTIFIER ::= { hrDeviceTypes 10 }
 |    hrDeviceAudio             OBJECT IDENTIFIER ::= { hrDeviceTypes 11 }
 |    hrDeviceCoprocessor       OBJECT IDENTIFIER ::= { hrDeviceTypes 12 }
 |    hrDeviceKeyboard          OBJECT IDENTIFIER ::= { hrDeviceTypes 13 }
 |    hrDeviceModem             OBJECT IDENTIFIER ::= { hrDeviceTypes 14 }
 |    hrDeviceParallelPort      OBJECT IDENTIFIER ::= { hrDeviceTypes 15 }
 |    hrDevicePointing          OBJECT IDENTIFIER ::= { hrDeviceTypes 16 }
 |    hrDeviceSerialPort        OBJECT IDENTIFIER ::= { hrDeviceTypes 17 }
 |    hrDeviceTape              OBJECT IDENTIFIER ::= { hrDeviceTypes 18 }
 |    hrDeviceClock             OBJECT IDENTIFIER ::= { hrDeviceTypes 19 }
 |    hrDeviceVolatileMemory    OBJECT IDENTIFIER ::= { hrDeviceTypes 20 }
 |    hrDeviceNonVolatileMemory OBJECT IDENTIFIER ::= { hrDeviceTypes 21 }
 | 
 | (See discussion above for hrDeviceTable).
 |============================================================================
 | 1.3.6.1.2.1.25.3.1.n
 |                | | |
 |                | | * Identifying arc for type
 |                | *-hrDeviceTypes (OIDs specifying device types)
 |                *-hrDevice
 |
 | 1.3.6.1.2.1.25.3.2.1.2.<instance>
 |                | | | |
 |                | | | *-hrDeviceType
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrDevice_Cache()",
| and it's minions the cached value is the right-most arc we must return
| as the value.
|
| Hence whatever cache entry we retrieve, we tack the number retrieved
| from the cache for this attribute onto { hrDeviceType ... }.
*/
if ( (outvalue->ids = SNMP_malloc(10 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 10;


/*
| Load in the full hrDeviceType OID:
|
| 1.3.6.1.2.1.25.3.1.n
|                | | |
|                | | * Identifying arc for type
|                | *-hrDeviceTypes (OIDs specifying device types)
|                *-hrDevice
*/
outvalue->ids[0] = 1;
outvalue->ids[1] = 3;
outvalue->ids[2] = 6;
outvalue->ids[3] = 1;
outvalue->ids[4] = 2;
outvalue->ids[5] = 1;
outvalue->ids[6] = 25;
outvalue->ids[7] = 3;
outvalue->ids[8] = 1;

/* Cached Device Type indicator */
outvalue->ids[9] = row->attrib_list[HRDV_TYPE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceType() */


/*
 *  GetHrDeviceDesc
 *    A textual description of this device, including the device's 
 *    manufacturer and revision, and optionally, its serial number.
 *    
 *    Gets the value for HrDeviceDesc.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceDescr
 | 
 |  ACCESS         SYNTAX
 |  read-only      DisplayString (SIZE (0..64))
 | 
 | "A textual description of this device, including the device's manufacturer and
 | revision, and optionally, its serial number."
 | 
 | DISCUSSION:
 | 
 | (See discussion above for hrDeviceTable, the information source for this
 |  attribute depends on the device type).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.3.<instance>
 |                | | | |
 |                | | | *-hrDeviceDescr
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceDesc( 
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

outvalue->string = row->attrib_list[HRDV_DESCR].u.string_value;

/* "Truncate" here to meet RFC as needed*/
if ((outvalue->length = strlen(outvalue->string)) > 64) {
    outvalue->length = 64;
    }


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceDesc() */


/*
 *  GetHrDeviceID
 *    The product ID for this device.
 *    
 *    Gets the value for HrDeviceID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceID
 | 
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 | 
 | "The product ID for this device."
 | 
 |    ProductID ::= OBJECT IDENTIFIER
 | 
 |    "unknownProduct will be used for any unknown ProductID:
 |     unknownProduct OBJECT IDENTIFIER ::= { 0 0 }
 | 
 | DISCUSSION:
 | 
 | <POA-10> I anticipate always using "unknownProduct" as the value for this
 | attribute, as I can envision no systematic means of acquiring a registered
 | OID for all devices to be used as the value for this attribute.
 | 
 | RESOLVED >>>>>>>>
 | <POA-10> Returning an unknown Product ID is acceptable.
 | RESOLVED >>>>>>>>
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.4.<instance>
 |                | | | |
 |                | | | *-hrDeviceID
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0" 
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceID() */


/*
 *  GetHrDeviceStatus
 *    The current operational state of the device described by this row of the 
 *    table.  A value unknown (1) indicates that the current 
 *    
 *    Gets the value for HrDeviceStatus.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceStatus
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {unknown(1),running(2),warning(3),testing(4),
 |                          down(5)}
 | 
 | "The current operational state of the device described by this row of the
 | table.  A value unknown(1) indicates that the current state of the device is
 | unknown.  running(2) indicates that the device is up and running and that no
 | unusual error conditions are known.  The warning(3) state indicates that agent
 | has been informed of an unusual error condition by the operational software
 | (e.g., a disk device driver) but that the device is still 'operational'.  An
 | example would be high number of soft errors on a disk.  A value of testing(4),
 | indicates that the device is not available for use because it is in the
 | testing state.  The state of down(5) is used only when the agent has been
 | informed that the device is not available for any use."
 | 
 | DISCUSSION:
 | 
 | For those devices for which a driver can be queried for the device status,
 | this is done.  For all other circumstances, "unknown(1)" is returned.
 | 
 | (See discussion above for hrDeviceTable, the information source for this
 |  attribute depends on the device type).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.5.<instance>
 |                | | | |
 |                | | | *-hrDeviceStatus
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceStatus( 
        OUT INThrDeviceStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrDevice_Cache()",
| and its minions the cached value in the row just fetched above for
| the "hrDeviceType" attribute (indexed by our symbol "HRDV_TYPE") is the
| last arc in the OID that specifies the type of device for which we need
| to return status/errors.
|
| The scheme for returning status depends on the value of the type to
| dispatch to the correct code to handle that kind of device.
|
| Also, code that initializes the hrDevice cache for any given device
| has the option of storing in the "hidden context" attribute (accessed via 
| our symbol "HIDDEN_CTX") information needed to access that device.
| 
| For instance, the code that enters Printer devices into hrDevice (in
| function "Gen_HrPrinter_Cache()" in "HRPRINTE.C") stores a string in
| "HIDDEN_CTX" that is the printer name thereby allowing logic below to 
| re-open that printer to obtain status/errors.
|
*/
switch ( row->attrib_list[HRDV_TYPE].u.unumber_value ) {

    case HRDV_TYPE_LASTARC_PRINTER:
        /*  (In "HRPRINTE.C") */
        if (!COMPUTE_hrPrinter_status(row, (UINT *) outvalue)) {
            return SNMP_ERRORSTATUS_GENERR;
            }
        break;


    case HRDV_TYPE_LASTARC_PROCESSOR:
        /* Any processor in the table is running */
        *outvalue = 2;
        break;


    case HRDV_TYPE_LASTARC_DISKSTORAGE:
        /* Stored by Gen_hrDiskStorage_cache() */
        *outvalue =  row->attrib_list[HRDV_STATUS].u.unumber_value;
        break;


    case HRDV_TYPE_LASTARC_KEYBOARD:
    case HRDV_TYPE_LASTARC_POINTING:
        /* Any Keyboard or Mouse in the table is reasably presumed "running" */
        *outvalue = 2;  // "running"
        break;


    case HRDV_TYPE_LASTARC_PARALLELPORT:
    case HRDV_TYPE_LASTARC_SERIALPORT:
        *outvalue = 1;  // "Unknown"
        break;


    case HRDV_TYPE_LASTARC_OTHER:
    case HRDV_TYPE_LASTARC_UNKNOWN:
    case HRDV_TYPE_LASTARC_NETWORK:
    case HRDV_TYPE_LASTARC_VIDEO:
    case HRDV_TYPE_LASTARC_AUDIO:
    case HRDV_TYPE_LASTARC_COPROCESSOR:
    case HRDV_TYPE_LASTARC_MODEM:
    case HRDV_TYPE_LASTARC_TAPE:
    case HRDV_TYPE_LASTARC_CLOCK:
    case HRDV_TYPE_LASTARC_VOLMEMORY:
    case HRDV_TYPE_LASTARC_NONVOLMEMORY:

        *outvalue = 1;  // "Unknown"
        break;


    default:
        return SNMP_ERRORSTATUS_GENERR;

    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceStatus() */


/*
 *  GetHrDeviceErrors
 *    The number of errors detected on this device.  It should be noted that as 
 *    this object has a SYNTAX of Counter, that it does not 
 *    
 *    Gets the value for HrDeviceErrors.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceErrors
 |  ACCESS         SYNTAX
 |  read-only      Counter
 | 
 | "The number of errors detected on this device.  It should be noted that as
 | this object has a SYNTAX of Counter, that it does not have a defined initial
 | value.  However, it is recommended that this object be initialized to zero."
 | 
 | 
 | DISCUSSION:
 | 
 | For those devices for which a driver can be queried for the device errors,
 | this is done.  For all other circumstances, "0" is returned.
 | 
 | (See discussion above for hrDeviceTable, the information source for this
 |  attribute depends on the device type).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.6.<instance>
 |                | | | |
 |                | | | *-hrDeviceErrors
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceErrors( 
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrDevice_Cache()",
| and its minions the cached value in the row just fetched above for
| the "hrDeviceType" attribute (indexed by our symbol "HRDV_TYPE") is the
| last arc in the OID that specifies the type of device for which we need
| to return status/errors.
|
| The scheme for returning status depends on the value of the type to
| dispatch to the correct code to handle that kind of device.
|
| Also, code that initializes the hrDevice cache for any given device
| has the option of storing in the "hidden context" attribute (accessed via 
| our symbol "HIDDEN_CTX") information needed to access that device.
| 
| For instance, the code that enters Printer devices into hrDevice (in
| function "Gen_HrPrinter_Cache()" in "HRPRINTE.C") stores a string in
| "HIDDEN_CTX" that is the printer name thereby allowing logic below to 
| re-open that printer to obtain status/errors.
|
*/
switch ( row->attrib_list[HRDV_TYPE].u.unumber_value ) {

    case HRDV_TYPE_LASTARC_PRINTER:

        /*  (In "HRPRINTE.C") */
        if (!COMPUTE_hrPrinter_errors(row, outvalue)) {
            return SNMP_ERRORSTATUS_GENERR;
            }
        break;


    case HRDV_TYPE_LASTARC_PROCESSOR:

        /* If 'errors' ain't 0, odds are low you're gonna find out via SNMP */
        *outvalue = 0;
        break;


    case HRDV_TYPE_LASTARC_POINTING:
    case HRDV_TYPE_LASTARC_KEYBOARD:
    case HRDV_TYPE_LASTARC_PARALLELPORT:
    case HRDV_TYPE_LASTARC_SERIALPORT:
        /* 'errors' presumed 0 */
        *outvalue = 0;
        break;


    case HRDV_TYPE_LASTARC_OTHER:
    case HRDV_TYPE_LASTARC_UNKNOWN:
    case HRDV_TYPE_LASTARC_NETWORK:
    case HRDV_TYPE_LASTARC_DISKSTORAGE:
    case HRDV_TYPE_LASTARC_VIDEO:
    case HRDV_TYPE_LASTARC_AUDIO:
    case HRDV_TYPE_LASTARC_COPROCESSOR:
    case HRDV_TYPE_LASTARC_MODEM:
    case HRDV_TYPE_LASTARC_TAPE:
    case HRDV_TYPE_LASTARC_CLOCK:
    case HRDV_TYPE_LASTARC_VOLMEMORY:
    case HRDV_TYPE_LASTARC_NONVOLMEMORY:
        *outvalue = 0;
        break;

    default:
        return SNMP_ERRORSTATUS_GENERR;

    }

return SNMP_ERRORSTATUS_NOERROR ;
} /* end of GetHrDeviceErrors() */


/*
 *  HrDeviceEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDeviceEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRDEVICEENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRDEVICEENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRDEVICEENTRY_VAR_INDEX ] ;

        /*
        | For hrDeviceTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDeviceTable cache.
        | Check that here.
        */
	if ( FindTableRow(tmp_instance, &hrDevice_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDeviceEntryFindInstance() */



/*
 *  HrDeviceEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDeviceEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRDEVICEENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRDEVICEENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDeviceEntryFindNextInstance() */



/*
 *  HrDeviceEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrDeviceEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrDeviceEntryConvertInstance() */




/*
 *  HrDeviceEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrDeviceEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrDevice Table */
} /* end of HrDeviceEntryFreeInstance() */


/*
| End of Generated Code
*/

/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */
/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */
/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */

BOOL
Gen_HrDevice_Cache(
                    void
                    )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDevice table,
|       "HrDevice_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to 
|       populate the cache for the HrDevice table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
| A Row in the hrDeviceTable
| 
| "A (conceptual) entry for one device contained by the host.  As an example, an
| instance of the hrDeviceType object might be named hrDeviceType.3"
| 
|    HrDeviceEntry ::= SEQUENCE {
|            hrDeviceIndex           INTEGER,
|            hrDeviceType            OBJECT IDENTIFIER,
|            hrDeviceDescr           DisplayString,
|            hrDeviceID              ProductID,
|            hrDeviceStatus          INTEGER,
|            hrDeviceErrors          Counter
|        }
| 
| DISCUSSION:
| 
| This is the largest and most complicated table to populate.  The strategy for
| populating entries in this table is to execute a slug of code for each device
| type (in the list below) in an attempt to find all instances of that device
| type.  For some devices, the code uses standard Win32 API functions, for
| others it is clear that special-purpose code is needed to extract the relevant
| information from the "behind the scenes" (direct NT kernel inquiries).
| 
| This table is fully populated with respect to the other tables in the hrDevice
| group. The other tables are sparse tables augmenting only selected entries in
| hrDeviceTable.
| 
| The list of registered device types (i.e. values that can be used in the
| hrDeviceType attribute) are:
| 
|    hrDeviceOther             OBJECT IDENTIFIER ::= { hrDeviceTypes 1 }
|    hrDeviceUnknown           OBJECT IDENTIFIER ::= { hrDeviceTypes 2 }
|    hrDeviceProcessor         OBJECT IDENTIFIER ::= { hrDeviceTypes 3 }
|    hrDeviceNetwork           OBJECT IDENTIFIER ::= { hrDeviceTypes 4 }
|    hrDevicePrinter           OBJECT IDENTIFIER ::= { hrDeviceTypes 5 }
|    hrDeviceDiskStorage       OBJECT IDENTIFIER ::= { hrDeviceTypes 6 }
|    hrDeviceVideo             OBJECT IDENTIFIER ::= { hrDeviceTypes 10 }
|    hrDeviceAudio             OBJECT IDENTIFIER ::= { hrDeviceTypes 11 }
|    hrDeviceCoprocessor       OBJECT IDENTIFIER ::= { hrDeviceTypes 12 }
|    hrDeviceKeyboard          OBJECT IDENTIFIER ::= { hrDeviceTypes 13 }
|    hrDeviceModem             OBJECT IDENTIFIER ::= { hrDeviceTypes 14 }
|    hrDeviceParallelPort      OBJECT IDENTIFIER ::= { hrDeviceTypes 15 }
|    hrDevicePointing          OBJECT IDENTIFIER ::= { hrDeviceTypes 16 }
|    hrDeviceSerialPort        OBJECT IDENTIFIER ::= { hrDeviceTypes 17 }
|    hrDeviceTape              OBJECT IDENTIFIER ::= { hrDeviceTypes 18 }
|    hrDeviceClock             OBJECT IDENTIFIER ::= { hrDeviceTypes 19 }
|    hrDeviceVolatileMemory    OBJECT IDENTIFIER ::= { hrDeviceTypes 20 }
|    hrDeviceNonVolatileMemory OBJECT IDENTIFIER ::= { hrDeviceTypes 21 }
| 
| All of the foregoing types can be divided into two groups based on the
| approach needed to acquire information about them.  Information for the first
| group can be queried using Win32 API functions while the second group 
| requires special inquiry-code.
| 
| (1) Win32 Device-Types  Win32 Function Used
| ----------------------  -------------------
|    hrDeviceOther
|         Partitions      DeviceIoControl (IOCTL_GET_PARTITION_INFO)
| 
|    hrDeviceProcessor    GetSystemInfo
|    hrDevicePrinter      EnumPrinterDrivers
|    hrDeviceDiskStorage  QueryDosDevice/CreateFile (using physical drive access)
|    hrDeviceKeyboard     GetKeyboardType
|    hrDevicePointing     (Win32 function provides pointer-device button-count)
|
| 
| (2) Special-Inquiry Device-Types
| ---------------------------------
|    hrDeviceNetwork      Access is provided via special "mib2util" DLL
| 
|    hrDeviceParallelPort NtQuerySystemInformation(SYSTEM_DEVICE_INFORMATION)
|    hrDeviceSerialPort
| 
|    hrDeviceVideo        ??? NtQuerySystemInformation(SYSTEM_GDI_DRIVER_INFORMATION)
|    hrDeviceAudio        ???
|    hrDeviceTape         ???
| 
| 
| The following "devices" do not readily fall into either of the above groups
| and no attempt is made to recognize them:
| 
|    hrDeviceModem             OBJECT IDENTIFIER ::= { hrDeviceTypes 14 }
|    hrDeviceVolatileMemory    OBJECT IDENTIFIER ::= { hrDeviceTypes 20 }
|    hrDeviceNonVolatileMemory OBJECT IDENTIFIER ::= { hrDeviceTypes 21 }
|    hrDeviceCoprocessor       OBJECT IDENTIFIER ::= { hrDeviceTypes 12 }
|    hrDeviceClock             OBJECT IDENTIFIER ::= { hrDeviceTypes 19 }
| 
| 
| Other Implementation Details
| ----------------------------
| The bulk of the information for this table (and the associated sparse tables
| hrProcessorTable, hrNetworkTable, hrPrinterTable, hrDiskStorageTable,
| hrPartitionTable and hrFSTable) is acquired and stored in a local cache at the
| time the SNMP agent enrolls the DLL for the Host Resources MIB.  This strategy
| is designed to reduce the hit on system resources when requests are processed.
| The only information that is acquired dynamically (on a per SNMP request) is
| information for variables likely to be dynamic: Status and Error status.
| 
| One consequence of this strategy is that user-implemented changes to the
| system configuration (including changing printer drivers, or disk partition
| layout) will not be reported until the SNMP service is restarted.
| 
| 
|============================================================================
| 1.3.6.1.2.1.25.3.1.n
|                | | |
|                | | * Identifying arc for type
|                | *-hrDeviceTypes (OIDs specifying device types)
|                *-hrDevice
|
| 1.3.6.1.2.1.25.3.2.1....
|                | | |
|                | | *hrDeviceEntry
|                | *hrDeviceTable
|                *-hrDevice
|
*/
{


/*
|============================================================================
|
| Call the "Gen_*_cache()" functions for each of the "sub-tables" within
| the hrDevice table.
|
| Each of these functions is responsible for:
|
|       + populating the hrDevice cache with however many rows are called for
|         given the device(s) available
|
|       + creating and populating their own cache for the sub-table if
|         the sub-table needs a cache.  (If all the sub-table attributes
|         are "computed" on request, then there is no need for a separate 
|         sub-table cache).
*/

if (Gen_HrPrinter_Cache(HRDV_TYPE_LASTARC_PRINTER) == FALSE) {
    return ( FALSE );
    }

if (Gen_HrProcessor_Cache(HRDV_TYPE_LASTARC_PROCESSOR) == FALSE) {
    return ( FALSE );
    }

if (Gen_HrNetwork_Cache(HRDV_TYPE_LASTARC_NETWORK) == FALSE) {
    return ( FALSE );
    }

if (Gen_HrDiskStorage_Cache(HRDV_TYPE_LASTARC_DISKSTORAGE) == FALSE) {
    return ( FALSE );
    }


/*
|============================================================================
|
| Now handle the odd "one-off" devices for which potentially just a single 
| entry is made into the existing hrDevice table cache.
*/
if (Gen_SingleDevices() == FALSE) {
    return ( FALSE );
    }

#if defined(CACHE_DUMP)
PrintCache(&hrDevice_cache);
PrintCache(&hrDiskStorage_cache);
#endif


/*
| HrDevice cache generation complete.
*/
return ( TRUE );
}


/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */

BOOL
Gen_SingleDevices( void )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function creates a new row entry populated with all "static" cache-able
|       values for HrDevice table for each "one-off" device and returns TRUE.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       being populated.  This function handles populating hrDevice with
|       a row for each "single-type" device (such as keyboard).
|
|  OTHER THINGS TO KNOW:
|
|       Devices being added by this function are not associated with
|       sub-tables.
|
|       We handle:
|         + Keyboard "device"
|         + Pointing "device"
|         + Parallel and Serial Port "devices"
|
*/
{
UINT    key_status;             /* Value returned from GetKeyboardType()    */
UINT    button_count;           /* Mouse button count from GetSystemMetrics */
CHAR    msg[256];               /* (Big enough for constant strings below)  */
UINT    dev_number;

#define PHYS_SIZE 64
CHAR    phys_name[PHYS_SIZE];   /* Buffer where a string like "\\.C:" (for */
                                /*  example) is built for drive access.    */
HANDLE                  hdrv;   /* Handle to device                        */


/*
|==============================================================================
| Keyboard Device
|
| If we can get keyboard type... */
if ((key_status = GetKeyboardType(0)) != 0 ) {

    PCHAR       key_type;              /* Description string             */

    /* Select initial part of description string */
    switch (key_status) {
        case 1: key_type = "IBM PC/XT or compatible (83-key) keyboard"; break;
        case 2: key_type = "Olivetti \"ICO\" (102-key) keyboard"; break;
        case 3: key_type = "IBM PC/AT (84-key) or similar keyboard"; break;
        case 4: key_type = "IBM enhanced (101- or 102-key) keyboard"; break;
        case 5: key_type = "Nokia 1050 and similar keyboards"; break;
        case 6: key_type = "Nokia 9140 and similar keyboards"; break;
        case 7: key_type = "Japanese keyboard"; break;
        default: key_type = "Unknown keyboard"; break;
        }

    /* Build the full description string */
    sprintf(msg, "%s, Subtype=(%d)", key_type, GetKeyboardType(1));

    if (AddHrDeviceRow(HRDV_TYPE_LASTARC_KEYBOARD,      // Last Type OID arc
                       msg,                             // Description string
                       NULL,                            // No hidden context
                       CA_UNKNOWN) == NULL) {

        return ( FALSE );       /* Something blew */
        }
    }

/*
|==============================================================================
| Pointing Device
|
| If we can get Mouse Button count... */
if ((button_count = GetSystemMetrics(SM_CMOUSEBUTTONS)) != 0 ) {

    sprintf(msg, "%d-Buttons %s",
            button_count,
            (GetSystemMetrics(SM_MOUSEWHEELPRESENT)) ? " (with wheel)" : "");

 
    if (AddHrDeviceRow(HRDV_TYPE_LASTARC_POINTING,      // Last Type OID arc
                       msg,                             // Description string
                       NULL,                            // No hidden context
                       CA_UNKNOWN) == NULL) {

        return ( FALSE );       /* Something blew */
        }
    }


/*
|==============================================================================
| LPT Devices
|
| For every LPTx device we can open successfully. . .
*/
for (dev_number = 1; dev_number < 4; dev_number += 1) {

    /* Build it for device n: */
    sprintf(phys_name, "LPT%d:", dev_number);

    /*
    | Suppress any attempt by the system to talk to the user
    */
    SetErrorMode(SEM_FAILCRITICALERRORS);

    /* Attempt to get a handle using this physical name string */
    if ((hdrv = CreateFile(phys_name,           // Device
                               GENERIC_READ,    // Access mode
                               FILE_SHARE_READ, // Share Mode
                               NULL,            // Security
                               OPEN_EXISTING,   // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL             // Template file
                           )) != INVALID_HANDLE_VALUE) {

        /*
        | Ok, we managed to get ahold of it, we'll put it in the table.
        */
        if (AddHrDeviceRow(HRDV_TYPE_LASTARC_PARALLELPORT, // Last Type OID arc
                           phys_name,                      // Descr string
                           NULL,                           // No hidden context
                           CA_UNKNOWN) == NULL) {
            CloseHandle(hdrv); // Prefix bug 445177
            return ( FALSE );       /* Something blew */
            }

        CloseHandle(hdrv);
        }   /* if (we managed to "CreateFile" the device) */
    else {
        /*
        | Keep trucking if we couldn't open the device, but quit when we
        | hit this error.
        */
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            break;
            }
        }

    SetErrorMode(0);        /* Turn error suppression mode off */
    }   /* For each device */

/*
|==============================================================================
| COM Devices
|
| For every COMx device we can open successfully. . .
*/
for (dev_number = 1; dev_number <= 4; dev_number += 1) {

    /* Build it for device n: */
    sprintf(phys_name, "COM%d:", dev_number);

    /*
    | Suppress any attempt by the system to talk to the user
    */
    SetErrorMode(SEM_FAILCRITICALERRORS);

    /* Attempt to get a handle using this physical name string */
    if ((hdrv = CreateFile(phys_name,           // Device
                               GENERIC_READ,    // Access mode
                               FILE_SHARE_READ, // Share Mode
                               NULL,            // Security
                               OPEN_EXISTING,   // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL             // Template file
                           )) != INVALID_HANDLE_VALUE) {

        /*
        | Ok, we managed to get ahold of it, we'll put it in the table.
        */
        if (AddHrDeviceRow(HRDV_TYPE_LASTARC_SERIALPORT,   // Last Type OID arc
                           phys_name,                      // Descr string
                           NULL,                           // No hidden context
                           CA_UNKNOWN) == NULL) {

            return ( FALSE );       /* Something blew */
            }

        CloseHandle(hdrv);
        }   /* if (we managed to "CreateFile" the device) */
    else {
        /*
        | Keep trucking if we couldn't open the device, but quit when we
        | hit this error (skip share failures).
        */
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            break;
            }
        }

    SetErrorMode(0);        /* Turn error suppression mode off */
    }   /* For each device */
    return ( TRUE );    //--ft:09/28-- sundown cleanup
}

/* AddHrDeviceRow - Generate another Row Entry in HrDevice Table */
/* AddHrDeviceRow - Generate another Row Entry in HrDevice Table */
/* AddHrDeviceRow - Generate another Row Entry in HrDevice Table */

CACHEROW *
AddHrDeviceRow(
               ULONG   type_arc,       /* Last Arc value for OID for Type   */
               LPSTR   descr,          /* Description string                */
               void   *hidden_ctx,     /* If non-NULL: Hidden-context value */
               ATTRIB_TYPE  hc_type    /* Type of "hidden_ctx"              */
               )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number that is inserted as the right-most arc in
|       Object Identifier that is the cache entry for the hrDevicetype of the
|       device.
|
|       "descr" is a string pointer that is to be the cached value of
|       the hrDeviceDesc attribute.
|
|       "hidden_ctx" - If non-null, this is a pointer to the value to be
|       stored as the "Hidden Context" attribute in the new row.
|
|       "hc_type" is the type of "hidden_ctx" if hidden_ctx is non-null.
|
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDevice table,
|       "HrDevice_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function creates a new row entry populated with all "static" cache-able
|       values for HrDevice table and returns a pointer to the new row entry.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage" or other
|       internal logic error).
|
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in each of the "sub-hrDevicetable"
|       files to populate the cache for the HrDevice table for the rows
|       pertaining to a particular sub-table (hrProcessorTable, hrPrinterTable
|       etc).
|
|  OTHER THINGS TO KNOW:
|
|  The "hidden_ctx" argument provides an easy way for the caller to stash
|  a value useful for later run-time reference.  For instance, "GET" functions
|  for Printer devices may need a string that identifies the printer (for
|  a given row-entry) in order to lookup the current value of an SNMP 
|  attribute (like the current status).  So the "Hidden Context" attribute
|  may be set to a string that can be submitted to a Win32 function to obtain
|  the current status for the printer.
*/
{
static                          /* NOTE: "static" is a 'must'              */
ULONG     table_index=0;        /* HrDeviceTable index counter             */

CACHEROW *row;                  /* --> Cache structure for row-being built */


/*
| OK, the caller wants another row in the table, get a row-entry created.
*/
if ((row = CreateTableRow( HRDV_ATTRIB_COUNT ) ) == NULL) {
    return ( NULL );       // Out of memory
    }

/*
| Set up the standard-hrDevice attributes in the new row
*/

/* =========== hrDeviceIndex ==========*/
row->attrib_list[HRDV_INDEX].attrib_type = CA_NUMBER;
row->attrib_list[HRDV_INDEX].u.unumber_value = (table_index += 1) ;


/* =========== hrDeviceType ==========
|
| Some GET functions for "computed" attributes expect to be able to use
| the value of the "hrDeviceType" cache value stored below to dispatch
| to appropriate code based on the device type (using the last type-OID arc
| as the "switch" value).
*/
row->attrib_list[HRDV_TYPE].attrib_type = CA_NUMBER;
row->attrib_list[HRDV_TYPE].u.unumber_value = type_arc ;


/* =========== hrDeviceDescr ==========*/
row->attrib_list[HRDV_DESCR].attrib_type = CA_STRING;
if ( (row->attrib_list[HRDV_DESCR].u.string_value
      = ( LPSTR ) malloc(strlen(descr) + 1)) == NULL) {
    return ( NULL );       /* out of memory */
    }
strcpy(row->attrib_list[HRDV_DESCR].u.string_value, descr);


/*
| The rest of the standard hrDevice attributes are "computed" at run time
*/

/* =========== hrDeviceStatus ==========*/
row->attrib_list[HRDV_STATUS].attrib_type = CA_COMPUTED;


/* =========== hrDeviceErrors ==========*/
row->attrib_list[HRDV_ERRORS].attrib_type = CA_COMPUTED;

/*
|================================================================
| If they gave us a hidden-context attribute string, store it now.
*/
if (hidden_ctx != NULL) {

    switch (hc_type) {

        case CA_STRING:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_STRING;
            if ( (row->attrib_list[HIDDEN_CTX].u.string_value
                  = ( LPSTR ) malloc(strlen((LPSTR)hidden_ctx) + 1)) == NULL) {
                return ( NULL );       /* out of memory */
                }
            strcpy(row->attrib_list[HIDDEN_CTX].u.string_value, hidden_ctx);
            break;

        case CA_NUMBER:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_NUMBER;
            row->attrib_list[HIDDEN_CTX].u.unumber_value =
                                                      *((ULONG *) hidden_ctx);
            break;

        case CA_CACHE:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_CACHE;
            row->attrib_list[HIDDEN_CTX].u.cache = (CACHEHEAD *) hidden_ctx;
            break;

        case CA_UNKNOWN:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_UNKNOWN;
            break;

        default:
            return ( NULL );    /* Something wrong */
        }
    }
else {
    /* Show no "Hidden-Context" attribute for this row */
    row->attrib_list[HIDDEN_CTX].attrib_type = CA_UNKNOWN;
    row->attrib_list[HIDDEN_CTX].u.string_value = NULL;
    }

/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrDeviceTable.
*/
if (AddTableRow(row->attrib_list[HRDV_INDEX].u.unumber_value,  /* Index */
                row,                                           /* Row   */
                &hrDevice_cache                                /* Cache */
                ) == FALSE) {
    return ( NULL );       /* Internal Logic Error! */
    }

/*
| Meet caller's expectation of receiving a pointer to the new row.
*/
return ( row );
}

#if defined(CACHE_DUMP)

/* debug_print_hrdevice - Prints a Row from HrDevice */
/* debug_print_hrdevice - Prints a Row from HrDevice */
/* debug_print_hrdevice - Prints a Row from HrDevice */

static void
debug_print_hrdevice(
                     CACHEROW     *row  /* Row in hrDiskStorage table */
                     )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{
char    *type;          /* String representation of device type */

if (row == NULL) {
    fprintf(OFILE, "====================\n");
    fprintf(OFILE, "hrDevice Table Cache\n");
    fprintf(OFILE, "====================\n");
    return;
    }

fprintf(OFILE, "hrDeviceIndex. . . . . . . %d\n",
        row->attrib_list[HRDV_INDEX].u.unumber_value);

switch (row->attrib_list[HRDV_TYPE].u.unumber_value) {

    case 1: type = "Other"; break;
    case 2: type = "Unknown"; break;
    case 3: type = "Processor"; break;
    case 4: type = "Network"; break;
    case 5: type = "Printer"; break;
    case 6: type = "DiskStorage"; break;
    case 10: type = "Video"; break;
    case 11: type = "Audio"; break;
    case 12: type = "Coprocessor"; break;
    case 13: type = "Keyboard"; break;
    case 14: type = "Modem"; break;
    case 15: type = "ParallelPort"; break;
    case 16: type = "Pointing"; break;
    case 17: type = "SerialPort"; break;
    case 18: type = "Tape"; break;
    case 19: type = "Clock"; break;
    case 20: type = "VolatileMemory"; break;
    case 21: type = "NonVolatileMemory"; break;
    default: type = "<Unknown!>"; break;
    }

fprintf(OFILE, "hrDeviceType . . . . . . . %d (%s)\n",
        row->attrib_list[HRDV_TYPE].u.unumber_value, type);

fprintf(OFILE, "hrDeviceDescr. . . . . . . %s\n",
        row->attrib_list[HRDV_DESCR].u.string_value);

fprintf(OFILE, "hrDeviceStatus . . . . . . ");
switch (row->attrib_list[HRDV_STATUS].attrib_type) {

    case CA_STRING:
        fprintf(OFILE, "CA_STRING: \"%s\"\n",
                row->attrib_list[HRDV_STATUS].u.string_value);
        break;

    case CA_NUMBER:
        fprintf(OFILE, "CA_NUMBER: %d\n",
                row->attrib_list[HRDV_STATUS].u.unumber_value);
        break;

    case CA_UNKNOWN:
        fprintf(OFILE, "CA_UNKNOWN\n");
        break;

    case CA_COMPUTED:
        fprintf(OFILE, "CA_COMPUTED\n");
        break;

    default:
        fprintf(OFILE, "(INCORRECT)\n");
        break;
    }

fprintf(OFILE, "hrDeviceErrors . . . . . . ");
switch (row->attrib_list[HRDV_ERRORS].attrib_type) {

    case CA_STRING:
        fprintf(OFILE, "CA_STRING: \"%s\"\n",
                row->attrib_list[HRDV_ERRORS].u.string_value);
        break;

    case CA_NUMBER:
        fprintf(OFILE, "CA_NUMBER: %d\n",
                row->attrib_list[HRDV_ERRORS].u.unumber_value);
        break;

    case CA_UNKNOWN:
        fprintf(OFILE, "CA_UNKNOWN\n");
        break;

    case CA_COMPUTED:
        fprintf(OFILE, "CA_COMPUTED\n");
        break;

    default:
        fprintf(OFILE, "(INCORRECT)\n");
        break;
    }


/* Hidden Context */
fprintf(OFILE, "(HIDDEN CONTEXT) . . . . . ");

switch (row->attrib_list[HRDV_TYPE].u.unumber_value) {

    /*
    | What is stored in HIDDEN_CTX is hardwired for these types
    | of cache entries:
    */
    case 3: // "Processor"
        fprintf(OFILE, "CA_NUMBER: %d (Processor Number)\n",
                row->attrib_list[HIDDEN_CTX].u.unumber_value);
        break;


    case 4: // "Network"
        fprintf(OFILE, "CA_NUMBER: %d ( \"hrNetworkIfIndex\" value)\n",
                row->attrib_list[HIDDEN_CTX].u.unumber_value);
        break;


    case 5: // "Printer"
        fprintf(OFILE, "CA_STRING: \"%s\" ( \"OpenPrinter\" string)\n",
                row->attrib_list[HIDDEN_CTX].u.string_value);
        break;


    /* For this type, it varies */
    case 6: // "DiskStorage"

        switch (row->attrib_list[HIDDEN_CTX].attrib_type) {

            case CA_STRING:
                fprintf(OFILE, "CA_STRING: \"%s\"\n",
                        row->attrib_list[HIDDEN_CTX].u.string_value);
                break;

            case CA_NUMBER:
                fprintf(OFILE, "CA_NUMBER: %d\n",
                        row->attrib_list[HIDDEN_CTX].u.unumber_value);
                break;

            case CA_UNKNOWN:
                fprintf(OFILE, "CA_UNKNOWN\n");
                break;

            case CA_COMPUTED:
                fprintf(OFILE, "CA_COMPUTED\n");
                break;

            case CA_CACHE:
                fprintf(OFILE, "CA_CACHE @ 0x%x\n",
                        row->attrib_list[HIDDEN_CTX].u.cache);
                if (row->attrib_list[HIDDEN_CTX].u.cache != NULL) {
                    PrintCache(row->attrib_list[HIDDEN_CTX].u.cache);
                    }
                break;
            }

        break;


    case 10: // "Video"
    case 11: // "Audio"
    case 12: // "Coprocessor"
    case 13: // "Keyboard"
    case 14: // "Modem"
    case 15: // "ParallelPort"
    case 16: // "Pointing"
    case 17: // "SerialPort"
    case 18: // "Tape"
    case 19: // "Clock"
    case 20: // "VolatileMemory"
    case 21: // "NonVolatileMemory"
    case 2: // "Unknown"
    case 1: // "Other"
    default:
        fprintf(OFILE, "<None>\n");
        break;

    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrdiskst.c ===
/*
 *  HrDiskStorageEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrDiskStorageEntry.  Actual 
 *    instrumentation code is supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:43:17 1996
 *
 */


#include <windows.h>
#include <malloc.h>
#include <stdio.h>        /* For sprintf                        */
#include <string.h>
#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file    */
#include "HMCACHE.H"      /* Cache-related definitions          */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */
#include <winioctl.h>     /* For PARTITION_INFORMATION et. al.  */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */
static BOOL Gen_nonFixed_disks ( ULONG type_arc );

/* Gen_Fixed_disks - Scan for Fixed Disks */
static BOOL Gen_Fixed_disks ( ULONG type_arc );

/* ProcessPartitions - Process Partition Information into HrDevice Row */
static BOOL ProcessPartitions(
                  HANDLE        hdrv,   /* Fixed-Disk containing partitions */
                  CACHEROW     *dv_row, /* Row in hrDevice table for disk   */
                  CHAR         *pntdev  /* NT Device name for physical disk */
                  );

/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */
static CACHEROW *Process_DS_Row ( 
                ULONG       type_arc,  /* hrDeviceType last arc value        */
                ULONG       access,    /* hrDiskStorageAccess = readWrite(1) */
                ULONG       media,     /* hrDiskStorageMedia = floppyDisk(4) */
                ULONG       removable, /* hrDiskStorageRemovable = TRUE      */
                ULONG       capacityKB,/* hrDiskStorageCapacity, (kilobytes) */
                ULONG       status,    /* hrDeviceStatus = unknown(1)        */
                CHAR       *descr      /* hrDeviceDescr string               */
                );

/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */
static PCHAR
FindPartitionLabel(
                   CHAR   *pntdev, /* NT Device name for physical disk */
                   UINT   part_id  /* Partition Number (1-origined)    */
                   );

/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */
static void
debug_print_hrdiskstorage(
                          CACHEROW     *row  /* Row in hrDiskStorage table */
                          );

/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */
static void
debug_print_hrpartition(
                        CACHEROW     *row  /* Row in hrPartition table */
                        );

/*
|==============================================================================
| Create the list-head for the HrDiskStorage cache.
|
| (This macro is defined in "HMCACHE.H").
*/
CACHEHEAD_INSTANCE(hrDiskStorage_cache, debug_print_hrdiskstorage);




/*
 *  GetHrDiskStorageAccess
 *    An indication if this long-term storage device is readable and writable 
 *    or only readable.  This should reflect the media type, a
 *    
 *    Gets the value for HrDiskStorageAccess.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageAccess
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {readWrite(1), readOnly(2)}
 | 
 | "An indication if this long-term storage device is readable and writable or
 | only readable.  This should reflect the media type, any write-protect
 | mechanism, and any device configuration that affects the entire device."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.1.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageAccess
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageAccess" value from this entry
*/
*outvalue = row->attrib_list[HRDS_ACCESS].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageAccess() */


/*
 *  GetHrDiskStorageMedia
 *    An indication of the type of media used in this long-term storage device.
 *    
 *    Gets the value for HrDiskStorageMedia.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageMedia
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {other(1),unknown(2),hardDisk(3),floppyDisk(4),
 |                          opticalDiskROM(5),opticalDiskWORM(6),opticalDiskRW(7),
 |                          ramDisk(8)}
 | 
 | "An indication of the type of media used in this long-term storage device."
 | 
 | Discussion
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.2.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageMedia
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageMedia( 
        OUT INThrDiskStorageMedia *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageAccess" value from this entry
*/
*outvalue = row->attrib_list[HRDS_MEDIA].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageMedia() */


/*
 *  GetHrDiskStorageRemoveble
 *    Denotes whether or not the disk media may be removed from the drive.
 *    
 *    Gets the value for HrDiskStorageRemoveble.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageRemoveble
 | 
 |  ACCESS         SYNTAX
 |  read-only      Boolean
 | 
 | "Denotes whether or not the disk media may be removed from the drive."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.3.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageRemovable
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageRemoveble( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageRemovable" value from this entry
*/
*outvalue = row->attrib_list[HRDS_REMOVABLE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageRemoveble() */


/*
 *  GetHrDiskStorageCapacity
 *    The total size for this long-term storage device.
 *    
 *    Gets the value for HrDiskStorageCapacity.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageCapacity
 | 
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 | 
 | "The total size for this long-term storage device."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.4.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageCapacity
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageCapacity( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageCapacity" value from this entry
*/
*outvalue = row->attrib_list[HRDS_CAPACITY].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageCapacity() */


/*
 *  HrDiskStorageEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDiskStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRDISKSTORAGEENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRDISKSTORAGEENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRDISKSTORAGEENTRY_VAR_INDEX ] ;

        /*
        | For hrDiskStorage, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDiskStorage cache.
        | Check that here.
        |
        | Note that if there is a row there, there is also one in the
        | hrDevice table with the same index.
        */
	if ( FindTableRow(tmp_instance, &hrDiskStorage_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDiskStorageEntryFindInstance() */



/*
 *  HrDiskStorageEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDiskStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then 
    //  NOSUCHNAME is returned so that correct MIB rollover processing occurs.
    //  If this is a table, then the next instance is the one following the 
    //  current instance.
    //
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRDISKSTORAGEENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRDISKSTORAGEENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDiskStorage_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDiskStorageEntryFindNextInstance() */



/*
 *  HrDiskStorageEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrDiskStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrDiskStorageEntryConvertInstance() */




/*
 *  HrDiskStorageEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrDiskStorageEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrDiskStorageTable */
} /* end of HrDiskStorageEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */
/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */
/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */

BOOL
Gen_HrDiskStorage_Cache(
                    ULONG type_arc
                    )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that both caches have been fully
|       populated with all "static" cache-able values.  This function populates
|       not only the hrDevice table cache but the hrDiskStorage cache as well.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" ("HRDEVENT.C") 
|       to populate the cache for the HrDiskStorage table AND the hrDevice
|       Table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|       This function differs from all of the other corresponding sub-table
|       function instances in that this sub-table has its own cache, rather
|       than depending solely on that of the hrDevice table.
|
|       As a consequence, we don't need fancy logic in the FindInstance()
|       and FindNextInstance() functions to determine whether a particular
|       instance is valid: if it is, there is a row entry in the local
|       hrDiskStorage cache.
|
|       As another consequence, this function must load both caches with
|       data (and it must use the same "index" numbers in both caches
|       for each row entered).
|
|       ----
|
|       The strategy on getting all disks goes like this:
|
|       * Since the "\\.\PHYSICALDRIVEn" trick with "CreateFile" doesn't allow
|         access to floppies or CD-ROMs, we process these separately as a
|         first step.
|
|         + We presume "A:" and "B:" may be floppies and we look for them
|           explicitly.  Any found are presumed "readWrite" and Removable.
|           If a medium is present, we may get a full description plus an
|           accurate storage size, otherwise we just don't know for sure,
|           (DeviceIoControl for drive info fails if no disk is in the
|            floppy drive).
|
|         + We then scan all logical drive strings looking for instances of 
|           CD-ROM drives. Any found are presumed "readOnly" and Removable.
|           We can't obtain storage sizes even if a disk is present for these,
|           so storage is left at zero.
|
|       * Then the  "\\.\PHYSICALDRIVEn" trick is used to enumerate the real
|         hard disks, and real storage sizes are obtainable.
|
|============================================================================
| 1.3.6.1.2.1.25.3.6....
|                | |
|                | *-hrDiskStorageTable (the table)
|                *-hrDevice
*/
{

/*
| Do Floppies and CD-ROM drives (non-fixed disks)
*/
if (Gen_nonFixed_disks( type_arc ) == FALSE) {
    return ( FALSE );
    }

/*
| Do Fixed drives
*/
if (Gen_Fixed_disks( type_arc ) == FALSE) {
    return ( FALSE );
    }

/* Success */
return ( TRUE );
}

/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */
/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */
/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */

static BOOL
Gen_nonFixed_disks ( 
                    ULONG type_arc
                    )
/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the both cachees have been fully
|       populated with all non-Fixed disks.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|     Part I of hrDiskStorage cache population.
|
|  OTHER THINGS TO KNOW:
|
|     We scan using the list of Logical Disk drive strings from 
|     GetLogicalDriveStrings() formed up into UNC form, (e.g. "\\.\A:"
|     for "A:\" returned from GetLogicalDriveStrings()).
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
LPSTR   pDrvStrings;            /* --> allocated storage for drive strings */
LPSTR   pOriginal_DrvStrings;   /* (Needed for final deallocation          */
DWORD   DS_request_len;         /* Storage actually needed                 */
DWORD   DS_current_len;         /* Storage used on 2nd call                */

#define PHYS_SIZE 32
CHAR    phys_name[PHYS_SIZE];   /* Buffer where a string like "\\.C:" (for */
                                /*  example) is built for drive access.    */


/*
| We're going to call GetLogicalDriveStrings() twice, once to get the proper
| buffer size, and the second time to actually get the drive strings.
|
| The Bogus call.
*/
if ((DS_request_len = GetLogicalDriveStrings(2, temp)) == 0) {

    /* Request failed altogether, can't initialize */
    return ( FALSE );
    }

/*
| Grab enough storage for the drive strings plus one null byte at the end
*/

if ( (pOriginal_DrvStrings = pDrvStrings = malloc( (DS_request_len + 2) ) )
    == NULL) {

    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
    }

/* Go for all of the strings
|
| The Real Call.
*/
if ((DS_current_len = GetLogicalDriveStrings(DS_request_len, pDrvStrings))
    == 0) {

    /* Request failed altogether, can't initialize */
    free( pOriginal_DrvStrings );
    return ( FALSE );
    }

/*
|==============================================================================
| For each logical drive . . . 
*/
while ( strlen(pDrvStrings) > 0 ) {

    UINT        drivetype;      /* Type of the drive from "GetDriveType()"   */

    /*
    | Get the drive-type so we can decide whether it should participate in
    | this population effort.  We do only CD-ROMS and REMOVABLES.
    */
    drivetype = GetDriveType(pDrvStrings);

    /* Skip the stuff we don't want to look at */
    if ( drivetype != DRIVE_REMOVABLE && drivetype != DRIVE_CDROM ) {

        /* Step to next string, if any */
        pDrvStrings += strlen(pDrvStrings) + 1;

        continue;
        }


    /* If we have room in the buffer to build the handle-name string */
    if ((strlen(pDrvStrings) + strlen("\\\\.\\")) < PHYS_SIZE) {

        #define DESCR_BSZ 512
        CHAR                    d_buf[DESCR_BSZ]; /* Dsecription bld buff */
        HANDLE                  hdrv;       /* Handle to device           */
        DWORD                   bytes_out;  /* Bytes retnd into geo_info  */
        DISK_GEOMETRY           geo_info;   /* Geometry Info from drive   */
        char                   *mt;         /* Media Type */

        ULONG       access;     /* hrDiskStorageAccess = readWrite(1) */
        ULONG       media;      /* hrDiskStorageMedia = floppyDisk(4) */
        ULONG       removable;  /* hrDiskStorageRemovable = TRUE      */
        ULONG       capacityKB; /* hrDiskStorageCapacity, (kilobytes) */
        ULONG       status;     /* hrDeviceStatus = unknown(1)        */
        CHAR       *descr;      /* hrDeviceDescr string               */


        /*                         012345
        |  Build it for device A: "\\.\A:" */
        sprintf(phys_name, "\\\\.\\%2.2s", pDrvStrings);

        /*
        |  Set SNMP variables accordingly
        */
        if (drivetype != DRIVE_CDROM) {     /* Floppy */

            access = 1;          /* hrDiskStorageAccess = readWrite(1) */
            media = 4;           /* hrDiskStorageMedia = floppyDisk(4) */
            removable = TRUE;    /* hrDiskStorageRemovable = TRUE      */
            capacityKB = 0;      /* hrDiskStorageCapacity (unknown)    */
            status = 1;          /* hrDeviceStatus = unknown(1)        */
            descr = pDrvStrings; /* hrDeviceDescr, initial (e.g."A:\") */
            }

        else {                              /* CD-ROM */
            /*
            | We can't get much of anything about CD-ROMs except the fact
            | that there is one.  Capacity cannot be presumed as DVD is
            | now available and some drives read both CD-ROMs and DVD.
            */
            access = 2;          /* hrDiskStorageAccess = readOnly(2)  */
            media = 5;           /* hrDiskStorageMedia = opticalDiskROM(5)*/
            removable = TRUE;    /* hrDiskStorageRemovable = TRUE      */
            capacityKB = 0;      /* hrDiskStorageCapacity (unknown)    */
            status = 1;          /* hrDeviceStatus = unknown(1)        */
            descr = pDrvStrings; /* hrDeviceDescr, initial (e.g."D:\") */
            }


        /*
        | Suppress any attempt by the system to make the user put a volume in a
        | removable drive ("CreateFile" will just fail).
        */
        SetErrorMode(SEM_FAILCRITICALERRORS);

        /* Attempt to get a handle using this physical name string */
        hdrv = CreateFile(phys_name,                   // Device
                               GENERIC_READ,           // device query
                                                       // Share Mode
                               FILE_SHARE_READ   |
                               FILE_SHARE_WRITE,
                               NULL,                   // Security
                               OPEN_EXISTING,          // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL                    // Template file
                               );

        /* If we successfully opened the device . . . */
        if (hdrv != INVALID_HANDLE_VALUE) {

            /*
            | Device is Open.
            |
            | If it is NOT a CD-ROM, (ie, a floppy) its worth trying to get
            | DRIVE GEOMETRY (which will come back if there is a floppy in
            | the drive).
            */

            if (drivetype != DRIVE_CDROM) {     /* Floppy */

                /* ==========================================================
                |  IOCTL_DISK_GET_DRIVE_GEOMETRY
                |
                |  If we can get this, we get a better description and an
                |  accurate capacity value.
                */
                if (DeviceIoControl(hdrv,           // device handle
                                                    // IoControlCode (op-code)
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY,

                                    NULL,           // "input buffer"
                                    0,              // "input buffer size"
                                    &geo_info,      // "output buffer"
                                                    // "output buffer size"
                                    sizeof(DISK_GEOMETRY),

                                    &bytes_out,     // bytes written to geo_info
                                    NULL            // no Overlapped I/o
                                    )) {

                    /*
                    | Compute capacity
                    */
                    capacityKB = (ULONG)
                        ((geo_info.Cylinders.QuadPart * // 64 bits

                        (geo_info.TracksPerCylinder *   // 32 bits
                         geo_info.SectorsPerTrack *
                         geo_info.BytesPerSector)

                        ) / 1024);


                    /* hrDeviceStatus = running(2) */
                    status = 2;

                    switch ( geo_info.MediaType ) {

                        case  F5_1Pt2_512:    mt = "5.25, 1.2MB,  512 bytes/sector"; break;
                        case  F3_1Pt44_512:   mt = "3.5,  1.44MB, 512 bytes/sector"; break;
                        case  F3_2Pt88_512:   mt = "3.5,  2.88MB, 512 bytes/sector"; break;
                        case  F3_20Pt8_512:   mt = "3.5,  20.8MB, 512 bytes/sector"; break;
                        case  F3_720_512:     mt = "3.5,  720KB,  512 bytes/sector"; break;
                        case  F5_360_512:     mt = "5.25, 360KB,  512 bytes/sector"; break;
                        case  F5_320_512:     mt = "5.25, 320KB,  512 bytes/sector"; break;
                        case  F5_320_1024:    mt = "5.25, 320KB,  1024 bytes/sector"; break;
                        case  F5_180_512:     mt = "5.25, 180KB,  512 bytes/sector"; break;
                        case  F5_160_512:     mt = "5.25, 160KB,  512 bytes/sector"; break;
                        case  F3_120M_512:    mt = "3.5, 120M Floppy"; break;
                        case  F3_640_512:     mt = "3.5 ,  640KB,  512 bytes/sector"; break;
                        case  F5_640_512:     mt = "5.25,  640KB,  512 bytes/sector"; break;
                        case  F5_720_512:     mt = "5.25,  720KB,  512 bytes/sector"; break;
                        case  F3_1Pt2_512:    mt = "3.5 ,  1.2Mb,  512 bytes/sector"; break;
                        case  F3_1Pt23_1024:  mt = "3.5 ,  1.23Mb, 1024 bytes/sector"; break;
                        case  F5_1Pt23_1024:  mt = "5.25,  1.23MB, 1024 bytes/sector"; break;
                        case  F3_128Mb_512:   mt = "3.5 MO 128Mb   512 bytes/sector"; break;
                        case  F3_230Mb_512:   mt = "3.5 MO 230Mb   512 bytes/sector"; break;
                        case  F8_256_128:     mt = "8in,   256KB,  128 bytes/sector"; break;

                        default:
                        case  RemovableMedia:
                        case  FixedMedia:
                        case  Unknown:        mt = "Format is unknown"; break;
                        }

                    /* Format a better description if it'll all fit */
                    if ((strlen(pDrvStrings) + strlen(mt) + 1) < DESCR_BSZ ) {
                        sprintf(d_buf, "%s%s", pDrvStrings, mt);
                        descr = d_buf;
                        }
                    } /* If (we managed to get geometry information) */
                }

            CloseHandle(hdrv);

            }   /* if (we managed to "CreateFile" the device successfully) */

        /*
        | Create a row in HrDevice Table and a corresponding row in
        | hrDiskStorage sub-table.
        */
        if ( Process_DS_Row ( 
                             type_arc,  /* hrDeviceType last arc  */
                             access,    /* hrDiskStorageAccess    */
                             media,     /* hrDiskStorageMedia     */
                             removable, /* hrDiskStorageRemovable */
                             capacityKB,/* hrDiskStorageCapacity  */
                             status,    /* hrDeviceStatus         */
                             descr      /* hrDeviceDescr          */
                             ) == NULL) {

            /* Something blew */
            free( pOriginal_DrvStrings );
            return ( FALSE );
            }


        SetErrorMode(0);        /* Turn error suppression mode off */
        }   /* if (we managed to build a device name) */

    /* Step to next string, if any */
    pDrvStrings += strlen(pDrvStrings) + 1;
    }


free( pOriginal_DrvStrings );

/* Successful scan */
return ( TRUE );
}

/* Gen_Fixed_disks - Scan for Fixed Disks */
/* Gen_Fixed_disks - Scan for Fixed Disks */
/* Gen_Fixed_disks - Scan for Fixed Disks */

static BOOL
Gen_Fixed_disks ( 
                    ULONG type_arc
                    )
/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the both cachees have been fully
|       populated with all non-Fixed disks.  If the device from which the
|       system was booted is encountered, it's hrDevice index is set into
|       "InitLoadDev_index" (defined in "HRDEVENT.C").
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|     Part II of hrDiskStorage cache population.
|
|  OTHER THINGS TO KNOW:
|
|     We scan using the "\\.\PHYSICALDRIVEx" syntax permitted to
|     "CreateFile()".  CreateFile seems to allow opens only on disks
|     that are hard-fixed disks (no floppies, no CD-ROMS).
|
|     This function is also (while it is "at it") looking for the drive
|     from which the system was booted (in order to set a global value
|     (hrdevice table index) for the value of "InitLoadDev_index" (defined
|     in "HRDEVENT.C") which becomes the value of "HrSystemInitialLoadDevice".
*/
{
HANDLE  hdrv;                   /* Handle to device                    */
UINT    dev_number;             /* Current "x" in "\\.\PHYSICALDRIVEx" */

#undef  PHYS_SIZE
#define PHYS_SIZE 64
CHAR    phys_name[PHYS_SIZE];   /* Buffer where a string like          */
                                /*  "\\.PHYSICALDRIVE0"  (for example) */
                                /* is built for drive access.          */

DRIVE_LAYOUT_INFORMATION *dl;       /* Drive-layout pointer       */
#define BBSz 768
CHAR                    big[BBSz];  /* Big buffer for layout info */
DWORD                   bytes_out;  /* Bytes retnd into "big"     */

CHAR                    windir[MAX_PATH]; /* Current Windows Directory      */
CHAR                    ntdev[MAX_PATH];  /* NT Device Name for MSDOS drive */
CHAR                    pntdev[MAX_PATH]; /* NT Device Name for PHYSICALDRIVE*/

/*
|==============================================================================
| Compute the NT "device name" we expect is the device from which the
| system was booted.
|
| Strategy:
|
| - Obtain "current windows directory" and truncate to obtain just the MS-DOS
|   device name.
|
| - Do QueryDosDevice to get the underlying "NT Device Name", which will
|   include a "\PartitionX" on the end of it, where "X" is presumed to be
|   the 1-origined partition number.
|
| - Mangle the NT Device Name so that it sez "....\Partition0" (ie "partition
|   zero") which is the NT Device Name we expect to be associated with the
|   "\\.\PHYSICALDRIVEy" string we generate for each valid fixed disk below.
*/
/* If we can get the current Windows Directory */
if (GetWindowsDirectory(windir, MAX_PATH) != 0 ) {

    /* Truncate to just "C:" (or whatever) */
    windir[2] = '\0';

    /* Obtain the NT Device Name associated with MS-DOS logical drive */
    if (QueryDosDevice(windir, ntdev, MAX_PATH) != 0) {

        PCHAR   partition;

        /* If the string "\Partition" appears in this string */
        if ((partition = strstr(ntdev,"\\Partition")) != NULL) {

            /* Convert it to say "\Partition0" regardless */
            strcpy(partition, "\\Partition0");
            }
        else {
            /* Failure: Null-terminate so we fail gracefully */
            ntdev[0] = '\0';
            }
        }
    else {
        /* Failure: Null-terminate so we fail gracefully */
        ntdev[0] = '\0';
        }
    }
else {
    /* Failure: Null-terminate so we fail gracefully */
    ntdev[0] = '\0';
    }

/*
|==============================================================================
| For every physical device we can open successfully. . .
*/
for (dev_number = 0; ; dev_number += 1) {

    /* Build it for device n: "\\.\PHYSICALDRIVEn" */
    sprintf(phys_name, "\\\\.\\PHYSICALDRIVE%d", dev_number);

    /*
    | Suppress any attempt by the system to make the user put a volume in a
    | removable drive ("CreateFile" will just fail).
    */
    SetErrorMode(SEM_FAILCRITICALERRORS);

    /* Attempt to get a handle using this physical name string */
    if ((hdrv = CreateFile(phys_name,                  // Device
                               GENERIC_READ,           // Access
                                                       // Share Mode
                               FILE_SHARE_READ   |
                               FILE_SHARE_WRITE,
                               NULL,                   // Security
                               OPEN_EXISTING,          // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL             // Template file
                           )) != INVALID_HANDLE_VALUE) {

        ULONG       access;     /* hrDiskStorageAccess = readWrite(1) */
        ULONG       media;      /* hrDiskStorageMedia = floppyDisk(4) */
        ULONG       removable;  /* hrDiskStorageRemovable = TRUE      */
        ULONG       capacityKB; /* hrDiskStorageCapacity, (kilobytes) */
        ULONG       status;     /* hrDeviceStatus = unknown(1)        */
        CHAR       *descr;      /* hrDeviceDescr string               */
        DWORD       bytes_out;  /* Bytes retnd into geo_info          */
        DISK_GEOMETRY geo_info; /* Geometry Info from drive           */
        char       *mt;         /* Media Type                         */
        CACHEROW   *dv_row;     /* HrDevice table row created for disk*/


        /*
        | Device is Open, so we can presume it really exists, so it goes
        | into the hrDevice table.
        |
        | It is presumed to be a FIXED disk.
        */

        access = 1;          /* hrDiskStorageAccess = readWrite(1) */
        media = 3;           /* hrDiskStorageMedia = hardDisk(3)   */
        removable = FALSE;   /* hrDiskStorageRemovable = FALSE     */
        capacityKB = 0;      /* hrDiskStorageCapacity (unknown)    */
        status = 1;          /* hrDeviceStatus = unknown(1)        */
        descr = "Fixed Disk";/* hrDeviceDescr                      */


        /* ==========================================================
        |  IOCTL_DISK_GET_DRIVE_GEOMETRY
        |
        |  If we can get this, we get a better description and an
        |  accurate capacity value.
        */
        if (DeviceIoControl(hdrv,           // device handle
                                            // IoControlCode (op-code)
                            IOCTL_DISK_GET_DRIVE_GEOMETRY,
                            NULL,           // "input buffer"
                            0,              // "input buffer size"
                            &geo_info,      // "output buffer"
                                            // "output buffer size"
                            sizeof(DISK_GEOMETRY),
                            &bytes_out,     // bytes written to geo_info
                            NULL            // no Overlapped I/o
                            )) {

            /*
            | Compute capacity
            */
            capacityKB = (ULONG) 
                (geo_info.Cylinders.QuadPart *  // 64 bit

                 (geo_info.TracksPerCylinder *  // 32 bits
                  geo_info.SectorsPerTrack *
                  geo_info.BytesPerSector)

                 ) / 1024;

            /* hrDeviceStatus = running(2) */
            status = 2;

            switch ( geo_info.MediaType ) {

                case  FixedMedia:
                    break;

                default:
                    descr = "Unknown Media";
                }
            }


        /*
        | Create a row in HrDevice Table and a corresponding row in
        | hrDiskStorage sub-table.
        */
        if ((dv_row = Process_DS_Row (type_arc,  /* hrDeviceType last arc  */
                                      access,    /* hrDiskStorageAccess    */
                                      media,     /* hrDiskStorageMedia     */
                                      removable, /* hrDiskStorageRemovable */
                                      capacityKB,/* hrDiskStorageCapacity  */
                                      status,    /* hrDeviceStatus         */
                                      descr      /* hrDeviceDescr          */
                                      )
             ) == NULL) {

            /* Something blew */
            CloseHandle(hdrv);
            return ( FALSE );
            }

        /*
        | If it turns out this is the device from which the system was
        | booted, we need to return the index associated with the "dv_row"
        | row into "InitLoadDev_index" (defined in "HRDEVENT.C") to become
        | the value of "HrSystemInitialLoadDevice".
        |
        | See if the NT Device name associated with this "\\.\PHYSICALDRIVEx"
        | matches the value predicted for the system boot device.
        |
        |  If we can get the NT Device name for "PHYSICALDRIVEn" . . . */
        if (QueryDosDevice(&phys_name[4], pntdev, MAX_PATH) != 0 ) {

            /* If it matches the predicted value for boot device . . . */
            if ( strcmp(pntdev, ntdev) == 0) {

                /* Record the index for the current "physicaldrive" */
                InitLoadDev_index = dv_row->index;
                }
            }
        else {
            /*
            | Fail gracefully so things will still work in
            | "ProcessPartition()" below.
            */
            pntdev[0] = '\0';
            }

        /*
        | Create a hrPartition table (in the HrDevice Table row just created
        | for the disk) to represent the partitions on this fixed disk.
        */
        if ( ProcessPartitions( hdrv, dv_row, pntdev ) != TRUE ) {
            
            /* Something blew */
            CloseHandle(hdrv);
            return ( FALSE );
            }

        /* Fold up shop on this disk */
        CloseHandle(hdrv);
        } /* If we managed to "CreateFile()" the device */

    else {      /* Open failed... give up the scan */
        break;
        }

    SetErrorMode(0);        /* Turn error suppression mode off */
    }   /* For each device */

/* Successful scan */
return ( TRUE );
}

/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */
/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */
/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */

static CACHEROW *
Process_DS_Row ( 
                ULONG       type_arc,  /* hrDeviceType last arc value        */
                ULONG       access,    /* hrDiskStorageAccess = readWrite(1) */
                ULONG       media,     /* hrDiskStorageMedia = floppyDisk(4) */
                ULONG       removable, /* hrDiskStorageRemovable = TRUE      */
                ULONG       capacityKB,/* hrDiskStorageCapacity, (kilobytes) */
                ULONG       status,    /* hrDeviceStatus = unknown(1)        */
                CHAR       *descr      /* hrDeviceDescr string               */
                )
/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|       The rest of the arguments outline above are used to fill in
|       attribute values in both the hrDevice table row and the corresponding
|       hrDiskStorage row.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns pointer to row entry made to the hrDevice
|       table indicating that the both caches have been fully
|       populated with a new row.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage" or other
|       failure.).
|
|  THE BIG PICTURE:
|
|
|  OTHER THINGS TO KNOW:
|
|     This function contains common "row-insertion" code for the
|     Gen_Fixed_disks() and Gen_nonFixed_disks() functions.
*/
{
CACHEROW   *dv_row;     /* Row created in hrDevice table      */
CACHEROW   *ds_row;     /* Row created in hrDiskStorage table */


/*
|==========================
| Create hrDevice Row entry.
|
| Note we're initializing this as though the Hidden Context is always
| going to be a Cache pointer.  It will be for fixed-disks (that have
| Partition Tables), but for other disks the "NULL" signals "No Partition
| Table".
|
| For fixed-disks, the NULL is overwritten later (in "ProcessPartitions()")
| by a pointer to malloced storage containing an instance of  CACHEHEAD
| structure that carries the hrPartition Table for that fixed-disk).
*/
if ((dv_row = AddHrDeviceRow(type_arc,   // DeviceType OID Last-Arc
                             descr,      // Used as description
                             NULL,       // Hidden Ctx (none)
                             CA_CACHE    // Hidden Ctx type
                             )) == NULL ) {
    /* Something blew */
    return ( NULL );
    }

/* Re-Set hrDeviceStatus */
dv_row->attrib_list[HRDV_STATUS].attrib_type = CA_NUMBER;
dv_row->attrib_list[HRDV_STATUS].u.unumber_value = status;

/*
|===============================
| Create hrDiskStorage Row entry
|
| Note: The index is not recorded IN the row, but the entry
|       is "indexed": by the hrDevice row index.  This happens
|       in the AddTableRow() call below.
*/
if ((ds_row = CreateTableRow( HRDS_ATTRIB_COUNT ) ) == NULL) {
    return ( NULL );       // Out of memory
    }

/*
| Set the attribute values for this row
*/

/* =========== hrDiskStorageAccess ==========*/
ds_row->attrib_list[HRDS_ACCESS].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_ACCESS].u.unumber_value = access;

/* =========== hrDiskStorageAccess ==========*/
ds_row->attrib_list[HRDS_MEDIA].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_MEDIA].u.unumber_value = media;

/* =========== hrDiskStorageRemovable ==========*/
ds_row->attrib_list[HRDS_REMOVABLE].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_REMOVABLE].u.unumber_value = removable;

/* =========== hrDiskStorageCapacity ==========*/
ds_row->attrib_list[HRDS_CAPACITY].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_CAPACITY].u.unumber_value = capacityKB;


/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrDiskStorage Table..
|
| Use the same index that was used to specify the row inserted
| into the hrDevice table.
*/


if (AddTableRow(dv_row->attrib_list[HRDV_INDEX].u.unumber_value,  /* Index */
                ds_row,                                           /* Row   */
                &hrDiskStorage_cache                              /* Cache */
                ) == FALSE) {

    return ( NULL );       /* Internal Logic Error! */
    }

/* Processing complete */
return ( dv_row );
}

/* ProcessPartitions - Process Partition Information into HrDevice Row */
/* ProcessPartitions - Process Partition Information into HrDevice Row */
/* ProcessPartitions - Process Partition Information into HrDevice Row */

static BOOL
ProcessPartitions(
                  HANDLE        hdrv,   /* Fixed-Disk containing partitions */
                  CACHEROW     *dv_row, /* Row in hrDevice table for disk   */
                  CHAR         *pntdev  /* NT Device name for physical disk */
                  )
/*
|  EXPLICIT INPUTS:
|
|       "hdrv" - handle open to the fixed disk whose partitions are to be
|       enumerated.
|
|       "dv_row" - the HrDevice row into which the new hrPartition Table
|       is to go.
|
|       "pntdev" - NT Device Name for the physical disk we're dealing with.
|                  We need this to infer the logical device name for any
|                  active partition.
|
|  IMPLICIT INPUTS:
|
|       "HrFSTable_cache" - this gets scanned to allow "hrPartitionFSIndex"
|       to be filled in.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the Partition Information
|       for the given disk has been used to populate an hrPartition Table
|       instance.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage" or other
|       failure.).
|
|  THE BIG PICTURE:
|
|     This is the function that instantiates hrPartition tables.
|
|  OTHER THINGS TO KNOW:
|
|     Documentation at the top of the hrPartition Table file "HRPARTIT.C"
|     might be of interest.
|
|     BUG: As of build 1515, (and indeed in earlier versions of NT) the
|     "PartitionNumber" returned in response to DeviceIoControl opcode
|     "IOCTL_DISK_GET_DRIVE_LAYOUT" comes back as garbage.  Whatever
|     comes back is reported as the value of "hrPartitionID" (garbage or
|     not).  However when trying to fetch the Volume Label, as part of a
|     workaround attempt, we use the index generated in the code below 
|     in an attempt to approximate the proper Partition Number.
*/
{
#define DL_SIZE 1024
CHAR            dl_buf[DL_SIZE];  /* Drive-Layout info comes back here   */
UINT            i;                /* Handy-Dandy loop index              */
ULONG           table_index=0;    /* hrPartition Table row index counter */
DWORD           bytes_out;        /* Exactly how big "dl_buf" got filled */
DRIVE_LAYOUT_INFORMATION
                *dl;              /* Drive-layout pointer                */


/*
| See if we can grab the Drive's partition layout info.
*/
if (DeviceIoControl(hdrv,                         // device handle
                    IOCTL_DISK_GET_DRIVE_LAYOUT,  // IoControlCode (op-code)
                    NULL,                         // "input buffer"
                    0,                            // "input buffer size"
                    dl_buf,                       // "output buffer"
                    DL_SIZE,                      // "output buffer size"
                    &bytes_out,                   // bytes written to part_info
                    NULL                          // no Overlapped I/o
                    )) {

    CACHEHEAD *ch;

    /*
    | OK, there's presumed to be at least one partition: instantiate the
    | new partition table.
    |
    | Do this by creating its cache list-head structure.
    */
    dv_row->attrib_list[HIDDEN_CTX].attrib_type = CA_CACHE;
    if ((dv_row->attrib_list[HIDDEN_CTX].u.cache
         = ch = (CACHEHEAD *) malloc( sizeof(CACHEHEAD) )) == NULL) {
        return ( FALSE );
        }

    /*
    | Now initialize the contents properly.
    | (This should match what macro CACHEHEAD_INSTANCE does to a static
    |  instance).
    */
    ch->list_count = 0;
    ch->list = NULL;

    #if defined(CACHE_DUMP)
        ch->print_row = debug_print_hrpartition;
    #else
        ch->print_row = NULL;
    #endif


    /* Grab a dereferencable pointer to the Drive Layout info */
    dl = (DRIVE_LAYOUT_INFORMATION *) dl_buf;

    /* For every Partition "slot" returned . . . */
    for (i = 0; i < dl->PartitionCount; i += 1) {

        PARTITION_INFORMATION
                        *p;       /* Partition info thats going to go . . */
        CACHEROW        *row;     /* . . .into this row in HrPartition    */
        CACHEROW        *fs_row;  /* Row ptr in HrFSEntry table           */
        ULONG           last_arc; /* Last OID arc to use as FS-Type       */


        /* Grab a simple pointer to the next PARTITION_INFO to consider */
        p = &(dl->PartitionEntry[i]);

        /*
        | Note: It may be that not all of the PartitionEntry elements are
        |       "live".
        */
        if (p->PartitionType == PARTITION_ENTRY_UNUSED) {
            continue;
            }

        /*
        |===============================
        | Create hrPartition Row entry
        |
        | Note: This table is also "indexed" by the hrDevice row index
        */
        if ((row = CreateTableRow( HRPT_ATTRIB_COUNT ) ) == NULL) {
            return ( FALSE );       // Out of memory
            }

        /* =========== hrPartitionIndex ==========*/
        row->attrib_list[HRPT_INDEX].attrib_type = CA_NUMBER;
        row->attrib_list[HRPT_INDEX].u.unumber_value = (table_index += 1);


        /* =========== hrPartitionLabel ==========*/
        row->attrib_list[HRPT_LABEL].attrib_type = CA_STRING;

        /*
        | If there is an MS-DOS logical device letter assigned to this
        | partition. . .
        */
        if ( p->RecognizedPartition ) {

            /*
            | Go get the label, copy it to malloc'ed storage and return it.
            |
            | NOTE: Due to what seems like a bug, we're passing in "i+1" here
            |       rather than "p->PartitionNumber" (which seems to come
            |       back as garbage).  Clearly "i" is not a proper substitute
            |       in the long run.  See "OTHER THINGS TO KNOW" in the docs
            |       above for this function.
            */
            row->attrib_list[HRPT_LABEL].u.string_value =
                FindPartitionLabel(pntdev, (i+1));
            }
        else {
            /* No label if no MS-DOS device */
            row->attrib_list[HRPT_LABEL].u.string_value = NULL;
            }


        /* =========== hrPartitionID ==========
        |
        | In build 1515, this number is returned as garbage.  See
        | "OTHER THINGS TO KNOW" above.
        */
        row->attrib_list[HRPT_ID].attrib_type = CA_NUMBER;
        row->attrib_list[HRPT_ID].u.unumber_value = p->PartitionNumber;


        /* =========== hrPartitionSize ==========*/
        row->attrib_list[HRPT_SIZE].attrib_type = CA_NUMBER;
        row->attrib_list[HRPT_SIZE].u.unumber_value =
            p->PartitionLength.LowPart / 1024;

        /* =========== hrPartitionFSIndex ==========*/
        row->attrib_list[HRPT_FSINDEX].attrib_type = CA_NUMBER;

        /* Assume no file system mounted (that we can find) */
        row->attrib_list[HRPT_FSINDEX].u.unumber_value = 0;

        /* Find the first Row (if any) in the hrFSTable */
        if ((fs_row = FindNextTableRow(0, &hrFSTable_cache)) == NULL) {

            /* No file systems listed at all.. we're done */
            continue;
            }

        /*
        | Convert the Partition-Type into the "last-arc" value we use
        | to indicate what kind of file-system it is.
        */
        last_arc = PartitionTypeToLastArc( p->PartitionType );

        do {    /* Walk the hrFSEntry table */

            /*
            | If we found that the hrFSTable entry "fs_row" specifies a
            | file-system TYPE (by arc number) that matches what the current
            | partition's type number translates to ... we're done.
            */
            if (fs_row->attrib_list[HRFS_TYPE].u.unumber_value == last_arc) {
                row->attrib_list[HRPT_FSINDEX].u.unumber_value = fs_row->index;
                break;
                }

            /* Step to the next row */
            fs_row = GetNextTableRow(fs_row);
            }
               while (fs_row != NULL);

        /*
        |===============================
        |Now add the row to the table
        */
        if (AddTableRow(row->attrib_list[HRPT_INDEX].u.unumber_value,/* Index */
                        row,                                         /* Row   */
                        ch                                           /* Cache */
                        ) == FALSE) {

            return ( FALSE );       /* Internal Logic Error! */
            }

        } /* For each partition */

    }  /* If DeviceIoControl succeeded */


/* Partition Table complete */
return ( TRUE ) ;
}


/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */
/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */
/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */

static PCHAR
FindPartitionLabel(
                   CHAR   *pntdev, /* NT Device name for physical disk */
                   UINT   part_id  /* Partition Number (1-origined)    */
                   )
/*
|  EXPLICIT INPUTS:
|
|       "pntdev" - the NT Device Name (e.g. "\Device\Harddisk0\Partition0"
|       for the PHYSICAL device we're working on).
|
|       "part_id" - One-origined Partition number for which we hope to find
|       an MS-DOS Volume Label.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to malloc'ed storage containing the
|       MS-DOS Device Volume label (as returned by "GetVolumeInformation()").
|
|     On any Failure:
|       Function returns NULL (indicating "some kind of failure").
|
|  THE BIG PICTURE:
|
|     This "helper" function attempts to map an NT Device Name and a
|     one-origined Partition Number into a Volume Label for return as
|     the value of "hrPartitionLabel".
|
|  OTHER THINGS TO KNOW:
|
|  The algorithm is based on studying the output from "QueryDosDevices()"
|  and blithely assuming that we can "back-map" the string
|  "\Device\HarddiskX\PartitionY" for any Partition "Y" to the associated
|  MS-DOS Device.  There is precious little documentation that sez we can,
|  but we try.
|
|  Here's the approach:
|
|  * Using the NT Device Name for the "PHYSICALDRIVEn", we scrape the
|    "\Partition0" off the end of the name and replace it with "\PartitionY"
|    where "Y" is the Partition number passed as input to this function.
|    This is the "Generated Partition Name".
|
|    ("PHYSICALDRIVE" NT Device Names all seem to have "\Partition0" as
|    the terminating part of their name, and since the Win32 docs say that
|    Partition Numbers are "1-origined", this seems like a safe approach.)
|
|  * We generate a list of all the MS-DOS device names (using QueryDosDevices).
|
|  * We take each MS-DOS Device name and ask for it's current underlying
|    NT Device name mapping.
|
|    + If the first name mapping for any MS-DOS Device matches our
|      "Generated Partition Name", then the MS-DOS Device name is submitted
|      to "GetVolumeInformation()" and the Volume Label returned is used as
|      the "Partition Label".
*/
{
#define BIG_BUFF 1024
CHAR    gen_part_name[MAX_PATH+16];     /* "pntdev" is at most MAX_PATH    */
CHAR   *partition;                      /* Where "\Partition0" starts      */
CHAR    MSDOS_devices[BIG_BUFF];        /* List of MS-DOS device names     */
CHAR    NT_device[BIG_BUFF];            /* Mapping of NT device names      */
CHAR   *devname;                        /* Index for MSDOS_devices         */


/* Copy the NT Device Name for the Physical Drive */
strcpy(gen_part_name, pntdev);

/* Obtain a pointer to the beginning of "\Partition0" in this string */
if ((partition = strstr(gen_part_name, "\\Partition")) != NULL) {

    /*
    | Replace "\Partition0" with "\PartitionY" where "Y" is the supplied
    | partition number:  We've got the "Generated Partition Name".
    */
    sprintf(partition, "\\Partition%d", part_id);

    /*
    | Now ask for a list of MS-DOS Device Names
    */
    if ( QueryDosDevice(NULL, MSDOS_devices, BIG_BUFF) != 0) {

        /*
        | Swing down the list of MS-DOS device names and get the NT Device
        | name mappings.
        */
        for (devname = MSDOS_devices;
             *devname != '\0';
             devname += (strlen(devname)+1)) {

            /* Obtain the mappings for device "devname" */
            QueryDosDevice(devname, NT_device, BIG_BUFF);

            /* If the first mapping matches the Generated Partition Name */
            if (strcmp(gen_part_name, NT_device) == 0) {

                #define VOL_LABEL_SIZE 128
                CHAR    MSDOS_root[64];            /* Root Path Name       */
                CHAR    v_label[VOL_LABEL_SIZE];   /* Volume Label         */
                CHAR    *ret_label;                /* --> Malloced storage */
                DWORD   comp_len;                  /* Filename length      */
                DWORD   flags;


                /*
                | We're obliged to add a root-directory "\" to the MS-DOS
                | device name.
                */
                sprintf(MSDOS_root, "%s\\", devname);

                /* Fetch the Volume Information for the MS-DOS Device */
                if (GetVolumeInformation(
                                         MSDOS_root,       // MS-DOS root name
                                         v_label,          // Vol. Label buf
                                         VOL_LABEL_SIZE,   // vol. label size
                                         NULL,             // Serial Number
                                         &comp_len,        // FileName length
                                         &flags,           // Flags
                                         NULL,             // File System name
                                         0                 // Name buff. len
                                         ) != 0) {
                    /*
                    | Allocate storage to hold a returnable copy
                    */
                    if ( (ret_label = (CHAR *) malloc(strlen(v_label) + 1))
                        != NULL) {

                        /* Copy the label to malloced storage */
                        strcpy(ret_label, v_label);

                        return (ret_label);
                        }
                    else {
                        /* Out of storage */
                        return (NULL);
                        }
                    }
                else {
                    /* "GetVolumeInformation" failed on MSDOS name */
                    return (NULL);
                    }
                }
            }                    
        }
    }

return (NULL);  /* Other Failure */
}

#if defined(CACHE_DUMP)

/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */
/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */
/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */

static void
debug_print_hrdiskstorage(
                          CACHEROW     *row  /* Row in hrDiskStorage table */
                          )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=========================\n");
    fprintf(OFILE, "hrDiskStorage Table Cache\n");
    fprintf(OFILE, "=========================\n");
    return;
    }

fprintf(OFILE, "hrDiskStorageAccess. . . . %d ",
        row->attrib_list[HRDS_ACCESS].u.unumber_value);
switch (row->attrib_list[HRDS_ACCESS].u.unumber_value) {
    case 1: fprintf(OFILE, "(readWrite)\n");            break;
    case 2: fprintf(OFILE, "(readOnly)\n");             break;
    default:fprintf(OFILE, "(???)\n");                  break;
    }

fprintf(OFILE, "hrDiskStorageMedia . . . . %d ",
        row->attrib_list[HRDS_MEDIA].u.unumber_value);
switch (row->attrib_list[HRDS_MEDIA].u.unumber_value) {
    case 1: fprintf(OFILE, "(Other)\n");                break;
    case 2: fprintf(OFILE, "(Unknown)\n");              break;
    case 3: fprintf(OFILE, "(hardDisk)\n");             break;
    case 4: fprintf(OFILE, "(floppyDisk)\n");           break;
    case 5: fprintf(OFILE, "(opticalDiskROM)\n");       break;
    case 6: fprintf(OFILE, "(opticalDiskWORM)\n");      break;
    case 7: fprintf(OFILE, "(opticalDiskRW)\n");        break;
    case 8: fprintf(OFILE, "(ramDisk)\n");              break;
    default:fprintf(OFILE, "(???)\n");                  break;
    }

fprintf(OFILE, "hrDiskStorageRemovable . . %d ",
        row->attrib_list[HRDS_REMOVABLE].u.unumber_value);
switch (row->attrib_list[HRDS_REMOVABLE].u.unumber_value) {
    case 0: fprintf(OFILE, "(FALSE)\n"); break;
    case 1: fprintf(OFILE, "(TRUE)\n"); break;
    default: 
            fprintf(OFILE, "(???)\n"); break;
    }

fprintf(OFILE, "hrDiskStorageCapacity. . . %d (KBytes)\n",
        row->attrib_list[HRDS_CAPACITY].u.unumber_value);

}


/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */
/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */
/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */

static void
debug_print_hrpartition(
                        CACHEROW     *row  /* Row in hrPartition table */
                        )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "     =======================\n");
    fprintf(OFILE, "     hrPartition Table Cache\n");
    fprintf(OFILE, "     =======================\n");
    return;
    }


fprintf(OFILE, "     hrPartitionIndex . . . . . %d\n",
        row->attrib_list[HRPT_INDEX].u.unumber_value);

fprintf(OFILE, "     hrPartitionLabel . . . . . \"%s\"\n",
        row->attrib_list[HRPT_LABEL].u.string_value);

fprintf(OFILE, "     hrPartitionID. . . . . . . 0x%x\n",
        row->attrib_list[HRPT_ID].u.unumber_value);

fprintf(OFILE, "     hrPartitionSize. . . . . . %d\n",
        row->attrib_list[HRPT_SIZE].u.unumber_value);

fprintf(OFILE, "     hrPartitionFSIndex . . . . %d\n",
        row->attrib_list[HRPT_FSINDEX].u.unumber_value);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrdevent.h ===
/*
 *  File HRDEVENT.H
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module is contains definitions pertaining to the HostMIB
 *    hrDevice table... definitions needed by the "sub-tables" within
 *    the hrDevice table and the functions that deal with these tables.
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V1.0 - 04/28/97  D. D. Burns     Original Creation
 */

#ifndef hrdevent_h
#define hrdevent_h


/*
|==============================================================================
| hrDevice Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below (with the exception of "hrDeviceID" which is never cached
|    and handled exclusively by the GetHrDeviceID() function).
|
|    One special define is used in the same manner as the defines for the
|    real attributes to access a "hidden attribute" value which is never
|    returned as a consequence of an SNMP request, but is stored in the cache
|    to allow "computed" values to be obtained for some of the real attributes.
|
|    An example of a value in the HIDDEN_CTX attribute might be the string
|    needed to look up a value of hrDeviceStatus for this device or another
|    "computed" value in another associated table (such as hrPrintertable).
|
|    These symbols are used as C indices into the array of attributes within a
|    cached-row of the hrDevice Table.
|
*/
#define HRDV_INDEX    0    // hrDeviceIndex
#define HRDV_TYPE     1    // hrDeviceType
#define HRDV_DESCR    2    // hrDeviceDescr
                           // (hrDeviceID omitted)
#define HRDV_STATUS   3    // hrDeviceStatus
#define HRDV_ERRORS   4    // hrDeviceErrors
#define HIDDEN_CTX    5    // (Hidden Context Information).
                      //-->Add more here, change count below!
#define HRDV_ATTRIB_COUNT 6


/*
|==============================================================================
| hrPartition Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
|    These symbols appear in this file so that code in HRDISKST.C can
|    properly initialize rows in the HrPartition table while code in
|    HRPARTIT.C can reference them.
*/
#define HRPT_INDEX     0    // hrPartitionIndex
#define HRPT_LABEL     1    // hrPartitionLabel
#define HRPT_ID        2    // hrPartitionID
#define HRPT_SIZE      3    // hrPartitionSize
#define HRPT_FSINDEX   4    // hrPartitionFSIndex
                      //-->Add more here, change count below!
#define HRPT_ATTRIB_COUNT 5


/*
|==============================================================================
| hrDiskStorage Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
*/
#define HRDS_ACCESS    0    // hrDiskStorageAccess
#define HRDS_MEDIA     1    // hrDiskStorageMedia
#define HRDS_REMOVABLE 2    // hrDiskStorageRemovable
#define HRDS_CAPACITY  3    // hrDiskStorageCapacity
                      //-->Add more here, change count below!
#define HRDS_ATTRIB_COUNT 4


/*
|==============================================================================
| hrDevice Type OID Ending Arcs
|
|    RFC1514 specifies an object identifier "{ hrDeviceTypes }" to be used
|    as a prefix to the full OID that specifies a device's type in the
|    hrDevice table.  The symbols below specify the final arc "x" as in
|    "{ hrDeviceTypes x }" to be used for each device type.
|
|    You can't change these symbol values... we're just trying to be
|    mnemonic here.
*/
#define HRDV_TYPE_LASTARC_OTHER         1
#define HRDV_TYPE_LASTARC_UNKNOWN       2
#define HRDV_TYPE_LASTARC_PROCESSOR     3
#define HRDV_TYPE_LASTARC_NETWORK       4
#define HRDV_TYPE_LASTARC_PRINTER       5
#define HRDV_TYPE_LASTARC_DISKSTORAGE   6
#define HRDV_TYPE_LASTARC_VIDEO         10
#define HRDV_TYPE_LASTARC_AUDIO         11
#define HRDV_TYPE_LASTARC_COPROCESSOR   12
#define HRDV_TYPE_LASTARC_KEYBOARD      13
#define HRDV_TYPE_LASTARC_MODEM         14
#define HRDV_TYPE_LASTARC_PARALLELPORT  15
#define HRDV_TYPE_LASTARC_POINTING      16
#define HRDV_TYPE_LASTARC_SERIALPORT    17
#define HRDV_TYPE_LASTARC_TAPE          18
#define HRDV_TYPE_LASTARC_CLOCK         19
#define HRDV_TYPE_LASTARC_VOLMEMORY     20
#define HRDV_TYPE_LASTARC_NONVOLMEMORY  21


/*
|==============================================================================
| HRDEVICE-Related Function Prototypes
*/

/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */
BOOL Gen_HrPrinter_Cache( ULONG type_arc );       /* "HRPRINTE.C" */

/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */
BOOL COMPUTE_hrPrinter_status(
                         CACHEROW *row,
                         UINT     *outvalue
                         );                       /* "HRPRINTE.C" */

/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */
BOOL COMPUTE_hrPrinter_errors(
                         CACHEROW *row,
                         UINT     *outvalue
                         );                       /* "HRPRINTE.C" */

/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
BOOL Gen_HrProcessor_Cache( ULONG type_arc );     /* "HRPROCES.C" */

/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice NETWORK Table */
BOOL Gen_HrNetwork_Cache( ULONG type_arc );       /* "HRNETWOR.C" */

/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */
BOOL Gen_HrDiskStorage_Cache( ULONG type_arc );   /* "HRDISKST.C" */
extern CACHEHEAD hrDiskStorage_cache;    /* This cache is globally accessible */


/* AddrHrDeviceRow - Generate another Row Entry in HrDevice Table
|
|  Special purpose cache-row function just for hrDevice and related sub-tables.
|
|  Source is in "HRDEVENT.C".
*/
CACHEROW *
AddHrDeviceRow(
               ULONG   type_arc,       /* Last Arc value for OID for Type   */
               LPSTR   descr,          /* Description string                */
               void   *hidden_ctx,     /* If non-NULL: Hidden-context value */
               ATTRIB_TYPE  hc_type    /* Type of "hidden_ctx"              */
               );


#endif /* hrdevent_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrfsentr.c ===
/*
 *  HrFSEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrFSEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/18/97  D. D. Burns     Genned: Thu Nov 07 16:44:44 1996
 *    V1.01 - 06/17/97  D. D. Burns     Fix bug in Gen_HrFSTable_Cache() that
 *                                        precluded finding "hrFSStorageIndex"
 *                                        for drives w/volume labels.
 *	
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions */
#include "string.h"       /* For string manipulation in "Gen_Hrstorage_Cache"*/
#include "stdio.h"        /* For sprintf */
#include <winioctl.h>     /* For PARTITION_INFORMATION */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */
static void
debug_print_hrFSTable(
                      CACHEROW     *row  /* Row in hrFSTable table */
                      );


/*
|==============================================================================
| Create the list-head for the HrFStable cache.
|
| - Global so that code in "ProcessPartitions()" in "HRDISKST.C" can search
|   this cache.
|
| - This macro is defined in "HMCACHE.H".
*/
CACHEHEAD_INSTANCE(hrFSTable_cache, debug_print_hrFSTable);



/*
 *  GetHrFSIndex
 *    A unique value for each file system local to this host.  The value for 
 *    each file system must remain constant at least from one r
 *    
 *    Gets the value for HrFSIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "A unique value for each file system local to this host.  The value for each
 | file system must remain constant at least from one re-initialization of the
 | agent to the next re-initialization."
 | 
 | 
 | DISCUSSION:
 | 
 | An entry is generated for each drive (network or not) returned by
 | "GetLogicalDrives".
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.1.<instance>
 |                | | | |
 |                | | | *hrFSIndex
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSIndex" value from this entry
*/
*outvalue = row->attrib_list[HRFS_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSIndex() */


/*
 *  GetHrFSMountPoint
 *    The path name of the root of this file system.
 *    
 *    Gets the value for HrFSMountPoint.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSMountPoint
 | 
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 | 
 | "The path name of the root of this file system."
 | 
 | DISCUSSION:
 | 
 | The value of this attribute is the proper value returned by
 | "GetLogicalDriveStrings" for the selected entry.
 | 
 | RESOLVED >>>>>>>>
 | <POA-15>  Just return an empty string for the Mount Point variables.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.2.<instance>
 |                | | | |
 |                | | | *hrFSMountPoint
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| The cache has the device string in it, but we return the empty string
| per the spec.
*/
#if 1
    /* Return the empty string */
    outvalue->string = "";
    outvalue->length = 0;
#else
    /* Return the cached string */
    outvalue->string = row->attrib_list[HRFS_MOUNTPT].u.string_value;
    outvalue->length = strlen(outvalue->string);

    /* "Truncate" here to meet RFC as needed*/
    if ((outvalue->length = strlen(outvalue->string)) > 128) {
        outvalue->length = 128;
        }
#endif

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSMountPoint() */


/*
 *  GetHrFSRemoteMountPoint
 *    A description of the name and/or address of the server that this file 
 *    system is mounted from.  This may also include parameters 
 *    
 *    Gets the value for HrFSRemoteMountPoint.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSRemoteMountPoint
 | 
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 | 
 | "A description of the name and/or address of the server that this file system
 | is mounted from.  This may also include parameters such as the mount point on
 | the remote file system.  If this is not a remote file system, this string
 | should have a length of zero."
 | 
 | DISCUSSION:
 | 
 | <POA-15> The starting point for deriving this attribute's value is the logical
 | drive name, which would already be known to represent a network drive.  I can
 | find no Win32 API function that maps a network logical drive to it's server.
 | 
 | RESOLVED >>>>>>>>
 | <POA-15>  Just return an empty string for the Mount Point variables.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.3.<instance>
 |                | | | |
 |                | | | *hrFSRemoteMountPoint
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSRemoteMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/* Return the empty string */
outvalue->string = "";
outvalue->length = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSRemoteMountPoint() */


/*
 *  GetHrFSType
 *    The value of this object identifies the type of this file system.
 *    
 *    Gets the value for HrFSType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSType
 | 
 |  ACCESS         SYNTAX
 |  read-only      OBJECT IDENTIFIER
 | 
 | "The value of this object identifies the type of this file system."
 | 
 | DISCUSSION:
 | 
 |    -- Registration for some popular File System types,
 |    -- for use with hrFSType.
 | 
 |    hrFSTypes               OBJECT IDENTIFIER ::= { hrDevice 9 }
 | 
 |    hrFSOther               OBJECT IDENTIFIER ::= { hrFSTypes 1 }
 |    hrFSUnknown             OBJECT IDENTIFIER ::= { hrFSTypes 2 }
 |    hrFSBerkeleyFFS         OBJECT IDENTIFIER ::= { hrFSTypes 3 }
 |    hrFSSys5FS              OBJECT IDENTIFIER ::= { hrFSTypes 4 }
 |    -- DOS
 |    hrFSFat                 OBJECT IDENTIFIER ::= { hrFSTypes 5 }
 |    -- OS/2 High Performance File System
 |    hrFSHPFS                OBJECT IDENTIFIER ::= { hrFSTypes 6 }
 |    --  Macintosh Hierarchical File System
 |    hrFSHFS                 OBJECT IDENTIFIER ::= { hrFSTypes 7 }
 | 
 | 
 |    -- Macintosh File System
 |    hrFSMFS                 OBJECT IDENTIFIER ::= { hrFSTypes 8 }
 |    -- Windows NT
 |    hrFSNTFS                OBJECT IDENTIFIER ::= { hrFSTypes 9 }
 |    hrFSVNode               OBJECT IDENTIFIER ::= { hrFSTypes 10 }
 |    hrFSJournaled           OBJECT IDENTIFIER ::= { hrFSTypes 11 }
 |    -- CD File systems
 |    hrFSiso9660             OBJECT IDENTIFIER ::= { hrFSTypes 12 }
 |    hrFSRockRidge           OBJECT IDENTIFIER ::= { hrFSTypes 13 }
 | 
 |    hrFSNFS                 OBJECT IDENTIFIER ::= { hrFSTypes 14 }
 |    hrFSNetware             OBJECT IDENTIFIER ::= { hrFSTypes 15 }
 |    -- Andrew File System
 |    hrFSAFS                 OBJECT IDENTIFIER ::= { hrFSTypes 16 }
 |    -- OSF DCE Distributed File System
 |    hrFSDFS                 OBJECT IDENTIFIER ::= { hrFSTypes 17 }
 |    hrFSAppleshare          OBJECT IDENTIFIER ::= { hrFSTypes 18 }
 |    hrFSRFS                 OBJECT IDENTIFIER ::= { hrFSTypes 19 }
 |    -- Data General
 |    hrFSDGCFS               OBJECT IDENTIFIER ::= { hrFSTypes 20 }
 |    -- SVR4 Boot File System
 |    hrFSBFS                 OBJECT IDENTIFIER ::= { hrFSTypes 21 }
 | 
 | Win32 API function "GetVolumeInformation" can provide us with the 
 | information needed to select the correct OID for this attribute's value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.9.n
 |                | | |
 |                | | *-Type indicator
 |                | *-hrFSTypes
 |                *-hrDevice
 |
 | 1.3.6.1.2.1.25.3.8.1.4.<instance>
 |                | | | |
 |                | | | *hrFSType
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrFSTable_Cache()",
| the cached value is the right-most arc we must return as the value.
|
| Hence whatever cache entry we retrieve, we tack the number retrieved
| from the cache for this attribute onto { hrFSTypes ... }.
*/
if ( (outvalue->ids = SNMP_malloc(10 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 10;


/*
| Load in the full hrFSType OID:
|
| 1.3.6.1.2.1.25.3.9.n
|                | | |
|                | | *-Type indicator
|                | *-hrFSTypes
|                *-hrDevice
*/
outvalue->ids[0] = 1;
outvalue->ids[1] = 3;
outvalue->ids[2] = 6;
outvalue->ids[3] = 1;
outvalue->ids[4] = 2;
outvalue->ids[5] = 1;
outvalue->ids[6] = 25;
outvalue->ids[7] = 3;
outvalue->ids[8] = 9;

/* Cached FS Type indicator */
outvalue->ids[9] = row->attrib_list[HRFS_TYPE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSType() */


/*
 *  GetHrFSAccess
 *    An indication if this file system is logically configured by the 
 *    operating system to be readable and writable or only readable. 
 *    
 *    Gets the value for HrFSAccess.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSAccess
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {readWrite(1),readOnly(2)}
 | 
 | "An indication if this file system is logically configured by the operating
 | system to be readable and writable or only readable.  This does not represent
 | any local access-control policy, except one that is applied to the file system
 | as a whole."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "GetVolumeInformation" can provide us with the information
 | needed to select the correct OID for this attribute's value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.5.<instance>
 |                | | | |
 |                | | | *hrFSAccess
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSAccess" value from this entry
*/
*outvalue = row->attrib_list[HRFS_ACCESS].u.unumber_value;


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSAccess() */


/*
 *  GetHrFSBootable
 *    A falg indicating whether this file system is bootable.
 *    
 *    Gets the value for HrFSBootable.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSBootable
 | 
 |  ACCESS         SYNTAX
 |  read-only      Boolean
 | 
 | "A flag indicating whether this file system is bootable."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "CreatFile" and DeviceIoControlcan provide us with the
 | information needed to select the correct OID for this attribute's value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.6.<instance>
 |                | | | |
 |                | | | *hrFSBootable
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSBootable( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSBootable" value from this entry
*/
*outvalue = row->attrib_list[HRFS_BOOTABLE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSBootable() */


/*
 *  GetHrFSStorageIndex
 *    The index of the hrStorageEntry that represents information about this 
 *    file system.  If there is no such information available, 
 *    
 *    Gets the value for HrFSStorageIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSStorageIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 | 
 | "The index of the hrStorageEntry that represents information about this file
 | system.  If there is no such information available, then this value shall be
 | zero.  The relevant storage entry will be useful in tracking the percent usage
 | of this file system and diagnosing errors that may occur when it runs out of
 | space."
 | 
 | DISCUSSION:
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.7.<instance>
 |                | | | |
 |                | | | *hrFSStorageIndex
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSStorageIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSStorageIndex" value from this entry
*/
*outvalue = row->attrib_list[HRFS_STORINDX].u.unumber_value;


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSStorageIndex() */


/*
 *  GetHrFSLastFullBackupDate
 *    The last date at which this complete file system was copied to another 
 *    storage device for backup.  This information is useful fo
 *    
 *    Gets the value for HrFSLastFullBackupDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSLastFullBackupDate
 | 
 |  ACCESS         SYNTAX
 |  read-write     DateAndTime
 | 
 | "The last date at which this complete file system was copied to another
 | storage device for backup.  This information is useful for ensuring that
 | backups are being performed regularly.  If this information is not known, then
 | this variable shall have the value corresponding to January 1, year 0000,
 | 00:00:00.0, which is encoded as (hex)'00 00 01 01 00 00 00 00'."
 | 
 | DISCUSSION:
 | 
 | This metric is apparently not recorded and is not made available through
 | any documented Win32 API function.  Consequently, we return the appropriate
 | "not known" value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.8.<instance>
 |                | | | |
 |                | | | *hrFSLastFullBackupDate
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSLastFullBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

outvalue->length = 8;
outvalue->string = "\0\0\1\1\0\0\0\0";


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSLastFullBackupDate() */


/*
 *  SetHrFSLastFullBackupDate
 *    The last date at which this complete file system was copied to another 
 *    storage device for backup.  This information is useful fo
 *    
 *    Sets the HrFSLastFullBackupDate value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrFSLastFullBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrFSLastFullBackupDate() */


/*
 *  GetHrFSLastPartialBackupDate
 *    The last date at which a portion of thes file system was copied to 
 *    another storage device for backup.  This information is usefu
 *    
 *    Gets the value for HrFSLastPartialBackupDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSLastPartialBackupDate
 | 
 |  ACCESS         SYNTAX
 |  read-write     DateAndTime
 | 
 | "The last date at which a portion of this file system was copied to another
 | storage device for backup.  This information is useful for ensuring that
 | backups are being performed regularly.  If this information is not known, 
 | then this variable shall have the value corresponding to 
 | January 1, year 0000, 00:00:00.0, which is encoded as
 | (hex)'00 00 01 01 00 00 00 00'."
 | 
 | DISCUSSION:
 | 
 | This metric is apparently not recorded and is not made available through
 | any documented Win32 API function.  Consequently, we return the appropriate
 | "not known" value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.9.<instance>
 |                | | | |
 |                | | | *hrFSLastPartialBackupDate
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSLastPartialBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

outvalue->length = 8;
outvalue->string = "\0\0\1\1\0\0\0\0";

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSLastPartialBackupDate() */


/*
 *  SetHrFSLastPartialBackupDate
 *    The last date at which a portion of thes file system was copied to 
 *    another storage device for backup.  This information is usefu
 *    
 *    Sets the HrFSLastPartialBackupDate value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrFSLastPartialBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrFSLastPartialBackupDate() */


/*
 *  HrFSEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrFSEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRFSENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRFSENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRFSENTRY_VAR_INDEX ] ;

        /*
        | For hrFSTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrFSTable cache.
        | Check that here.
        */
	if ( FindTableRow(tmp_instance, &hrFSTable_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrFSEntryFindInstance() */



/*
 *  HrFSEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrFSEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRFSENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRFSENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrFSTable_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrFSEntryFindNextInstance() */



/*
 *  HrFSEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrFSEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrFSEntryConvertInstance() */




/*
 *  HrFSEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrFSEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrFSTable */
} /* end of HrFSEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */
/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */
/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */

BOOL
Gen_HrFSTable_Cache(
                    void
                    )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrFSTable,
|       "hrFSTable_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to 
|       populate the cache for the HrStorage table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
| DISCUSSION:
| 
| It appears that there is a one-to-one correspondence between NT logical drives
| and "file systems" as defined by this table.  As a consequence, the contents
| of this table is almost identical to the hrStorageTable except that remote
| network drives (in unix-speak, remotely mounted file systems) are included
| in this table while excluded from hrStorageTable.
| 
| To this end, a combination of Win32 API functions "GetLogicalDrives",
| "GetVolumeInformation", "GetDriveType" and "GetDiskFreeSpace" are used to
| acquire the information for the SNMP attributes in this table.
| 
|============================================================================
| 1.3.6.1.2.1.25.3.8.1...
|                | | |
|                | | *hrFSEntry
|                | *-hrFSTable
|                *-hrDevice
|
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
LPSTR   pDrvStrings;            /* --> allocated storage for drive strings */
LPSTR   pOriginal_DrvStrings;   /* (Needed for final deallocation          */
DWORD   DS_request_len;         /* Storage actually needed                 */
DWORD   DS_current_len;         /* Storage used on 2nd call                */
ULONG   table_index=0;          /* hrFSTable index counter                 */
CACHEROW *row;                  /* --> Cache structure for row-being built */
UINT    i;                      /* Handy-Dandy loop index                  */

#define PHYS_SIZE 32
CHAR    phys_name[PHYS_SIZE];   /* Buffer where a string like "\\.C:" (for */
                                /*  example) is built for drive access.    */
/*
| Blow away any old copy of the cache
*/
DestroyTable(&hrFSTable_cache);

/*
| We're going to call GetLogicalDriveStrings() twice, once to get the proper
| buffer size, and the second time to actually get the drive strings.
*/
if ((DS_request_len = GetLogicalDriveStrings(2, temp)) == 0) {

    /* Request failed altogether, can't initialize */
    return ( FALSE );
    }

/*
| Grab enough storage for the drive strings plus one null byte at the end
*/

if ( (pOriginal_DrvStrings = pDrvStrings = malloc( (DS_request_len + 1) ) )
    == NULL) {

    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
    }

/* Go for all of the strings */
if ((DS_current_len = GetLogicalDriveStrings(DS_request_len, pDrvStrings))
    == 0) {

    /* Request failed altogether, can't initialize */
    free( pOriginal_DrvStrings );
    return ( FALSE );
    }


/*
|==============================================================================
| As long as we've got an unprocessed drive-string which may correspond to
| a File-System for which we need a table-row entry . . . 
*/
while ( strlen(pDrvStrings) > 0 ) {

    UINT        drivetype;      /* Type of the drive from "GetDriveType()"   */
    ULONG       fs_type;        /* derived File-System type (last-arc value) */
    UINT        bootable;       /* derived "bootable" value (Boolean)        */
    UINT        readwrite;      /* derived "readwrite" value (0 or 1)        */
    UINT        storage_index;  /* Index into hrStorageTable to matching slot*/
    CACHEROW   *row_hrstorage;  /* As returned by FindNextTableRow()         */


    /*
    | Get the drive-type so we can decide whether it should participate in
    | this table.  We do both locals and remotes (unlike hrStorage, from
    | which this code was ripped off).
    */
    drivetype = GetDriveType(pDrvStrings);

    if (   drivetype == DRIVE_UNKNOWN
        || drivetype == DRIVE_NO_ROOT_DIR
        ) {

        /* Step to next string, if any */
        pDrvStrings += strlen(pDrvStrings) + 1;

        continue;
        }

    /*
    | OK, we want this one in the table, get a row-entry created.
    */
    if ((row = CreateTableRow( HRFS_ATTRIB_COUNT ) ) == NULL) {
        return ( FALSE );       // Out of memory
        }

    /* =========== hrFSIndex ==========*/
    row->attrib_list[HRFS_INDEX].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_INDEX].u.unumber_value = (table_index += 1) ;


    /* =========== hrFSMountPoint ==========
    | Note: We store the device string in the cache, but the "GET" function
    |       always returns an empty string, per the spec.
    */
    row->attrib_list[HRFS_MOUNTPT].attrib_type = CA_STRING;

    /* Get some space */
    if ( (row->attrib_list[HRFS_MOUNTPT].u.string_value
          = ( LPSTR ) malloc(strlen(pDrvStrings) + 1)) == NULL) {
        return ( FALSE );       /* out of memory */
        }
    /* Copy the Value into the space */
    strcpy(row->attrib_list[HRFS_MOUNTPT].u.string_value, pDrvStrings);

    /*
    | The GET functions for "computed" attributes expect to be able to use
    | the value of the "hrFSMountPoint" cache value stored above to lookup
    | (using system calls) their respective values.  We may or may not actually
    | report this stored-value as the value of the attribute in initial
    | release.
    */


    /* =========== hrFSRemoteMountPoint ==========*/
    row->attrib_list[HRFS_RMOUNTPT].attrib_type = CA_COMPUTED;


    /* =========== hrFSType     ==========
    |  =========== hrFSAccess   ==========
    |  =========== hrFSBootable ==========
    |
    | We use the first two characters of the drive string (e.g. "C:") to
    | create the special string (e.g. "\\.\C:") needed to obtain a "CreateFile"
    | handle to the device "C" or partition "C".
    |
    | With that, a DeviceIoControl call for partition information gives
    | us an idea as to the type and bootability of the device or partition.
    |
    | If any step in this process fails, the type is "hrFSUnknown", bootable
    | is "FALSE" and Access is presumed "read-write".
    |
    | For hrFSType we store a single number as the cached value of the 
    | hrFSType attribute.  When this attribute is fetched, the cached number 
    | forms the last arc in the OBJECT IDENTIFIER that actually specifies the
    | type: { hrFSTypes x }, where "x" is what gets stored.
    */
    fs_type = 2;        /* 2 = last arc value for "hrFSUnknown" */
    bootable = 0;       /* if unknown, "not bootable"           */
    readwrite = 1;      /* if unknown, "read-write"             */

    /* If we have room in the buffer to build the handle-name string */
    if ((strlen(pDrvStrings) + strlen("\\\\.\\")) < PHYS_SIZE) {

        HANDLE                  hdrv;       /* Handle to device           */
        PARTITION_INFORMATION   part_info;  /* Partition Info from device */
        DWORD                   bytes_out;  /* Bytes retnd into part_info */


        /* Build it for device A: "\\.\A:" */
        sprintf(phys_name, "\\\\.\\%2.2s", pDrvStrings);

        /*
        | Suppress any attempt by the system to make the user put a volume in a
        | removable drive ("CreateFile" will just fail).
        */
        SetErrorMode(SEM_FAILCRITICALERRORS);

        /* Attempt to get a handle using this physical name string */
        if ((hdrv = CreateFile(phys_name,             // Device
                               GENERIC_READ,          // Access
                               FILE_SHARE_READ   |
                               FILE_SHARE_WRITE,      // Share Mode
                               NULL,                  // Security
                               OPEN_EXISTING,         // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL, // FlagsandAttributes
                               NULL                   // Template file
                               )) != INVALID_HANDLE_VALUE) {
            /*
            | Device is Open
            |
            | Try for Partition Information on the "device" we opened
            |
            | (Not supported by Floppy drivers, so this'll probably fail).
            */
            if (DeviceIoControl(hdrv,           // device handle
                                                // IoControlCode (op-code)
                                IOCTL_DISK_GET_PARTITION_INFO,

                                NULL,           // "input buffer"
                                0,              // "input buffer size"
                                &part_info,     // "output buffer"
                                                // "output buffer size"
                                sizeof(PARTITION_INFORMATION),

                                &bytes_out,     // bytes written to part_info
                                NULL            // no Overlapped I/o
                                )) {

                /*
                | We've got Partition Information for the device: use it
                */
                bootable = part_info.BootIndicator;

                /*
                | Assign an OID Type "last-arc number" for those file system
                | types we recognize.
                */
                switch (part_info.PartitionType) {

                    case PARTITION_UNIX:             // Unix
                        fs_type = 3;    // "hrFSBerkeleyFFS"
                        break;

                    case PARTITION_FAT_12:           // 12-bit FAT entries
                    case PARTITION_FAT_16:           // 16-bit FAT entries
                    case PARTITION_HUGE:             // Huge partition MS-DOS V4
                    case PARTITION_FAT32:            // FAT32
                    case PARTITION_FAT32_XINT13:     // FAT32 using extended int13 services
                        fs_type = 5;    // "hrFSFat"
                        break;

                    case PARTITION_IFS:              // IFS Partition
                    case VALID_NTFT:                 // NTFT uses high order bits
                        fs_type = 9;    // "hrFSNTFS"
                        break;

                    case PARTITION_XENIX_1:          // Xenix
                    case PARTITION_XENIX_2:          // Xenix
                    case PARTITION_XINT13:           // Win95 partition using extended int13 services
                    case PARTITION_XINT13_EXTENDED:  // Same as type 5 but uses extended int13 services
                    case PARTITION_EXTENDED:         // Extended partition entry
                    case PARTITION_PREP:             // PowerPC Reference Platform (PReP) Boot Partition
                        fs_type = 1;    // "hrFSOther"
                        break;

                    case PARTITION_ENTRY_UNUSED:     // Entry unused
                    default:
                        /* This will translate to fs_type = 2 "unknown" */
                        break;
                    }
                }   /* If (we managed to get partition information) */

            CloseHandle(hdrv);
            }   /* if (we managed to "CreateFile" the device) */

        SetErrorMode(0);        /* Turn error suppression mode off */
        }   /* if (we managed to build a device name) */

    /* =========== hrFSType     ========== */
    row->attrib_list[HRFS_TYPE].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_TYPE].u.unumber_value = fs_type;


    /* =========== hrFSAccess   ========== */
    /* Quick check: if its a CD-ROM, we presume it is readonly */
    if (drivetype == DRIVE_CDROM) {
        readwrite = 2;
        }
    row->attrib_list[HRFS_ACCESS].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_ACCESS].u.unumber_value = readwrite;


    /* =========== hrFSBootable ========== */
    row->attrib_list[HRFS_BOOTABLE].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_BOOTABLE].u.unumber_value = bootable;


    /* =========== hrFSStorageIndex ==========
    | Strategy:
    |
    | We wander up the hrStorage table looking for an exact match between
    | the storage attribute "hrStorageDescr" (which contains the DOS drive
    | string as returned by GetLogicalDriveStrings()) and the current drive
    | string.
    |
    | The first exact match: the index of that hrStorageTable row gets
    | stored here as the value of "hrFSStorageIndex".
    |
    | No Match: Store zero per the RFC spec.
    |
    | Come PnP, this attribute has to become "computed", as entries may come
    | and go from the hrStorage table.
    |
    | NOTE: The length of the comparison of the match is limited by the
    |       drive string we generate in this function, as the "description"
    |       from the hrStorage table may have other stuff appended to the
    |       end of the drive-string.
    */
    row->attrib_list[HRFS_STORINDX].attrib_type = CA_NUMBER;
    storage_index = 0;  /* Presume failure */

    /* Scan the hrStorageTable cache */
    for (row_hrstorage = FindNextTableRow(0, &hrStorage_cache);
         row_hrstorage != NULL;
         row_hrstorage = FindNextTableRow(i, &hrStorage_cache)
         ) {

        /* Obtain the actual row index */
        i = row_hrstorage->index;

        /* If (this entry has an exact match on drive-strings) */
        if (strncmp(row_hrstorage->attrib_list[HRST_DESCR].u.string_value,
                   pDrvStrings,strlen(pDrvStrings)) == 0) {

            /* We found a match, record it and break out */
            storage_index = i;
            break;
            }
        }

    row->attrib_list[HRFS_STORINDX].u.unumber_value = storage_index;


    /* =========== hrFSLastFullBackupDate ==========*/
    row->attrib_list[HRFS_LASTFULL].attrib_type = CA_COMPUTED;


    /* =========== hrFSLastPartialBackupDate ==========*/
    row->attrib_list[HRFS_LASTPART].attrib_type = CA_COMPUTED;


    /*
    | ======================================================
    | Now insert the filled-in CACHEROW structure into the
    | cache-list for the hrFSTable.
    */
    if (AddTableRow(row->attrib_list[HRFS_INDEX].u.unumber_value,  /* Index */
                    row,                                           /* Row   */
                    &hrFSTable_cache                               /* Cache */
                    ) == FALSE) {
        return ( FALSE );       /* Internal Logic Error! */
        }

    /* Step to next string, if any */
    pDrvStrings += strlen(pDrvStrings) + 1;

    } /* while (drive-strings remain . . .) */


free( pOriginal_DrvStrings );


#if defined(CACHE_DUMP)
PrintCache(&hrFSTable_cache);
#endif


/*
| Initialization of this table's cache succeeded
*/

return (TRUE);
}


/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */
/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */
/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */

ULONG
PartitionTypeToLastArc (
                        BYTE p_type
                        )
/*
|  EXPLICIT INPUTS:
|
|       Disk Partition Type as returned in PARTITION_INFORMATINO
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns the value that should be used as the Last-Arc "x"
|       in a "hrFSTypes" Object Identifier.
|
|     On any Failure:
|       Function returns the last-arc value for "UNKNOWN".
|
|  THE BIG PICTURE:
|
|       In more than one spot we need to be able to translate from
|       a Partition Type to our "Last-Arc" value.
|
|  OTHER THINGS TO KNOW:
|
*/
{
ULONG   last_arc = 2;           /* "2" = "UNKNOWN" */

/*
| Assign an OID Type "last-arc number" for those file system
| types we recognize.
*/
switch ( p_type ) {

    case PARTITION_UNIX:             // Unix
        last_arc = 3;    // "hrFSBerkeleyFFS"
        break;

    case PARTITION_FAT_12:           // 12-bit FAT entries
    case PARTITION_FAT_16:           // 16-bit FAT entries
    case PARTITION_HUGE:             // Huge partition MS-DOS V4
    case PARTITION_FAT32:            // FAT32
    case PARTITION_FAT32_XINT13:     // FAT32 using extended int13 services
        last_arc = 5;    // "hrFSFat"
        break;

    case PARTITION_IFS:              // IFS Partition
    case VALID_NTFT:                 // NTFT uses high order bits
        last_arc = 9;    // "hrFSNTFS"
        break;

    case PARTITION_XENIX_1:          // Xenix
    case PARTITION_XENIX_2:          // Xenix
    case PARTITION_XINT13:           // Win95 partition using extended int13 services
    case PARTITION_XINT13_EXTENDED:  // Same as type 5 but uses extended int13 services
    case PARTITION_EXTENDED:         // Extended partition entry
    case PARTITION_PREP:             // PowerPC Reference Platform (PReP) Boot Partition
        last_arc = 1;    // "hrFSOther"
        break;

    case PARTITION_ENTRY_UNUSED:     // Entry unused
    default:
        /* This will translate to "unknown" */
        break;
    }

return ( last_arc );
}

#if defined(CACHE_DUMP)

/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */
/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */
/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */

static void
debug_print_hrFSTable(
                      CACHEROW     *row  /* Row in hrFSTable table */
                      )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=====================\n");
    fprintf(OFILE, "hrFSTable Table Cache\n");
    fprintf(OFILE, "=====================\n");
    return;
    }


fprintf(OFILE, "hrFSIndex. . . . . . . . %d\n",
        row->attrib_list[HRFS_INDEX].u.unumber_value);

fprintf(OFILE, "hrFSMountPoint . . . . . \"%s\" (ALWAYS RETURNED AS EMPTY STRING) \n",
        row->attrib_list[HRFS_MOUNTPT].u.string_value);

fprintf(OFILE, "hrFSRemoteMountPoint . . \"%s\"\n",
        row->attrib_list[HRFS_RMOUNTPT].u.string_value);

fprintf(OFILE, "hrFSType . . . . . . . . %d ",
        row->attrib_list[HRFS_TYPE].u.unumber_value);

switch (row->attrib_list[HRFS_TYPE].u.unumber_value) {
    case 1: fprintf(OFILE, "(hrFSOther)\n");            break;
    case 2: fprintf(OFILE, "(hrFSUnknown)\n");          break;
    case 3: fprintf(OFILE, "(hrFSBerkeleyFFS)\n");      break;
    case 5: fprintf(OFILE, "(hrFSFat)\n");              break;
    case 9: fprintf(OFILE, "(hrFSNTFS)\n");             break;
    default:
            fprintf(OFILE, "(???)\n");
    }


fprintf(OFILE, "hrFSAccess . . . . . . . %d ",
        row->attrib_list[HRFS_ACCESS].u.number_value);
switch (row->attrib_list[HRFS_ACCESS].u.unumber_value) {
    case 1: fprintf(OFILE, "(readWrite)\n"); break;
    case 2: fprintf(OFILE, "(readOnly)\n"); break;
    default: 
            fprintf(OFILE, "(???)\n"); break;
    }


fprintf(OFILE, "hrFSBootable . . . . . . %d ",
        row->attrib_list[HRFS_BOOTABLE].u.number_value);

switch (row->attrib_list[HRFS_BOOTABLE].u.unumber_value) {
    case 0: fprintf(OFILE, "(FALSE)\n"); break;
    case 1: fprintf(OFILE, "(TRUE)\n"); break;
    default: 
            fprintf(OFILE, "(???)\n"); break;
    }

fprintf(OFILE, "hrFSStorageIndex . . . . %d\n",
        row->attrib_list[HRFS_STORINDX].u.number_value);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrnetwor.c ===
/*
 *  HrNetworkEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrNetworkEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:42:33 1996
 *
 */


#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */
#include "iphlpapi.h"     /* Access to MIB2 Utility function */



/*
 *  GetHrNetworkIfIndex
 *    The value of the ifIndex which corresponds to this network device.
 *    
 *    Gets the value for HrNetworkIfIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrNetworkIfIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER
 | 
 | "The value of ifIndex which corresponds to this network device."
 | 
 | DISCUSSION:
 | 
 | <POA-13> A mechanism by which I can map a network interface device (as found
 | in the course of populating the hrDeviceTable) to the "ifIndex" value in
 | MIB-II needs to be described to me.
 | 
 | RESOLVED >>>>>>>>
 | <POA-13> We expose this info via MIB2UTIL.DLL.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.4.1.1.<instance>
 |                | | | |
 |                | | | *-HrNetworkIfIndex
 |                | | *-HrNetworkEntry
 |                | *-HrNetworkTable
 |                *-hrDevice
 */

UINT
GetHrNetworkIfIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }


/*
| By convention with "Gen_HrNetwork_Cache()", the "Hidden Context" attribute
| for the selected row is the value to be returned by hrNetworkIfIndex.
*/
*outvalue = row->attrib_list[HIDDEN_CTX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrNetworkIfIndex() */


/*
 *  HrNetworkEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrNetworkEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT             tmp_instance;  /* Instance arc value                 */
    CACHEROW        *row;           /* Row entry fetched from cache       */

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRNETWORKENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRNETWORKENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRNETWORKENTRY_VAR_INDEX ] ;

        /*
        | For hrNetworkTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDeviceTable cache.
        |
        | Check that here.
        */
	if ( (row = FindTableRow(tmp_instance, &hrDevice_cache)) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
            /*
            | The instance arc selects an hrDeviceTable row entry, but is that
            | entry actually for a device of type "Network"?
            |
            | (We examine the last arc of the OID that specifies the device
            |  type in the row entry selected by the instance arc).
            */
            if (row->attrib_list[HRDV_TYPE].u.unumber_value !=
                HRDV_TYPE_LASTARC_NETWORK) {

                return SNMP_ERRORSTATUS_NOSUCHNAME;
                }

	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.

	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrNetworkEntryFindInstance() */



/*
 *  HrNetworkEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrNetworkEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRNETWORKENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRNETWORKENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    /*
    | The instance arc selects an hrDeviceTable row entry, but is that
    | entry actually for a device of type "Network"?
    |
    | (We examine the last arc of the OID that specifies the device
    |  type in the row entry selected by the instance arc).
    */
    do {
        if (row->attrib_list[HRDV_TYPE].u.unumber_value ==
            HRDV_TYPE_LASTARC_NETWORK) {

            /* Found an hrDeviceTable entry for the right device type */
            break;
            }

        /* Step to the next row in the table */
        row = GetNextTableRow( row );
        }
        while ( row != NULL );

    /* If we found a proper device-type row . . . */
    if ( row != NULL) {
        instance->ids[ 0 ] = row->index ;
        instance->idLength = 1 ;
        }
    else {

        /*
        | Fell off the end of the hrDeviceTable without finding a row
        | entry that had the right device type.
        */
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrNetworkEntryFindNextInstance() */



/*
 *  HrNetworkEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrNetworkEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrNetworkEntryConvertInstance() */




/*
 *  HrNetworkEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrNetworkEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrNetwork Table */
} /* end of HrNetworkEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */

BOOL
Gen_HrNetwork_Cache(
                      ULONG type_arc
                      )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the HrDevice cache has been fully
|       populated with all rows required for Network devices.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" to
|       populate the cache for the HrDevice table with Network-device 
|       specific entries.
|
|  OTHER THINGS TO KNOW:
|
|       Since all the attributes in the HrNetwork "sub" table are computed
|       upon request (based on cached information in a selected row in the
|       HrDevice table) there is no need to build a cache specifically for
|       this sub-table.  (This routine is only loading the HrDevice cache.
|                                                          --------
|
|       This function holds a convention with the GET routines earlier in
|       this module that the "HIDDEN_CTX" attribute for Network-devices 
|       contains a string that is the value of "hrNetworkIfIndex".
|============================================================================
| 1.3.6.1.2.1.25.3.4.1...
|                | | |
|                | | *-HrNetworkEntry
|                | *-HrNetworkTable
|                *-hrDevice
*/
{
DWORD           dwBytesRequired;    
MIB_IFTABLE    *iftable;        /* --> Heap storage containing table     */
UINT            i;              /* iftable index                         */


/*
| We fetch the IfTable from the Mib2 subsection of the agent and for each
| network interface (ie for every entry in the table) we create a row in
| the hrDeviceTable.
|
| The HIDDEN_CTX attribute value in the row will simply be the "dwIndex"
| entry in the from the iftable entry from which the row was generated.
| This becomes the value of "hrNetworkIfIndex".
*/

/* Initialize */
dwBytesRequired = 0;
iftable = NULL;

/* Ask for the size of the table from "iphlpapi" */
if (GetIfTable(iftable, &dwBytesRequired, TRUE) != ERROR_INSUFFICIENT_BUFFER) {
    return ( FALSE );
    }

/* Allocate necessary memory */
if ((iftable = (MIB_IFTABLE *)malloc(dwBytesRequired)) == NULL) {
    return ( FALSE );
    }

/* Ask for the table information from "iphlpapi" */
if (GetIfTable(iftable, &dwBytesRequired, TRUE) != NO_ERROR ) {

    /* Release */
    free(iftable);

    /* Something blew */
    return ( FALSE );
    }

/* Sweep thru any table creating hrDevice rows */ 
for (i = 0; i < iftable->dwNumEntries; i += 1) {

    /*
    | "Hidden Context" is the ifTable index passed in from the GetIfTable()
    |
    | It will be returned as the value of "hrNetworkIfIndex" by the Get
    | function.
    */

    if (AddHrDeviceRow(type_arc,                     // DeviceType OID Last-Arc
        (unsigned char *) &iftable->table[i].bDescr, // Device Description
                       &iftable->table[i].dwIndex,   // Hidden Ctx "index"
                       CA_NUMBER                     // Hidden Ctx "type"
                       ) == NULL ) {

        /* Release */
        free(iftable);

        /* Something blew */
        return ( FALSE );
        }
    }

/* Release */
free(iftable);

return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrpartit.c ===
/*
 *  HrPartitionEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrPartitionEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:43:52 1996
 *
 | 
 | The approach envisioned for generating the contents of this table consists 
 | of walking all physical drives (using CreateFile and the "physical drive" 
 | naming convention) and acquiring the partition information for each drive 
 | using Win32 API functions DeviceIoControl (IOCTL_DISK_GET_DRIVE_LAYOUT).
 | 
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions          */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */


/*
|==============================================================================
| A word about the cache for this sub-table.
|
| This is a unique sub-table within the hrDevice table in that it is doubly
| indexed.
|
| As a consequence, there are multiple instances of the cache-head,
| one for each simple instance of this table.  Consequently there is no
| single, static instance of a cache-head to be found (as is typically the
| case for sub-tables of hrDevice) here at the start of the module.
|
| The "value" of the "hidden-context" attribute for a hrDevice table
| row for this sub-table has as its value a pointer to a slug of malloced
| memory containing the cache-head for that instance of this sub-table.
| (See "HMCACHE.C" for storage picture).
|
| Initialization of this sub-table occurs as part of the initialization
| of the HrDiskStorage sub-table (HRDISKST.C) in function "ProcessPartitions".
*/

/*
|==============================================================================
| Function Prototypes for this module.
*/
/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */
static UINT
RollToNextFixedDisk (
UINT       *dev_tmp_instance ,     /* ->Device Table Instance Arc ("1st")    */
UINT       *part_tmp_instance ,    /* ->Partition Table Instance Arc ("2nd") */
CACHEROW  **dev_row,               /* ->> Entry in hrDevice Table            */
CACHEHEAD **part_cache             /* ->> Cache-Header for Partition         */
                     );


/*
 *  GetHrPartitionIndex
 *    A unique value for each partition on this long term storage device.  The 
 *    value for each long-term storage device must remain con
 *    
 *    Gets the value for HrPartitionIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "A unique value for each partition on this long- term storage device.  The
 | value for each long-term storage device must remain constant at least from one
 | re-initialization of the agent to the next re- initialization."
 | 
 | DISCUSSION:
 | 
 | (See discussion above for the table as a whole).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.1.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionIndex
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = part_row->attrib_list[HRPT_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionIndex() */


/*
 *  GetHrPartitionLabel
 *    A textual description of this partition.
 *    
 *    Gets the value for HrPartitionLabel.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionLabel
 |
 | ACCESS         SYNTAX
 | read-only      InternationalDisplayString (SIZE (0..128))
 |
 | "A textual description of this partition."
 |
 | DISCUSSION:
 |
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.2.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionLabel
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionLabel( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

outvalue->string = part_row->attrib_list[HRPT_LABEL].u.string_value;

if (outvalue->string == NULL) {
    outvalue->length = 0;
    }
else {
    outvalue->length = strlen(outvalue->string);

    /* "Truncate" here to meet RFC as needed*/
    if (outvalue->length > 128) {
        outvalue->length = 128;
        }
    }

return SNMP_ERRORSTATUS_NOERROR ;


} /* end of GetHrPartitionLabel() */


/*
 *  GetHrPartitionID
 *    A descriptor which uniquely represents this partition to the responsible 
 *    operating system.  On some systems, this might take on 
 *    
 *    Gets the value for HrPartitionID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionID
 | 
 |  ACCESS         SYNTAX
 |  read-only      OCTET STRING
 | 
 | "A descriptor which uniquely represents this partition to the responsible
 | operating system.  On some systems, this might take on a binary
 | representation."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.3.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionID
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionID( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

outvalue->string = (char *) &(part_row->attrib_list[HRPT_ID].u.unumber_value);
outvalue->length = 4;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionID() */


/*
 *  GetHrPartitionSize
 *    The size of this partition.
 *    
 *    Gets the value for HrPartitionSize.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionSize
 | 
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 | 
 | "The size of this partition."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.4.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionSize
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionSize( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = part_row->attrib_list[HRPT_SIZE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionSize() */


/*
 *  GetHrPartitionFSIndex
 *    The index of the file system mounted on this partition.  If no file 
 *    system is mounted on this partition, then this value shall b
 *    
 *    Gets the value for HrPartitionFSIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionFSIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 | 
 | "The index of the file system mounted on this partition.  If no file system is
 | mounted on this partition, then this value shall be zero.  Note that multiple
 | partitions may point to one file system, denoting that that file system
 | resides on those partitions.  Multiple file systems may not reside on one
 | partition."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.5.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionFSIndex
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = part_row->attrib_list[HRPT_FSINDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionFSIndex() */


/*
 *  HrPartitionEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPartitionEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT        dev_tmp_instance ;     /* Device Table Instance Arc     */
    UINT        part_tmp_instance ;    /* Partition Table Instance Arc  */
    CACHEROW    *dev_row;              /* --> Entry in hrDevice Table   */
    CACHEHEAD   *part_cache;           /* --> Cache-Header for Partition*/


    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRPARTITIONENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
        // Instance is 2 arcs for this table:
    else  if ( FullOid->idLength != HRPARTITIONENTRY_VAR_INDEX + 2 )
	// Instance length is more than 2, or 1 exactly, either way: error
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

        /*
        | Check the first of two instance arcs here.  The first should
        | select a valid entry in hrDiskStorage cache.  This guarantees
        | that a disk is being selected.  If a valid entry is present in
        | hrDiskStorage cache, then a corresponding row should be in the
        | main hrDevice table (and having checked hrDiskStorage first, we
        | don't have to verify the type of the entry in hrDevice).
        |
        | The corresponding hrDevice row entry should have a hidden-context
        | that is a non-NULL pointer to a CACHEHEAD **if** the first instance
        | arc is truly selecting a Fixed-Disk (which is the only kind of disk
        | for which HrPartition sub-tables are constructed).
        */
	dev_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX ] ;

	if ( FindTableRow(dev_tmp_instance, &hrDiskStorage_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }

        /*
        | Ok, there is an entry in hrDiskStorage, now go get the corresponding
        | hrDevice entry... it **will be** for a Disk.
        */
        if ( (dev_row = FindTableRow(dev_tmp_instance, &hrDevice_cache))
            == NULL ) {
	    return SNMP_ERRORSTATUS_GENERR ;
            }

        /*
        | Check to be sure there is a cache tucked into the hidden-context,
        | this assures us it is a Fixed Disk and that there is something to
        | search given the second instance arc.  (The cache header may be
        | for an empty cache, but it will support a search).
        */
        if (dev_row->attrib_list[HIDDEN_CTX].attrib_type != CA_CACHE ||
            (part_cache = dev_row->attrib_list[HIDDEN_CTX].u.cache) == NULL) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }

        /*
        | First instance arc ("dev_tmp_instance") is kosher... check the second,
        | ("part_tmp_instance") it should select a valid entry in the cache 
        | whose header pointer is in HIDDEN_CTX.
        */
	part_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX + 1] ;
        if ( FindTableRow(part_tmp_instance, part_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }

	else
	{
	    // the both instances are valid.  Create the instance portion of
	    // the OID to be returned from this call.
	    instance->ids[ 0 ] = dev_tmp_instance ;
	    instance->ids[ 1 ] = part_tmp_instance ;
	    instance->idLength = 2 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrPartitionEntryFindInstance() */



/*
 *  HrPartitionEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPartitionEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    UINT        dev_tmp_instance=0;   /* Device Table Instance Arc ("1st")   */
    UINT        part_tmp_instance=0;  /* Partition Table Instance Arc ("2nd")*/
    CACHEROW    *hrDevice_row;        /* Looked-up row in hrDevice table     */
    CACHEROW    *dev_row = NULL;      /* --> Entry in hrDiskStorage Table    */
    CACHEROW    *part_row = NULL;     /* --> Entry in hrPartition Table      */
    CACHEHEAD   *part_cache=NULL;     /* --> Cache-Header for Partition      */
    UINT        ret_status;           /* Status to be returned by this func  */


    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    /*
    | With two numeric indices to deal with on this table, we're attempting
    | to cover the following situations:
    |
    | 1) No instance arcs provided at all.  In this case, we need to look up
    |    and return the instance arcs that select the first fixed-disk and
    |    the first partition within that disk.  We cover this case as a
    |    "standalone" case.
    |
    | 2) Only the hrdevice ("disk selecting") first instance arc is provided.
    |    In this case, we'll "assume" an initial partition-selecting instance
    |    arc of "0", and continue processing with the code that covers case 3.
    |
    | 3) Two or more instance arcs are provided, in which case we just use the
    |    first of two arcs as the hrdevice ("disk selecting") "first" instance 
    |    arc and the second arc as the hrPartition ("partition selecting") 
    |    "second" instance arc, ignoring any remaining arcs.
    |
    | The "Party Line" on this logic is that it works even if the "fixed-disk"
    | entries don't have monotonically increasing indices the way the
    | cache-population code currently creates them and even if the partition
    | cache (table) has no entries for a particular disk (it must, however
    | have a cache).
    */
    

    if ( FullOid->idLength <= HRPARTITIONENTRY_VAR_INDEX ) {

        /* CASE 1
        |
        | No instance arcs were provided, so we want to setup local instance
        | arcs that select the first hrDevice table "Fixed Disk" entry and the
        | first "Partition" entry within that disk (if any disk and if any
        | partitions within that disk).
        |
        | Entry into "RollToNextFixedDisk()" is special for this case as
        | "dev_row" is NULL, so it'll roll to the first legal Fixed-Disk.
        */
        ret_status =
            RollToNextFixedDisk(&dev_tmp_instance,     // hrDiskStorage arc
                                &part_tmp_instance,    // hrPartition arc
                                &dev_row,              // row in hrDiskStorage
                                &part_cache            // cache for hrPartition
                                );

        /* If we got a no-good return status */
        if (ret_status != SNMP_ERRORSTATUS_NOERROR) {
            return ( ret_status );
            }

        /*
        | Ok, all we need to do is roll into the hrPartition table using the
        | second instance arc returned above (which will be zero) to find
        | the true first entry in the hrPartition table cache so we can return
        | it's index as the second instance arc, (or keep rolling if the
        | partition table (cache) is empty (which it really shouldn't be, but
        | we have it covered if it is)).
        |
        | All this is performed by the "General Roll" code below.
        */           
        }

    else {  /* Some instance arcs provided */

        if ( FullOid->idLength == HRPARTITIONENTRY_VAR_INDEX + 1 ) {

            /* CASE 2
            |
            | Exactly one instance arc is provided, 
            | so use it and assume the second arc is 0.
            */
            dev_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX ] ;
            part_tmp_instance = 0;
            }

        else {

            /* CASE 3
            |
            | Two or more instance arcs are provided, 
            | so use the first two arcs and ignore the rest.
            */
            dev_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX ] ;
            part_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX + 1] ;
            }

        /* Show "No HrPartition Cache Selected Yet" (at entry time: NULL) */

        /*
        | At this point, we need to know whether the first instance arc
        | actually selects a Fixed-Disk entry in hrDevice (and hrDiskStorage)
        | that has an hrPartition table that we can "roll" thru.
        |
        | Attempt a direct ("non-rolling") lookup on the hrDiskStorage table
        | cache with the first instance arc.
        */
        dev_row = FindTableRow(dev_tmp_instance, &hrDiskStorage_cache);

        /*
        | If (an entry is found)
        */
        if ( dev_row != NULL) {

            /* If (the entry is for a "Fixed-Disk") */
            if ( dev_row->attrib_list[HRDS_REMOVABLE].u.unumber_value
                == FALSE) {

                /*
                | Perform "FindTableRow" on hrdevice cache using first 
                | instance arc.
                */
                hrDevice_row = FindTableRow(dev_tmp_instance, &hrDevice_cache);
                
                /*
                | If (no hrdevice entry was found)
                */
                if ( hrDevice_row  == NULL) {
                    return SNMP_ERRORSTATUS_GENERR ;
                    }

                /*
                | If the hrdevice entry DOES NOT have a
                | cache associated with it . . .
                */
                if ( (hrDevice_row->attrib_list[HIDDEN_CTX].attrib_type
                      != CA_CACHE) ||

                     (hrDevice_row->attrib_list[HIDDEN_CTX].u.cache
                      == NULL)) {

                    return SNMP_ERRORSTATUS_GENERR ;
                    }

                /*
                | Select the cache from the hrdevice disk entry as the 
                | HrPartition table cache to be searched in the following
                | logic.
                */
                part_cache = hrDevice_row->attrib_list[HIDDEN_CTX].u.cache;

                } /* if entry was fixed-disk */

            } /* if entry was found */

        /*
        | At this point, if a hrpartition cache has been selected (!NULL),
        | the first instance arc has selected a fixed-disk entry
        | and there is no need to "roll" on the first index.
        |
        | Otherwise we've got to "reset" the second instance arc
        | to "0" and do a rolling lookup on the first arc for
        | another Fixed-disk entry (that should have a partition-cache).
        */

        /* if (an hrpartition cache has NOT been selected) */
        if (part_cache == NULL) {

            /* Perform "RollToNextFixedDisk" processing */
            ret_status =
                RollToNextFixedDisk(&dev_tmp_instance,  // hrDiskStorage arc
                                    &part_tmp_instance, // hrPartition arc
                                    &dev_row,           // row in hrDiskStorage
                                    &part_cache         // hrPartition cache
                                    );

            /* If we got a no-good return status */
            if (ret_status != SNMP_ERRORSTATUS_NOERROR) {
                return ( ret_status );  // (either NOSUCH or GENERR)
                }
            }

        }  /* else Some instance arcs provided */

    /*
    | At this point, we have:
    |
    |   + a valid hrPartition cache to search,
    |   + the second instance arc to search it with (by "rolling"),
    |   + the first instance arc that is valid, (but may need to be
    |       rolled again if there are no valid partitions found).
    |
    | We can now do a "General Roll" to land on the proper Partition entry.
    */

    while (1) {         /* "General Roll" */

        /*
        | Do a "FindNextTableRow" (rolling) lookup on the hrpartition
        | cache with the current value of the second instance arc.
        |
        | if (an entry was found)
        */
        if ((part_row = FindNextTableRow(part_tmp_instance, part_cache))
            != NULL ) {

            /*
            | Return the current first arc and the index from the returned
            | entry as the second instance arc and signal NOERROR.
            */
            instance->ids[ 0 ] = dev_tmp_instance ;
            instance->ids[ 1 ] = part_row->index;
            instance->idLength = 2 ;

            return SNMP_ERRORSTATUS_NOERROR ;
            }

        /*
        | Fell off the end of the current hrPartition cache, must
        | go get another hrPartition cache from the next fixed-disk entry.
        |
        | Perform "RollToNextFixedDisk" processing
        */
        ret_status =
            RollToNextFixedDisk(&dev_tmp_instance,  // hrDiskStorage arc
                                &part_tmp_instance, // hrPartition arc
                                &dev_row,           // row in hrDiskStorage
                                &part_cache         // hrPartition cache
                                );

        if (ret_status != SNMP_ERRORSTATUS_NOERROR) {
            return ( ret_status );   // (either NOSUCH or GENERR)
            }

        } /* while */


} /* end of HrPartitionEntryFindNextInstance() */

/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */
/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */
/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */

static UINT
RollToNextFixedDisk (
                                                                  /* Index */
UINT       *dev_tmp_instance,     /* ->Device Table Instance Arc    ("1st") */
UINT       *part_tmp_instance,    /* ->Partition Table Instance Arc ("2nd") */
CACHEROW  **dev_row,              /* ->> Entry in hrDevice Table            */
CACHEHEAD **part_cache            /* ->> Cache-Header for Partition         */
                     )

/*
|  EXPLICIT INPUTS:
|
|       "dev_tmp_instance" & "part_tmp_instance" are pointers to the "current"
|       instance arcs for the hrDevice and hrPartition table respectively.
|
|       Note that "*dev_tmp_instance" is also implicitly the index into the 
|       hrDiskStorage table as well.
|
|       "dev_row" - is a pointer to the pointer to the hrDiskStorage
|       row currently selected by "*dev_tmp_instance".  It is the 
|       case that "*dev_row" might be null, indicating that no row
|       has been selected yet.
|
|       "part_cache" is a pointer to the pointer to any selected hrPartition
|       table (ie a cache taken from an hrDevice row for a fixed-disk).  If
|       no such partition cache has been selected yet, then "*part_cache" is
|       NULL.
|
|  IMPLICIT INPUTS:
|
|       "HrDiskStorage_cache" may be referenced if "*dev_row" is NULL.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns SNMP_ERRORSTATUS_NOERROR when the roll to the next
|       Fixed-Disk hrDiskStorage entry has succeeded.  New "first" and "second"
|       instance arcs are returned as well as the cache for the hrPartition
|       table that needs to be searched using the "second" arc.
|       
|     On any Failure:
|       Function returns SNMP_ERRORSTATUS_GENERR if it bumps into what it
|       thinks should be a Fixed-Disk entry in hrDevice but the entry does
|       not have an hrPartition table cache as it should.
|
|       Function returns SNMP_ERRORSTATUS_NOSUCHNAME if it can't find another
|       hrDevice entry for a Fixed-Disk.
|
|  THE BIG PICTURE:
|
|     This function takes care of the details of "rolling" to the next
|     Fixed-Disk entry in hrDevice (& HrDiskStorage) on behalf of
|     "HrPartitionEntryFindNextInstance()".
|
|  OTHER THINGS TO KNOW:
|
|     Because we rolling at the device "level", we reset the "instance"
|     arc for the partition level back to zero so that a FindNextTableRow
|     using zero will select the first entry in the selected hrPartition
|     Table (cache) being returned by this function.
*/
{
CACHEROW        *hrDevice_row;          /* Looked-up row in hrDevice table */


/* Reset the second instance arc to "0" */
*part_tmp_instance = 0;

while (1) {   /* Forever . . . */

    /*
    | Try to get the "next" hrDiskStorage row 
    | given our pointer to the current row.
    |
    | If no "current" row, start with the first in hrDiskStorage
    | and riffle upward until we get the row "after" the row that
    | the current device instance arc would have selected.
    */

    /* if (there is no current hrDiskStorage row) */
    if (*dev_row == NULL) {

        /* If the cache is empty . . . */
        if ( (*dev_row =
              FindNextTableRow(*dev_tmp_instance, &hrDiskStorage_cache))
              == NULL) {
            return SNMP_ERRORSTATUS_NOSUCHNAME;
            }
        }
    else {

        /*
        | Perform "GetNextTableRow" on current hrdiskstorage entry
        |
        | if (processing returned no-next-entry)
        */
        if ( (*dev_row = GetNextTableRow((*dev_row))) == NULL) {
            return SNMP_ERRORSTATUS_NOSUCHNAME;
            }
        }

    /*
    | Ok, we've got a "next" row in hrDiskStorage.  If it isn't for a fixed
    | disk, we've got to go around again in hopes of finding one that is.
    */

    /* if (entry is not for Fixed-Disk (skip Removables)) */
    if ( (*dev_row)->attrib_list[HRDS_REMOVABLE].u.unumber_value == TRUE) {
      continue;         /* Skippity doo-dah */
      }

    /*
    | Set current first instance arc value to index of current entry:
    | it is the "next" row following the row for which the original
    | device instance arc selected.
    */
    *dev_tmp_instance = (*dev_row)->index;

    /*
    | Ok, now we've got to go over to the big hrDevice table and hope to
    | find the corresponding hrDevice row given the row index we're on in
    | hrDiskStorage.  As this is coded, I realize that we could have put
    | the HIDDEN_CTX attribute in the hrDiskStorage entry rather than
    | the hrDevice entry and saved this lookup, but it matters little.
    */

    /*
    | Do "FindTableRow" on hrdevice cache using first instance arc
    |
    | if (no hrdevice entry was found) */
    if ( (hrDevice_row = FindTableRow(*dev_tmp_instance, &hrDevice_cache))
        == NULL) {
        /*
        | There should be an hrDevice table entry for every entry in
        | hrDiskStorage.  This seems not to be the case for some reason.
        */
        return SNMP_ERRORSTATUS_GENERR ;
        }

    /* If (the hrdevice entry DOES NOT have a cache associated with it) */
    if ( (hrDevice_row->attrib_list[HIDDEN_CTX].attrib_type != CA_CACHE) ||
         (hrDevice_row->attrib_list[HIDDEN_CTX].u.cache == NULL) ) {
        /*
        | There should be a cache in the HIDDEN_CTX attribute for all fixed
        | disks.
        */
        return SNMP_ERRORSTATUS_GENERR ;
        }

    /*
    | Select and return the cache from the hrDevice fixed-disk row entry as 
    | the HrPartition table cache to be searched on return.
    */
    *part_cache = hrDevice_row->attrib_list[HIDDEN_CTX].u.cache;

    return SNMP_ERRORSTATUS_NOERROR;
    }
}


/*
 *  HrPartitionEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrPartitionEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array[2];/* The address of this (char *) is passed back     */
                         /* as an array of pointers to instance arc numbers */

static ULONG    inst1,   /* The addresses of these ULONGs are passed back  */
                inst2;   /* (Obviously, no "free()" action is needed) */

    /* We expect the two arcs in "oid_spec" */
    inst1 = oid_spec->ids[0];
    array[0] = (char *) &inst1;

    inst2 = oid_spec->ids[1];
    array[1] = (char *) &inst2;

    native_spec->count = 2;
    native_spec->array = array;

    return SUCCESS ;

} /* end of HrPartitionEntryConvertInstance() */




/*
 *  HrPartitionEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrPartitionEntryFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrPartitionEntryFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrprinte.c ===
/*
 *  HrPrinterEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrPrinterEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:42:50 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */
#include "HRDEVENT.H"     /* HrDevice Table  related definitions */
#include <winspool.h>     /* Needed to acquire printer-status*/



/*
 *  GetHrPrinterStatus
 *    The current status of this printer device.
 *    
 *    Gets the value for HrPrinterStatus.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPrinterStatus
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {other(1),unknown(2),idle(3),printing(4),warmup(5)}
 | 
 | "The current status of this printer device.  When in the idle(1), printing(2),
 | or warmup(3) state, the corresponding hrDeviceStatus should be running(2) or
 | warning(3).  When in the unknown state, the corresponding hrDeviceStatus
 | should be unknown(1)."
 | 
 | DISCUSSION:
 | 
 | <POA-14> The actual status and error state of a hardware printer is deeply
 | buried with respect to the application level.  Given that we can acquire
 | the name of the printer driver for a printer, some input on how best to
 | report the hardware status and error state would be appreciated.
 | 
 | LIMITED RESOLUTION >>>>>>>>
 | <POA-14> We report logical printers as though they were hardware printers.
 | This results in certain "undercount" and "overcount" situations when using
 | Host MIB values for inventory purposes.  For status purposes, the status
 | of the logical printers is returned.
 | LIMITED RESOLUTION >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.5.1.1.<instance>
 |                | | | |
 |                | | | *hrPrinterStatus
 |                | | *hrPrinterEntry
 |                | *hrPrinterTable
 |                *-hrDevice
 */

UINT
GetHrPrinterStatus( 
        OUT INThrPrinterStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Ok, here's the skinny:  Just about all the status information that can
| be acquired about a printer under NT is acquired by
| "COMPUTE_hrPrinter_status()" that was written to service the need of
| reporting general status for printer devices out of "hrDeviceStatus".
|
| Since we can't gather any more information reliably than this function
| does, we simply call it and map the return codes it provides as values
| for "hrDeviceStatus" into codes appropriate for this attribute variable.
|
*/
if (COMPUTE_hrPrinter_status(row, (UINT *) outvalue) != TRUE) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* We get back:
|               "unknown" = 1   If we can't open the printer at all.
|
|               "running" = 2   If we can open the printer and no status is
|                               showing on it.
|               "warning" = 3   If we can open the printer but PAUSED or
|                               PENDING_DELETION is showing on it.
*/
switch (*outvalue) {

    case 1:             // "unknown" for hrDeviceStatus
        *outvalue = 2;  // goes to-> "unknown" for hrPrinterStatus
        break;


    case 2:             // "running" for hrDeviceStatus
    case 3:             // "warning" for hrDeviceStatus
    default:
        *outvalue = 1;  // goes to-> "other" for hrPrinterStatus
        break;
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPrinterStatus() */


/*
 *  GetHrPrinterDetectedErrorState
 *    The error conditions as detected by the printer.
 *    
 *    Gets the value for HrPrinterDetectedErrorState.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPrinterDetectedErrorState
 | 
 |  ACCESS         SYNTAX
 |  read-only      OCTET STRING
 | 
 | "This object represents any error conditions detected by the printer.  The
 | error conditions are encoded as bits in an octet string, with the following
 | definitions:
 | 
 |     Condition         Bit #    hrDeviceStatus
 | 
 |     lowPaper          0        warning(3)
 |     noPaper           1        down(5)
 |     lowToner          2        warning(3)
 |     noToner           3        down(5)
 |     doorOpen          4        down(5)
 |     jammed            5        down(5)
 |     offline           6        down(5)
 |     serviceRequested  7        warning(3)
 | 
 | If multiple conditions are currently detected and the hrDeviceStatus would not
 | otherwise be unknown(1) or testing(4), the hrDeviceStatus shall correspond to
 | the worst state of those indicated, where down(5) is worse than warning(3)
 | which is worse than running(2).
 | 
 | Bits are numbered starting with the most significant bit of the first byte
 | being bit 0, the least significant bit of the first byte being bit 7, the most
 | significant bit of the second byte being bit 8, and so on.  A one bit encodes
 | that the condition was detected, while a zero bit encodes that the condition
 | was not detected.
 | 
 | This object is useful for alerting an operator to specific warning or error
 | conditions that may occur, especially those requiring human intervention."
 | 
 | DISCUSSION:
 | 
 | (See discussion above for "hrPrinterStatus").
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.5.1.2.<instance>
 |                | | | |
 |                | | | *hrPrinterDetectedErrorState
 |                | | *hrPrinterEntry
 |                | *hrPrinterTable
 |                *-hrDevice
 */

UINT
GetHrPrinterDetectedErrorState( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that under NT, you can barely tell
| if the printer is on, unlike 95, where you can tell if it is on its
| second bottle of toner for the day.
|
| Consequently we return a single all-bits zero octet regardless of 
| the instance value (which by now in the calling sequence of things
| has been validated anyway).
*/

outvalue->length = 1;
outvalue->string = "\0";

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPrinterDetectedErrorState() */


/*
 *  HrPrinterEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPrinterEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT             tmp_instance;  /* Instance arc value                 */
    CACHEROW        *row;           /* Row entry fetched from cache       */

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRPRINTERENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRPRINTERENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRPRINTERENTRY_VAR_INDEX ] ;

        /*
        | For hrPrinterTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDeviceTable cache.
        |
        | Check that here.
        */
	if ( (row = FindTableRow(tmp_instance, &hrDevice_cache)) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
            /*
            | The instance arc selects an hrDeviceTable row entry, but is that
            | entry actually for a device of type "Printer"?
            |
            | (We examine the last arc of the OID that specifies the device
            |  type in the row entry selected by the instance arc).
            */
            if (row->attrib_list[HRDV_TYPE].u.unumber_value !=
                HRDV_TYPE_LASTARC_PRINTER) {

                return SNMP_ERRORSTATUS_NOSUCHNAME;
                }

	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.

	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrPrinterEntryFindInstance() */



/*
 *  HrPrinterEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPrinterEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRPRINTERENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRPRINTERENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    /*
    | The instance arc selects an hrDeviceTable row entry, but is that
    | entry actually for a device of type "Printer"?
    |
    | (We examine the last arc of the OID that specifies the device
    |  type in the row entry selected by the instance arc).
    */
    do {
        if (row->attrib_list[HRDV_TYPE].u.unumber_value ==
            HRDV_TYPE_LASTARC_PRINTER) {

            /* Found an hrDeviceTable entry for the right device type */
            break;
            }

        /* Step to the next row in the table */
        row = GetNextTableRow( row );
        }
        while ( row != NULL );

    /* If we found a proper device-type row . . . */
    if ( row != NULL) {
        instance->ids[ 0 ] = row->index ;
        instance->idLength = 1 ;
        }
    else {

        /*
        | Fell off the end of the hrDeviceTable without finding a row
        | entry that had the right device type.
        */
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrPrinterEntryFindNextInstance() */



/*
 *  HrPrinterEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrPrinterEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrPrinterEntryConvertInstance() */




/*
 *  HrPrinterEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrPrinterEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrPrinter Table */
} /* end of HrPrinterEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */
/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */
/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */

BOOL
Gen_HrPrinter_Cache(
                    ULONG type_arc
                    )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the HrDevice cache has been fully
|       populated with all rows required for Printer devices.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" to
|       populate the cache for the HrDevice table with printer-specific
|       entries.
|
|  OTHER THINGS TO KNOW:
|
|       Since all the attributes in the HrPrinter "sub" table are computed
|       upon request (based on cached information in a selected row in the
|       HrDevice table) there is no need to build a cache specifically for
|       this sub-table.  (This routine is loading the HrDevice cache despite
|       it's name).                                   --------
|
|       This function holds a convention with the GET routines earlier in
|       this module that the "HIDDEN_CTX" attribute for printers contains
|       a string that can be used in OpenPrinter to get a handle to that
|       printer.
|============================================================================
| 1.3.6.1.2.1.25.3.5.1...
|                | | |
|                | | *hrPrinterEntry
|                | *hrPrinterTable
|                *-hrDevice
|
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
DWORD   PI_request_len;         /* Printer Info: Storage actually needed   */
DWORD   PI_current_len;         /* Printer Info: Storage used on 2nd call  */
DWORD   PI_count;               /* Count of Printer Infos returned         */
UINT    i;                      /* Handy-Dandy loop index                  */
PRINTER_INFO_4 
        *PrinterInfo;           /* --> allocated storage for drive strings */


/*
| We're going to call EnumPrinters() twice, once to get the proper
| buffer size, and the second time to actually get the printer info.
*/
EnumPrinters(PRINTER_ENUM_LOCAL,  // Flags
             NULL,                // Name (ignored)
             4,                   // Level
             temp,                // Buffer
             1,                   // "Too Small" Buffer size
             &PI_request_len,     // Required length... comes back.
             &PI_count
             );
/*
| Grab enough storage for the enumeration structures
*/
if ( (PrinterInfo = malloc(PI_request_len)) == NULL) {
    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
    }

/* Now get the real stuff */
if (!EnumPrinters(PRINTER_ENUM_LOCAL,  // Flags
             NULL,                // Name (ignored)
             4,                   // Level
   (unsigned char *) PrinterInfo, // Buffer to receive enumeration
             PI_request_len,      // Actual buffer size
             &PI_request_len,     // Required length... comes back.
             &PI_count
             )) {

    /* Failed for some reason */
    free( PrinterInfo );
    return ( FALSE );
    }


/*
| Now swing down the list, and for every LOCAL printer,
|
|  + Fetch the description
|  + Make an hrDevice table row entry with the printer name & description
*/
for (i = 0; i < PI_count; i += 1) {

    /* If it is a Local printer ... */
    if (PrinterInfo[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) {

        HANDLE  hprinter;       /* Handle to a printer */

        /* Open it to get a handle */
        if (OpenPrinter(PrinterInfo[i].pPrinterName,    // Printer Name
                        &hprinter,                      // Receive handle here
                        NULL                            // Security
                        ) == TRUE ) {

            PRINTER_INFO_2     *p2;
            DWORD              P2_request_len; /* Bytes-needed by GetPrinter */


            /*
            | Printer is Open, get a PRINTER_INFO_2 "slug-o-data"
            |
            | 1st call: Fails, but gets buffer size needed.
            */
            GetPrinter(hprinter,        // printer handle
                       2,               // Level 2
                       temp,            // Buffer for INFO_2
                       1,               // Buffer-too-small
                       &P2_request_len  // What we really need
                       );

            /*
            | Grab enough storage for the PRINTER_INFO_2 structure
            */
            if ( (p2 = malloc(P2_request_len)) == NULL) {

                /* Storage Request failed altogether, can't initialize */
                free( PrinterInfo );
                ClosePrinter( hprinter );
                return ( FALSE );
                }

            /*
            | 2nd call: Should succeed.
            */
            if (GetPrinter(hprinter,        // printer handle
                           2,               // Level 2
                     (unsigned char *) p2,  // Buffer for INFO_2
                           P2_request_len,  // Buffer-just-right
                           &P2_request_len  // What we really need
                           ) == TRUE) {


                /* Add a row to HrDevice Table
                |
                | We're using the printer-driver name as a "Poor Man's"
                | description: the driver "names" are quite descriptive with
                | version numbers yet!.
                |
                | The Hidden Context is the name needed to open the printer
                | to gain information about its status.
                */
                if (AddHrDeviceRow(type_arc,         // DeviceType OID Last-Arc
                                   p2->pDriverName,  // Used as description
                                   PrinterInfo[i].pPrinterName, // Hidden Ctx
                                   CA_STRING         // Hidden Ctx type
                                   ) == NULL ) {

                    /* Failure at a lower level: drop everything */
                    free( p2 );
                    free( PrinterInfo );
                    ClosePrinter( hprinter );
                    return ( FALSE );
                    }
                }

            /* Close up shop on this printer*/
            free( p2 );
            ClosePrinter( hprinter );
            }
        }
    }

free( PrinterInfo );

return ( TRUE );
}

/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */
/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */
/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */

BOOL
COMPUTE_hrPrinter_errors(
                         CACHEROW *row,
                         UINT     *outvalue
                         )

/*
|  EXPLICIT INPUTS:
|
|       "row" points to the hrDevice cache row for the printer whose error
|       count is to be returned.
|
|       Attribute "HIDDEN_CTX" has a string value that is the name of the
|       printer by convention with "Gen_HrPrinter_Cache()" above.
|
|       "outvalue" is a pointer to an integer to receive the error count.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE and an error count for the specified printer.
|
|     On any Failure:
|       Function returns FALSE.
|
|  THE BIG PICTURE:
|
|       For an hrDevice attribute whose value is "computed", at the time of 
|       the request to see it is received, we dispatch to a "COMPUTE_" function
|       to get the value.  This is such a routine for printers.
|
|  OTHER THINGS TO KNOW:
|
|       This function holds a convention with the Gen_cache routines earlier in
|       this module that the "HIDDEN_CTX" attribute for printers contains
|       a string that can be used in OpenPrinter to get a handle to that
|       printer.
*/
{

/*
| No way to get any error counts under NT 
*/
*outvalue = 0;
return ( TRUE );

}

/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */
/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */
/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */

BOOL
COMPUTE_hrPrinter_status(
                         CACHEROW *row,
                         UINT     *outvalue
                         )

/*
|  EXPLICIT INPUTS:
|
|       "row" points to the hrDevice cache row for the printer whose status
|       is to be returned.
|
|       Attribute "HIDDEN_CTX" has a string value that is the name of the
|       printer by convention with "Gen_HrPrinter_Cache()" above.
|
|       "outvalue" is a pointer to an integer to receive the status.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE and a status for the specified printer:
|
|               "unknown" = 1   If we can't open the printer at all.
|
|               "running" = 2   If we can open the printer and no status is
|                               showing on it.
|               "warning" = 3   If we can open the printer but PAUSED or
|                               PENDING_DELETION is showing on it.
|
|
|     On any Failure:
|       Function returns FALSE.
|
|  THE BIG PICTURE:
|
|       For an hrDevice attribute whose value is "computed", at the time of 
|       the request to see it is received, we dispatch to a "COMPUTE_" function
|       to get the value.  This is such a routine for printers.
|
|  OTHER THINGS TO KNOW:
|
|       This function holds a convention with the Gen_cache routines earlier in
|       this module that the "HIDDEN_CTX" attribute for printers contains
|       a string that can be used in OpenPrinter to get a handle to that
|       printer.
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
HANDLE  hprinter;               /* Handle to a printer */


/* Open Printer whose name is in "Hidden Context"  to get a handle */
if (OpenPrinter(row->attrib_list[HIDDEN_CTX].u.string_value,    // Printer Name
                &hprinter,                      // Receive handle here
                NULL                            // Security
                ) == TRUE ) {

    PRINTER_INFO_2     *p2;
    DWORD              P2_request_len; /* Bytes-needed by GetPrinter */


    /*
    | Printer is Open, get a PRINTER_INFO_2 "slug-o-data"
    |
    | 1st call: Fails, get buffer size needed.
    */
    GetPrinter(hprinter,        // printer handle
               2,               // Level 2
               temp,            // Buffer for INFO_2
               1,               // Buffer-too-small
               &P2_request_len  // What we really need
               );

    /*
    | Grab enough storage for the PRINTER_INFO_2 structure
    */
    if ( (p2 = malloc(P2_request_len)) == NULL) {

        /* Storage Request failed altogether */
        ClosePrinter( hprinter );
        return ( FALSE );
        }

    /*
    | 2nd call: Should succeed.
    */
    if (GetPrinter(hprinter,        // printer handle
                   2,               // Level 2
             (unsigned char *) p2,  // Buffer for INFO_2
                   P2_request_len,  // Buffer-just-right
                   &P2_request_len  // What we really need
                   ) == TRUE) {

        /*
        | As of this writing, only two status values are available
        | under NT:
        |
        |       PRINTER_STATUS_PAUSED
        |       PRINTER_STATUS_PENDING_DELETION
        |
        | Basically, if either of these is TRUE, we'll signal "warning".
        | If neither are TRUE, we'll signal "running" (on the basis that
        | we've managed to open the printer OK and it shows no status).
        */
        if (   (p2->Status & PRINTER_STATUS_PAUSED)
            || (p2->Status & PRINTER_STATUS_PENDING_DELETION)) {

            *outvalue = 3;      // "warning"
            }
        else {
            *outvalue = 2;      // "running"
            }
        }

    /* Free up and return */
    ClosePrinter( hprinter );
    free( p2 );
    }
else {
    *outvalue = 1;      // "unknown"
    }

return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrstoent.c ===
/*
 *  HrStorageEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrStorageEntry.
 *    Actual instrumentation code is supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class, plus the cache
 *    initialization function "Gen_Hrstorage_Cache()".
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/17/97  D. D. Burns     Genned: Thu Nov 07 16:40:22 1996
 *    V1.01 - 05/15/97  D. D. Burns     Move Disk Label/Size acquisitions
 *                                       to cache from real-time
 *    V1.02 - 06/18/97  D. D. Burns     Add spt to scan event log for
 *                                       allocation failures
 *
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions */
#include "string.h"       /* For string manipulation in "Gen_Hrstorage_Cache"*/
#include "stdio.h"        /* For sprintf */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */
static UINT
ScanLog_Failures(
                 CHAR   *device
                 );


#if defined(CACHE_DUMP)

/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */
static void
debug_print_hrstorage(
                      CACHEROW     *row  /* Row in hrstorage table */
                      );
#endif

/*
|==============================================================================
| Cache Refresh Time
|
| The cache for the hrStorage and hrFSTable tables are refreshed automatically
| when a request arrives at the hrStorage --AND-- the cache is older than 
| CACHE_MAX_AGE in seconds.
|
*/
static
LARGE_INTEGER   cache_time;   // 100ns Timestamp of cache (when last refreshed)

#define CACHE_MAX_AGE 120     // Maximum age in seconds

/*
|==============================================================================
| Create the list-head for the HrStorage table cache.
|
| This list-head is globally accessible so the logic that loads hrFSTable
| can scan this cache for matches (among other reasons).
|
| (This macro is defined in "HMCACHE.H").
*/
CACHEHEAD_INSTANCE(hrStorage_cache, debug_print_hrstorage);


/*
|==============================================================================
| Local string for this kind of "storage".
*/
#define VM            "Virtual Memory"


/*
 * ============================================================================
 *  GetHrStorageIndex
 *    A unique value for each logical storage are contained by the host.
 *
 *    Gets the value for HrStorageIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageIndex
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "A unique value for each logical storage area contained by the host."
 |
 | DISCUSSION:
 |
 | The value of this attribute is always the number of drives reported by
 | "GetLogicalDrives" (excepting network drives) plus one (for reporting on
 | "Virtual Memory").
 |
 |============================================================================
 | 1.3.6.1.2.1.25.2.3.1.1.<instance>
 |                | | | |
 |                | | | *hrStorageIndex
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageIndex(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */

/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrStorageIndex" value from this entry
*/
*outvalue = row->attrib_list[HRST_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageIndex() */


/*
 * ============================================================================
 *  GetHrStorageType
 *    The type of strage represented by this entry.
 *
 *    Gets the value for HrStorageType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageType
 |
 |  ACCESS         SYNTAX
 |  read-only      OBJECT IDENTIFIER
 |
 | "The type of storage represented by this entry."
 |
 |    -- Registration for some storage types, for use with hrStorageType
 |
 |    hrStorageOther          OBJECT IDENTIFIER ::= { hrStorageTypes 1 }
 |    hrStorageRam            OBJECT IDENTIFIER ::= { hrStorageTypes 2 }
 |    -- hrStorageVirtualMemory is temporary storage of swapped
 |    -- or paged memory
 |    hrStorageVirtualMemory  OBJECT IDENTIFIER ::= { hrStorageTypes 3 }
 |    hrStorageFixedDisk      OBJECT IDENTIFIER ::= { hrStorageTypes 4 }
 |    hrStorageRemovableDisk  OBJECT IDENTIFIER ::= { hrStorageTypes 5 }
 |    hrStorageFloppyDisk     OBJECT IDENTIFIER ::= { hrStorageTypes 6 }
 |    hrStorageCompactDisc    OBJECT IDENTIFIER ::= { hrStorageTypes 7 }
 |    hrStorageRamDisk        OBJECT IDENTIFIER ::= { hrStorageTypes 8 }
 |
 | DISCUSSION:
 |
 | The value returned for this attribute is determined by indications from
 | "GetDriveType" for disks.  For the "Virtual Memory" entry, the OID for
 | "hrStorageVirtualMemory" is returned.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.2.3.1.2.<instance>
 |                | | | |
 |                | | | *hrStorageType
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageType(
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_Hrstorage_Cache()",
| the cached value is the right-most arc we must return as the value.
|
| Hence whatever cache entry we retrieve, we tack the number retrieved
| from the cache for this attribute onto { hrStorageTypes ... }.
*/
if ( (outvalue->ids = SNMP_malloc(10 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 10;


/*
| Load in the full hrStorageType OID:
|
| 1.3.6.1.2.1.25.2.1.n
|                | | |
|                | | *-Type indicator
|                | *-hrStorageTypes (OIDs specifying storage types)
|                *-hrStorage
|
*/
outvalue->ids[0] = 1;
outvalue->ids[1] = 3;
outvalue->ids[2] = 6;
outvalue->ids[3] = 1;
outvalue->ids[4] = 2;
outvalue->ids[5] = 1;
outvalue->ids[6] = 25;
outvalue->ids[7] = 2;
outvalue->ids[8] = 1;

/* Cached Type indicator */
outvalue->ids[9] = row->attrib_list[HRST_TYPE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageType() */


/*
 *  GetHrStorageDesc
 *    A description of the type and instance of the storage described by this
 *    entry.
 *
 *    Gets the value for HrStorageDesc.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageDescr
 |
 |  ACCESS         SYNTAX
 |  read-only      DisplayString
 |
 | "A description of the type and instance of the storage described by this
 | entry."
 |
 | DISCUSSION:
 |
 | For the Virtual Memory entry, the string "Virtual Memory" is returned.
 |
 | For disks, a string composed of:
 |         + the logical drive letter followed by
 |         + the Volume Identification (for drives containing a volume)
 |           in double quotes
 |         + the Volume Serial Number
 |
 | For instance, the value of this variable for drive C might be
 |                          C: Label="Main Disk"  Serial #=0030-34FE
 |
 | For speed, the label acquisition is done at cache-build time, and
 | as a consequence the removable drives are sampled only once.
 | ===========================================================================
 | 1.3.6.1.2.1.25.2.3.1.3.<instance>
 |                | | | |
 |                | | | *hrStorageDescr
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageDesc(
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Return the description that was computed at cache-build time */
outvalue->length = strlen(row->attrib_list[HRST_DESCR].u.string_value);
outvalue->string = row->attrib_list[HRST_DESCR].u.string_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageDesc() */


/*
 *  GetHrStorageAllocationUnits
 *    The size, in bytes, of the data objects allocated from this pool.  If
 *    this entry is monitoring sectors, blocks, buffers, or pack
 *
 *    Gets the value for HrStorageAllocationUnits.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageAllocationUnits
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "The size, in bytes, of the data objects allocated from this pool.  If this
 | entry is monitoring sectors, blocks, buffers, or packets, for example, this
 | number will commonly be greater than one.  Otherwise this number will
 | typically be one."
 |
 | DISCUSSION:
 |
 | For Virtual Memory, the value returned is that provided as
 | "AllocationGranularity" after a call to "GetSystemInfo".
 |
 | For disks, the size of the "hrStorageAllocationUnits" value is computed as
 | the quantity "BytesPerSector * SectorsPerCluster" as returned by Win32 API
 | function "GetDiskFreeSpace".
 |
 | =============================================================================
 | 1.3.6.1.2.1.25.2.3.1.4.<instance>
 |                | | | |
 |                | | | *hrStorageAllocationUnits
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageAllocationUnits(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRST_ALLOC].u.number_value;
return ( SNMP_ERRORSTATUS_NOERROR );

} /* end of GetHrStorageAllocationUnits() */


/*
 *  GetHrStorageSize
 *    The size of the storage represented by this entry, in units of
 *    hrStorageAllocationUnits.
 *
 *    Gets the value for HrStorageSize.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageSize
 |
 |  ACCESS         SYNTAX
 |  read-write     INTEGER (0..2147483647)
 |
 | "The size of the storage represented by this entry, in units of
 | hrStorageAllocationUnits."
 |
 | DISCUSSION:
 |
 | For Virtual Memory, the value returned is computed as "TotalPageFile" (as
 | returned by "GlobalMemoryStatus") divided by "AllocationGranularity" from
 | "GetSystemInfo".
 |
 | For disks, the "hrStorageSize" value is the value of "TotalNumberOfClusters"
 | as returned by Win32 API function "GetDiskFreeSpace".
 |
 | <POA-4> This variable is marked as ACCESS="read-write".  It is unclear to me
 | what effect can be expected from a SET operation on this variable.  I propose
 | making a SET operation have no effect.
 |
 | RESOLVED >>>>>>>
 | <POA-4> Leaving this read-only is fine.
 | RESOLVED >>>>>>>
 |
 | =============================================================================
 | 1.3.6.1.2.1.25.2.3.1.5.<instance>
 |                | | | |
 |                | | | *hrStorageSize
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageSize(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRST_SIZE].u.number_value;
return ( SNMP_ERRORSTATUS_NOERROR )  ;

} /* end of GetHrStorageSize() */


/*
 *  SetHrStorageSize
 *    The size of the storage represented by this entry, in units of
 *    hrStorageAllocationUnits.
 *
 *    Sets the HrStorageSize value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 *
 | =============================================================================
 | 1.3.6.1.2.1.25.2.3.1.5.<instance>
 |                | | | |
 |                | | | *hrStorageSize
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
SetHrStorageSize(
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

#if 0
//debug debug debug debug debug
static int x=0;
if (x==0) {
    /*
    | If it is invoked here, the invocation
    | of it in mib.c must be removed.
    */
    Gen_HrDevice_Cache();
    x =1;
    }
//debug debug debug debug debug
#endif

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrStorageSize() */


/*
 *  GetHrStorageUsed
 *    The amount of the storage represented by this entry that is allocated,
 *    in units of hrStorageAllocationUnits.
 *
 *    Gets the value for HrStorageUsed.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageUsed
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 |
 | "The amount of the storage represented by this entry that is allocated, in
 | units of hrStorageAllocationUnits."
 |
 | DISCUSSION:
 |
 | For Virtual Memory, the value returned is computed as the quantity
 | "TotalPageFile" less "AvailPageFile" (as returned by "GlobalMemoryStatus")
 | divided by "AllocationGranularity" (as returned by "GetSystemInfo".
 |
 | For disks, the "hrStorageUsed" value is computed as the quantity
 | "TotalNumberOfClusters - NumberOfFreeClusters" as returned by Win32 API
 | function "GetDiskFreeSpace".
 |
 | ===========================================================================
 | 1.3.6.1.2.1.25.2.3.1.6.<instance>
 |                | | | |
 |                | | | *hrStorageUsed
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageUsed(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */



/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRST_USED].u.number_value;
return ( SNMP_ERRORSTATUS_NOERROR )  ;

} /* end of GetHrStorageUsed() */


/*
 *  GetHrStorageAllocationFailures
 *    The number of requests for storage represented by this entry that could
 *    not be honored due to not enough storage.  It should be
 *
 *    Gets the value for HrStorageAllocationFailures.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 |=============================================================================
 |hrStorageAllocationFailures
 |
 | ACCESS         SYNTAX
 | read-only      Counter
 |
 |"The number of requests for storage represented by this entry that could not
 |be honored due to not enough storage.  It should be noted that as this object
 |has a SYNTAX of Counter, that it does not have a defined initial value.
 |However, it is recommended that this object be initialized to zero."
 |
 |DISCUSSION:
 |
 |<POA-5> This value as very problematical for both Virtual Memory and Disk
 |storage.  There appear to be no Win32 APIs that report allocation failures for
 |either virtual memory or disk storage.  I presume there may be performance
 |monitoring counters stored in the registry, however I'm not able to find the
 |documentation that describes where such information might be stored.  For
 |disks, we need to be able to map whatever counters are stored into logical
 |drives (as that is how this table is organized).
 |
 |RESOLVED >>>>>>>
 |<POA-5> You would have to scan to event log looking for the out of virtual
 |memory and out of disk space events and count them.
 |RESOLVED >>>>>>>
 |=============================================================================
 | 1.3.6.1.2.1.25.2.3.1.7.<instance>
 |                | | | |
 |                | | | *hrStorageAllocationFailures
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageAllocationFailures(
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
CHAR            device[3];      /* Device Name build-buffer             */
ULONG           index;          /* As fetched from instance structure   */
CACHEROW       *row;            /* Row entry fetched from cache         */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Load the "device[]" array with two characters, either something like "C:"
| (indicating we're interested in allocation failures for "C:") or "VM"
| if we want VM storage allocation failures.... from the HRST_DESCR string.
*/
if (strcmp(row->attrib_list[HRST_DESCR].u.string_value, VM) == 0) {
    /* Storage is really "Virtual Memory" */
    device[0] = 'V';
    device[1] = 'M';
    }
else {
    device[0] = row->attrib_list[HRST_DESCR].u.string_value[0];
    device[1] = row->attrib_list[HRST_DESCR].u.string_value[1];
    }
device[2] = '\0';       /* Null-terminate */

/* Riffle thru the Event Log looking for this device's failures */
*outvalue = ScanLog_Failures( device );

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageAllocationFailures() */


/*
 *  HrStorageEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSTORAGEENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSTORAGEENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSTORAGEENTRY_VAR_INDEX ] ;

        /*
        | Check for age-out and possibly refresh the entire cache for the
        | hrStorage table and hrFSTable before we check to see if the 
        | instance is there.
        */
        if (hrStorageCache_hrFSTableCache_Refresh() == FALSE) {
            return SNMP_ERRORSTATUS_GENERR;
            }

        /*
        | For hrStorage, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrStorageTable cache.
        | Check that here.
        */
	if ( FindTableRow(tmp_instance, &hrStorage_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageEntryFindInstance() */



/*
 *  HrStorageEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //  Developer supplied code to find the next instance of class goes here.
    //
    //  The purpose of this function is to indicate to the rest of the system
    //  what the exact OID of the "next instance" is GIVEN THAT:
    //
    //          a) The "FullOid" passed in will have enough arcs to specify
    //             both the TABLE and the ATTRIBUTE in the table
    //
    //          b) The "instance" OID array is always big enough to have
    //             as many arcs as needed loaded into it by this function
    //             to specify (exactly) the "next instance"
    //
    //
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //
    //  If the FullOid is so short that it does not specify an instance,
    //  then the only instance of the class should be returned.  If this is a
    //  table, the first row of the table is returned.  To do these things,
    //  set the "instance" OID to just the right arcs such that when
    //  concatenated onto the FullOid, the concatenation exactly specifies
    //  the first instance of this attribute in the table.
    //
    //  If an instance is specified and this is a non-table class, then
    //  NOSUCHNAME is returned so that correct MIB rollover processing occurs.
    //
    //  If this is a table, then the next instance is the one following the
    //  current instance.
    //
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSTORAGEENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSTORAGEENTRY_VAR_INDEX ] ;
        }

    /*
    | Check for age-out and possibly refresh the entire cache for the
    | hrStorage table and hrFSTable before we check to see if the 
    | instance is there.
    */
    if (hrStorageCache_hrFSTableCache_Refresh() == FALSE) {
        return SNMP_ERRORSTATUS_GENERR;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrStorage_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageEntryFindNextInstance() */



/*
 *  HrStorageEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrStorageEntryConvertInstance() */




/*
 *  HrStorageEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrStorageEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrStorageTable */
} /* end of HrStorageEntryFreeInstance() */

/*
| End of Generated Code
*/


/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */
/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */
/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */

BOOL
hrStorageCache_hrFSTableCache_Refresh(
                     void
                     )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS: 
|
|       The "hrStorage_cache" CACHEHEAD structure and the time when
|       it was last refreshed in module-local cell "cache_time".
|       The "hrFSTable_cache" CACHEHEAD structure which depends on
|       the hrStorage_cache CACHEHEAD structure.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       The function returns TRUE.  Only if the cache-time has aged-out
|       is the cache actually rebuilt.
|
|     On any Failure:
|       If during a rebuild there is an error, this function returns FALSE.
|       The state of the cache is indeterminate.
|
|  THE BIG PICTURE:
|
|       This function is invoked before any reference is made to any SNMP
|       variable in the hrStorage table.  It checks to see
|       if the cache needs to be rebuilt based on the last time it was built.
|       Since the hrFSTable_cache depends on the hrStorage table,
|       hrFSTable_cache will be rebuilt whenever hrStorage table is rebuilt.
|
|       The calls to this function are strategically located in the
|       "FindInstance" and "FindNextInstance" functions in "HRSTOENT.C"
|       (this module).
|
|  OTHER THINGS TO KNOW:
|
*/
{
LARGE_INTEGER   now_time;       /* Current System time in 100 ns ticks */


/* Get the current time in 100 ns ticks*/
NtQuerySystemTime (&now_time);

/* If the cache is older than the maximum allowed time (in ticks) . . .  */
if ( (now_time.QuadPart - cache_time.QuadPart) > (CACHE_MAX_AGE * 10000000) )
{
    if (Gen_Hrstorage_Cache())
    {
        // hrFSStorageIndex attribute of hrFSTable depends on the 
        // the index of the hrStorageEntry 
        return (Gen_HrFSTable_Cache());
    }
    else
        return FALSE;
}

return ( TRUE );        /* No Error (because no refresh) */
}

/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */
/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */
/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */

BOOL
Gen_Hrstorage_Cache(
                    void
                    )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrStorage table,
|       "hrStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to
|       populate the cache for the HrStorage table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
|  DISCUSSION:
|
|  Since this table is meant for diagnosing "out-of-storage" situations and
|  given that the information is meant to be regarded from the point of view
|  of an application, we simply report every instance of what would appear
|  on the "Drive Bar" of the File Manager (excepting network drives) plus
|  one more table entry to reflect information on "Virtual Memory".
|
|  To this end, a combination of Win32 API functions "GetLogicalDrives",
|  "GetVolumeInformation", "GetDriveType" and "GetDiskFreeSpace" are used to
|  acquire the information for the SNMP attributes in this table.
|
|  For reporting on "Virtual Memory", functions "GlobalMemoryStatus" and
|  "GetSystemInfo" are invoked.
|============================================================================
| 1.3.6.1.2.1.25.2.1....
|                | |
|                | *-hrStorageTypes (OIDs specifying storage types)
|                *-hrStorage
|
| 1.3.6.1.2.1.25.2.2....
|                | |
|                | *-hrMemorySize   (standalone attribute)
|                *-hrStorage
|
| 1.3.6.1.2.1.25.2.3....
|                | |
|                | *-hrStorageTable (the table)
|                *-hrStorage
*/

#define VOL_NAME_SIZE 256
#define DESCR_SIZE    384

{
CHAR    temp[8];                /* Temporary buffer for first call         */
LPSTR   pDrvStrings;            /* --> allocated storage for drive strings */
LPSTR   pOriginal_DrvStrings;   /* (Needed for final deallocation          */
DWORD   DS_request_len;         /* Storage actually needed                 */
DWORD   DS_current_len;         /* Storage used on 2nd call                */
ULONG   table_index=0;          /* hrStorageTable index counter            */
CACHEROW *row;                  /* --> Cache structure for row-being built */

SYSTEM_INFO     sys_info;       /* Filled in by GetSystemInfo for VM       */

LPSTR   str_descr;              /* String for disk label/serial description*/
TCHAR   volname[VOL_NAME_SIZE+2];            /* Volume Name returned here  */
DWORD   volnamesize=VOL_NAME_SIZE;           /* Size of volname buffer     */
DWORD   serial_number;          /* Volume Serial Number                    */
DWORD   max_comp_len;           /* File system file-name component length  */
DWORD   filesys_flags;          /* File System flags (GetVolInformation)   */
CHAR    descr[DESCR_SIZE];      /* Full description possibly built here    */

DWORD   SectorsPerCluster;      /* GetDiskFreeSpace() cells */
DWORD   BytesPerSector;
DWORD   NumberOfFreeClusters;
DWORD   TotalNumberOfClusters;

MEMORYSTATUS    mem_status;     /* Filled in by GlobalMemoryStatus        */
NTSTATUS        ntstatus;       /* Generic return status                  */


/*
| Blow away any old copy of the cache
*/
DestroyTable(&hrStorage_cache);

/*
| We're going to call GetLogicalDriveStrings() twice, once to get the proper
| buffer size, and the second time to actually get the drive strings.
|
| Bogus:
*/
if ((DS_request_len = GetLogicalDriveStrings(2, temp)) == 0) {

    /* Request failed altogether, can't initialize */
    return ( FALSE );
    }

/*
| Grab enough storage for the drive strings plus one null byte at the end
*/

if ( (pOriginal_DrvStrings = pDrvStrings = malloc( (DS_request_len + 2) ) )
    == NULL) {

    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
    }

/* Go for all of the strings */
if ((DS_current_len = GetLogicalDriveStrings(DS_request_len, pDrvStrings))
    == 0) {

    /* Request failed altogether, can't initialize */
    free( pOriginal_DrvStrings );
    return ( FALSE );
    }

/*
| Freshen the time on the cache
|
| Get the current system-time in 100ns intervals . . . */
ntstatus = NtQuerySystemTime (&cache_time);


/*
|==============================================================================
| As long as we've got an unprocessed drive-string. . .
*/
while ( strlen(pDrvStrings) > 0 ) {

    UINT        drivetype;      /* Type of the drive from "GetDriveType()" */


    /*
    | Get the drive-type so we can decide whether it should participate in
    | this table.
    */
    drivetype = GetDriveType(pDrvStrings);

    if (   drivetype == DRIVE_UNKNOWN
        || drivetype == DRIVE_NO_ROOT_DIR
        || drivetype == DRIVE_REMOTE            /* No Remotes in HrStorage */
        ) {

        /* Step to next string, if any */
        pDrvStrings += strlen(pDrvStrings) + 1;

        continue;
        }

    /*
    | OK, we want this one in the table, get a row-entry created.
    */
    if ((row = CreateTableRow( HRST_ATTRIB_COUNT ) ) == NULL) {
        return ( FALSE );       // Out of memory
        }

    /* =========== hrStorageIndex ==========*/
    row->attrib_list[HRST_INDEX].attrib_type = CA_NUMBER;
    row->attrib_list[HRST_INDEX].u.unumber_value = ++table_index;


    /* =========== hrStorageType ==========*/
    row->attrib_list[HRST_TYPE].attrib_type = CA_NUMBER;

    /*
    | Based on the drive-type returned, we store a single number as
    | the cached value of the hrStorageType attribute.  When this attribute
    | is fetched, the cached number forms the last arc in the OBJECT IDENTIFIER
    | that actually specifies the type: { hrStorageTypes x }, where "x" is
    | what gets stored.
    */
    switch (drivetype) {

        case DRIVE_REMOVABLE:
            row->attrib_list[HRST_TYPE].u.unumber_value = 5;
            break;

        case DRIVE_FIXED:
            row->attrib_list[HRST_TYPE].u.unumber_value = 4;
            break;

        case DRIVE_CDROM:
            row->attrib_list[HRST_TYPE].u.unumber_value = 7;
            break;

        case DRIVE_RAMDISK:
            row->attrib_list[HRST_TYPE].u.unumber_value = 8;
            break;

        default:
            row->attrib_list[HRST_TYPE].u.unumber_value = 1;  // "Other"
            break;
        }


    /* =========== hrStorageDescr ==========
    |
    |  We try and fetch the volume label here, to get a string
    |  that may look like:
    |           C: Label="Main Disk"  Serial #=0030-34FE
    |
    | Handle all kinds of disk storage here:
    |
    |   Try to get volume label and serial number.  If we fail, we just give
    |   'em the root-path name.
    |
    |   Presume that we'll fail, and just return the root-path string.
    */
    str_descr = pDrvStrings;

    /*
    | Suppress any attempt by the system to make the user put a volume in a
    | removable drive.
    */
    SetErrorMode(SEM_FAILCRITICALERRORS);

    if (GetVolumeInformation(pDrvStrings,       /* drive name           */
                             volname,           /* Volume Name Buffer   */
                             volnamesize,       /* Size of buffer       */
                             &serial_number,    /* Vol. # Returned here */
                             &max_comp_len,     /* Max filename length  */
                             &filesys_flags,    /* File System flags    */
                             NULL,              /* Name of Filesystem   */
                             0                  /* Length of name       */
                             )) {
        /*
        | We got something back.
        |
        | If we have room given string lengths, build a description:
        |
        |    <root path> Label:<volume name>  Serial Number: <#>
        */
        #define SPRINTF_FORMAT "%s Label:%s  Serial Number %x"

        if ((strlen(SPRINTF_FORMAT) + strlen(volname) + strlen(str_descr))
            < DESCR_SIZE) {
            sprintf(descr,
                    SPRINTF_FORMAT,
                    str_descr,          // root-path
                    volname,            // volume name
                    serial_number);     // volume serial #
            str_descr = descr;
            }
        }


    row->attrib_list[HRST_DESCR].attrib_type = CA_STRING;

    /*
    | Note:
    |       The convention is established that the first characters of
    |       this description string is always the device-string (e.g. "C:")
    |       or the value of local symbol "VM" ("Virtual Memory").
    |
    |       Code in "GetHrStorageAllocationFailures()" attempts to extract
    |       the drive letter (or "Virtual Memory") from the beginning of this
    |       string in order to determine allocation failures from the
    |       Event Log(!).
    */
    if ( (row->attrib_list[HRST_DESCR].u.string_value
          = ( LPSTR ) malloc(strlen(str_descr) + 1)) == NULL) {
        return ( FALSE );       /* out of memory */
        }
    /* Copy the Value into the space */
    strcpy(row->attrib_list[HRST_DESCR].u.string_value, str_descr);

    row->attrib_list[HRST_ALLOC].attrib_type = CA_NUMBER;
    row->attrib_list[HRST_SIZE].attrib_type = CA_NUMBER;
    row->attrib_list[HRST_USED].attrib_type = CA_NUMBER;

    /*
    | Handle all kinds of disk storage info here:
    |
    |   Try to get volume statistics via GetDiskFreeSpace().
    */
    if (GetDiskFreeSpace(pDrvStrings,           // drive
                         &SectorsPerCluster,
                         &BytesPerSector,
                         &NumberOfFreeClusters,
                         &TotalNumberOfClusters
                         )) {
        /* Success */

        /* =========== hrStorageAllocationUnits ==========*/
        row->attrib_list[HRST_ALLOC].u.unumber_value =
                          BytesPerSector * SectorsPerCluster;

        /* =========== hrStorageSize ==========*/
        row->attrib_list[HRST_SIZE].u.unumber_value = TotalNumberOfClusters;

        /* =========== hrStorageUsed ==========*/
        row->attrib_list[HRST_USED].u.unumber_value =
            TotalNumberOfClusters - NumberOfFreeClusters;
        }
    else {
        /* Failure */

        /* =========== hrStorageAllocationUnits ==========*/
        row->attrib_list[HRST_ALLOC].u.unumber_value = 0;

        /* =========== hrStorageSize ==========*/
        row->attrib_list[HRST_SIZE].u.unumber_value = 0;

        /* =========== hrStorageUsed ==========*/
        row->attrib_list[HRST_USED].u.unumber_value = 0;
        }

    /* =========== hrStorageAllocationFailures ==========*/
    row->attrib_list[HRST_FAILS].attrib_type = CA_COMPUTED;

    SetErrorMode(0);        /* Turn error suppression mode off */

    /*
    | Now insert the filled-in CACHEROW structure into the
    | cache-list for the hrStorageTable.
    */
    if (AddTableRow(row->attrib_list[HRST_INDEX].u.unumber_value,  /* Index */
                    row,                                           /* Row   */
                    &hrStorage_cache                               /* Cache */
                    ) == FALSE) {
        return ( FALSE );       /* Internal Logic Error! */
        }

    /* Step to next string, if any */
    pDrvStrings += strlen(pDrvStrings) + 1;
    }


free( pOriginal_DrvStrings );

/*
|==============================================================================
| Now handle Virtual Memory as a special case.
|==============================================================================
*/
if ((row = CreateTableRow( HRST_ATTRIB_COUNT ) ) == NULL) {
    return ( FALSE );       // Out of memory
    }

/* =========== hrStorageIndex ==========*/
row->attrib_list[HRST_INDEX].attrib_type = CA_NUMBER;
row->attrib_list[HRST_INDEX].u.unumber_value = ++table_index;

/* =========== hrStorageType ==========*/
row->attrib_list[HRST_TYPE].attrib_type = CA_NUMBER;
row->attrib_list[HRST_TYPE].u.unumber_value = 3;        /* Virtual Memory */

/* =========== hrStorageDescr ==========*/
row->attrib_list[HRST_DESCR].attrib_type = CA_STRING;
if ( (row->attrib_list[HRST_DESCR].u.string_value
      = ( LPSTR ) malloc(strlen(VM) + 1)) == NULL) {
    return ( FALSE );       /* out of memory */
    }
strcpy(row->attrib_list[HRST_DESCR].u.string_value, VM);


/* =========== hrStorageAllocationUnits ==========*/
GetSystemInfo(&sys_info);
row->attrib_list[HRST_ALLOC].attrib_type = CA_NUMBER;
row->attrib_list[HRST_ALLOC].u.unumber_value =
                                             sys_info.dwAllocationGranularity;

/* =========== hrStorageSize ==========*/
/* Acquire current memory statistics */
GlobalMemoryStatus(&mem_status);

row->attrib_list[HRST_SIZE].attrib_type = CA_NUMBER;
row->attrib_list[HRST_SIZE].u.unumber_value =
    (DWORD)(mem_status.dwTotalPageFile / sys_info.dwAllocationGranularity);


/* =========== hrStorageUsed ==========*/
row->attrib_list[HRST_USED].attrib_type = CA_NUMBER;
row->attrib_list[HRST_USED].attrib_type =
    (int)((mem_status.dwTotalPageFile - mem_status.dwAvailPageFile)
                           / sys_info.dwAllocationGranularity);

/* =========== hrStorageAllocationFailures ==========*/
row->attrib_list[HRST_FAILS].attrib_type = CA_COMPUTED;

/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrStorageTable.
*/
if (AddTableRow(row->attrib_list[HRST_INDEX].u.unumber_value,  /* Index */
                row,                                           /* Row   */
                &hrStorage_cache                               /* Cache */
                ) == FALSE) {
    return ( FALSE );       /* Internal Logic Error! */
    }
/*
|==============================================================================
| End of Virtual Memory
|==============================================================================
*/


#if defined(CACHE_DUMP)
PrintCache(&hrStorage_cache);
#endif

/*
| Initialization of this table's cache succeeded
*/
return (TRUE);
}

/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */
/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */
/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */

static UINT
ScanLog_Failures(
                 CHAR   *device
                 )

/*
|  EXPLICIT INPUTS:
|
|       "device" is either the string "VM" (for "Virtual Memory") or
|       the logical device for which we're looking for failures (e.g. "C:").
|
|  IMPLICIT INPUTS:
|
|       The System Event log file.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       Function returns the number of storage allocation failures
|       found for the specified device.
|
|  THE BIG PICTURE:
|
|       This is a "helper" function for routine "GetHrStorageAllocationFailures"
|       within this module.
|
|  OTHER THINGS TO KNOW:
|
|       We scan backwards (in time) thru the Event Log until we hit the
|       "Event Logging Started" event record (because, presumably, we don't
|       care about failures that happened before the system last came up).
*/

/*
| These symbols select the "Event Log Started" informational message.
*/
#define EVENTLOG_START_ID   0x80001775
#define EVENTLOG_START_TYPE 4
#define EVENTLOG_START_SRC  "EventLog"

{
#define EVL_BUFFER_SIZE 2048
EVENTLOGRECORD *pevlr;
BYTE            bBuffer[EVL_BUFFER_SIZE];
DWORD           dwRead, dwNeeded, cRecords;
HANDLE          h;
BOOL            keep_scanning = TRUE;
UINT            alloc_failures = 0;

/*
| Open the System event log
*/
h = OpenEventLog(NULL,      /* local computer */
                 "System"   /* source name    */
                 );

if (h == NULL) {
    return ( alloc_failures );
    }

pevlr = (EVENTLOGRECORD *) &bBuffer;

/*
| Read records sequentially "Backward in Time" until there
| are no more, or we hit the "Event Logging Started" event.
|
| Read a "Slug 'o Records":
*/
while (ReadEventLog(h,                      // event log handle
                    EVENTLOG_BACKWARDS_READ | // reads backward
                    EVENTLOG_SEQUENTIAL_READ, // sequential read
                    0,                      // ignored for sequential reads
                    pevlr,                  // address of buffer
                    EVL_BUFFER_SIZE,        // size of buffer
                    &dwRead,                // count of bytes read
                    &dwNeeded)              // bytes in next record
       && keep_scanning == TRUE) {


    /* Wind down thru this "slug" . . . */
    while (dwRead > 0) {

        /*
        | Check for "Event Logging Started"
        |
        | (The source name is just past the end of the formal structure).
        */
        if (   pevlr->EventID == EVENTLOG_START_ID
            && pevlr->EventType == EVENTLOG_START_TYPE
            && strcmp( ((LPSTR) ((LPBYTE) pevlr + sizeof(EVENTLOGRECORD))),
                      EVENTLOG_START_SRC) == 0
            ) {
            keep_scanning = FALSE;
            break;
            }

//============================================================================
// INSERT RECORD CHECKING LOGIC OF THIS SORT HERE:
//
//      IF (    <eventrecordID>           == pevlr->EventID
//           && <eventrecordtype>         == pevlr->EventType
//           && <eventrecordsourcestring> == (is the same as..)
//                     ( (LPSTR) ((LPBYTE) pevlr + sizeof(EVENTLOGRECORD)) )
//         ) {
//              // It's an allocation-failure record, if it is for device
//              // "device", then count it.
//              IF (strcmp(device, <eventrecordinstance-data>) {
//                  alloc_failures += 1;
//                  }
//           }
//============================================================================

        dwRead -= pevlr->Length;
        pevlr = (EVENTLOGRECORD *)
            ((LPBYTE) pevlr + pevlr->Length);
        }

    pevlr = (EVENTLOGRECORD *) &bBuffer;
    }

CloseEventLog(h);

/* Give 'em the count */
return (alloc_failures);
}

#if defined(CACHE_DUMP)

/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */
/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */
/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */

static void
debug_print_hrstorage(
                      CACHEROW     *row  /* Row in hrstorage table */
                      )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=====================\n");
    fprintf(OFILE, "hrStorage Table Cache\n");
    fprintf(OFILE, "=====================\n");
    return;
    }


fprintf(OFILE, "hrStorageIndex . . . . . %d\n",
        row->attrib_list[HRST_INDEX].u.unumber_value);

fprintf(OFILE, "hrStorageType. . . . . . %d ",
        row->attrib_list[HRST_TYPE].u.unumber_value);

switch (row->attrib_list[HRST_TYPE].u.unumber_value) {
    case 1: fprintf(OFILE, "(Other)\n");        break;
    case 2: fprintf(OFILE, "(RAM)\n");        break;
    case 3: fprintf(OFILE, "(Virtual Memory)\n");        break;
    case 4: fprintf(OFILE, "(Fixed Disk)\n");        break;
    case 5: fprintf(OFILE, "(Removable Disk)\n");        break;
    case 6: fprintf(OFILE, "(Floppy Disk)\n");        break;
    case 7: fprintf(OFILE, "(Compact Disk)\n");        break;
    case 8: fprintf(OFILE, "(RAM Disk)\n");        break;
    default:
            fprintf(OFILE, "(Unknown)\n");
    }


fprintf(OFILE, "hrStorageDescr . . . . . \"%s\"\n",
        row->attrib_list[HRST_DESCR].u.string_value);

fprintf(OFILE, "hrStorageAllocationUnits %d\n",
        row->attrib_list[HRST_ALLOC].u.number_value);

fprintf(OFILE, "hrStorageSize. . . . . . %d\n",
        row->attrib_list[HRST_SIZE].u.number_value);

fprintf(OFILE, "hrStorageUsed. . . . . . %d\n",
        row->attrib_list[HRST_USED].u.number_value);

fprintf(OFILE, "hrStorageAllocationFails (Computed)\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrproces.c ===
/*
 *  HrProcessorEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrProcessorEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:42:19 1996
 *
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */
#include <stdio.h>

/*
|==============================================================================
| "Processor-Information Buffer" Definition
|
| This definition defines a logical "Processor Information Block" where we
| can store all the information returned from an NtQuerySystemInformation()
| call that requests "SystemProcessorPerformanceInformation" for each running
| processor.
*/
typedef
    struct  pi_block {
        struct pi_block  *other;      // Associated "other" buffer

        LARGE_INTEGER     sys_time;   // Time when "pi_array" was last
                                      //      refreshed in 100ns ticks

        SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
                          *pi_array;   // Array: One element per processor
        DWORD              pi_size;    // Size in bytes of "pi_array" storage
                      }
                       PI_BLOCK;

/*
|==============================================================================
| "Processor-Information Buffer" Instances
|
| We create two instances of a Processor Information Buffer, one for the
| "oldest" and a second for "newest" samples of timer values.  Maintaining 
| two enables us to compute the average over time for processor loads.
|
| These blocks are initialized by code in "Gen_HrProcessor_Cache()" in
| this module.
|
| These buffers are refreshed in an alternating manner by function
| "hrProcessLoad_Refresh()" (in this module) that itself is invoked on a
| timer-driven basis.  (See source for the function).
*/
static
PI_BLOCK        pi_buf1;        // First Buffer
static
PI_BLOCK        pi_buf2;        // Second Buffer 


/*
|==============================================================================
| Oldest "Processor-Information Buffer"
|
| This cell points at one of the two PI_BLOCKs above.  It always points to
| the buffer block that has the "oldest" data in it.
*/
static
PI_BLOCK       *oldest_pi=NULL;

#if defined(PROC_CACHE)         // For debug cache dump only
static
int             processor_count;
#endif


/*
 *  GetHrProcessorFrwID
 *    The product ID of the firmware associated with the processor.
 *    
 *    Gets the value for HrProcessorFrwID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrProcessorFrwID
 | 
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 | 
 | "The product ID of the firmware associated with the processor."
 | 
 | DISCUSSION:
 | 
 | <POA-11> The underlying syntax of this attribute is Object Identifier.  None
 | of the documented Win32 API functions seem capable of reporting this value.
 | We are allowed to report "unknownProductID"  ("0.0") in liew of the real
 | value, and this will be hardcoded unless an alternative is specified.
 | 
 | RESOLVED >>>>>>>>
 | <POA-11> Returning an unknown Product ID is acceptable.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.3.1.1.<instance>
 |                | | | |
 |                | | | *-hrProcessorFrwID
 |                | | *-hrProcessorEntry
 |                | *-hrProcessorTable
 |                *-hrDevice
 */

UINT
GetHrProcessorFrwID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0" 
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrProcessorFrwID() */


/*
 *  GetHrProcessorLoad
 *    The average, over the last minute, of the percentage of time that this 
 *    processor was not idle.
 *    
 *    Gets the value for HrProcessorLoad.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrProcessorLoad
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..100)
 | 
 | "The average, over the last minute, of the percentage of time that this
 | processor was not idle."
 | 
 | DISCUSSION:
 | 
 | <POA-12> It seems likely to me that this performance statistic might be
 | maintained or be derivable from performance information maintained in the
 | Registry.  Please describe.
 | 
 | RESOLVED >>>>>>>>
 | <POA-12> I think we should just use the PerfMon code for this.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | We reference a continuously updated module-local cache of CPU time-usage
 | info maintained in the buffer-blocks "pi_buf1" and "pi_buf2" defined
 | at the beginning of this module.  In the code below, we reach into these
 | caches and compute the processor load for the processor specified.
 |============================================================================
 | 1.3.6.1.2.1.25.3.3.1.2.<instance>
 |                | | | |
 |                | | | *-hrProcessorLoad
 |                | | *-hrProcessorEntry
 |                | *-hrProcessorTable
 |                *-hrDevice
 */

UINT
GetHrProcessorLoad( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure   */
CACHEROW        *row;           /* Row entry fetched from cache         */
ULONG           p;              /* Selected Processor (number from 0)   */
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
               *oldest, *newest;/* --> CPU data for "n" and "n+1minute" */
LONGLONG        llDendiff;      /* Difference Denominator               */
LONGLONG        llNewNum;       /* Numerator of Newest Time-count       */
LONGLONG        llOldNum;       /* Numerator of Oldest Time-count       */
double          fNum,fDen;      /* Floated versions of LONGLONGs        */
double          fload;          /* Percentage Load                      */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with "Gen_HrProcessor_Cache()" the cache initialization
| routine, the "hidden context" for devices which are "Processors" is
| the Processor Number, starting with 0.
*/
p = row->attrib_list[HIDDEN_CTX].u.unumber_value;


/*
| We compute the load using "SystemProcessorPerformanceInformation" that
| has been gathered for all processors in buffers maintained in "pi_buf1"
| and "pi_buf2".
|
| Obtain pointers to the "newest" and "oldest" slug of information for
| the specified processor out of "pi_buf1/2".
*/
oldest = &(oldest_pi->pi_array[p]);
newest = &(oldest_pi->other->pi_array[p]);


/*
| The performance info (as of this writing) we need comes from:
|
| typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
|     LARGE_INTEGER IdleTime;
|     LARGE_INTEGER KernelTime;
|     LARGE_INTEGER UserTime;
|     LARGE_INTEGER DpcTime;          // DEVL only
|     LARGE_INTEGER InterruptTime;    // DEVL only
|     ULONG InterruptCount;
| } ....
|
| where "IdleTime" is taken to be time spent by this processor in its
|                  idlethread.
|
|       "KernelTime" is taken to be total time spent by processor in kernel
|                  mode code (including the idle thread).
|
|       "UserTime" is taken to be total time spent by processor in user mode
|                  code.
|
| all in ticks of 100ns (one tenth of a millionth of a second).
|
| So total "Not-Idle" time is "(KernelTime-IdleTime) + UserTime" in ticks.
| Total time for the interval is the difference in the "sys_time" that is
| associated with each buffer ("oldest_pi->" and "oldest_pi->other->").
|
*/
llNewNum = (newest->KernelTime.QuadPart - newest->IdleTime.QuadPart)
                  + newest->UserTime.QuadPart;
llOldNum = (oldest->KernelTime.QuadPart - oldest->IdleTime.QuadPart)
                  + oldest->UserTime.QuadPart;

            /* (Newest System-Time)             -     (Oldest System-Time)  */
llDendiff = oldest_pi->other->sys_time.QuadPart - oldest_pi->sys_time.QuadPart;

/* If there will be no divide by 0 */
if ( llDendiff != 0 ) {

    /*
    | Now float these guys and convert to a percentage.
    */
    fNum = (double) (llNewNum - llOldNum);
    fDen = (double) llDendiff;

    fload = (fNum / fDen) * 100.0;
    }
else {
    fload = 0.0;
    }
 
*outvalue = (int) fload;      // Truncate to integer

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrProcessorLoad() */


/*
 *  HrProcessorEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrProcessorEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT            tmp_instance ;  /* Instance arc value                 */
    CACHEROW        *row;           /* Row entry fetched from cache       */

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRPROCESSORENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRPROCESSORENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRPROCESSORENTRY_VAR_INDEX ] ;

        /*
        | For hrProcessorTable, the instance arc(s) is a single arc, and 
        | it must correctly select an entry in the hrDeviceTable cache.
        |
        | Check that here.
        */
	if ( (row = FindTableRow(tmp_instance, &hrDevice_cache)) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
            /*
            | The instance arc selects an hrDeviceTable row entry, but is that
            | entry actually for a device of type "Processor"?
            |
            | (We examine the last arc of the OID that specifies the device
            |  type in the row entry selected by the instance arc).
            */
            if (row->attrib_list[HRDV_TYPE].u.unumber_value !=
                HRDV_TYPE_LASTARC_PROCESSOR) {

                return SNMP_ERRORSTATUS_NOSUCHNAME;
                }

	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrProcessorEntryFindInstance() */



/*
 *  HrProcessorEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrProcessorEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRPROCESSORENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRPROCESSORENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    /*
    | The instance arc selects an hrDeviceTable row entry, but is that
    | entry actually for a device of type "Processor"?
    |
    | (We examine the last arc of the OID that specifies the device
    |  type in the row entry selected by the instance arc).
    */
    do {
        if (row->attrib_list[HRDV_TYPE].u.unumber_value ==
            HRDV_TYPE_LASTARC_PROCESSOR) {

            /* Found an hrDeviceTable entry for the right device type */
            break;
            }

        /* Step to the next row in the table */
        row = GetNextTableRow( row );
        }
        while ( row != NULL );

    /* If we found a proper device-type row . . . */
    if ( row != NULL) {
        instance->ids[ 0 ] = row->index ;
        instance->idLength = 1 ;
        }
    else {

        /*
        | Fell off the end of the hrDeviceTable without finding a row
        | entry that had the right device type.
        */
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrProcessorEntryFindNextInstance() */



/*
 *  HrProcessorEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrProcessorEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrProcessorEntryConvertInstance() */




/*
 *  HrProcessorEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrProcessorEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrProcessor Table */
} /* end of HrProcessorEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */

BOOL
Gen_HrProcessor_Cache(
                      ULONG type_arc
                      )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the HrDevice cache has been fully
|       populated with all rows required for Processor devices.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" to
|       populate the cache for the HrDevice table with processor-specific
|       entries.
|
|  OTHER THINGS TO KNOW:
|
|       This function is loading entries into the existing HrDevice cache
|       for devices of type "processor" as well as setting up what logically
|       amounts to a "cache" of information used to compute the value of
|       hrProcessorLoad.
|
|       Specifically, this function initializes module-local cells that
|       describe buffers containing processor-time information for each
|       processor.
|
|       This function holds a convention with the GET routines earlier in
|       this module that the "HIDDEN_CTX" attribute for processors contains
|       a number that can be used to select which processor information
|       is to be returned.  We generate this number here.
|============================================================================
| 1.3.6.1.2.1.25.3.3.1...
|                | | |
|                | | *hrProcessorEntry
|                | *hrProcessorTable
|                *-hrDevice
|
*/
{
SYSTEM_INFO     sys_info;       /* Filled in by GetSystemInfo for processors */
UINT            i;              /* Handy-Dandy loop index                    */
char           *descr;          /* Selected description string               */


/* Acquire system information statistics */
GetSystemInfo(&sys_info);

/*
| Build a description based on the system info.  We presume all processors
| are identical.
*/
switch (sys_info.wProcessorArchitecture) {


    case PROCESSOR_ARCHITECTURE_INTEL:
        switch (sys_info.wProcessorLevel) {
            case 3:     descr = "Intel 80386";     break;
            case 4:     descr = "Intel 80486";     break;
            case 5:     descr = "Intel Pentium";   break;
            default:    descr = "Intel";           break;
            }
        break;
                
    case PROCESSOR_ARCHITECTURE_ALPHA:
        switch (sys_info.wProcessorLevel) {
            case 21064: descr = "Alpha 21064";     break;
            case 21066: descr = "Alpha 21066";     break;
            case 21164: descr = "Alpha 21164";     break;
            default:    descr = "DEC Alpha";       break;
            }
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        switch (sys_info.wProcessorLevel) {
            case 4:     descr = "MIPS R4000";     break;
            default:    descr = "MIPS";           break;
            }
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        switch (sys_info.wProcessorLevel) {
            case 1:     descr = "PPC 601";       break;
            case 3:     descr = "PPC 603";       break;
            case 4:     descr = "PPC 604";       break;
            case 6:     descr = "PPC 603+";      break;
            case 9:     descr = "PPC 604+";      break;
            case 20:    descr = "PPC 620";       break;
            default:    descr = "PPC";           break;
            }
        break;
    
    case PROCESSOR_ARCHITECTURE_UNKNOWN:
    default:
        descr = "Unknown Processor Type";
    }

/*
| For every processor we have in the system, fill in a row in the hrDevice
| table.
*/
for (i = 0; i < sys_info.dwNumberOfProcessors; i += 1) {

    /*
    | "Hidden Context" is a generated number starting at 0 which we'll
    | consider to be the processor number..
    */

    if (AddHrDeviceRow(type_arc,        // DeviceType OID Last-Arc
                       descr,           // Device Description
                       &i,              // Hidden Ctx "Processor #"
                       CA_NUMBER        // Hidden Ctx type
                       ) == NULL ) {

        /* Something blew */
        return ( FALSE );
        }
    }

/*
| Now initialize the PI_BLOCK instances needed to compute the hrProcessorLoad
| and the pointer to the PI_BLOCK instance that is to be considered the
| "oldest".
*/

/*
| Storage for both buffers. . . .*/
pi_buf1.pi_size = sys_info.dwNumberOfProcessors *
                  sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
if ((pi_buf1.pi_array = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                        malloc(pi_buf1.pi_size)) == NULL) {
    return ( FALSE );  // Out of Memory
    }

pi_buf2.pi_size = sys_info.dwNumberOfProcessors *
                  sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
if ((pi_buf2.pi_array = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                        malloc(pi_buf2.pi_size)) == NULL) {
    return ( FALSE );  // Out of Memory
    }

/*
| Now "hook" the two buffer blocks together so we can switch between them
| symmetrically.
*/
pi_buf1.other = &pi_buf2;
pi_buf2.other = &pi_buf1;

#if defined(PROC_CACHE)         // For debug cache dump only
processor_count = sys_info.dwNumberOfProcessors;
#endif

/*
| Pretend the first is the oldest and get it refreshed.
*/
oldest_pi = &pi_buf1;     // Select it
hrProcessLoad_Refresh();  // Refresh it, and select the other as "oldest"

SleepEx(1, FALSE);        // Pause one millisecond to avoid divide by 0
hrProcessLoad_Refresh();  // Refresh the second and select other as "oldest"

/*
| Now each Processor Information Block contains full information (about
| all processors) separated in time by 1 millisecond.  The "oldest" will
| be refreshed periodically every minute by the timer which is initialized
| via a call to "TrapInit()" made from source "mib.c" after the initialization
| of caches is complete.  Once the timer begins ticking regularly, the time
| samples in these two PI_BLOCK buffers will differ by one minute, (the period
| of the timer) which is the period required by the definition of
| "hrProcessorLoad".
*/


return ( TRUE );
}


/* hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine */
/* hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine */
/* hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine */

void
hrProcessLoad_Refresh(
                      void
                      )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The "Processor-Information Buffer" specified by module-local cell
|       "oldest_pi" is refreshed with new time information fetched from
|       the kernel.
|
|  OUTPUTS:
|
|     On Success:
|       The PI_Block specified by "oldest_pi" is refreshed and "oldest_pi"
|       is set to point to the other PI_BLOCK.
|
|     On any Failure:
|       Function simply returns.
|
|  THE BIG PICTURE:
|
|       At subagent startup time, a timer is created by code in "TrapInit()"
|       set to "tick" at an interval of one minute.
|
|       Each time the timer goes off, the SNMP Agent calls the 
|       "SnmpExtensionTrap()" standard entry point for the sub agent.  Rather
|       than handle a trap, that function will invoke this function which
|       gathers CPU performance data so that the hrProcessLoad value can be
|       properly computed.
|
|  OTHER THINGS TO KNOW:
|
|       We alternate the buffer into which the newest CPU data is placed
|       by simply changing "oldest_pi" (each time we're invoked) to point
|       to the "other" buffer after we're done refreshing the oldest buffer.
|       In this manner, we always have two buffers of Processor Load info
|       allowing us to compute the load during the times associated with
|       those two buffers.
*/
{
NTSTATUS        ntstatus;
DWORD           bytesused;


/* Get the current system-time in 100ns intervals . . .*/
ntstatus = NtQuerySystemTime (&oldest_pi->sys_time);

/*
| . . . and as rapidly thereafter refresh the oldest buffer with information
|       on all processors */
ntstatus = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                    oldest_pi->pi_array,
                                    oldest_pi->pi_size,
                                    &bytesused);

#if defined(PROC_CACHE)
/* =========================== DEBUG DUMP ================================== */
    {
    FILE            *pfile;                 /* Dump goes here        */
    time_t          ltime;                  /* For debug message     */
    int             i;                      /* Loop index            */
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
                    *oldest, *newest;/* --> CPU data for "n" and "n+1minute" */


    if ((pfile=fopen(PROC_FILE, "a+")) != NULL) {

        time( &ltime);
        fprintf(pfile, "\n=============== Open for appending: %s", ctime( &ltime ));

        fprintf(pfile, "Periodic Refresh of \"oldest_pi\" @ %x\n", oldest_pi);

        /* For each processor . . . */
        for (i=0; i < processor_count; i += 1) {

            fprintf(pfile, "For Processor %d:\n", i);

            oldest = &(oldest_pi->pi_array[i]);
            //newest = &(oldest_pi->other->pi_array[i]);

            fprintf(pfile, "  IdleTime   = (HI) %x  (LO) %x\n",
                    oldest->IdleTime.HighPart, oldest->IdleTime.LowPart);
            fprintf(pfile, "  KernelTime = (HI) %x  (LO) %x\n",
                    oldest->KernelTime.HighPart, oldest->KernelTime.LowPart);
            fprintf(pfile, "  UserTime   = (HI) %x  (LO) %x\n",
                    oldest->UserTime.HighPart, oldest->UserTime.LowPart);
            }
        }

    fclose(pfile);
    }
/* =========================== DEBUG DUMP ================================== */
#endif

/* Now the other buffer contains the "oldest" data, so change "oldest_pi" */
oldest_pi = oldest_pi->other;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrstorag.c ===
/*
 *  HrStorage.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrStorage.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/17/97  D. D. Burns Original Creation: Thu Nov 07 16:39:42 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */


/*
 *  GetHrMemorySize
 *    The amount of physical main memory contained by the host.
 *
 *    Gets the value for HrMemorySize.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrMemorySize
 |
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 |
 | "The amount of physical main memory contained by the host."
 |
 | DISCUSSION:
 |
 | Win32 API function "GlobalMemoryStatus" is invoked and the value returned
 | in structure MEMORYSTATUS for cell "dwTotalPhys" is used to compute the value
 | returned for this attribute.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.2.2.0
 |                | |
 |                | *-hrMemorySize
 |                *-hrStorage
 */

UINT
GetHrMemorySize(
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
MEMORYSTATUS    mem_status;     /* For "GlobalMemoryStatus()" call */

    /* Get the "mem_status" structure filled in */
    GlobalMemoryStatus(&mem_status);

    /* Return total available physical bytes reduced to 1024 blocks */
    *outvalue = (KBytes)(mem_status.dwTotalPhys / 1024);

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrMemorySize() */


/*
 *  HrStorageFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.
    //  However, if there is any context that needs to be set, it can be done
    //  here.

    if ( FullOid->idLength <= HRSTORAGE_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSTORAGE_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSTORAGE_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageFindInstance() */



/*
 *  HrStorageFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then
    //  NOSUCHNAME is returned so that correct MIB rollover processing occurs.
    //
    //  If this is a table, then the next instance is the one following the
    //  current instance.
    //
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSTORAGE_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageFindNextInstance() */



/*
 *  HrStorageConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrStorageConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrStorageConvertInstance() */




/*
 *  HrStorageFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrStorageFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrStorageFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrswrune.c ===
/*
 *  HrSWRunEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWRunEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 05/14/97  D. D. Burns     Genned: Thu Nov 07 16:47:29 1996
 *
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file    */
#include "HMCACHE.H"      /* Cache-related definitions          */
#include <string.h>



/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table cache */
static BOOL
AddHrSWRunRow(PSYSTEM_PROCESS_INFORMATION ProcessInfo);

/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */
void
FetchProcessParams(
PSYSTEM_PROCESS_INFORMATION ProcessInfo,   /* Process for parameters     */
CHAR                      **path_str,      /* Returned PATH string       */
CHAR                      **params_str     /* Returned Parameters string */
              );

#if defined(CACHE_DUMP)

/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */
static void
debug_print_hrswrun(
                     CACHEROW     *row  /* Row in hrSWRun(Perf) table */
                     );
#endif


/*
|==============================================================================
| Cache Refresh Time
|
| The cache for the hrSWRun and hrSWRunPerf tables is refreshed automatically
| when a request arrives --AND-- the cache is older than CACHE_MAX_AGE
| in seconds.
|
*/
static
LARGE_INTEGER   cache_time;   // 100ns Timestamp of cache (when last refreshed)

#define CACHE_MAX_AGE 120     // Maximum age in seconds


/*
|==============================================================================
| Create the list-head for the HrSWRun(Perf) Table cache.
|
| This cache contains info for both the hrSWRun and hrSWRunPerf tables.
| (This macro is defined in "HMCACHE.H").
|
| This is global so code for the hrSWRunPerf table ("HRSWPREN.C") can
| reference it.
*/
CACHEHEAD_INSTANCE(hrSWRunTable_cache, debug_print_hrswrun);



/*
|==============================================================================
| Operating System Index
|
|  SNMP attribute "HrSWOSIndex" is the index into hrSWRun to the entry that
|  primary operating system running on the host.  This value is computed in
|  this module in function "AddHrSWRunRow()" and stored here for reference
|  by code in "HRSWRUN.C".
*/
ULONG   SWOSIndex;



/*
 *  GetHrSWRunIndex
 *    A unique value for each piece of software running on the host.  Wherever
 *    possible, this should be the system's native, unique id
 *
 *    Gets the value for HrSWRunIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunIndex
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "A unique value for each piece of software running on the host.  Wherever
 | possible, this should be the system's native, unique identification number."
 |
 | DISCUSSION:
 |
 | By using performance monitoring information from the Registry (using code
 | from "PVIEW") this attribute is given the value of the Process ID.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.1.<instance>
 |                | | | |
 |                | | | *-hrSWRunIndex
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunIndex(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSR_INDEX].u.number_value;
return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunIndex() */


/*
 *  GetHrSWRunName
 *    A textual description of this running piece of software, including the
 *    manufacturer, revision, and the name by which it is commo
 *
 *    Gets the value for HrSWRunName.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunName
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE (0..64))
 |
 | "A textual description of this running piece of software, including the
 | manufacturer, revision, and the name by which it is commonly known.  If this
 | software was installed locally, this should be the same string as used in the
 | corresponding hrSWInstalledName."
 |
 | DISCUSSION:
 |
 | By using performance monitoring information from the Registry (using code
 | from "PVIEW") this attribute is given the value of the Process name.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.2.<instance>
 |                | | | |
 |                | | | *-hrSWRunName
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunName(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Return the name that was computed at cache-build time */
outvalue->length = strlen(row->attrib_list[HRSR_NAME].u.string_value);
outvalue->string = row->attrib_list[HRSR_NAME].u.string_value;
if (outvalue->length > 64) {
    outvalue->length = 64;      /* Truncate */
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunName() */


/*
 *  GetHrSWRunID
 *    The product ID of this running piece of software.
 *
 *    Gets the value for HrSWRunID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunID
 |
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 |
 | "The product ID of this running piece of software."
 |
 | DISCUSSION:
 |
 | <POA-16> I anticipate always using "unknownProduct" as the value for this
 | attribute, as I can envision no systematic means of acquiring a registered
 | OID for all process software to be used as the value for this attribute.
 |
 | RESOLVED >>>>>>>
 | <POA-16> Returning an unknown Product ID is acceptable.
 | RESOLVED >>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.3.<instance>
 |                | | | |
 |                | | | *-hrSWRunID
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunID(
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0"
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunID() */


/*
 *  GetHrSWRunPath
 *    A description of the location on long-term storage (e.g. a disk drive)
 *    from which this software was loaded.
 *
 *    Gets the value for HrSWRunPath.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunPath
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 |
 | "A description of the location on long-term storage (e.g. a disk drive) from
 | which this software was loaded."
 |
 | DISCUSSION:
 |
 | <POA-17> This information is not extracted by the sample PVIEW code from the
 | performance monitoring statistics kept in the Registry.  If this information
 | is available from the Registry or some other source, I need to acquire the
 | description of how to get it.
 |
 | RESOLVED >>>>>>>>
 | <POA-17> This is obtained using PerfMon code pointers provided by Bob Watson.
 | RESOLVED >>>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.4.<instance>
 |                | | | |
 |                | | | *-hrSWRunPath
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunPath(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the Path string that was computed at cache-build time.
| NOTE: This string might be NULL.
*/
if (row->attrib_list[HRSR_PATH].u.string_value == NULL) {
    outvalue->length = 0;
    }
else {
    outvalue->length = strlen(row->attrib_list[HRSR_PATH].u.string_value);
    outvalue->string = row->attrib_list[HRSR_PATH].u.string_value;
    if (outvalue->length > 128) {
        outvalue->length = 128;      /* Truncate */
        }
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunPath() */

/*
 *  GetHrSWRunParameters
 *
 *    A description of the parameters supplied to this software when it was
 *    initially loaded."
 *
 *    Gets the value for HrSWRunParameters.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunParameters
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 |
 | "A description of the parameters supplied to this software when it was
 | initially loaded."
 |
 | DISCUSSION:
 |
 | <POA-18> This information is not extracted by the sample PVIEW code from the
 | performance monitoring statistics kept in the Registry.  If this information
 | is available from the Registry or some other source, I need to acquire the
 | description of how to get it.
 |
 | RESOLVED >>>>>>>>
 | <POA-18> See discussion for "hrSWRunPath" above.
 | RESOLVED >>>>>>>>
 |
 |============================================================================
 | NOTE: This function edited in by hand, as it was not originally generated.
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.5.<instance>
 |                | | | |
 |                | | | *-hrSWRunParameters
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunParameters(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the Parameter string that was computed at cache-build time.
| NOTE: This string might be NULL.
*/
if (row->attrib_list[HRSR_PARAM].u.string_value == NULL) {
    outvalue->length = 0;
    }
else {
    outvalue->length = strlen(row->attrib_list[HRSR_PARAM].u.string_value);
    outvalue->string = row->attrib_list[HRSR_PARAM].u.string_value;
    if (outvalue->length > 128) {
        outvalue->length = 128;      /* Truncate */
        }
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunParameters() */


/*
 *  GetHrSWRunType
 *    The type of this software.
 *
 *    Gets the value for HrSWRunType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunType
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {unknown(1),operatingSystem(2),deviceDriver(3),
 |                           application(4)}
 |
 | "The type of this software."
 |
 | DISCUSSION:
 |
 | <POA-19> This information is not extracted by the sample PVIEW code from the
 | performance monitoring statistics kept in the Registry.  If this information
 | is available from the Registry or some other source, I need to acquire the
 | description of how to get it.
 |
 | >>>>>>>>
 | <POA-19>  I am not sure whether this information is included in the perfmon
 | data block. I will investigate further.
 | >>>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.6.<instance>
 |                | | | |
 |                | | | *-hrSWRunType
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunType(
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSR_TYPE].u.number_value;
return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunType() */


/*
 *  GetHrSWRunStatus
 *    The status of this running piece of software.  Setting this value to
 *    invalid(4) shall cause this software to stop running and be
 *
 *    Gets the value for HrSWRunStatus.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunStatus
 |
 |  ACCESS         SYNTAX
 |  read-write     INTEGER {
 |                         running(1),
 |                         runnable(2), -- waiting for resource (CPU, memory, IO)
 |                         notRunnable(3), -- loaded but waiting for event
 |                         invalid(4)      -- not loaded
 |                         }
 |
 | "The status of this running piece of software.  Setting this value to
 | invalid(4) shall cause this software to stop running and to be unloaded."
 |
 | DISCUSSION:
 |
 | <POA-20> For an SNMP "GET" on this attribute, this information is not extracted
 | by the sample PVIEW code from the performance monitoring statistics kept in
 | the Registry.  If this information is available from the Registry or some
 | other source, I need to acquire the description of how to get it.
 |
 | RESOLVED >>>>>>>
 | <POA-20>  I think running and notRunnable will be all that are applicable
 | here (that latter being returned in situations which are currently labeled
 | "not responding").
 | RESOLVED >>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.7.<instance>
 |                | | | |
 |                | | | *-hrSWRunStatus
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunStatus(
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSR_STATUS].u.number_value;
return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunStatus() */


/*
 *  SetHrSWRunStatus
 *    The status of this running piece of software.  Setting this value to
 *    invalid(4) shall cause this software to stop running and be
 *
 *    Sets the HrSWRunStatus value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrSWRunStatus(
        IN INThrSWRunStatus *invalue ,
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrSWRunStatus() */


/*
 *  HrSWRunEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWRUNENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWRUNENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWRUNENTRY_VAR_INDEX ] ;

        /*
        | Check for age-out and possibly refresh the entire cache for the
        | hrSWRun table before we check to see if the instance is there.
        */
        if (hrSWRunCache_Refresh() == FALSE) {
            return SNMP_ERRORSTATUS_GENERR;
            }

        /*
        | For hrSWRun, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrSWRun Table cache.
        | Check that here.
        */
	if ( FindTableRow(tmp_instance, &hrSWRunTable_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunEntryFindInstance() */



/*
 *  HrSWRunEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSWRUNENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSWRUNENTRY_VAR_INDEX ] ;
        }

    /*
    | Check for age-out and possibly refresh the entire cache for the
    | hrSWRun table before we check to see if the instance is there.
    */
    if (hrSWRunCache_Refresh() == FALSE) {
        return SNMP_ERRORSTATUS_GENERR;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrSWRunTable_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunEntryFindNextInstance() */



/*
 *  HrSWRunEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWRunEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrSWRunEntryConvertInstance() */




/*
 *  HrSWRunEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWRunEntryFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWRunEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table */
/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table */
/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table */

BOOL
Gen_HrSWRun_Cache(
                  void
                  )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrSWRun table,
|       "hrSWRunTable_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.  This function populates
|       the hrSWRun Table cache, but this cache also includes the two
|       attributes for the hrSWRunPerf Table.  So in effect, one cache serves
|       two tables, but the hrSWRunPerf table is a "one-to-one" extension
|       of hrSWRun table.. that is a row in hrSWRun always has a corresponding
|       "two-entry" row in hrSWRunPerf.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in  "UserMibInit()" ("MIB.C")  to
|       populate the cache for the HrSWRun table (which also serves the
|       hrSWRunPerf Table).
|
|       It is also re-entered whenever a request for information from this
|       cache comes in and the cache is older than a certain age (symbol
|       "CACHE_MAX_AGE" defined at the beginning of this module).  In this
|       case the cache is rebuilt, and in this way this function is different
|       from all the other "Gen_*_Cache()" functions which only build their
|       caches once (in the initial release).
|
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each cachehead is found in the respective table's source file.
|
|       The strategy on getting running software enumerated revolves around
|       NtQuerySystemInformation(SystemProcessInformation...) invocation.
|
|       Once we have a list of processes, additional information (such as
|       the parameters on the command-line) are fetched by opening the
|       process (if possible) and reading process memory.
|
|       Note that unlike the other cache's in the initial release, this cache
|       for hrSWRun and hrSWRunPerf is updated before it is read if it is
|       older than a specified period of time (set by #define at the beginning
|       of this file).
|
|============================================================================
| 1.3.6.1.2.1.25.4.1.0
|                | |
|                | *-hrSWOSIndex
|                *-hrSWRun
|
| 1.3.6.1.2.1.25.4.2.1..
|                | | |
|                | | *-hrSWRunEntry
|                | *-hrSWRunTable
|                *-hrSWRun
*/
#define LARGE_BUFFER_SIZE       (4096*8)
#define INCREMENT_BUFFER_SIZE   (4096*2)
{
static                             /* Initial ProcessBuffer size        */
DWORD      ProcessBufSize = LARGE_BUFFER_SIZE;
static
LPBYTE     pProcessBuffer = NULL;  /* Re-used and re-expanded as needed */

PSYSTEM_PROCESS_INFORMATION
           ProcessInfo;            /* --> Next process to process       */
ULONG      ProcessBufferOffset=0;  /* Accumulating offset cell          */
NTSTATUS   ntstatus;               /* Generic return status             */
DWORD      dwReturnedBufferSize;   /* From NtQuerySystemInformation()   */


/*
| Blow away any old copy of the cache
*/
DestroyTable( &hrSWRunTable_cache );


/*
| Grab an initial buffer for Process Information
*/
if (pProcessBuffer == NULL) {
    /* allocate a new block */
    if ((pProcessBuffer = malloc ( ProcessBufSize )) == NULL) {
        return ( FALSE );
        }
    }


/*
| Go for a (new/refreshed) buffer of current Process Info
*/
while( (ntstatus = NtQuerySystemInformation(
                                            SystemProcessInformation,
                                            pProcessBuffer,
                                            ProcessBufSize,
                                            &dwReturnedBufferSize
                                            )
        ) == STATUS_INFO_LENGTH_MISMATCH ) {

    /* expand buffer & retry */
    ProcessBufSize += INCREMENT_BUFFER_SIZE;

    if ( !(pProcessBuffer = realloc(pProcessBuffer,ProcessBufSize)) ) {
        return ( FALSE );
        }
    }

/*
| Freshen the time on the cache
|
| Get the current system-time in 100ns intervals . . . */
ntstatus = NtQuerySystemTime (&cache_time);


/*
| Loop over each instance of Process Information in the ProcessBuffer
| and build a row in the cache for hrSWRun and hrSWRunPerf tables.
*/
for (ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;
     ;  /* Exit check below */
     ProcessBufferOffset += ProcessInfo->NextEntryOffset,
     ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset]
     ) {

    /* Add a Row to the cache */
    if (AddHrSWRunRow(ProcessInfo) != TRUE) {
        return ( FALSE );       // Out of memory
        }

    /* If this is the last process, bag it */
    if (ProcessInfo->NextEntryOffset == 0) {
        break;
        }
    }

#if defined(CACHE_DUMP)
PrintCache(&hrSWRunTable_cache);
#endif

/* Cache (re)-build successful */
return ( TRUE );
}

/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table */
/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table */
/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table */

static BOOL
AddHrSWRunRow(

PSYSTEM_PROCESS_INFORMATION ProcessInfo   /* --> Next process to process */

              )

/*
|  EXPLICIT INPUTS:
|
|       "ProcessInfo" points to the next process (as described by a
|       SYSTEM_PROCESS_INFORMATION structure) for which a row is to be
|       inserted into the HrSWRun(Perf) table cache.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDevice table,
|       "hrSWRunTable_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function creates a new row entry populated with all "static" cache-able
|       values for HrSWRun(Perf) table and returns TRUE.  Note that if the
|       process is the "System Process", the row entry index is stored in
|       module cell "SWOSIndex" for reference by code in "HRSWRUN.C".
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the cache-build code in "Gen_HrSWRun_Cache()" above.
|
|  OTHER THINGS TO KNOW:
|
|    The cache being (re)built by this function serves two tables, hrSWRun
|    and hrSWRunPerf.
|
|    In general, we use the Process's "ProcessID" as the index in the
|    hrSWRun(Perf) table.  However special handling is done for the Idle
|    Process because it's Process ID is zero.   We convert it to "1" to meet
|    the SNMP requirement that indexes be greater than zero.  We note that
|    as of this writing, no process id of 1 is seen in build 1515 (the "System"
|    process has a processID of 2).
|
|    The "type" of software can be unknown(1), operatingSystem(2),
|    deviceDriver(3) and application(4).  We only detect the Idle and System
|    processes (by their names) as "operatingSystem(2)", everything else
|    is presumed "application(4)".
|
|    As for "status", it can be running(1), runnable(2), notRunnable(3) or
|    invalid(4).  If the number of threads is greater than 0, it is presumed
|    "running(1)", otherwise "invalid(4)".
*/
#define ANSI_PNAME_LEN 256
{
ANSI_STRING     pname;          /* ANSI version of UNICODE process name    */
CHAR            pbuf[ANSI_PNAME_LEN+1];    /* Buffer for "pname"           */
CHAR           *pname_str;      /* Pointer to our final process name       */
CHAR           *path_str=NULL;  /* Pointer to our Path name                */
CHAR           *params=NULL;    /* Pointer to any parameters fnd on cmdline*/
UINT            type;           /* SNMP code for type of software          */
UINT            status;         /* SNMP code for the status of software    */
CACHEROW        *row;           /* --> Cache structure for row-being built */


/*
| OK, the caller wants another row in the table, get a row-entry created.
*/
if ((row = CreateTableRow( HRSR_ATTRIB_COUNT ) ) == NULL) {
    return ( FALSE );       // Out of memory
    }

/*
| Set up the standard-hrSWRun(Perf) attributes in the new row
*/

type = 4;       /* Presume "application(4)" type software */

if (ProcessInfo->NumberOfThreads > 0) {
    status = 1;     /* Presume "running(1)" for software status */
    }
else {
    status = 4;     /* "invalid(4)", process on the way out */
    }

/* =========== HrSWRunIndex ==========*/
row->attrib_list[HRSR_INDEX].attrib_type = CA_NUMBER;
row->attrib_list[HRSR_INDEX].u.unumber_value =
                                   HandleToUlong(ProcessInfo->UniqueProcessId) ;

/* Special check for system idle process, roll it from 0 to 1 */
if (ProcessInfo->UniqueProcessId == 0) {
    row->attrib_list[HRSR_INDEX].u.unumber_value = 1;
    }



/* =========== HrSWRunName ==========*/
row->attrib_list[HRSR_NAME].attrib_type = CA_STRING;

/* If we actually have a process name for this process . . . */
if (ProcessInfo->ImageName.Buffer != NULL) {

    /* Prep the STRING structure */
    pname.Buffer = pbuf;
    pname.MaximumLength = ANSI_PNAME_LEN;

    /* Convert from Unicode */
    RtlUnicodeStringToAnsiString(&pname,               // Target string
                                 (PUNICODE_STRING)&ProcessInfo->ImageName,//Src
                                 FALSE);               // = Don't Allocate buf
    /*
    | Here we parse not only the process name but any path that may be
    | prepended to it.  (We make no attempt to eliminate any ".EXE" that
    | may be on the end of the image name).
    |
    | NOTE: If you are going to rip off this code, be aware that as-of
    |       build 1515, we NEVER seem to get an image name that has the
    |       path prepended on the front... so most of this code to skip
    |       the possibly-present path is almost certainly superfluous.
    */

    /* Try to "backup" until we hit any "\" */
    if ( (pname_str = strrchr(pname.Buffer,'\\')) != NULL) {
        pname_str++;                     /* Pop to first char after "\" */
        }
    else {
        pname_str = pname.Buffer;        /* Use entire string, no "\" found */

        /*
        | A piece of software with no path means it could be the "System"
        | process.  Check for that here.
        */
        if (strcmp(pname_str, "System") == 0) {
            type = 2;   /* Mark the software as "operatingSystem(2)" type */

            /*
            | We're processing the main System Process, so record it's index
            | in module-level cell for reference from "HRSWRUN.C".
            */
            SWOSIndex = row->attrib_list[HRSR_INDEX].u.unumber_value;
            }
        }
    }
else {
    /* The system idle process has no name */
    pname_str = "System Idle Process";
    type = 2;             /* Mark the software as "operatingSystem(2)" type */
    }

/* Allocate cache storage and copy the process name to it */
if ( (row->attrib_list[HRSR_NAME].u.string_value
      = ( LPSTR ) malloc(strlen(pname_str) + 1)) == NULL) {
    return ( FALSE );       /* out of memory */
    }
strcpy(row->attrib_list[HRSR_NAME].u.string_value, pname_str);

/*
| We bother to do the overhead of trying to extract path & parameters from
| the command-line that started the process by reading process memory
| only if the type of the software is "application(4)" and status is
| "runnable(2)".
*/
if (status == 2 && type == 4) {  /* If it is a runnable application . . . */

    FetchProcessParams(ProcessInfo, &path_str, &params);
    }


/* =========== HrSWRunPath ==========*/
row->attrib_list[HRSR_PATH].attrib_type = CA_STRING;
row->attrib_list[HRSR_PATH].u.string_value = NULL;

/* If we did detect a path . . . */
if (path_str != NULL) {

    /* Allocate cache storage and copy the path string to it */
    if ( (row->attrib_list[HRSR_PATH].u.string_value
          = ( LPSTR ) malloc(strlen(path_str) + 1)) == NULL) {
        return ( FALSE );       /* out of memory */
        }
    strcpy(row->attrib_list[HRSR_PATH].u.string_value, path_str);
    }


/* =========== HrSWRunParameters ==========
row->attrib_list[HRSR_PARAM].attrib_type = CA_STRING;
row->attrib_list[HRSR_PARAM].u.string_value = NULL;    /* In case of none */

/* If we did find parameters . . . */
if (params != NULL) {

    /* Allocate cache storage and copy the parameter string to it */
    if ( (row->attrib_list[HRSR_PARAM].u.string_value
          = ( LPSTR ) malloc(strlen(params) + 1)) == NULL) {
        return ( FALSE );       /* out of memory */
        }
    strcpy(row->attrib_list[HRSR_PARAM].u.string_value, params);
    }


/* =========== HrSWRunType ========== */
row->attrib_list[HRSR_TYPE].attrib_type = CA_NUMBER;
row->attrib_list[HRSR_TYPE].u.unumber_value = type;


/* =========== HrSWRunStatus ========== */
row->attrib_list[HRSR_STATUS].attrib_type = CA_NUMBER;
row->attrib_list[HRSR_STATUS].u.unumber_value = status;

/*
| For hrSWRunPerf Table:
*/

/* =========== HrSWRunPerfCPU ==========
| UserTime + KernelTime are in 100ns (1/10th of a millionth of a second)
| units and HrSWRunPerfCPU is supposed to be in 1/100th of a second units.
|
| So .01        - second intervals
| is .010 000 0 - 100nanoseconds intervals,
|
| so dividing 100ns intervals by 100,000 gives centi-seconds.
*/

row->attrib_list[HRSP_CPU].attrib_type = CA_NUMBER;
row->attrib_list[HRSP_CPU].u.unumber_value = (ULONG)
((ProcessInfo->UserTime.QuadPart + ProcessInfo->KernelTime.QuadPart) / 100000);


/* =========== HrSWRunPerfMem ========== */
row->attrib_list[HRSP_MEM].attrib_type = CA_NUMBER;
row->attrib_list[HRSP_MEM].u.unumber_value =
                                           (ULONG)(ProcessInfo->WorkingSetSize / 1024);


/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrSWRun(Perf) Table.
*/
if (AddTableRow(row->attrib_list[HRSR_INDEX].u.unumber_value,  /* Index */
                row,                                           /* Row   */
                &hrSWRunTable_cache                            /* Cache */
                ) == FALSE) {
    return ( FALSE );       /* Internal Logic Error! */
    }

return ( TRUE );
}

/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */
/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */
/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */

BOOL
hrSWRunCache_Refresh(
                     void
                     )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The "hrSWRunTable_cache" CACHEHEAD structure and the time when
|       it was last refreshed in module-local cell "cache_time".
|
|  OUTPUTS:
|
|     On Success/Failure:
|       The function returns TRUE.  Only if the cache-time has aged-out
|       is the cache actually rebuilt.
|
|     On any Failure:
|       If during a rebuild there is an error, this function returns FALSE.
|       The state of the cache is indeterminate.
|
|  THE BIG PICTURE:
|
|       This function is invoked before any reference is made to any SNMP
|       variable in the hrSWRun or hrSWRunPerf table.  It checks to see
|       if the cache needs to be rebuilt based on the last time it was built.
|
|       The calls to this function are strategically located in the
|       "FindInstance" and "FindNextInstance" functions in "HRSWRUNE.C"
|       (this module) and "HRSWPREN.C" (for the RunPerf table) as well
|       as in "HRSWRUN.C" for the stand-alone attribute "hrSWOSIndex".
|
|  OTHER THINGS TO KNOW:
|
*/
{
LARGE_INTEGER   now_time;       /* Current System time in 100 ns ticks */


/* Get the current time in 100 ns ticks*/
NtQuerySystemTime (&now_time);

/* If the cache is older than the maximum allowed time (in ticks) . . .  */
if ( (now_time.QuadPart - cache_time.QuadPart) > (CACHE_MAX_AGE * 10000000) ){
    return ( Gen_HrSWRun_Cache() );
    }

return ( TRUE );        /* No Error (because no refresh) */
}

/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */
/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */
/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */

void
FetchProcessParams(

PSYSTEM_PROCESS_INFORMATION ProcessInfo,    /* Process for parameters     */
CHAR                      **path_str,       /* Returned PATH string       */
CHAR                      **params_str      /* Returned Parameters string */
              )
/*
|  EXPLICIT INPUTS:
|
|       "ProcessInfo" points to the process (as described by a
|       SYSTEM_PROCESS_INFORMATION structure) for which the path & parameters
|       (from the command-line) are desired.
|
|       "path_str" is the address of a pointer to be set to any "path" string.
|       "params" is the address of a pointer to be set to any "parameters"
|        string.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns pointers to a static buffer containing the
|       path & parameters section of the command line.  There may be nothing
|       in the buffer (ie just the null-termination).
|
|     On any Failure:
|       Function returns NULLS indicating a problem was encountered
|       attempting to obtain the command-line image from which the
|       path & parameter portion is to be extracted, or indicating that
|       one or both were not present.
|
|  THE BIG PICTURE:
|
|       Called from "AddHrSWRunRow()" above, this is a helper function
|       that serves to isolate the code lifted from "TLIST" from
|       the rest of the subagent.
|
|  OTHER THINGS TO KNOW:
|
|    The black magic here was lifted from sections of "TLIST".
*/
{
HANDLE                      hProcess;
PEB                         Peb;
NTSTATUS                    Status;
PROCESS_BASIC_INFORMATION   BasicInfo;
WCHAR                       szT[MAX_PATH * 2];
UNICODE_STRING              u_param;
RTL_USER_PROCESS_PARAMETERS ProcessParameters;

#define ANSI_PARAM_LEN (MAX_PATH * 2)
ANSI_STRING     param;          /* ANSI version of UNICODE command line    */
static
CHAR            pbuf[ANSI_PARAM_LEN+1];    /* Buffer for "parameters"      */
CHAR           *param_str;      /* Pointer to our final parameter string   */
SIZE_T          dwbytesret;     /* Count of bytes read from process memory */


/* Presume failure/nothing obtained */
*path_str = NULL;
*params_str = NULL;

/* get a handle to the process */
hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                       FALSE,
                       HandleToUlong(ProcessInfo->UniqueProcessId));
if (!hProcess) {
    return;
    }


Status = NtQueryInformationProcess(hProcess, ProcessBasicInformation,
    &BasicInfo, sizeof(BasicInfo), NULL);
if (!NT_SUCCESS(Status)) {
    CloseHandle(hProcess);
    return;
    }


// get the PEB
if (ReadProcessMemory(hProcess, BasicInfo.PebBaseAddress, &Peb,
    sizeof(PEB), NULL)) {

    // get the processparameters
    if (ReadProcessMemory(hProcess, Peb.ProcessParameters,
        &ProcessParameters, sizeof(ProcessParameters), NULL)) {

        // get cmdline
        if (ReadProcessMemory(hProcess,
                              ProcessParameters.CommandLine.Buffer,
                              szT,
                              sizeof(szT),
                              &dwbytesret
                              )
            ) {

            CHAR        *scanner;       /* Used for parsing the command-line */

            /* Prep the STRING structure */
            param.Buffer = pbuf;
            param.MaximumLength = ANSI_PARAM_LEN;
            u_param.Length = (USHORT) dwbytesret;
            u_param.Buffer = szT;

            /* Convert from Unicode */
            RtlUnicodeStringToAnsiString(&param,    /* Target string        */
                                         &u_param,  /* Src                  */
                                         FALSE);    /* = Don't Allocate buf */

            /*
            | OK, we can have the following situations:
            |
            | 1)   "\system\system32\smss.exe -parameter1 -parameter2"
            |       --------path-----         -------parameters------
            |
            | 2)   "\system\system32\smss.exe"
            |       --------path-----
            |
            | 3)   "smss.exe -parameter1 -parameter2"
            |                -------parameters------
            |
            | and we want to handle this by returning "path" and "parameter"
            | as shown, where:
            |
            | 1) both path and parameters are present
            | 2) only path is present
            | 3) only parameters are present
            |
            | We do this:
            |
            |  - Scan forward for a blank.
            |    If we get one:
            |           + return the address following it as "parameters"
            |           + set the blank to a null byte (cutting off parameters)
            |    If not:
            |           + return NULL as "parameters"
            |
            |    ----Parameters are done.
            |
            |  - Perform a reverse search for "\" on whatever is now in the
            |    buffer
            |    If we find a "\":
            |           + Step forward one character and turn it into a null
            |             byte (turning buffer into string containing path).
            |           + Return the buffer address as "path"
            |    If not:
            |           + return NULL as "path"
            */
            /* Parameter */
            if ((scanner = strchr(pbuf, ' ')) != NULL) {

                /* Return address of char after blank as start of parameters */
                *params_str = (scanner + 1);
                *scanner = '\0';             /* Terminate base string */
                }
            else {
                /* No parameters */
                *params_str = NULL;
                }

            /* Path */
            if ((scanner = strrchr(pbuf, '\\')) != NULL) {
                /* Terminate the path */
                *(scanner+1) = '\0';

                /* Return start of buffer as path */
                *path_str = pbuf;
                }
            else {
                /* No path */
                *path_str = NULL;
                }

            CloseHandle(hProcess);

            /* Return address of static ANSI string buffer */
            return;
            }
        }
    }

CloseHandle(hProcess);

/* Nothing back */
return;
}

#if defined(CACHE_DUMP)

/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */
/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */
/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */

static void
debug_print_hrswrun(
                    CACHEROW     *row  /* Row in hrSWRun(Perf) table */
                    )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=================================\n");
    fprintf(OFILE, "hrSWRun & hrSWRunPerf Table Cache\n");
    fprintf(OFILE, "=================================\n");
    return;
    }


fprintf(OFILE, "HrSWRunIndex . . . . . . %d\n",
        row->attrib_list[HRSR_INDEX].u.unumber_value);

fprintf(OFILE, "HrSWRunName. . . . . . . \"%s\"\n",
        row->attrib_list[HRSR_NAME].u.string_value);

fprintf(OFILE, "HrSWRunPath. . . . . . . \"%s\"\n",
        row->attrib_list[HRSR_PATH].u.string_value);

fprintf(OFILE, "HRSWRunParameters. . . . \"%s\"\n",
        row->attrib_list[HRSR_PARAM].u.string_value);

fprintf(OFILE, "HrSWRunType. . . . . . . %d ",
        row->attrib_list[HRSR_TYPE].u.unumber_value);

switch (row->attrib_list[HRSR_TYPE].u.unumber_value) {
    case 1: fprintf(OFILE, "(unknown)\n");        break;
    case 2: fprintf(OFILE, "(operatingSystem)\n");        break;
    case 3: fprintf(OFILE, "(deviceDriver)\n");        break;
    case 4: fprintf(OFILE, "(application)\n");        break;
    default:
            fprintf(OFILE, "(???)\n");
    }

fprintf(OFILE, "HrSWRunStatus. . . . . . %d ",
        row->attrib_list[HRSR_STATUS].u.unumber_value);

switch (row->attrib_list[HRSR_STATUS].u.unumber_value) {
    case 1: fprintf(OFILE, "(running)\n");        break;
    case 2: fprintf(OFILE, "(runnable)\n");        break;
    case 3: fprintf(OFILE, "(notRunnable)\n");        break;
    case 4: fprintf(OFILE, "(invalid)\n");        break;
    default:
            fprintf(OFILE, "(???)\n");
    }

fprintf(OFILE, "HrSWRunPerfCpu . . . . . %d (Centi-seconds)\n",
        row->attrib_list[HRSP_CPU].u.unumber_value);

fprintf(OFILE, "HrSWRunPerfMem . . . . . %d (Kbytes)\n",
        row->attrib_list[HRSP_MEM].u.unumber_value);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrswpren.c ===
/*
 *  HrSWRunPerfEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWRunPerfEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 05/14/97  D. D. Burns     Genned: Thu Nov 07 16:48:05 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */

/*
| NOTE:
|    The cache used by this table is the same one created for hrSWRun.  The
|    CACHEHEAD structure for it is located in "HRSWRUNE.C".
*/



/*
 *  GetHrSWRunPerfCPU
 *    The number of centi-seconds of the total system's CPU resources consumed 
 *    by this process.  Note that  on a multi-processor syste
 *    
 *    Gets the value for HrSWRunPerfCPU.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunPerfCPU
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER
 | 
 | "The number of centi-seconds of the total system's CPU resources consumed by
 | this process.  Note that on a multi-processor system, this value may increment
 | by more than one centi-second in one centi-second of real (wall clock) time."
 | 
 | DISCUSSION:
 | 
 | <POA-22> Given the performance monitoring counters available in the Registry,
 | how do we compute this SNMP attribute value for a given process?
 | 
 | RESOLVED >>>>>>>>
 | <POA-22> I think we should just use the PerfMon code for this.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.5.1.1.1.<instance>
 |                | | | |
 |                | | | *-hrSWRunPerfCPU
 |                | | *-hrSWRunPerfEntry
 |                | *-hrSWRunPerfTable
 |                *-hrSWRunPerf
 */

UINT
GetHrSWRunPerfCPU( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSP_CPU].u.number_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunPerfCPU() */


/*
 *  GetHrSWRunPerfMem
 *    The total amount of real system memory allocated to this process.
 *    
 *    Gets the value for HrSWRunPerfMem.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunPerfMem
 | 
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 | 
 | "The total amount of real system memory allocated to this process."
 | 
 | DISCUSSION:
 | 
 | <POA-23> Given the performance monitoring counters available in the Registry,
 | how do we compute this SNMP attribute value for a given process?
 | 
 | RESOLVED >>>>>>>>
 | <POA-22> I think we should just use the PerfMon code for this.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.5.1.1.2.<instance>
 |                | | | |
 |                | | | *-hrSWRunPerfMem
 |                | | *-hrSWRunPerfEntry
 |                | *-hrSWRunPerfTable
 |                *-hrSWRunPerf
 */

UINT
GetHrSWRunPerfMem( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSP_MEM].u.number_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunPerfMem() */


/*
 *  HrSWRunPerfEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunPerfEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWRUNPERFENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWRUNPERFENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWRUNPERFENTRY_VAR_INDEX ] ;

        /*
        | Check for age-out and possibly refresh the entire cache for the 
        | hrSWRun(Perf) table before we check to see if the instance is there.
        */
        if (hrSWRunCache_Refresh() == FALSE) {
            return SNMP_ERRORSTATUS_GENERR;
            }

        /*
        | For hrSWRunPerf, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrSWRun(Perf) Table cache.
        | Check that here.
        */
	if ( FindTableRow(tmp_instance, &hrSWRunTable_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunPerfEntryFindInstance() */



/*
 *  HrSWRunPerfEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunPerfEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSWRUNPERFENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSWRUNPERFENTRY_VAR_INDEX ] ;
        }

    /*
    | Check for age-out and possibly refresh the entire cache for the 
    | hrSWRun(Perf) table before we check to see if the instance is there.
    */
    if (hrSWRunCache_Refresh() == FALSE) {
        return SNMP_ERRORSTATUS_GENERR;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrSWRunTable_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunPerfEntryFindNextInstance() */



/*
 *  HrSWRunPerfEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWRunPerfEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrSWRunPerfEntryConvertInstance() */




/*
 *  HrSWRunPerfEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWRunPerfEntryFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWRunPerfEntryFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrswinst.c ===
/*
 *  HrSWInstalled.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWInstalled.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:48:30 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file     */


/*
 *  GetHrSWInstalledLastChange
 *    The value of sysUpTime when an entry in the hrSWInstalledTable was last 
 *    added, renamed, or deleted.  Because this table is likel
 *    
 *    Gets the value for HrSWInstalledLastChange.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledLastChange
 | 
 |  ACCESS         SYNTAX
 |  read-only      TimeTicks
 | 
 | "The value of sysUpTime when an entry in the hrSWInstalledTable was last
 | added, renamed, or deleted.  Because this table is likely to contain many
 | entries, polling of this object allows a management station to determine when
 | re-downloading of the table might be useful."
 |
 |============================================================================
 | Decision is made to report the current value of sysUpTime as a means of
 | signalling the SNMP Manager that "whatever he's got now, he should ask
 | for the latest".  Our cache of installed software is never updated after
 | the agent comes up in the first release.
 |============================================================================
 | 1.3.6.1.2.1.25.6.1.0....
 |                | | 
 |                | *hrSWInstalledLastChange
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledLastChange( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    *outvalue = SnmpSvcGetUptime();

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledLastChange() */


/*
 *  GetHrSWInstalledLastUpdateTime
 *    The value of sysUpTime when the hrSWInstalledTAble was last completely 
 *    updated.  Because caching of this data will be a popular 
 *    
 *    Gets the value for HrSWInstalledLastUpdateTime.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledLastUpdateTime
 | 
 |  ACCESS         SYNTAX
 |  read-only      TimeTicks
 | 
 | "The value of sysUpTime when the hrSWInstalledTable was last completely
 | updated.  Because caching of this data will be a popular implementation
 | strategy, retrieval of this object allows a management station to obtain a
 | guarantee that no data in this table is older than the indicated time."
 |
 |============================================================================
 | Decision is made to report the current value of sysUpTime as a means of
 | signalling the SNMP Manager that "whatever he's got now, he should ask
 | for the latest".  Our cache of installed software is never updated after
 | the agent comes up in the first release.
 |============================================================================
 | 1.3.6.1.2.1.25.6.2.0....
 |                | | 
 |                | *hrSWInstalledLastUpdateTime
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledLastUpdateTime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    *outvalue = SnmpSvcGetUptime();

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledLastUpdateTime() */


/*
 *  HrSWInstalledFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWINSTALLED_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWINSTALLED_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWINSTALLED_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledFindInstance() */



/*
 *  HrSWInstalledFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSWINSTALLED_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledFindNextInstance() */



/*
 *  HrSWInstalledConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWInstalledConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrSWInstalledConvertInstance() */




/*
 *  HrSWInstalledFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWInstalledFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWInstalledFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrsystem.c ===
/*
 *  HrSystem.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSystem.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/17/97  D. D. Burns     Genned: Thu Nov 07 16:39:21 1996
 *
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include <lmcons.h>       /* for NET_API_STATUS    */
#include <lmwksta.h>      /* For NetWkStaGetInfo() */
#include <lmapibuf.h>     /* For NetApiBufferFree()*/
#include <lmerr.h>        /* For NERR_Success      */
#include <winsock.h>      /* For htons()           */

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* For "hrSystemInitialLoadDevice" */


/*
 *  GetHrSystemUptime
 *    The amount of time since this host was last initialized.
 *    
 *    Gets the value for HrSystemUptime.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemUptime
 | 
 |  ACCESS         SYNTAX
 |  read-only      TimeTicks
 | 
 | "The amount of time since this host was last initialized.  Note that this is
 | different from sysUpTime in MIB-II [3] because sysUpTime is the uptime of 
 | the network management portion of the system."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "GetTickCount" is used to obtain the value returned for a
 | GET on this variable.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.1.1.0
 |                | |
 |                | *-hrSystemUptime
 |                *---hrSystem
 */

UINT
GetHrSystemUptime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

*outvalue = GetTickCount();

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemUptime() */


/*
 *  GetHrSystemDate
 *    The host's notion of the local date and time of day.
 *    
 *    Gets the value for HrSystemDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemDate
 | 
 |  ACCESS         SYNTAX
 |  read-write     DateAndTime
 | 
 | "The host's notion of the local date and time of day."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "GetLocalTime" is used to obtain the value returned for a
 | GET on this variable.
 | 
 | Since this variable is "read-write", this implies that the system time can
 | be set by a SET request.  This is done with a Win32 API function
 | "SetLocalTime".
 | 
 | <POA-1> Issuing "SetLocalTime" requires that the issuing process have the
 | "SE_SYSTEMTIME_NAME" privilege which is not the default.  Are there any
 | security concerns about issuing the necessary Win32 API function call
 | "AdjustTokenPrivileges" from inside the SNMP agent to enable setting of
 | the system time?  Any other problems?
 | 
 | RESOLVED >>>>>>>
 | <POA-1> Let's leave this read-only.
 | RESOLVED >>>>>>>
 |
 |========================== From RFC1514 ====================================
 |
 |    DateAndTime ::= OCTET STRING (SIZE (8 | 11))
 |    --        A date-time specification for the local time of day.
 |    --        This data type is intended to provide a consistent
 |    --        method of reporting date information.
 |    --
 |    --            field  octets  contents                  range
 |    --            _____  ______  ________                  _____
 |    --              1      1-2   year                      0..65536
 |    --                           (in network byte order)
 |    --              2       3    month                     1..12
 |    --              3       4    day                       1..31
 |    --              4       5    hour                      0..23
 |    --              5       6    minutes                   0..59
 |    --              6       7    seconds                   0..60
 |    --                           (use 60 for leap-second)
 |    --              7       8    deci-seconds              0..9
 |    --              8       9    direction from UTC        "+" / "-"
 |    --                           (in ascii notation)
 |    --              9      10    hours from UTC            0..11
 |    --             10      11    minutes from UTC          0..59
 |    --
 |    --            Note that if only local time is known, then
 |    --            timezone information (fields 8-10) is not present.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.1.2.0
 |                | |
 |                | *-hrSystemDate
 |                *---hrSystem
 */

UINT
GetHrSystemDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
SYSTEMTIME      localtime;             // Where we retrieve current local time
USHORT          year_networkbyteorder; // Network byte order of year
static
char            octet_time[8];         // OCTET STRING format of "time"

    GetLocalTime(&localtime);

    year_networkbyteorder = htons(localtime.wYear);

    //
    // Format "dateandtime" according to RFC1514
    //
    octet_time[0] = (year_networkbyteorder & 0xFF);
    octet_time[1] = (year_networkbyteorder >> 8);
    octet_time[2] = (char) localtime.wMonth;
    octet_time[3] = (char) localtime.wDay;
    octet_time[4] = (char) localtime.wHour;
    octet_time[5] = (char) localtime.wMinute;
    octet_time[6] = (char) localtime.wSecond;
    octet_time[7] = localtime.wMilliseconds / 100;

    outvalue->length = 8;
    outvalue->string = octet_time;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemDate() */


/*
 *  GetHrSystemInitialLoadDevice
 *    The index of the hrDeviceEntry for the device from which this host is 
 *    configured to load its initial operating system configurat
 *    
 *    Gets the value for HrSystemInitialLoadDevice.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemInitialLoadDevice
 | 
 |  ACCESS         SYNTAX
 |  read-write     INTEGER (1..2147483647)
 | 
 | "The index of the hrDeviceEntry for the device from which this host is
 | configured to load its initial operating system configuration."
 | 
 | DISCUSSION:
 | 
 | <POA-2> It seems that RFC1514 is attempting to allow the setting and resetting
 | of the default operating system to be booted thru the combination of this
 | attribute and "hrSystemInitialLoadParameters" (below).
 | 
 | While generic PC hardware typically boots from a hard disk partition that is
 | going to wind up being labelled as drive "C:", these two variables speak to a
 | more general situation in which a hardware bootstrap loader can be set to
 | point to almost any system image on a "permanent file system" (to use the unix
 | phrase).  It is apparent that we must attempt to approximate this in some way.
 | 
 | I note that a system file named "Boot.ini" resides on the bootable partition
 | of an Intel NT system.  The one on my system looks like:
 | 
 | >>>>>>>>
 | [boot loader]
 | timeout=30
 | default=multi(0)disk(0)rdisk(0)partition(1)\WINNT35
 | [operating systems]
 | multi(0)disk(0)rdisk(0)partition(1)\WINNT35="Windows NT Server Version 3.51"
 | multi(0)disk(0)rdisk(0)partition(1)\WINNT35="Windows NT Server Version 3.51 [VGA mode]" /basevideo /sos
 | <<<<<<<<
 | 
 | The contents of this file seems to be the source of the menu that appears
 | during the NT boot process.  Programming a selection from this menu is a close
 | approximation to the flexibility hinted at thru the combination of these
 | two SNMP attributes, "hrSystemInitialLoadDevice" and
 | "hrSystemInitialLoadParameters".
 | 
 | For the purposes of "GET", given the "default" shown in the "Boot.ini" file
 | above, it would seem that the string "multi(0)disk(0)rdisk(0)partition(1)"
 | constitutes a passing resemblance to "hrSystemInitialLoadDevice" while the
 | string "\WINNT35" seems to be a good candidate for the value of
 | "hrSystemInitialLoadParameters" (where both of these are drawn from the value
 | specified for "default" under "[boot loader]").
 | 
 | For the purposes of "SET", we would be required to modify this file according
 | to the values received.  I note that the file on my system is write-protected
 | and clearly this poses a problem if we allow the SNMP agent to attempt to
 | modify it.  Additionally, there is the problem of error-checking any value
 | provided from an SNMP SET request (I do not know the exact semantic
 | significance of "multi(0)disk(0)rdisk(0)partition(1)" and I do not know how
 | to error-check a received value).
 | 
 | RESOLVED >>>>>>>
 | <POA-2> Call GetWindowsDirectory and work backwards from that (get the 
 | device name, e.g. D, then do a QueryDosDevice to get the underlying 
 | partition information).  Much more accurate than trying to parse boot.ini, 
 | and portable to Alpha.  Leave read-only.
 | RESOLVED >>>>>>>
 |============================================================================
 | 1.3.6.1.2.1.25.1.3.0
 |                | |
 |                | *-hrSystemInitialLoadDevice
 |                *---hrSystem
 */

UINT
GetHrSystemInitialLoadDevice( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    /*
    | Fetch this magic index from static storage in "HRDEVENT.C".
    */
    *outvalue = InitLoadDev_index;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemInitialLoadDevice() */



/*
 *  SetHrSystemInitialLoadDevice
 *    The index of the hrDeviceEntry for the device from which this host is 
 *    configured to load its initial operating system configurat
 *    
 *    Sets the HrSystemInitialLoadDevice value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrSystemInitialLoadDevice( 
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrSystemInitialLoadDevice() */


/*
 *  GetHrSystemInitialLoadParameters
 *    This object contains the paramets (e.g. a pathname and parameter) 
 *    supplied to the load device when requesting the initial operat
 *    
 *    Gets the value for HrSystemInitialLoadParameters.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemInitialLoadParameters
 | 
 |   ACCESS        SYNTAX
 |   read-write    InternationalDisplayString (SIZE (0..128))
 | 
 | "This object contains the parameters (e.g. a pathname and parameter) supplied
 | to the load device when requesting the initial operating system configuration
 | from that device."
 | 
 | DISCUSSION:
 | 
 | (See discussion for "hrSystemInitialLoadDevice" above).
 | 
 | For initial version, we return a zero length string, and it is not SETable.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.1.4.0
 |                | |
 |                | *-hrSystemInitialLoadParameters
 |                *---hrSystem
 */

UINT
GetHrSystemInitialLoadParameters( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    // (No parameter-string returned  for initial release)
    outvalue->length = 0;
    outvalue->string = NULL;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemInitialLoadParameters() */


/*
 *  SetHrSystemInitialLoadParameters
 *    This object contains the paramets (e.g. a pathname and parameter) 
 *    supplied to the load device when requesting the initial operat
 *    
 *    Sets the HrSystemInitialLoadParameters value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrSystemInitialLoadParameters( 
        IN InternationalDisplayString *invalue ,
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrSystemInitialLoadParameters() */

/*
 *  GetHrSystemNumUsers
 *    The number of user sessions for which this host is storing state 
 *    information.
 *    
 *    Gets the value for HrSystemNumUsers.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemNumUsers
 | 
 |  ACCESS         SYNTAX
 |  read-only      Gauge
 | 
 | "The number of user sessions for which this host is storing state information.
 | A session is a collection of processes requiring a single act of user
 | authentication and possibly subject to collective job control."
 | 
 | DISCUSSION:
 | 
 | <POA-3> This metric does not seem to be directly available thru a standard
 | Win32 API function.  I note that what appears to be logon information seems to
 | be stored in the registry under:
 | 
 |           "HKEY_LOCAL_MACHINE\microsoft\windows nt\winlogon".
 | 
 | + Should I use this as a source for this SNMP attribute?
 | + If this registry entry is the proper place to acquire this information, what
 |   is the full and proper way to parse this entry?  (By this I mean if more
 |   than one user is logged on, how does this single registry entry reflect
 |   multiple users?)
 | + Does it reflect other users logged in via a network connection?
 | 
 | RESOLVED >>>>>>>
 | <POA-3> There is going to be either one interactive user or none.  Use 
 | NetWkstaGetInfo to try to determine the name of the currently logged on 
 | interactive user and if this succeeds then it is the former.
 | RESOLVED >>>>>>>
 |
 |=============================================================================
 | 1.3.6.1.2.1.25.1.5.0
 |                | |
 |                | *-hrSystemNumUsers
 |                *---hrSystem
 */

UINT
GetHrSystemNumUsers( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    LPBYTE  info;     /* Where we get logged-on information */


    // Attempt to get the number of logged-on users . . . 
    if (NetWkstaGetInfo(NULL,           /* "Local" computer     */
                        102,            /* Info Level 102       */
                        &info) != NERR_Success) {

        return SNMP_ERRORSTATUS_GENERR ;
        }


    /* Just return it */
    *outvalue = ((LPWKSTA_INFO_102) info)->wki102_logged_on_users;

    /* Free the Net API Buffer */
    NetApiBufferFree(info);

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemNumUsers() */


/*
 *  GetHrSystemProcesses
 *    The number of process contexts currently loaded or running on this system.
 *    
 *    Gets the value for HrSystemProcesses.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 |=============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemProcesses
 | 
 |  ACCESS         SYNTAX
 |  read-only      Gauge
 | 
 | "The number of process contexts currently loaded or running on this system."
 | 
 | DISCUSSION:
 | 
 | The sample-code "Process Viewer" (PVIEWER.EXE) that is part of the Win32 SDK
 | infers a list of active processes from performance information that is stored
 | in the registry.  We use this approach (and borrowed code) to obtaining a
 | count of active processes.
 |
 |-- (The foregoing approach is abandoned for a direct "beyond-the-veil" call
 |--  to NtQuerySystemInfo()).
 |=============================================================================
 | 1.3.6.1.2.1.25.1.6.0
 |                | |
 |                | *-hrSystemNumUsers
 |                *---hrSystem
 */

UINT
GetHrSystemProcesses( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    ULONG       process_count;

    // If we failed to get the Process Count successfully . . . 
    if ((process_count = Spt_GetProcessCount()) == 0) {
        return SNMP_ERRORSTATUS_GENERR ;
        }

    // Return the value
    *outvalue = process_count;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemProcesses() */


/*
 *  GetHrSystemMaxProcesses
 *    The maximum number of process contexts this system can support.  If there 
 *    is no fixed maximum, the value should be zero.
 *    
 *    Gets the value for HrSystemMaxProcesses.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 |=============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemMaxProcesses
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 | 
 | "The maximum number of process contexts this system can support.  If there is
 | no fixed maximum, the value should be zero.  On systems that have a fixed
 | maximum, this object can help diagnose failures that occur when this maximum
 | is reached."
 | 
 | DISCUSSION:
 | 
 | My understanding is there is no fixed maximum, as the effective maximum is
 | main-memory dependent.  We return 0 for the value of this attribute.
 | 
 |=============================================================================
 | 1.3.6.1.2.1.25.1.7.0
 |                | |
 |                | *-hrSystemNumUsers
 |                *---hrSystem
 */

UINT
GetHrSystemMaxProcesses( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    *outvalue = 0;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemMaxProcesses() */


/*
 *  HrSystemFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSystemFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, 
    //  if there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSYSTEM_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSYSTEM_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSYSTEM_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSystemFindInstance() */



/*
 *  HrSystemFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSystemFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSYSTEM_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSystemFindNextInstance() */



/*
 *  HrSystemConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSystemConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrSystemConvertInstance() */




/*
 *  HrSystemFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSystemFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSystemFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\hrswrun.c ===
/*
 *  HrSWRun.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWRun.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 05/14/97  D. D. Burns     Genned: Thu Nov 07 16:46:47 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file  */
#include "HMCACHE.H"      /* Cache-related definitions        */


/*
 *  GetHrSWOSIndex
 *    The value of the hrSWRunIndex for the hrSWRunEntry that represents the 
 *    primary operating system running on this host.  This obje
 *    
 *    Gets the value for HrSWOSIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWOSIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "The value of the hrSWRunIndex for the hrSWRunEntry that represents the
 | primary operating system running on this host.  This object is useful for
 | quickly and uniquely identifying that primary operating system."
 | 
 | 
 | DISCUSSION:
 | 
 | The value for this attribute is the index for the process named "System".
 |
 |============================================================================
 | This value is computed in module "HRSWRUNE.C" in function "AddHrSWRunRow()"
 | and stored in that module for global reference by this code.
 |============================================================================
 | 1.3.6.1.2.1.25.4.1.0
 |                | |
 |                | *-hrSWOSIndex
 |                *-hrSWRun
 */

UINT
GetHrSWOSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| Check and Refresh the entire cache for the hrSWRun table
*/
if (hrSWRunCache_Refresh() == FALSE) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = SWOSIndex;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWOSIndex() */


/*
 *  HrSWRunFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWRUN_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWRUN_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWRUN_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunFindInstance() */



/*
 *  HrSWRunFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSWRUN_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunFindNextInstance() */



/*
 *  HrSWRunConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWRunConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrSWRunConvertInstance() */




/*
 *  HrSWRunFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWRunFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWRunFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\mib_xtrn.h ===
/*
 *  mib_xtrn.h v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1994 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the external declarations for the MIB.
 *
 *  Author:
 *
 *	David Burns @ Webenable Inc
 *
 *  Date:
 *
 *	Thu Nov 07 16:38:28 1996
 *
 *  Revision History:
 *
 */

#ifndef mib_xtrn_h
#define mib_xtrn_h

// Necessary includes.

#include <snmp.h>
#include "gennt.h"
#include "hostmsmi.h"

//
// External declarations for the table
//
//extern table declarations

extern class_t class_info[] ;
extern trap_t trap_info[] ;
extern UINT number_of_traps ;
extern char *EventLogString ;

#endif /* mib_xtrn_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\mib.h ===
/*
 *  mib.h v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the definitions for the MIB generated by Agent
 *    Factory.  This module includes the definitions for attribute and class
 *    codes, object identifiers, and the tables for each group or table in the
 *    MIB.
 *
 *  Author:
 *
 *	David Burns @ Webenable Inc
 *
 *  Date:
 *
 *	Thu Nov 07 16:38:26 1996
 *
 *  Revision History:
 *
 */

#ifndef mib_h
#define mib_h

// Necessary includes.

#include <snmp.h>
#include "gennt.h"
#include "smint.h"
#include "hostmsmi.h"

#define SUBROOT_LENGTH 7
extern AsnObjectIdentifier Subroot_oid ;
#define HOST_CODE 25
#define HOST_SEQ MIB_2_SEQ, 25
#define HOST_LENGTH ( MIB_2_LENGTH + 1  )
#define HRSYSTEM_CODE 1
#define HRSYSTEM_SEQ HOST_SEQ, 1
#define HRSYSTEM_LENGTH ( HOST_LENGTH + 1  )
#define HRSTORAGE_CODE 2
#define HRSTORAGE_SEQ HOST_SEQ, 2
#define HRSTORAGE_LENGTH ( HOST_LENGTH + 1  )
#define HRDEVICE_CODE 3
#define HRDEVICE_SEQ HOST_SEQ, 3
#define HRDEVICE_LENGTH ( HOST_LENGTH + 1  )
#define HRSWRUN_CODE 4
#define HRSWRUN_SEQ HOST_SEQ, 4
#define HRSWRUN_LENGTH ( HOST_LENGTH + 1  )
#define HRSWRUNPERF_CODE 5
#define HRSWRUNPERF_SEQ HOST_SEQ, 5
#define HRSWRUNPERF_LENGTH ( HOST_LENGTH + 1  )
#define HRSWINSTALLED_CODE 6
#define HRSWINSTALLED_SEQ HOST_SEQ, 6
#define HRSWINSTALLED_LENGTH ( HOST_LENGTH + 1  )
#define HRSTORAGETABLE_CODE 3
#define HRSTORAGETABLE_SEQ HRSTORAGE_SEQ, 3
#define HRSTORAGETABLE_LENGTH ( HRSTORAGE_LENGTH + 1  )
#define HRSTORAGEENTRY_CODE 1
#define HRSTORAGEENTRY_SEQ HRSTORAGETABLE_SEQ, 1
#define HRSTORAGEENTRY_LENGTH ( HRSTORAGETABLE_LENGTH + 1  )
#define HRDEVICETABLE_CODE 2
#define HRDEVICETABLE_SEQ HRDEVICE_SEQ, 2
#define HRDEVICETABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRDEVICEENTRY_CODE 1
#define HRDEVICEENTRY_SEQ HRDEVICETABLE_SEQ, 1
#define HRDEVICEENTRY_LENGTH ( HRDEVICETABLE_LENGTH + 1  )
#define HRNETWORKTABLE_CODE 4
#define HRNETWORKTABLE_SEQ HRDEVICE_SEQ, 4
#define HRNETWORKTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRNETWORKENTRY_CODE 1
#define HRNETWORKENTRY_SEQ HRNETWORKTABLE_SEQ, 1
#define HRNETWORKENTRY_LENGTH ( HRNETWORKTABLE_LENGTH + 1  )
#define HRPROCESSORTABLE_CODE 3
#define HRPROCESSORTABLE_SEQ HRDEVICE_SEQ, 3
#define HRPROCESSORTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRPROCESSORENTRY_CODE 1
#define HRPROCESSORENTRY_SEQ HRPROCESSORTABLE_SEQ, 1
#define HRPROCESSORENTRY_LENGTH ( HRPROCESSORTABLE_LENGTH + 1  )
#define HRPRINTERTABLE_CODE 5
#define HRPRINTERTABLE_SEQ HRDEVICE_SEQ, 5
#define HRPRINTERTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRPRINTERENTRY_CODE 1
#define HRPRINTERENTRY_SEQ HRPRINTERTABLE_SEQ, 1
#define HRPRINTERENTRY_LENGTH ( HRPRINTERTABLE_LENGTH + 1  )
#define HRDISKSTORAGETABLE_CODE 6
#define HRDISKSTORAGETABLE_SEQ HRDEVICE_SEQ, 6
#define HRDISKSTORAGETABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRDISKSTORAGEENTRY_CODE 1
#define HRDISKSTORAGEENTRY_SEQ HRDISKSTORAGETABLE_SEQ, 1
#define HRDISKSTORAGEENTRY_LENGTH ( HRDISKSTORAGETABLE_LENGTH + 1  )
#define HRPARTITIONTABLE_CODE 7
#define HRPARTITIONTABLE_SEQ HRDEVICE_SEQ, 7
#define HRPARTITIONTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRPARTITIONENTRY_CODE 1
#define HRPARTITIONENTRY_SEQ HRPARTITIONTABLE_SEQ, 1
#define HRPARTITIONENTRY_LENGTH ( HRPARTITIONTABLE_LENGTH + 1  )
#define HRFSTABLE_CODE 8
#define HRFSTABLE_SEQ HRDEVICE_SEQ, 8
#define HRFSTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRFSENTRY_CODE 1
#define HRFSENTRY_SEQ HRFSTABLE_SEQ, 1
#define HRFSENTRY_LENGTH ( HRFSTABLE_LENGTH + 1  )
#define HRSWRUNTABLE_CODE 2
#define HRSWRUNTABLE_SEQ HRSWRUN_SEQ, 2
#define HRSWRUNTABLE_LENGTH ( HRSWRUN_LENGTH + 1  )
#define HRSWRUNENTRY_CODE 1
#define HRSWRUNENTRY_SEQ HRSWRUNTABLE_SEQ, 1
#define HRSWRUNENTRY_LENGTH ( HRSWRUNTABLE_LENGTH + 1  )
#define HRSWRUNPERFTABLE_CODE 1
#define HRSWRUNPERFTABLE_SEQ HRSWRUNPERF_SEQ, 1
#define HRSWRUNPERFTABLE_LENGTH ( HRSWRUNPERF_LENGTH + 1  )
#define HRSWRUNPERFENTRY_CODE 1
#define HRSWRUNPERFENTRY_SEQ HRSWRUNPERFTABLE_SEQ, 1
#define HRSWRUNPERFENTRY_LENGTH ( HRSWRUNPERFTABLE_LENGTH + 1  )
#define HRSWINSTALLEDTABLE_CODE 3
#define HRSWINSTALLEDTABLE_SEQ HRSWINSTALLED_SEQ, 3
#define HRSWINSTALLEDTABLE_LENGTH ( HRSWINSTALLED_LENGTH + 1  )
#define HRSWINSTALLEDENTRY_CODE 1
#define HRSWINSTALLEDENTRY_SEQ HRSWINSTALLEDTABLE_SEQ, 1
#define HRSWINSTALLEDENTRY_LENGTH ( HRSWINSTALLEDTABLE_LENGTH + 1  )
#define HRDEVICETYPES_CODE 1
#define HRDEVICETYPES_SEQ HRDEVICE_SEQ, 1
#define HRDEVICETYPES_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRSTORAGETYPES_CODE 1
#define HRSTORAGETYPES_SEQ HRSTORAGE_SEQ, 1
#define HRSTORAGETYPES_LENGTH ( HRSTORAGE_LENGTH + 1  )
#define HRFSTYPES_CODE 9
#define HRFSTYPES_SEQ HRDEVICE_SEQ, 9
#define HRFSTYPES_LENGTH ( HRDEVICE_LENGTH + 1  )
extern AsnObjectIdentifier host_oid;
extern AsnObjectIdentifier hrSystemUptime_oid;
extern AsnObjectIdentifier hrSystemDate_oid;
extern AsnObjectIdentifier hrSystemInitialLoadDevice_oid;
extern AsnObjectIdentifier hrSystemInitialLoadParameters_oid;
extern AsnObjectIdentifier hrSystemNumUsers_oid;
extern AsnObjectIdentifier hrSystemProcesses_oid;
extern AsnObjectIdentifier hrSystemMaxProcesses_oid;
#define HRSYSTEMUPTIME_CODE 1
#define HRSYSTEMUPTIME_SEQ HRSYSTEM_SEQ, 1
#define HRSYSTEMUPTIME_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMDATE_CODE 2
#define HRSYSTEMDATE_SEQ HRSYSTEM_SEQ, 2
#define HRSYSTEMDATE_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMINITIALLOADDEVICE_CODE 3
#define HRSYSTEMINITIALLOADDEVICE_SEQ HRSYSTEM_SEQ, 3
#define HRSYSTEMINITIALLOADDEVICE_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMINITIALLOADPARAMETERS_CODE 4
#define HRSYSTEMINITIALLOADPARAMETERS_SEQ HRSYSTEM_SEQ, 4
#define HRSYSTEMINITIALLOADPARAMETERS_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMNUMUSERS_CODE 5
#define HRSYSTEMNUMUSERS_SEQ HRSYSTEM_SEQ, 5
#define HRSYSTEMNUMUSERS_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMPROCESSES_CODE 6
#define HRSYSTEMPROCESSES_SEQ HRSYSTEM_SEQ, 6
#define HRSYSTEMPROCESSES_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMMAXPROCESSES_CODE 7
#define HRSYSTEMMAXPROCESSES_SEQ HRSYSTEM_SEQ, 7
#define HRSYSTEMMAXPROCESSES_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEM_VAR_INDEX  ( HRSYSTEM_LENGTH + 1 )
#define MIN_HRSYSTEM_CODE 1
#define MAX_HRSYSTEM_CODE 7
extern AsnObjectIdentifier hrSystem_oid;
extern AsnObjectIdentifier hrMemorySize_oid;
#define HRMEMORYSIZE_CODE 2
#define HRMEMORYSIZE_SEQ HRSTORAGE_SEQ, 2
#define HRMEMORYSIZE_LENGTH ( HRSTORAGE_LENGTH + 1  )
#define HRSTORAGE_VAR_INDEX  ( HRSTORAGE_LENGTH + 1 )
#define MIN_HRSTORAGE_CODE 2
#define MAX_HRSTORAGE_CODE 2
extern AsnObjectIdentifier hrStorage_oid;
extern AsnObjectIdentifier hrStorageOther_oid;
extern AsnObjectIdentifier hrStorageRAM_oid;
extern AsnObjectIdentifier hrStorageVirtualMemory_oid;
extern AsnObjectIdentifier hrStorageFixedDisk_oid;
extern AsnObjectIdentifier hrStorageRemovableDisk_oid;
extern AsnObjectIdentifier hrStorageFloppyDisk_oid;
extern AsnObjectIdentifier hrStorageCompactDisk_oid;
extern AsnObjectIdentifier hrStorageRamDisk_oid;
#define HRSTORAGEOTHER_CODE 1
#define HRSTORAGEOTHER_SEQ HRSTORAGETYPES_SEQ, 1
#define HRSTORAGEOTHER_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGERAM_CODE 2
#define HRSTORAGERAM_SEQ HRSTORAGETYPES_SEQ, 2
#define HRSTORAGERAM_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEVIRTUALMEMORY_CODE 3
#define HRSTORAGEVIRTUALMEMORY_SEQ HRSTORAGETYPES_SEQ, 3
#define HRSTORAGEVIRTUALMEMORY_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEFIXEDDISK_CODE 4
#define HRSTORAGEFIXEDDISK_SEQ HRSTORAGETYPES_SEQ, 4
#define HRSTORAGEFIXEDDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEREMOVABLEDISK_CODE 5
#define HRSTORAGEREMOVABLEDISK_SEQ HRSTORAGETYPES_SEQ, 5
#define HRSTORAGEREMOVABLEDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEFLOPPYDISK_CODE 6
#define HRSTORAGEFLOPPYDISK_SEQ HRSTORAGETYPES_SEQ, 6
#define HRSTORAGEFLOPPYDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGECOMPACTDISK_CODE 7
#define HRSTORAGECOMPACTDISK_SEQ HRSTORAGETYPES_SEQ, 7
#define HRSTORAGECOMPACTDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGERAMDISK_CODE 8
#define HRSTORAGERAMDISK_SEQ HRSTORAGETYPES_SEQ, 8
#define HRSTORAGERAMDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
extern AsnObjectIdentifier hrStorageTypes_oid;
extern AsnObjectIdentifier hrStorageIndex_oid;
extern AsnObjectIdentifier hrStorageType_oid;
extern AsnObjectIdentifier hrStorageDesc_oid;
extern AsnObjectIdentifier hrStorageAllocationUnits_oid;
extern AsnObjectIdentifier hrStorageSize_oid;
extern AsnObjectIdentifier hrStorageUsed_oid;
extern AsnObjectIdentifier hrStorageAllocationFailures_oid;
#define HRSTORAGEINDEX_CODE 1
#define HRSTORAGEINDEX_SEQ HRSTORAGEENTRY_SEQ, 1
#define HRSTORAGEINDEX_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGETYPE_CODE 2
#define HRSTORAGETYPE_SEQ HRSTORAGEENTRY_SEQ, 2
#define HRSTORAGETYPE_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEDESC_CODE 3
#define HRSTORAGEDESC_SEQ HRSTORAGEENTRY_SEQ, 3
#define HRSTORAGEDESC_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEALLOCATIONUNITS_CODE 4
#define HRSTORAGEALLOCATIONUNITS_SEQ HRSTORAGEENTRY_SEQ, 4
#define HRSTORAGEALLOCATIONUNITS_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGESIZE_CODE 5
#define HRSTORAGESIZE_SEQ HRSTORAGEENTRY_SEQ, 5
#define HRSTORAGESIZE_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEUSED_CODE 6
#define HRSTORAGEUSED_SEQ HRSTORAGEENTRY_SEQ, 6
#define HRSTORAGEUSED_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEALLOCATIONFAILURES_CODE 7
#define HRSTORAGEALLOCATIONFAILURES_SEQ HRSTORAGEENTRY_SEQ, 7
#define HRSTORAGEALLOCATIONFAILURES_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEENTRY_VAR_INDEX  ( HRSTORAGEENTRY_LENGTH + 1 )
#define MIN_HRSTORAGEENTRY_CODE 1
#define MAX_HRSTORAGEENTRY_CODE 7
extern AsnObjectIdentifier hrStorageEntry_oid;
#define HRDEVICE_VAR_INDEX  ( HRDEVICE_LENGTH + 1 )
extern AsnObjectIdentifier hrDeviceOther_oid;
extern AsnObjectIdentifier hrDeviceUnknown_oid;
extern AsnObjectIdentifier hrDeviceProcessor_oid;
extern AsnObjectIdentifier hrDeviceNetwork_oid;
extern AsnObjectIdentifier hrDevicePrinter_oid;
extern AsnObjectIdentifier hrDeviceDiskStorage_oid;
extern AsnObjectIdentifier hrDeviceVideo_oid;
extern AsnObjectIdentifier hrDeviceAudio_oid;
extern AsnObjectIdentifier hrDeviceCoprocessor_oid;
extern AsnObjectIdentifier hrDeviceKeyboard_oid;
extern AsnObjectIdentifier hrDeviceModem_oid;
extern AsnObjectIdentifier hrDeviceParallelPort_oid;
extern AsnObjectIdentifier hrDevicePointing_oid;
extern AsnObjectIdentifier hrDeviceSerialPort_oid;
extern AsnObjectIdentifier hrDeviceTape_oid;
extern AsnObjectIdentifier hrDeviceClock_oid;
extern AsnObjectIdentifier hrDeviceVolatileMemory_oid;
extern AsnObjectIdentifier hrDeviceNonVolatileMemory_oid;
#define HRDEVICEOTHER_CODE 1
#define HRDEVICEOTHER_SEQ HRDEVICETYPES_SEQ, 1
#define HRDEVICEOTHER_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEUNKNOWN_CODE 2
#define HRDEVICEUNKNOWN_SEQ HRDEVICETYPES_SEQ, 2
#define HRDEVICEUNKNOWN_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPROCESSOR_CODE 3
#define HRDEVICEPROCESSOR_SEQ HRDEVICETYPES_SEQ, 3
#define HRDEVICEPROCESSOR_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICENETWORK_CODE 4
#define HRDEVICENETWORK_SEQ HRDEVICETYPES_SEQ, 4
#define HRDEVICENETWORK_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPRINTER_CODE 5
#define HRDEVICEPRINTER_SEQ HRDEVICETYPES_SEQ, 5
#define HRDEVICEPRINTER_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEDISKSTORAGE_CODE 6
#define HRDEVICEDISKSTORAGE_SEQ HRDEVICETYPES_SEQ, 6
#define HRDEVICEDISKSTORAGE_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEVIDEO_CODE 10
#define HRDEVICEVIDEO_SEQ HRDEVICETYPES_SEQ, 10
#define HRDEVICEVIDEO_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEAUDIO_CODE 11
#define HRDEVICEAUDIO_SEQ HRDEVICETYPES_SEQ, 11
#define HRDEVICEAUDIO_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICECOPROCESSOR_CODE 12
#define HRDEVICECOPROCESSOR_SEQ HRDEVICETYPES_SEQ, 12
#define HRDEVICECOPROCESSOR_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEKEYBOARD_CODE 13
#define HRDEVICEKEYBOARD_SEQ HRDEVICETYPES_SEQ, 13
#define HRDEVICEKEYBOARD_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEMODEM_CODE 14
#define HRDEVICEMODEM_SEQ HRDEVICETYPES_SEQ, 14
#define HRDEVICEMODEM_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPARALLELPORT_CODE 15
#define HRDEVICEPARALLELPORT_SEQ HRDEVICETYPES_SEQ, 15
#define HRDEVICEPARALLELPORT_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPOINTING_CODE 16
#define HRDEVICEPOINTING_SEQ HRDEVICETYPES_SEQ, 16
#define HRDEVICEPOINTING_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICESERIALPORT_CODE 17
#define HRDEVICESERIALPORT_SEQ HRDEVICETYPES_SEQ, 17
#define HRDEVICESERIALPORT_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICETAPE_CODE 18
#define HRDEVICETAPE_SEQ HRDEVICETYPES_SEQ, 18
#define HRDEVICETAPE_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICECLOCK_CODE 19
#define HRDEVICECLOCK_SEQ HRDEVICETYPES_SEQ, 19
#define HRDEVICECLOCK_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEVOLATILEMEMORY_CODE 20
#define HRDEVICEVOLATILEMEMORY_SEQ HRDEVICETYPES_SEQ, 20
#define HRDEVICEVOLATILEMEMORY_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICENONVOLATILEMEMORY_CODE 21
#define HRDEVICENONVOLATILEMEMORY_SEQ HRDEVICETYPES_SEQ, 21
#define HRDEVICENONVOLATILEMEMORY_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
extern AsnObjectIdentifier hrDeviceTypes_oid;
extern AsnObjectIdentifier hrDeviceIndex_oid;
extern AsnObjectIdentifier hrDeviceType_oid;
extern AsnObjectIdentifier hrDeviceDesc_oid;
extern AsnObjectIdentifier hrDeviceID_oid;
extern AsnObjectIdentifier hrDeviceStatus_oid;
extern AsnObjectIdentifier hrDeviceErrors_oid;
#define HRDEVICETYPE_CODE 2
#define HRDEVICETYPE_SEQ HRDEVICEENTRY_SEQ, 2
#define HRDEVICETYPE_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEDESC_CODE 3
#define HRDEVICEDESC_SEQ HRDEVICEENTRY_SEQ, 3
#define HRDEVICEDESC_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEID_CODE 4
#define HRDEVICEID_SEQ HRDEVICEENTRY_SEQ, 4
#define HRDEVICEID_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICESTATUS_CODE 5
#define HRDEVICESTATUS_SEQ HRDEVICEENTRY_SEQ, 5
#define HRDEVICESTATUS_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEERRORS_CODE 6
#define HRDEVICEERRORS_SEQ HRDEVICEENTRY_SEQ, 6
#define HRDEVICEERRORS_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEINDEX_CODE 1
#define HRDEVICEINDEX_SEQ HRDEVICEENTRY_SEQ, 1
#define HRDEVICEINDEX_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEENTRY_VAR_INDEX  ( HRDEVICEENTRY_LENGTH + 1 )
#define MIN_HRDEVICEENTRY_CODE 1
#define MAX_HRDEVICEENTRY_CODE 6
extern AsnObjectIdentifier hrDeviceEntry_oid;
extern AsnObjectIdentifier hrProcessorFrwID_oid;
extern AsnObjectIdentifier hrProcessorLoad_oid;
#define HRPROCESSORFRWID_CODE 1
#define HRPROCESSORFRWID_SEQ HRPROCESSORENTRY_SEQ, 1
#define HRPROCESSORFRWID_LENGTH ( HRPROCESSORENTRY_LENGTH + 1  )
#define HRPROCESSORLOAD_CODE 2
#define HRPROCESSORLOAD_SEQ HRPROCESSORENTRY_SEQ, 2
#define HRPROCESSORLOAD_LENGTH ( HRPROCESSORENTRY_LENGTH + 1  )
#define HRPROCESSORENTRY_VAR_INDEX  ( HRPROCESSORENTRY_LENGTH + 1 )
#define MIN_HRPROCESSORENTRY_CODE 1
#define MAX_HRPROCESSORENTRY_CODE 2
extern AsnObjectIdentifier hrProcessorEntry_oid;
extern AsnObjectIdentifier hrNetworkIfIndex_oid;
#define HRNETWORKIFINDEX_CODE 1
#define HRNETWORKIFINDEX_SEQ HRNETWORKENTRY_SEQ, 1
#define HRNETWORKIFINDEX_LENGTH ( HRNETWORKENTRY_LENGTH + 1  )
#define HRNETWORKENTRY_VAR_INDEX  ( HRNETWORKENTRY_LENGTH + 1 )
#define MIN_HRNETWORKENTRY_CODE 1
#define MAX_HRNETWORKENTRY_CODE 1
extern AsnObjectIdentifier hrNetworkEntry_oid;
extern AsnObjectIdentifier hrPrinterStatus_oid;
extern AsnObjectIdentifier hrPrinterDetectedErrorState_oid;
#define HRPRINTERSTATUS_CODE 1
#define HRPRINTERSTATUS_SEQ HRPRINTERENTRY_SEQ, 1
#define HRPRINTERSTATUS_LENGTH ( HRPRINTERENTRY_LENGTH + 1  )
#define HRPRINTERDETECTEDERRORSTATE_CODE 2
#define HRPRINTERDETECTEDERRORSTATE_SEQ HRPRINTERENTRY_SEQ, 2
#define HRPRINTERDETECTEDERRORSTATE_LENGTH ( HRPRINTERENTRY_LENGTH + 1  )
#define HRPRINTERENTRY_VAR_INDEX  ( HRPRINTERENTRY_LENGTH + 1 )
#define MIN_HRPRINTERENTRY_CODE 1
#define MAX_HRPRINTERENTRY_CODE 2
extern AsnObjectIdentifier hrPrinterEntry_oid;
extern AsnObjectIdentifier hrDiskStorageAccess_oid;
extern AsnObjectIdentifier hrDiskStorageMedia_oid;
extern AsnObjectIdentifier hrDiskStorageRemoveble_oid;
extern AsnObjectIdentifier hrDiskStorageCapacity_oid;
#define HRDISKSTORAGEACCESS_CODE 1
#define HRDISKSTORAGEACCESS_SEQ HRDISKSTORAGEENTRY_SEQ, 1
#define HRDISKSTORAGEACCESS_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGEMEDIA_CODE 2
#define HRDISKSTORAGEMEDIA_SEQ HRDISKSTORAGEENTRY_SEQ, 2
#define HRDISKSTORAGEMEDIA_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGEREMOVEBLE_CODE 3
#define HRDISKSTORAGEREMOVEBLE_SEQ HRDISKSTORAGEENTRY_SEQ, 3
#define HRDISKSTORAGEREMOVEBLE_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGECAPACITY_CODE 4
#define HRDISKSTORAGECAPACITY_SEQ HRDISKSTORAGEENTRY_SEQ, 4
#define HRDISKSTORAGECAPACITY_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGEENTRY_VAR_INDEX  ( HRDISKSTORAGEENTRY_LENGTH + 1 )
#define MIN_HRDISKSTORAGEENTRY_CODE 1
#define MAX_HRDISKSTORAGEENTRY_CODE 4
extern AsnObjectIdentifier hrDiskStorageEntry_oid;
extern AsnObjectIdentifier hrPartitionIndex_oid;
extern AsnObjectIdentifier hrPartitionLabel_oid;
extern AsnObjectIdentifier hrPartitionID_oid;
extern AsnObjectIdentifier hrPartitionSize_oid;
extern AsnObjectIdentifier hrPartitionFSIndex_oid;
#define HRPARTITIONINDEX_CODE 1
#define HRPARTITIONINDEX_SEQ HRPARTITIONENTRY_SEQ, 1
#define HRPARTITIONINDEX_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONLABEL_CODE 2
#define HRPARTITIONLABEL_SEQ HRPARTITIONENTRY_SEQ, 2
#define HRPARTITIONLABEL_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONID_CODE 3
#define HRPARTITIONID_SEQ HRPARTITIONENTRY_SEQ, 3
#define HRPARTITIONID_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONSIZE_CODE 4
#define HRPARTITIONSIZE_SEQ HRPARTITIONENTRY_SEQ, 4
#define HRPARTITIONSIZE_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONFSINDEX_CODE 5
#define HRPARTITIONFSINDEX_SEQ HRPARTITIONENTRY_SEQ, 5
#define HRPARTITIONFSINDEX_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONENTRY_VAR_INDEX  ( HRPARTITIONENTRY_LENGTH + 1 )
#define MIN_HRPARTITIONENTRY_CODE 1
#define MAX_HRPARTITIONENTRY_CODE 5
extern AsnObjectIdentifier hrPartitionEntry_oid;
extern AsnObjectIdentifier hrFSIndex_oid;
extern AsnObjectIdentifier hrFSMountPoint_oid;
extern AsnObjectIdentifier hrFSRemoteMountPoint_oid;
extern AsnObjectIdentifier hrFSType_oid;
extern AsnObjectIdentifier hrFSAccess_oid;
extern AsnObjectIdentifier hrFSBootable_oid;
extern AsnObjectIdentifier hrFSStorageIndex_oid;
extern AsnObjectIdentifier hrFSLastFullBackupDate_oid;
extern AsnObjectIdentifier hrFSLastPartialBackupDate_oid;
#define HRFSINDEX_CODE 1
#define HRFSINDEX_SEQ HRFSENTRY_SEQ, 1
#define HRFSINDEX_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSMOUNTPOINT_CODE 2
#define HRFSMOUNTPOINT_SEQ HRFSENTRY_SEQ, 2
#define HRFSMOUNTPOINT_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSREMOTEMOUNTPOINT_CODE 3
#define HRFSREMOTEMOUNTPOINT_SEQ HRFSENTRY_SEQ, 3
#define HRFSREMOTEMOUNTPOINT_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSTYPE_CODE 4
#define HRFSTYPE_SEQ HRFSENTRY_SEQ, 4
#define HRFSTYPE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSACCESS_CODE 5
#define HRFSACCESS_SEQ HRFSENTRY_SEQ, 5
#define HRFSACCESS_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSBOOTABLE_CODE 6
#define HRFSBOOTABLE_SEQ HRFSENTRY_SEQ, 6
#define HRFSBOOTABLE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSSTORAGEINDEX_CODE 7
#define HRFSSTORAGEINDEX_SEQ HRFSENTRY_SEQ, 7
#define HRFSSTORAGEINDEX_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSLASTFULLBACKUPDATE_CODE 8
#define HRFSLASTFULLBACKUPDATE_SEQ HRFSENTRY_SEQ, 8
#define HRFSLASTFULLBACKUPDATE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSLASTPARTIALBACKUPDATE_CODE 9
#define HRFSLASTPARTIALBACKUPDATE_SEQ HRFSENTRY_SEQ, 9
#define HRFSLASTPARTIALBACKUPDATE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSENTRY_VAR_INDEX  ( HRFSENTRY_LENGTH + 1 )
#define MIN_HRFSENTRY_CODE 1
#define MAX_HRFSENTRY_CODE 9
extern AsnObjectIdentifier hrFSEntry_oid;
extern AsnObjectIdentifier hrFSOther_oid;
extern AsnObjectIdentifier hrFSUnknown_oid;
extern AsnObjectIdentifier hrFSBerkeleyFFS_oid;
extern AsnObjectIdentifier hrFSSys5FS_oid;
extern AsnObjectIdentifier hrFSFat_oid;
extern AsnObjectIdentifier hrFSHPFS_oid;
extern AsnObjectIdentifier hrFSHFS_oid;
extern AsnObjectIdentifier hrFSMFS_oid;
extern AsnObjectIdentifier hrFSNTFS_oid;
extern AsnObjectIdentifier hrFSVNode_oid;
extern AsnObjectIdentifier hrFSJournaled_oid;
extern AsnObjectIdentifier hrFSiso9660_oid;
extern AsnObjectIdentifier hrFSRockRidge_oid;
extern AsnObjectIdentifier hrFSNFS_oid;
extern AsnObjectIdentifier hrFSNetware_oid;
extern AsnObjectIdentifier hrFSAFS_oid;
extern AsnObjectIdentifier hrFSDFS_oid;
extern AsnObjectIdentifier hrFSApplshare_oid;
extern AsnObjectIdentifier hrFSRFS_oid;
extern AsnObjectIdentifier hrFSDGFS_oid;
extern AsnObjectIdentifier hrFSBFS_oid;
#define HRFSOTHER_CODE 1
#define HRFSOTHER_SEQ HRFSTYPES_SEQ, 1
#define HRFSOTHER_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSUNKNOWN_CODE 2
#define HRFSUNKNOWN_SEQ HRFSTYPES_SEQ, 2
#define HRFSUNKNOWN_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSBERKELEYFFS_CODE 3
#define HRFSBERKELEYFFS_SEQ HRFSTYPES_SEQ, 3
#define HRFSBERKELEYFFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSSYS5FS_CODE 4
#define HRFSSYS5FS_SEQ HRFSTYPES_SEQ, 4
#define HRFSSYS5FS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSFAT_CODE 5
#define HRFSFAT_SEQ HRFSTYPES_SEQ, 5
#define HRFSFAT_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSHPFS_CODE 6
#define HRFSHPFS_SEQ HRFSTYPES_SEQ, 6
#define HRFSHPFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSHFS_CODE 7
#define HRFSHFS_SEQ HRFSTYPES_SEQ, 7
#define HRFSHFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSMFS_CODE 8
#define HRFSMFS_SEQ HRFSTYPES_SEQ, 8
#define HRFSMFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSNTFS_CODE 9
#define HRFSNTFS_SEQ HRFSTYPES_SEQ, 9
#define HRFSNTFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSVNODE_CODE 10
#define HRFSVNODE_SEQ HRFSTYPES_SEQ, 10
#define HRFSVNODE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSJOURNALED_CODE 11
#define HRFSJOURNALED_SEQ HRFSTYPES_SEQ, 11
#define HRFSJOURNALED_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSISO9660_CODE 12
#define HRFSISO9660_SEQ HRFSTYPES_SEQ, 12
#define HRFSISO9660_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSROCKRIDGE_CODE 13
#define HRFSROCKRIDGE_SEQ HRFSTYPES_SEQ, 13
#define HRFSROCKRIDGE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSNFS_CODE 14
#define HRFSNFS_SEQ HRFSTYPES_SEQ, 14
#define HRFSNFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSNETWARE_CODE 15
#define HRFSNETWARE_SEQ HRFSTYPES_SEQ, 15
#define HRFSNETWARE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSAFS_CODE 16
#define HRFSAFS_SEQ HRFSTYPES_SEQ, 16
#define HRFSAFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSDFS_CODE 17
#define HRFSDFS_SEQ HRFSTYPES_SEQ, 17
#define HRFSDFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSAPPLSHARE_CODE 18
#define HRFSAPPLSHARE_SEQ HRFSTYPES_SEQ, 18
#define HRFSAPPLSHARE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSRFS_CODE 19
#define HRFSRFS_SEQ HRFSTYPES_SEQ, 19
#define HRFSRFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSDGFS_CODE 20
#define HRFSDGFS_SEQ HRFSTYPES_SEQ, 20
#define HRFSDGFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSBFS_CODE 21
#define HRFSBFS_SEQ HRFSTYPES_SEQ, 21
#define HRFSBFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
extern AsnObjectIdentifier hrFSTypes_oid;
extern AsnObjectIdentifier hrSWOSIndex_oid;
#define HRSWOSINDEX_CODE 1
#define HRSWOSINDEX_SEQ HRSWRUN_SEQ, 1
#define HRSWOSINDEX_LENGTH ( HRSWRUN_LENGTH + 1  )
#define HRSWRUN_VAR_INDEX  ( HRSWRUN_LENGTH + 1 )
#define MIN_HRSWRUN_CODE 1
#define MAX_HRSWRUN_CODE 1
extern AsnObjectIdentifier hrSWRun_oid;
extern AsnObjectIdentifier hrSWRunIndex_oid;
extern AsnObjectIdentifier hrSWRunName_oid;
extern AsnObjectIdentifier hrSWRunID_oid;
extern AsnObjectIdentifier hrSWRunPath_oid;
extern AsnObjectIdentifier hrSWRunParameters_oid;
extern AsnObjectIdentifier hrSWRunType_oid;
extern AsnObjectIdentifier hrSWRunStatus_oid;
#define HRSWRUNINDEX_CODE 1
#define HRSWRUNINDEX_SEQ HRSWRUNENTRY_SEQ, 1
#define HRSWRUNINDEX_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNNAME_CODE 2
#define HRSWRUNNAME_SEQ HRSWRUNENTRY_SEQ, 2
#define HRSWRUNNAME_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNID_CODE 3
#define HRSWRUNID_SEQ HRSWRUNENTRY_SEQ, 3
#define HRSWRUNID_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNPATH_CODE 4
#define HRSWRUNPATH_SEQ HRSWRUNENTRY_SEQ, 4
#define HRSWRUNPATH_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNPARAMETERS_CODE 5
#define HRSWRUNPARAMETERS_SEQ HRSWRUNENTRY_SEQ, 5
#define HRSWRUNPARAMETERS_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNENTRY_VAR_INDEX  ( HRSWRUNENTRY_LENGTH + 1 )
#define HRSWRUNTYPE_CODE 6
#define HRSWRUNTYPE_SEQ HRSWRUNENTRY_SEQ, 6
#define HRSWRUNTYPE_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNSTATUS_CODE 7
#define HRSWRUNSTATUS_SEQ HRSWRUNENTRY_SEQ, 7
#define HRSWRUNSTATUS_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNENTRY_VAR_INDEX  ( HRSWRUNENTRY_LENGTH + 1 )
#define MIN_HRSWRUNENTRY_CODE 1
#define MAX_HRSWRUNENTRY_CODE 7
extern AsnObjectIdentifier hrSWRunEntry_oid;
#define HRSWRUNPERF_VAR_INDEX  ( HRSWRUNPERF_LENGTH + 1 )
extern AsnObjectIdentifier hrSWRunPerfCPU_oid;
extern AsnObjectIdentifier hrSWRunPerfMem_oid;
#define HRSWRUNPERFCPU_CODE 1
#define HRSWRUNPERFCPU_SEQ HRSWRUNPERFENTRY_SEQ, 1
#define HRSWRUNPERFCPU_LENGTH ( HRSWRUNPERFENTRY_LENGTH + 1  )
#define HRSWRUNPERFMEM_CODE 2
#define HRSWRUNPERFMEM_SEQ HRSWRUNPERFENTRY_SEQ, 2
#define HRSWRUNPERFMEM_LENGTH ( HRSWRUNPERFENTRY_LENGTH + 1  )
#define HRSWRUNPERFENTRY_VAR_INDEX  ( HRSWRUNPERFENTRY_LENGTH + 1 )
#define MIN_HRSWRUNPERFENTRY_CODE 1
#define MAX_HRSWRUNPERFENTRY_CODE 2
extern AsnObjectIdentifier hrSWRunPerfEntry_oid;
extern AsnObjectIdentifier hrSWInstalledLastChange_oid;
extern AsnObjectIdentifier hrSWInstalledLastUpdateTime_oid;
#define HRSWINSTALLEDLASTCHANGE_CODE 1
#define HRSWINSTALLEDLASTCHANGE_SEQ HRSWINSTALLED_SEQ, 1
#define HRSWINSTALLEDLASTCHANGE_LENGTH ( HRSWINSTALLED_LENGTH + 1  )
#define HRSWINSTALLEDLASTUPDATETIME_CODE 2
#define HRSWINSTALLEDLASTUPDATETIME_SEQ HRSWINSTALLED_SEQ, 2
#define HRSWINSTALLEDLASTUPDATETIME_LENGTH ( HRSWINSTALLED_LENGTH + 1  )
#define HRSWINSTALLED_VAR_INDEX  ( HRSWINSTALLED_LENGTH + 1 )
#define MIN_HRSWINSTALLED_CODE 1
#define MAX_HRSWINSTALLED_CODE 2
extern AsnObjectIdentifier hrSWInstalled_oid;
extern AsnObjectIdentifier hrSWInstalledIndex_oid;
extern AsnObjectIdentifier hrSWInstalledName_oid;
extern AsnObjectIdentifier hrSWInstalledID_oid;
extern AsnObjectIdentifier hrSWInstalledType_oid;
extern AsnObjectIdentifier hrSWInstalledDate_oid;
#define HRSWINSTALLEDINDEX_CODE 1
#define HRSWINSTALLEDINDEX_SEQ HRSWINSTALLEDENTRY_SEQ, 1
#define HRSWINSTALLEDINDEX_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDNAME_CODE 2
#define HRSWINSTALLEDNAME_SEQ HRSWINSTALLEDENTRY_SEQ, 2
#define HRSWINSTALLEDNAME_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDID_CODE 3
#define HRSWINSTALLEDID_SEQ HRSWINSTALLEDENTRY_SEQ, 3
#define HRSWINSTALLEDID_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDTYPE_CODE 4
#define HRSWINSTALLEDTYPE_SEQ HRSWINSTALLEDENTRY_SEQ, 4
#define HRSWINSTALLEDTYPE_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDDATE_CODE 5
#define HRSWINSTALLEDDATE_SEQ HRSWINSTALLEDENTRY_SEQ, 5
#define HRSWINSTALLEDDATE_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDENTRY_VAR_INDEX  ( HRSWINSTALLEDENTRY_LENGTH + 1 )
#define MIN_HRSWINSTALLEDENTRY_CODE 1
#define MAX_HRSWINSTALLEDENTRY_CODE 5
extern AsnObjectIdentifier hrSWInstalledEntry_oid;
#define CLASS_TABLE_MAX 15

UINT
GetHrSystemUptime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemInitialLoadDevice( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrSystemInitialLoadDevice( 
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemInitialLoadParameters( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrSystemInitialLoadParameters( 
        IN InternationalDisplayString *invalue ,
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemNumUsers( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemProcesses( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemMaxProcesses( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSystemFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSystemFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSystemConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSystemFreeInstance( IN OUT InstanceName *instance );

//  HrSWRunEntry.c 

UINT
GetHrSWRunIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunName( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunPath( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunParameters( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunType( 
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunStatus( 
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrSWRunStatus( 
        IN INThrSWRunStatus *invalue ,
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWRunEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWRunEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWRunEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWRunEntryFreeInstance( IN OUT InstanceName *instance );

//  HrSWRun.c 

UINT
GetHrSWOSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWRunFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWRunFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWRunConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWRunFreeInstance( IN OUT InstanceName *instance );

// HrSWRunPerfEntry.c 

UINT
GetHrSWRunPerfCPU( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunPerfMem( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWRunPerfEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWRunPerfEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWRunPerfEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWRunPerfEntryFreeInstance( IN OUT InstanceName *instance );

//  HrSWInstalled.c 

UINT
GetHrSWInstalledLastChange( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledLastUpdateTime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWInstalledFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWInstalledFreeInstance( IN OUT InstanceName *instance );

// HrStorage.c 

UINT
GetHrMemorySize( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrStorageFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrStorageFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrStorageConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrStorageFreeInstance( IN OUT InstanceName *instance );

// HrStorageEntry.c 

UINT
GetHrStorageIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageDesc( 
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageAllocationUnits( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageSize( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrStorageSize( 
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageUsed( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageAllocationFailures( 
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrStorageEntryFreeInstance( IN OUT InstanceName *instance );

// HrProcessorEntry.c 

UINT
GetHrProcessorFrwID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrProcessorLoad( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrProcessorEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrProcessorEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrProcessorEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrProcessorEntryFreeInstance( IN OUT InstanceName *instance );

// HrPrinterEntry.c 

UINT
GetHrPrinterStatus( 
        OUT INThrPrinterStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPrinterDetectedErrorState( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrPrinterEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrPrinterEntryFreeInstance( IN OUT InstanceName *instance );

// HrPrinterEntry.c 

UINT
GetHrPrinterStatus( 
        OUT INThrPrinterStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPrinterDetectedErrorState( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrPrinterEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrPrinterEntryFreeInstance( IN OUT InstanceName *instance );

//  HrPartitionEntry.c 

UINT
GetHrPartitionIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionLabel( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionID( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionSize( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrPartitionEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrPartitionEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrPartitionEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrPartitionEntryFreeInstance( IN OUT InstanceName *instance );

//  HrNetworkEntry.c 

UINT
GetHrNetworkIfIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrNetworkEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrNetworkEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrNetworkEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrNetworkEntryFreeInstance( IN OUT InstanceName *instance );

//  HrFSEntry.c 

UINT
GetHrFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSRemoteMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSBootable( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSStorageIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSLastFullBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrFSLastFullBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSLastPartialBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrFSLastPartialBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrFSEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrFSEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrFSEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrFSEntryFreeInstance( IN OUT InstanceName *instance );

// HrDiskStorageEntry.c 

UINT
GetHrDiskStorageAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDiskStorageMedia( 
        OUT INThrDiskStorageMedia *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDiskStorageRemoveble( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDiskStorageCapacity( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrDiskStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrDiskStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrDiskStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrDiskStorageEntryFreeInstance( IN OUT InstanceName *instance );

// HrDeviceEntry.c 

UINT
GetHrDeviceIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceDesc( 
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceStatus( 
        OUT INThrDeviceStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceErrors( 
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrDeviceEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrDeviceEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrDeviceEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrDeviceEntryFreeInstance( IN OUT InstanceName *instance );

//  hostmsmi.c

UINT
SMIGetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue );
UINT
SMIGetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue );
UINT
SMIGetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue );

// HrSWInstalledEntry.c 

UINT
GetHrSWInstalledIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledName( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledType( 
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWInstalledEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWInstalledEntryFreeInstance( IN OUT InstanceName *instance );



/*
|==============================================================================
| hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine
*/
void
hrProcessLoad_Refresh(
                      void
                      );

/*
|==============================================================================
| Magic "Fetch Instance" Macro
|
| This macro decodes an "InstanceName" structure given the HostMIB's indices
| which are always simple numbers.
*/
#define GET_INSTANCE(n) (*((ULONG *)(instance->array[n])))

#endif // mib_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\mib.c ===
/*
 *  mib.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains oids and tables used for the table driven design.
 *
 *  Functions:
 *
 *    UserMibInit()
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc.  Genned: Thu Nov 07 16:38:27 1996
 *
 *
 *  Revision History:
 *
 *      04/15/97        Changed "mibEventValue" to "hostmib.dll" from
 *                              "gendll.dll", and
 *                              "eventLogString" to "HostMIBAgent"
 *                              from "GenAgent".
 */


#include <windows.h>
#include <malloc.h>
#include <stdio.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"

#include "HMCACHE.H"    // For Cache-build function prototypes

//
// Text String used in logging to the Application Event log
//

    //
    //  THE EVENT AND DLL STRINGS ARE DECLARED HERE - FILLED IN BY CASE TOOL.
    //  note- nyi, null strings supplied temporarily
    //

char eventLogString[13] = "HostMIBAgent\0" ;
char *EventLogString = eventLogString ;

char mibEventValue[12] = "hostmib.dll\0" ;

//
//  BEGIN generated code:
//	OIDs
//	variable_t table for the attributes of each class
//	class_info containing information about each class
//
//  NOTE:  This stub code will not work if a table exists in the middle of a
//	group. It will work if all tables are at the end of the group.
//
//	Variable tables
//		A NULL entry exists for each "hole" in the sequence of
//		attributes. For example, if attributes 1, 3, 4, and 7 are
//		defined, there will be a NULL entry in the variable table
//		corresponding to attribute 2, 5, and 6.  There is always
//		a NULL entry for 0 in the variable tables, since 0 is an
//		invalid OID arc value for an attribute.
//
//	Class table
//		The class table entries are ordered lexicographically to
//		facilitate SNMP GetNext processing.
//
static
UINT
subroot_array [ SUBROOT_LENGTH ] = {1, 3, 6, 1, 2, 1, 25 } ;
AsnObjectIdentifier
Subroot_oid = { SUBROOT_LENGTH, subroot_array } ;
static
UINT
host_array[ HOST_LENGTH ] = { HOST_SEQ } ;
AsnObjectIdentifier
host_oid = { HOST_LENGTH, host_array } ;
static
UINT
hrSystemUptime_array[ HRSYSTEMUPTIME_LENGTH ] = { HRSYSTEMUPTIME_SEQ } ;
AsnObjectIdentifier
hrSystemUptime_oid = { HRSYSTEMUPTIME_LENGTH, hrSystemUptime_array } ;
static
UINT
hrSystemDate_array[ HRSYSTEMDATE_LENGTH ] = { HRSYSTEMDATE_SEQ } ;
AsnObjectIdentifier
hrSystemDate_oid = { HRSYSTEMDATE_LENGTH, hrSystemDate_array } ;
static
UINT
hrSystemInitialLoadDevice_array[ HRSYSTEMINITIALLOADDEVICE_LENGTH ] = { HRSYSTEMINITIALLOADDEVICE_SEQ } ;
AsnObjectIdentifier
hrSystemInitialLoadDevice_oid = { HRSYSTEMINITIALLOADDEVICE_LENGTH, hrSystemInitialLoadDevice_array } ;
static
UINT
hrSystemInitialLoadParameters_array[ HRSYSTEMINITIALLOADPARAMETERS_LENGTH ] = { HRSYSTEMINITIALLOADPARAMETERS_SEQ } ;
AsnObjectIdentifier
hrSystemInitialLoadParameters_oid = { HRSYSTEMINITIALLOADPARAMETERS_LENGTH, hrSystemInitialLoadParameters_array } ;
static
UINT
hrSystemNumUsers_array[ HRSYSTEMNUMUSERS_LENGTH ] = { HRSYSTEMNUMUSERS_SEQ } ;
AsnObjectIdentifier
hrSystemNumUsers_oid = { HRSYSTEMNUMUSERS_LENGTH, hrSystemNumUsers_array } ;
static
UINT
hrSystemProcesses_array[ HRSYSTEMPROCESSES_LENGTH ] = { HRSYSTEMPROCESSES_SEQ } ;
AsnObjectIdentifier
hrSystemProcesses_oid = { HRSYSTEMPROCESSES_LENGTH, hrSystemProcesses_array } ;
static
UINT
hrSystemMaxProcesses_array[ HRSYSTEMMAXPROCESSES_LENGTH ] = { HRSYSTEMMAXPROCESSES_SEQ } ;
AsnObjectIdentifier
hrSystemMaxProcesses_oid = { HRSYSTEMMAXPROCESSES_LENGTH, hrSystemMaxProcesses_array } ;
static
UINT
hrSystem_array[ HRSYSTEM_LENGTH ] = { HRSYSTEM_SEQ } ;
AsnObjectIdentifier
hrSystem_oid = { HRSYSTEM_LENGTH, hrSystem_array } ;
variable_t
    hrSystem_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSystemUptime_oid, ASN_RFC1155_TIMETICKS, NSM_READ_ONLY,
      GetHrSystemUptime, NULL,
      SMIGetTimeTicks, SMISetTimeTicks } , 
    { &hrSystemDate_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSystemDate, NULL,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    { &hrSystemInitialLoadDevice_oid, ASN_INTEGER, NSM_READ_WRITE,
      GetHrSystemInitialLoadDevice, SetHrSystemInitialLoadDevice,
      SMIGetInteger, SMISetInteger } , 
    { &hrSystemInitialLoadParameters_oid, ASN_OCTETSTRING, NSM_READ_WRITE,
      GetHrSystemInitialLoadParameters, SetHrSystemInitialLoadParameters,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSystemNumUsers_oid, ASN_RFC1155_GAUGE, NSM_READ_ONLY,
      GetHrSystemNumUsers, NULL,
      SMIGetGauge, SMISetGauge } , 
    { &hrSystemProcesses_oid, ASN_RFC1155_GAUGE, NSM_READ_ONLY,
      GetHrSystemProcesses, NULL,
      SMIGetGauge, SMISetGauge } , 
    { &hrSystemMaxProcesses_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSystemMaxProcesses, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSystem_set_array[ MAX_HRSYSTEM_CODE + 1];
//  extern BYTE hrSystem_set_array[] ;
extern variable_t hrSystem_var_table[] ;
static
UINT
hrMemorySize_array[ HRMEMORYSIZE_LENGTH ] = { HRMEMORYSIZE_SEQ } ;
AsnObjectIdentifier
hrMemorySize_oid = { HRMEMORYSIZE_LENGTH, hrMemorySize_array } ;
static
UINT
hrStorage_array[ HRSTORAGE_LENGTH ] = { HRSTORAGE_SEQ } ;
AsnObjectIdentifier
hrStorage_oid = { HRSTORAGE_LENGTH, hrStorage_array } ;
variable_t
    hrStorage_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrMemorySize_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrMemorySize, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrStorage_set_array[ MAX_HRSTORAGE_CODE + 1];
//  extern BYTE hrStorage_set_array[] ;
extern variable_t hrStorage_var_table[] ;
static
UINT
hrStorageOther_array[ HRSTORAGEOTHER_LENGTH ] = { HRSTORAGEOTHER_SEQ } ;
AsnObjectIdentifier
hrStorageOther_oid = { HRSTORAGEOTHER_LENGTH, hrStorageOther_array } ;
static
UINT
hrStorageRAM_array[ HRSTORAGERAM_LENGTH ] = { HRSTORAGERAM_SEQ } ;
AsnObjectIdentifier
hrStorageRAM_oid = { HRSTORAGERAM_LENGTH, hrStorageRAM_array } ;
static
UINT
hrStorageVirtualMemory_array[ HRSTORAGEVIRTUALMEMORY_LENGTH ] = { HRSTORAGEVIRTUALMEMORY_SEQ } ;
AsnObjectIdentifier
hrStorageVirtualMemory_oid = { HRSTORAGEVIRTUALMEMORY_LENGTH, hrStorageVirtualMemory_array } ;
static
UINT
hrStorageFixedDisk_array[ HRSTORAGEFIXEDDISK_LENGTH ] = { HRSTORAGEFIXEDDISK_SEQ } ;
AsnObjectIdentifier
hrStorageFixedDisk_oid = { HRSTORAGEFIXEDDISK_LENGTH, hrStorageFixedDisk_array } ;
static
UINT
hrStorageRemovableDisk_array[ HRSTORAGEREMOVABLEDISK_LENGTH ] = { HRSTORAGEREMOVABLEDISK_SEQ } ;
AsnObjectIdentifier
hrStorageRemovableDisk_oid = { HRSTORAGEREMOVABLEDISK_LENGTH, hrStorageRemovableDisk_array } ;
static
UINT
hrStorageFloppyDisk_array[ HRSTORAGEFLOPPYDISK_LENGTH ] = { HRSTORAGEFLOPPYDISK_SEQ } ;
AsnObjectIdentifier
hrStorageFloppyDisk_oid = { HRSTORAGEFLOPPYDISK_LENGTH, hrStorageFloppyDisk_array } ;
static
UINT
hrStorageCompactDisk_array[ HRSTORAGECOMPACTDISK_LENGTH ] = { HRSTORAGECOMPACTDISK_SEQ } ;
AsnObjectIdentifier
hrStorageCompactDisk_oid = { HRSTORAGECOMPACTDISK_LENGTH, hrStorageCompactDisk_array } ;
static
UINT
hrStorageRamDisk_array[ HRSTORAGERAMDISK_LENGTH ] = { HRSTORAGERAMDISK_SEQ } ;
AsnObjectIdentifier
hrStorageRamDisk_oid = { HRSTORAGERAMDISK_LENGTH, hrStorageRamDisk_array } ;
static
UINT
hrStorageTypes_array[ HRSTORAGETYPES_LENGTH ] = { HRSTORAGETYPES_SEQ } ;
AsnObjectIdentifier
hrStorageTypes_oid = { HRSTORAGETYPES_LENGTH, hrStorageTypes_array } ;
static
UINT
hrStorageIndex_array[ HRSTORAGEINDEX_LENGTH ] = { HRSTORAGEINDEX_SEQ } ;
AsnObjectIdentifier
hrStorageIndex_oid = { HRSTORAGEINDEX_LENGTH, hrStorageIndex_array } ;
static
UINT
hrStorageType_array[ HRSTORAGETYPE_LENGTH ] = { HRSTORAGETYPE_SEQ } ;
AsnObjectIdentifier
hrStorageType_oid = { HRSTORAGETYPE_LENGTH, hrStorageType_array } ;
static
UINT
hrStorageDesc_array[ HRSTORAGEDESC_LENGTH ] = { HRSTORAGEDESC_SEQ } ;
AsnObjectIdentifier
hrStorageDesc_oid = { HRSTORAGEDESC_LENGTH, hrStorageDesc_array } ;
static
UINT
hrStorageAllocationUnits_array[ HRSTORAGEALLOCATIONUNITS_LENGTH ] = { HRSTORAGEALLOCATIONUNITS_SEQ } ;
AsnObjectIdentifier
hrStorageAllocationUnits_oid = { HRSTORAGEALLOCATIONUNITS_LENGTH, hrStorageAllocationUnits_array } ;
static
UINT
hrStorageSize_array[ HRSTORAGESIZE_LENGTH ] = { HRSTORAGESIZE_SEQ } ;
AsnObjectIdentifier
hrStorageSize_oid = { HRSTORAGESIZE_LENGTH, hrStorageSize_array } ;
static
UINT
hrStorageUsed_array[ HRSTORAGEUSED_LENGTH ] = { HRSTORAGEUSED_SEQ } ;
AsnObjectIdentifier
hrStorageUsed_oid = { HRSTORAGEUSED_LENGTH, hrStorageUsed_array } ;
static
UINT
hrStorageAllocationFailures_array[ HRSTORAGEALLOCATIONFAILURES_LENGTH ] = { HRSTORAGEALLOCATIONFAILURES_SEQ } ;
AsnObjectIdentifier
hrStorageAllocationFailures_oid = { HRSTORAGEALLOCATIONFAILURES_LENGTH, hrStorageAllocationFailures_array } ;
static
UINT
hrStorageEntry_array[ HRSTORAGEENTRY_LENGTH ] = { HRSTORAGEENTRY_SEQ } ;
AsnObjectIdentifier
hrStorageEntry_oid = { HRSTORAGEENTRY_LENGTH, hrStorageEntry_array } ;
variable_t
    hrStorageEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrStorageIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrStorageIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageType_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrStorageType, NULL,
      SMIGetObjectId, SMISetObjectId } , 
    { &hrStorageDesc_oid, ASN_RFC1213_DISPSTRING, NSM_READ_ONLY,
      GetHrStorageDesc, NULL,
      SMIGetDispString, SMISetDispString } , 
    { &hrStorageAllocationUnits_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrStorageAllocationUnits, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageSize_oid, ASN_INTEGER, NSM_READ_WRITE,
      GetHrStorageSize, SetHrStorageSize,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageUsed_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrStorageUsed, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageAllocationFailures_oid, ASN_RFC1155_COUNTER, NSM_READ_ONLY,
      GetHrStorageAllocationFailures, NULL,
      SMIGetCounter, SMISetCounter } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrStorageEntry_set_array[ MAX_HRSTORAGEENTRY_CODE + 1];
//  extern BYTE hrStorageEntry_set_array[] ;
extern variable_t hrStorageEntry_var_table[] ;
static
UINT
hrDeviceOther_array[ HRDEVICEOTHER_LENGTH ] = { HRDEVICEOTHER_SEQ } ;
AsnObjectIdentifier
hrDeviceOther_oid = { HRDEVICEOTHER_LENGTH, hrDeviceOther_array } ;
static
UINT
hrDeviceUnknown_array[ HRDEVICEUNKNOWN_LENGTH ] = { HRDEVICEUNKNOWN_SEQ } ;
AsnObjectIdentifier
hrDeviceUnknown_oid = { HRDEVICEUNKNOWN_LENGTH, hrDeviceUnknown_array } ;
static
UINT
hrDeviceProcessor_array[ HRDEVICEPROCESSOR_LENGTH ] = { HRDEVICEPROCESSOR_SEQ } ;
AsnObjectIdentifier
hrDeviceProcessor_oid = { HRDEVICEPROCESSOR_LENGTH, hrDeviceProcessor_array } ;
static
UINT
hrDeviceNetwork_array[ HRDEVICENETWORK_LENGTH ] = { HRDEVICENETWORK_SEQ } ;
AsnObjectIdentifier
hrDeviceNetwork_oid = { HRDEVICENETWORK_LENGTH, hrDeviceNetwork_array } ;
static
UINT
hrDevicePrinter_array[ HRDEVICEPRINTER_LENGTH ] = { HRDEVICEPRINTER_SEQ } ;
AsnObjectIdentifier
hrDevicePrinter_oid = { HRDEVICEPRINTER_LENGTH, hrDevicePrinter_array } ;
static
UINT
hrDeviceDiskStorage_array[ HRDEVICEDISKSTORAGE_LENGTH ] = { HRDEVICEDISKSTORAGE_SEQ } ;
AsnObjectIdentifier
hrDeviceDiskStorage_oid = { HRDEVICEDISKSTORAGE_LENGTH, hrDeviceDiskStorage_array } ;
static
UINT
hrDeviceVideo_array[ HRDEVICEVIDEO_LENGTH ] = { HRDEVICEVIDEO_SEQ } ;
AsnObjectIdentifier
hrDeviceVideo_oid = { HRDEVICEVIDEO_LENGTH, hrDeviceVideo_array } ;
static
UINT
hrDeviceAudio_array[ HRDEVICEAUDIO_LENGTH ] = { HRDEVICEAUDIO_SEQ } ;
AsnObjectIdentifier
hrDeviceAudio_oid = { HRDEVICEAUDIO_LENGTH, hrDeviceAudio_array } ;
static
UINT
hrDeviceCoprocessor_array[ HRDEVICECOPROCESSOR_LENGTH ] = { HRDEVICECOPROCESSOR_SEQ } ;
AsnObjectIdentifier
hrDeviceCoprocessor_oid = { HRDEVICECOPROCESSOR_LENGTH, hrDeviceCoprocessor_array } ;
static
UINT
hrDeviceKeyboard_array[ HRDEVICEKEYBOARD_LENGTH ] = { HRDEVICEKEYBOARD_SEQ } ;
AsnObjectIdentifier
hrDeviceKeyboard_oid = { HRDEVICEKEYBOARD_LENGTH, hrDeviceKeyboard_array } ;
static
UINT
hrDeviceModem_array[ HRDEVICEMODEM_LENGTH ] = { HRDEVICEMODEM_SEQ } ;
AsnObjectIdentifier
hrDeviceModem_oid = { HRDEVICEMODEM_LENGTH, hrDeviceModem_array } ;
static
UINT
hrDeviceParallelPort_array[ HRDEVICEPARALLELPORT_LENGTH ] = { HRDEVICEPARALLELPORT_SEQ } ;
AsnObjectIdentifier
hrDeviceParallelPort_oid = { HRDEVICEPARALLELPORT_LENGTH, hrDeviceParallelPort_array } ;
static
UINT
hrDevicePointing_array[ HRDEVICEPOINTING_LENGTH ] = { HRDEVICEPOINTING_SEQ } ;
AsnObjectIdentifier
hrDevicePointing_oid = { HRDEVICEPOINTING_LENGTH, hrDevicePointing_array } ;
static
UINT
hrDeviceSerialPort_array[ HRDEVICESERIALPORT_LENGTH ] = { HRDEVICESERIALPORT_SEQ } ;
AsnObjectIdentifier
hrDeviceSerialPort_oid = { HRDEVICESERIALPORT_LENGTH, hrDeviceSerialPort_array } ;
static
UINT
hrDeviceTape_array[ HRDEVICETAPE_LENGTH ] = { HRDEVICETAPE_SEQ } ;
AsnObjectIdentifier
hrDeviceTape_oid = { HRDEVICETAPE_LENGTH, hrDeviceTape_array } ;
static
UINT
hrDeviceClock_array[ HRDEVICECLOCK_LENGTH ] = { HRDEVICECLOCK_SEQ } ;
AsnObjectIdentifier
hrDeviceClock_oid = { HRDEVICECLOCK_LENGTH, hrDeviceClock_array } ;
static
UINT
hrDeviceVolatileMemory_array[ HRDEVICEVOLATILEMEMORY_LENGTH ] = { HRDEVICEVOLATILEMEMORY_SEQ } ;
AsnObjectIdentifier
hrDeviceVolatileMemory_oid = { HRDEVICEVOLATILEMEMORY_LENGTH, hrDeviceVolatileMemory_array } ;
static
UINT
hrDeviceNonVolatileMemory_array[ HRDEVICENONVOLATILEMEMORY_LENGTH ] = { HRDEVICENONVOLATILEMEMORY_SEQ } ;
AsnObjectIdentifier
hrDeviceNonVolatileMemory_oid = { HRDEVICENONVOLATILEMEMORY_LENGTH, hrDeviceNonVolatileMemory_array } ;
static
UINT
hrDeviceTypes_array[ HRDEVICETYPES_LENGTH ] = { HRDEVICETYPES_SEQ } ;
AsnObjectIdentifier
hrDeviceTypes_oid = { HRDEVICETYPES_LENGTH, hrDeviceTypes_array } ;
static
UINT
hrDeviceIndex_array[ HRDEVICEINDEX_LENGTH ] = { HRDEVICEINDEX_SEQ } ;
AsnObjectIdentifier
hrDeviceIndex_oid = { HRDEVICEINDEX_LENGTH, hrDeviceIndex_array } ;
static
UINT
hrDeviceType_array[ HRDEVICETYPE_LENGTH ] = { HRDEVICETYPE_SEQ } ;
AsnObjectIdentifier
hrDeviceType_oid = { HRDEVICETYPE_LENGTH, hrDeviceType_array } ;
static
UINT
hrDeviceDesc_array[ HRDEVICEDESC_LENGTH ] = { HRDEVICEDESC_SEQ } ;
AsnObjectIdentifier
hrDeviceDesc_oid = { HRDEVICEDESC_LENGTH, hrDeviceDesc_array } ;
static
UINT
hrDeviceID_array[ HRDEVICEID_LENGTH ] = { HRDEVICEID_SEQ } ;
AsnObjectIdentifier
hrDeviceID_oid = { HRDEVICEID_LENGTH, hrDeviceID_array } ;
static
UINT
hrDeviceStatus_array[ HRDEVICESTATUS_LENGTH ] = { HRDEVICESTATUS_SEQ } ;
AsnObjectIdentifier
hrDeviceStatus_oid = { HRDEVICESTATUS_LENGTH, hrDeviceStatus_array } ;
static
UINT
hrDeviceErrors_array[ HRDEVICEERRORS_LENGTH ] = { HRDEVICEERRORS_SEQ } ;
AsnObjectIdentifier
hrDeviceErrors_oid = { HRDEVICEERRORS_LENGTH, hrDeviceErrors_array } ;
static
UINT
hrDeviceEntry_array[ HRDEVICEENTRY_LENGTH ] = { HRDEVICEENTRY_SEQ } ;
AsnObjectIdentifier
hrDeviceEntry_oid = { HRDEVICEENTRY_LENGTH, hrDeviceEntry_array } ;
variable_t
    hrDeviceEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrDeviceIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDeviceIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrDeviceType_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrDeviceType, NULL,
      SMIGetObjectId, SMISetObjectId } , 
    { &hrDeviceDesc_oid, ASN_RFC1213_DISPSTRING, NSM_READ_ONLY,
      GetHrDeviceDesc, NULL,
      SMIGetDispString, SMISetDispString } , 
    { &hrDeviceID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrDeviceID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrDeviceStatus_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDeviceStatus, NULL,
      SMIGetINThrDeviceStatus, SMISetINThrDeviceStatus } , 
    { &hrDeviceErrors_oid, ASN_RFC1155_COUNTER, NSM_READ_ONLY,
      GetHrDeviceErrors, NULL,
      SMIGetCounter, SMISetCounter } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrDeviceEntry_set_array[ MAX_HRDEVICEENTRY_CODE + 1];
//  extern BYTE hrDeviceEntry_set_array[] ;
extern variable_t hrDeviceEntry_var_table[] ;
static
UINT
hrProcessorFrwID_array[ HRPROCESSORFRWID_LENGTH ] = { HRPROCESSORFRWID_SEQ } ;
AsnObjectIdentifier
hrProcessorFrwID_oid = { HRPROCESSORFRWID_LENGTH, hrProcessorFrwID_array } ;
static
UINT
hrProcessorLoad_array[ HRPROCESSORLOAD_LENGTH ] = { HRPROCESSORLOAD_SEQ } ;
AsnObjectIdentifier
hrProcessorLoad_oid = { HRPROCESSORLOAD_LENGTH, hrProcessorLoad_array } ;
static
UINT
hrProcessorEntry_array[ HRPROCESSORENTRY_LENGTH ] = { HRPROCESSORENTRY_SEQ } ;
AsnObjectIdentifier
hrProcessorEntry_oid = { HRPROCESSORENTRY_LENGTH, hrProcessorEntry_array } ;
variable_t
    hrProcessorEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrProcessorFrwID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrProcessorFrwID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrProcessorLoad_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrProcessorLoad, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrProcessorEntry_set_array[ MAX_HRPROCESSORENTRY_CODE + 1];
//  extern BYTE hrProcessorEntry_set_array[] ;
extern variable_t hrProcessorEntry_var_table[] ;
static
UINT
hrNetworkIfIndex_array[ HRNETWORKIFINDEX_LENGTH ] = { HRNETWORKIFINDEX_SEQ } ;
AsnObjectIdentifier
hrNetworkIfIndex_oid = { HRNETWORKIFINDEX_LENGTH, hrNetworkIfIndex_array } ;
static
UINT
hrNetworkEntry_array[ HRNETWORKENTRY_LENGTH ] = { HRNETWORKENTRY_SEQ } ;
AsnObjectIdentifier
hrNetworkEntry_oid = { HRNETWORKENTRY_LENGTH, hrNetworkEntry_array } ;
variable_t
    hrNetworkEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrNetworkIfIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrNetworkIfIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrNetworkEntry_set_array[ MAX_HRNETWORKENTRY_CODE + 1];
//  extern BYTE hrNetworkEntry_set_array[] ;
extern variable_t hrNetworkEntry_var_table[] ;
static
UINT
hrPrinterStatus_array[ HRPRINTERSTATUS_LENGTH ] = { HRPRINTERSTATUS_SEQ } ;
AsnObjectIdentifier
hrPrinterStatus_oid = { HRPRINTERSTATUS_LENGTH, hrPrinterStatus_array } ;
static
UINT
hrPrinterDetectedErrorState_array[ HRPRINTERDETECTEDERRORSTATE_LENGTH ] = { HRPRINTERDETECTEDERRORSTATE_SEQ } ;
AsnObjectIdentifier
hrPrinterDetectedErrorState_oid = { HRPRINTERDETECTEDERRORSTATE_LENGTH, hrPrinterDetectedErrorState_array } ;
static
UINT
hrPrinterEntry_array[ HRPRINTERENTRY_LENGTH ] = { HRPRINTERENTRY_SEQ } ;
AsnObjectIdentifier
hrPrinterEntry_oid = { HRPRINTERENTRY_LENGTH, hrPrinterEntry_array } ;
variable_t
    hrPrinterEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrPrinterStatus_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPrinterStatus, NULL,
      SMIGetINThrPrinterStatus, SMISetINThrPrinterStatus } , 
    { &hrPrinterDetectedErrorState_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrPrinterDetectedErrorState, NULL,
      SMIGetOctetString, SMISetOctetString } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrPrinterEntry_set_array[ MAX_HRPRINTERENTRY_CODE + 1];
//  extern BYTE hrPrinterEntry_set_array[] ;
extern variable_t hrPrinterEntry_var_table[] ;
static
UINT
hrDiskStorageAccess_array[ HRDISKSTORAGEACCESS_LENGTH ] = { HRDISKSTORAGEACCESS_SEQ } ;
AsnObjectIdentifier
hrDiskStorageAccess_oid = { HRDISKSTORAGEACCESS_LENGTH, hrDiskStorageAccess_array } ;
static
UINT
hrDiskStorageMedia_array[ HRDISKSTORAGEMEDIA_LENGTH ] = { HRDISKSTORAGEMEDIA_SEQ } ;
AsnObjectIdentifier
hrDiskStorageMedia_oid = { HRDISKSTORAGEMEDIA_LENGTH, hrDiskStorageMedia_array } ;
static
UINT
hrDiskStorageRemoveble_array[ HRDISKSTORAGEREMOVEBLE_LENGTH ] = { HRDISKSTORAGEREMOVEBLE_SEQ } ;
AsnObjectIdentifier
hrDiskStorageRemoveble_oid = { HRDISKSTORAGEREMOVEBLE_LENGTH, hrDiskStorageRemoveble_array } ;
static
UINT
hrDiskStorageCapacity_array[ HRDISKSTORAGECAPACITY_LENGTH ] = { HRDISKSTORAGECAPACITY_SEQ } ;
AsnObjectIdentifier
hrDiskStorageCapacity_oid = { HRDISKSTORAGECAPACITY_LENGTH, hrDiskStorageCapacity_array } ;
static
UINT
hrDiskStorageEntry_array[ HRDISKSTORAGEENTRY_LENGTH ] = { HRDISKSTORAGEENTRY_SEQ } ;
AsnObjectIdentifier
hrDiskStorageEntry_oid = { HRDISKSTORAGEENTRY_LENGTH, hrDiskStorageEntry_array } ;
variable_t
    hrDiskStorageEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrDiskStorageAccess_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageAccess, NULL,
      SMIGetINTAccess, SMISetINTAccess } , 
    { &hrDiskStorageMedia_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageMedia, NULL,
      SMIGetINThrDiskStorageMedia, SMISetINThrDiskStorageMedia } , 
    { &hrDiskStorageRemoveble_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageRemoveble, NULL,
      SMIGetBoolean, SMISetBoolean } , 
    { &hrDiskStorageCapacity_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageCapacity, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrDiskStorageEntry_set_array[ MAX_HRDISKSTORAGEENTRY_CODE + 1];
//  extern BYTE hrDiskStorageEntry_set_array[] ;
extern variable_t hrDiskStorageEntry_var_table[] ;
static
UINT
hrPartitionIndex_array[ HRPARTITIONINDEX_LENGTH ] = { HRPARTITIONINDEX_SEQ } ;
AsnObjectIdentifier
hrPartitionIndex_oid = { HRPARTITIONINDEX_LENGTH, hrPartitionIndex_array } ;
static
UINT
hrPartitionLabel_array[ HRPARTITIONLABEL_LENGTH ] = { HRPARTITIONLABEL_SEQ } ;
AsnObjectIdentifier
hrPartitionLabel_oid = { HRPARTITIONLABEL_LENGTH, hrPartitionLabel_array } ;
static
UINT
hrPartitionID_array[ HRPARTITIONID_LENGTH ] = { HRPARTITIONID_SEQ } ;
AsnObjectIdentifier
hrPartitionID_oid = { HRPARTITIONID_LENGTH, hrPartitionID_array } ;
static
UINT
hrPartitionSize_array[ HRPARTITIONSIZE_LENGTH ] = { HRPARTITIONSIZE_SEQ } ;
AsnObjectIdentifier
hrPartitionSize_oid = { HRPARTITIONSIZE_LENGTH, hrPartitionSize_array } ;
static
UINT
hrPartitionFSIndex_array[ HRPARTITIONFSINDEX_LENGTH ] = { HRPARTITIONFSINDEX_SEQ } ;
AsnObjectIdentifier
hrPartitionFSIndex_oid = { HRPARTITIONFSINDEX_LENGTH, hrPartitionFSIndex_array } ;
static
UINT
hrPartitionEntry_array[ HRPARTITIONENTRY_LENGTH ] = { HRPARTITIONENTRY_SEQ } ;
AsnObjectIdentifier
hrPartitionEntry_oid = { HRPARTITIONENTRY_LENGTH, hrPartitionEntry_array } ;
variable_t
    hrPartitionEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrPartitionIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPartitionIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrPartitionLabel_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrPartitionLabel, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrPartitionID_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrPartitionID, NULL,
      SMIGetOctetString, SMISetOctetString } , 
    { &hrPartitionSize_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPartitionSize, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    { &hrPartitionFSIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPartitionFSIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrPartitionEntry_set_array[ MAX_HRPARTITIONENTRY_CODE + 1];
//  extern BYTE hrPartitionEntry_set_array[] ;
extern variable_t hrPartitionEntry_var_table[] ;
static
UINT
hrFSIndex_array[ HRFSINDEX_LENGTH ] = { HRFSINDEX_SEQ } ;
AsnObjectIdentifier
hrFSIndex_oid = { HRFSINDEX_LENGTH, hrFSIndex_array } ;
static
UINT
hrFSMountPoint_array[ HRFSMOUNTPOINT_LENGTH ] = { HRFSMOUNTPOINT_SEQ } ;
AsnObjectIdentifier
hrFSMountPoint_oid = { HRFSMOUNTPOINT_LENGTH, hrFSMountPoint_array } ;
static
UINT
hrFSRemoteMountPoint_array[ HRFSREMOTEMOUNTPOINT_LENGTH ] = { HRFSREMOTEMOUNTPOINT_SEQ } ;
AsnObjectIdentifier
hrFSRemoteMountPoint_oid = { HRFSREMOTEMOUNTPOINT_LENGTH, hrFSRemoteMountPoint_array } ;
static
UINT
hrFSType_array[ HRFSTYPE_LENGTH ] = { HRFSTYPE_SEQ } ;
AsnObjectIdentifier
hrFSType_oid = { HRFSTYPE_LENGTH, hrFSType_array } ;
static
UINT
hrFSAccess_array[ HRFSACCESS_LENGTH ] = { HRFSACCESS_SEQ } ;
AsnObjectIdentifier
hrFSAccess_oid = { HRFSACCESS_LENGTH, hrFSAccess_array } ;
static
UINT
hrFSBootable_array[ HRFSBOOTABLE_LENGTH ] = { HRFSBOOTABLE_SEQ } ;
AsnObjectIdentifier
hrFSBootable_oid = { HRFSBOOTABLE_LENGTH, hrFSBootable_array } ;
static
UINT
hrFSStorageIndex_array[ HRFSSTORAGEINDEX_LENGTH ] = { HRFSSTORAGEINDEX_SEQ } ;
AsnObjectIdentifier
hrFSStorageIndex_oid = { HRFSSTORAGEINDEX_LENGTH, hrFSStorageIndex_array } ;
static
UINT
hrFSLastFullBackupDate_array[ HRFSLASTFULLBACKUPDATE_LENGTH ] = { HRFSLASTFULLBACKUPDATE_SEQ } ;
AsnObjectIdentifier
hrFSLastFullBackupDate_oid = { HRFSLASTFULLBACKUPDATE_LENGTH, hrFSLastFullBackupDate_array } ;
static
UINT
hrFSLastPartialBackupDate_array[ HRFSLASTPARTIALBACKUPDATE_LENGTH ] = { HRFSLASTPARTIALBACKUPDATE_SEQ } ;
AsnObjectIdentifier
hrFSLastPartialBackupDate_oid = { HRFSLASTPARTIALBACKUPDATE_LENGTH, hrFSLastPartialBackupDate_array } ;
static
UINT
hrFSEntry_array[ HRFSENTRY_LENGTH ] = { HRFSENTRY_SEQ } ;
AsnObjectIdentifier
hrFSEntry_oid = { HRFSENTRY_LENGTH, hrFSEntry_array } ;
variable_t
    hrFSEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrFSIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrFSMountPoint_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrFSMountPoint, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrFSRemoteMountPoint_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrFSRemoteMountPoint, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrFSType_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrFSType, NULL,
      SMIGetObjectId, SMISetObjectId } , 
    { &hrFSAccess_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSAccess, NULL,
      SMIGetINTAccess, SMISetINTAccess } , 
    { &hrFSBootable_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSBootable, NULL,
      SMIGetBoolean, SMISetBoolean } , 
    { &hrFSStorageIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSStorageIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrFSLastFullBackupDate_oid, ASN_OCTETSTRING, NSM_READ_WRITE,
      GetHrFSLastFullBackupDate, SetHrFSLastFullBackupDate,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    { &hrFSLastPartialBackupDate_oid, ASN_OCTETSTRING, NSM_READ_WRITE,
      GetHrFSLastPartialBackupDate, SetHrFSLastPartialBackupDate,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrFSEntry_set_array[ MAX_HRFSENTRY_CODE + 1];
//  extern BYTE hrFSEntry_set_array[] ;
extern variable_t hrFSEntry_var_table[] ;
static
UINT
hrFSOther_array[ HRFSOTHER_LENGTH ] = { HRFSOTHER_SEQ } ;
AsnObjectIdentifier
hrFSOther_oid = { HRFSOTHER_LENGTH, hrFSOther_array } ;
static
UINT
hrFSUnknown_array[ HRFSUNKNOWN_LENGTH ] = { HRFSUNKNOWN_SEQ } ;
AsnObjectIdentifier
hrFSUnknown_oid = { HRFSUNKNOWN_LENGTH, hrFSUnknown_array } ;
static
UINT
hrFSBerkeleyFFS_array[ HRFSBERKELEYFFS_LENGTH ] = { HRFSBERKELEYFFS_SEQ } ;
AsnObjectIdentifier
hrFSBerkeleyFFS_oid = { HRFSBERKELEYFFS_LENGTH, hrFSBerkeleyFFS_array } ;
static
UINT
hrFSSys5FS_array[ HRFSSYS5FS_LENGTH ] = { HRFSSYS5FS_SEQ } ;
AsnObjectIdentifier
hrFSSys5FS_oid = { HRFSSYS5FS_LENGTH, hrFSSys5FS_array } ;
/*
 *    DOS
 */
static
UINT
hrFSFat_array[ HRFSFAT_LENGTH ] = { HRFSFAT_SEQ } ;
AsnObjectIdentifier
hrFSFat_oid = { HRFSFAT_LENGTH, hrFSFat_array } ;
/*
 *    OS/2 High Performance File System
 */
static
UINT
hrFSHPFS_array[ HRFSHPFS_LENGTH ] = { HRFSHPFS_SEQ } ;
AsnObjectIdentifier
hrFSHPFS_oid = { HRFSHPFS_LENGTH, hrFSHPFS_array } ;
/*
 *    Macintosh Hierarchical File System
 */
static
UINT
hrFSHFS_array[ HRFSHFS_LENGTH ] = { HRFSHFS_SEQ } ;
AsnObjectIdentifier
hrFSHFS_oid = { HRFSHFS_LENGTH, hrFSHFS_array } ;
/*
 *    Macintosh File System
 */
static
UINT
hrFSMFS_array[ HRFSMFS_LENGTH ] = { HRFSMFS_SEQ } ;
AsnObjectIdentifier
hrFSMFS_oid = { HRFSMFS_LENGTH, hrFSMFS_array } ;
/*
 *    Windows NT
 */
static
UINT
hrFSNTFS_array[ HRFSNTFS_LENGTH ] = { HRFSNTFS_SEQ } ;
AsnObjectIdentifier
hrFSNTFS_oid = { HRFSNTFS_LENGTH, hrFSNTFS_array } ;
static
UINT
hrFSVNode_array[ HRFSVNODE_LENGTH ] = { HRFSVNODE_SEQ } ;
AsnObjectIdentifier
hrFSVNode_oid = { HRFSVNODE_LENGTH, hrFSVNode_array } ;
static
UINT
hrFSJournaled_array[ HRFSJOURNALED_LENGTH ] = { HRFSJOURNALED_SEQ } ;
AsnObjectIdentifier
hrFSJournaled_oid = { HRFSJOURNALED_LENGTH, hrFSJournaled_array } ;
/*
 *    CD File System
 */
static
UINT
hrFSiso9660_array[ HRFSISO9660_LENGTH ] = { HRFSISO9660_SEQ } ;
AsnObjectIdentifier
hrFSiso9660_oid = { HRFSISO9660_LENGTH, hrFSiso9660_array } ;
static
UINT
hrFSRockRidge_array[ HRFSROCKRIDGE_LENGTH ] = { HRFSROCKRIDGE_SEQ } ;
AsnObjectIdentifier
hrFSRockRidge_oid = { HRFSROCKRIDGE_LENGTH, hrFSRockRidge_array } ;
static
UINT
hrFSNFS_array[ HRFSNFS_LENGTH ] = { HRFSNFS_SEQ } ;
AsnObjectIdentifier
hrFSNFS_oid = { HRFSNFS_LENGTH, hrFSNFS_array } ;
static
UINT
hrFSNetware_array[ HRFSNETWARE_LENGTH ] = { HRFSNETWARE_SEQ } ;
AsnObjectIdentifier
hrFSNetware_oid = { HRFSNETWARE_LENGTH, hrFSNetware_array } ;
/*
 *    Andrew File System
 */
static
UINT
hrFSAFS_array[ HRFSAFS_LENGTH ] = { HRFSAFS_SEQ } ;
AsnObjectIdentifier
hrFSAFS_oid = { HRFSAFS_LENGTH, hrFSAFS_array } ;
/*
 *    OSF DCE Distributed File System
 */
static
UINT
hrFSDFS_array[ HRFSDFS_LENGTH ] = { HRFSDFS_SEQ } ;
AsnObjectIdentifier
hrFSDFS_oid = { HRFSDFS_LENGTH, hrFSDFS_array } ;
static
UINT
hrFSApplshare_array[ HRFSAPPLSHARE_LENGTH ] = { HRFSAPPLSHARE_SEQ } ;
AsnObjectIdentifier
hrFSApplshare_oid = { HRFSAPPLSHARE_LENGTH, hrFSApplshare_array } ;
static
UINT
hrFSRFS_array[ HRFSRFS_LENGTH ] = { HRFSRFS_SEQ } ;
AsnObjectIdentifier
hrFSRFS_oid = { HRFSRFS_LENGTH, hrFSRFS_array } ;
/*
 *    Data General
 */
static
UINT
hrFSDGFS_array[ HRFSDGFS_LENGTH ] = { HRFSDGFS_SEQ } ;
AsnObjectIdentifier
hrFSDGFS_oid = { HRFSDGFS_LENGTH, hrFSDGFS_array } ;
/*
 *    SVR4 Boot File System
 */
static
UINT
hrFSBFS_array[ HRFSBFS_LENGTH ] = { HRFSBFS_SEQ } ;
AsnObjectIdentifier
hrFSBFS_oid = { HRFSBFS_LENGTH, hrFSBFS_array } ;
static
UINT
hrFSTypes_array[ HRFSTYPES_LENGTH ] = { HRFSTYPES_SEQ } ;
AsnObjectIdentifier
hrFSTypes_oid = { HRFSTYPES_LENGTH, hrFSTypes_array } ;
static
UINT
hrSWOSIndex_array[ HRSWOSINDEX_LENGTH ] = { HRSWOSINDEX_SEQ } ;
AsnObjectIdentifier
hrSWOSIndex_oid = { HRSWOSINDEX_LENGTH, hrSWOSIndex_array } ;
static
UINT
hrSWRun_array[ HRSWRUN_LENGTH ] = { HRSWRUN_SEQ } ;
AsnObjectIdentifier
hrSWRun_oid = { HRSWRUN_LENGTH, hrSWRun_array } ;
variable_t
    hrSWRun_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWOSIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWOSIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWRun_set_array[ MAX_HRSWRUN_CODE + 1];
//  extern BYTE hrSWRun_set_array[] ;
extern variable_t hrSWRun_var_table[] ;
static
UINT
hrSWRunIndex_array[ HRSWRUNINDEX_LENGTH ] = { HRSWRUNINDEX_SEQ } ;
AsnObjectIdentifier
hrSWRunIndex_oid = { HRSWRUNINDEX_LENGTH, hrSWRunIndex_array } ;
static
UINT
hrSWRunName_array[ HRSWRUNNAME_LENGTH ] = { HRSWRUNNAME_SEQ } ;
AsnObjectIdentifier
hrSWRunName_oid = { HRSWRUNNAME_LENGTH, hrSWRunName_array } ;
static
UINT
hrSWRunID_array[ HRSWRUNID_LENGTH ] = { HRSWRUNID_SEQ } ;
AsnObjectIdentifier
hrSWRunID_oid = { HRSWRUNID_LENGTH, hrSWRunID_array } ;
static
UINT
hrSWRunPath_array[ HRSWRUNPATH_LENGTH ] = { HRSWRUNPATH_SEQ } ;
AsnObjectIdentifier
hrSWRunPath_oid = { HRSWRUNPATH_LENGTH, hrSWRunPath_array } ;
static
UINT
hrSWRunParameters_array[ HRSWRUNPARAMETERS_LENGTH ] = { HRSWRUNPARAMETERS_SEQ } ;
AsnObjectIdentifier
hrSWRunParameters_oid = { HRSWRUNPARAMETERS_LENGTH, hrSWRunParameters_array } ;
static
UINT
hrSWRunType_array[ HRSWRUNTYPE_LENGTH ] = { HRSWRUNTYPE_SEQ } ;
AsnObjectIdentifier
hrSWRunType_oid = { HRSWRUNTYPE_LENGTH, hrSWRunType_array } ;
static
UINT
hrSWRunStatus_array[ HRSWRUNSTATUS_LENGTH ] = { HRSWRUNSTATUS_SEQ } ;
AsnObjectIdentifier
hrSWRunStatus_oid = { HRSWRUNSTATUS_LENGTH, hrSWRunStatus_array } ;
static
UINT
hrSWRunEntry_array[ HRSWRUNENTRY_LENGTH ] = { HRSWRUNENTRY_SEQ } ;
AsnObjectIdentifier
hrSWRunEntry_oid = { HRSWRUNENTRY_LENGTH, hrSWRunEntry_array } ;
variable_t
    hrSWRunEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWRunIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrSWRunName_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWRunName, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWRunID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrSWRunID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrSWRunPath_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWRunPath, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWRunParameters_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWRunParameters, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWRunType_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunType, NULL,
      SMIGetINTSWType, SMISetINTSWType } , 
    { &hrSWRunStatus_oid, ASN_INTEGER, NSM_READ_WRITE,
      GetHrSWRunStatus, SetHrSWRunStatus,
      SMIGetINThrSWRunStatus, SMISetINThrSWRunStatus } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWRunEntry_set_array[ MAX_HRSWRUNENTRY_CODE + 1];
//  extern BYTE hrSWRunEntry_set_array[] ;
extern variable_t hrSWRunEntry_var_table[] ;
static
UINT
hrSWRunPerfCPU_array[ HRSWRUNPERFCPU_LENGTH ] = { HRSWRUNPERFCPU_SEQ } ;
AsnObjectIdentifier
hrSWRunPerfCPU_oid = { HRSWRUNPERFCPU_LENGTH, hrSWRunPerfCPU_array } ;
static
UINT
hrSWRunPerfMem_array[ HRSWRUNPERFMEM_LENGTH ] = { HRSWRUNPERFMEM_SEQ } ;
AsnObjectIdentifier
hrSWRunPerfMem_oid = { HRSWRUNPERFMEM_LENGTH, hrSWRunPerfMem_array } ;
static
UINT
hrSWRunPerfEntry_array[ HRSWRUNPERFENTRY_LENGTH ] = { HRSWRUNPERFENTRY_SEQ } ;
AsnObjectIdentifier
hrSWRunPerfEntry_oid = { HRSWRUNPERFENTRY_LENGTH, hrSWRunPerfEntry_array } ;
variable_t
    hrSWRunPerfEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWRunPerfCPU_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunPerfCPU, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrSWRunPerfMem_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunPerfMem, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWRunPerfEntry_set_array[ MAX_HRSWRUNPERFENTRY_CODE + 1];
//  extern BYTE hrSWRunPerfEntry_set_array[] ;
extern variable_t hrSWRunPerfEntry_var_table[] ;
static
UINT
hrSWInstalledLastChange_array[ HRSWINSTALLEDLASTCHANGE_LENGTH ] = { HRSWINSTALLEDLASTCHANGE_SEQ } ;
AsnObjectIdentifier
hrSWInstalledLastChange_oid = { HRSWINSTALLEDLASTCHANGE_LENGTH, hrSWInstalledLastChange_array } ;
static
UINT
hrSWInstalledLastUpdateTime_array[ HRSWINSTALLEDLASTUPDATETIME_LENGTH ] = { HRSWINSTALLEDLASTUPDATETIME_SEQ } ;
AsnObjectIdentifier
hrSWInstalledLastUpdateTime_oid = { HRSWINSTALLEDLASTUPDATETIME_LENGTH, hrSWInstalledLastUpdateTime_array } ;
static
UINT
hrSWInstalled_array[ HRSWINSTALLED_LENGTH ] = { HRSWINSTALLED_SEQ } ;
AsnObjectIdentifier
hrSWInstalled_oid = { HRSWINSTALLED_LENGTH, hrSWInstalled_array } ;
variable_t
    hrSWInstalled_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWInstalledLastChange_oid, ASN_RFC1155_TIMETICKS, NSM_READ_ONLY,
      GetHrSWInstalledLastChange, NULL,
      SMIGetTimeTicks, SMISetTimeTicks } , 
    { &hrSWInstalledLastUpdateTime_oid, ASN_RFC1155_TIMETICKS, NSM_READ_ONLY,
      GetHrSWInstalledLastUpdateTime, NULL,
      SMIGetTimeTicks, SMISetTimeTicks } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWInstalled_set_array[ MAX_HRSWINSTALLED_CODE + 1];
//  extern BYTE hrSWInstalled_set_array[] ;
extern variable_t hrSWInstalled_var_table[] ;
static
UINT
hrSWInstalledIndex_array[ HRSWINSTALLEDINDEX_LENGTH ] = { HRSWINSTALLEDINDEX_SEQ } ;
AsnObjectIdentifier
hrSWInstalledIndex_oid = { HRSWINSTALLEDINDEX_LENGTH, hrSWInstalledIndex_array } ;
static
UINT
hrSWInstalledName_array[ HRSWINSTALLEDNAME_LENGTH ] = { HRSWINSTALLEDNAME_SEQ } ;
AsnObjectIdentifier
hrSWInstalledName_oid = { HRSWINSTALLEDNAME_LENGTH, hrSWInstalledName_array } ;
static
UINT
hrSWInstalledID_array[ HRSWINSTALLEDID_LENGTH ] = { HRSWINSTALLEDID_SEQ } ;
AsnObjectIdentifier
hrSWInstalledID_oid = { HRSWINSTALLEDID_LENGTH, hrSWInstalledID_array } ;
static
UINT
hrSWInstalledType_array[ HRSWINSTALLEDTYPE_LENGTH ] = { HRSWINSTALLEDTYPE_SEQ } ;
AsnObjectIdentifier
hrSWInstalledType_oid = { HRSWINSTALLEDTYPE_LENGTH, hrSWInstalledType_array } ;
static
UINT
hrSWInstalledDate_array[ HRSWINSTALLEDDATE_LENGTH ] = { HRSWINSTALLEDDATE_SEQ } ;
AsnObjectIdentifier
hrSWInstalledDate_oid = { HRSWINSTALLEDDATE_LENGTH, hrSWInstalledDate_array } ;
static
UINT
hrSWInstalledEntry_array[ HRSWINSTALLEDENTRY_LENGTH ] = { HRSWINSTALLEDENTRY_SEQ } ;
AsnObjectIdentifier
hrSWInstalledEntry_oid = { HRSWINSTALLEDENTRY_LENGTH, hrSWInstalledEntry_array } ;
variable_t
    hrSWInstalledEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWInstalledIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWInstalledIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrSWInstalledName_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWInstalledName, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWInstalledID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrSWInstalledID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrSWInstalledType_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWInstalledType, NULL,
      SMIGetINTSWType, SMISetINTSWType } , 
    { &hrSWInstalledDate_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWInstalledDate, NULL,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWInstalledEntry_set_array[ MAX_HRSWINSTALLEDENTRY_CODE + 1];
//  extern BYTE hrSWInstalledEntry_set_array[] ;
extern variable_t hrSWInstalledEntry_var_table[] ;
class_t
    class_info[] = { 
    // hrSystem
    { NON_TABLE, &hrSystem_oid, HRSYSTEM_VAR_INDEX,
      MIN_HRSYSTEM_CODE, MAX_HRSYSTEM_CODE,
      HrSystemFindInstance, HrSystemFindNextInstance,
      HrSystemConvertInstance, HrSystemFreeInstance,
      hrSystem_var_table } , 

    // hrStorage
    { NON_TABLE, &hrStorage_oid, HRSTORAGE_VAR_INDEX,
      MIN_HRSTORAGE_CODE, MAX_HRSTORAGE_CODE,
      HrStorageFindInstance, HrStorageFindNextInstance,
      HrStorageConvertInstance, HrStorageFreeInstance,
      hrStorage_var_table } , 

    // hrStorageEntry
    { TABLE, &hrStorageEntry_oid, HRSTORAGEENTRY_VAR_INDEX,
      MIN_HRSTORAGEENTRY_CODE, MAX_HRSTORAGEENTRY_CODE,
      HrStorageEntryFindInstance, HrStorageEntryFindNextInstance,
      HrStorageEntryConvertInstance, HrStorageEntryFreeInstance,
      hrStorageEntry_var_table } , 

    // hrDeviceEntry
    { TABLE, &hrDeviceEntry_oid, HRDEVICEENTRY_VAR_INDEX,
      MIN_HRDEVICEENTRY_CODE, MAX_HRDEVICEENTRY_CODE,
      HrDeviceEntryFindInstance, HrDeviceEntryFindNextInstance,
      HrDeviceEntryConvertInstance, HrDeviceEntryFreeInstance,
      hrDeviceEntry_var_table } , 

    // hrProcessorEntry
    { TABLE, &hrProcessorEntry_oid, HRPROCESSORENTRY_VAR_INDEX,
      MIN_HRPROCESSORENTRY_CODE, MAX_HRPROCESSORENTRY_CODE,
      HrProcessorEntryFindInstance, HrProcessorEntryFindNextInstance,
      HrProcessorEntryConvertInstance, HrProcessorEntryFreeInstance,
      hrProcessorEntry_var_table } , 

    // hrNetworkEntry
    { TABLE, &hrNetworkEntry_oid, HRNETWORKENTRY_VAR_INDEX,
      MIN_HRNETWORKENTRY_CODE, MAX_HRNETWORKENTRY_CODE,
      HrNetworkEntryFindInstance, HrNetworkEntryFindNextInstance,
      HrNetworkEntryConvertInstance, HrNetworkEntryFreeInstance,
      hrNetworkEntry_var_table } , 

    // hrPrinterEntry
    { TABLE, &hrPrinterEntry_oid, HRPRINTERENTRY_VAR_INDEX,
      MIN_HRPRINTERENTRY_CODE, MAX_HRPRINTERENTRY_CODE,
      HrPrinterEntryFindInstance, HrPrinterEntryFindNextInstance,
      HrPrinterEntryConvertInstance, HrPrinterEntryFreeInstance,
      hrPrinterEntry_var_table } , 

    // hrDiskStorageEntry
    { TABLE, &hrDiskStorageEntry_oid, HRDISKSTORAGEENTRY_VAR_INDEX,
      MIN_HRDISKSTORAGEENTRY_CODE, MAX_HRDISKSTORAGEENTRY_CODE,
      HrDiskStorageEntryFindInstance, HrDiskStorageEntryFindNextInstance,
      HrDiskStorageEntryConvertInstance, HrDiskStorageEntryFreeInstance,
      hrDiskStorageEntry_var_table } , 

    // hrPartitionEntry
    { TABLE, &hrPartitionEntry_oid, HRPARTITIONENTRY_VAR_INDEX,
      MIN_HRPARTITIONENTRY_CODE, MAX_HRPARTITIONENTRY_CODE,
      HrPartitionEntryFindInstance, HrPartitionEntryFindNextInstance,
      HrPartitionEntryConvertInstance, HrPartitionEntryFreeInstance,
      hrPartitionEntry_var_table } , 

    // hrFSEntry
    { TABLE, &hrFSEntry_oid, HRFSENTRY_VAR_INDEX,
      MIN_HRFSENTRY_CODE, MAX_HRFSENTRY_CODE,
      HrFSEntryFindInstance, HrFSEntryFindNextInstance,
      HrFSEntryConvertInstance, HrFSEntryFreeInstance,
      hrFSEntry_var_table } , 

    // hrSWRun
    { NON_TABLE, &hrSWRun_oid, HRSWRUN_VAR_INDEX,
      MIN_HRSWRUN_CODE, MAX_HRSWRUN_CODE,
      HrSWRunFindInstance, HrSWRunFindNextInstance,
      HrSWRunConvertInstance, HrSWRunFreeInstance,
      hrSWRun_var_table } , 

    // hrSWRunEntry
    { TABLE, &hrSWRunEntry_oid, HRSWRUNENTRY_VAR_INDEX,
      MIN_HRSWRUNENTRY_CODE, MAX_HRSWRUNENTRY_CODE,
      HrSWRunEntryFindInstance, HrSWRunEntryFindNextInstance,
      HrSWRunEntryConvertInstance, HrSWRunEntryFreeInstance,
      hrSWRunEntry_var_table } , 

    // hrSWRunPerfEntry
    { TABLE, &hrSWRunPerfEntry_oid, HRSWRUNPERFENTRY_VAR_INDEX,
      MIN_HRSWRUNPERFENTRY_CODE, MAX_HRSWRUNPERFENTRY_CODE,
      HrSWRunPerfEntryFindInstance, HrSWRunPerfEntryFindNextInstance,
      HrSWRunPerfEntryConvertInstance, HrSWRunPerfEntryFreeInstance,
      hrSWRunPerfEntry_var_table } , 

    // hrSWInstalled
    { NON_TABLE, &hrSWInstalled_oid, HRSWINSTALLED_VAR_INDEX,
      MIN_HRSWINSTALLED_CODE, MAX_HRSWINSTALLED_CODE,
      HrSWInstalledFindInstance, HrSWInstalledFindNextInstance,
      HrSWInstalledConvertInstance, HrSWInstalledFreeInstance,
      hrSWInstalled_var_table } , 

    // hrSWInstalledEntry
    { TABLE, &hrSWInstalledEntry_oid, HRSWINSTALLEDENTRY_VAR_INDEX,
      MIN_HRSWINSTALLEDENTRY_CODE, MAX_HRSWINSTALLEDENTRY_CODE,
      HrSWInstalledEntryFindInstance, HrSWInstalledEntryFindNextInstance,
      HrSWInstalledEntryConvertInstance, HrSWInstalledEntryFreeInstance,
      hrSWInstalledEntry_var_table } , 
    } ; 

extern class_t class_info[] ;

extern char *EventLogString ;
extern char mibEventValue[] ;




/*
 *  UserMibInit
 *
 *    This routine is to allow user to initialize any variable at the time of
 *    dll's activation.  This routine setups up the registry for application
 *    event logging and calls out to the trap initialization code.  The user
 *    specific code follows.
 *
 *  Arguments:
 *
 *    hPollForTrapEvent    handle for traps - this is used to coordinate
 *                         between the Extendible Agent and this Extension
 *                         Agent.  It is passed to the TrapInit() routine.
 *                             - NULL indicates no traps
 *                             - value from CreateEvent() indicates traps
 *                               are implemented and the Extendible agent
 *                               must poll for them
 *
 *  Return Code:
 *
 *    SUCCESS     Successful initialization
 *    FAILURE     Unable to initialize
 *
 */

UINT
UserMibInit( IN OUT HANDLE *hPollForTrapEvent )
{
    HKEY hkey ;
    DWORD dwData ;
    UCHAR valuebuf[ 80 ] ;
    char mibEventKey[ 256 ] ;


    // The user must initialize the Event Log handle.  NULL in the first
    // argument indicates that the log is on the local machine.  The text
    // string for the second argument is the same as the subkey in the
    // registry under
    //       HKEY_LOCAL_MACHINE
    //         SYSTEM
    //           CurrentControlSet
    //             Services
    //               EventLog
    //                 Application
    //                   GenAgent    (for this example)
    //
    // But first create the subkey and set the values associated with it.
    // The subkey uses the eventLogString name.

    memset( mibEventKey, '\0', sizeof( UCHAR ) * 256 ) ;
    sprintf( mibEventKey ,
             "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\%s" ,
             eventLogString ) ;
    if ( RegCreateKey( HKEY_LOCAL_MACHINE, mibEventKey, &hkey ) )
        return FAILURE ;

    memset( valuebuf, '\0', sizeof( UCHAR ) * 80 ) ;
    sprintf( valuebuf, "%%SystemRoot%%\\System32\\%s", mibEventValue ) ;
    if ( RegSetValueEx( hkey ,
                        "EventMessageFile" ,  // Value name
                        0 ,                   // must be zero
                        REG_EXPAND_SZ ,       // value type
                        (LPBYTE) valuebuf ,   // address of value data
                        strlen( valuebuf ) + 1 ) )
        return FAILURE ;
    dwData = EVENTLOG_ERROR_TYPE |
             EVENTLOG_WARNING_TYPE |
             EVENTLOG_INFORMATION_TYPE ;
    if ( RegSetValueEx( hkey ,
                        "TypesSupported" ,    // Value name
                        0 ,                   // must be zero
                        REG_DWORD ,           // value type
                        (LPBYTE)&dwData ,     // address of value data
                        sizeof( DWORD ) ) )   // length of value data
        return FAILURE ;
    RegCloseKey( hkey ) ;

    //
    //  USER'S INITIALIZATION CODE HERE.
    //

    /* 
    ||=============================================================
    || NOTE: Order of these initialization is important!
    ||       Some later inits may depend on earlier inits
    ||       ..see below
    ||=============================================================
    */


    /* HRSYSTEM DEPENDS:
    |  =================
    |   hrSystem Table has no cache, but the value of 
    |   "HrSystemInitialLoadDevice" depends on the hrDevice table having been
    |   initialized.
    */


    /* HRSTORAGE DEPENDS:
    |  =================
    |   None.
    */
    if (Gen_Hrstorage_Cache() == FALSE)      { return FAILURE ; }


    /* HRFSTABLE DEPENDS:
    |  =================
    |   The HRSTORAGE cache is searched in order to set the value of
    |   all "hrFSStorageIndex" attributes.
    */
    if (Gen_HrFSTable_Cache() == FALSE)      { return FAILURE ; }


    /* HRDEVICE DEPENDS:
    |  =================
    |   The HRFSTABLE cache is searched in order to set the values for
    |   "hrPartitionFSIndex" attributes in the hrPartition sub-table of
    |   the hrdevice table.
    |
    | Debugging Note:
    |  If you temporarily "no-op" the next line (and trigger the
    |  actual invocation of this cache build function from, say,
    |  function "SetHrStorageSize()" by sending a "SET" of that variable),
    |  you also need to "no-op" the invocation of "TrapInit()" below,
    |  otherwise the subagent will trap when the hrProcessorLoad timer
    |  (set-up by "TrapInit()" below) goes off.
    */
    if (Gen_HrDevice_Cache() == FALSE)       { return FAILURE ; }


    /* HRSWINSTALLED DEPENDS:
    |  ======================
    |   None.
    */
    if (Gen_HrSWInstalled_Cache() == FALSE)  { return FAILURE ; }


    /* HRSWRUN/PERF DEPENDS:
    |  =====================
    |   None.  This function is called repeatedly to refresh the cache
    |   at intervals of CACHE_MAX_AGE (defined in "HRSWRUNE.C").
    */
    if (Gen_HrSWRun_Cache() == FALSE)        { return FAILURE ; }


    /*
    | This "TrapInit" processing is deferred until after Gen_HrDevice_Cache()
    | processing has been done.
    |
    | Because no traps are defined by HostMIB, we use the mechanism
    | (by which the main SNMP agent "polls" for Traps when an event goes off)
    | to actually cause the HostMIB subagent to be periodically entered so
    | that timer-counts needed to accurately report "hrProcessorLoad"
    | values for each CPU may be refreshed.
    |
    | The hrProcessor sub-table initialization is performed as part of
    | hrDevice table init.  Buffer initialization for hrProcessorLoad is done
    | as part of this initialization and must be complete before we do this
    | "TrapInit()" call.
    |
    | "TrapInit()" in reality sets up the timer handle returned as 
    | "hPollForTrapEvent".  The function that is entered when the timer 
    | goes off ("hrProcessLoad_Refresh()" in "HRPROCES.C") expects the 
    | buffer initialization to have already been performed... hence the 
    | call to "TrapInit()" must follow other cache initialization.
    */    
    TrapInit( hPollForTrapEvent ) ;

    return SUCCESS ;

} /* end of UserMibInit() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\smint.c ===
/*
 *  smint.c v0.12  Mar 12 1996
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995, 1996 DIGITAL EQUIPMENT CORPORATION              *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the SMI envelopes around the callout to the user's
 *    get and set routines.
 *
 *        SMIGetInteger
 *        SMIGetNSMBoolean
 *        SMIGetBIDTEnum
 *        SMIGetOctetString
 *        SMIGetObjectId
 *        SMIGetCounter
 *        SMIGetGauge
 *        SMIGetTimeTicks
 *        SMIGetIpAddress
 *        SMIGetDispString
 *        SMISetInteger
 *        SMISetNSMBoolean
 *        SMISetBIDTEnum
 *        SMISetOctetString
 *        SMISetObjectId
 *        SMISetCounter
 *        SMISetGauge
 *        SMISetTimeTicks
 *        SMISetIpAddress
 *        SMISetDispString
 *        SMIBuildInteger
 *        SMIBuildDIDTEnum
 *        SMIBuildOctetString
 *        SMIBuildObjectId
 *        SMIBuildCounter
 *        SMIBuildGauge
 *        SMIBuildTimeTicks
 *        SMIBuildIpAddress
 *        SMIBuildDispString
 *        SMIFree
 *
 *  Author:
 *     Wayne Duso, Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *     2/17/95
 *
 *  Revision History:
 *  v0.1   Jul 20 95     AGS  Added SMIGet/SetBoolean
 *  v0.11  Feb 14 1996   AGS  changed SMIGet/SetBoolean to SMIGet/SetNSMBoolean
 *  v0.12  Mar 12, 1996  KKF  set outvalue.length to 256 for SMISetOctetString,
 *                            SMISetDispString so that instrumentation code knows
 *                            max length of buffer.
 *  v0.13  May 15, 1997  DDB  To Microsoft: 6 changes of "malloc" to
 *                              "SNMP_malloc"
 */


// Necessary includes.

#include <snmp.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>

#include "mib.h"
#include "mib_xtrn.h"
#include "smint.h"        // Wayne's type def file



/*
 *  SMIGetInteger
 *
 *    Encompasses the callouts to variables of the data type INTEGER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Integer outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number = (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetInteger() */



/*
 *  SMIGetNSMBoolean
 *
 *    Encompasses the callouts to variables of the data type Boolean.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *    In SNMPv1  true = 1 AND false = 2
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    NSM_Boolean outvalue ;	  // nsm_true = 1, nsm_false = 2
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number = (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetNSMBoolean() */




/*
 *  SMIGetBIDTEnum
 *
 *    Encompasses the callouts to variables of the data type INTEGER that
 *    are enumerated.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    BIDT_ENUMERATION outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number = (AsnInteger)outvalue ;
    }
    return result ;

}  /* end of SMIGetBIDTEnum() */





/*
 *  SMIGetOctetString
 *
 *    Encompasses the callouts to variables of the data type OCTET STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    OctetString outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;    // dummy holder for future use

    outvalue.string = stream ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.string.length = outvalue.length ;
        VarBind->value.asnValue.string.stream =
//            malloc( outvalue.length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
            SNMP_malloc( outvalue.length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    outvalue.string ,
                    outvalue.length ) ;
            VarBind->value.asnType =  ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    return result ;

}  /* end of SMIGetOctetString() */




/*
 *  SMIGetObjectId
 *
 *    Encompasses the callouts to variables of the data type OBJECT IDENTIFIER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    UINT status ;
    ObjectIdentifier outvalue ;
    Access_Credential access ;    // dummy holder for future use

    memset( &outvalue, '\0', sizeof( ObjectIdentifier ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        status = SNMP_oidcpy( &VarBind->value.asnValue.object, &outvalue ) ;
        if ( !status )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            if ( outvalue.idLength != 0 )
			SNMP_free( outvalue.ids ) ;
            VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;
        }
    }
    return result ;

}  /* end of SMIGetObjectId() */




/*
 *  SMIGetCounter
 *
 *    Encompasses the callouts to variables of the data type COUNTER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Counter outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_RFC1155_COUNTER ;
        VarBind->value.asnValue.counter = outvalue ;
    }
    return result ;

}  /* end of SMIGetCounter() */




/*
 *  SMIGetGauge
 *
 *    Encompasses the callouts to variables of the data type GAUGE.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Gauge outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_RFC1155_GAUGE ;
        VarBind->value.asnValue.gauge = outvalue ;
    }
    return result ;

}  /* end of SMIGetGauge() */




/*
 *  SMIGetTimeTicks
 *
 *    Encompasses the callouts to variables of the data type TIMETICKS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    TimeTicks outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_RFC1155_TIMETICKS ;
        VarBind->value.asnValue.ticks = outvalue ;
    }
    return result ;

}  /* end of SMIGetTimeTicks() */




/*
 *  SMIGetIpAddress
 *
 *    Encompasses the callouts to variables of the data type IP ADDRESS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    IpAddress outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.address.length = 4 ;
//        VarBind->value.asnValue.address.stream = malloc( 4 * sizeof( char ) ) ;
// Changed 5/15/97 DDB
        VarBind->value.asnValue.address.stream = SNMP_malloc( 4 * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.address.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.address.stream ,
                    (BYTE *)(&outvalue),
                    4 ) ;
            VarBind->value.asnType = ASN_RFC1155_IPADDRESS ;
            VarBind->value.asnValue.address.dynamic = TRUE ;
        }
    }
    return result ;

}  /* end of SMIGetIpAddress() */



/*
 *  SMIGetDispString
 *
 *    Encompasses the callouts to variables of the data type DISPLAY STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Simple_DisplayString outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;    // dummy holder for future use

    outvalue.string = stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.string.length = outvalue.length ;
        VarBind->value.asnValue.string.stream =
//            malloc( outvalue.length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
            SNMP_malloc( outvalue.length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    outvalue.string ,
                    VarBind->value.asnValue.string.length ) ;
            VarBind->value.asnType = ASN_RFC1213_DISPSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    return result ;

}  /* end of SMIGetDispString() */




/*
 *  SMISetInteger
 *
 *    Encompasses the callouts to variables of the data type INTEGER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Integer *invalue ;
    Integer outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (Integer *)( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetInteger() */




/*
 *  SMISetNSMBoolean
 *
 *    Encompasses the callouts to variables of the data type Boolean
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *    In SNMPv1  true = 1 AND false = 2
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    NSM_Boolean *invalue ;        // nsm_true = 1, nsm_false = 2
    NSM_Boolean outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (NSM_Boolean *)( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetNSMBoolean() */




/*
 *  SMISetBIDTEmun
 *
 *    Encompasses the callouts to variables of the data type INTEGER that
 *    is enumerated.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    BIDT_ENUMERATION *invalue ;
    BIDT_ENUMERATION outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (BIDT_ENUMERATION *)( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetBIDTEnum() */





/*
 *  SMISetOctetString
 *
 *    Encompasses the callouts to variables of the data type OCTET STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    OctetString invalue ;
    OctetString outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;    // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 256 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetOctetString() */




/*
 *  SMISetObjectId
 *
 *    Encompasses the callouts to variables of the data type OBJECT IDENTIFIER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    ObjectIdentifier *invalue ;
    ObjectIdentifier outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = &VarBind->value.asnValue.object ;
    memset( &outvalue, '\0', sizeof ( ObjectIdentifier ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    if ( outvalue.idLength != 0 )
		SNMP_free( outvalue.ids ) ;

    return result ;

}  /* end of SMISetObjectId() */




/*
 *  SMISetCounter
 *
 *    Encompasses the callouts to variables of the data type COUNTER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Counter *invalue ;
    Counter outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (Counter *)( &VarBind->value.asnValue.counter ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetCounter() */



/*
 *  SMISetGauge
 *
 *    Encompasses the callouts to variables of the data type GAUGE.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Gauge *invalue ;
    Gauge outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (Gauge *)( &VarBind->value.asnValue.gauge ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetGauge() */



/*
 *  SMISetTimeTicks
 *
 *    Encompasses the callouts to variables of the data type TIMETICKS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    TimeTicks *invalue ;
    TimeTicks outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (TimeTicks *)( &VarBind->value.asnValue.ticks ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue , &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetTimeTicks() */




/*
 *  SMISetIpAddress
 *
 *    Encompasses the callouts to variables of the data type IP ADDRESS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    IpAddress invalue ;
    IpAddress outvalue ;
    Access_Credential access ;    // dummy holder for future use

    memcpy( &invalue, VarBind->value.asnValue.address.stream , 4 ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetIpAddress() */



/*
 *  SMISetDispString
 *
 *    Encompasses the callouts to variables of the data type DISPLAY STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Simple_DisplayString invalue ;
    Simple_DisplayString outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;    // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 256 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetDispString() */




/*
 *  SMIBuildInteger
 *
 *    Places the variable of datatype INTEGER into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                     address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildInteger( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue )

{
    Integer *svalue = (Integer *)invalue ;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildInteger() */




/*
 *  SMIBuildOctetString
 *
 *    Places the variable of datatype OCTET STRING into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildOctetString( IN OUT RFC1157VarBind *VarBind ,
                     IN char *invalue )

{
    OctetString *svalue = (OctetString *)invalue ;

    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    VarBind->value.asnValue.string.length = svalue->length ;
    VarBind->value.asnValue.string.stream =
//        malloc( svalue->length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
        SNMP_malloc( svalue->length * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.string.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.string.stream ,
                svalue->string ,
                svalue->length ) ;
        VarBind->value.asnType =  ASN_OCTETSTRING ;
        VarBind->value.asnValue.string.dynamic = TRUE ;
    }
    return status ;

}  /* end of SMIBuildOctetString() */




/*
 *  SMIBuildObjectId
 *
 *    Places the variable of datatype OBJECT IDENTIFIER into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildObjectId( IN OUT RFC1157VarBind *VarBind ,
                  IN char *invalue )


{
    ObjectIdentifier *svalue = (ObjectIdentifier *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;
    UINT sts = TRUE ;

    sts = SNMP_oidcpy( &VarBind->value.asnValue.object ,
                       (AsnObjectIdentifier *)svalue ) ;
    if ( !sts )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
        VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;

    return status ;

}  /* end of SMIBuildObjectId() */




/*
 *  SMIBuildCounter
 *
 *    Places the variable of datatype COUNTER into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildCounter( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue )

{
    Counter *svalue = (Counter *)invalue ;
    VarBind->value.asnType = ASN_RFC1155_COUNTER ;
    VarBind->value.asnValue.counter = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildCounter() */




/*
 *  SMIBuildGauge
 *
 *    Places the variable of datatype GAUGE into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    svalue                     address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildGauge( IN OUT RFC1157VarBind *VarBind ,
               IN char *invalue )

{
    Gauge *svalue = (Gauge *)invalue ;
    VarBind->value.asnType = ASN_RFC1155_GAUGE ;
    VarBind->value.asnValue.gauge = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildGauge() */




/*
 *  SMIBuildTimeTicks
 *
 *    Places the variable of datatype TIME TICKS into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildTimeTicks( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue )

{
    TimeTicks *svalue = (TimeTicks *)invalue ;
    VarBind->value.asnType = ASN_RFC1155_TIMETICKS ;
    VarBind->value.asnValue.ticks = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildTimeTicks() */




/*
 *  SMIBuildIpAddress
 *
 *    Places the variable of datatype IpAddress into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildIpAddress( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue )

{
    IpAddress *svalue = (IpAddress *)invalue;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    VarBind->value.asnValue.address.length = 4 ;
//    VarBind->value.asnValue.address.stream = malloc( 4 * sizeof( char ) ) ;
// Changed 5/15/97 DDB
    VarBind->value.asnValue.address.stream = SNMP_malloc( 4 * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.address.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.address.stream, (BYTE *)svalue, 4 ) ;
        VarBind->value.asnType = ASN_RFC1155_IPADDRESS ;
        VarBind->value.asnValue.address.dynamic = TRUE ;
    }
    return status ;

}  /* end of SMIBuildIpAddress() */



/*
 *  SMIBuildDispString
 *
 *    Places the variable of datatype DISPLAY STRING into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                     address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildDispString( IN OUT RFC1157VarBind *VarBind ,
                    IN char *invalue )

{
    Simple_DisplayString *svalue = (Simple_DisplayString *)invalue;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    VarBind->value.asnValue.string.length = svalue->length ;
    VarBind->value.asnValue.string.stream =
//        malloc( VarBind->value.asnValue.string.length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
        SNMP_malloc( VarBind->value.asnValue.string.length * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.string.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.string.stream ,
                svalue->string ,
                VarBind->value.asnValue.string.length ) ;
        VarBind->value.asnType = ASN_RFC1213_DISPSTRING ;
        VarBind->value.asnValue.string.dynamic = TRUE ;
    }
    return status ;

}  /* end of SMIBuildDispString() */

/* end of smi.c */


/*  SMIFree
 *
 *    Free the variable
 *
 *  Arguments:
 *
 *    invalue                     address of data
 *
 *  Return Codes:
 *
 *
 */

void
SMIFree( IN AsnAny *invalue )

{
    switch (invalue->asnType) {

        case ASN_OCTETSTRING:
        case ASN_RFC1155_IPADDRESS:
            if (invalue->asnValue.string.length != 0) {
	            invalue->asnValue.string.length = 0 ;
	            free(invalue->asnValue.string.stream) ;
            }
	    break;

        case ASN_OBJECTIDENTIFIER:
            if (invalue->asnValue.object.idLength != 0)
	            SNMP_free(invalue->asnValue.object.ids) ;
	        break ;

        default:
			break ;
    }
}  /* end of SMIFree */

/* end of smi.c */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\user.h ===
/*
 *  user.h v0.10
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module is a spane holder for user definitions.
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V1.0 - 04/16/97  D. D. Burns     Original Creation
 */

#ifndef user_h
#define user_h

/*
| USER.C - Function Prototypes
*/

/* Spt_GetProcessCount - Retrieve count of number of active processes */
ULONG
Spt_GetProcessCount(
                    void
                    );

/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */
ULONG
PartitionTypeToLastArc (
                        BYTE p_type
                        );                      /* Located in "HRFSENTR.C" */

#endif /* user_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\smint.h ===
/* smint.h  v0.10
// Copyright (C) 1992-1995, All Rights Reserved, by
// Digital Equipment Corporation, Maynard, Mass.
//
// This software is furnished under a license and may be used and copied
// only  in  accordance  with  the  terms  of such  license and with the
// inclusion of the above copyright notice. This software or  any  other
// copies thereof may not be provided or otherwise made available to any
// other person. No title to and ownership of  the  software  is  hereby
// transferred.
//
// The information in this software is subject to change without  notice
// and  should  not be  construed  as  a commitment by Digital Equipment
// Corporation.
//
// Digital assumes no responsibility for the use or  reliability  of its
// software on equipment which is not supplied by Digital.
*/

/*
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the native data type definitions.  This file
 *    is taken from the Calaveras Project's system management work done by
 *    Wayne Duso.  By using these native data types (Structure of Management
 *    Information (SMI)) it is intended to align the management APIs on
 *    the Windows NT and UNIX platforms as closely as possible.
 */


#if !defined(_SMINT_H_)
#define _SMINT_H_ 

#if !defined(lint) && defined(INCLUDE_ALL_RCSID)
static char smitydef_h_rcsid[] = "$Header: /calsrv/usr/cal10/duso/calaveras/RCS/smint.h,v 1.6 1993/08/13 15:29:49 duso Exp $";
#endif



/*
// FACILITY:
//
// Calaveras System Management
//
// ABSTRACT:
//
// Structure Of Management Information (SMI) support. Specifically, type 
// declarations targeted for Management Agent use.
//
// AUTHORS:
//
// Wayne W. Duso
//
// CREATION DATE:
// 
// 25-November-1992 
//
// MODIFICATION HISTORY:
//
// $Log: smitydef.h,v $
 * Revision 1.7  1994/03/23  14:02:00  miriam
 * Modifications for Windows NT platform
 *
 * Revision 1.6  1993/08/13  15:29:49  duso
 * Housekeeping.
 *
 * Revision 1.5  1993/03/11  21:26:51  duso
 * Modify interface types to reflect CA X1.1.1 changes.
 *
 * Revision 1.4  1993/03/10  17:36:26  duso
 * Fix free bug resulting from using MOSS to create opaque structures and not
 * using MOSS to free said structures. Manipulation of MOSS opaque structures
 * now done using MOSS supplied routines exclusively. In the spirit of
 * providing opaque types with a 'complete' API, a create() operations has been
 * added to each SMI supported type.
 *
 * Revision 1.3  1993/02/22  18:12:58  duso
 * Support for all SNMP SMI types now in place. Also exclusive copy passed from
 * avlToLocal; not reference copy. This 'inefficiency' was needed to support
 * structure types (length, value). Said types could not be mutated from an
 * avl octet to their true form using references.
 *
 * Revision 1.2  1993/01/28  21:45:24  duso
 * Major clean up and completion to support SNMP centered MOMStub and class
 * Simple test MOC.
*/



/*
// TABLE OF CONTENTS
//
//  Associated Documents
//
//  Usage/Design Notes
//
//  Include Files
//
//  SMI Supported Types (typedef(s))
//      BIDT_ENUMERATION
//      ConstructionStart
//      ConstructionEnd
//      Counter
//      Gauge
//      Integer
//      IpAddress
//      Null
//      ObjectIdentifier
//      OctetString
//      Opaque
//      TimeTicks
*/


/*
// Associated Documents
//
// [1]  Calaveras Managed Object Module Framework Design Specification
// [2]  smidbty.h: Declares the pseudo abstract base psuedo class DtEntry and 
//      its API.
// [3]  smitypes.h: Declares actual instances of DtEntry, one for each typed
//      delcared in this file.
*/          


/*
// Usage/Design Notes
//
//  1.  Each type declared in this file has an accompanying API. The APIs
//      are declared in [2,3]. It is strongly recommended that type instances
//      be accessed through their API, not through direct manipulation of 
//      their internal format [NB: Additional operations must be added to the
//      API set to make the type's concrete/indiginous-like. Specifically,
//      there currently is no 'compare' interface; this must/will be corrected].
//   
//  2.  For each SMI type supported - those being any type defined by either 
//      RFC 1155 or by additions to said RFC accepted by the IETF - there is a 
//      typedef defining its 'in-memory' or 'local' representation. This 
//      information is made available to the SMI type database, the managed 
//      object module stub, and managed object classes (management agents) 
//      through this module.
*/   


/*
// Include Files
*/

#include <snmp.h>


 

/*
// SMI Supported Types (typedef(s))
*/
typedef enum
{
    nsm_true = 1 ,
    nsm_false = 2
} NSM_Boolean ;


typedef int BIDT_ENUMERATION;
/*  Signed 32 bit integer is the base data construct used by the MIR to 
//  represent integer enumerations.
*/


typedef unsigned long int Counter;
/*  Unsigned 32 bit integer is the base data construct.
*/


typedef unsigned long int Gauge;
/*  Unsigned 32 bit integer is the base data construct.
*/


typedef int Integer;
/*  Signed 32 bit integer is the base data construct.
*/


typedef unsigned long int IpAddress;
/*  Unsigned 32 bit integer is the base data construct. Interpret as
//  a 4 octet hex value.
*/


typedef char Null;
/*  The semantics of Null are that it should always be a 0 constant.
*/


typedef AsnObjectIdentifier ObjectIdentifier;
/*  
//  Aggregate type: Note that this is typedef to the Windows NT's version
//  of an object identifier to enable use with the Windows NT SNMP routines.
//  The Common Agent's MOSS library is not available for use on Windows NT.
//
//  The fields for the object identifier are:
//	UINT idLength ;		// number of integers in the oid's int array
//	UINT *ids ;		// address of the oid's int array
*/


typedef struct
/*  
//  This one is used to minimize differences across platforms and because
//  Windows NT has no support routines for manipulating an octet string.
//  Should that change consideration should be given to using the native
//  for as the Common Agent is not available on Windows NT.
//  Aggregate type: Note that this is structured exactly as the CA MOSS 
//  definition octet_string found in moss.h. As such, it should either be
//  removed in favor of that definition or its synchronization must be 
//  ensured.
*/
{
    int length;                 /* length of string */
    unsigned long int dataType; /* ASN.1 data type tag (currently optional)*/
    char* string;               /* pointer to counted string */
} OctetString;


typedef struct
/*  
//  Aggregate type
*/
{
    int length;     /* length of string */
    char* string;   /* pointer to counted entity */
} Opaque;


typedef unsigned long int TimeTicks;
/*  Unsigned 32 bit integer is the base data construct.
*/

typedef OctetString Simple_DisplayString ;
/* Included here as oppose to in the simpleema.hxx file on Calaveras to
// reduce the number of header files.
*/

typedef int Access_Credential ;
/* This is a dummy place holder for use in the future
*/

typedef struct 
{
    unsigned int count ;  /* number of identifying variables for an instance */
    char **array ;        /* array of pointers to variables' data */
} InstanceName ;
/* This is a flexible structure for passing the ordered native datatypes
// that compose the instance name.  For example,
//    tcpConnEntry from RFC 1213 p. 49 (MIB-II) is identified by
//
//	INDEX {
//		tcpConnLocalAddress,
//		tcpConnLocalPort,
//		tcpConnRemAddress,
//		tcpConnRemPort
//	      }
//
// The instance name would be an ordered set :
//
//	count = 4
//	array[ 0 ] = address of an IP Address (the local ip address)
//	array[ 1 ] = address of an Integer (the local port)
//	array[ 2 ] = address of an IP Address (the remote ip address)
//	array[ 3 ] = address of an Integer (the remote port)
*/

#define MAX_OCTET_STRING 256

UINT
SMIGetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMIGetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMIGetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance );
UINT
SMIGetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance );
UINT
SMIGetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance );
UINT
SMIGetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMIGetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance );
UINT
SMIGetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMIGetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMIGetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance );
UINT
SMISetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance );
UINT
SMISetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance );
UINT
SMISetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance );
UINT
SMISetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMISetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMISetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance );
UINT
SMIBuildInteger( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue );
UINT
SMIBuildOctetString( IN OUT RFC1157VarBind *VarBind ,
                     IN char *invalue );
UINT
SMIBuildObjectId( IN OUT RFC1157VarBind *VarBind ,
                  IN char *invalue );
UINT
SMIBuildCounter( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue );
UINT
SMIBuildGauge( IN OUT RFC1157VarBind *VarBind ,
               IN char *invalue );
UINT
SMIBuildTimeTicks( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue );
UINT
SMIBuildIpAddress( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue );
UINT
SMIBuildDispString( IN OUT RFC1157VarBind *VarBind ,
                    IN char *invalue );
void
SMIFree( IN AsnAny *invalue );

#endif  /*_SMINT_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\hostmib\user.c ===
/*
 *  user.c v0.10
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains support functions for the HostMIB Subagent.
 *
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V0.01 - 04/16/97  D. D. Burns     Original Creation
 *
 *
 */




/*

|
| Support Functions accessible from outside this module:
|

Spt_GetProcessCount
    This function supports hrSystem table attribute "hrSystemProcesses"
    by returning the number of active processes in the system.  This
    code is derived from PERFDLL code in files "PERFSPRC.C" and
    "PERFPROC.C".

|
| Support Functions accessible only from inside this module:
|

*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>


/*
|| LOCAL DEFINES
*/

/*
| Spt_GetProcessCount
*/
#define INCREMENT_BUFFER_SIZE ((DWORD)(4096*2))
#define LARGE_BUFFER_SIZE   ((DWORD)(4096*16))



/* Spt_GetProcessCount - Retrieve count of number of active processes */
/* Spt_GetProcessCount - Retrieve count of number of active processes */
/* Spt_GetProcessCount - Retrieve count of number of active processes */

ULONG
Spt_GetProcessCount(
                    void
                    )
/*
|  IN SUPPORT OF:
|
|       HRSYSTEM.C - "hrSystemProcesses"
|
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       System performance information is fetched thru
|       "NtQuerySystemInformation()".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns the count of active processes as determined by
|       the number of performance information blocks for processes that
|       have both a name and a non-zero thread count (in the style of code in
|       "PERFPROC.C").
|
|     On any Failure:
|       Function returns zero (not a legal number of processes).
|
|  THE BIG PICTURE:
|
|       The generated function "GetHrSystemProcesses()" in HRSYSTEM.C is
|       invoked by the generic subagent to retrieve the current value of 
|       the SNMP attribute "GetHrSystemProcesses".  All the work of 
|       retrieving that value is done by this support function.
|
|  OTHER THINGS TO KNOW:
|
|       This function incurs a rather substantial bit of overhead in that
|       to determine the number of processes active it actually fetches
|       a large slug of performance data (a "slug" per process) for all
|       processes and merely counts the number of slugs returned.
|       This seems to be the only available way to acquire this information.
|
*/
{
DWORD   dwReturnedBufferSize;
NTSTATUS Status;
DWORD   ProcessBufSize = LARGE_BUFFER_SIZE;     // Initial Process-Buf size
LPBYTE  pProcessBuffer = NULL;                  // Pointer to Process-Buf
PSYSTEM_PROCESS_INFORMATION ProcessInfo;        // Walking ptr thru Process-Buf
ULONG   ProcessBufferOffset = 0;                // 
ULONG   Process_count = 0;                      // Count of Live processes


//
//  Get process data from system.
//

// Grab an initially-sized buffer to receive data
pProcessBuffer = malloc(ProcessBufSize);
if (pProcessBuffer == NULL) {
    return (0);         // Out of memory
    }

/*
| Loop until we've allocated a buffer big enough to receive all the data
| NtQuery wants to give us.
|
| Exit with the buffer loaded with info or on some kind of non-mismatch error.
*/

while( (Status = NtQuerySystemInformation(
                        SystemProcessInformation,
                        pProcessBuffer,
                        ProcessBufSize,
                        &dwReturnedBufferSize))
      == STATUS_INFO_LENGTH_MISMATCH ) {

    LPBYTE  pNewProcessBuffer;               // For use on realloc

    // expand buffer & retry
    ProcessBufSize += INCREMENT_BUFFER_SIZE;

    if ( !(pNewProcessBuffer = realloc(pProcessBuffer,ProcessBufSize)) ) {

        /* If realloc failed and left us with the old buffer, free it */
        if (pProcessBuffer != NULL) {
            free(pProcessBuffer);
            }

        return (0);     // Out of memory
        }
    else {
        /* Successful Realloc */
        pProcessBuffer = pNewProcessBuffer;
        }

    /* Try another query */        
    }

/* If we didn't meet with full success. . . */
if ( !NT_SUCCESS(Status) ) {
    if (pProcessBuffer != NULL) {
        free(pProcessBuffer);
        }

    return (0);     // Unknown error that prevents us from continuing
    }

/*
| At this point, "pProcessBuffer" points to a buffer formatted as a
| "System Process Information" structure.
|
| Setup to go a-walking it.
*/
ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;

while ( TRUE ) {

    // check for Live processes
    //  (i.e. name or threads)

    if ((ProcessInfo->ImageName.Buffer != NULL) ||
        (ProcessInfo->NumberOfThreads > 0)) {

        /* thread is not Dead */
        Process_count += 1;
        }


    // exit if this was the last process in list
    if (ProcessInfo->NextEntryOffset == 0) {
        break;
        }

    // point to next buffer in list
    ProcessBufferOffset += ProcessInfo->NextEntryOffset;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                      &pProcessBuffer[ProcessBufferOffset];

    }


free(pProcessBuffer);

return (Process_count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\dlog_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    dlog_lm.c

Abstract:

    This file contains MIB_dlog_lmget, which actually call lan manager
    for the dloge table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <string.h>
#include <search.h>
#include <stdlib.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include "mib.h"
#include "mibfuncs.h"
#include "dlog_tbl.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int dlog_entry_cmp(
       IN DOM_LOGON_ENTRY *A,
       IN DOM_LOGON_ENTRY *B
       ) ;

void build_dlog_entry_oids( );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_dlog_lmget
//    Retrieve dlogion table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_dlogons_lmget(
	   )

{
SNMPAPI nResult = SNMPAPI_NOERROR;
#if 0
DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
SHARE_INFO_2 *DataTable;
DOM_LOGON_ENTRY *MIB_DomLogonTableElement ;
int First_of_this_block;
DWORD resumehandle=0;

   //
   //
   // If cached, return piece of info.
   //
   //

   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

   // free the old table  LOOK OUT!!
   	
   // init the length
   MIB_DomLogonTable.Len = 0;
   First_of_this_block = 0;
   	
   do {  //  as long as there is more data to process

	lmCode =
    	NetShareEnum(NULL,          // local server
                2,                  // level 2,
                &bufptr,            // data structure to return
                MAX_PREFERRED_LENGTH,
                &entriesread,
                &totalentries,
                &resumehandle       //  resume handle
                );

        //
        // Filter out all the Admin shares (name ending with $).
        //
        AdminFilter(2,&entriesread,bufptr);


    DataTable = (SHARE_INFO_2 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
    	{  // valid so process it, otherwise error
   	
   	if(0 == MIB_DomLogonTable.Len) {  // 1st time, alloc the whole table
   		// alloc the table space
                MIB_DomLogonTable.Table = SnmpUtilMemAlloc(totalentries *
   						sizeof(DOM_LOGON_ENTRY) );
   	}
	
	MIB_DomLogonTableElement = MIB_DomLogonTable.Table + First_of_this_block ;
	
   	for(i=0; i<entriesread; i++) {  // once for each entry in the buffer
   		// increment the entry number
   		
   		MIB_DomLogonTable.Len ++;
   		
   		// Stuff the data into each item in the table
   		
   		// dloge name
                MIB_DomLogonTableElement->svShareName.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_netname ) ) ;
   		MIB_DomLogonTableElement->svShareName.length =
   				strlen( DataTable->shi2_netname ) ;
		MIB_DomLogonTableElement->svShareName.dynamic = TRUE;
   		memcpy(	MIB_DomLogonTableElement->svShareName.stream,
   			DataTable->shi2_netname,
   			strlen( DataTable->shi2_netname ) ) ;
   		
   		// Share Path
                MIB_DomLogonTableElement->svSharePath.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_path ) ) ;
   		MIB_DomLogonTableElement->svSharePath.length =
   				strlen( DataTable->shi2_path ) ;
		MIB_DomLogonTableElement->svSharePath.dynamic = TRUE;
   		memcpy(	MIB_DomLogonTableElement->svSharePath.stream,
   			DataTable->shi2_path,
   			strlen( DataTable->shi2_path ) ) ;
   		
   		
   		// Share Comment/Remark
                MIB_DomLogonTableElement->svShareComment.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_remark ) ) ;
   		MIB_DomLogonTableElement->svShareComment.length =
   				strlen( DataTable->shi2_remark ) ;
		MIB_DomLogonTableElement->svShareComment.dynamic = TRUE;
   		memcpy(	MIB_DomLogonTableElement->svShareComment.stream,
   			DataTable->shi2_remark,
   			strlen( DataTable->shi2_remark ) ) ;
   		
   		
   		DataTable ++ ;  // advance pointer to next dlog entry in buffer
		MIB_DomLogonTableElement ++ ;  // and table entry
		
   	} // for each entry in the data table
   	
   	// indicate where to start adding on next pass, if any
   	First_of_this_block = i ;
   	
       	} // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    build_dlog_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_DomLogonTable.Table[0], MIB_DomLogonTable.Len,
          sizeof(DOM_LOGON_ENTRY), dlog_entry_cmp );

   //
   //
   // Cache table
   //
   //

   //
   //
   // Return piece of information requested
   //
   //

Exit:
#endif
   return nResult;

} // MIB_dlog_get

//
// MIB_dlog_cmp
//    Routine for sorting the dlogion table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int dlog_entry_cmp(
       IN DOM_LOGON_ENTRY *A,
       IN DOM_LOGON_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( &A->Oid, &B->Oid );
} // MIB_dlog_cmp


//
//    None.
//
void build_dlog_entry_oids(
       )

{
#if 0
AsnOctetString OSA ;
char StrA[MIB_SHARE_NAME_LEN];
DOM_LOGON_ENTRY *ShareEntry ;
unsigned i;

// start pointer at 1st guy in the table
ShareEntry = MIB_DomLogonTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_DomLogonTable.Len ; i++)  {
   // for each entry in the dlogion table

   // Make string to use as index
   memcpy( StrA, ShareEntry->svShareName.stream,
                 ShareEntry->svShareName.length );

   OSA.stream = StrA ;
   OSA.length =  ShareEntry->svShareName.length ;
   OSA.dynamic = FALSE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &ShareEntry->Oid );

   ShareEntry++; // point to the next guy in the table

   } // for
#endif
} // build_dlog_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\hash.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hash Table and support functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>

#include "mib.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "hash.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define HT_SIZE    101
#define HT_RADIX   18

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

   // Structure of one node in the hash table
typedef struct hash_node
           {
	   MIB_ENTRY        *MibEntry;
	   struct hash_node *Next;
	   } HASH_NODE;

   // Hash table definition
HASH_NODE *MIB_HashTable[HT_SIZE];

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_HashInit
//    Initializes hash table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_HashInit()

{
UINT      I;
UINT      HashRes;
HASH_NODE *ht_ptr;
SNMPAPI   nResult;


   // Initialize hash table
   for ( I=0;I < HT_SIZE;I++ )
      {
      MIB_HashTable[I] = NULL;
      }

   // Loop MIB hashing the OID's to find position in Hash Table
   for ( I=0;I < MIB_num_variables;I++ )
      {
      HashRes = MIB_Hash( &Mib[I].Oid );

      // Check for empty bucket
      if ( MIB_HashTable[HashRes] == NULL )
         {
	 // Allocate first node in bucket
         MIB_HashTable[HashRes] = SnmpUtilMemAlloc( sizeof(HASH_NODE) );
	 if ( MIB_HashTable[HashRes] == NULL )
	    {
	    SetLastError( SNMP_MEM_ALLOC_ERROR );

	    nResult = SNMPAPI_ERROR;
	    goto Exit;
	    }

	 // Make copy of position in hash table to save MIB entry
	 ht_ptr = MIB_HashTable[HashRes];
	 }
      else
         {
	 // Find end of bucket
	 ht_ptr = MIB_HashTable[HashRes];
	 while ( ht_ptr->Next != NULL )
	    {
	    ht_ptr = ht_ptr->Next;
	    }

	 // Alloc space for next node
         ht_ptr->Next = SnmpUtilMemAlloc( sizeof(HASH_NODE) );
	 if ( ht_ptr->Next == NULL )
	    {
	    SetLastError( SNMP_MEM_ALLOC_ERROR );

	    nResult = SNMPAPI_ERROR;
	    goto Exit;
	    }

	 // Make copy of position in hash table to save MIB entry
	 ht_ptr = ht_ptr->Next;
	 }

      // Save MIB Entry pointer
      ht_ptr->MibEntry = &Mib[I];
      ht_ptr->Next     = NULL;
      }

Exit:
   return nResult;
} // MIB_HashInit



//
// MIB_Hash
//    Hash an Object Identifier to find its position in the Hash Table.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_Hash(
        IN AsnObjectIdentifier *Oid // OID to hash
	)

{
long I;
UINT Sum;


   Sum = 0;
   for ( I=0;I < (long)Oid->idLength-1;I++ )
      {
      Sum = Sum * HT_RADIX + Oid->ids[I+1];
      }

   return Sum % HT_SIZE;
} // MIB_Hash



//
// MIB_HashLookup
//    Lookup OID in Hash Table and return pointer to MIB Entry.
//
// Notes:
//
// Return Codes:
//    NULL - OID not present in Hash Table.
//
// Error Codes:
//    None.
//
MIB_ENTRY *MIB_HashLookup(
              IN AsnObjectIdentifier *Oid // OID to lookup
	      )

{
HASH_NODE *ht_ptr;
MIB_ENTRY *pResult;
UINT      HashPos;


   // Hash OID to find position in Hash Table
   HashPos = MIB_Hash( Oid );

   // Search hash bucket for match
   ht_ptr = MIB_HashTable[HashPos];
   while ( ht_ptr != NULL )
      {
      if ( !SnmpUtilOidCmp(Oid, &ht_ptr->MibEntry->Oid) )
         {
	 pResult = ht_ptr->MibEntry;
	 goto Exit;
	 }

      ht_ptr = ht_ptr->Next;
      }

   // Check for not found error
   if ( ht_ptr == NULL )
      {
      pResult = NULL;
      }

Exit:
   return pResult;
} // MIB_HashLookup



#if 0 // Left in in case of more testing on hash performance
//
//
// Debugging Code
//
//

void MIB_HashPerformance()

{
UINT I;
UINT LargestBucket;
UINT BucketSize;
HASH_NODE *ht_ptr;
ULONG Sum;
ULONG Count;


   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Hash Performance Report\n" );

   LargestBucket = 0;
   Count         = 0;
   Sum           = 0;
   for ( I=0;I < HT_SIZE;I++ )
      {
      BucketSize = 0;
      ht_ptr     = MIB_HashTable[I];

      // Count nodes in bucket
      while ( ht_ptr != NULL )
         {
	 BucketSize++;
	 ht_ptr = ht_ptr->Next;
	 }

      if ( BucketSize )
         {
	 SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   %d -- Bucket Size:  %d\n", I, BucketSize ));

         Sum += BucketSize;
	 Count ++;

         LargestBucket = max( LargestBucket, BucketSize );
	 }
      }

   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Number of Buckets:  %d\n", HT_SIZE ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Number of MIB Var:  %d\n", MIB_num_variables ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Hashing Radix    :  %d\n", HashRadix ));

   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Used bucket Count:  %d\n", Count ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Avg. Bucket Size :  %d\n", Sum / Count ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Larg. bucket Size:  %d\n", LargestBucket ));
} // MIB_HashPerformance
#endif
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\dlog_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    dlog_tbl.h

Abstract:

    Define all of the structures and routines used in the domain logon list
    table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef dlog_tbl_h
#define dlog_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define DLOG_USER_FIELD        1
#define DLOG_MACHINE_FIELD     2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the domain logon table
typedef struct dom_logon_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString domLogonUser;    // Index
	   AsnDisplayString domLogonMachine; // Index
	   } DOM_LOGON_ENTRY;

   // Domain logon table definition
typedef struct
           {
	   UINT            Len;
	   DOM_LOGON_ENTRY *Table;
           } DOM_LOGON_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern DOM_LOGON_TABLE  MIB_DomLogonTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_dlogons_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* dlog_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\hash.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Constants, types, and prototypes for Hash Table and supporting functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef hash_h
#define hash_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#include "mib.h"

//--------------------------- PUBLIC STRUCTS --------------------------------

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_HashInit(
           void
           );

UINT MIB_Hash(
        IN AsnObjectIdentifier *Oid // OID to hash
	);

MIB_ENTRY *MIB_HashLookup(
              IN AsnObjectIdentifier *Oid // OID to lookup
	      );

#ifdef MIB_DEBUG
void MIB_HashPerformance( void );
#endif

//------------------------------- END ---------------------------------------

#endif /* hash_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\lmcache.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    lmcache.c

Abstract:

    This file actually creates the global cache_table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <time.h>

#ifdef WIN32
#include <windows.h>
#endif

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

CACHE_ENTRY cache_table[MAX_CACHE_ENTRIES] =
		{
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0}
		};

time_t cache_expire[MAX_CACHE_ENTRIES] =
		{
		120,	// 2 min cache expiration for C_NETWKSTAGETINFO		   1
		120,	// 2 min cache expiration for C_NETSERVERGETINFO	   2
		120,	// 2 min cache expiration for C_NETSTATISTICSGET_SERVER	3
		120,	// 2 min cache expiration for C_NETSTATISTICSGET_WORKSTATION	4
		120,	// 2 min cache expiration for C_NETSERVICEENUM		   5
		120,	// 2 min cache expiration for C_NETSESSIONENUM		   6
		120,	// 2 min cache expiration for C_NETUSERENUM			   7
		120,	// 2 min cache expiration for C_NETSHAREENUM		   8
		120,	// 2 min cache expiration for C_NETUSEENUM			   9
		120,	// 2 min cache expiration for C_NETWKSTAUSERGETINFO	  10
		120,	// 2 min cache expiration for C_NETSERVERENUM         11
		120,	// 2 min cache expiration for C_NETWKSTAGETINFO_502   12
		120,	// 2 min cache expiration for C_NETSERVERGETINFO_402  13
		120,	// 2 min cache expiration for C_NETSERVERGETINFO_403  14
		120,	// 2 min cache expiration for C_NETWKSTAGETINFO_101   15
		120,	// 2 min cache expiration for C_PRNT_TABLE            16
		120,	// 2 min cache expiration for C_USES_TABLE            17
		120,	// 2 min cache expiration for C_DLOG_TABLE            18
		120,	// 2 min cache expiration for C_SESS_TABLE            19
		120,	// 2 min cache expiration for C_SRVR_TABLE            20
		120,	// 2 min cache expiration for C_SRVC_TABLE            21
		120,	// 2 min cache expiration for C_USER_TABLE            22
		120,	// 2 min cache expiration for C_ODOM_TABLE            23
		120,	// 2 min cache expiration for C_SHAR_TABLE            24
		120	// 2 min cache expiration for C_NETSERVERENUM			25
		};
//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\lmcache.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    lmcache.h

Abstract:

    This routine declares all of the structures required to cache the Lan
    Manager function calls.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef lmcache_h
#define lmcache_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#define	C_NETWKSTAGETINFO		1
#define	C_NETSERVERGETINFO		2
#define	C_NETSTATISTICSGET_SERVER	3
#define	C_NETSTATISTICSGET_WORKST	4
#define	C_NETSERVICEENUM		5
#define	C_NETSESSIONENUM		6
#define	C_NETUSERENUM			7
#define	C_NETSHAREENUM			8
#define	C_NETUSEENUM			9
#define	C_NETWKSTAUSERGETINFO		10
#define	C_NETSERVERENUM			11
#define	C_NETWKSTAGETINFO_502		12
#define	C_NETSERVERGETINFO_402		13
#define	C_NETSERVERGETINFO_403		14
#define	C_NETWKSTAGETINFO_101		15
#define C_PRNT_TABLE			16
#define C_USES_TABLE			17
#define C_DLOG_TABLE			18
#define C_SESS_TABLE			19
#define C_SRVR_TABLE			20
#define C_SRVC_TABLE			21
#define C_USER_TABLE			22
#define C_ODOM_TABLE			23
#define C_SHAR_TABLE		  	24
#define	MAX_CACHE_ENTRIES		25

//--------------------------- PUBLIC STRUCTS --------------------------------

typedef struct cache_entry
	{
	time_t acquisition_time ;	// time that data acquired
	LPBYTE bufptr;			// pointer to buffer
	DWORD entriesread;		// stuffed if appropriate
	DWORD totalentries;		// stuffed if appropriate
	} CACHE_ENTRY ;
	
//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern CACHE_ENTRY cache_table[MAX_CACHE_ENTRIES] ;
extern time_t cache_expire[MAX_CACHE_ENTRIES];
//--------------------------- PUBLIC PROTOTYPES -----------------------------


//------------------------------- END ---------------------------------------

#endif /* lmcache_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\dlog_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    dlog_tbl.c

Abstract:

    All routines to perform operations on the Domain Logon Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "dlog_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Domain Logon table
static UINT                dlogSubids[] = { 4, 8, 1 };
static AsnObjectIdentifier MIB_DomLogonPrefix = { 3, dlogSubids };

DOM_LOGON_TABLE     MIB_DomLogonTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define DLOG_FIELD_SUBID    (MIB_DomLogonPrefix.idLength+MIB_OidPrefix.idLength)

#define DLOG_FIRST_FIELD       DLOG_USER_FIELD
#define DLOG_LAST_FIELD        DLOG_MACHINE_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_dlogons_get(
        IN OUT RFC1157VarBind *VarBind
	);

int MIB_dlogons_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_dlogons_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_dlogons_func
//    High level routine for handling operations on the Domain Logon table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_dlogons_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Domain Logon table with the info from server
	 if ( SNMPAPI_ERROR == MIB_dlogons_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_DomLogonTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { DLOG_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };


         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonTable.Table[0].Oid );
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_dlogons_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Domain Logon Table with the info from server
	 if ( SNMPAPI_ERROR == MIB_dlogons_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[DLOG_FIELD_SUBID];

         // Lookup OID in table
         if (Field < DLOG_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = DLOG_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > DLOG_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_dlogons_match( &VarBind->name, &Entry );

    
         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_DomLogonTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > DLOG_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_DomLogonTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > DLOG_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonTable.Table[Entry].Oid );
         }

         ErrStat = MIB_dlogons_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_dlogons_func



//
// MIB_dlogons_get
//    Retrieve Domain Logon Table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_dlogons_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[DLOG_FIELD_SUBID] < DLOG_FIRST_FIELD ||
       VarBind->name.ids[DLOG_FIELD_SUBID] > DLOG_LAST_FIELD)
   {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
   }

   // Fill the Domain Logon Table with the info from server
   if ( SNMPAPI_ERROR == MIB_dlogons_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_dlogons_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_dlogons_copyfromtable( Entry, VarBind->name.ids[DLOG_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_dlogons_get



//
// MIB_dlogons_match
//    Match the target OID with a location in the Domain Logon Table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_dlogons_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_DomLogonPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_DomLogonPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_DomLogonTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_DomLogonTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_dlogons_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_dlogons_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case DLOG_USER_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_DomLogonTable.Table[Entry].domLogonUser.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonUser.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonUser.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomLogonTable.Table[Entry].domLogonUser.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case DLOG_MACHINE_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                      * MIB_DomLogonTable.Table[Entry].domLogonMachine.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonMachine.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonMachine.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomLogonTable.Table[Entry].domLogonMachine.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Domain Logon Table.\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_dlogons_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\mib.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mib.c

Abstract:

    Contains definition of LAN Manager MIB.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>

#include "mibfuncs.h"
#include "hash.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "mib.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // If an addition or deletion to the MIB is necessary, there are several
   // places in the code that must be checked and possibly changed.
   //
   // 1.  There are 4 constants that are used as indexes to the start of each
   //     group in the MIB.  These are defined in MIB.H and must be adjusted
   //     to reflect any changes that affect them.
   //
   // 2.  The last field in each MIB entry is used to point to the NEXT
   //     leaf variable or table root.  If an AGGREGATE is next in the MIB,
   //     this pointer should skip it, because an AGGREGATE can never be
   //     accessed.  The last variable in the MIB is NULL.  Using the constants
   //     defined in step 1 above provides some flexibility.
   //
   // 3.  Following the MIB is a table of TABLE pointers into the MIB.  These
   //     pointers must be updated to reflect any changes made to the MIB.
   //     Each entry should point to the variable immediately below the table
   //     root.  (ie The entry in the table for "Session Table" should point
   //     to the MIB variable { svSessionTable 1 } in the server group.)

   // The prefix to all of the LM mib names is 1.3.6.1.4.1.77.1
UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 77, 1 };
AsnObjectIdentifier MIB_OidPrefix = { sizeof OID_Prefix / sizeof(UINT),
                                      OID_Prefix };

   // OID definitions for MIB -- group partitions
UINT MIB_common_group[] = { 1 };
UINT MIB_server_group[] = { 2 };
UINT MIB_wksta_group[]  = { 3 };
UINT MIB_domain_group[] = { 4 };

   // OID definitions for MIB -- COMMON group
UINT MIB_comVersionMaj[]    = { 1, 1, 0 };
UINT MIB_comVersionMin[]    = { 1, 2, 0 };
UINT MIB_comType[]          = { 1, 3, 0 };
UINT MIB_comStatStart[]     = { 1, 4, 0 };
UINT MIB_comStatNumNetIOs[] = { 1, 5, 0 };
UINT MIB_comStatFiNetIOs[]  = { 1, 6, 0 };
UINT MIB_comStatFcNetIOs[]  = { 1, 7, 0 };

   // OID definitions for MIB -- SERVER group
UINT MIB_svDescription[]         = { 2, 1, 0 };
UINT MIB_svSvcNumber[]           = { 2, 2, 0 };
UINT MIB_svSvcTable[]            = { 2, 3 };
UINT MIB_svSvcEntry[]            = { 2, 3, 1 };
UINT MIB_svStatOpens[]           = { 2, 4, 0 };
UINT MIB_svStatDevOpens[]        = { 2, 5, 0 };
UINT MIB_svStatQueuedJobs[]      = { 2, 6, 0 };
UINT MIB_svStatSOpens[]          = { 2, 7, 0 };
UINT MIB_svStatErrorOuts[]       = { 2, 8, 0 };
UINT MIB_svStatPwErrors[]        = { 2, 9, 0 };
UINT MIB_svStatPermErrors[]      = { 2, 10, 0 };
UINT MIB_svStatSysErrors[]       = { 2, 11, 0 };
UINT MIB_svStatSentBytes[]       = { 2, 12, 0 };
UINT MIB_svStatRcvdBytes[]       = { 2, 13, 0 };
UINT MIB_svStatAvResponse[]      = { 2, 14, 0 };
UINT MIB_svSecurityMode[]        = { 2, 15, 0 };
UINT MIB_svUsers[]               = { 2, 16, 0 };
UINT MIB_svStatReqBufsNeeded[]   = { 2, 17, 0 };
UINT MIB_svStatBigBufsNeeded[]   = { 2, 18, 0 };
UINT MIB_svSessionNumber[]       = { 2, 19, 0 };
UINT MIB_svSessionTable[]        = { 2, 20 };
UINT MIB_svSessionEntry[]        = { 2, 20, 1 };
UINT MIB_svAutoDisconnects[]     = { 2, 21, 0 };
UINT MIB_svDisConTime[]          = { 2, 22, 0 };
UINT MIB_svAuditLogSize[]        = { 2, 23, 0 };
UINT MIB_svUserNumber[]          = { 2, 24, 0 };
UINT MIB_svUserTable[]           = { 2, 25 };
UINT MIB_svUserEntry[]           = { 2, 25, 1 };
UINT MIB_svShareNumber[]         = { 2, 26, 0 };
UINT MIB_svShareTable[]          = { 2, 27 };
UINT MIB_svShareEntry[]          = { 2, 27, 1 };
UINT MIB_svPrintQNumber[]        = { 2, 28, 0 };
UINT MIB_svPrintQTable[]         = { 2, 29 };
UINT MIB_svPrintQEntry[]         = { 2, 29, 1 };

   // OID definitions for MIB - WORKSTATION group
UINT MIB_wkstaStatSessStarts[] = { 3, 1, 0 };
UINT MIB_wkstaStatSessFails[]  = { 3, 2, 0 };
UINT MIB_wkstaStatUses[]       = { 3, 3, 0 };
UINT MIB_wkstaStatUseFails[]   = { 3, 4, 0 };
UINT MIB_wkstaStatAutoRecs[]   = { 3, 5, 0 };
UINT MIB_wkstaErrorLogSize[]   = { 3, 6, 0 };
UINT MIB_wkstaUseNumber[]      = { 3, 7, 0 };
UINT MIB_wkstaUseTable[]       = { 3, 8 };
UINT MIB_wkstaUseEntry[]       = { 3, 8, 1 };

   // OID definitions for MIB - DOMAIN group
UINT MIB_domPrimaryDomain[]     = { 4, 1, 0 };
UINT MIB_domLogonDomain[]       = { 4, 2, 0 };
UINT MIB_domOtherDomainNumber[] = { 4, 3, 0 };
UINT MIB_domOtherDomainTable[]  = { 4, 4 };
UINT MIB_domOtherDomainEntry[]  = { 4, 4, 1 };
UINT MIB_domServerNumber[]      = { 4, 5, 0 };
UINT MIB_domServerTable[]       = { 4, 6 };
UINT MIB_domServerEntry[]       = { 4, 6, 1 };
UINT MIB_domLogonNumber[]       = { 4, 7, 0 };
UINT MIB_domLogonTable[]        = { 4, 8 };
UINT MIB_domLogonEntry[]        = { 4, 8, 1 };


   // LAN Manager MIB definiton
MIB_ENTRY Mib[] = {

             // LAN MGR 2 Root

          { { 0, NULL }, MIB_AGGREGATE, // { lanmanager 1 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_COM_START] },

             // COMMON group

          { { 1, MIB_common_group }, MIB_AGGREGATE, // { lanmgr-2 1 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_COM_START] },

          { { 3, MIB_comVersionMaj }, ASN_OCTETSTRING, // { common 1 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMVERSIONMAJ,
            &Mib[MIB_COM_START+1] },
          { { 3, MIB_comVersionMin }, ASN_OCTETSTRING, // { common 2 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMVERSIONMIN,
            &Mib[MIB_COM_START+2] },
          { { 3, MIB_comType }, ASN_OCTETSTRING, // { common 3 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMTYPE,
            &Mib[MIB_COM_START+3] },
          { { 3, MIB_comStatStart }, ASN_INTEGER, // { common 4 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATSTART,
            &Mib[MIB_COM_START+4] },
          { { 3, MIB_comStatNumNetIOs }, ASN_RFC1155_COUNTER, // { common 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATNUMNETIOS,
            &Mib[MIB_COM_START+5] },
          { { 3, MIB_comStatFiNetIOs }, ASN_RFC1155_COUNTER, // { common 6 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATFINETIOS,
            &Mib[MIB_COM_START+6] },
          { { 3, MIB_comStatFcNetIOs }, ASN_RFC1155_COUNTER, // { common 7 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATFCNETIOS,
            &Mib[MIB_SV_START] },

             // SERVER group

          { { 1, MIB_server_group }, MIB_AGGREGATE, // { lanmgr-2 2 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_SV_START] },

          { { 3, MIB_svDescription }, ASN_RFC1213_DISPSTRING, // { Server 1 }
            MIB_ACCESS_READWRITE, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVDESCRIPTION,
            &Mib[MIB_SV_START+1] },
          { { 3, MIB_svSvcNumber }, ASN_INTEGER, // { Server 2 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSVCNUMBER,
            &Mib[MIB_SV_START+3] },
          { { 2, MIB_svSvcTable }, MIB_AGGREGATE, // { Server 3 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVSVCTABLE,
            &Mib[MIB_SV_START+3] },
          { { 3, MIB_svSvcEntry }, MIB_TABLE, // { svSvcTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_srvcs_func, MIB_LM_SVSVCENTRY,
            &Mib[MIB_SV_START+4] },
          { { 3, MIB_svStatOpens }, ASN_RFC1155_COUNTER, // { server 4 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATOPENS,
            &Mib[MIB_SV_START+5] },
          { { 3, MIB_svStatDevOpens }, ASN_RFC1155_COUNTER, // { server 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATDEVOPENS,
            &Mib[MIB_SV_START+6] },
          { { 3, MIB_svStatQueuedJobs }, ASN_RFC1155_COUNTER, // { server 6 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATQUEUEDJOBS,
            &Mib[MIB_SV_START+7] },
          { { 3, MIB_svStatSOpens }, ASN_RFC1155_COUNTER, // { server 7 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATSOPENS,
            &Mib[MIB_SV_START+8] },
          { { 3, MIB_svStatErrorOuts }, ASN_RFC1155_COUNTER, // { server 8 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATERROROUTS,
            &Mib[MIB_SV_START+9] },
          { { 3, MIB_svStatPwErrors }, ASN_RFC1155_COUNTER, // { server 9 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATPWERRORS,
            &Mib[MIB_SV_START+10] },
          { { 3, MIB_svStatPermErrors }, ASN_RFC1155_COUNTER, // { server 10 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATPERMERRORS,
            &Mib[MIB_SV_START+11] },
          { { 3, MIB_svStatSysErrors }, ASN_RFC1155_COUNTER, // { server 11 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATSYSERRORS,
            &Mib[MIB_SV_START+12] },
          { { 3, MIB_svStatSentBytes }, ASN_RFC1155_COUNTER, // { server 12 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATSENTBYTES,
            &Mib[MIB_SV_START+13] },
          { { 3, MIB_svStatRcvdBytes }, ASN_RFC1155_COUNTER, // { server 13 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATRCVDBYTES,
            &Mib[MIB_SV_START+14] },
          { { 3, MIB_svStatAvResponse }, ASN_INTEGER, // { server 14 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATAVRESPONSE,
            &Mib[MIB_SV_START+15] },
          { { 3, MIB_svSecurityMode }, ASN_INTEGER, // { server 15 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSECURITYMODE,
            &Mib[MIB_SV_START+16] },
          { { 3, MIB_svUsers }, ASN_INTEGER, // { server 16 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVUSERS,
            &Mib[MIB_SV_START+17] },
          { { 3, MIB_svStatReqBufsNeeded }, ASN_RFC1155_COUNTER, // { server 17}
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATREQBUFSNEEDED,
            &Mib[MIB_SV_START+18] },
          { { 3, MIB_svStatBigBufsNeeded }, ASN_RFC1155_COUNTER, // { server 18}
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATBIGBUFSNEEDED,
            &Mib[MIB_SV_START+19] },
          { { 3, MIB_svSessionNumber }, ASN_INTEGER, // { server 19 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSESSIONNUMBER,
            &Mib[MIB_SV_START+21] },
          { { 2, MIB_svSessionTable }, MIB_AGGREGATE, // { server 20 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVSESSIONTABLE,
            &Mib[MIB_SV_START+21] },
          { { 3, MIB_svSessionEntry }, MIB_TABLE, // { svSessionTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_sess_func, MIB_LM_SVSESSIONENTRY,
            &Mib[MIB_SV_START+22] },
          { { 3, MIB_svAutoDisconnects }, ASN_INTEGER, // { server 21 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVAUTODISCONNECTS,
            &Mib[MIB_SV_START+23] },
          { { 3, MIB_svDisConTime }, ASN_INTEGER, // { server 22 }
            MIB_ACCESS_READWRITE, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVDISCONTIME,
#if 0
            &Mib[MIB_SV_START+24] },
#else
            &Mib[MIB_SV_START+25] },
#endif
          { { 3, MIB_svAuditLogSize }, ASN_INTEGER, // { server 23 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVAUDITLOGSIZE,
            &Mib[MIB_SV_START+25] },
          { { 3, MIB_svUserNumber }, ASN_INTEGER, // { server 24 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVUSERNUMBER,
            &Mib[MIB_SV_START+27] },
          { { 2, MIB_svUserTable }, MIB_AGGREGATE, // { server 25 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVUSERTABLE,
            &Mib[MIB_SV_START+27] },
          { { 3, MIB_svUserEntry }, MIB_TABLE, // { svUserTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_users_func, MIB_LM_SVUSERENTRY,
            &Mib[MIB_SV_START+28] },
          { { 3, MIB_svShareNumber }, ASN_INTEGER, // { server 26 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSHARENUMBER,
            &Mib[MIB_SV_START+30] },
          { { 2, MIB_svShareTable }, MIB_AGGREGATE, // { server 27 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVSHARETABLE,
            &Mib[MIB_SV_START+30] },
          { { 3, MIB_svShareEntry }, MIB_TABLE, // { svShareTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_shares_func, MIB_LM_SVSHAREENTRY,
            &Mib[MIB_SV_START+31] },
          { { 3, MIB_svPrintQNumber }, ASN_INTEGER, // { server 28 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVPRINTQNUMBER,
            &Mib[MIB_SV_START+33] },
          { { 2, MIB_svPrintQTable }, MIB_AGGREGATE, // { server 29 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVPRINTQTABLE,
            &Mib[MIB_SV_START+33] },
          { { 3, MIB_svPrintQEntry }, MIB_TABLE, // { svPrintQTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_prntq_func, MIB_LM_SVPRINTQENTRY,
            &Mib[MIB_WKSTA_START] },

          // WORKSTATION group

          { { 1, MIB_wksta_group }, MIB_AGGREGATE, // { lanmgr-2 3 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_WKSTA_START] },

          { { 3, MIB_wkstaStatSessStarts }, ASN_RFC1155_COUNTER, // { wrksta 1 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATSESSSTARTS,
            &Mib[MIB_WKSTA_START+1] },
          { { 3, MIB_wkstaStatSessFails }, ASN_RFC1155_COUNTER, // { wrksta 2 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATSESSFAILS,
            &Mib[MIB_WKSTA_START+2] },
          { { 3, MIB_wkstaStatUses }, ASN_RFC1155_COUNTER, // { wrksta 3 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATUSES,
            &Mib[MIB_WKSTA_START+3] },
          { { 3, MIB_wkstaStatUseFails }, ASN_RFC1155_COUNTER, // { wrksta 4 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATUSEFAILS,
            &Mib[MIB_WKSTA_START+4] },
          { { 3, MIB_wkstaStatAutoRecs }, ASN_RFC1155_COUNTER, // { wrksta 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATAUTORECS,
#if 0
            &Mib[MIB_WKSTA_START+5] },
#else
            &Mib[MIB_WKSTA_START+6] },
#endif
          { { 3, MIB_wkstaErrorLogSize }, ASN_INTEGER, // { wrksta 6 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTAERRORLOGSIZE,
            &Mib[MIB_WKSTA_START+6] },
          { { 3, MIB_wkstaUseNumber }, ASN_INTEGER, // { wrksta 7 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTAUSENUMBER,
            &Mib[MIB_WKSTA_START+8] },
          { { 2, MIB_wkstaUseTable }, MIB_AGGREGATE, // { wrksta 8 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_WKSTAUSETABLE,
            &Mib[MIB_WKSTA_START+8] },
          { { 3, MIB_wkstaUseEntry }, MIB_TABLE, // { wrkstaUseTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_wsuses_func, MIB_LM_WKSTAUSEENTRY,
            &Mib[MIB_DOM_START] },

             // DOMAIN group

          { { 1, MIB_domain_group }, MIB_AGGREGATE, // { lanmgr-2 4 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_DOM_START] },

          { { 3, MIB_domPrimaryDomain }, ASN_RFC1213_DISPSTRING, // { domain 1 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMPRIMARYDOMAIN,
#if 0
            &Mib[MIB_DOM_START+1] },
#else
            NULL },
#endif
          { { 3, MIB_domLogonDomain }, ASN_RFC1213_DISPSTRING, // { domain 2 }
#if 0
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
#else
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, TRUE,
#endif
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMLOGONDOMAIN,
            &Mib[MIB_DOM_START+2] },
          { { 3, MIB_domOtherDomainNumber }, ASN_INTEGER, // { domain 3 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMOTHERDOMAINNUMBER,
            &Mib[MIB_DOM_START+4] },
          { { 2, MIB_domOtherDomainTable }, MIB_AGGREGATE, // { domain 4 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_DOMOTHERDOMAINTABLE,
            &Mib[MIB_DOM_START+4] },
          { { 3, MIB_domOtherDomainEntry }, MIB_TABLE, // { domOtherDomTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_odoms_func, MIB_LM_DOMOTHERDOMAINENTRY,
            &Mib[MIB_DOM_START+5] },
          { { 3, MIB_domServerNumber }, ASN_INTEGER, // { domain 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMSERVERNUMBER,
            &Mib[MIB_DOM_START+7] },
          { { 2, MIB_domServerTable }, MIB_AGGREGATE, // { domain 6 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_DOMSERVERTABLE,
            &Mib[MIB_DOM_START+7] },
          { { 3, MIB_domServerEntry }, MIB_TABLE, // { domServerTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_svsond_func, MIB_LM_DOMSERVERENTRY,
            NULL }
          };
UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY );


//
// List of table pointers - References must agree with MIB
//
MIB_ENTRY *MIB_Tables[] = {
             &Mib[MIB_SV_START+3],     // Service
             &Mib[MIB_SV_START+21],    // Session
             &Mib[MIB_SV_START+27],    // User
             &Mib[MIB_SV_START+30],    // Share
             &Mib[MIB_SV_START+33],    // Print Queue
             &Mib[MIB_WKSTA_START+8],  // Uses
             &Mib[MIB_DOM_START+4],    // Other domain
             &Mib[MIB_DOM_START+7]     // Server
             };
UINT MIB_table_list_size = sizeof MIB_Tables / sizeof( MIB_ENTRY * );

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_get_entry
//    Lookup OID in MIB, and return pointer to its entry.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    SNMP_MIB_UNKNOWN_OID
//
MIB_ENTRY *MIB_get_entry(
              IN AsnObjectIdentifier *Oid
              )

{
AsnObjectIdentifier TempOid;
UINT                I;
MIB_ENTRY           *pResult;


   // Check prefix
   if ( SnmpUtilOidNCmp(&MIB_OidPrefix, Oid, MIB_PREFIX_LEN) )
      {
      pResult = NULL;
      goto Exit;
      }

   // Strip prefix by placing in temp
   TempOid.idLength = Oid->idLength - MIB_PREFIX_LEN;
   TempOid.ids      = &Oid->ids[MIB_PREFIX_LEN];

   // Get pointer into MIB
   pResult = MIB_HashLookup( &TempOid );

   // Check for possible table entry
   if ( pResult == NULL )
      {
      for ( I=0;I < MIB_table_list_size;I++ )
         {
         if ( !SnmpUtilOidNCmp(&TempOid, &MIB_Tables[I]->Oid,
                            MIB_Tables[I]->Oid.idLength) )
            {
            pResult = MIB_Tables[I];
            goto Exit;
            }
         }
      }

Exit:
   return pResult;
} // MIB_get_entry



//
// MakeOidFromStr
//    Makes an OID out of string so a table can be indexed.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
SNMPAPI MakeOidFromStr(
           IN AsnDisplayString *Str,    // String to make OID
           OUT AsnObjectIdentifier *Oid // Resulting OID
           )

{
UINT    I;
SNMPAPI nResult;


   if ( NULL == (Oid->ids = SnmpUtilMemAlloc((Str->length+1) * sizeof(UINT))) )
      {
      nResult = SNMP_MEM_ALLOC_ERROR;
      goto Exit;
      }

   // Place length as first OID sub-id
   Oid->ids[0] = Str->length;

   // Place each character of string as sub-id
   for ( I=0;I < Str->length;I++ )
      {
      Oid->ids[I+1] = Str->stream[I];
      }

   Oid->idLength = Str->length + 1;


Exit:
   return nResult;
} // MakeOidFromStr

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\mib.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mib.h

Abstract:

    LAN Manager MIB constants, types, and prototypes for implementing the LM
    MIB and its support functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef mib_h
#define mib_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>
#include <snmputil.h>

   // MIB Specifics
#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength
#define MIB_TABLE                 0xe0   // High 3 bits not used by ASN
#define MIB_SRVC_NAME_LEN         15
#define MIB_SESS_CLIENT_NAME_LEN  15
#define MIB_SESS_USER_NAME_LEN    20
#define MIB_USER_NAME_LEN         20
#define MIB_SHARE_NAME_LEN        12
#define MIB_PRINTQ_NAME_LEN       12
#define MIB_USES_LOCAL_NAME_LEN   8
#define MIB_USES_REMOTE_LEN       255
#define MIB_DOM_OTHER_NAME_LEN    15
#define MIB_DOM_SERVER_NAME_LEN   15
#define MIB_DOM_LOGON_USER        20
#define MIB_DOM_LOGON_MACHINE     15


   // Start positions in MIB of first leaf of each group
#define MIB_COM_START          2
#define MIB_SV_START           10
#define MIB_WKSTA_START        45
#define MIB_DOM_START          55


   // MIB Node types
#define MIB_AGGREGATE          (MIB_TABLE | 0x0f)

   // MIB function actions
#define MIB_ACTION_GET         ASN_RFC1157_GETREQUEST
#define MIB_ACTION_SET         ASN_RFC1157_SETREQUEST
#define MIB_ACTION_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_ACTION_GETFIRST    (MIB_TABLE | 0x00)
//#define MIB_ACTION_MATCH       (MIB_TABLE | 0x01)

   // MIB Variable access privileges
#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_ACCESS_NOT         3

   // MIB Variable status
#define MIB_STATUS_MANDATORY   0

   // LM operations -- COMMON group
#define MIB_LM_COMVERSIONMAJ          0
#define MIB_LM_COMVERSIONMIN          1
#define MIB_LM_COMTYPE                2
#define MIB_LM_COMSTATSTART           3
#define MIB_LM_COMSTATNUMNETIOS       4
#define MIB_LM_COMSTATFINETIOS        5
#define MIB_LM_COMSTATFCNETIOS        6

   // LM operations -- SERVER group
#define MIB_LM_SVDESCRIPTION          7
#define MIB_LM_SVSVCNUMBER            8
#define MIB_LM_SVSVCTABLE             9
#define MIB_LM_SVSVCENTRY             10
#define MIB_LM_SVSTATOPENS            16
#define MIB_LM_SVSTATDEVOPENS         17
#define MIB_LM_SVSTATQUEUEDJOBS       18
#define MIB_LM_SVSTATSOPENS           19
#define MIB_LM_SVSTATERROROUTS        20
#define MIB_LM_SVSTATPWERRORS         21
#define MIB_LM_SVSTATPERMERRORS       22
#define MIB_LM_SVSTATSYSERRORS        23
#define MIB_LM_SVSTATSENTBYTES        24
#define MIB_LM_SVSTATRCVDBYTES        25
#define MIB_LM_SVSTATAVRESPONSE       26
#define MIB_LM_SVSECURITYMODE         27
#define MIB_LM_SVUSERS                28
#define MIB_LM_SVSTATREQBUFSNEEDED    29
#define MIB_LM_SVSTATBIGBUFSNEEDED    30
#define MIB_LM_SVSESSIONNUMBER        31
#define MIB_LM_SVSESSIONTABLE         32
#define MIB_LM_SVSESSIONENTRY         33
#define MIB_LM_SVAUTODISCONNECTS      42
#define MIB_LM_SVDISCONTIME           43
#define MIB_LM_SVAUDITLOGSIZE         44
#define MIB_LM_SVUSERNUMBER           45
#define MIB_LM_SVUSERTABLE            46
#define MIB_LM_SVUSERENTRY            47
#define MIB_LM_SVSHARENUMBER          49
#define MIB_LM_SVSHARETABLE           50
#define MIB_LM_SVSHAREENTRY           51
#define MIB_LM_SVPRINTQNUMBER         55
#define MIB_LM_SVPRINTQTABLE          56
#define MIB_LM_SVPRINTQENTRY          57

   // LM operations -- WORKSTATION group
#define MIB_LM_WKSTASTATSESSSTARTS    60
#define MIB_LM_WKSTASTATSESSFAILS     61
#define MIB_LM_WKSTASTATUSES          62
#define MIB_LM_WKSTASTATUSEFAILS      63
#define MIB_LM_WKSTASTATAUTORECS      64
#define MIB_LM_WKSTAERRORLOGSIZE      65
#define MIB_LM_WKSTAUSENUMBER         66
#define MIB_LM_WKSTAUSETABLE          67
#define MIB_LM_WKSTAUSEENTRY          68

   // LM operations -- DOMAIN group
#define MIB_LM_DOMPRIMARYDOMAIN       72
#define MIB_LM_DOMLOGONDOMAIN         73
#define MIB_LM_DOMOTHERDOMAINNUMBER   74
#define MIB_LM_DOMOTHERDOMAINTABLE    75
#define MIB_LM_DOMOTHERDOMAINENTRY    76
#define MIB_LM_DOMOTHERNAME           77
#define MIB_LM_DOMSERVERNUMBER        78
#define MIB_LM_DOMSERVERTABLE         79
#define MIB_LM_DOMSERVERENTRY         80
#define MIB_LM_DOMLOGONNUMBER         82
#define MIB_LM_DOMLOGONTABLE          83
#define MIB_LM_DOMLOGONENTRY          84

   // Table matching constants
#define MIB_TBL_POS_FOUND    0
#define MIB_TBL_POS_BEFORE   -1
#define MIB_TBL_POS_END      -2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // MIB generic data type
typedef ULONG LDATA;

   // MIB variable definition
typedef struct mib_entry
           {
	   AsnObjectIdentifier Oid;
	   BYTE                Type;
	   UINT                Access;
	   UINT                Status;
	   int                 Leaf;
           void *              (*LMFunc)( UINT, LDATA, void * );
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   UINT                LMData;
	   struct mib_entry    *MibNext;
	   } MIB_ENTRY;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

   // Internal MIB structure
extern MIB_ENTRY Mib[];
extern UINT      MIB_num_variables;

   // Prefix to every variable in the LM MIB
extern AsnObjectIdentifier MIB_OidPrefix;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

MIB_ENTRY *MIB_get_entry(
              IN AsnObjectIdentifier *Oid
	      );

SNMPAPI MakeOidFromStr(
	   IN AsnDisplayString *Str,    // String to make OID
           OUT AsnObjectIdentifier *Oid // Resulting OID
	   );

//------------------------------- END ---------------------------------------

#endif /* mib_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\odom_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    odom_tbl.h

Abstract:

    Define the structures and routines used in the other domain table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef odom_tbl_h
#define odom_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define ODOM_NAME_FIELD        1

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the other domain table
typedef struct dom_other_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString domOtherName;
	   } DOM_OTHER_ENTRY;

   // Other domain table definition
typedef struct
           {
	   UINT            Len;
	   DOM_OTHER_ENTRY *Table;
           } DOM_OTHER_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern DOM_OTHER_TABLE  MIB_DomOtherDomainTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_odoms_lmget(
           void
	   );

int MIB_odoms_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_odoms_lmset(
        IN AsnObjectIdentifier *Index,
	IN UINT Field,
	IN AsnAny *Value
	);

//------------------------------- END ---------------------------------------

#endif /* odom_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\mibfuncs.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibfuncs.h

Abstract:

    All constants, types, and prototypes to support the MIB manipulation
    functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef mibfuncs_h
#define mibfuncs_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#include "mib.h"

//--------------------------- PUBLIC STRUCTS --------------------------------

// Return type from LAN Manager conver functions
typedef struct lan_return_info_type {

	unsigned int size ;
	unsigned int data_element_type;
	union {
		AsnInteger intval;
		AsnOctetString octstrval;
	} d ;
} lan_return_info_type ;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

void * MIB_common_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,  // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

void * MIB_server_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,    // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

void * MIB_workstation_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,    // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

void * MIB_domain_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,    // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

UINT MIB_srvcs_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_sess_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_users_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_shares_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_prntq_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_wsuses_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_odoms_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_svsond_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_dlogons_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_leaf_func(
        IN UINT Action,
	IN MIB_ENTRY *MibPtr,
	IN RFC1157VarBind *VarBind
	);

//
// Prototype for AdminFilter function
//

VOID
AdminFilter(
    DWORD           Level,
    LPDWORD         pEntriesRead,
    LPBYTE          ShareInfo
    );

//------------------------------- END ---------------------------------------

#endif /* mibfuncs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\odom_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    odom_tbl.c

Abstract:

    Routines supporting operations on the Other Domain Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "odom_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Other Domain table
static UINT                odomSubids[] = { 4, 4, 1 };
static AsnObjectIdentifier MIB_DomOtherDomainPrefix = { 3, odomSubids };

DOM_OTHER_TABLE  MIB_DomOtherDomainTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define ODOM_FIELD_SUBID       (MIB_DomOtherDomainPrefix.idLength + \
                                MIB_OidPrefix.idLength)

#define ODOM_FIRST_FIELD       ODOM_NAME_FIELD
#define ODOM_LAST_FIELD        ODOM_NAME_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_odoms_get(
        IN OUT RFC1157VarBind *VarBind
	);

UINT MIB_odoms_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_odoms_func
//    High level routine for handling operations on the Other Domain table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_odoms_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Other Domain table with the info from server
         if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_DomOtherDomainTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { ODOM_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };


         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainTable.Table[0].Oid );
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_odoms_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Other Domain Table with the info from server
         if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[ODOM_FIELD_SUBID];

         // Lookup OID in table
         if (Field < ODOM_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = ODOM_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > ODOM_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_odoms_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_DomOtherDomainTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > ODOM_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_DomOtherDomainTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > ODOM_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainTable.Table[Entry].Oid );
         }

         ErrStat = MIB_odoms_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         // Make sure OID is long enough
	 if ( ODOM_FIELD_SUBID + 1 > VarBind->name.idLength )
            {
	    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	    goto Exit;
	    }

	 // Get field number
	 Field = VarBind->name.ids[ODOM_FIELD_SUBID];

	 // If the field being set is not the NAME field, error
	 if ( Field != ODOM_NAME_FIELD )
	    {
	    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
	    }

         // Check for proper type before setting
         if ( ASN_RFC1213_DISPSTRING != VarBind->value.asnType )
	    {
	    ErrStat = SNMP_ERRORSTATUS_BADVALUE;
	    goto Exit;
	    }

	 // Call LM set routine
	 ErrStat = MIB_odoms_lmset( &VarBind->name, Field, &VarBind->value );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_odoms_func



//
// MIB_odoms_get
//    Retrieve Other Domain Table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_odoms_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[ODOM_FIELD_SUBID] < ODOM_FIRST_FIELD ||
       VarBind->name.ids[ODOM_FIELD_SUBID] > ODOM_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }
   
   // Fill the Other Domain Table with the info from server
   if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_odoms_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_odoms_copyfromtable( Entry,
                                      VarBind->name.ids[ODOM_FIELD_SUBID],
                                      VarBind );

Exit:
   return ErrStat;
} // MIB_odoms_get



//
// MIB_odoms_match
//    Match the target OID with a location in the Other Domain Table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_odoms_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_DomOtherDomainPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_DomOtherDomainPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_DomOtherDomainTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_DomOtherDomainTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_odoms_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_odoms_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case ODOM_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_DomOtherDomainTable.Table[Entry].domOtherName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomOtherDomainTable.Table[Entry].domOtherName.stream,
                       MIB_DomOtherDomainTable.Table[Entry].domOtherName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomOtherDomainTable.Table[Entry].domOtherName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Other Domain Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_odoms_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\prnt_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    prnt_tbl.h

Abstract:

    Print Queue Table processing routine and structure definitions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef prnt_tbl_h
#define prnt_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define PRNTQ_NAME_FIELD       1
#define PRNTQ_JOBS_FIELD       2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the print queue table
typedef struct printq_entry
           {
           AsnObjectIdentifier Oid;
	   AsnDisplayString svPrintQName;    // Index
	   AsnInteger       svPrintQNumJobs;
	   }  PRINTQ_ENTRY;

   // Print Queue table definition
typedef struct
           {
	   UINT         Len;
	   PRINTQ_ENTRY *Table;
           } PRINTQ_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern PRINTQ_TABLE     MIB_PrintQTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_prntq_lmget(
           void
           );

//------------------------------- END ---------------------------------------

#endif /* prnt_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\mibfuncs.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibfuncs.c

Abstract:

    Contains MIB functions for GET's and SET's for LM MIB.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef DOS
#if 0
#define INCL_NETWKSTA
#define INCL_NETERRORS
#include <lan.h>
#endif
#endif

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>
//---ft:07/13---LsaGetUserName substitutes NetWkstaGetUserInfo
#include <subauth.h>    // needed for the definition of PUNICODE_STRING
#include <ntlsa.h>      // LSA APIs
//---tf---
#include "mib.h"
#include "lmcache.h"


//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "mibfuncs.h"
#include "odom_tbl.h"
#include "user_tbl.h"
#include "shar_tbl.h"
#include "srvr_tbl.h"
#include "prnt_tbl.h"
#include "uses_tbl.h"


//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

void  * MIB_common_func(
           IN UINT Action,  // Action to perform on Data
           IN LDATA LMData, // LM Data to manipulate
           IN void *SetData
           )

{
SNMPAPI nResult;
unsigned lmCode;
WKSTA_INFO_101 *wksta_info_one;
SERVER_INFO_102 *server_info_two;
STAT_SERVER_0 *server_stats_zero;
STAT_WORKSTATION_0 *wrk_stats_zero;
LPBYTE bufptr;
lan_return_info_type *retval=NULL;
BYTE *stream;
char temp[80];
BOOL cache_it ;
time_t curr_time ;

UNREFERENCED_PARAMETER(SetData);

   time(&curr_time);    // get the time

   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {
            case MIB_LM_COMVERSIONMAJ:

              if((NULL == cache_table[C_NETWKSTAGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETWKSTAGETINFO].bufptr ) ;
                //
                lmCode =
                NetWkstaGetInfo( NULL,                  // local server
                                101,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       wksta_info_one = (WKSTA_INFO_101 *) bufptr ;
                       _itoa(wksta_info_one->wki101_ver_major,temp,10) ;
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( strlen(temp) ))
                       )  {
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }
                       memcpy(stream,&temp,strlen(temp));
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = strlen(temp);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
               }
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_COMVERSIONMAJ.\n" ));
               break;

            case MIB_LM_COMVERSIONMIN:

              if((NULL == cache_table[C_NETWKSTAGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETWKSTAGETINFO].bufptr ) ;
                //
               lmCode =
               NetWkstaGetInfo( NULL,                   // local server
                                101,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       wksta_info_one = (WKSTA_INFO_101 *) bufptr ;
                       _itoa(wksta_info_one->wki101_ver_minor,temp,10) ;
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( strlen(temp) ))
                       ){
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }
                       memcpy(stream,&temp,strlen(temp));
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = strlen(temp);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_COMVERSIONMIN.\n" ));
               break;

            case MIB_LM_COMTYPE:
              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr ) ;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       server_info_two = (SERVER_INFO_102 *) bufptr ;
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( 4 * sizeof(BYTE) ))
                       ){
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }
                       *(DWORD*)stream=server_info_two->sv102_type & 0x000000FF;
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = 4 * sizeof(BYTE);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_COMTYPE.\n" ));
               break;

            case MIB_LM_COMSTATSTART:
              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr);

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_start;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATSTART.\n" ));
               break;

            case MIB_LM_COMSTATNUMNETIOS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval =
                  (wrk_stats_zero->SmbsReceived).LowPart +
                          (wrk_stats_zero->SmbsTransmitted).LowPart;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATNUMNETIOS.\n" ));
               break;

            case MIB_LM_COMSTATFINETIOS:


              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->InitiallyFailedOperations;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATFINETIOS.\n" ));
               break;

            case MIB_LM_COMSTATFCNETIOS:


              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->FailedCompletionOperations;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)

               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATFCNETIOS.\n" ));
               break;

            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;

      case MIB_ACTION_SET:
         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }

Exit:
   return retval /*nResult*/;
} // MIB_common_func

void  * MIB_server_func(
           IN UINT Action,  // Action to perform on Data
           IN LDATA LMData, // LM Data to manipulate
           IN void *SetData
           )

{

lan_return_info_type *retval=NULL;
SERVER_INFO_102 *server_info_two;
SERVER_INFO_102 server_info_10two;
STAT_SERVER_0 *server_stats_zero;
SERVER_INFO_102 *server_info_102 ;
SERVER_INFO_403 *server_info_four ;
SESSION_INFO_2 * session_info_two;
SERVER_INFO_402 *server_info_402 ;
#if 1
USER_INFO_0 *user_info_zero ;
#endif
unsigned lmCode;
BYTE *stream;
AsnOctetString *strvalue;
AsnInteger intvalue;
DWORD entriesread;
DWORD totalentries;
SNMPAPI nResult;
LPBYTE bufptr;
BOOL cache_it ;
time_t curr_time ;
#ifdef UNICODE
LPWSTR unitemp ;
#endif

   time(&curr_time);    // get the time

   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {

        case MIB_LM_SVDESCRIPTION:
              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr );

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       server_info_two = (SERVER_INFO_102 *) bufptr ;

                       #ifdef UNICODE
                                if (SnmpUtilUnicodeToUTF8(
                                        &stream,
                                        server_info_two->sv102_comment,
                                        TRUE))
                                {
                                    SnmpUtilMemFree(retval);
                                    retval = NULL;
                                    goto Exit;
                                }
                       #else
                               if(NULL ==
                                (stream = SnmpUtilMemAlloc( strlen(server_info_two->sv102_comment) + 1 ))
                               ) {
                                  SnmpUtilMemFree(retval);
                                  retval=NULL;
                                  goto Exit ;
                               }

                                memcpy(stream,server_info_two->sv102_comment,
                                        strlen(server_info_two->sv102_comment));
                       #endif
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length =
                                strlen(stream);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVDESCRIPTION.\n" ));
               break;


                case MIB_LM_SVSVCNUMBER:

              if((NULL == cache_table[C_NETSERVICEENUM].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVICEENUM].acquisition_time
                         + cache_expire[C_NETSERVICEENUM]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVICEENUM].bufptr) ;

               lmCode =
               NetServiceEnum( NULL,                    // local server
                                0,                      // level 0
                                &bufptr,                        // data structure to return
                                MAX_PREFERRED_LENGTH,
                                &entriesread,
                                &totalentries,
                                NULL);
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVICEENUM].bufptr ;
                totalentries =  cache_table[C_NETSERVICEENUM].totalentries ;
                entriesread =  cache_table[C_NETSERVICEENUM].entriesread ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       retval->d.intval = totalentries; // LOOK OUT!!
                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVICEENUM].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVICEENUM].bufptr = bufptr ;
                                cache_table[C_NETSERVICEENUM].totalentries =
                                                totalentries ;
                                cache_table[C_NETSERVICEENUM].entriesread =
                                                entriesread ;
                        } // if (cache_it)
               }


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSVCNUMBER.\n" ));
               break;


                case MIB_LM_SVSTATOPENS:


              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_fopens;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)

               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATOPENS.\n" ));
               break;


                case MIB_LM_SVSTATDEVOPENS:



              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_devopens;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATDEVOPENS.\n" ));
               break;

                case MIB_LM_SVSTATQUEUEDJOBS:



              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_jobsqueued;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATQUEUEDJOBS.\n" ));
               break;

                case MIB_LM_SVSTATSOPENS:


              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_sopens;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSOPENS.\n" ));
               break;

                case MIB_LM_SVSTATERROROUTS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_serrorout;
                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSERROROUTS.\n" ));
               break;

                case MIB_LM_SVSTATPWERRORS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_pwerrors;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATPWERRORS.\n" ));
               break;

                case MIB_LM_SVSTATPERMERRORS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_permerrors;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATPERMERRORS.\n" ));
               break;

                case MIB_LM_SVSTATSYSERRORS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_syserrors;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSYSERRORS.\n" ));
               break;

                case MIB_LM_SVSTATSENTBYTES:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_bytessent_low;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSENTBYTES.\n" ));
               break;

                case MIB_LM_SVSTATRCVDBYTES:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_bytesrcvd_low;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATRCVDBYTES.\n" ));
               break;

                case MIB_LM_SVSTATAVRESPONSE:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_avresponse;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATAVRESPONSE.\n" ));
               break;

         case MIB_LM_SVSECURITYMODE:

             // hard code USER security per dwaink
             //
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       retval->d.intval = 2 ;

#if 0
              if((NULL == cache_table[C_NETSERVERGETINFO_403].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO_403].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO_403]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO_403].bufptr) ;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                403,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO_403].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_four = (SERVER_INFO_403 *) bufptr ;
                       retval->d.intval = server_info_four->sv403_security;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO_403].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO_403].bufptr = bufptr ;
                        } // if (cache_it)
               }
#endif
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSECURITYMODE.\n" ));
               break;



                case MIB_LM_SVUSERS:

              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr) ;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_102 = (SERVER_INFO_102 *) bufptr ;
                       retval->d.intval = server_info_102->sv102_users;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVUSERS.\n" ));
               break;

                case MIB_LM_SVSTATREQBUFSNEEDED:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_reqbufneed;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATREQBUFSNEEDED.\n" ));
               break;

                case MIB_LM_SVSTATBIGBUFSNEEDED:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_bigbufneed;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATBIGBUFNEEDED.\n" ));
               break;

                case MIB_LM_SVSESSIONNUMBER:

              if((NULL == cache_table[C_NETSESSIONENUM].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSESSIONENUM].acquisition_time
                         + cache_expire[C_NETSESSIONENUM]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSESSIONENUM].bufptr) ;

               lmCode =
               NetSessionEnum(  NULL,                   // local server
                                NULL,           // get server stats
                                NULL,
                                2,                      // level
                                &bufptr,                // data structure to return
                                MAX_PREFERRED_LENGTH,
                                &entriesread,
                                &totalentries,
                                NULL                    // no resume handle
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSESSIONENUM].bufptr ;
                totalentries =  cache_table[C_NETSESSIONENUM].totalentries ;
                entriesread =  cache_table[C_NETSESSIONENUM].entriesread ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       session_info_two = (SESSION_INFO_2 *) bufptr ;
                       retval->d.intval = totalentries;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSESSIONENUM].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSESSIONENUM].bufptr = bufptr ;
                                cache_table[C_NETSESSIONENUM].totalentries =
                                                totalentries ;
                                cache_table[C_NETSESSIONENUM].entriesread =
                                                entriesread ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSESSIONNUMBER.\n" ));
               break;

                case MIB_LM_SVAUTODISCONNECTS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr);

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_stimedout;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATAUTODISCONNECT.\n" ));
               break;

                case MIB_LM_SVDISCONTIME:

              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr) ;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_102 = (SERVER_INFO_102 *) bufptr ;
                       retval->d.intval = server_info_102->sv102_disc ;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVDISCONTIME.\n" ));
               break;

                case MIB_LM_SVAUDITLOGSIZE:


            {
                HANDLE hEventLog;
                DWORD  cRecords;

                hEventLog = OpenEventLog( NULL,
                                          TEXT("APPLICATION"));
                    if(NULL ==
                       (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                    retval->data_element_type = ASN_INTEGER ;
                if(GetNumberOfEventLogRecords( hEventLog, &cRecords )){

                       retval->d.intval = cRecords ;
                } else {
                       retval->d.intval = 0 ;
                }
                DeregisterEventSource( hEventLog );
            }
#if 0
              if((NULL == cache_table[C_NETSERVERGETINFO_402].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO_402].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO_402]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO_402].bufptr) ;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                402,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO_402].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_402 = (SERVER_INFO_402 *) bufptr ;
                       retval->d.intval = server_info_402->sv402_maxauditsz ;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO_402].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO_402].bufptr = bufptr ;
                        } // if (cache_it)
                }
#endif
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVAUDITLOGSIZE.\n" ));
               break;


                case MIB_LM_SVUSERNUMBER:



                MIB_users_lmget();   // fire off the table get
                if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_UserTable.Len;

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVUSERNUMBER.\n" ));
               break;


                case MIB_LM_SVSHARENUMBER:


                MIB_shares_lmget();   // fire off the table get
                if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ) )
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_ShareTable.Len;


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSHARENUMBER.\n" ));
               break;


        case MIB_LM_SVPRINTQNUMBER:

                MIB_prntq_lmget();   // fire off the table get
                if(NULL ==
                    (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_PrintQTable.Len;


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_PRINTQNUMBER.\n" ));
               break;



            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;

      case MIB_ACTION_SET:
         switch ( LMData )
            {

        case MIB_LM_SVDESCRIPTION:

                // retrieve string to be written
                strvalue = (AsnOctetString *) SetData ;

                // convert it to zero terminated string
                stream = SnmpUtilMemAlloc( strvalue->length+1 );
                if (stream == NULL) {
                    retval = (void *) FALSE;
                    break;
                }
                memcpy(stream,strvalue->stream,strvalue->length);
                stream[strvalue->length] = 0;

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "LMMIB2: changing server description to %s.\n",
                    stream
                    ));

                #ifdef UNICODE
                if (SnmpUtilUTF8ToUnicode(&unitemp,
                                          stream,
                                          TRUE
                                          )) {
                    SnmpUtilMemFree(stream);
                    retval = (void *) FALSE;
                    break;
                }
                SnmpUtilMemFree(stream);
                stream = (LPBYTE)unitemp;
                #endif

                lmCode = NetServerSetInfo(
                                NULL,                   // this server
                                SV_COMMENT_INFOLEVEL,   // level
                                (LPBYTE)&stream,        // data
                                NULL );                 // option

                SnmpUtilMemFree(stream);

                if(NERR_Success == lmCode) {

                        retval = (void *) TRUE;
                        cache_table[C_NETSERVERGETINFO].acquisition_time = 0;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "LMMIB2: server description changed, invalidating cache.\n"
                            ));

                } else {

                        retval = (void *) FALSE;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "LMMIB2: server description not changed 0x%08lx.\n",
                            lmCode
                            ));
                }
                break ;

        case MIB_LM_SVDISCONTIME:

                intvalue = (AsnInteger)((ULONG_PTR) SetData) ;
                memset(&server_info_10two,0,sizeof(server_info_10two));
                server_info_10two.sv102_disc = intvalue ;
                lmCode = NetServerSetInfo(
                                NULL,                   // this server
                                SV_DISC_INFOLEVEL,                      // level
                                (LPBYTE)&server_info_10two,     // data
                                NULL );                 // option
                if(NERR_Success == lmCode) {
                        retval = (void *)TRUE;
                } else {
                        retval = (void *) FALSE;
                }
                break ;

        case MIB_LM_SVAUDITLOGSIZE:

                retval =  (void *) FALSE;
                break ;

            }  // switch(LMData)

         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }

Exit:
   return retval /*nResult*/;
} // MIB_server_func

void  * MIB_workstation_func(
           IN UINT Action,   // Action to perform on Data
           IN LDATA LMData,    // LM Data to manipulate
           IN void *SetData
           )

{

SNMPAPI nResult;
unsigned lmCode;
STAT_WORKSTATION_0 *wrk_stats_zero;
WKSTA_INFO_502 *wksta_info_five;
LPBYTE bufptr;
lan_return_info_type *retval=NULL;
DWORD entriesread;
DWORD totalentries;
BOOL cache_it ;
time_t curr_time ;


UNREFERENCED_PARAMETER(SetData);
   time(&curr_time);    // get the time

   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {

                case MIB_LM_WKSTASTATSESSSTARTS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //

                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->Sessions;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATSESSSTARTS.\n" ));
               break;


                case MIB_LM_WKSTASTATSESSFAILS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->FailedSessions;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATSESSFAILS.\n" ));
               break;

                case MIB_LM_WKSTASTATUSES:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->UseCount;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATUSES.\n" ));
               break;

                case MIB_LM_WKSTASTATUSEFAILS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->FailedUseCount;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATUSEFAILS.\n" ));
               break;

                case MIB_LM_WKSTASTATAUTORECS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->Reconnects;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATAUTORECS.\n" ));
               break;

                case MIB_LM_WKSTAERRORLOGSIZE:

              if((NULL == cache_table[C_NETWKSTAGETINFO_502].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO_502].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO_502]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETWKSTAGETINFO_502].bufptr) ;

               lmCode =
               NetWkstaGetInfo( NULL,                   // local server
                                502,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO_502].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wksta_info_five = (WKSTA_INFO_502 *) bufptr ;
                       retval->d.intval =
                           wksta_info_five->wki502_maximum_collection_count ;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO_502].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO_502].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTAERRORLOGSIZE.\n" ));
               break;


                case MIB_LM_WKSTAUSENUMBER:

                MIB_wsuses_lmget();   // fire off the table get
                if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_WkstaUsesTable.Len;


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTAUSENUMBER.\n" ));
               break;

            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;


      case MIB_ACTION_SET:
         switch ( LMData )
            {

                case MIB_LM_WKSTAERRORLOGSIZE:
                        ;
            }

         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }

Exit:
   return retval /*nResult*/;
}

void  * MIB_domain_func(
           IN UINT Action,   // Action to perform on Data
           IN LDATA LMData,  // LM Data to manipulate
           void *SetData
           )

{


SNMPAPI nResult;
unsigned lmCode;
WKSTA_INFO_101 *wksta_info_one;
LPBYTE bufptr;
lan_return_info_type *retval=NULL;
DWORD entriesread;
DWORD totalentries;
BYTE *stream;
BOOL cache_it ;
time_t curr_time ;

UNREFERENCED_PARAMETER(SetData);
   time(&curr_time);    // get the time


   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {

                case MIB_LM_DOMPRIMARYDOMAIN:

              if((NULL == cache_table[C_NETWKSTAGETINFO_101].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO_101].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO_101]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETWKSTAGETINFO_101].bufptr) ;

               lmCode =
               NetWkstaGetInfo( NULL,                   // local server
                                101,                    // level 101,
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO_101].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       wksta_info_one = (WKSTA_INFO_101 *) bufptr ;
#ifdef UNICODE
                       if (SnmpUtilUnicodeToUTF8(
                                        &stream,
                                        wksta_info_one->wki101_langroup,
                                        TRUE))
                       {
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }
#else
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( strlen(wksta_info_one->wki101_langroup)+2 ))){
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }

                       memcpy(stream,
                                        wksta_info_one->wki101_langroup,
                                        strlen(wksta_info_one->wki101_langroup));
#endif
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = strlen(stream);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO_101].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO_101].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMPRIMARYDOMAIN.\n" ));
               break;

               case MIB_LM_DOMLOGONDOMAIN:
              if((NULL == cache_table[C_NETWKSTAUSERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAUSERGETINFO].acquisition_time
                         + cache_expire[C_NETWKSTAUSERGETINFO]              ) ) )
              {
                // it has expired!
                PLSA_UNICODE_STRING logonUserName, logonDomainName;

                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETWKSTAUSERGETINFO].bufptr) ;
                logonUserName = logonDomainName = NULL;

                // sensible point. Hard to get a call that is returning the logonDomainName:
                // NetWkstaUserGetInfo() is returning NO_LOGON_SESSION (for level 1)
                // LsaGetUserName() is returning inaccurate info when running from service controller.
                lmCode = LsaGetUserName( &logonUserName, &logonDomainName);

                SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: got '%c'\n", (LPBYTE)(logonDomainName->Buffer)[0] ));
                if (lmCode == 0)
                    bufptr = (LPBYTE)logonDomainName->Buffer;
                cache_it = TRUE ;
              }
              else
              {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAUSERGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  
              {
                  // valid so return it, otherwise error NULL
                  if(NULL == (retval = SnmpUtilMemAlloc(sizeof(lan_return_info_type))) )
                          goto Exit ;
                  retval->data_element_type = ASN_OCTETSTRING ;
#ifdef UNICODE
                  if (SnmpUtilUnicodeToUTF8(
                    &stream,
                    (LPWSTR)bufptr,
                    TRUE))
                  {
                      SnmpUtilMemFree(retval);
                      retval=NULL;
                      goto Exit ;
                  }
#else
                  if(NULL == (stream = SnmpUtilMemAlloc(strlen((LPWSTR)bufptr)+2)) )
                  {
                      SnmpUtilMemFree(retval);
                      retval=NULL;
                      goto Exit ;
                  }

                  memcpy(stream,
                         bufptr,
                         strlen(bufptr));
#endif
                  retval->d.octstrval.stream = stream;
                  retval->d.octstrval.length = strlen(stream);
                  retval->d.octstrval.dynamic = TRUE;

                  if(cache_it)
                  {
                    // now save it in the cache
                    cache_table[C_NETWKSTAUSERGETINFO].acquisition_time = curr_time ;
                    cache_table[C_NETWKSTAUSERGETINFO].bufptr = bufptr ;
                  } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMLOGONDOMAIN.\n" ));
               break;


               case MIB_LM_DOMOTHERDOMAINNUMBER:

               MIB_odoms_lmget();   // fire off the table get
               if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
               retval->data_element_type = ASN_INTEGER ;
               retval->d.intval = MIB_DomOtherDomainTable.Len;

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMOTHERDOMAINNUMBER.\n" ));
               break;


               case MIB_LM_DOMSERVERNUMBER:

               MIB_svsond_lmget();   // fire off the table get
                
               if(NULL ==
                  (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
               retval->data_element_type = ASN_INTEGER ;
               retval->d.intval = MIB_DomServerTable.Len;

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMSERVERNUMBER.\n" ));
               break;


//
// OPENISSUE --> NETLOGONENUM permanently eliminated
//
#if 0
// did some  of these guys get lost ???
// double check there is a mistake in the mib table
//
               case MIB_LM_DOMLOGONNUMBER:
               case MIB_LM_DOMLOGONTABLE:
               case MIB_LM_DOMLOGONENTRY:
               case MIB_LM_DOMLOGONUSER:
               case MIB_LM_DOMLOGONMACHINE:
#endif
            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;

      case MIB_ACTION_SET:
         switch ( LMData )
            {
                case MIB_LM_DOMOTHERNAME:
                        ;
            }
         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }

Exit:
   return retval /*nResult*/;
}



//
// MIB_leaf_func
//    Performs actions on LEAF variables in the MIB.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_leaf_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
lan_return_info_type *MibVal;
UINT                 nResult;

   switch ( Action )
      {
      case MIB_ACTION_GETNEXT:
         if ( MibPtr->MibNext == NULL )
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         nResult = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                MibPtr->MibNext, VarBind );
         break;

      case MIB_ACTION_GETFIRST:

         // Check to see if this variable is accessible for GET
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
            {
            if ( MibPtr->MibNext != NULL )
               {
               nResult = (*MibPtr->MibNext->MibFunc)( Action,
                                                      MibPtr->MibNext,
                                                      VarBind );
               }
            else
               {
               nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
               }

            break;
            }
         else
            {
            // Place correct OID in VarBind
            SnmpUtilOidFree( &VarBind->name );
            SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
            SnmpUtilOidAppend( &VarBind->name, &MibPtr->Oid );
            }

         // Purposefully let fall through to GET

      case MIB_ACTION_GET:
         // Make sure that this variable is GET'able
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Call the LM call to get data
         MibVal = (*MibPtr->LMFunc)( MIB_ACTION_GET, MibPtr->LMData, NULL );
         if ( MibVal == NULL )
            {
            nResult = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Setup varbind's return value
         VarBind->value.asnType = MibPtr->Type;
         switch ( MibPtr->Type )
            {
            case ASN_RFC1155_COUNTER:
            case ASN_RFC1155_GAUGE:
            case ASN_RFC1155_TIMETICKS:
            case ASN_INTEGER:
               VarBind->value.asnValue.number = MibVal->d.intval;
               break;

            case ASN_RFC1155_IPADDRESS:
            case ASN_RFC1155_OPAQUE:
            case ASN_OCTETSTRING:
               // This is non-standard copy of structure
               VarBind->value.asnValue.string = MibVal->d.octstrval;
               break;

            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Processing LAN Manager LEAF Variable\n" ));
               nResult = SNMP_ERRORSTATUS_GENERR;
               SnmpUtilMemFree( MibVal );
               goto Exit;
            } // type switch

         // Free memory alloc'ed by LM API call
         SnmpUtilMemFree( MibVal );
         nResult = SNMP_ERRORSTATUS_NOERROR;
         break;

      case MIB_ACTION_SET:
         // Check for writable attribute
         if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
              MibPtr->Access != MIB_ACCESS_WRITE )
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Check for proper type before setting
         if ( MibPtr->Type != VarBind->value.asnType )
            {
            nResult = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
            }

         // Call LM routine to set variable
         switch ( VarBind->value.asnType )
            {
            case ASN_RFC1155_COUNTER:
            case ASN_INTEGER:
               if ( SNMPAPI_ERROR ==
                    (*MibPtr->LMFunc)(MIB_ACTION_SET, MibPtr->LMData,
                                      (void *)&VarBind->value.asnValue.number) )
                  {
                  nResult = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
                  }
               break;

            case ASN_OCTETSTRING: // This entails ASN_RFC1213_DISPSTRING also
               if ( SNMPAPI_ERROR ==
                    (*MibPtr->LMFunc)(MIB_ACTION_SET, MibPtr->LMData,
                                      (void *)&VarBind->value.asnValue.string) )
                  {
                  nResult = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
                  }
               break;
            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Processing LAN Manager LEAF Variable\n" ));
               nResult = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
            }

         nResult = SNMP_ERRORSTATUS_NOERROR;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Processing LAN Manager LEAF Variable\n" ));
         nResult = SNMP_ERRORSTATUS_GENERR;
      } // switch

Exit:
   return nResult;
} // MIB_leaf_func

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\odom_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    odom_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the other domains table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>
//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "odom_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

int __cdecl odom_entry_cmp(
       IN const DOM_OTHER_ENTRY *A,
       IN const DOM_OTHER_ENTRY *B
       ) ;

void build_odom_entry_oids( );

int chrcount(char *s)
{
char *temp;
int i;
temp = s;
i = 1;  // assume one since no terminating space, other code counts tokens
while( NULL != (temp = strchr(temp,' ')) ) {
        i++;
        }
return i;
}

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_odoms_lmset
//    Perform the necessary actions to set an entry in the Other Domain Table.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
UINT MIB_odoms_lmset(
        IN AsnObjectIdentifier *Index,
        IN UINT Field,
        IN AsnAny *Value
        )

{
LPBYTE bufptr = NULL;
WKSTA_USER_INFO_1101 ODom;
LPBYTE Temp;
UINT   Entry;
UINT   I;
UINT   ErrStat = SNMP_ERRORSTATUS_NOERROR;
#ifdef UNICODE
LPWSTR unitemp ;
#endif


   // Must make sure the table is in memory
   if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   // See if match in table
   if ( MIB_TBL_POS_FOUND == MIB_odoms_match(Index, &Entry) )
      {
      // If empty string then delete entry
      if ( Value->asnValue.string.length == 0 )
         {
         // Alloc memory for buffer
         bufptr = SnmpUtilMemAlloc( DNLEN * sizeof(char) *
                          (MIB_DomOtherDomainTable.Len-1) +
                          MIB_DomOtherDomainTable.Len-1 );

         // prefix #57351
         if (bufptr == NULL)
            return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            

         // Create the other domain string
         Temp = bufptr;
         for ( I=0;I < MIB_DomOtherDomainTable.Len;I++ )
            {
            if ( I+1 != Entry )
               {
               memcpy( Temp,
                       MIB_DomOtherDomainTable.Table[I].domOtherName.stream,
                       MIB_DomOtherDomainTable.Table[I].domOtherName.length );
               Temp[MIB_DomOtherDomainTable.Table[I].domOtherName.length] = ' ';
               Temp += MIB_DomOtherDomainTable.Table[I].domOtherName.length + 1;
               }
            }
         *(Temp-1) = '\0';
         }
      else
         {
         // Cannot modify the domain entries, so bad value
         ErrStat = SNMP_ERRORSTATUS_BADVALUE;
         goto Exit;
         }
      }
   else
      {
      // Check for addition of NULL string, bad value
      if ( Value->asnValue.string.length == 0 )
         {
         ErrStat = SNMP_ERRORSTATUS_BADVALUE;
         goto Exit;
         }

      //
      // Entry doesn't exist so add it to the list
      //

      // Alloc memory for buffer
      bufptr = SnmpUtilMemAlloc( DNLEN * sizeof(char) *
                       (MIB_DomOtherDomainTable.Len+1) +
                       MIB_DomOtherDomainTable.Len+1 );

      // prefix #57352
      if (bufptr == NULL)
          return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;

      // Create the other domain string
      Temp = bufptr;
      for ( I=0;I < MIB_DomOtherDomainTable.Len;I++ )
         {
         memcpy( Temp, MIB_DomOtherDomainTable.Table[I].domOtherName.stream,
                 MIB_DomOtherDomainTable.Table[I].domOtherName.length );
         Temp[MIB_DomOtherDomainTable.Table[I].domOtherName.length] = ' ';
         Temp += MIB_DomOtherDomainTable.Table[I].domOtherName.length + 1;
         }

      // Add new entry
      memcpy( Temp, Value->asnValue.string.stream,
                    Value->asnValue.string.length );

      // Add NULL terminator
      Temp[Value->asnValue.string.length] = '\0';
      }

   // Set table and check return codes
   #ifdef UNICODE
   SnmpUtilUTF8ToUnicode(         &unitemp,
                                bufptr,
                                TRUE );
   ODom.wkui1101_oth_domains = unitemp;
   #else
   ODom.wkui1101_oth_domains = bufptr;
   #endif
#if 0
   if ( NERR_Success == NetWkstaUserSetInfo(NULL, 1101, (LPBYTE)&ODom, NULL) )
      {
      // Make cache be reloaded next time
      cache_table[C_ODOM_TABLE].bufptr = NULL;
      }
   else
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      }
#else
   ErrStat = SNMP_ERRORSTATUS_GENERR;
#endif

Exit:
   SnmpUtilMemFree( bufptr );

   return ErrStat;
} // MIB_odoms_lmset



//
// MIB_odom_lmget
//    Retrieve print queue table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_odoms_lmget(
           )

{

DWORD totalentries;
LPBYTE bufptr = NULL;
unsigned lmCode;
WKSTA_USER_INFO_1101 *DataTable;
DOM_OTHER_ENTRY *MIB_DomOtherDomainTableElement ;
char *p;
char *next;
time_t curr_time ;
unsigned i;
SNMPAPI nResult = SNMPAPI_NOERROR;



   time(&curr_time);    // get the time


   //
   //
   // If cached, return piece of info.
   //
   //


   if((NULL != cache_table[C_ODOM_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_ODOM_TABLE].acquisition_time
                 + cache_expire[C_ODOM_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit; // the global table is valid

        }

   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //


     //
     // remember to free the existing data
     //

     MIB_DomOtherDomainTableElement = MIB_DomOtherDomainTable.Table ;

     // iterate over the whole table
     for(i=0; i<MIB_DomOtherDomainTable.Len ;i++)
     {
        // free any alloc'ed elements of the structure
        SnmpUtilOidFree(&(MIB_DomOtherDomainTableElement->Oid));
        SafeFree(MIB_DomOtherDomainTableElement->domOtherName.stream);

        MIB_DomOtherDomainTableElement ++ ;  // increment table entry
     }
     SafeFree(MIB_DomOtherDomainTable.Table) ;  // free the base Table
     MIB_DomOtherDomainTable.Table = NULL ;     // just for safety
     MIB_DomOtherDomainTable.Len = 0 ;          // just for safety

     lmCode =
        NetWkstaUserGetInfo(
                        0,                      // required
                        1101,                   // level 0,
                        &bufptr                 // data structure to return
                        );


    DataTable = (WKSTA_USER_INFO_1101 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error
        if(NULL==DataTable->wkui1101_oth_domains) {
                // Prefix #57350
                // free all of the lanman data
                SafeBufferFree( bufptr ) ;
                // Signal error
                nResult = SNMPAPI_ERROR;
                goto Exit;

        } else {  // compute it
        totalentries = chrcount((char *)DataTable->wkui1101_oth_domains);
        if(0 == MIB_DomOtherDomainTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_DomOtherDomainTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(DOM_OTHER_ENTRY) );

                // Prefix #57349
                if (MIB_DomOtherDomainTable.Table == NULL) 
                {
                    // free all of the lanman data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
        }

        MIB_DomOtherDomainTableElement = MIB_DomOtherDomainTable.Table  ;

        // make a pointer to the beginning of the string field

        #ifdef UNICODE
        SnmpUtilUnicodeToUTF8(
                &p,
                DataTable->wkui1101_oth_domains,
                TRUE);
        #else
        p =  DataTable->wkui1101_oth_domains  ;
        #endif

        // scan through the field, making an entry for each space
        // separated domain
        while(  (NULL != p ) &&
                ('\0' != *p)  ) {  // once for each entry in the buffer

                // increment the entry number

                MIB_DomOtherDomainTable.Len ++;

                // find the end of this one
                next = strchr(p,' ');

                // if more to come, ready next pointer and mark end of this one
                if(NULL != next) {
                        *next='\0' ;    // replace space with EOS
                        next++ ;        // point to beginning of next domain
                }


                MIB_DomOtherDomainTableElement->domOtherName.stream = SnmpUtilMemAlloc (
                                strlen( p ) ) ;
                MIB_DomOtherDomainTableElement->domOtherName.length =
                                strlen( p ) ;
                MIB_DomOtherDomainTableElement->domOtherName.dynamic = TRUE;
                memcpy( MIB_DomOtherDomainTableElement->domOtherName.stream,
                        p,
                        strlen( p ) ) ;


                MIB_DomOtherDomainTableElement ++ ;  // and table entry

                DataTable ++ ;  // advance pointer to next sess entry in buffer

            } // while still more to do

        } // if there really were entries
        } // if data is valid to process

    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }


   // free all of the lan man data
   SafeBufferFree( bufptr ) ;


    // iterate over the table populating the Oid field
    build_odom_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( (void *)&MIB_DomOtherDomainTable.Table[0], (size_t)MIB_DomOtherDomainTable.Len,
          (size_t)sizeof(DOM_OTHER_ENTRY), odom_entry_cmp );

   //
   //
   // Cache table
   //
   //


   if(0 != MIB_DomOtherDomainTable.Len) {

        cache_table[C_ODOM_TABLE].acquisition_time = curr_time ;

        cache_table[C_ODOM_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested
   //
   //

Exit:
   return nResult;
} // MIB_odom_get

//
// MIB_odom_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl odom_entry_cmp(
       IN const DOM_OTHER_ENTRY *A,
       IN const DOM_OTHER_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_odom_cmp


//
//    None.
//
void build_odom_entry_oids(
       )

{
AsnOctetString OSA ;
DOM_OTHER_ENTRY *DomOtherEntry ;
unsigned i;

// start pointer at 1st guy in the table
DomOtherEntry = MIB_DomOtherDomainTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_DomOtherDomainTable.Len ; i++)  {
   // for each entry in the session table

   OSA.stream = DomOtherEntry->domOtherName.stream ;
   OSA.length =  DomOtherEntry->domOtherName.length ;
   OSA.dynamic = FALSE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &DomOtherEntry->Oid );

   DomOtherEntry++; // point to the next guy in the table

   } // for

} // build_odom_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\prnt_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    prnt_tbl.c

Abstract:

    Routines supporting operations on the Print Queue table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "prnt_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Print Queue table
static UINT                printQSubids[] = { 2, 29, 1 };
static AsnObjectIdentifier MIB_PrintQPrefix = { 3, printQSubids };

PRINTQ_TABLE     MIB_PrintQTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define PRNTQ_FIELD_SUBID     (MIB_PrintQPrefix.idLength+MIB_OidPrefix.idLength)

#define PRNTQ_FIRST_FIELD      PRNTQ_NAME_FIELD
#define PRNTQ_LAST_FIELD       PRNTQ_JOBS_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_prntq_get(
        IN OUT RFC1157VarBind *VarBind
        );

int MIB_prntq_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_prntq_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_prntq_func
//    High level routine for handling operations on the print queue table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_prntq_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Print Queue table with the info from server
         if ( SNMPAPI_ERROR == MIB_prntq_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_PrintQTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { PRNTQ_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };

         // prefix bug 445188
         AsnObjectIdentifier tmpOid;
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQTable.Table[0].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_prntq_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Print Queue table with the info from server
         if ( SNMPAPI_ERROR == MIB_prntq_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[PRNTQ_FIELD_SUBID];

        // Lookup OID in table
         if (Field < PRNTQ_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = PRNTQ_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > PRNTQ_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_prntq_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_PrintQTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > PRNTQ_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_PrintQTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > PRNTQ_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         AsnObjectIdentifier tmpOid; // prefix bug 445188
         
         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         // prefix bug 445188  
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQTable.Table[Entry].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_prntq_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_prntq_func



//
// MIB_prntq_get
//    Retrieve print queue table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_prntq_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found = MIB_TBL_POS_END;
UINT   ErrStat;

   if (VarBind->name.ids[PRNTQ_FIELD_SUBID] < PRNTQ_FIRST_FIELD ||
       VarBind->name.ids[PRNTQ_FIELD_SUBID] > PRNTQ_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Print Queue table with the info from server
   if ( SNMPAPI_ERROR == MIB_prntq_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   // Prefix # 118016
   // make sure  MIB_prntq_lmget doesn't invalid the global MIB_PrintQTable.Table
   if (MIB_PrintQTable.Table)
      Found = MIB_prntq_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_prntq_copyfromtable( Entry,
                                      VarBind->name.ids[PRNTQ_FIELD_SUBID],
                                      VarBind );

Exit:
   return ErrStat;
} // MIB_prntq_get



//
// MIB_prntq_match
//    Match the target OID with a location in the Print Queue table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_prntq_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_PrintQPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_PrintQPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_PrintQTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_PrintQTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_prntq_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_prntq_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case PRNTQ_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_PrintQTable.Table[Entry].svPrintQName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_PrintQTable.Table[Entry].svPrintQName.stream,
                       MIB_PrintQTable.Table[Entry].svPrintQName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_PrintQTable.Table[Entry].svPrintQName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case PRNTQ_JOBS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_PrintQTable.Table[Entry].svPrintQNumJobs;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Print Queue Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_prntq_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\prnt_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    prnt_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the print queue table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <winspool.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>
//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "prnt_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)   if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------


int __cdecl prnt_entry_cmp(
       IN const PRINTQ_ENTRY *A,
       IN const PRINTQ_ENTRY *B
       ) ;

void build_prnt_entry_oids( );

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_prnt_lmget
//    Retrieve print queue table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_prntq_lmget(
       )

{

DWORD entriesread = 0;              // init number of table entries read
DWORD bytesNeeded = 0;              // init size needed
DWORD dwLastError = ERROR_SUCCESS;  // init last error to no error
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
PRINTER_INFO_2 *DataTable;
PRINTQ_ENTRY *MIB_PrintQTableElement ;
int First_of_this_block;
time_t curr_time ;
BOOL result;
SNMPAPI nResult = SNMPAPI_NOERROR;


   time(&curr_time);    // get the time

   //
   //
   // If cached, return piece of info.
   //
   //

   if((NULL != cache_table[C_PRNT_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_PRNT_TABLE].acquisition_time
             + cache_expire[C_PRNT_TABLE]              ) ) )
    { // it has NOT expired!
        
        goto Exit ; // the global table is valid
    
    }
    
     //
     // remember to free the existing data
     //

     MIB_PrintQTableElement = MIB_PrintQTable.Table ;

     // iterate over the whole table
     for(i=0; i<MIB_PrintQTable.Len ;i++)
     {
        // free any alloc'ed elements of the structure
        SnmpUtilOidFree(&(MIB_PrintQTableElement->Oid));
        SafeFree(MIB_PrintQTableElement->svPrintQName.stream);
        
        MIB_PrintQTableElement ++ ;  // increment table entry
     }
     SafeFree(MIB_PrintQTable.Table) ;  // free the base Table
     MIB_PrintQTable.Table = NULL ; // just for safety
     MIB_PrintQTable.Len = 0 ;      // just for safety


   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

    // call it with zero length buffer to get the size
    //
    result = EnumPrinters(
                    PRINTER_ENUM_SHARED |
                    PRINTER_ENUM_LOCAL,     // what type to enum
                    NULL,                   // local server
                    2,                      // level
                    NULL,                   // where to put it
                    0,                      // max of above
                    &bytesNeeded,           // additional bytes req'd
                    &entriesread );         // how many we got this time

    if (result)
    {
        // When there is no table entries from spooler *and* spooler is 
        // running, we'll be here.
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: EnumPrinters returns TRUE, bytesNeeded=0x%08lx\n",
            bytesNeeded
            ));
        
        goto Exit; // get out with 0 entries in the table
    }
    // Assert: result == FALSE
    dwLastError = GetLastError();           // save last error
    
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: LMMIB2: EnumPrinters returns FALSE, bytesNeeded=0x%08lx, dwLastError=0x%08lx\n",
        bytesNeeded, dwLastError
        ));
    
    if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
    {
        //
        // EnumPrinters Failed and the last error is not 
        // ERROR_INSUFFICIENT_BUFFER, we'll bail out with 0 entries in the 
        // table.
        // For example, if spooler service was down, we will be here.
        //
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: EnumPrinters failed, lasterror != ERROR_INSUFFICIENT_BUFFER, bytesNeeded=%d\n",
            bytesNeeded
            ));
        
        goto Exit; // get out with 0 entries in the table, so getnext will work
    }
    // Assert: dwLastError == ERROR_INSUFFICIENT_BUFFER

    bufptr = SnmpUtilMemAlloc(bytesNeeded); // SnmpUtilMemAlloc the buffer
    if(NULL==bufptr)
    {
        nResult = SNMPAPI_ERROR;
        goto Exit ;      // can't allocate memory, error out
    }


    // then read the rest of it
    // call it again
    result = EnumPrinters(
                PRINTER_ENUM_SHARED |
                PRINTER_ENUM_LOCAL,     // what type to enum
                NULL,                   // local server
                2,                      // level
                bufptr,                 // where to put it
                bytesNeeded,            // max of above
                &bytesNeeded,           // additional bytes req'd
                &entriesread );         // how many we got this time
    

    if (!result) {
       // Signal error
       SafeFree( bufptr ); 
       nResult = SNMPAPI_ERROR;
       goto Exit;
    }


    DataTable = (PRINTER_INFO_2 *) bufptr ;

    
    if(0 == MIB_PrintQTable.Len) {  // 1st time, alloc the whole table
        // alloc the table space
                MIB_PrintQTable.Table = SnmpUtilMemAlloc(entriesread *
                        sizeof(PRINTQ_ENTRY) );
                // prefix bug 445181
                if (MIB_PrintQTable.Table == NULL) {
                    // free the table
                    SafeFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
    }
    
    MIB_PrintQTableElement = MIB_PrintQTable.Table  ;
    
    for(i=0; i<entriesread; i++) {  // once for each entry in the buffer
        
        // increment the entry number
        
        MIB_PrintQTable.Len ++;
        
        // Stuff the data into each item in the table
        
        // client name
        MIB_PrintQTableElement->svPrintQName.dynamic = TRUE;
        
        #ifdef UNICODE
        if (SnmpUtilUnicodeToUTF8(
            &MIB_PrintQTableElement->svPrintQName.stream,
            DataTable->pPrinterName,
            TRUE))
        {
            MIB_PrintQTableElement->svPrintQName.stream = NULL;
            MIB_PrintQTableElement->svPrintQName.length = 0;
        }
        else
        {
            MIB_PrintQTableElement->svPrintQName.length = 
                strlen (MIB_PrintQTableElement->svPrintQName.stream);
        }
        #else
        MIB_PrintQTableElement->svPrintQName.stream = SnmpUtilMemAlloc (
                strlen( DataTable->pPrinterName ) + 1 ) ;
        MIB_PrintQTableElement->svPrintQName.length =
                strlen( DataTable->pPrinterName ) ;

        memcpy( MIB_PrintQTableElement->svPrintQName.stream,
            DataTable->pPrinterName,
            strlen( DataTable->pPrinterName ) ) ;
        #endif
        
        // number of connections
        MIB_PrintQTableElement->svPrintQNumJobs =
            DataTable->cJobs;
        
            
        MIB_PrintQTableElement ++ ;  // and table entry
    
       DataTable ++ ;  // advance pointer to next sess entry in buffer
        
    } // for each entry in the data table
    
    // free all of the printer enum data
    if(NULL!=bufptr)                // free the table
        SnmpUtilMemFree( bufptr ) ;
    
    


    // iterate over the table populating the Oid field
    build_prnt_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_PrintQTable.Table[0], MIB_PrintQTable.Len,
          sizeof(PRINTQ_ENTRY), prnt_entry_cmp );

   //
   //
   // Cache table
   //
   //

   if(0 != MIB_PrintQTable.Len) {
    
    cache_table[C_PRNT_TABLE].acquisition_time = curr_time ;

    cache_table[C_PRNT_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested in global table
   //
   //

Exit:
   return nResult;
} // MIB_prnt_get

//
// MIB_prnt_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl prnt_entry_cmp(
       IN const PRINTQ_ENTRY *A,
       IN const PRINTQ_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_prnt_cmp


//
//    None.
//
void build_prnt_entry_oids(
       )

{
AsnOctetString OSA ;
PRINTQ_ENTRY *PrintQEntry ;
unsigned i;

// start pointer at 1st guy in the table
PrintQEntry = MIB_PrintQTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_PrintQTable.Len ; i++)  {
   // for each entry in the session table

   OSA.stream = PrintQEntry->svPrintQName.stream ;
   OSA.length =  PrintQEntry->svPrintQName.length ;
   OSA.dynamic = TRUE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &PrintQEntry->Oid );

   PrintQEntry++; // point to the next guy in the table

   } // for

} // build_prnt_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\resolve.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    resolve.h

Abstract:

    All constants, types, and prototypes to resolve Variable Bindings.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef resolve_h
#define resolve_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

//--------------------------- PUBLIC STRUCTS --------------------------------

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

//------------------------------- END ---------------------------------------

#endif /* resolve_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\sess_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    sess_lm.c

Abstract:

    This file contains MIB_sess_lmget, which actually call lan manager
    for the session table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "sess_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int __cdecl sess_entry_cmp(
       IN const SESS_ENTRY *A,
       IN const SESS_ENTRY *B
       ) ;

void build_sess_entry_oids( );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_sess_lmset
//    Perform the necessary actions to SET a field in the Session Table.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
UINT MIB_sess_lmset(
        IN AsnObjectIdentifier *Index,
        IN UINT Field,
        IN AsnAny *Value
        )

{
NET_API_STATUS lmCode;
int            Found;
UINT           Entry;
AsnInteger     ErrStat = SNMP_ERRORSTATUS_NOERROR;
char           Client[100];
char           User[100];
#ifdef UNICODE
LPWSTR         UniClient;
LPWSTR         UniUser;
#endif


   // Must make sure the table is in memory
   if ( SNMPAPI_ERROR == MIB_sess_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   // Find a match in the table
   if ( MIB_TBL_POS_FOUND != MIB_sess_match(Index, &Entry, FALSE) )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Check for action on Table
   if ( Value->asnValue.number == SESS_STATE_DELETED )
      {
      strcpy( Client, "\\\\" );
      strncpy( &Client[2], MIB_SessionTable.Table[Entry].svSesClientName.stream,
                       MIB_SessionTable.Table[Entry].svSesClientName.length );
      Client[MIB_SessionTable.Table[Entry].svSesClientName.length+2] = '\0';
      strncpy( User, MIB_SessionTable.Table[Entry].svSesUserName.stream,
                     MIB_SessionTable.Table[Entry].svSesUserName.length );
      User[MIB_SessionTable.Table[Entry].svSesUserName.length] = '\0';

#ifdef UNICODE
      SnmpUtilUTF8ToUnicode(      &UniClient,
                                Client,
                                TRUE );
      SnmpUtilUTF8ToUnicode(      &UniUser,
                                User,
                                TRUE );

      lmCode = NetSessionDel( NULL, UniClient, UniUser );
      SnmpUtilMemFree(UniClient);
      SnmpUtilMemFree(UniUser);
#else
      // Call the LM API to delete it
      lmCode = NetSessionDel( NULL, Client, User );
#endif

      // Check for successful operation
      switch( lmCode )
         {
         case NERR_Success:
            // Make cache be reloaded next time
            cache_table[C_SESS_TABLE].bufptr = NULL;
            break;

         case NERR_ClientNameNotFound:
         case NERR_UserNotFound:
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;

         default:
            ErrStat = SNMP_ERRORSTATUS_GENERR;
         }
      }

Exit:
   return ErrStat;
} // MIB_sess_lmset



//
// MIB_sess_lmget
//    Retrieve session table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_sess_lmget(
           )

{

DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr=NULL;
unsigned lmCode;
unsigned i;
SESSION_INFO_2 *DataTable;
SESS_ENTRY *MIB_SessionTableElement ;
int First_of_this_block;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
LPSTR tempbuff ;
DWORD resumehandle=0;

   time(&curr_time);    // get the time


//return nResult;  // OPENISSUE  remember the problem with the error
                 // every time a free is done from this call to Enum?


   //
   //
   // If cached, return piece of info.
   //
   //


   if((NULL != cache_table[C_SESS_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_SESS_TABLE].acquisition_time
                 + cache_expire[C_SESS_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit ; // the global table is valid

        }

   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

   // free the old table  LOOK OUT!!


     MIB_SessionTableElement = MIB_SessionTable.Table ;

     // iterate over the whole table
     for(i=0; i<MIB_SessionTable.Len ;i++)
     {
        // free any alloc'ed elements of the structure
        SnmpUtilOidFree(&(MIB_SessionTableElement->Oid));
        SafeFree(MIB_SessionTableElement->svSesClientName.stream);
        SafeFree(MIB_SessionTableElement->svSesUserName.stream);

        MIB_SessionTableElement ++ ;  // increment table entry
     }
     SafeFree(MIB_SessionTable.Table) ; // free the base Table
     MIB_SessionTable.Table = NULL ;    // just for safety
     MIB_SessionTable.Len = 0 ;         // just for safety

   First_of_this_block = 0;

   do {  //  as long as there is more data to process

   lmCode =
   NetSessionEnum( NULL,                        // local server
                        NULL,           // get server stats
                        NULL,
                        2,                      // level
                        &bufptr,                // data structure to return
                        MAX_PREFERRED_LENGTH,
                        &entriesread,
                        &totalentries,
                        NULL   //&resumehandle          //  resume handle
                        );


    if(NULL == bufptr)  return nResult ;

    DataTable = (SESSION_INFO_2 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error

        if(0 == MIB_SessionTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_SessionTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(SESS_ENTRY) );
        }

        MIB_SessionTableElement = MIB_SessionTable.Table + First_of_this_block ;

        for(i=0; i<entriesread; i++) {  // once for each entry in the buffer
                // increment the entry number

                MIB_SessionTable.Len ++;

                // Stuff the data into each item in the table

                // client name
                MIB_SessionTableElement->svSesClientName.dynamic = TRUE;

#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_SessionTableElement->svSesClientName.stream,
                        DataTable->sesi2_cname,
                        TRUE))
                {
                    MIB_SessionTableElement->svSesClientName.stream = NULL;
                    MIB_SessionTableElement->svSesClientName.length = 0;
                }
                else
                {
                    MIB_SessionTableElement->svSesClientName.length = 
                        strlen (MIB_SessionTableElement->svSesClientName.stream);
                }
#else
                MIB_SessionTableElement->svSesClientName.stream = SnmpUtilMemAlloc (
                                strlen( DataTable->sesi2_cname )+1 ) ;
                MIB_SessionTableElement->svSesClientName.length =
                                strlen( DataTable->sesi2_cname ) ;
                memcpy( MIB_SessionTableElement->svSesClientName.stream,
                        DataTable->sesi2_cname,
                        strlen( DataTable->sesi2_cname ) ) ;
#endif

                // user name
                MIB_SessionTableElement->svSesUserName.dynamic = TRUE;


#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_SessionTableElement->svSesUserName.stream,
                        DataTable->sesi2_username,
                        TRUE))
                {
                    MIB_SessionTableElement->svSesUserName.length = 0;
                    MIB_SessionTableElement->svSesUserName.stream = NULL;
                }
                else
                {
                    MIB_SessionTableElement->svSesUserName.length =
                        strlen(MIB_SessionTableElement->svSesUserName.stream);
                }
#else
                MIB_SessionTableElement->svSesUserName.stream = SnmpUtilMemAlloc (
                    strlen( DataTable->sesi2_username ) + 1 ) ;
                MIB_SessionTableElement->svSesUserName.length =
                    strlen( DataTable->sesi2_username ) ;

                memcpy( MIB_SessionTableElement->svSesUserName.stream,
                        DataTable->sesi2_username,
                        strlen( DataTable->sesi2_username ) ) ;
#endif
                // number of connections
                MIB_SessionTableElement->svSesNumConns =
                        // DataTable->sesi2_num_conns ; LM_NOT_THERE
                        0 ;  // so get ready in case somebody implements

                // number of opens
                MIB_SessionTableElement->svSesNumOpens =
                        DataTable->sesi2_num_opens ;

                // session time
                MIB_SessionTableElement->svSesTime =
                        DataTable->sesi2_time ;

                // session idle time
                MIB_SessionTableElement->svSesIdleTime =
                        DataTable->sesi2_idle_time ;

                // client type parsing

                // first convert from unicode if needed
#ifdef UNICODE
                SnmpUtilUnicodeToUTF8(
                        &tempbuff,
                        DataTable->sesi2_cltype_name,
                        TRUE);
#else
                tempbuff = SnmpUtilMemAlloc( strlen(DataTable->sesi2_cltype_name) + 1 );
                memcpy( tempbuff,
                        DataTable->sesi2_cltype_name,
                        strlen( DataTable->sesi2_cltype_name ) ) ;
#endif

                // let's assume 0 is undefined but better than garbage ...
                MIB_SessionTableElement->svSesClientType = 0 ;
                if(0==strcmp(   "DOWN LEVEL",
                                tempbuff))
                        MIB_SessionTableElement->svSesClientType = 1 ;
                else if(0==strcmp("DOS LM",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 2 ;
                else if(0==strcmp("DOS LM 2.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 3 ;
                else if(0==strcmp("OS/2 LM 1.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 4 ;
                else if(0==strcmp("OS/2 LM 2.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 5 ;
                else if(0==strcmp("DOS LM 2.1",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 6 ;
                else if(0==strcmp("OS/2 LM 2.1",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 7 ;
                else if(0==strcmp("AFP 1.1",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 8 ;
                else if(0==strcmp("AFP 2.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 9 ;
                else if(0==strcmp("NT",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 10 ;
                SnmpUtilMemFree(tempbuff);

                // state is always active, set uses to indicate delete request
                MIB_SessionTableElement->svSesState = 1; //always active


                DataTable ++ ;  // advance pointer to next sess entry in buffer
                MIB_SessionTableElement ++ ;  // and table entry

        } // for each entry in the data table


        // free all of the lan man data
        SafeBufferFree( bufptr ) ;

        // indicate where to start adding on next pass, if any
        First_of_this_block = i ;

        } // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    build_sess_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( (void *)&MIB_SessionTable.Table[0], (size_t)MIB_SessionTable.Len,
          (size_t)sizeof(SESS_ENTRY), sess_entry_cmp );

   //
   //
   // Cache table
   //
   //

   if(0 != MIB_SessionTable.Len) {

        cache_table[C_SESS_TABLE].acquisition_time = curr_time ;

        cache_table[C_SESS_TABLE].bufptr = bufptr ;
   }


   //
   //
   // Return piece of information requested
   //
   //

Exit:
   return nResult;
} // MIB_sess_get

//
// MIB_sess_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl sess_entry_cmp(
       IN const SESS_ENTRY *A,
       IN const SESS_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_sess_cmp


//
//    None.
//
void build_sess_entry_oids(
       )

{
AsnOctetString OSA ;
AsnObjectIdentifier UserNameOid ;
SESS_ENTRY *SessEntry ;
unsigned i;

// start pointer at 1st guy in the table
SessEntry = MIB_SessionTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_SessionTable.Len ; i++)  {
   // for each entry in the session table

   // copy the client name into the oid buffer first
   MakeOidFromStr( &SessEntry->svSesClientName, &SessEntry->Oid );

   // copy the user name into a temporary oid buffer
   MakeOidFromStr( &SessEntry->svSesUserName, &UserNameOid );

   // append the two entries forming the index
   SnmpUtilOidAppend( &SessEntry->Oid, &UserNameOid );

   // free the temporary buffer
   SnmpUtilOidFree( &UserNameOid );

   SessEntry++; // point to the next guy in the table

   } // for

} // build_sess_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\sess_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    sess_tbl.h

Abstract:

    Definition of all structures used by the Session table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

#ifndef sess_tbl_h
#define sess_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SESS_CLIENT_FIELD      1
#define SESS_USER_FIELD        2
#define SESS_NUMCONS_FIELD     3
#define SESS_NUMOPENS_FIELD    4
#define SESS_TIME_FIELD        5
#define SESS_IDLETIME_FIELD    6
#define SESS_CLIENTTYPE_FIELD  7
#define SESS_STATE_FIELD       8

   // State definitions
#define SESS_STATE_ACTIVE      1
#define SESS_STATE_DELETED     2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the session table
typedef struct sess_entry
           {
           AsnObjectIdentifier Oid;
	   AsnDisplayString svSesClientName; // Index
	   AsnDisplayString svSesUserName;   // Index
	   AsnInteger       svSesNumConns;
	   AsnInteger       svSesNumOpens;
	   AsnCounter       svSesTime;
	   AsnCounter       svSesIdleTime;
	   AsnInteger       svSesClientType;
	   AsnInteger       svSesState;
	   } SESS_ENTRY;

   // Session table definition
typedef struct
           {
	   UINT       Len;
	   SESS_ENTRY *Table;
           } SESSION_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern SESSION_TABLE    MIB_SessionTable ;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_sess_lmget(
           void
	   );

UINT MIB_sess_lmset(
        IN AsnObjectIdentifier *Index,
	IN UINT Field,
	IN AsnAny *Value
	);

int MIB_sess_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       );

//------------------------------- END ---------------------------------------

#endif /* sess_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\sess_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    sess_tbl.c

Abstract:

    All routines to support opertions on the LM MIB session table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "sess_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Session table
static UINT                sessSubids[] = { 2, 20, 1 };
static AsnObjectIdentifier MIB_SessPrefix = { 3, sessSubids };

SESSION_TABLE MIB_SessionTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SESS_FIELD_SUBID       (MIB_SessPrefix.idLength+MIB_OidPrefix.idLength)

#define SESS_FIRST_FIELD       SESS_CLIENT_FIELD
#define SESS_LAST_FIELD        SESS_STATE_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_sess_get(
        IN OUT RFC1157VarBind *VarBind
        );

int MIB_sess_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       );

UINT MIB_sess_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_sess_func
//    High level routine for handling operations on the session table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_sess_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Session table with the info from server
         if ( SNMPAPI_ERROR == MIB_sess_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_SessionTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { SESS_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };


         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SessPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SessionTable.Table[0].Oid );
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_sess_get( VarBind );
         break;

      case MIB_ACTION_GETNEXT:
         // Fill the Session table with the info from server
         if ( SNMPAPI_ERROR == MIB_sess_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Determine which field
         Field = VarBind->name.ids[SESS_FIELD_SUBID];

        // Lookup OID in table
         if (Field < SESS_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = SESS_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > SESS_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_sess_match( &VarBind->name, &Entry, TRUE );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_SessionTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > SESS_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_SessionTable.Len-1 )
               {
               Entry = 0;
               Field ++;

               /* item not implemented. Skip */

               if (Field == SESS_NUMCONS_FIELD) {
                   Field++;
               }

               if ( Field > SESS_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SessPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SessionTable.Table[Entry].Oid );
         }

         ErrStat = MIB_sess_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         // Make sure OID is long enough
         if ( SESS_FIELD_SUBID + 1 > VarBind->name.idLength )
            {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Get field number
         Field = VarBind->name.ids[SESS_FIELD_SUBID];

         // If the field being set is not the STATE field, error
         if ( Field != SESS_STATE_FIELD )
            {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Check for proper type before setting
         if ( ASN_INTEGER != VarBind->value.asnType )
            {
            ErrStat = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
            }

         // Make sure that the value is valid
         if ( VarBind->value.asnValue.number < SESS_STATE_ACTIVE &&
              VarBind->value.asnValue.number > SESS_STATE_DELETED )
            {
            ErrStat = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
            }

         ErrStat = MIB_sess_lmset( &VarBind->name, Field, &VarBind->value );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_sess_func



//
// MIB_sess_get
//    Retrieve session table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_sess_get(
        IN OUT RFC1157VarBind *VarBind
        )

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[SESS_FIELD_SUBID] < SESS_FIRST_FIELD ||
       VarBind->name.ids[SESS_FIELD_SUBID] > SESS_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Session table with the info from server
   if ( SNMPAPI_ERROR == MIB_sess_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_sess_match( &VarBind->name, &Entry, FALSE );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   if ( VarBind->name.ids[SESS_FIELD_SUBID] == SESS_NUMCONS_FIELD )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_sess_copyfromtable( Entry, VarBind->name.ids[SESS_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_sess_get



//
// MIB_sess_match
//    Match the target OID with a location in the Session table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_sess_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_SessPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_SessPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_SessionTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_SessionTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;
         if (Next) {
             while ( ( (*Pos) + 1 < MIB_SessionTable.Len ) &&
                     !SnmpUtilOidCmp( &TempOid, &MIB_SessionTable.Table[(*Pos)+1].Oid)) {
                 (*Pos)++;
             }
         }

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_sess_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_sess_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SESS_CLIENT_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_SessionTable.Table[Entry].svSesClientName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_SessionTable.Table[Entry].svSesClientName.stream,
                       MIB_SessionTable.Table[Entry].svSesClientName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_SessionTable.Table[Entry].svSesClientName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SESS_USER_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_SessionTable.Table[Entry].svSesUserName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_SessionTable.Table[Entry].svSesUserName.stream,
                       MIB_SessionTable.Table[Entry].svSesUserName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_SessionTable.Table[Entry].svSesUserName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SESS_NUMCONS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesNumConns;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SESS_NUMOPENS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesNumOpens;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SESS_TIME_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesTime;
         VarBind->value.asnType = ASN_RFC1155_COUNTER;
         break;

      case SESS_IDLETIME_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesIdleTime;
         VarBind->value.asnType = ASN_RFC1155_COUNTER;
         break;

      case SESS_CLIENTTYPE_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesClientType;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SESS_STATE_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesState;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Session Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_sess_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\resolve.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    resolve.c

Abstract:

    High level routines to process the variable binding list.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mib.h"
#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

AsnInteger ResolveVarBind(
              IN RFC1157VarBind *VarBind, // Variable Binding to resolve
              IN UINT PduAction           // Action specified in PDU
              );

SNMPAPI SnmpExtensionQuery(
           IN BYTE ReqType,               // 1157 Request type
           IN OUT RFC1157VarBindList *VarBinds, // Var Binds to resolve
           OUT AsnInteger *ErrorStatus,         // Error status returned
           OUT AsnInteger *ErrorIndex           // Var Bind containing error
           );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//
// ResolveVarBind
//    Resolve a variable binding.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
AsnInteger ResolveVarBind(
              IN RFC1157VarBind *VarBind, // Variable Binding to resolve
              IN UINT PduAction           // Action specified in PDU
              )

{
MIB_ENTRY            *MibPtr;
AsnObjectIdentifier  TempOid;
AsnInteger           nResult;


   // Lookup OID in MIB
   MibPtr = MIB_get_entry( &VarBind->name );

   // Check to see if OID is between LM variables
   if ( MibPtr == NULL && PduAction == MIB_ACTION_GETNEXT )
      {
      UINT I;


      //
      // OPENISSUE - Should change to binary search
      //
      // Search through MIB to see if OID is within the LM MIB's scope
      I = 0;
      while ( MibPtr == NULL && I < MIB_num_variables )
         {
         // Construct OID with complete prefix for comparison purposes
         if (SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &TempOid, &Mib[I].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree( &TempOid );
            nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }

         // Check for OID in MIB
         if ( 0 > SnmpUtilOidCmp(&VarBind->name, &TempOid) )
            {
            MibPtr = &Mib[I];
            PduAction = MIB_ACTION_GETFIRST;
            }

         // Free OID memory before copying another
         SnmpUtilOidFree( &TempOid );

         I++;
         } // while
      } // if

   // If OID not within scope of LM MIB, then no such name
   if ( MibPtr == NULL )
      {
      nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Call MIB function to apply requested operation
   if ( MibPtr->MibFunc == NULL )
      {
      // If not GET-NEXT, then error
      if ( PduAction != MIB_ACTION_GETNEXT && PduAction != MIB_ACTION_GETFIRST )
         {
         nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
         goto Exit;
         }

      // Since this is AGGREGATE, use GET-FIRST on next variable, then return
      nResult = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                             MibPtr->MibNext, VarBind );
      }
   else
      {
      // Make complete OID of MIB name
      if (SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix ) == SNMPAPI_ERROR)
         {
         nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
         goto Exit;
         }
      if (SnmpUtilOidAppend( &TempOid, &MibPtr->Oid ) == SNMPAPI_ERROR)
         {
         SnmpUtilOidFree( &TempOid );
         nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
         goto Exit;
         }

      if ( MibPtr->Type == MIB_TABLE && !SnmpUtilOidCmp(&TempOid, &VarBind->name) )
         {
         if ( PduAction == MIB_ACTION_GETNEXT )
            {
            // Supports GET-NEXT on a MIB table's root node
            PduAction = MIB_ACTION_GETFIRST;
            }
         else
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            SnmpUtilOidFree( &TempOid );
            goto Exit;
            }
         }

      nResult = (*MibPtr->MibFunc)( PduAction, MibPtr, VarBind );

      // Free temp memory
      SnmpUtilOidFree( &TempOid );
      }

Exit:
   return nResult;
} // ResolveVarBind

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// SnmpExtensionQuery
//    Loop through var bind list resolving each var bind name to an entry
//    in the LAN Manager MIB.
//
// Notes:
//    Table sets are handled on a case by case basis, because in some cases
//    more than one entry in the Var Bind list will be needed to perform a
//    single SET on the LM MIB.  This is due to the LM API calls.
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI SnmpExtensionQuery(
           IN BYTE ReqType,               // 1157 Request type
           IN OUT RFC1157VarBindList *VarBinds, // Var Binds to resolve
           OUT AsnInteger *ErrorStatus,         // Error status returned
           OUT AsnInteger *ErrorIndex           // Var Bind containing error
           )

{
UINT    I;
SNMPAPI nResult;


//
//
// OPENISSUE - Support is not available for TABLE SETS.
//
//
   nResult = SNMPAPI_NOERROR;

   *ErrorIndex = 0;
   // Loop through Var Bind list resolving var binds
   for ( I=0;I < VarBinds->len;I++ )
      {
      *ErrorStatus = ResolveVarBind( &VarBinds->list[I], ReqType );

      // Check for GET-NEXT past end of MIB
      if ( *ErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
           ReqType == MIB_ACTION_GETNEXT )
         {
         *ErrorStatus = SNMP_ERRORSTATUS_NOERROR;

         // Set Var Bind pointing to next enterprise past LM MIB
         SnmpUtilOidFree( &VarBinds->list[I].name );
         SnmpUtilOidCpy( &VarBinds->list[I].name, &MIB_OidPrefix );
         VarBinds->list[I].name.ids[MIB_PREFIX_LEN-1] ++;
         }

      if ( *ErrorStatus != SNMP_ERRORSTATUS_NOERROR )
         {
         *ErrorIndex = I+1;
         goto Exit;
         }
      }

Exit:
   return nResult;
} // SnmpExtensionQuery

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\shar_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    shar_lm.c

Abstract:

    This file contains MIB_shar_lmget, which actually call lan manager
    for the share table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "shar_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)	if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int __cdecl shar_entry_cmp(
       IN const SHARE_ENTRY *A,
       IN const SHARE_ENTRY *B
       ) ;

void build_shar_entry_oids( );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_shar_lmget
//    Retrieve sharion table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_shares_lmget(
	   )

{

DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
SHARE_INFO_2 *DataTable;
SHARE_ENTRY *MIB_ShareTableElement ;
int First_of_this_block;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
DWORD resumehandle=0;


   time(&curr_time);	// get the time


   //
   //
   // If cached, return piece of info.
   //
   //


   if((NULL != cache_table[C_SHAR_TABLE].bufptr) &&
      (curr_time <
    	(cache_table[C_SHAR_TABLE].acquisition_time
        	 + cache_expire[C_SHAR_TABLE]              ) ) )
   	{ // it has NOT expired!
     	
     	goto Exit ; // the global table is valid
	
	}
	
   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

	
     //
     // remember to free the existing data
     //

     MIB_ShareTableElement = MIB_ShareTable.Table ;

     // iterate over the whole table
     for(i=0; i<MIB_ShareTable.Len ;i++)
     {
     	// free any alloc'ed elements of the structure
     	SnmpUtilOidFree(&(MIB_ShareTableElement->Oid));
     	SafeFree(MIB_ShareTableElement->svShareName.stream);
     	SafeFree(MIB_ShareTableElement->svSharePath.stream);
     	SafeFree(MIB_ShareTableElement->svShareComment.stream);
     	
	MIB_ShareTableElement ++ ;  // increment table entry
     }
     SafeFree(MIB_ShareTable.Table) ;	// free the base Table
     MIB_ShareTable.Table = NULL ;	// just for safety
     MIB_ShareTable.Len = 0 ;		// just for safety


   	
#if 0 // Done above
   // init the length
   MIB_ShareTable.Len = 0;
#endif
   First_of_this_block = 0;
   	
   do {  //  as long as there is more data to process

        lmCode =
	     NetShareEnum(NULL,      // local server
            2,                  // level 2,
            &bufptr,            // data structure to return
            MAX_PREFERRED_LENGTH,
            &entriesread,
            &totalentries,
            &resumehandle       //  resume handle
            );

        //
        // Filter out all the Admin shares (name ending with $).
        //
        AdminFilter(2,&entriesread,bufptr);


    DataTable = (SHARE_INFO_2 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
    	{  // valid so process it, otherwise error
   	
    if(0 == MIB_ShareTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_ShareTable.Table = SnmpUtilMemAlloc(totalentries *
                        sizeof(SHARE_ENTRY) );
                // prefix bugs 445180
                if (MIB_ShareTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
    }
	
    MIB_ShareTableElement = MIB_ShareTable.Table + First_of_this_block ;
	
    for(i=0; i<entriesread; i++) {  // once for each entry in the buffer
   		// increment the entry number
   		
   		MIB_ShareTable.Len ++;
   		
   		// Stuff the data into each item in the table
   		
   		// share name
   		MIB_ShareTableElement->svShareName.dynamic = TRUE;
		
		#ifdef UNICODE
		if (SnmpUtilUnicodeToUTF8(
			&MIB_ShareTableElement->svShareName.stream,
   			DataTable->shi2_netname,
			TRUE))
        {
            MIB_ShareTableElement->svShareName.length = 0;
            MIB_ShareTableElement->svShareName.stream = NULL;
        }
        else
        {
            MIB_ShareTableElement->svShareName.length = 
                strlen(MIB_ShareTableElement->svShareName.stream);
        }
		#else
        MIB_ShareTableElement->svShareName.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_netname ) + 1 ) ;
   		MIB_ShareTableElement->svShareName.length =
   				strlen( DataTable->shi2_netname ) ;
   		memcpy(	MIB_ShareTableElement->svShareName.stream,
   			DataTable->shi2_netname,
   			strlen( DataTable->shi2_netname ) ) ;
   		#endif
   		
   		// Share Path
   		MIB_ShareTableElement->svSharePath.dynamic = TRUE;
   		
		#ifdef UNICODE
		if (SnmpUtilUnicodeToUTF8(
			&MIB_ShareTableElement->svSharePath.stream,
   			DataTable->shi2_path,
			TRUE))
        {
            MIB_ShareTableElement->svSharePath.length = 0;
            MIB_ShareTableElement->svSharePath.stream = NULL;
        }
        else
        {
            MIB_ShareTableElement->svSharePath.length =
                strlen(MIB_ShareTableElement->svSharePath.stream);
        }
		#else
        MIB_ShareTableElement->svSharePath.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_path ) + 1 ) ;
   		MIB_ShareTableElement->svSharePath.length =
   				strlen( DataTable->shi2_path ) ;

   		memcpy(	MIB_ShareTableElement->svSharePath.stream,
   			DataTable->shi2_path,
   			strlen( DataTable->shi2_path ) ) ;
   		#endif
   		
   		// Share Comment/Remark
   		MIB_ShareTableElement->svShareComment.dynamic = TRUE;
   		
		#ifdef UNICODE
		if (SnmpUtilUnicodeToUTF8(
			&MIB_ShareTableElement->svShareComment.stream,
   			DataTable->shi2_remark,
			TRUE))
        {
            MIB_ShareTableElement->svShareComment.length = 0;
            MIB_ShareTableElement->svShareComment.stream = NULL;
        }
        else
        {
            MIB_ShareTableElement->svShareComment.length =
                strlen(MIB_ShareTableElement->svShareComment.stream);
        }
		#else
        MIB_ShareTableElement->svShareComment.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_remark ) + 1 ) ;
   		MIB_ShareTableElement->svShareComment.length =
   				strlen( DataTable->shi2_remark ) ;

   		memcpy(	MIB_ShareTableElement->svShareComment.stream,
   			DataTable->shi2_remark,
   			strlen( DataTable->shi2_remark ) ) ;
   		#endif
   		
   		DataTable ++ ;  // advance pointer to next shar entry in buffer
		MIB_ShareTableElement ++ ;  // and table entry
		
   	} // for each entry in the data table
   	
   	
   	// free all of the lan man data
	SafeBufferFree( bufptr ) ;
	
   	// indicate where to start adding on next pass, if any
   	First_of_this_block = i ;
   	
       	} // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    build_shar_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_ShareTable.Table[0], MIB_ShareTable.Len,
          sizeof(SHARE_ENTRY), shar_entry_cmp );

   //
   //
   // Cache table
   //
   //


   if(0 != MIB_ShareTable.Len) {
   	
   	cache_table[C_SHAR_TABLE].acquisition_time = curr_time ;

   	cache_table[C_SHAR_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested
   //
   //

Exit:
   return nResult;
} // MIB_shar_get

//
// MIB_shar_cmp
//    Routine for sorting the sharion table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl shar_entry_cmp(
       IN const SHARE_ENTRY *A,
       IN const SHARE_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_shar_cmp


//
//    None.
//
void build_shar_entry_oids(
       )

{
AsnOctetString OSA ;
SHARE_ENTRY *ShareEntry ;
unsigned i;

// start pointer at 1st guy in the table
ShareEntry = MIB_ShareTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_ShareTable.Len ; i++)  {
   // for each entry in the sharion table

   OSA.stream = ShareEntry->svShareName.stream ;
   OSA.length =  ShareEntry->svShareName.length ;
   OSA.dynamic = FALSE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &ShareEntry->Oid );

   ShareEntry++; // point to the next guy in the table

   } // for

} // build_shar_entry_oids


VOID
AdminFilter(
    DWORD           Level,
    LPDWORD         pEntriesRead,
    LPBYTE          ShareInfo
    )

/*++

Routine Description:

    This function filters out the admin shares (ones denoted by a
    a $ as the last character in the name) from a NetShareEnum
    buffer.

    This function only supports info levels 0,1, and 2.  If any other
    level is passed in, the function doesn't perform the filter
    operation.

Arguments:

    Level - Indicates the info level of the enumeration buffer passed in.

    pEntriesRead - Pointer to a location which on entry indicates the
        number of entries to be filtered.  On exit it will indicate
        the number of entries after filtering.

    ShareInfo - Pointer to the buffer containing the enumerated structures.

Return Value:

    none.

--*/
{
    LPBYTE          pFiltered = ShareInfo;
    DWORD           filteredEntries=0;
    DWORD           i;
    DWORD           entrySize;
    DWORD           namePtrOffset;
    LPWSTR          pName;

    switch(Level) {
    case 0:
        entrySize = sizeof(SHARE_INFO_0);
        namePtrOffset = (DWORD)((LPBYTE)&(((LPSHARE_INFO_0)ShareInfo)->shi0_netname) -
                         ShareInfo);
        break;
    case 1:
        entrySize = sizeof(SHARE_INFO_1);
        namePtrOffset = (DWORD)((LPBYTE)&(((LPSHARE_INFO_1)ShareInfo)->shi1_netname) -
                         ShareInfo);
        break;
    case 2:
        entrySize = sizeof(SHARE_INFO_2);
        namePtrOffset = (DWORD)((LPBYTE)&(((LPSHARE_INFO_2)ShareInfo)->shi2_netname) -
                         ShareInfo);
        break;
    default:
        return;
    }

    for (i=0; i < *pEntriesRead; i++) {
        pName = *((LPWSTR *)(ShareInfo+namePtrOffset));
        if (pName[wcslen(pName)-1] != L'$') {
            filteredEntries++;
            if (pFiltered != ShareInfo) {
                memcpy(pFiltered, ShareInfo,entrySize);
            }
            pFiltered += entrySize;
        }
        ShareInfo += entrySize;
    }
    *pEntriesRead = filteredEntries;
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\shar_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    shar_tbl.h

Abstract:

    Define all structures and routines used by the share table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef shar_tbl_h
#define shar_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SHARE_NAME_FIELD        1
#define SHARE_PATH_FIELD        2
#define SHARE_COMMENT_FIELD     3

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the share table
typedef struct share_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString svShareName;    // Index
	   AsnDisplayString svSharePath;
	   AsnDisplayString svShareComment;
	   } SHARE_ENTRY;

   // Share table definition
typedef struct
           {
	   UINT        Len;
	   SHARE_ENTRY *Table;
           } SHARE_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern SHARE_TABLE      MIB_ShareTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_shares_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* shar_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\shar_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    shar_tbl.c

Abstract:

    All routines to perform operations on the Share Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "shar_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Share table
static UINT                shareSubids[] = { 2, 27, 1 };
static AsnObjectIdentifier MIB_SharePrefix = { 3, shareSubids };

SHARE_TABLE      MIB_ShareTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SHARE_FIELD_SUBID      (MIB_SharePrefix.idLength+MIB_OidPrefix.idLength)

#define SHARE_FIRST_FIELD       SHARE_NAME_FIELD
#define SHARE_LAST_FIELD        SHARE_COMMENT_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_shares_get(
        IN OUT RFC1157VarBind *VarBind
	);

int MIB_shares_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_shares_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_shares_func
//    High level routine for handling operations on the Share table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_shares_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Share Table with the info from server
         MIB_shares_lmget();

         // If no elements in table, then return next MIB var, if one
         if ( MIB_ShareTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { SHARE_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };

          // prefix bug 445188
         AsnObjectIdentifier tmpOid;
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_SharePrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_ShareTable.Table[0].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_shares_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Share table with the info from server
         MIB_shares_lmget();

         // Determine which field
         Field = VarBind->name.ids[SHARE_FIELD_SUBID];

        // Lookup OID in table
         if (Field < SHARE_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = SHARE_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > SHARE_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_shares_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_ShareTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > SHARE_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_ShareTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > SHARE_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;
         
         AsnObjectIdentifier tmpOid; // Prefix bug 445187

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         // Prefix bug 445187
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_SharePrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_ShareTable.Table[Entry].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_shares_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_shares_func



//
// MIB_shares_get
//    Retrieve Share table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_shares_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found = MIB_TBL_POS_END;
UINT   ErrStat;

   if (VarBind->name.ids[SHARE_FIELD_SUBID] < SHARE_FIRST_FIELD ||
       VarBind->name.ids[SHARE_FIELD_SUBID] > SHARE_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Share table with the info from server
   MIB_shares_lmget();

   // Prefix # 118017
   // make sure  MIB_shares_lmget doesn't invalid the global MIB_ShareTable.Table
   if (MIB_ShareTable.Table)
      Found = MIB_shares_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_shares_copyfromtable( Entry, VarBind->name.ids[SHARE_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_shares_get



//
// MIB_shares_match
//    Match the target OID with a location in the Share table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_shares_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_SharePrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_SharePrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_ShareTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_ShareTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_shares_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_shares_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SHARE_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_ShareTable.Table[Entry].svShareName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_ShareTable.Table[Entry].svShareName.stream,
                       MIB_ShareTable.Table[Entry].svShareName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_ShareTable.Table[Entry].svShareName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SHARE_PATH_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_ShareTable.Table[Entry].svSharePath.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_ShareTable.Table[Entry].svSharePath.stream,
                       MIB_ShareTable.Table[Entry].svSharePath.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_ShareTable.Table[Entry].svSharePath.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SHARE_COMMENT_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_ShareTable.Table[Entry].svShareComment.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_ShareTable.Table[Entry].svShareComment.stream,
                       MIB_ShareTable.Table[Entry].svShareComment.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_ShareTable.Table[Entry].svShareComment.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Share Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_shares_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\snmptst4.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    snmptst4.c

Abstract:

    Driver routine to invoke an test the Extension Agent DLL.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>


//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>
#include <authapi.h>

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

typedef AsnObjectIdentifier View; // temp until view is defined...

int __cdecl main(
    IN int  argumentCount,
    IN char *argumentVector[])
    {
    HANDLE  hExtension;
    FARPROC initAddr;
    FARPROC queryAddr;
    FARPROC trapAddr;

    DWORD  timeZeroReference;
    HANDLE hPollForTrapEvent;
    View   supportedView;

    INT i;
    INT numQueries = 10;
    UINT typ;

    extern INT nLogLevel;
    extern INT nLogType;

    nLogLevel = 15;
    nLogType  = 1;

    // avoid compiler warning...
    UNREFERENCED_PARAMETER(argumentCount);
    UNREFERENCED_PARAMETER(argumentVector);

    timeZeroReference = GetCurrentTime()/10;

    // load the extension agent dll and resolve the entry points...
    if (GetModuleHandle("lmmib2.dll") == NULL)
        {
        if ((hExtension = LoadLibrary("lmmib2.dll")) == NULL)
            {
            dbgprintf(1, "error on LoadLibrary %d\n", GetLastError());

            }
        else if ((initAddr = GetProcAddress(hExtension,
                 "SnmpExtensionInit")) == NULL)
            {
            dbgprintf(1, "error on GetProcAddress %d\n", GetLastError());
            }
        else if ((queryAddr = GetProcAddress(hExtension,
                 "SnmpExtensionQuery")) == NULL)
            {
            dbgprintf(1, "error on GetProcAddress %d\n",
                              GetLastError());

            }
        else if ((trapAddr = GetProcAddress(hExtension,
                 "SnmpExtensionTrap")) == NULL)
            {
            dbgprintf(1, "error on GetProcAddress %d\n",
                      GetLastError());

            }
        else
            {
            // initialize the extension agent via its init entry point...
            (*initAddr)(
                timeZeroReference,
                &hPollForTrapEvent,
                &supportedView);
            }
        } // end if (Already loaded)

    // create a trap thread to respond to traps from the extension agent...

    //rather than oomplicate this test routine, will poll for these events
    //below.  normally this would be done by another thread in the extendible
    //agent.


    // loop here doing repetitive extension agent get queries...
    // poll for potential traps each iteration (see note above)...

    //block...
         {
         RFC1157VarBindList varBinds;
         AsnInteger         errorStatus;
         AsnInteger         errorIndex;
         UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 77 };
         AsnObjectIdentifier MIB_OidPrefix = { 7, OID_Prefix };


	 errorStatus = 0;
	 errorIndex  = 0;
         varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
         varBinds.len = 1;
         varBinds.list[0].name.idLength = MIB_OidPrefix.idLength;
         varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT) *
                                               varBinds.list[0].name.idLength );
         memcpy( varBinds.list[0].name.ids, MIB_OidPrefix.ids,
                 sizeof(UINT)*varBinds.list[0].name.idLength );
         varBinds.list[0].value.asnType = ASN_NULL;

         do
            {
	    printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
                                        printf( "   " );
            (*queryAddr)( (AsnInteger)ASN_RFC1157_GETNEXTREQUEST,
                          &varBinds,
		          &errorStatus,
		          &errorIndex
                          );
            printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
	    if ( errorStatus )
	       {
               printf( "\nErrorstatus:  %lu\n\n", errorStatus );
	       }
	    else
	       {
               printf( "\n  =  " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	       }
            putchar( '\n' );
            }
         while ( varBinds.list[0].name.ids[7-1] != 78 );

         // Free the memory
         SnmpUtilVarBindListFree( &varBinds );


#if 0

            // query potential traps (see notes above)
            if (hPollForTrapEvent != NULL)
                {
                DWORD dwResult;

                if      ((dwResult = WaitForSingleObject(hPollForTrapEvent,
                         0/*immediate*/)) == 0xffffffff)
                    {
                    dbgprintf(1, "error on WaitForSingleObject %d\n",
                        GetLastError());
                    }
                else if (dwResult == 0 /*signaled*/)
                    {
                    AsnObjectIdentifier enterprise;
                    AsnInteger          genericTrap;
                    AsnInteger          specificTrap;
                    AsnTimeticks        timeStamp;
                    RFC1157VarBindList  variableBindings;

                    while(
                        (*trapAddr)(&enterprise, &genericTrap, &specificTrap,
                                    &timeStamp, &variableBindings)
                        )
                        {
                        printf("trap: gen=%d spec=%d time=%d\n",
                            genericTrap, specificTrap, timeStamp);

                        //also print data

                        } // end while ()

                    } // end if (trap ready)

                } // end if (handling traps)
#endif


         } // block


    return 0;

    } // end main()


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\srvc_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvc_tbl.h

Abstract:

    Define all of the structures and routines used in the service table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

#ifndef srvc_tbl_h
#define srvc_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SRVC_NAME_FIELD        1
#define SRVC_INSTALLED_FIELD   2
#define SRVC_OPERATING_FIELD   3
#define SRVC_UNINSTALLED_FIELD 4
#define SRVC_PAUSED_FIELD      5

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the service table
typedef struct srvc_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString svSvcName;            // Index
	   AsnInteger       svSvcInstalledState;
	   AsnInteger       svSvcOperatingState;
	   AsnInteger       svSvcCanBeUninstalled;
	   AsnInteger       svSvcCanBePaused;
	   } SRVC_ENTRY;

   // Service table definition
typedef struct
           {
	   UINT       Len;
	   SRVC_ENTRY *Table;
           } SRVC_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern SRVC_TABLE       MIB_SrvcTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_srvcs_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* srvc_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\srvc_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvc_lm.c

Abstract:

    This file contains MIB_srvc_lmget, which actually call lan manager
    for the srvce table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "srvc_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)	if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int __cdecl srvc_entry_cmp(
       IN const SRVC_ENTRY *A,
       IN const SRVC_ENTRY *B
       ) ;

void build_srvc_entry_oids( );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_srvc_lmget
//    Retrieve srvcion table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_srvcs_lmget(
	   )

{
DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
SERVICE_INFO_2 *DataTable;
SRVC_ENTRY *MIB_SrvcTableElement ;
int First_of_this_block;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
DWORD resumehandle=0;
#ifdef UNICODE
LPSTR stream;
#endif


   time(&curr_time);	// get the time


   //
   //
   // If cached, return piece of info.
   //
   //


   if((NULL != cache_table[C_SRVC_TABLE].bufptr) &&
      (curr_time <
    	(cache_table[C_SRVC_TABLE].acquisition_time
        	 + cache_expire[C_SRVC_TABLE]              ) ) )
   	{ // it has NOT expired!
     	
     	goto Exit ; // the global table is valid
	
	}
	
   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

   	
     //
     // remember to free the existing data
     //

     MIB_SrvcTableElement = MIB_SrvcTable.Table ;

     // iterate over the whole table
     for(i=0; i<MIB_SrvcTable.Len ;i++)
     {
     	// free any alloc'ed elements of the structure
     	SnmpUtilOidFree(&(MIB_SrvcTableElement->Oid));
     	SafeFree(MIB_SrvcTableElement->svSvcName.stream);
     	
	MIB_SrvcTableElement ++ ;  // increment table entry
     }
     SafeFree(MIB_SrvcTable.Table) ;	// free the base Table
     MIB_SrvcTable.Table = NULL ;	// just for safety
     MIB_SrvcTable.Len = 0 ;		// just for safety

   First_of_this_block = 0;
   	
   do {  //  as long as there is more data to process

	       lmCode =
            NetServiceEnum( NULL,       // local server
                    2,                  // level 2
                    &bufptr,            // data structure to return
                    MAX_PREFERRED_LENGTH,
                    &entriesread,
                    &totalentries,
                    &resumehandle       //  resume handle
	       			);

    DataTable = (SERVICE_INFO_2 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
    	{  // valid so process it, otherwise error
   	
            if(0 == MIB_SrvcTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_SrvcTable.Table = SnmpUtilMemAlloc(totalentries *
                        sizeof(SRVC_ENTRY) );
                // prefix bugs 445185 and 445186
                if (MIB_SrvcTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit; 
                }
            }
    
	MIB_SrvcTableElement = MIB_SrvcTable.Table + First_of_this_block ;
	
   	for(i=0; i<entriesread; i++) {  // once for each entry in the buffer
   		// increment the entry number
   		
   		MIB_SrvcTable.Len ++;
   		
   		// Stuff the data into each item in the table
   		
   		MIB_SrvcTableElement->svSvcName.dynamic = TRUE;

		#ifdef UNICODE
		if (SnmpUtilUnicodeToUTF8(
			&MIB_SrvcTableElement->svSvcName.stream,
   			DataTable->svci2_display_name,
			TRUE))
        {
            MIB_SrvcTableElement->svSvcName.length = 0;
            MIB_SrvcTableElement->svSvcName.stream = NULL;
        }
        else
        {
            MIB_SrvcTableElement->svSvcName.length =
                strlen(MIB_SrvcTableElement->svSvcName.stream);
        }

		#else
   		// service name
        MIB_SrvcTableElement->svSvcName.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->svci2_display_name ) + 1) ;

        memcpy(	MIB_SrvcTableElement->svSvcName.stream,
   			DataTable->svci2_display_name,
   			strlen( DataTable->svci2_display_name ) + 1) ;

        MIB_SrvcTableElement->svSvcName.length =
   				strlen( MIB_SrvcTableElement->svSvcName.stream )) ;
   		#endif
   		
		MIB_SrvcTableElement->svSvcInstalledState =
   			(DataTable->svci2_status & 0x03) + 1;
		MIB_SrvcTableElement->svSvcOperatingState =
   			((DataTable->svci2_status>>2) & 0x03) + 1;
		MIB_SrvcTableElement->svSvcCanBeUninstalled =
   			((DataTable->svci2_status>>4) & 0x01) + 1;
		MIB_SrvcTableElement->svSvcCanBePaused =
   			((DataTable->svci2_status>>5) & 0x01) + 1;
   		
   		DataTable ++ ;  // advance pointer to next srvc entry in buffer
		MIB_SrvcTableElement ++ ;  // and table entry
		
   	} // for each entry in the data table
   	
   	
   	// free all of the lan man data
	SafeBufferFree( bufptr ) ;
	
   	// indicate where to start adding on next pass, if any
   	First_of_this_block = i ;
   	
       	} // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    build_srvc_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_SrvcTable.Table[0], MIB_SrvcTable.Len,
          sizeof(SRVC_ENTRY), srvc_entry_cmp );

   //
   //
   // Cache table
   //
   //


   if(0 != MIB_SrvcTable.Len) {
   	
   	cache_table[C_SRVC_TABLE].acquisition_time = curr_time ;

   	cache_table[C_SRVC_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested
   //
   //
Exit:
   return nResult;
} // MIB_srvc_get

//
// MIB_srvc_cmp
//    Routine for sorting the srvcion table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl srvc_entry_cmp(
       IN const SRVC_ENTRY *A,
       IN const SRVC_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_srvc_cmp


//
//    None.
//
void build_srvc_entry_oids(
       )

{
AsnOctetString OSA ;
SRVC_ENTRY *SrvcEntry ;
unsigned i;

// start pointer at 1st guy in the table
SrvcEntry = MIB_SrvcTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_SrvcTable.Len ; i++)  {
   // for each entry in the srvc table

   OSA.stream =  SrvcEntry->svSvcName.stream;
   OSA.length =  SrvcEntry->svSvcName.length;
   OSA.dynamic = FALSE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &SrvcEntry->Oid );

   SrvcEntry++; // point to the next guy in the table

   } // for
} // build_srvc_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\srvr_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvr_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the domain server table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "srvr_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)	if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

int __cdecl srvr_entry_cmp(
       IN const DOM_SERVER_ENTRY *A,
       IN const DOM_SERVER_ENTRY *B
       ) ;

void build_srvr_entry_oids( );

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_srvr_lmget
//    Retrieve domain server table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_svsond_lmget()
{
    DWORD               entriesread;
    DWORD               totalentries;
    LPBYTE              bufptr;
    unsigned            lmCode;
    unsigned            i;
    SERVER_INFO_100     *DataTable;
    DOM_SERVER_ENTRY    *MIB_DomServerTableElement ;
    int                 First_of_this_block;
    time_t              curr_time ;
    SNMPAPI             nResult = SNMPAPI_NOERROR;
    DWORD               resumehandle=0;


    time(&curr_time);	// get the time


    //
    //
    // If cached, return piece of info.
    //
    //
    if((NULL != cache_table[C_SRVR_TABLE].bufptr) && 
       (curr_time < (cache_table[C_SRVR_TABLE].acquisition_time + cache_expire[C_SRVR_TABLE]))
      )
    { // it has NOT expired!
        goto Exit ; // the global table is valid
    }


    // free the old table  LOOK OUT!!
    MIB_DomServerTableElement = MIB_DomServerTable.Table ;

    // iterate over the whole table
    for(i=0; i<MIB_DomServerTable.Len ;i++)
    {
        // free any alloc'ed elements of the structure
        SnmpUtilOidFree(&(MIB_DomServerTableElement->Oid));
        SafeFree(MIB_DomServerTableElement->domServerName.stream);

        MIB_DomServerTableElement ++ ;  // increment table entry
    }
    SafeFree(MIB_DomServerTable.Table) ;	// free the base Table
    MIB_DomServerTable.Table = NULL ;	// just for safety
    MIB_DomServerTable.Len = 0 ;		// just for safety

    First_of_this_block = 0;
    do
    {
        //  as long as there is more data to process


        //
        //
        // Do network call to gather information and put it in a nice array
        //
        //
        lmCode = NetServerEnum(
                    NULL,			// local server NT_PROBLEM
		            100,			// level 100
		            &bufptr,		// data structure to return
		            MAX_PREFERRED_LENGTH,  
		            &entriesread,
		            &totalentries,
		            SV_TYPE_SERVER,
		            NULL,
       		        &resumehandle		//  resume handle
		        );

        DataTable = (SERVER_INFO_100 *) bufptr ;

        if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {
            // valid so process it, otherwise error

            if(0 == MIB_DomServerTable.Len)
            {
                // 1st time, alloc the whole table
                // alloc the table space
                MIB_DomServerTable.Table = SnmpUtilMemAlloc(totalentries * sizeof(DOM_SERVER_ENTRY) );
                if (MIB_DomServerTable.Table == NULL)
                {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
            }

            MIB_DomServerTableElement = MIB_DomServerTable.Table + First_of_this_block ;

            for(i=0; i<entriesread; i++)
            {
                // once for each entry in the buffer
                // increment the entry number

                MIB_DomServerTable.Len ++;

                // Stuff the data into each item in the table
                MIB_DomServerTableElement->domServerName.dynamic = TRUE;
#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                    &MIB_DomServerTableElement->domServerName.stream,
                    DataTable->sv100_name,
                    TRUE))
                {
                    MIB_DomServerTableElement->domServerName.stream = NULL;
                }
                else
                {
                    MIB_DomServerTableElement->domServerName.length =
                        strlen(MIB_DomServerTableElement->domServerName.stream);
                }
#else
                MIB_DomServerTableElement->domServerName.stream = SnmpUtilMemAlloc(strlen( DataTable->sv100_name ) + 1 );
                MIB_DomServerTableElement->domServerName.length = strlen( DataTable->sv100_name ) ;

                // client name
                memcpy(
                    MIB_DomServerTableElement->domServerName.stream,
                    DataTable->sv100_name,
                    strlen(DataTable->sv100_name)) ;
#endif

                MIB_DomServerTableElement ++ ;  // and table entry
                DataTable ++ ;  // advance pointer to next sess entry in buffer

            } // for each entry in the data table


            // free all of the lan man data
            SafeBufferFree( bufptr ) ;

            // indicate where to start adding on next pass, if any
            First_of_this_block = i ;

        } // if data is valid to process
        else
        {
            // if ERROR_NO_BROWSER_SERVERS_FOUND we are not running in an NetBIOS environment
            // in this case we will have an empty table.
            nResult = (lmCode == ERROR_NO_BROWSER_SERVERS_FOUND) ? SNMPAPI_NOERROR : SNMPAPI_ERROR;
            goto Exit;
        }

    } while (ERROR_MORE_DATA == lmCode) ;


    // iterate over the table populating the Oid field
    build_srvr_entry_oids();

    // Sort the table information using MSC QuickSort routine
    qsort( &MIB_DomServerTable.Table[0], MIB_DomServerTable.Len,
          sizeof(DOM_SERVER_ENTRY), srvr_entry_cmp );

    //
    //
    // Cache table
    //
    //

    if(0 != MIB_DomServerTable.Len)
    {
        cache_table[C_SRVR_TABLE].acquisition_time = curr_time ;
        cache_table[C_SRVR_TABLE].bufptr = bufptr ;
    }

    //
    //
    // Return piece of information requested
    //
    //
    Exit:
    return nResult;
} // MIB_srvr_get

//
// MIB_srvr_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl srvr_entry_cmp(
       IN const DOM_SERVER_ENTRY *A,
       IN const DOM_SERVER_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_srvr_cmp


//
//    None.
//
void build_srvr_entry_oids(
       )

{
AsnOctetString OSA ;
DOM_SERVER_ENTRY *DomServerEntry ;
unsigned i;

// start pointer at 1st guy in the table
DomServerEntry = MIB_DomServerTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_DomServerTable.Len ; i++)  {
   // for each entry in the session table

   OSA.stream = DomServerEntry->domServerName.stream ;
   OSA.length =  DomServerEntry->domServerName.length ;
   OSA.dynamic = FALSE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &DomServerEntry->Oid );

   DomServerEntry++; // point to the next guy in the table

   } // for

} // build_srvr_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\srvr_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvr_tbl.h

Abstract:

    Define all of the structures and routines used in the server table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef srvr_tbl_h
#define srvr_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SRVR_NAME_FIELD        1

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the domain server table
typedef struct dom_server_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString domServerName; // Index
	   } DOM_SERVER_ENTRY;

   // Domain server table definition
typedef struct
           {
	   UINT             Len;
	   DOM_SERVER_ENTRY *Table;
           } DOM_SERVER_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern DOM_SERVER_TABLE MIB_DomServerTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_svsond_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* srvr_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\test.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    test.c

Abstract:

    Test the LM MIB and its supporting functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mib.h"
#include "mibfuncs.h"
#include "hash.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

SNMPAPI SnmpExtensionQuery(
	   IN AsnInteger ReqType,               // 1157 Request type
	   IN OUT RFC1157VarBindList *VarBinds, // Var Binds to resolve
	   OUT AsnInteger *ErrorStatus,         // Error status returned
	   OUT AsnInteger *ErrorIndex           // Var Bind containing error
	   );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

BYTE pBuffer[2000];
UINT nLength;
SnmpMgmtCom Msg;
MIB_ENTRY *MibPtr;
void *pResult;

void main( )

{

   //
   // Init hashing system
   //
   MIB_HashInit();

   //
   // Title
   //
   printf( "Tests for MIB root:  " );
   SnmpUtilPrintOid( &MIB_OidPrefix ); printf( "\n--------------------------\n\n" );

   //
   // Display significant Mib variables
   //
   printf( "Common start:  " );
   SnmpUtilPrintOid( &Mib[MIB_COM_START].Oid );
   putchar( '\n' );
   printf( "Server start:  " );
   SnmpUtilPrintOid( &Mib[MIB_SV_START].Oid );
   putchar( '\n' );
   printf( "Workstation start:  " );
   SnmpUtilPrintOid( &Mib[MIB_WKSTA_START].Oid );
   putchar( '\n' );
   printf( "Domain start:  " );
   SnmpUtilPrintOid( &Mib[MIB_DOM_START].Oid );
   putchar( '\n' );

   printf( "Last MIB variable:  " );
   SnmpUtilPrintOid( &Mib[MIB_num_variables-1].Oid );
   putchar( '\n' );
   putchar( '\n' );

   //
   // Specific tests for integrity
   //

   printf( "FIRST leaf get\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 1, 1, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "LAST leaf get\n" );

      {
#if 1
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 5, 0 };
#else
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 7, 0 };
#endif
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET on an AGGREGATE\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET on a TABLE root\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 3, 8, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET on a NON existent variable\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 100, 8 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on hole with MIB-TABLE following\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on hole with MIB-AGGREGATE following\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 26, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on hole with LEAF following\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on variable BEFORE Beginning of LM MIB\n" );

      {
      UINT itemn[]                 = { 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on variable past end of MIB\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 2 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on Server Description\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 1, 0 };
      BYTE *Value                  = "This server sux";
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_RFC1213_DISPSTRING;
      varBinds.list[0].value.asnValue.string.stream = Value;
      varBinds.list[0].value.asnValue.string.length = strlen( Value );
      varBinds.list[0].value.asnValue.string.dynamic = FALSE;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         printf( "New Value:  " );
	 SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	 }
      printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "Try and SET Server Description with WRONG type\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 1, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_INTEGER;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         printf( "New Value:  " );
         SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	 }

      printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "Try and SET a LEAF that is READ-ONLY\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 1, 1, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_INTEGER;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         printf( "New Value:  " );
	 SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	 }
      printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on the odom table to add entry\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 4, 1, 1, 4, 'T', 'O', 'D', 'D' };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_RFC1213_DISPSTRING;
      varBinds.list[0].value.asnValue.string.length = 4;
      varBinds.list[0].value.asnValue.string.stream = "TODD";
      varBinds.list[0].value.asnValue.string.dynamic = FALSE;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on root of session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );

      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on root entry of session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );

      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on an invalid field in session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      // Get entry in the session table to delete
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );

      // Adjust to set a bad field
      varBinds.list[0].name.ids[11] = 7;
      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET with invalid type on field in session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      // Get entry in the session table to delete
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );

      // Adjust to set the svSesState to DELETED
      varBinds.list[0].name.ids[11]  = 8;
      varBinds.list[0].value.asnType = ASN_NULL;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on non-existent entry in session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20, 1, 8, 1, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );

      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on the session table to delete entry\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      // Get entry in the session table to delete
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );

      // Adjust to set the svSesState to DELETED
      varBinds.list[0].name.ids[11] = 8;
      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;

      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT starting from ROOT of LM MIB\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus;
      AsnInteger errorIndex;
      BOOL Continue                = TRUE;
      time_t Time;

      while ( Continue )
         {
	 errorStatus = 0;
	 errorIndex  = 0;
         varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
         varBinds.len = 1;
SnmpUtilOidCpy( &varBinds.list[0].name, &MIB_OidPrefix );
#if 0
         varBinds.list[0].name.idLength = MIB_PREFIX_LEN;
         varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                               varBinds.list[0].name.idLength );
         memcpy( varBinds.list[0].name.ids, &itemn,
                 sizeof(UINT)*varBinds.list[0].name.idLength );
#endif
         varBinds.list[0].value.asnType = ASN_NULL;

         do
            {
            Time = time( NULL );
            printf( "Time:  %s", ctime(&Time) );
	    printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
                                        printf( "   " );
            SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                                &varBinds,
			        &errorStatus,
			        &errorIndex
                                );
            printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
	    if ( errorStatus )
	       {
               printf( "\nErrorstatus:  %lu\n\n", errorStatus );
	       }
	    else
	       {
               printf( "\n  =  " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	       }
            putchar( '\n' );
            }
         while ( varBinds.list[0].name.ids[MIB_PREFIX_LEN-1] != 1 );

         // Free the memory
         SnmpUtilVarBindListFree( &varBinds );

	 // Prompt for next pass
	 printf( "Press ENTER to continue, CTRL-C to quit\n" );
	 getchar();
         } // while continue
      }
} // test

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\srvc_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvc_tbl.c

Abstract:

    All routines to support operations on the LM MIB Service Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "srvc_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Service table
static UINT                srvcSubids[] = { 2, 3, 1 };
static AsnObjectIdentifier MIB_SrvcPrefix = { 3, srvcSubids };

SRVC_TABLE   MIB_SrvcTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SRVC_FIELD_SUBID       (MIB_SrvcPrefix.idLength+MIB_OidPrefix.idLength)

#define SRVC_FIRST_FIELD       SRVC_NAME_FIELD
#define SRVC_LAST_FIELD        SRVC_PAUSED_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_srvcs_get(
        IN OUT RFC1157VarBind *VarBind
	);

int MIB_srvcs_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_srvcs_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_srvcs_func
//    High level routine for handling operations on the Service table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_srvcs_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Service table with the info from server
         if ( SNMPAPI_ERROR == MIB_srvcs_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_SrvcTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { SRVC_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };


         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcTable.Table[0].Oid );
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_srvcs_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Service Table with the info from server
         if ( SNMPAPI_ERROR == MIB_srvcs_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[SRVC_FIELD_SUBID];

        // Lookup OID in table
         if (Field < SRVC_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = SRVC_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > SRVC_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_srvcs_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_SrvcTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > SRVC_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_SrvcTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > SRVC_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcTable.Table[Entry].Oid );
         }

         ErrStat = MIB_srvcs_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_srvcs_func



//
// MIB_srvcs_get
//    Retrieve Service Table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_srvcs_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[SRVC_FIELD_SUBID] < SRVC_FIRST_FIELD ||
       VarBind->name.ids[SRVC_FIELD_SUBID] > SRVC_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Service Table with the info from server
   if ( SNMPAPI_ERROR == MIB_srvcs_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_srvcs_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_srvcs_copyfromtable( Entry, VarBind->name.ids[SRVC_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_srvcs_get



//
// MIB_srvcs_match
//    Match the target OID with a location in the Service Table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_srvcs_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_SrvcPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_SrvcPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_SrvcTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_SrvcTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_srvcs_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_srvcs_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SRVC_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_SrvcTable.Table[Entry].svSvcName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_SrvcTable.Table[Entry].svSvcName.stream,
                       MIB_SrvcTable.Table[Entry].svSvcName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_SrvcTable.Table[Entry].svSvcName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SRVC_INSTALLED_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
	                        MIB_SrvcTable.Table[Entry].svSvcInstalledState;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SRVC_OPERATING_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
	                        MIB_SrvcTable.Table[Entry].svSvcOperatingState;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SRVC_UNINSTALLED_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
	                  MIB_SrvcTable.Table[Entry].svSvcCanBeUninstalled;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SRVC_PAUSED_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
	                            MIB_SrvcTable.Table[Entry].svSvcCanBePaused;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Services Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_srvcs_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\srvr_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvr_tbl.c

Abstract:

    Routines to perform operations on the Domain Server Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "srvr_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Domain Server table
static UINT                svsondSubids[] = { 4, 6, 1 };
static AsnObjectIdentifier MIB_DomServerPrefix = { 3, svsondSubids };

DOM_SERVER_TABLE MIB_DomServerTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SRVR_FIELD_SUBID   (MIB_DomServerPrefix.idLength+MIB_OidPrefix.idLength)

#define SRVR_FIRST_FIELD       SRVR_NAME_FIELD
#define SRVR_LAST_FIELD        SRVR_NAME_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_svsond_get(
        IN OUT RFC1157VarBind *VarBind
	);

int MIB_svsond_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_svsond_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_svsond_func
//    High level routine for handling operations on the Domain Server table
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
UINT MIB_svsond_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Domain Server table with the info from server
         if ( SNMPAPI_ERROR == MIB_svsond_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_DomServerTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { SRVR_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };


         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerTable.Table[0].Oid );
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_svsond_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Domain Server table with the info from server
         if ( SNMPAPI_ERROR == MIB_svsond_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[SRVR_FIELD_SUBID];

         // Lookup OID in table
         if (Field < SRVR_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = SRVR_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > SRVR_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
            Found = MIB_svsond_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_DomServerTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > SRVR_LAST_FIELD )
//               {
                if ( MibPtr->MibNext == NULL )
                   {
                   ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                   goto Exit;
                   }
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_DomServerTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > SRVR_LAST_FIELD )
                  {
                  if ( MibPtr->MibNext == NULL )
                       {
                       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                       goto Exit;
                       }
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerTable.Table[Entry].Oid );
         }

         ErrStat = MIB_svsond_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_svsond_func



//
// MIB_svsond_get
//    Retrieve Domain Server table information.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
UINT MIB_svsond_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[SRVR_FIELD_SUBID] < SRVR_FIRST_FIELD ||
       VarBind->name.ids[SRVR_FIELD_SUBID] > SRVR_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Domain Server table with the info from server
   if ( SNMPAPI_ERROR == MIB_svsond_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_svsond_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_svsond_copyfromtable( Entry, VarBind->name.ids[SRVR_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_svsond_get



//
// MIB_svsond_match
//    Match the target OID with a location in the Domain Server table
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None
//
int MIB_svsond_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_DomServerPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_DomServerPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_DomServerTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_DomServerTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



UINT MIB_svsond_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SRVR_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_DomServerTable.Table[Entry].domServerName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomServerTable.Table[Entry].domServerName.stream,
                       MIB_DomServerTable.Table[Entry].domServerName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomServerTable.Table[Entry].domServerName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Domain Server Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_svsond_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\user_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    user_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the user table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "user_tbl.h"
#include "lmcache.h"


//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------


int __cdecl user_entry_cmp(
       IN const USER_ENTRY *A,
       IN const USER_ENTRY *B
       ) ;

void build_user_entry_oids( );

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_user_lmget
//    Retrieve print queue table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_users_lmget(
           )

{

DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
USER_INFO_0 *DataTable;
USER_ENTRY *MIB_UserTableElement ;
int First_of_this_block;
LPSTR ansi_string;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
DWORD resumehandle=0;


   time(&curr_time);    // get the time


   //
   //
   // If cached, return piece of info.
   //
   //


   if((NULL != cache_table[C_USER_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_USER_TABLE].acquisition_time
                 + cache_expire[C_USER_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit ; // the global table is valid

        }

   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

     //
     // remember to free the existing data
     //

     MIB_UserTableElement = MIB_UserTable.Table ;

     // iterate over the whole table
     for(i=0; i<MIB_UserTable.Len ;i++)
     {
        // free any alloc'ed elements of the structure
        SnmpUtilOidFree(&(MIB_UserTableElement->Oid));
        SafeFree(MIB_UserTableElement->svUserName.stream);

        MIB_UserTableElement ++ ;  // increment table entry
     }
     SafeFree(MIB_UserTable.Table) ;    // free the base Table
     MIB_UserTable.Table = NULL ;       // just for safety
     MIB_UserTable.Len = 0 ;            // just for safety



#if 0 // done above
   // init the length
   MIB_UserTable.Len = 0;
#endif
   First_of_this_block = 0;

   do {  //  as long as there is more data to process


        lmCode =
        NetUserEnum(    NULL,                   // local server
                        0,                      // level 0, no admin priv.
            FILTER_NORMAL_ACCOUNT,
                        &bufptr,                // data structure to return
                        MAX_PREFERRED_LENGTH,
                        &entriesread,
                        &totalentries,
                        &resumehandle           //  resume handle
                        );


    DataTable = (USER_INFO_0 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error

        if(0 == MIB_UserTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_UserTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(USER_ENTRY) );
                // prefix bugs 445183 and 445184
                if (MIB_UserTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit; 
                }
        }

        MIB_UserTableElement = MIB_UserTable.Table + First_of_this_block ;

        for(i=0; i<entriesread; i++) {  // once for each entry in the buffer


                // increment the entry number

                MIB_UserTable.Len ++;

                // Stuff the data into each item in the table

                // convert the undocumented unicode to something readable
                SnmpUtilUnicodeToUTF8(
                        &ansi_string,
                        DataTable->usri0_name,
                        TRUE ); // auto alloc the space for ansi

                // client name
                MIB_UserTableElement->svUserName.stream = ansi_string;
                MIB_UserTableElement->svUserName.length =
                                strlen( ansi_string ) ;
                MIB_UserTableElement->svUserName.dynamic = TRUE;
                ansi_string = NULL;
                MIB_UserTableElement ++ ;  // and table entry

                DataTable ++ ;  // advance pointer to next sess entry in buffer

        } // for each entry in the data table

        // free all of the lan man data
        SafeBufferFree( bufptr ) ;

        // indicate where to start adding on next pass, if any
        First_of_this_block = i ;

        } // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    build_user_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_UserTable.Table[0], MIB_UserTable.Len,
          sizeof(USER_ENTRY), user_entry_cmp );

   //
   //
   // Cache table
   //
   //


   if(0 != MIB_UserTable.Len) {

        cache_table[C_USER_TABLE].acquisition_time = curr_time ;

        cache_table[C_USER_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested
   //
   //
Exit:
   return nResult;
} // MIB_user_get

//
// MIB_user_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl user_entry_cmp(
       IN const USER_ENTRY *A,
       IN const USER_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_user_cmp


//
//    None.
//
void build_user_entry_oids(
       )

{
AsnOctetString OSA ;
USER_ENTRY *UserEntry ;
unsigned i;

// start pointer at 1st guy in the table
UserEntry = MIB_UserTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_UserTable.Len ; i++)  {
   // for each entry in the session table

   OSA.stream = UserEntry->svUserName.stream ;
   OSA.length =  UserEntry->svUserName.length ;
   OSA.dynamic = FALSE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &UserEntry->Oid );

   UserEntry++; // point to the next guy in the table

   } // for

} // build_user_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\testdll.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    testdll.c

Abstract:

    LAN Manager MIB 2 Extension Agent DLL.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>


//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

//#include <stdio.h>


//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "hash.h"
#include "mib.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

DWORD timeZero = 0;


//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

BOOL DllEntryPoint(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;

        } // end switch()

    return TRUE;

    } // end DllEntryPoint()


BOOL SnmpExtensionInit(
    IN  DWORD  timeZeroReference,
    OUT HANDLE *hPollForTrapEvent,
    OUT AsnObjectIdentifier *supportedView)
    {
    // record time reference from extendible agent
    timeZero = timeZeroReference;

    // setup trap notification
    *hPollForTrapEvent = NULL;

    // tell extendible agent what view this extension agent supports
    *supportedView = MIB_OidPrefix; // NOTE!  structure copy

    // Initialize MIB access hash table
    MIB_HashInit();

    return TRUE;

    } // end SnmpExtensionInit()


BOOL SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger          *genericTrap,
    OUT AsnInteger          *specificTrap,
    OUT AsnTimeticks        *timeStamp,
    OUT RFC1157VarBindList  *variableBindings)
    {

    return FALSE;

    } // end SnmpExtensionTrap()


// This function is implemented in file RESOLVE.C

#if 0
BOOL SnmpExtensionQuery(
    IN BYTE requestType,
    IN OUT RFC1157VarBindList *variableBindings,
    OUT AsnInteger *errorStatus,
    OUT AsnInteger *errorIndex)
    {

    } // end SnmpExtensionQuery()
#endif


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\user_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    user_tbl.c

Abstract:

    All routines to perform operations on the User Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "user_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Users table
static UINT                userSubids[] = { 2, 25, 1 };
static AsnObjectIdentifier MIB_UserPrefix = { 3, userSubids };

USER_TABLE MIB_UserTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define USER_FIELD_SUBID       (MIB_UserPrefix.idLength+MIB_OidPrefix.idLength)

#define USER_FIRST_FIELD       USER_NAME_FIELD
#define USER_LAST_FIELD        USER_NAME_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_users_get(
        IN OUT RFC1157VarBind *VarBind
	);

int MIB_users_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_users_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_users_func
//    High level routine for handling operations on the Users table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_users_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Users Table with the info from server
         if ( SNMPAPI_ERROR == MIB_users_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_UserTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { USER_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };

         // prefix bug 445189
         AsnObjectIdentifier tmpOid;
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserTable.Table[0].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_users_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Users table with the info from server
         if ( SNMPAPI_ERROR == MIB_users_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[USER_FIELD_SUBID];

         // Lookup OID in table
         if (Field < USER_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = USER_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > USER_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_users_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_UserTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > USER_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_UserTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > USER_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         AsnObjectIdentifier tmpOid; // Prefix bug 445189

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

          // Prefix bug 445189
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserTable.Table[Entry].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_users_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_users_func



//
// MIB_users_get
//    Retrieve Users table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_users_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[USER_FIELD_SUBID] < USER_FIRST_FIELD ||
       VarBind->name.ids[USER_FIELD_SUBID] > USER_LAST_FIELD)
   {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
   }

   // Fill the Users table with the info from server
   if ( SNMPAPI_ERROR == MIB_users_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_users_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_users_copyfromtable( Entry,
                                      VarBind->name.ids[USER_FIELD_SUBID],
                                      VarBind );

Exit:
   return ErrStat;
} // MIB_users_get



//
// MIB_users_match
//    Match the target OID with a location in the Users table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_users_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_UserPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_UserPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_UserTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_UserTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_users_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_users_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case USER_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_UserTable.Table[Entry].svUserName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_UserTable.Table[Entry].svUserName.stream,
                       MIB_UserTable.Table[Entry].svUserName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_UserTable.Table[Entry].svUserName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Users Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_users_copyfromtable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\user_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    user_tbl.h

Abstract:

    Define all structures and routines for user table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef user_tbl_h
#define user_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define USER_NAME_FIELD        1

//--------------------------- PUBLIC STRUCTS --------------------------------


   // Entries in the user table
typedef struct user_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString svUserName; // Index
	   } USER_ENTRY;

   // User table definition
typedef struct
           {
	   UINT       Len;
	   USER_ENTRY *Table;
           } USER_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern USER_TABLE       MIB_UserTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_users_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* user_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\uses_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uses_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the workstation uses table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "uses_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

int __cdecl uses_entry_cmp(
       IN const WKSTA_USES_ENTRY *A,
       IN const WKSTA_USES_ENTRY *B
       ) ;

void build_uses_entry_oids( );

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_wsuses_lmget
//    Retrieve workstation uses table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_wsuses_lmget(
           )

{

DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
USE_INFO_1 *DataTable;
WKSTA_USES_ENTRY *MIB_WkstaUsesTableElement ;
int First_of_this_block;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
DWORD resumehandle=0;


   time(&curr_time);    // get the time


   //
   //
   // If cached, return piece of info.
   //
   //

   if((NULL != cache_table[C_USES_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_USES_TABLE].acquisition_time
                 + cache_expire[C_USES_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit ; // the global table is valid

        }


   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

   // free the old table  LOOK OUT!!


     MIB_WkstaUsesTableElement = MIB_WkstaUsesTable.Table ;

     // iterate over the whole table
     for(i=0; i<MIB_WkstaUsesTable.Len ;i++)
     {
        // free any alloc'ed elements of the structure
        SnmpUtilOidFree(&(MIB_WkstaUsesTableElement->Oid));
        SafeFree(MIB_WkstaUsesTableElement->useLocalName.stream);
        SafeFree(MIB_WkstaUsesTableElement->useRemote.stream);

        MIB_WkstaUsesTableElement ++ ;  // increment table entry
     }
     SafeFree(MIB_WkstaUsesTable.Table) ;       // free the base Table
     MIB_WkstaUsesTable.Table = NULL ;  // just for safety
     MIB_WkstaUsesTable.Len = 0 ;               // just for safety


#if 0 // done above
   // init the length
   MIB_WkstaUsesTable.Len = 0;
#endif
   First_of_this_block = 0;

   do {  //  as long as there is more data to process

   lmCode =
        NetUseEnum(     NULL,                   // local server
        1,                      // level 1, no admin priv.
        &bufptr,                // data structure to return
        MAX_PREFERRED_LENGTH,
        &entriesread,
        &totalentries,
        &resumehandle           //  resume handle
        );


    DataTable = (USE_INFO_1 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error

        if(0 == MIB_WkstaUsesTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_WkstaUsesTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(WKSTA_USES_ENTRY) );
                // prefix bugs 445182
                if (MIB_WkstaUsesTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit; 
                }
        }

        MIB_WkstaUsesTableElement = MIB_WkstaUsesTable.Table + First_of_this_block ;

        for(i=0; i<entriesread; i++) {  // once for each entry in the buffer


                // increment the entry number

                MIB_WkstaUsesTable.Len ++;

                // Stuff the data into each item in the table

                // client name
                MIB_WkstaUsesTableElement->useLocalName.dynamic = TRUE;

#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_WkstaUsesTableElement->useLocalName.stream,
                        DataTable->ui1_local,
                        TRUE))
                {
                    MIB_WkstaUsesTableElement->useLocalName.length = 0;
                    MIB_WkstaUsesTableElement->useLocalName.stream = NULL;
                }
                else
                {
                    MIB_WkstaUsesTableElement->useLocalName.length =
                        strlen(MIB_WkstaUsesTableElement->useLocalName.stream);
                }
#else
                MIB_WkstaUsesTableElement->useLocalName.stream = SnmpUtilMemAlloc (
                                strlen( DataTable->ui1_local ) + 1 ) ;
                MIB_WkstaUsesTableElement->useLocalName.length =
                                strlen( DataTable->ui1_local ) ;
                memcpy( MIB_WkstaUsesTableElement->useLocalName.stream,
                        DataTable->ui1_local,
                        strlen( DataTable->ui1_local ) ) ;
#endif

                // remote name
                MIB_WkstaUsesTableElement->useRemote.dynamic = TRUE;

#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_WkstaUsesTableElement->useRemote.stream,
                        DataTable->ui1_remote,
                        TRUE))
                {
                    MIB_WkstaUsesTableElement->useRemote.length = 0;
                    MIB_WkstaUsesTableElement->useRemote.stream = NULL;
                }
                else
                {
                    MIB_WkstaUsesTableElement->useRemote.length = 
                        strlen(MIB_WkstaUsesTableElement->useRemote.stream);
                }
#else
                MIB_WkstaUsesTableElement->useRemote.stream = SnmpUtilMemAlloc (
                                strlen( DataTable->ui1_remote ) + 1 ) ;
                MIB_WkstaUsesTableElement->useRemote.length =
                                strlen( DataTable->ui1_remote ) ;

                memcpy( MIB_WkstaUsesTableElement->useRemote.stream,
                        DataTable->ui1_remote,
                        strlen( DataTable->ui1_remote ) ) ;
#endif

                // status
                MIB_WkstaUsesTableElement->useStatus =
                                DataTable->ui1_status ;


                MIB_WkstaUsesTableElement ++ ;  // and table entry

                DataTable ++ ;  // advance pointer to next sess entry in buffer

        } // for each entry in the data table

        // free all of the lan man data
        SafeBufferFree( bufptr ) ;


        // indicate where to start adding on next pass, if any
        First_of_this_block = i ;

        } // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    build_uses_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_WkstaUsesTable.Table[0], MIB_WkstaUsesTable.Len,
          sizeof(WKSTA_USES_ENTRY), uses_entry_cmp );

   //
   //
   // Cache table
   //
   //

   if(0 != MIB_WkstaUsesTable.Len) {

        cache_table[C_USES_TABLE].acquisition_time = curr_time ;

        cache_table[C_USES_TABLE].bufptr = bufptr ;
   }


   //
   //
   // Return piece of information requested
   //
   //
Exit:
   return nResult;
} // MIB_uses_get

//
// MIB_uses_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl uses_entry_cmp(
       IN const WKSTA_USES_ENTRY *A,
       IN const WKSTA_USES_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_uses_cmp


//
//    None.
//
void build_uses_entry_oids(
       )

{
AsnOctetString OSA ;
AsnObjectIdentifier RemoteOid ;
WKSTA_USES_ENTRY *WkstaUsesEntry ;
unsigned i;

// start pointer at 1st guy in the table
WkstaUsesEntry = MIB_WkstaUsesTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_WkstaUsesTable.Len ; i++)  {
   // for each entry in the session table

   // copy the local name into the oid buffer first
   MakeOidFromStr( &WkstaUsesEntry->useLocalName, &WkstaUsesEntry->Oid );

   // copy the remote name into a temporary oid buffer
   MakeOidFromStr( &WkstaUsesEntry->useRemote, &RemoteOid );

   // append the two entries forming the index
   SnmpUtilOidAppend( &WkstaUsesEntry->Oid, &RemoteOid );

   // free the temporary buffer
   SnmpUtilOidFree( &RemoteOid );

   WkstaUsesEntry++; // point to the next guy in the table

   } // for

} // build_uses_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\uses_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uses_tbl.c

Abstract:

    Routines to perform operations on the Workstation Uses table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "uses_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Uses table
static UINT                usesSubids[] = { 3, 8, 1 };
static AsnObjectIdentifier MIB_UsesPrefix = { 3, usesSubids };

WKSTA_USES_TABLE MIB_WkstaUsesTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define USES_FIELD_SUBID       (MIB_UsesPrefix.idLength+MIB_OidPrefix.idLength)

#define USES_FIRST_FIELD       USES_LOCAL_FIELD
#define USES_LAST_FIELD        USES_STATUS_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------


//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_wsuses_get(
        IN OUT RFC1157VarBind *VarBind
        );

int MIB_wsuses_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       );

UINT MIB_wsuses_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_wsuses_func
//    High level routine for handling operations on the uses table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_wsuses_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Uses table with the info from server
         if ( SNMPAPI_ERROR == MIB_wsuses_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_WkstaUsesTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { USES_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };


         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_UsesPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_WkstaUsesTable.Table[0].Oid );
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_wsuses_get( VarBind );
         break;

      case MIB_ACTION_GETNEXT:
         // Fill the Uses table with the info from server
         if ( SNMPAPI_ERROR == MIB_wsuses_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Determine which field
         Field = VarBind->name.ids[USES_FIELD_SUBID];

         // Lookup OID in table
         if (Field < USES_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = USES_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > USES_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_wsuses_match( &VarBind->name, &Entry, TRUE );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_WkstaUsesTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > USES_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_WkstaUsesTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > USES_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         SnmpUtilOidFree( &VarBind->name );
         SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
         SnmpUtilOidAppend( &VarBind->name, &MIB_UsesPrefix );
         SnmpUtilOidAppend( &VarBind->name, &FieldOid );
         SnmpUtilOidAppend( &VarBind->name, &MIB_WkstaUsesTable.Table[Entry].Oid );
         }

         ErrStat = MIB_wsuses_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_wsuses_func



//
// MIB_wsuses_get
//    Retrieve Uses table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_wsuses_get(
        IN OUT RFC1157VarBind *VarBind
        )

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[USES_FIELD_SUBID] < USES_FIRST_FIELD ||
       VarBind->name.ids[USES_FIELD_SUBID] > USES_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Uses table with the info from server
   if ( SNMPAPI_ERROR == MIB_wsuses_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_wsuses_match( &VarBind->name, &Entry, FALSE );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_wsuses_copyfromtable( Entry, VarBind->name.ids[USES_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_wsuses_get



//
// MIB_wsuses_match
//    Match the target OID with a location in the Uses table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_wsuses_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;

   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_UsesPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_UsesPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_WkstaUsesTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_WkstaUsesTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;
         if (Next) {
             while ( ( (*Pos) + 1 < MIB_WkstaUsesTable.Len ) &&
                     !SnmpUtilOidCmp( &TempOid, &MIB_WkstaUsesTable.Table[(*Pos)+1].Oid)) {
                 (*Pos)++;
             }
         }

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
} // MIB_wsuses_match



//
// MIB_wsuses_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_wsuses_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case USES_LOCAL_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_WkstaUsesTable.Table[Entry].useLocalName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_WkstaUsesTable.Table[Entry].useLocalName.stream,
                       MIB_WkstaUsesTable.Table[Entry].useLocalName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_WkstaUsesTable.Table[Entry].useLocalName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case USES_REMOTE_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_WkstaUsesTable.Table[Entry].useRemote.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_WkstaUsesTable.Table[Entry].useRemote.stream,
                       MIB_WkstaUsesTable.Table[Entry].useRemote.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_WkstaUsesTable.Table[Entry].useRemote.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case USES_STATUS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_WkstaUsesTable.Table[Entry].useStatus;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error WorkstationUses Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_wsuses_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\eaload.h ===
#ifndef _EALOAD_H
#define _EALOAD_H

// Primary Module Parameters
//---------------------------
// "ParameterMessageFile" param flag
#define PMP_PARAMMSGFILE    0x00000001

typedef struct
{
    DWORD   dwParams;   // bitmask of PMP_* values, identifying the valid parameters in the structure
    HMODULE hModule;    // place holder for the "ParameterMessageFile" param
} tPrimaryModuleParms;

// Returns in 'Params' the requested parameters (identified by Params.dwParams field)
DWORD LoadPrimaryModuleParams(
         IN  HKEY hkLogFile,               // opened registry key to HKLM\System\CurrentControlSet\Services\EventLog\<LogFile>
         IN  LPCTSTR tchPrimModule,        // name of the PrimaryModule as it is defined in the "PrimaryModule" value of the key above
         OUT tPrimaryModuleParms &Params); // allocated output buffer, ready to receive the values for the requested parameters

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\lmmib2\uses_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uses_tbl.h

Abstract:

    Define the structures and routines used in the workstation uses table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef uses_tbl_h
#define uses_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define USES_LOCAL_FIELD       1
#define USES_REMOTE_FIELD      2
#define USES_STATUS_FIELD      3

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the workstation uses table
typedef struct wksta_uses_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString    useLocalName; // Index
	   AsnDisplayString    useRemote;    // Index
	   AsnInteger          useStatus;
	   } WKSTA_USES_ENTRY;

   // Workstation uses table definition
typedef struct
           {
	   UINT             Len;
	   WKSTA_USES_ENTRY *Table;
           } WKSTA_USES_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern WKSTA_USES_TABLE MIB_WkstaUsesTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_wsuses_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* uses_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpeldl.h ===
#ifndef SNMPELDLL_H
#define SNMPELDLL_H

extern  DWORD           SnmpEvLogProc(void);
extern  HANDLE          hMutex;                                 // handle for mutex object
extern  VOID            WriteTrace(UINT nLvl, LPSTR CONST szStuff, ...);
extern  TCHAR           szTraceFileName[];                      // trace filename
extern  DWORD           nTraceLevel;                            // trace level
extern  BOOL            fTraceFileName;                         // trace filename param existance flag

        LPTSTR          lpszEventLogs = (LPTSTR) NULL;          // pointer to event log name array
        PHANDLE         phEventLogs = (PHANDLE) NULL;           // Pointer to event log handle array
        PHMODULE        phPrimHandles = (PHMODULE) NULL;        // pointer to primary module handle array
        UINT            uNumEventLogs = 0;                      // Number of event logs present
        INT             iLogNameSize = 0;                       // size of event log name array
        UINT            nMaxTrapSize = 0;                       // maximum trap size

        HKEY            hkRegResult = (HKEY) NULL;              // handle to Parameters registry entry
        HANDLE          hWriteEvent;                            // handle to write log events
        HANDLE          hStopAll;                               // handle to global dll shutdown event
        HANDLE          hServThrd;                              // handle to SNMPELPT thread
        HANDLE          hEventNotify;                           // handle to notify SNMPELDL that a trap is ready to process
        HANDLE          hRegChanged;                            // handle to registry key changed event

        BOOL            fGlobalTrim = TRUE;                     // global message trimming flag (trim msg first or insertion strings first)
        BOOL            fThresholdEnabled = TRUE;               // global threshold checking enabled flag
        BOOL            fTrimFlag = FALSE;                      // global trimming flag (do or don't do trimming at all)
        BOOL            fTrapSent = FALSE;                      // global trap sent flag
        BOOL            fRegNotify = FALSE;                     // registry notification initialization flag
        BOOL            fRegOk = FALSE;                         // registry notification in effect flag
        BOOL            fLogInit = FALSE;                       // indicate log file registry information not yet read
        BOOL            fThreshold = FALSE;                     // global performance threshold flag
        BOOL            fSendThresholdTrap = FALSE;             // indicator to send threshold reached trap
        BOOL            fDoLogonEvents = TRUE;                  // do we need to send logon events

        TCHAR           szBaseOID[MAX_PATH+1] = TEXT("");       // base enterprise OID
        TCHAR           szSupView[MAX_PATH+1] = TEXT("");       // supported view OID

        DWORD           dwTimeZero;                             // time zero reference
        DWORD           dwThresholdCount;                       // threshold count for performance
        DWORD           dwThresholdTime;                        // time in seconds for threshold for performance
        DWORD           dwTrapCount = 0;                        // number of traps sent
        DWORD           dwTrapStartTime = 0;                    // time when first trap in time period sent
        DWORD           dwLastBootTime = 0;                     // time the last boot occurred
        DWORD           dwTrapQueueSize = 0;

        // WinSE Bug# 15128, Windows Bug# 293698  
        // default is INFINITE ==> no polling (wait for system notification)
        DWORD           g_dwEventLogPollTime = (DWORD)INFINITE; // time in millsecs to poll for event logs

        PVarBindQueue   lpVarBindQueue = (PVarBindQueue) NULL;  // pointer to first varbind queue entry
        PSourceHandleList   lpSourceHandleList = (PSourceHandleList) NULL;  // pointer to first source/handle entry

        AsnObjectIdentifier thresholdOID;                       // OID used for threshold reached trap
        RFC1157VarBindList  thresholdVarBind;                   // varbind list used for threshold reached trap
const   TCHAR           lpszThreshold[] = TEXT("SNMP EventLog Extension Agent is quiescing trap processing due to performance threshold parameters.");

#endif                          // end of snmpeldl.h definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\eaload.cpp ===
#include <windows.h>        // windows definitions
#include <snmp.h>           // snmp definitions
#include "snmpelea.h"       // global dll definitions
#include "snmpelmg.h"
#include "snmpelep.h"
#include "EALoad.h"

// Returns in 'Params' the requested parameters (identified by Params.dwParams field)
DWORD LoadPrimaryModuleParams(
         IN  HKEY hkLogFile,               // opened registry key to HKLM\System\CurrentControlSet\Services\EventLog\<LogFile>
         IN  LPCTSTR tchPrimModule,        // name of the PrimaryModule as it is defined in the "PrimaryModule" value of the key above
         OUT tPrimaryModuleParms &Params)  // allocated output buffer, ready to receive the values for the requested parameters
{
    DWORD retCode;
    HKEY  hkPrimaryModule;

    // open the 'HKLM\SYSTEM\CurrentControlSet\Services\EventLog\<LogFile\<PrimaryModule>' registry key
    retCode = RegOpenKeyEx(
				hkLogFile,
				tchPrimModule,
				0,
				KEY_READ,
				&hkPrimaryModule);
    if (retCode != ERROR_SUCCESS)
        return retCode;

    if (Params.dwParams & PMP_PARAMMSGFILE) // "ParameterMessageFile" is requested
    {
        DWORD dwType;
        TCHAR tszParamMsgFileName[MAX_PATH+1];
        DWORD dwParamMsgFileLen = MAX_PATH+1;

        // get the 'ParameterMessageFile' value from the '<PrimaryModule>' key
		retCode = RegQueryValueEx(
				    hkPrimaryModule,
				    EXTENSION_PARM_MODULE,
				    0,
				    &dwType,
				    (LPBYTE) tszParamMsgFileName,
				    &dwParamMsgFileLen);
        if (retCode == ERROR_SUCCESS)
        {
            TCHAR tszExpandedFileName[MAX_PATH+1];

            if (ExpandEnvironmentStrings(
                    tszParamMsgFileName,
                    tszExpandedFileName,
                    MAX_PATH+1) > 0)
            {
                Params.hModule = (HMODULE) LoadLibraryEx(tszExpandedFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
                if (Params.hModule == NULL)
                {
                    retCode = GetLastError();
                    WriteLog(SNMPELEA_CANT_LOAD_PRIM_DLL, tszParamMsgFileName, retCode);
                }
            }
            else
                retCode = GetLastError();
        }
    }

    RegCloseKey(hkPrimaryModule);

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpeldl.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

        SNMPELDL.CPP


Abstract:

        This module is the main extension agent DLL for the SNMP Event Log
        Extension Agent DLL.

        Standard tracing and logging routines are defined in this module.

        DLL initialization and termination routines are defined here.

        SNMP trap initialization and processing is defined here.

        Spawning of the log processing thread is done in this routine.

Author:

        Randy G. Braze (Braze Computing Services) Created 16 October 1994


Revision History:
        9 Feb 99    FlorinT: Removed warning event logs on startup (when registry parameters are not found)

        16 Dec 98   FlorinT: Added LoadPrimaryModuleParams and 'EALoad.*' files

        1 Dec 98    FlorinT: Remove psupportedView - it is freed by the SNMP master agent

        7 Feb 96    Moved tracing and logging to separate module.
                        Restructured building of varbinds to be outside of trap generation.
                        Calculated trap buffer length correctly.
                        Created varbind queue and removed event log buffer queue.

        28 Feb 96   Added code to support a performance threshold reached indicator.
                        Removed pointer references to varbindlist and enterpriseoid.

        10 Mar 96   Removed OemToChar coding and registry checking.
                        Modifications to read log file names from EventLog registry entries and not
                        from specific entries in the SNMP Extension Agent's registry entries.
                        Included SnmpMgrStrToOid as an internal function, as opposed to using the function
                        provided by MGMTAPI.DLL. SNMPTRAP.EXE will be called if MGMTAPI is called, which
                        will disable other agents from being able to receive any traps. All references
                        to MGMTAPI.DLL and MGMTAPI.H will be removed.
                        Added a ThresholdEnabled flag to the registry to indicate if the threshold values
                        were to be monitored or ignored.

        13 Mar 96   Modified StrToOid routine to append the BaseEnterpriseOID to the specified string
                        if the string passed does not start with a period. Otherwise, the string is
                        converted as normal.
                        Changed TraceFileName parameter in the registry from REG_SZ to REG_EXPAND_SZ.
                        Modified registry reading routine to accept REG_EXPAND_SZ parameters.
                        Added additional tracing.

        07 May 96   Removed SnmpUtilOidFree and use two SNMP_free. One for the OID's ids array and
                        one for the OID itself. Also added psupportedView to free memory at exit.

        26 Jun 96   Modified the StrToOid function such that strings without leading "." have the base
                        OID appended instead of strings with a leading ".".

--*/

extern "C"
{
#include <stdlib.h>
#include <windows.h>        // windows definitions
#include <string.h>         // string declarations
#include <snmp.h>           // snmp definitions
#include <snmpexts.h>       // extension agent definitions
#include "snmpelea.h"       // global dll definitions
#include "snmpeldl.h"       // module specific definitions
#include "snmpelmg.h"       // message definitions
}

extern  VOID                FreeVarBind(UINT,RFC1157VarBindList     *);
#include "snmpelep.h"       // c++ variables and definitions
#include "EALoad.h"         // parameters loading functions

// MikeCure 4/3/98 hotfix for SMS Bug1 #20521
//===========================================
BOOL EnablePrivilege(VOID);

BOOL
StrToOid(
    IN          PCHAR                           lpszStr,
        IN      OUT     AsnObjectIdentifier     *asnOid
    )

/*++

Routine Description:

        This routine will convert the string passed to an OID.


Arguments:

        lpszStr -       Address of a null terminated string in the form n.n...n.

        asnOid  -       Address of converted OID of the input string.


Return Value:

        TRUE    -       If the string was successfully converted.

        FALSE   -       If the string could not be converted.

--*/

{
        CHAR    tokens[] = TEXT(".");           // delimiters to scan for
        CHAR    *token;                                         // token returned
        UINT    nTokens;                                        // number of tokens located
        UINT    i;                                                      // temporary counter
        CHAR    szString[MAX_PATH*2+1];         // temporary string holder
        CHAR    szOrgString[MAX_PATH*2+1];      // temporary string holder
        CHAR    *szStopString;                          // temporary string pointer

        WriteTrace(0x0a,"StrToOid: Entering routine to convert string to OID\n");
        WriteTrace(0x00,"StrToOid: String to convert is %s\n", lpszStr);

        nTokens = 0;                                            // reset counter

        if ( strlen(lpszStr) == 0 )
        {
                WriteTrace(0x14,"StrToOid: No strings found. Exiting with FALSE\n");
                return(FALSE);
        }

        if (lpszStr[0] != '.')
        {
                WriteTrace(0x0a,"StrToOid: BaseOID will not be appended to this OID\n");
                strcpy(szString, lpszStr);                      // copy original string
        }
        else
        {
                WriteTrace(0x0a,"StrToOid: BaseOID %s will be appended to this OID\n", szBaseOID);
                strcpy(szString, szBaseOID);            // copy in base OID
                strcat(szString, TEXT("."));            // stick in the .
                strcat(szString, lpszStr);                      // add in requested string
        }

        strcpy(szOrgString, szString);                  // save this string

        token = strtok(szString, tokens);       // get first token

        while (token != NULL)
        {
                szStopString = token;                           // set pointer to string
                strtoul(token, &szStopString, 10);      // check for valid values
                if ( (token == szStopString) || (*szStopString != NULL) )
                {
                        WriteTrace(0x14,"StrToOid: String contains a non-numeric value. Exiting with FALSE\n");
                        WriteLog(SNMPELEA_NON_NUMERIC_OID);
                        return(FALSE);
                }

                nTokens++;                                              // increment number of tokens found
                token = strtok(NULL, tokens);   // get next token
        }

        if (nTokens == 0)
        {
                WriteTrace(0x14,"StrToOid: No strings found. Exiting with FALSE\n");
                return(FALSE);
        }

        WriteTrace(0x00,"StrToOid: %lu tokens found\n", nTokens);
        WriteTrace(0x0a,"StrToOid: Allocating storage for OID\n");

        asnOid->ids = (UINT *) SNMP_malloc(nTokens * sizeof(UINT));     // allocate integer array

        if (asnOid->ids == NULL)
        {
                WriteTrace(0x14,"StrToOid: Unable to allocate integer array for OID structure. Exiting with FALSE\n");
                WriteLog(SNMPELEA_CANT_ALLOCATE_OID_ARRAY);
                return(FALSE);
        }

        WriteTrace(0x00,"StrToOid: OID integer array storage allocated at %08X\n", asnOid->ids);

        asnOid->idLength = nTokens;                     // set size of array
        strcpy(szString, szOrgString);          // copy original string
        token = strtok(szString, tokens);       // get first token
        i = 0;                                                          // set index to 0

        while (token != NULL)
        {
                asnOid->ids[i++] = strtoul(token, &szStopString, 10);   // convert string to number
                token = strtok(NULL, tokens);                                                   // get next token
        }

        if (nTraceLevel == 0)
        {
                for (i = 0; i < nTokens; i++)
                {
                        WriteTrace(0x00,"StrToOid: OID[%lu] is %lu\n",
                                i, asnOid->ids[i]);
                }
        }

        WriteTrace(0x0a,"StrToOid: Exiting routine with TRUE\n");
        return(TRUE);
}


VOID
CloseStopAll(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the event handle used to terminate the extension agent dll.


Arguments:

        None


Return Value:

        None

--*/

{
        LONG    lastError;                              // for GetLastError()

        if (hStopAll == NULL)
        {
                return;
        }

    WriteTrace(0x0a,"CloseStopAll: Closing handle to service shutdown event %08X\n",
                hStopAll);
        if ( !CloseHandle(hStopAll) )
        {
                lastError = GetLastError(); // save status
                WriteTrace(0x14,"CloseStopAll: Error closing handle for service shutdown event %08X; code %lu\n",
                        hStopAll, lastError);
                WriteLog(SNMPELEA_ERROR_CLOSING_STOP_AGENT_HANDLE,
                        HandleToUlong(hStopAll), lastError);
        }
}


VOID
CloseEventNotify(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the event handle used to notify SNMPELDL that a
        trap is waiting to be sent.


Arguments:

        None


Return Value:

        None

--*/

{
        LONG    lastError;                              // for GetLastError()

        if (hEventNotify == NULL)
        {
                return;
        }

    WriteTrace(0x0a,"CloseEventNotify: Closing handle to event notify event %08X\n",
                hEventNotify);
        if ( !CloseHandle(hEventNotify) )       // close log processing routine shutdown event handle
        {
                lastError = GetLastError(); // save error status
                WriteTrace(0x14,"CloseEventNotify: Error closing handle for StopLog event %08X; code %lu\n",
                        hEventNotify, lastError);
                WriteLog(SNMPELEA_ERROR_CLOSING_STOP_LOG_EVENT_HANDLE,
                        HandleToUlong(hEventNotify), lastError);
        }
}


VOID
CloseRegNotify(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the event handle used to notify SNMPELDL that a
        registry key value has changed.


Arguments:

        None


Return Value:

        None

--*/

{
        LONG    lastError;                              // for GetLastError()

        if (hRegChanged == NULL)
        {
                return;
        }

    WriteTrace(0x0a,"CloseRegNotify: Closing handle to registry key changed notify event %08X\n",
                hRegChanged);
        if ( !CloseHandle(hRegChanged) )        // close event handle
        {
                lastError = GetLastError(); // save error status
                WriteTrace(0x14,"CloseRegNotify: Error closing handle for registry key changed event %08X; code %lu\n",
                        hRegChanged, lastError);
                WriteLog(SNMPELEA_ERROR_CLOSING_REG_CHANGED_EVENT_HANDLE,
                        HandleToUlong(hRegChanged), lastError);
        }
}


VOID
CloseRegParmKey(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the registry key handle used to read the Parameters information
        from the registry.


Arguments:

        None


Return Value:

        None

--*/

{
        LONG    lastError;

        if (!fRegOk)
        {
                return;
        }

    WriteTrace(0x0a,"CloseRegParmKey: Closing Parameter key in registry\n");
        if ( (lastError = RegCloseKey(hkRegResult)) != ERROR_SUCCESS )  // close handle
        {
                WriteTrace(0x14,"CloseRegParmKey: Error closing handle for Parameters registry key %08X; code %lu\n",
                        hkRegResult, lastError);
                WriteLog(SNMPELEA_ERROR_CLOSING_REG_PARM_KEY,
                        HandleToUlong(hkRegResult), lastError);
        }
}

VOID
CloseLogs(
        IN      VOID
        )

/*++

Routine Description:

        This routine is called to close the currently open event logs. It is
        called when the agent is terminating normally and if an error is
        encountered during agent initialization.


Arguments:

        None


Return Value:

        None


--*/

{
    UINT   uVal;                                        // temporary counter

    WriteTrace(0x0a,"CloseLogs: Closing event logs\n");

    for (uVal = 0; uVal < uNumEventLogs; uVal++)
    {
        WriteTrace(0x00,"CloseLogs: Closing event log %s, handle %lu at %08X\n",
                        lpszEventLogs+uVal*(MAX_PATH+1), uVal, *(phEventLogs+uVal));
        CloseEventLog(*(phEventLogs+uVal));

                if (*(phPrimHandles+uVal) != (HMODULE) NULL)
                {
                        WriteTrace(0x00,"CloseLogs: Freeing PrimaryModule for event log %s, handle %lu at %08X\n",
                                lpszEventLogs+uVal*(MAX_PATH+1), uVal, *(phPrimHandles+uVal));
                        FreeLibrary(*(phPrimHandles+uVal));
                }
    }

    WriteTrace(0x0a,"CloseLogs: Freeing memory for event log handles at address %08X\n",
                phEventLogs);
        SNMP_free( (LPVOID) phEventLogs );                                      // free event log handle array

    WriteTrace(0x0a,"CloseLogs: Freeing memory for PrimaryModule handles at address %08X\n",
                phPrimHandles);
        SNMP_free( (LPVOID) phPrimHandles );                                    // free primary module handle array

    WriteTrace(0x0a,"CloseLogs: Freeing memory for event log names at address %08X\n",
                lpszEventLogs);
        SNMP_free( (LPVOID) lpszEventLogs );                                    // free log name array
}


extern "C" {
BOOL
Position_to_Log_End(
        IN      HANDLE  hLog
        )

/*++

Routine Description:

        Position_to_Log_End is called during DLL initialization. After each
        event log file is successfully opened, it is necessary to position each
        event log file to the current end of file. This way, only the events
        logged after the DLL has been started are reported. This routine will
        position the requested log to the end of file.

        Positioning to the end of the event log file is done by first getting
        the number of the oldest event log record. This value is then added to
        the number of event log records minus one. The resulting value is the
        record number of the last record in the event log file. ReadEventLog is
        called, specifying the seek parameter, to position to that exact record
        number.


Arguments:

        hLog                    -       Handle of the log file to position to end of file.


Return Value:

        TRUE    -       If the log was successfully positioned to end of file.

        FALSE   -       If the log was not positioned to end of file.


--*/

{
    LONG                        lastError;                                      // last error code
    PEVENTLOGRECORD     lpBuffer;                                       // address of data buffer
    PEVENTLOGRECORD     lpOrigBuffer;                           // address of data buffer
    DWORD                       nBytesRead;                                     // number of bytes read
    DWORD                       nMinNumberofBytesNeeded;        // remainder if buffer too small
    DWORD                       dwOldestRecord;                         // oldest record number in event log
    DWORD                       dwRecords;                                      // total number of records in event log
        DWORD                   uRecordNumber;                          // current log position

    WriteTrace(0x0a,"Position_to_Log_End: Entering position to end of log routine\n");
    WriteTrace(0x00,"Position_to_Log_End: Handle is %08X\n",hLog);

    if (!hLog)                     // if handle is invalid
    {                              //    then we cannot position correctly
        WriteTrace(0x14,"Position_to_Log_End: Handle for end of log is invalid - %08X\n",
                        hLog);
        WriteTrace(0x14,"Position_to_Log_End: Log position to end failed\n");
        WriteLog(SNMPELEA_LOG_HANDLE_INVALID, HandleToUlong(hLog)); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);            // log the message

        return FALSE;              // exit function
    }

    WriteTrace(0x0a,"Position_to_Log_End: Allocating log buffer\n");

    lpBuffer = (PEVENTLOGRECORD) SNMP_malloc(LOG_BUF_SIZE);  // allocate memory for buffer

    if (lpBuffer == (PEVENTLOGRECORD) NULL)              // if memory allocation failed
    {                                  //    then can't position log file
        WriteTrace(0x14,"Position_to_Log_End: Position to end of log for handle %08X failed\n",
                        hLog);
        WriteTrace(0x14,"Position_to_Log_End: Buffer memory allocation failed\n");
        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE, HandleToUlong(hLog));  // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                    // log the message

        return FALSE;                  //    exit the function
    }

        WriteTrace(0x00,"Position_to_Log_End: Log buffer memory allocated at %08X\n", lpBuffer);
    WriteTrace(0x0a,"Position_to_Log_End: Positioning to last record\n");

    WriteTrace(0x0a,"Position_to_Log_End: Getting oldest event log record\n");
    if ( !GetOldestEventLogRecord(hLog, &dwOldestRecord) )
    {
        lastError = GetLastError();       // get last error code

        WriteTrace(0x0a,"Position_to_Log_End: Freeing log event record buffer %08X\n",
                        lpBuffer);
        SNMP_free(lpBuffer);                   // free up buffer memory

        WriteTrace(0x14,"Position_to_Log_End: GetOldestEventLogRecord for log handle %08X failed with code %lu\n",
            hLog, lastError);
        WriteLog(SNMPELEA_ERROR_LOG_GET_OLDEST_RECORD, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                                // log the message

        return FALSE;
    }

    WriteTrace(0x00,"Position_to_Log_End: Oldest event log record is %lu\n",dwOldestRecord);

    WriteTrace(0x00,"Position_to_Log_End: Getting number of event log records\n");
    if ( !GetNumberOfEventLogRecords(hLog, &dwRecords) )
    {
        lastError = GetLastError();       // get last error code

        WriteTrace(0x0a,"Position_to_Log_End: Freeing log event record buffer\n");
        SNMP_free(lpBuffer);                   // free up buffer memory

        WriteTrace(0x14,"Position_to_Log_End: GetNumberOfEventLogRecords for log handle %08X failed with code %lu\n",
            hLog, lastError);
        WriteLog(SNMPELEA_ERROR_LOG_GET_NUMBER_RECORD, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                                // log the message

        return FALSE;
    }

    WriteTrace(0x00,"Position_to_Log_End: Number of event log records is %lu\n",dwRecords);

        uRecordNumber = dwOldestRecord + dwRecords - 1;         // current EOF

    WriteTrace(0x00,"Position_to_Log_End: Positioning to record #%lu\n",
        uRecordNumber);

    if ( !ReadEventLog(hLog,                    // log file handle to read
                EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,    // seek forward to specific record
                uRecordNumber,                                  // record # to position to
                lpBuffer,                                       // buffer to return log record in
                LOG_BUF_SIZE,                                   // size of buffer
                &nBytesRead,                                    // return bytes read this time
                &nMinNumberofBytesNeeded))              // return bytes needed for next full record
    {
        lastError = GetLastError();             // get last error code

        WriteTrace(0x0a,"Position_to_Log_End: Freeing log event record buffer %08X\n",
                        lpBuffer);
        SNMP_free(lpBuffer);                   // free buffer memory

        if (lastError == ERROR_HANDLE_EOF)
        {
            WriteTrace(0x00,"Position_to_Log_End: Handle %08X positioned at EOF\n",hLog);
            WriteTrace(0x0a,"Position_to_Log_End: Returning from position to end of log function\n");

            return TRUE;
        }

        WriteTrace(0x14,"Position_to_Log_End: SEEK to record in event log %08X failed with code %lu\n",
            hLog, lastError);
        WriteLog(SNMPELEA_ERROR_LOG_SEEK, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                   // log the message

        WriteTrace(0x00,"Position_to_Log_End: BytesRead is %lu\n", nBytesRead);
        WriteTrace(0x00,"Position_to_Log_End: MinNumberofBytesNeeded is %lu\n",
                    nMinNumberofBytesNeeded);

        return FALSE;
    }

    WriteTrace(0x0a,"Position_to_Log_End: Reading any residual records\n");
        lpOrigBuffer = lpBuffer;                        // save original buffer address
        nBytesRead = 0;                                         // reset byte count to nothing first
        lastError = 0;                                          // show no current error

    while (ReadEventLog(hLog,
        EVENTLOG_FORWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
        0,
        lpBuffer,
        LOG_BUF_SIZE,
        &nBytesRead,
        &nMinNumberofBytesNeeded))
    {
                lastError = GetLastError();                     // get last error code
                while (nBytesRead)
                {
                        WriteTrace(0x00,"Position_to_Log_End: Number of bytes read for residual read is %lu\n",
                                nBytesRead);
                        uRecordNumber = lpBuffer->RecordNumber; // save record number
                        nBytesRead -= lpBuffer->Length;         // reduce by this record count
                        lpBuffer = (PEVENTLOGRECORD) ((LPBYTE) lpBuffer +
                                lpBuffer->Length);                              // point to next record
                }
                lpBuffer = lpOrigBuffer;                // reload original address
    }

    WriteTrace(0x0a,"Position_to_Log_End: Checking for EOF return\n");


    WriteTrace(0x0a,"Position_to_Log_End: Freeing event log buffer memory %08X\n",
                lpOrigBuffer);
    SNMP_free(lpOrigBuffer);                                    // free buffer memory

    if ( (lastError == ERROR_HANDLE_EOF) ||     // if at the last record now
                 (lastError == NO_ERROR) )              // if no error occured
    {
        WriteTrace(0x00,"Position_to_Log_End: Handle %08X positioned at EOF; record #%lu\n",
                        hLog, uRecordNumber);
        WriteTrace(0x0a,"Position_to_Log_End: Returning from position to end of log function\n");

        return TRUE;                   // return all okay
    }
    else                              // otherwise
    {
        WriteTrace(0x14,"Position_to_Log_End: Read for handle %08X failed with code %lu\n",
                        hLog, lastError);
        WriteTrace(0x14,"Position_to_Log_End: Log not positioned to end\n");
        WriteLog(SNMPELEA_ERROR_READ_LOG_EVENT, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                         // log the message

        return FALSE;                  // give bad return code
    }
}
}

extern "C" {
BOOL
Read_Registry_Parameters(
        IN VOID
        )

/*++

Routine Description:

        Read_Registry_Parameters is called during SNMP trap initialization. The
        registry information is read to determine the trace file name (TraceFileName),
        the level of tracing desired (TraceLevel), the base enterprise OID (BaseEnterpriseOID),
        the supported view (SupportedView), and the message trimming flag (TrimMessage).
        Also, the names of the event logs to monitor are read from the registry.
        If no event logs are specified, the routine will terminate, as there is no work to perform.

        If, during the course of reading the registry information, a parameter
        is encountered that is not expected, an event log record is written and
        the parameter is ignored.

        The registry layout is as follows:

        HKEY_LOCAL_MACHINE
                SOFTWARE
                        Microsoft
                                SNMP_EVENTS
                                        EventLog
                                                Parameters
                                                        TraceFileName                   (REG_EXPAND_SZ)
                                                        TraceLevel                      (REG_DWORD)
                                                        BaseEnterpriseOID               (REG_SZ)
                                                        SupportedView                   (REG_SZ)
                                                        TrimMessage                     (REG_DWORD)
                                                        MaxTrapSize                     (REG_DWORD)
                                                        TrimFlag                        (REG_DWORD)
                                                        ThresholdEnabled                (REG_DWORD)
                                                        ThresholdFlag                   (REG_DWORD)
                                                        ThresholdCount                  (REG_DWORD)
                                                        ThresholdTime                   (REG_DWORD)
                                                        LastBootTime                    (REG_DWORD)
                                                        EventLogPollTime                (REG_DWORD)

Arguments:

        None


Return Value:

        TRUE    -       If registry parameters were processed successfully.

        FALSE   -       If registry parameters could not be read or if there were
                                no event logs specified to monitor.


--*/

{
    LONG    lastError;                      // return code from GetLastError()
    LONG    status;                         // status of API calls
    HKEY    hkResult, hkResult2;            // handle returned from API
    DWORD   iValue;                         // temporary counter
    DWORD   dwType;                         // type of the parameter read
    TCHAR   parmName[MAX_PATH+1];           // name of the parameter read
    DWORD   nameSize;                       // length of parameter name
    TCHAR   parm[MAX_PATH+1];               // value of the parameter
    DWORD   parmSize;                       // length of the parm value
    HANDLE  hLogFile;                       // handle from log open
    UINT    uVal;                           // loop counter
    BOOL    fTrimMsg = FALSE;               // registry info found flags
    BOOL    fBaseOID = FALSE;               // registry info found flags
    BOOL    fSupView = FALSE;               // registry info found flags
    BOOL    fTrapSize = FALSE;              // registry info found flags
    BOOL    fTrimFlg = FALSE;               // registry info found flags
    BOOL    fThresholdFlg = FALSE;          // registry info found flags
    BOOL    fThresholdCountFlg = FALSE;     // registry info found flags
    BOOL    fThresholdTimeFlg = FALSE;      // registry info found flags
    BOOL    fTraceLevelFlg = FALSE;         // registry info found flags
    BOOL    fThresholdEnabledFlg = FALSE;   // registry info found flags
    BOOL    fThresholdOff = FALSE;          // temporary flag
    DWORD   nReadBytes = 0;                 // number of bytes read from profile information
    TCHAR   lpszLog[MAX_PATH+1];            // temporary registry name
    BOOL    fLastBootFlg = FALSE;           // registry info found flag

    WriteTrace(0x0a,"Read_Registry_Parameters: Entering routine\n");

    if (fSendThresholdTrap)
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Routined entered due to threshold performance parameters reached and modified.\n");

        if ( hRegChanged != NULL )
        {
            if ( (lastError = RegNotifyChangeKeyValue(
                    hkRegResult,                                                                                    // handle of key to watch
                    TRUE,                                                                                                   // watch subkey stuff
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,    // types of changes to notify on
                    hRegChanged,                                                                                    // event to signal when change
                    TRUE)) == ERROR_SUCCESS )                                                               // asynchronous processing
            {
                WriteTrace(0x0a,"Read_Registry_Parameters: Notification of registry key changes was successful.\n");
                fRegOk = TRUE;                          // show registry notification is in effect
            }
            else
            {
                WriteTrace(0x14,"Read_Registry_Parameters: Notification of registry key changes failed with code of %lu\n",
                        lastError);
                WriteLog(SNMPELEA_REG_NOTIFY_CHANGE_FAILED, lastError);
                WriteTrace(0x14,"Read_Registry_Parameters: Initialization continues, but registry changes will require a restart of SNMP\n");
                CloseRegNotify();
            }
        }

        WriteTrace(0x0a,"Read_Registry_Parameters: Exiting Read_Registry_Parameters routine with TRUE.\n");
        return(TRUE);
    }

    WriteTrace(0x0a,"Read_Registry_Parameters: Opening %s\n", EXTENSION_PARM);

    if (fThreshold && fThresholdEnabled)    // if threshold checking enabled and threshold reached
    {
            fThresholdOff = TRUE;                           // indicate that we're not sending traps right now
    }
    else
    {
            fThresholdOff = FALSE;                          // otherwise, indicate we are sending traps right now
    }

    if (hkRegResult == NULL)
    {
            if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, EXTENSION_PARM, 0,
                    KEY_READ | KEY_SET_VALUE, &hkRegResult))
                    != ERROR_SUCCESS)                   // open registry information
            {
                    WriteTrace(0x14,"Read_Registry_Parameters: Error in RegOpenKeyEx for Parameters = %lu \n",
                            status);
                    WriteLog(SNMPELEA_NO_REGISTRY_PARAMETERS, status);   // log error message
                    return(FALSE);                                  // failed -- can't continue
            }
    }

    if (!fRegNotify)
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Creating event for registry change notification\n");
        fRegNotify = TRUE;                              // set flag to show initialization complete

        if ( (hRegChanged = CreateEvent(
                (LPSECURITY_ATTRIBUTES) NULL,
                FALSE,
                FALSE,
                (LPTSTR) NULL)) == NULL)
        {
            lastError = GetLastError(); // save error status
            WriteTrace(0x14,"Read_Registry_Parameters: Error creating registry change notification event; code %lu\n",
                    lastError);
            WriteLog(SNMPELEA_ERROR_CREATING_REG_CHANGE_EVENT, lastError);

            WriteTrace(0x14,"Read_Registry_Parameters: No registry notification will be performed. Continuing with initialization.\n");
        }
        else
        {
            WriteTrace(0x00,"Read_Registry_Parameters: Registry key changed event handle is %08X\n",
                    hRegChanged);
        }
    }

    if ( hRegChanged != NULL )
    {
        if ( (lastError = RegNotifyChangeKeyValue(
                hkRegResult,                                                                                    // handle of key to watch
                TRUE,                                                                                                   // watch subkey stuff
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,    // types of changes to notify on
                hRegChanged,                                                                                    // event to signal when change
                TRUE)) == ERROR_SUCCESS )                                                               // asynchronous processing
        {
            WriteTrace(0x0a,"Read_Registry_Parameters: Notification of registry key changes was successful.\n");
            fRegOk = TRUE;                          // show registry notification is in effect
        }
        else
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Notification of registry key changes failed with code of %lu\n",
                    lastError);
            WriteLog(SNMPELEA_REG_NOTIFY_CHANGE_FAILED, lastError);
            WriteTrace(0x14,"Read_Registry_Parameters: Initialization continues, but registry changes will require a restart of SNMP\n");
            CloseRegNotify();
        }
    }

    iValue = 0;                              // read first parameter
    nameSize = MAX_PATH;                     // can't be greater than this
    parmSize = MAX_PATH;                     // can't be greater than this
    g_dwEventLogPollTime = (DWORD) INFINITE; // default value is not to poll Event Logs

    while ((status = RegEnumValue(hkRegResult, iValue, parmName, &nameSize, 0,
                &dwType, (LPBYTE)&parm, &parmSize)) != ERROR_NO_MORE_ITEMS)
    {                                     // read until no more values
        if (status != ERROR_SUCCESS)          // if error during read
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Error reading registry value is %lu for index %lu (Parameters)\n",
                                status, iValue);            // show error information
            WriteLog(SNMPELEA_ERROR_REGISTRY_PARAMETER_ENUMERATE,
                                (DWORD) status, iValue);   // log error message

            fRegOk = FALSE;                                         // don't want to do notify now
            CloseRegNotify();                                       // close event handle
            CloseRegParmKey();                                      // close registry key
            return(FALSE);                                              // indicate stop
        }

        WriteTrace(0x00,"Read_Registry_Parameters: Parameter read is %s, length is %lu\n",
                        parmName, strlen(parmName));

        switch (dwType)
        {
            case REG_SZ : // if we have a string
            {
                WriteTrace(0x00,"Read_Registry_Parameters: Parameter type is REG_SZ\n");

                if ( _stricmp(parmName,EXTENSION_BASE_OID) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: BaseEnterpriseOID parameter matched\n");
                    strcpy(szBaseOID,parm);         // save base OID
                    fBaseOID = TRUE;                        // indicate parameter read
                }
                else if ( _stricmp(parmName,EXTENSION_TRACE_FILE) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: TraceFileName parameter matched\n");
                    strcpy(szTraceFileName,parm);   // save filename
                    fTraceFileName = TRUE;                  // indicate parameter read
                }
                else if ( _stricmp(parmName,EXTENSION_SUPPORTED_VIEW) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: SupportedView parameter matched\n");
                    strcpy(szSupView,parm);         // save supported view OID
                    fSupView = TRUE;                        // indicate parameter read
                }
                else                          // otherwise, bad value read
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value name: %s\n",parmName );
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value contents %s\n",parm );
                }
            }
            break;

            case REG_DWORD :// if double word parameter
            {
                WriteTrace(0x00,"Read_Registry_Parameters: Parameter type is REG_DWORD\n");

                if ( _stricmp(parmName,EXTENSION_TRACE_LEVEL) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: TraceLevel parameter matched\n");
                    nTraceLevel = *((DWORD *)parm); // copy registry trace level
                    fTraceLevelFlg = TRUE;                  //indicate parameter read
                    break;
                }
                else if ( _stricmp(parmName,EXTENSION_TRIM) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global TrimMessage parameter matched\n");
                    fGlobalTrim = (*((DWORD *)parm) == 1);          // set global message trim flag
                    fTrimMsg = TRUE;         // show parameter found
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_MAX_TRAP_SIZE) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Maximum Trap Size parameter matched\n");
                    nMaxTrapSize = *((DWORD *)parm);                // get trap size
                    fTrapSize = TRUE;                               // show parameter found
                    break;
                }
                else if ( _stricmp(parmName,EXTENSION_TRIM_FLAG) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global trap trimming flag TrimFlag parameter matched\n");
                    fTrimFlag = (*((DWORD *)parm) == 1);    // set global trim flag
                    fTrimFlg = TRUE;                // show parameter found
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_ENABLED) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global threshold checking flag ThresholdEnabled parameter matched\n");
                    fThresholdEnabled = (*((DWORD *)parm) == 1);    // set global threshold enabled flag
                    fThresholdEnabledFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_FLAG) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global preformance threshold flag Threshold parameter matched\n");
                    fThreshold = (*((DWORD *)parm) == 1);   // set global performance threshold flag
                    fThresholdFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_COUNT) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global preformance threshold count ThresholdCount parameter matched\n");
                    dwThresholdCount = *((DWORD *)parm);    // set global performance threshold count
                    fThresholdCountFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_TIME) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global preformance threshold time ThresholdTime parameter matched\n");
                    dwThresholdTime = *((DWORD *)parm);     // set global performance threshold time
                    fThresholdTimeFlg = TRUE;
                    break;                                  // exit case
                }
                else if (fDoLogonEvents && (_stricmp(parmName,EXTENSION_LASTBOOT_TIME) == 0))
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Initialization last boot time parameter matched\n");
                    dwLastBootTime = *((DWORD *)parm);  // set global last boot time
                    fLastBootFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_EVENT_LOG_POLL_TIME) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global Event Log poll time EventLogPollTime parameter matched\n");
                    DWORD dwEventLogPollTime = *((DWORD *)parm);     // registry poll time in seconds

                    WriteTrace(0x00,"Read_Registry_Parameters: EventLogPollTime parameter found in registry of %lu.\n",
                                    dwEventLogPollTime);
                    
                    // check for underflow and overflow values
                    if ( (dwEventLogPollTime != 0) && (dwEventLogPollTime <= ((DWORD)INFINITE/1000)) )
                    {
                        g_dwEventLogPollTime = dwEventLogPollTime * 1000; // poll time in milliseconds
                    }
                    else
                    {
                        WriteTrace(0x00,"Read_Registry_Parameters: reset EventLogPollTime parameter to %lu.\n",
                                    g_dwEventLogPollTime);
                    }
                    break;       
                }
                else                                                    // otherwise, bad parameter read
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value name: %s\n",parmName );
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value contents: %lu\n",parm );
                }
            }
            break;

            default :   // if not above, bad value read
            {
                WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value name: %s\n",parmName );
                WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value contents not displayed\n" );
            }
        } // end switch

        nameSize = MAX_PATH;                  // reset maximum length
        parmSize = MAX_PATH;                  // reset maximum length
        iValue++;                             // request next parameter value

    } // end while

    if (!fRegOk)
    {
        CloseRegParmKey();                                      // close registry key
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking BaseEnterpriseOID read from registry\n");
    
    if ( !fBaseOID )
    {
        WriteTrace(0x14,"Read_Registry_Parameters: BaseEnterpriseOID parameter not found in registry\n");
        WriteLog(SNMPELEA_NO_REGISTRY_BASEOID_PARAMETER);
        return(FALSE);                                          // exit - can't continue
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking SupportedView read from registry\n");
    
    if ( !fSupView )
    {
        WriteTrace(0x14,"Read_Registry_Parameters: SupportedView parameter not found in registry\n");
        WriteLog(SNMPELEA_NO_REGISTRY_SUPVIEW_PARAMETER);
        return(FALSE);                                          // exit - can't continue
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TraceFileName read from registry\n");
    
    if ( !fTraceFileName )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceFileName parameter not found in registry, defaulting to %s.\n",
                        szTraceFileName);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceFileName parameter found in registry of %s.\n", szTraceFileName);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TraceLevel read from registry\n");
    
    if ( !fTraceLevelFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceLevel parameter not found in registry, defaulting to %lu.\n",
                        nTraceLevel);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceLevel parameter found in registry of %lu.\n", nTraceLevel);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking MaxTrapSize read from registry\n");
    
    if ( !fTrapSize )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: MaxTrapSize parameter not found in registry, defaulting to %lu.\n",
                        MAX_TRAP_SIZE);
        nMaxTrapSize = MAX_TRAP_SIZE;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: MaxTrapSize parameter found in registry of %lu.\n", nMaxTrapSize);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TrimFlag read from registry\n");

    if ( !fTrimFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimFlag parameter not found in registry, defaulting to %lu.\n",
                        fTrimFlag);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimFlag parameter found in registry of %lu.\n", fTrimFlag);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TrimFlag read from registry\n");

    if ( !fTrimMsg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimMessage parameter not found in registry, defaulting to %lu.\n",
                        fGlobalTrim);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimMessage parameter found in registry of %lu.\n", fGlobalTrim);
    }


    WriteTrace(0x00,"Read_Registry_Parameters: Checking ThresholdEnabled parameter read from registry\n");

    if ( !fThresholdEnabledFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdEnabled parameter not found in registry, defaulting to 1.\n");
                fThresholdEnabled = TRUE;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdEnabled parameter found in registry of %lu.\n", fThresholdEnabled);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking Threshold parameter read from registry\n");
    
    if ( !fThresholdFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Threshold parameter not found in registry, defaulting to 0.\n");
        fThreshold = FALSE;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Threshold parameter found in registry of %lu.\n", fThreshold);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking ThresholdCount parameter read from registry\n");
    
    if ( !fThresholdCountFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdCount parameter not found in registry, defaulting to %lu.\n",
                        THRESHOLD_COUNT);
        dwThresholdCount = THRESHOLD_COUNT;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdCount parameter found in registry of %lu.\n",
                dwThresholdCount);

        if (dwThresholdCount < 2)
        {
            WriteTrace(0x00,"Read_Registry_Parameters: ThresholdCount is an invalid value -- a minimum of 2 is used.\n");
            dwThresholdCount = 2;
            WriteLog(SNMPELEA_REGISTRY_LOW_THRESHOLDCOUNT_PARAMETER, dwThresholdCount);
        }
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking ThresholdTime parameter read from registry\n");
    
    if ( !fThresholdTimeFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdTime parameter not found in registry, defaulting to %lu.\n",
                        THRESHOLD_TIME);
        dwThresholdTime = THRESHOLD_TIME;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdTime parameter found in registry of %lu.\n",
                dwThresholdTime);
        if (dwThresholdTime < 1)
        {
            WriteTrace(0x00,"Read_Registry_Parameters: ThresholdTime is an invalid value -- a minimum of 1 is used.\n");
            dwThresholdTime = 1;
            WriteLog(SNMPELEA_REGISTRY_LOW_THRESHOLDTIME_PARAMETER, dwThresholdTime);
        }
    }

    if ( (fThresholdEnabled && !fThreshold && fThresholdOff) ||
            (!fThresholdEnabled && fThresholdOff) )
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Threshold values have been reset. Trap processing resumed.\n");
        WriteLog(SNMPELEA_THRESHOLD_RESUMED);

        if (fLogInit)
        {
            for (DWORD inum = 0; inum < uNumEventLogs; inum++)
            {
                Position_to_Log_End(phEventLogs[inum]);
            }
        }
    }

    if ( fThresholdEnabled && fThreshold && !fThresholdOff )
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Threshold values have been set. Trap processing will not be done.\n");
        WriteLog(SNMPELEA_THRESHOLD_SET);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: BaseEnterpriseOID is %s\n", szBaseOID);
    WriteTrace(0x00,"Read_Registry_Parameters: SupportedView is %s\n", szSupView);
    WriteTrace(0x00,"Read_Registry_Parameters: Global TrimFlag value is %lu (trim yes/no)\n", fTrimFlag);
    WriteTrace(0x00,"Read_Registry_Parameters: Global TrimMessage value is %lu (trim msg/ins str first)\n", fGlobalTrim);

    if (fLogInit)
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Reread of registry parameters is complete\n");
        WriteTrace(0x0a,"Read_Registry_Parameters: Exiting Read_Registry_Parameters with TRUE\n");
        return(TRUE);
    }

    fLogInit = TRUE;                                // indicate not to read log information again

    WriteTrace(0x0a,"Read_Registry_Parameters: Opening %s\n", EVENTLOG_BASE);

    if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, EVENTLOG_BASE, 0,
         (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS), &hkResult))
         != ERROR_SUCCESS)                   // open for log names
    {
        WriteTrace(0x14,"Read_Registry_Parameters: Error in RegOpenKeyEx for EventLog = %lu\n",
                        status);
        WriteLog(SNMPELEA_NO_REGISTRY_LOG_NAME, status); // log error message
        return(FALSE);                        // if error, service stop
    }

    iValue = 0;                              // read first parameter
    parmSize = MAX_PATH;                     // maximum parameter size

    while ((status = RegEnumKey(hkResult, iValue, (char *) &parm, parmSize)) != ERROR_NO_MORE_ITEMS)
    {                                     // read until no more entries
        if (status != ERROR_SUCCESS)          // if error during read
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Error reading registry value is %lu for index %lu (EventLogFiles)\n",
                                status, iValue);            // show error information
            WriteLog(SNMPELEA_ERROR_REGISTRY_LOG_NAME_ENUMERATE, status, iValue);  // log the error message
            RegCloseKey(hkResult);             // close registry
            return(FALSE);                     // indicate service stop
        }

        // MikeCure 4/3/98 hotfix for SMS Bug1 #20521
        //===========================================
        EnablePrivilege();

        hLogFile = OpenEventLog( (LPTSTR) NULL, parm);

        if (hLogFile == NULL)
        {                         // did log file open?
            lastError = GetLastError(); // save error code
            WriteTrace(0x14,"Read_Registry_Parameters: Error in EventLogOpen = %lu\n",
                        lastError);
            WriteTrace(0x14,"Read_Registry_Parameters: Log file name: %s\n",parm);

            WriteLog(SNMPELEA_ERROR_OPEN_EVENT_LOG, parm, lastError);  // log the error message
            continue;                // failed -- forget this one
        }

        if ( !Position_to_Log_End(hLogFile) )
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to position to end of log. DLL terminated.\n");
            WriteLog(SNMPELEA_ERROR_LOG_END);
            WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);
            return(FALSE);          // exit with error
        }

        phEventLogs = (PHANDLE) SNMP_realloc( (LPVOID) phEventLogs,
                (uNumEventLogs+1) * sizeof(HANDLE));
                                                                 // reallocate array space
        if (phEventLogs == (PHANDLE) NULL)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to reallocate log event array\n");
            WriteLog(SNMPELEA_REALLOC_LOG_EVENT_ARRAY);
            return(FALSE);          // exit with error
        }

        WriteTrace(0x00,"Read_Registry_Parameters: Event log array reallocated at %08X\n",
                phEventLogs);

        *(phEventLogs+uNumEventLogs) = hLogFile; // save handle

        lpszEventLogs = (LPTSTR) SNMP_realloc( (LPVOID) lpszEventLogs,
                iLogNameSize + MAX_PATH + 1 );

        if (lpszEventLogs == (LPTSTR) NULL)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to reallocate log name array\n");
            WriteLog(SNMPELEA_REALLOC_LOG_NAME_ARRAY);
            return(FALSE);          // exit with error
        }

        WriteTrace(0x00,"Read_Registry_Parameters: Event log name array reallocated at %p\n",
                lpszEventLogs);

        iLogNameSize += MAX_PATH + 1;
        strcpy(lpszEventLogs+uNumEventLogs*(MAX_PATH+1), parm);

        phPrimHandles = (PHMODULE) SNMP_realloc( (LPVOID) phPrimHandles,
                (uNumEventLogs+1) * sizeof(HANDLE));
                                                                 // reallocate array space
        if (phPrimHandles == (PHMODULE) NULL)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to reallocate PrimaryModule handle array\n");
            WriteLog(SNMPELEA_REALLOC_PRIM_HANDLE_ARRAY);
            return(FALSE);          // exit with error
        }

        WriteTrace(0x00,"Read_Registry_Parameters: PrimaryModule handle array reallocated at %08X\n",
                phPrimHandles);

        parmSize = MAX_PATH;                  // reset to maximum

        strcpy(lpszLog, EVENTLOG_BASE);         // copy base registry name
        strcat(lpszLog, parm);                          // add on the log file name read

        WriteTrace(0x0a,"Read_Registry_Parameters: Opening registry for PrimaryModule for %s\n", lpszLog);

        if ( (status = RegOpenKeyEx(            // open the registry to read the name
                HKEY_LOCAL_MACHINE,                             // of the message module DLL
                lpszLog,                                                // registry key to open
                0,
                KEY_READ,
                &hkResult2) ) != ERROR_SUCCESS)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to open EventLog service registry key %s; RegOpenKeyEx returned %lu\n",
                        lpszLog, status);                       // write trace event record
            WriteLog(SNMPELEA_CANT_OPEN_REGISTRY_PARM_DLL, lpszLog, status);
            WriteTrace(0x0a,"Read_Registry_Parameters: Exiting Read_Registry_Parameters with FALSE\n");
            return(FALSE);                                  // return
        }

        if ( (status = RegQueryValueEx( // look up module name
                hkResult2,                                      // handle to registry key
                EXTENSION_PRIM_MODULE,          // key to look up
                0,                                                      // ignored
                &dwType,                                        // address to return type value
                (LPBYTE) parm,                          // where to return message module name
                &parmSize) ) != ERROR_SUCCESS)  // size of message module name field
        {
            WriteTrace(0x14,"Read_Registry_Parameters: No PrimaryModule registry key for %s; RegQueryValueEx returned %lu\n",
                    lpszEventLogs+uNumEventLogs*(MAX_PATH+1), status);                      // write trace event record
            *(phPrimHandles+uNumEventLogs) = (HMODULE) NULL;
        }
        else
        {
            DWORD retCode;
            tPrimaryModuleParms PMParams;

            PMParams.dwParams = PMP_PARAMMSGFILE;
            retCode = LoadPrimaryModuleParams(hkResult2, parm, PMParams);
            if (retCode != ERROR_SUCCESS)
            {
                WriteTrace(0x14, "Read_Registry_Parameters: LoadPrimaryModuleParams failed with errCode = %lu\n", retCode);
                *(phPrimHandles+uNumEventLogs) = NULL;
            }
            else
                *(phPrimHandles+uNumEventLogs) = PMParams.hModule;
        }

        RegCloseKey(hkResult2);                         // close registry key

        WriteTrace(0x00,"Read_Registry_Parameters: Log file name is %s\n",
                lpszEventLogs+uNumEventLogs*(MAX_PATH+1));
        WriteTrace(0x00,"Read_Registry_Parameters: Log handle #%lu is %08X\n",
                uNumEventLogs,hLogFile);
        WriteTrace(0x00,"Read_Registry_Parameters: PrimaryModule handle #%lu is %08X\n",
                uNumEventLogs,*(phPrimHandles+uNumEventLogs));

        uNumEventLogs++;
        parmSize = MAX_PATH;                  // reset to maximum
        iValue++;                             // read next parameter

    } // end while

    RegCloseKey(hkResult);                   // close registry info

    WriteTrace(0x00,"Read_Registry_Parameters: Number of handles acquired is %lu\n",
                uNumEventLogs);
    for (uVal = 0; uVal < uNumEventLogs; uVal++)
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Handle # %lu\t%08X\t%s\n", uVal,
                *(phEventLogs+uVal), lpszEventLogs+uVal*(MAX_PATH+1));
    }

    if (uNumEventLogs)                       // if we have logs opened
    {
        return(TRUE);                        // then we can say all okay
    }
    else
    {
        WriteTrace(0x14,"Read_Registry_Parameters: Registry contains no log file entries to process\n");
        //WriteLog(SNMPELEA_NO_REGISTRY_EVENT_LOGS);     // log error message
        return(FALSE);                      // if not, then not okay
    }
}                                           // request stop
}

//nadir
VOID
CloseSourceHandles(VOID)
{
   PSourceHandleList    lpSource;
   UINT lastError;

   lpSource = lpSourceHandleList;

   while (lpSource != (PSourceHandleList)NULL)
   {
      if ( !FreeLibrary(lpSource->handle) )                             // free msg dll
      {
         lastError = GetLastError();                            // get error code
         WriteTrace(0x14,"CloseSourceHandles: Error freeing message dll is %lu.\n", lastError);
         WriteLog(SNMPELEA_ERROR_FREEING_MSG_DLL, lastError);
      }

      lpSourceHandleList = lpSource->Next;
      SNMP_free(lpSource);
      lpSource = lpSourceHandleList;
   }
}



//nadir




extern "C" {
BOOL
APIENTRY
DllMain(
        IN      HANDLE  hDll,
        IN      DWORD   dwReason,
        IN      LPVOID  lpReserved
        )

/*++

Routine Description:

        SNMPEventLogDllMain is the dll initialization and termination routine.

        Once this termination request is received, the appropriate events will be
        signaled, notifying the subordinate threads that they should terminate
        to accomodate service termination.

Arguments:

        hDll            -       Handle to the DLL. Unreferenced.

        dwReason        -       Reason this routine was entered (process/thread attach/detach).

        lpReserved      -       Reserved. Unreferenced.

Return Value:

        TRUE    -       If initialization or termination was successful.

        FALSE   -       If initialization or termination was unsuccessful.

--*/

{
    DWORD       lastError;                              // to save GetLastError() return code

    UNREFERENCED_PARAMETER(hDll);
    UNREFERENCED_PARAMETER(lpReserved);

    WriteTrace(0x0a,"SNMPEventLogDllMain: Entering SNMPEventLogDllMain routine.....\n");

    switch(dwReason)
        {
                case DLL_PROCESS_ATTACH:
                        WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates process attach\n");

                        if ( (hWriteEvent = RegisterEventSource(
                                (LPTSTR) NULL,
                                EVNTAGNT_NAME) )
                                == NULL)
                        {
                                WriteTrace(0x20,"SNMPEventLogDllMain: Unable to log application events; code is %lu\n",
                                        GetLastError() );
                                WriteTrace(0x20,"SNMPEventLogDllMain: SNMP Event Log Extension Agent DLL initialization abnormal termination\n");
                                WriteTrace(0x0a,"SNMPEventLogDllMain: Exiting SNMPEventLogDllMain routine with FALSE\n");
                                return(FALSE);                  // error initializing
                        }

                        WriteTrace(0x14,"SNMPEventLogDllMain: SNMP Event Log Extension Agent DLL is starting\n");
                        WriteLog(SNMPELEA_STARTED);

                        WriteTrace(0x0a,"SNMPEventLogDllMain: Creating event for extension DLL shutdown\n");

                        if ( (hStopAll= CreateEvent(
                                (LPSECURITY_ATTRIBUTES) NULL,
                                TRUE, // changed to manual reset event
                                FALSE,
                                (LPTSTR) NULL)) == NULL)
                        {
                                lastError = GetLastError(); // save error status
                                WriteTrace(0x14,"SNMPEventLogDllMain: Error creating stop extension DLL event; code %lu\n",
                                        lastError);
                                WriteLog(SNMPELEA_ERROR_CREATING_STOP_AGENT_EVENT, lastError);

                                WriteTrace(0x14,"SNMPEventLogDllMain: SNMPELEA DLL abnormal initialization\n");
                                WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
                                WriteTrace(0x0a,"SNMPEventLogDllMain: Exiting SNMPEventLogDllMain routine with FALSE\n");
                                return(FALSE);
                        }

                        WriteTrace(0x00,"SNMPEventLogDllMain: Extension DLL shutdown event handle is %08X\n",
                                hStopAll);

                        break;

                case DLL_PROCESS_DETACH:
                        WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates process detach\n");
                        break;

                case DLL_THREAD_ATTACH:
                        WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates thread attach\n");
                        break;

                case DLL_THREAD_DETACH:
                        WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates thread detach\n");
                        break;

                default:
                        WriteTrace(0x0a,"SNMPEventLogDllMain: Unknown reason code indicated in SNMPEventLogDllMain\n");
                        break;

        } // end switch()

        WriteTrace(0x0a,"SNMPEventLogDllMain: Exiting SNMPEventLogDllMain routine with TRUE\n");
    return(TRUE);
}
}


extern "C" {
BOOL
APIENTRY
SnmpExtensionInit(
        IN      DWORD                           dwTimeZeroReference,
        OUT     HANDLE                          *hPollForTrapEvent,
        OUT     AsnObjectIdentifier     *supportedView
        )

/*++

Routine Description:

        SnmpExtensionInit is the extension dll initialization routine.

        This routine will create the event used to notify the manager agent that an event
        has occurred and that a trap should be generated. The TimeZeroReference will be
        saved and will be used by the trap generation routine to insert the time reference
        into the generated trap.

        The registry will be queried to determine which event logs will be used for tracking.
        These event log names are validated to insure that they are real log names. Event logs
        are opened and their handles are saved for event log processing.

        An event is created to notify the log processing thread of DLL termination. Then the
        log processing thread is spawned to handle all further event processing.

        The registry is then read to get the value for the supported view for this extension
        agent DLL. The registry layout for this routine is as follows:

        Registry
                Machine
                        SOFTWARE
                                Microsoft
                                        SNMP_EVENTS
                                                EventLog
                                                        Parameters
                                                                TraceFileName       (REG_SZ)
                                                                TraceLevel          (REG_DWORD)
                                                                BaseEnterpriseOID   (REG_SZ)
                                                                SupportedView       (REG_SZ)
                                                                TrimMessage         (REG_DWORD)
                                                                MaxTrapSize         (REG_DWORD)
                                                                TrimFlag            (REG_DWORD)
                                                                ThresholdEnabled    (REG_DWORD)
                                                                ThresholdFlag       (REG_DWORD)
                                                                ThresholdCount      (REG_DWORD)
                                                                ThresholdTime       (REG_DWORD)

Arguments:

        dwTimeZeroReference     -       Specifies a time-zero reference for the extension agent.

        hPollForTrapEvent       -       Pointer to an event handle for an event that will be asserted
                                                        when the SnmpExtensionTrap entry point should be polled by the
                                                        manager agent.

        supportedView           -       Points to an AsnObjectIdentifier specifying the MIB sub-tree
                                                        supported by this extension agent. Read from the registry.

Return Value:

        TRUE    -       If initialization or termination was successful.

        FALSE   -       If initialization or termination was unsuccessful.

--*/

{
        LONG    lastError;                      // for GetLastError()
        DWORD   dwThreadID;                     // for CreateThread()

    WriteTrace(0x0a,"SnmpExtensionInit: Entering extension agent SnmpExtensionInit routine\n");

        if ( !Read_Registry_Parameters() )
        {
                WriteTrace(0x14,"SnmpExtensionInit: Error during registry initialization processing\n");
                WriteLog(SNMPELEA_REGISTRY_INIT_ERROR);

                WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
                WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);

                CloseStopAll();                                 // close event handle

                if (fRegOk)
                {
                        CloseRegNotify();                       // close registry change event handle
                        CloseRegParmKey();                      // close registry key
                }
                WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");
                return(FALSE);                                  // exit init routine
        }


    WriteTrace(0x0a,"SnmpExtensionInit: Creating event for manager agent trap event notification\n");

    if ( (hEventNotify = CreateEvent(
        (LPSECURITY_ATTRIBUTES) NULL,
        FALSE,
        FALSE,
        (LPTSTR) NULL)) == NULL)
    {
        lastError = GetLastError(); // save error status
        WriteTrace(0x14,"SnmpExtensionInit: Error creating EventNotify event; code %lu\n",
            lastError);
        WriteLog(SNMPELEA_ERROR_CREATING_EVENT_NOTIFY_EVENT, lastError);

                CloseStopAll();                                 // close event handle

                if (fRegOk)
                {
                        CloseRegNotify();                       // close registry change event handle
                        CloseRegParmKey();                      // close registry key
                }

        WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
                WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");
        return(FALSE);
    }

    WriteTrace(0x00,"SnmpExtensionInit: Manager agent trap event notification handle is %08X\n",
                hEventNotify);

    WriteTrace(0x0a,"SnmpExtensionInit: Creating thread for event log processing routine\n");

    if ( (hServThrd = CreateThread(
        (LPSECURITY_ATTRIBUTES) NULL,                   // security attributes
        0,                                                                              // initial thread stack size
        (LPTHREAD_START_ROUTINE) SnmpEvLogProc, // starting address of thread
        0,                                                                              // no arguments
        0,                                                                              // creation flags
        &dwThreadID) ) == NULL )                                // returned thread id
    {
        lastError = GetLastError();                     // save error status
        WriteTrace(0x14,"SnmpExtensionInit: Error creating event log processing thread; code %lu\n",
            lastError);
        WriteLog(SNMPELEA_ERROR_CREATING_LOG_THREAD, lastError);    // log error message

                CloseStopAll();                                 // close event handle
                CloseEventNotify();                             // close notify event handle

                if (fRegOk)
                {
                        CloseRegNotify();                       // close registry change event handle
                        CloseRegParmKey();                      // close registry key
                }

        WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
                WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");
        return(FALSE);
    }

    WriteTrace(0x00,"SnmpExtensionInit: Handle to event log processing routine thread is %08X\n",
                hServThrd);

        dwTimeZero = dwTimeZeroReference;                       // save time zero reference
        *hPollForTrapEvent = hEventNotify;                      // return handle to event

        if (!StrToOid(szSupView, supportedView))
        {
                WriteTrace(0x14,"SnmpExtensionInit: Unable to convert supported view string to OID\n");
                WriteLog(SNMPELEA_SUPVIEW_CONVERT_ERROR);

                CloseStopAll();                                 // close event handle
                CloseEventNotify();                             // close notify event handle

                if (fRegOk)
                {
                        CloseRegNotify();                       // close registry change event handle
                        CloseRegParmKey();                      // close registry key
                }

                WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
                WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");
                return(FALSE);
        }

        WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with TRUE\n");
    return(TRUE);
}
}

extern "C" {
VOID
APIENTRY
SnmpExtensionClose()
{
    DWORD   lastError;      // to save GetLastError() return code
    DWORD   dwThreadID;
    DWORD   dwThirtySeconds = 30000;
    DWORD   dwWaitResult;
    BOOL    Itworked;

    WriteTrace(0x0a,"SnmpExtensionClose: Entering extension agent SnmpExtensionClose routine.\n");
    if ( !SetEvent(hStopAll) )
    {
        lastError = GetLastError(); // save error status
        WriteTrace(0x14,"SNMPEventLogDllMain: Error setting dll termination event %08X in process detach; code %lu\n",
            hStopAll, lastError);
        WriteLog(SNMPELEA_ERROR_SET_AGENT_STOP_EVENT, HandleToUlong(hStopAll), lastError);  // log error message
    }
    else
    {
        WriteTrace(0x0a,"SNMPEventLogDllMain: Shutdown event %08X is now complete\n",
                                hStopAll);
    }

    if (hServThrd)
    {
        WriteTrace(0x0a,"SNMPEventLogDllMain: Waiting for event log processing thread %08X to terminate\n", hServThrd);
        WriteTrace(0x0a,"SNMPEventLogDllMain: Checking for thread exit code value\n");
        Itworked = GetExitCodeThread(hServThrd, &dwThreadID);
        WriteTrace(0x0a,"SNMPEventLogDllMain: Thread exit code value is %lu\n",dwThreadID);

        if (!Itworked || (dwThreadID == STILL_ACTIVE))
        {
            if (!Itworked)
            {
                lastError = GetLastError();
                WriteTrace(0x14,"SNMPEventLogDllMain: GetExitCodeThread returned FALSE, reason code %lu\n",
                        lastError);
                WriteLog(SNMPELEA_GET_EXIT_CODE_THREAD_FAILED, lastError);
            }
            else
            {
                WriteTrace(0x0a,"SNMPEventLogDllMain: Thread exit code indicates still active. Will wait...\n");
            }

            // wait for the child to end
            WriteTrace(0x0a,"SNMPEventLogDllMain: About to wait...\n");
            // bug# 277187: removal of TerminateThread by waiting until hServThrd has gone
            dwWaitResult = WaitForSingleObject(hServThrd, INFINITE);
            WriteTrace(0x0a,"SNMPEventLogDllMain: Finished wait...\n");

            switch (dwWaitResult)
            {
            case WAIT_FAILED:
                lastError = GetLastError(); // save error status
                WriteTrace(0x14,"SNMPEventLogDllMain: Error on WaitForSingleObject/log processing thread %08X; code %lu\n",
                        hServThrd, lastError);
                WriteLog(SNMPELEA_ERROR_WAIT_LOG_THREAD_STOP,
                        HandleToUlong(hServThrd), lastError);    // log error message
                break;
            case WAIT_OBJECT_0 :
                WriteTrace(0x0a,"SNMPEventLogDllMain: Event log processing thread %08X has terminated!\n",hServThrd);
                break;
            case WAIT_TIMEOUT :
                WriteTrace(0x14,"SNMPEventLogDllMain: Event log processing thread %08X has not terminated within 30 seconds; terminating thread\n",
                        hServThrd);
                WriteLog(SNMPELEA_LOG_THREAD_STOP_WAIT_30,
                        HandleToUlong(hServThrd));  // log error message
                break;
            default :
                WriteTrace(0x14,"SNMPEventLogDllMain: Unknown result from WaitForSingleObject waiting on log processing thread %08X termination is %lu\n",
                        hServThrd, dwWaitResult );
                WriteLog(SNMPELEA_WAIT_LOG_STOP_UNKNOWN_RETURN,
                        HandleToUlong(hServThrd), dwWaitResult);  // log error message
            }
        }

        WriteTrace(0x0a,"SNMPEventLogDllMain: Checking for thread exit code again\n");
        Itworked = GetExitCodeThread(hServThrd, &dwThreadID);
        WriteTrace(0x0a,"SNMPEventLogDllMain: Thread exit code value is %lu\n",dwThreadID);

        WriteTrace(0x0a,"SNMPEventLogDllMain: Closing handle to log processing thread %08X\n",
                hServThrd);
        if ( !CloseHandle(hServThrd) )
        {
            lastError = GetLastError(); // save error status
            WriteTrace(0x14,"SNMPEventLogDllMain: Error closing handle for log processing thread %08X; code %lu\n",
                    hServThrd, lastError);
            WriteLog(SNMPELEA_ERROR_CLOSING_STOP_LOG_THREAD_HANDLE,
                    HandleToUlong(hServThrd), lastError); // log error message
        }
    }

    CloseStopAll();                     // close event handle
    CloseEventNotify();                 // close event handle
    if (fRegOk)
    {
        CloseRegNotify();               // close event handle
        CloseRegParmKey();              // close registry key
    }
    CloseLogs();                        // close all open log files
    CloseSourceHandles();

    WriteLog(SNMPELEA_STOPPED);

    DeregisterEventSource(hWriteEvent); // no longer a need for logging
    WriteTrace(0x14,"SNMPEventLogDllMain: SNMPELEA Event Log Extension Agent DLL has terminated\n");
}
}


BOOL
BuildThresholdTrap(
    IN  VOID
    )

/*++

Routine Description:

        This routine will build the threshold trap.


Arguments:

        None


Return Value:

        TRUE if created varbind, FALSE if an error occurred.

--*/

{
        TCHAR   szBuf[MAX_PATH+1];      // for OID conversion
        UINT    i;                                      // counter

        WriteTrace(0x0a,"BuildThresholdTrap: Building static variable bindings for threshold trap\n");
        WriteTrace(0x00,"BuildThresholdTrap: &thresholdVarBind is at %08X\n", &thresholdVarBind);
        WriteTrace(0x00,"BuildThresholdTrap: thresholdVarBind is %08X\n", thresholdVarBind);

        WriteTrace(0x00,"BuildThresholdTrap: BaseEnterpriseOID value read is %s\n", szBaseOID);

        if ( !StrToOid((char *) &szBaseOID, &thresholdOID) )
        {
                WriteTrace(0x14,"BuildThresholdTrap: Unable to convert OID from BaseEnterpriseOID\n");
                WriteLog(SNMPELEA_CANT_CONVERT_ENTERPRISE_OID);
                return(FALSE);
        }

        strcpy(szBuf, szBaseOID);                               // copy base string
        strcat(szBuf, TEXT(".1.0"));                    // tack on for varbind OID

        thresholdVarBind.list = (RFC1157VarBind *) SNMP_malloc(sizeof(RFC1157VarBind)); // allocate storage for varbind

        if (thresholdVarBind.list == NULL)
        {
                WriteTrace(0x14,"BuildThresholdTrap: Unable to allocate storage for varbind\n");
                WriteLog(SNMPELEA_ERROR_ALLOC_VAR_BIND);
                return(FALSE);
        }

        WriteTrace(0x00,"BuildThresholdTrap: Storage allocated for varbind entry at address at %08X\n",
                thresholdVarBind.list);

        thresholdVarBind.len = 1;               // set # of varbinds

        WriteTrace(0x00,"BuildThresholdTrap: Number of varbinds present set to %lu\n",
                thresholdVarBind.len);

        TCHAR * tempthreshmsg = (TCHAR *) SNMP_malloc(strlen(lpszThreshold) + 1);
        strcpy(tempthreshmsg, lpszThreshold);

        thresholdVarBind.list[0].value.asnValue.string.length = strlen(tempthreshmsg);  // get string length
        thresholdVarBind.list[0].value.asnValue.string.stream = (PUCHAR) tempthreshmsg; // point to string
        thresholdVarBind.list[0].value.asnValue.string.dynamic = TRUE;  // indicate not dynamically allocated
        thresholdVarBind.list[0].value.asnType = ASN_RFC1213_DISPSTRING;        // indicate type of object

        if ( !StrToOid((char *) &szBuf, &thresholdVarBind.list[0].name) )
        {
                WriteTrace(0x14,"BuildThresholdTrap: Unable to convert OID from BaseEnterpriseOID\n");
                WriteLog(SNMPELEA_CANT_CONVERT_ENTERPRISE_OID);
                SNMP_free(thresholdVarBind.list);
                return (FALSE);
        }

        if (nTraceLevel == 0)
        {
                WriteTrace(0x00,"BuildThresholdTrap: Varbind entry length is %lu\n",
                        thresholdVarBind.list[0].value.asnValue.string.length);
                WriteTrace(0x00,"BuildThresholdTrap: Varbind entry string is %s\n",
                        thresholdVarBind.list[0].value.asnValue.string.stream);
                WriteTrace(0x00,"BuildThresholdTrap: Varbind OID length is %lu\n",
                        thresholdVarBind.list[0].name.idLength);

                for (i = 0; i < thresholdVarBind.list[0].name.idLength; i++)
                {
                        WriteTrace(0x00,"BuildThresholdTrap: Varbind OID[%lu] is %lu\n",
                                i, thresholdVarBind.list[0].name.ids[i]);
                }
        }

        WriteTrace(0x00,"BuildThresholdTrap: &thresholdOID is at %08X\n", &thresholdOID);
        WriteTrace(0x00,"BuildThresholdTrap: thresholdOID is %08X\n", thresholdOID);
        WriteTrace(0x00,"BuildThresholdTrap: &thresholdVarBind is at %08X\n", &thresholdVarBind);
        WriteTrace(0x00,"BuildThresholdTrap: thresholdVarBind is %08X\n", thresholdVarBind);
        WriteTrace(0x0a,"BuildThresholdTrap: Variable bindings for threshold trap have been built\n");

        return (TRUE);
}


extern "C" {
BOOL
APIENTRY
SnmpExtensionTrap(
    IN  OUT AsnObjectIdentifier *enterprise,
                OUT AsnInteger          *genericTrap,
                OUT AsnInteger          *specificTrap,
                OUT AsnTimeticks        *timeStamp,
    IN  OUT RFC1157VarBindList  *variableBindings
        )

/*++

Routine Description:

        SnmpExtensionTrap is the extension dll trap processing routine.

        This routine will query the log processing output queue to determine if a trap has been
        generated and needs to be returned. A Mutex object is used to synchronize processing
        between this thread and the log event processing thread.

Arguments:

        enterprise                      -       Points to an OID indicating the originating enterprise generating the trap.

        genericTrap                     -       Points to an indication of the generic trap. Always indicates specific.

        specificTrap            -       Points to an indication of the specific trap generated. This is the
                                                        event log message number.

        timeStamp                       -       Points to a variable to receive the time stamp.

        variableBindings        -       Points to a list of variable bindings.

Return Value:

        TRUE    -       Valid trap data is being returned.

        FALSE   -       No traps were on the queue to process.

--*/

{
        LONG                    lastError;                              // GetLastError value
        UINT                    i,j;                                    // counter
        DWORD                   status, dwTimeNow;              // status variable and temp time holder
        HANDLE                  hWaitList[2];                   // wait list
        PVarBindQueue   lpNewVarBindQueue;              // temporary pointer
        DWORD                   dwOne = 1;                              // for registry setting

        WriteTrace(0x0a,"SnmpExtensionTrap: Entering SnmpExtensionTrap routine\n");
        
        hWaitList[0] = hMutex;                          // mutex handle
        hWaitList[1] = hStopAll;                        // DLL termination event handle

        WriteTrace(0x00,"SnmpExtensionTrap: Varbind list upon entry is %08X\n", variableBindings);
        WriteTrace(0x00,"SnmpExtensionTrap: Varbind queue upon entry is %08X\n", lpVarBindQueue);
        WriteTrace(0x00,"SnmpExtensionTrap: Handle to Mutex object is %08X\n", hMutex);
        WriteTrace(0x0a,"SnmpExtensionTrap: Waiting for Mutex object to become available\n");

        while (TRUE)
        {
                status = WaitForMultipleObjects(
                        2,                                                              // only two objects to wait on
                        (CONST PHANDLE) &hWaitList,             // address of array of event handles
                        FALSE,                                                  // only one event is required
                        1000);                                                  // only wait one second

                lastError = GetLastError();                     // save any error conditions
                WriteTrace(0x0a,"SnmpExtensionTrap: WaitForMulitpleObjects returned a value of %lu\n", status);

                switch (status)
                {
                        case WAIT_FAILED:
                                WriteTrace(0x14,"SnmpExtensionTrap: Error waiting for mutex event array is %lu\n",
                                        lastError);                                     // trace error message
                                WriteLog(SNMPELEA_ERROR_WAIT_ARRAY, lastError); // log error message
                                WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                                return(FALSE);                                  // get out now
                        case WAIT_TIMEOUT:
                                WriteTrace(0x0a,"SnmpExtensionTrap: Mutex object not available yet. Wait will continue.\n");
                                continue;                                               // retry the wait
                        case WAIT_ABANDONED:
                                WriteTrace(0x14,"SnmpExtensionTrap: Mutex object has been abandoned.\n");
                                WriteLog(SNMPELEA_MUTEX_ABANDONED);
                                WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                                return(FALSE);                                  // get out now
                        case 1:
                                WriteTrace(0x0a,"SnmpExtensionTrap: DLL shutdown detected. Wait abandoned.\n");
                                WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                                return(FALSE);
                        case 0:
                                WriteTrace(0x0a,"SnmpExtensionTrap: Mutex object acquired.\n");
                                break;
                        default:
                                WriteTrace(0x14,"SnmpExtensionTrap: Undefined error encountered in WaitForMultipleObjects. Wait abandoned.\n");
                                WriteLog(SNMPELEA_ERROR_WAIT_UNKNOWN);
                                WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                                return(FALSE);                                  // get out now
                }       // end switch for processing WaitForMultipleObjects

                break;                  // if we get here, then we've got the Mutex object

        }       // end while true for acquiring Mutex object

        while (TRUE)
        {
            if ( lpVarBindQueue == (PVarBindQueue) NULL )
            {
                    WriteTrace(0x0a,"SnmpExtensionTrap: Varbind queue pointer indicates no more data to process\n");

                    WriteTrace(0x0a,"SnmpExtensionTrap: Releasing mutex object %08X\n", hMutex);
                    if (!ReleaseMutex(hMutex))
                    {
                            lastError = GetLastError();             // get error information
                            WriteTrace(0x14,"SnmpExtensionTrap: Unable to release mutex object for reason code %lu\n",
                                    lastError);
                            WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
                    }

                    WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                    return(FALSE);                          // exit and indicate pointers are valid
            }

            if (lpVarBindQueue->fProcessed)
            {
                    dwTrapQueueSize--;
                    WriteTrace(0x0a,"SnmpExtensionTrap: Current queue pointer indicates processed trap\n");
                    WriteTrace(0x00,"SnmpExtensionTrap: Freeing processed trap storage\n");

                    WriteTrace(0x00,"SnmpExtensionTrap: Freeing enterprise OID %08X\n",
                            lpVarBindQueue->enterprise);
                    SNMP_free(lpVarBindQueue->enterprise->ids);                     // free enterprise OID
                    SNMP_free(lpVarBindQueue->enterprise);
                    WriteTrace(0x00,"SnmpExtensionTrap: Saving forward buffer pointer %08X\n",
                            lpVarBindQueue->lpNextQueueEntry);
                    lpNewVarBindQueue = lpVarBindQueue->lpNextQueueEntry;   // save forward pointer

    // The following will free the storage for the VarBindQueue entry. This includes:
    //              enterprise
    //              dwEventTime
    //              dwEventID
    //              lpVariableBindings
    //              fProcessed
    //              lpNextQueueEntry

                    WriteTrace(0x00,"SnmpExtensionTrap: Freeing varbind list pointer %08X\n",
                            lpVarBindQueue->lpVariableBindings);
                    SNMP_free(lpVarBindQueue->lpVariableBindings);                  // free varbind list pointer
                    WriteTrace(0x00,"SnmpExtensionTrap: Freeing varbind queue entry storage %08X\n",
                            lpVarBindQueue);
                    SNMP_free(lpVarBindQueue);                                                      // free remaining storage
                    lpVarBindQueue = lpNewVarBindQueue;                                     // reset current pointer
                    WriteTrace(0x00,"SnmpExtensionTrap: Setting current buffer pointer to %08X\n",
                            lpVarBindQueue);
                    WriteTrace(0x0a,"SnmpExtensionTrap: Reentering process loop for next buffer entry\n");

//While cleaning up check to see if threshold trap needs to be sent

                    if (fThresholdEnabled && fThreshold && fSendThresholdTrap)
                    {
                            WriteTrace(0x0a,"SnmpExtensionTrap: Sending trap to indicate performance threshold has been reached.\n");
                            fSendThresholdTrap = FALSE;             // reset indicator

                            WriteTrace(0x0a,"SnmpExtensionTrap: Delete all varbind entries\n");

                            //delete all the entries in the varbind queue.
                            while ( lpVarBindQueue != (PVarBindQueue) NULL )
                            {
                                lpNewVarBindQueue = lpVarBindQueue->lpNextQueueEntry;   // save forward pointer
                                FreeVarBind(lpVarBindQueue->lpVariableBindings->len,
                                                    lpVarBindQueue->lpVariableBindings);    // free varbind information
                                SNMP_free(lpVarBindQueue->enterprise->ids);                 // free enterprise OID field
                                SNMP_free(lpVarBindQueue->enterprise);                      // free enterprise OID field
                                SNMP_free(lpVarBindQueue->lpVariableBindings->list);        // free varbind storage
                                SNMP_free(lpVarBindQueue->lpVariableBindings);              // free varbind list storage
                                SNMP_free(lpVarBindQueue);                                  // free varbind entry
                                lpVarBindQueue = lpNewVarBindQueue;                         // reset current pointer
                            }

                            WriteTrace(0x0a,"SnmpExtensionTrap: Deleted all entries, releasing mutex object %08X\n", hMutex);

                            if (!ReleaseMutex(hMutex))
                            {
                                    lastError = GetLastError();             // get error information
                                    WriteTrace(0x14,"SnmpExtensionTrap: Unable to release mutex object for reason code %lu\n",
                                            lastError);
                                    WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
                            }

                            if (!BuildThresholdTrap())
                            {
                                    return (FALSE);
                            }

                            *enterprise = *(&thresholdOID);                                 // point to enterprise OID field
                            *genericTrap = SNMP_GENERICTRAP_ENTERSPECIFIC;  // indicate a specific type trap
                            *timeStamp = GetCurrentTime() - dwTimeZero;             // get time reference for trap
                            *specificTrap = SNMPELEA_THRESHOLD_REACHED & 0x0000ffff;        // get log message number
                            *variableBindings = *(&thresholdVarBind);               // get varbind list pointer

                            if (nTraceLevel == 0)
                            {
                                    WriteTrace(0x00,"SnmpExtensionTrap: *enterprise is %08X\n", *enterprise);
                                    WriteTrace(0x00,"SnmpExtensionTrap: &thresholdOID is %08X\n", &thresholdOID);
                                    WriteTrace(0x00,"SnmpExtensionTrap: *timeStamp is %08X\n", *timeStamp);
                                    WriteTrace(0x00,"SnmpExtensionTrap: *variableBindings is %08X\n", *variableBindings);
                                    WriteTrace(0x00,"SnmpExtensionTrap: &thresholdVarBind is %08X\n", &thresholdVarBind);
                                    WriteTrace(0x00,"SnmpExtensionTrap: *specificTrap is %08X\n", *specificTrap);
                                    WriteTrace(0x00,"SnmpExtensionTrap: SNMPELEA_THRESHOLD_REACHED is %08X\n", SNMPELEA_THRESHOLD_REACHED & 0x0000ffff);

                                    WriteTrace(0x00,"SnmpExtensionTrap: Number of entries in enterprise OID is %lu\n",
                                            enterprise->idLength);

                                    for (i = 0; i < enterprise->idLength; i++)
                                    {
                                            WriteTrace(0x00,"SnmpExtensionTrap: Enterprise OID[%lu] is %lu\n",
                                                    i, enterprise->ids[i]);
                                    }

                                    for (i = 0; i < variableBindings->len; i++)
                                    {
                                            WriteTrace(0x00,"SnmpExtensionTrap: Variable binding %lu is %s, length %lu\n",
                                                    i, variableBindings->list[i].value.asnValue.string.stream,
                                                    variableBindings->list[i].value.asnValue.string.length
                                                    );

                                            WriteTrace(0x00,"SnmpExtensionTrap: OID for this binding is (number of %lu):\n",
                                                    variableBindings->list[i].name.idLength);
                                            WriteTrace(0x00,"SnmpExtensionTrap: ");

                                            for (j = 0; j < variableBindings->list[i].name.idLength; j++)
                                            {
                                                    WriteTrace(MAXDWORD,"%lu.", variableBindings->list[i].name.ids[j]);
                                            }
                                            WriteTrace(MAXDWORD,"\n");
                                    }
                            }

                            WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with TRUE\n");
                            return(TRUE);                           // exit and indicate pointers are valid
                    }

                    continue;                                                                                       // reenter loop
            }

            *enterprise = *(lpVarBindQueue->enterprise);                            // point to enterprise OID field
            *genericTrap = SNMP_GENERICTRAP_ENTERSPECIFIC;                          // indicate a specific type trap
            *timeStamp = lpVarBindQueue->dwEventTime;                                       // get time reference for trap
            *specificTrap = lpVarBindQueue->dwEventID;                                      // get event log message number
            *variableBindings = *(lpVarBindQueue->lpVariableBindings);      // get varbind list pointer

            if (nTraceLevel == 0)
            {
                    WriteTrace(0x00,"SnmpExtensionTrap: *enterprise is %08X\n", *enterprise);
                    WriteTrace(0x00,"SnmpExtensionTrap: *(lpVarBindQueue->enterprise) is %08X\n",
                            lpVarBindQueue->enterprise);
                    WriteTrace(0x00,"SnmpExtensionTrap: *variableBindings is %08X\n", *variableBindings);
                    WriteTrace(0x00,"SnmpExtensionTrap: *(lpVarBindQueue->VariableBindings) is %08X\n",
                            lpVarBindQueue->lpVariableBindings);

                    WriteTrace(0x00,"SnmpExtensionTrap: Number of entries in enterprise OID is %lu\n",
                            enterprise->idLength);

                    for (i = 0; i < enterprise->idLength; i++)
                    {
                            WriteTrace(0x00,"SnmpExtensionTrap: Enterprise OID[%lu] is %lu\n",
                                    i, enterprise->ids[i]);
                    }

                    for (i = 0; i < variableBindings->len; i++)
                    {
                            WriteTrace(0x00,"SnmpExtensionTrap: Variable binding %lu is %s, length %lu\n",
                                    i, variableBindings->list[i].value.asnValue.string.stream,
                                    variableBindings->list[i].value.asnValue.string.length
                                    );

                            WriteTrace(0x00,"SnmpExtensionTrap: OID for this binding is (number of %lu):\n",
                                    variableBindings->list[i].name.idLength);
                            WriteTrace(0x00,"SnmpExtensionTrap: ");

                            for (j = 0; j < variableBindings->list[i].name.idLength; j++)
                            {
                                    WriteTrace(MAXDWORD,"%lu.", variableBindings->list[i].name.ids[j]);
                            }
                            WriteTrace(MAXDWORD,"\n");
                    }
            }

            lpVarBindQueue->fProcessed = TRUE;                              // indicate this entry processed
            break;
        }

        WriteTrace(0x0a,"SnmpExtensionTrap: Releasing mutex object %08X\n", hMutex);
        if (!ReleaseMutex(hMutex))
        {
                lastError = GetLastError();             // get error information
                WriteTrace(0x14,"SnmpExtensionTrap: Unable to release mutex object for reason code %lu\n",
                        lastError);
                WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
        }

        if (fThresholdEnabled)
        {
                if (!fThreshold)
                {
                        dwTimeNow = GetTickCount() / 1000;                              // get current time information

                        if (dwTrapStartTime == 0)
                        {
                                dwTrapCount = 1;                                                        // indicate first trap sent
                                dwTrapStartTime = dwTimeNow;                            // set start time
                        }
                        else
                        {
                                if ( (dwTimeNow - dwTrapStartTime) >= dwThresholdTime )
                                {
                                        WriteTrace(0x0a,"SnmpExtensionTrap:     Threshold time has been exceeded. Resetting threshold values.\n");
                                        dwTrapCount = 1;                                                // reset to 1 trap sent
                                        dwTrapStartTime = dwTimeNow;                    // set start time
                                }
                                else
                                {
                                        if (++dwTrapCount >= dwThresholdCount)
                                        {
                                                WriteTrace(0x0a,"SnmpExtensionTrap: Threshold count has been reached within defined performance parameters.\n");
                                                WriteTrace(0x0a,"SnmpExtensionTrap: Further traps will not be sent without operator intervention.\n");
                                                WriteLog(SNMPELEA_THRESHOLD_REACHED);

                                                fThreshold = TRUE;                                      // indicate performance stuff active
                                                fSendThresholdTrap = TRUE;                      // indicate to send the threshold reached trap next time

                                                dwTrapCount = 0;                                        // reset trap count
                                                dwTrapStartTime = 0;                            // indicate start time is invalid

                                                if ( (lastError = RegSetValueEx(
                                                        hkRegResult,                                    // registry key opened
                                                        EXTENSION_THRESHOLD_FLAG,               // which key value to set
                                                        NULL,                                                   // reserved
                                                        REG_DWORD,                                              // type of value to set
                                                        (const LPBYTE) &dwOne,                  // address of value to set to
                                                        sizeof(DWORD)                                   // size of the data value
                            ) != ERROR_SUCCESS)
                                                        )
                                                {
                                                        WriteTrace(0x14,"SnmpExtensionTrap: Unable to set registry key for threshold reached; RegSetValueEx returned %lu\n",
                                                                lastError);
                                                        WriteLog(SNMPELEA_SET_VALUE_FAILED, lastError);
                                                }

                                                WriteTrace(0x0a,"SnmpExtensionTrap: Threshold reached flag has been set in the registry\n");
                                        }
                                        else
                                        {
                                                WriteTrace(0x00,"SnmpExtensionTrap: Threshold count is %lu; time elapsed is %08X\n",
                                                        dwTrapCount, dwTimeNow - dwTrapStartTime);
                                        }
                                }
                        }
                }
        }

        WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with TRUE\n");
        return(TRUE);                                                                   // indicate that trap data is valid
}
}


extern "C" {
BOOL
APIENTRY
SnmpExtensionQuery(
    IN          BYTE                            requestType,
    IN  OUT     RFC1157VarBindList      *variableBindings,
    OUT         AsnInteger                      *errorStatus,
    OUT         AsnInteger                      *errorIndex
        )

/*++

Routine Description:

        SnmpExtensionQuery is the extension dll query processing routine.

        This routine is not supported and always returns an error.

Arguments:

        requestType                     -       Points to an OID indicating the originating enterprise generating the trap.

        variableBindings        -       Points to a list of variable bindings.

        errorStatus                     -       Points to a variable to receive the error status. Always ASN_ERRORSTATUS_NOSUCHNAME.

        errorIndex                      -       Points to a variable to receive the resulting error index. Always 0.

Return Value:

        Always returns TRUE.

--*/

{
    WriteTrace(0x0a,"SnmpExtensionQuery: Entering SnmpExtensionQuery routine\n");

    *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME; // indicate we don't know what they're asking for
    *errorIndex = 1;                            // indicate that it's the first varbind
                                                // show it's the first parameter

    if (requestType == MIB_ACTION_GETNEXT)
    {
        AsnObjectIdentifier oidOutOfView;

        // initialize oidOutOfView.ids, to avoid heap corruption when
        // when free-ed if StrToOid failed.
        oidOutOfView.ids = NULL;
        if (variableBindings != NULL && 
            StrToOid(szSupView, &oidOutOfView) &&
            oidOutOfView.idLength > 0)
        {
            UINT iVar;

            oidOutOfView.ids[oidOutOfView.idLength-1]++;

            for (iVar = 0; iVar < variableBindings->len; iVar++)
            {
                RFC1157VarBind *pVarBind;

                pVarBind = &(variableBindings->list[iVar]);
                SnmpUtilOidFree(&(pVarBind->name));
                SnmpUtilOidCpy(&(pVarBind->name), &oidOutOfView);
            }
            *errorStatus = SNMP_ERRORSTATUS_NOERROR;
            *errorIndex = 0;
        }

        SnmpUtilOidFree(&oidOutOfView);
    }


    WriteTrace(0x0a,"SnmpExtensionQuery: Exiting SnmpExtensionQuery routine\n");
    return(SNMPAPI_NOERROR);    // return to caller
}
}


// MikeCure 4/3/98 hotfix for SMS Bug1 #20521
//=============================================================================
//
//      EnablePrivileges()
//
//      Notes:  Added a new function to set the proper privileges on the
//              security log With NT 5 and NT4 SP5, the default privileges
//              no longer have access implicitely allowed. Now we've got to
//              grant explicit access.
//
//      Routine Description:
//              This routine enables all privileges in the token.
//
//      Arguments:
//              None.
//
//      Return Value:
//              BOOL.
//
//=============================================================================
BOOL EnablePrivilege(VOID)
{
    HANDLE Token;
    ULONG ReturnLength;
    PTOKEN_PRIVILEGES NewState;
    LUID Luid;
    BOOL Result;
    
    Token = NULL;
    NewState = NULL;
    
    Result = OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &Token
        );
    if (Result) {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES) malloc( ReturnLength );
        Result = (BOOL)(NewState != NULL);
        if (Result) {
            Result = GetTokenInformation( Token,            // TokenHandle
                TokenPrivileges,  // TokenInformationClass
                NewState,         // TokenInformation
                ReturnLength,     // TokenInformationLength
                &ReturnLength     // ReturnLength
                );
            
            if (Result) {
                //
                // Enable Security Privilege
                //
                Result = LookupPrivilegeValue(  NULL,
                    "SeSecurityPrivilege",
                    &Luid
                    );
                
                    if (Result) {
                    
                    NewState->PrivilegeCount = 1;
                    NewState->Privileges[0].Luid = Luid;
                    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                    
                    Result = AdjustTokenPrivileges( Token,          // TokenHandle
                        FALSE,          // DisableAllPrivileges
                        NewState,       // NewState (OPTIONAL)
                        ReturnLength,   // BufferLength
                        NULL,           // PreviousState (OPTIONAL)
                        &ReturnLength   // ReturnLength
                        );
                }       
            }
        }
                
        if (NewState != NULL) {
            free( NewState );
        }
        
        if (Token != NULL) {
            CloseHandle( Token );
        }
    }
    return( Result );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelea.h ===
#ifndef SNMPELEA_H
#define SNMPELEA_H

//
// NTSTATUS
//

typedef LONG NTSTATUS;
/*lint -e624 */  // Don't complain about different typedefs.   // winnt
typedef NTSTATUS *PNTSTATUS;
/*lint +e624 */  // Resume checking for different typedefs.    // winnt

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

// begin_winnt
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000
// end_winnt

typedef HMODULE *PHMODULE;

#define HANDLESIZE      sizeof(HANDLE)
#define EVENTRECSIZE    sizeof(EVENTLOGRECORD)
#define LOG_BUF_SIZE    4096
#define EVENTIDSIZE     4
#define MAX_QUEUE_SIZE  20

#define HALFMAXDWORD    0x80000000

#define SERVICE_ROOT                        TEXT("SYSTEM\\CurrentControlSet\\Services\\")
#define EXTENSION_ROOT                      TEXT("SOFTWARE\\Microsoft\\SNMP_EVENTS\\EventLog\\")
#define EXTENSION_SOURCES                   TEXT("SOFTWARE\\Microsoft\\SNMP_EVENTS\\EventLog\\Sources\\")

#define EVNTAGNT_NAME                       TEXT("EvntAgnt")
#define EVENTLOG_BASE       SERVICE_ROOT    TEXT("EventLog\\")
#define EVENTLOG_ROOT       EVENTLOG_BASE   TEXT("Application\\")
#define EVENTLOG_SERVICE    EVENTLOG_ROOT   EVNTAGNT_NAME

#define EXTENSION_PARM      EXTENSION_ROOT  TEXT("Parameters")

#define EXTENSION_MSG_MODULE                TEXT("EventMessageFile")
#define EXTENSION_PARM_MODULE               TEXT("ParameterMessageFile")
#define EXTENSION_PRIM_MODULE               TEXT("PrimaryModule")

#define EXTENSION_TRACE_FILE                TEXT("TraceFileName")
#define EXTENSION_TRACE_LEVEL               TEXT("TraceLevel")
#define EXTENSION_BASE_OID                  TEXT("BaseEnterpriseOID")
#define EXTENSION_SUPPORTED_VIEW            TEXT("SupportedView")
#define EXTENSION_TRIM                      TEXT("TrimMessage")
#define EXTENSION_MAX_TRAP_SIZE             TEXT("MaxTrapSize")
#define EXTENSION_TRIM_FLAG                 TEXT("TrimFlag")

#define EXTENSION_ENTERPRISE_OID            TEXT("EnterpriseOID")
#define EXTENSION_APPEND                    TEXT("Append")
#define EXTENSION_COUNT                     TEXT("Count")
#define EXTENSION_TIME                      TEXT("Time")
#define EXTENSION_THRESHOLD_FLAG            TEXT("Threshold")
#define EXTENSION_THRESHOLD_ENABLED         TEXT("ThresholdEnabled")
#define EXTENSION_THRESHOLD_COUNT           TEXT("ThresholdCount")
#define EXTENSION_THRESHOLD_TIME            TEXT("ThresholdTime")
#define EXTENSION_LASTBOOT_TIME             TEXT("LastBootTime")
#define EXTENSION_EVENT_LOG_POLL_TIME       TEXT("EventLogPollTime")

#define MUTEX_NAME                          TEXT("SnmpEventLogMutex")   // Mutex name

typedef struct  _VarBindQueue {
            DWORD               dwEventID;              // event ID
            DWORD               dwEventTime;            // time this event occurred
            BOOL                fProcessed;             // buffer processed flag
            AsnObjectIdentifier *enterprise;            // enterprise OID
            RFC1157VarBindList  *lpVariableBindings;    // variable bindings list
    struct  _VarBindQueue       *lpNextQueueEntry;      // pointer to next buffer structure
} VarBindQueue, *PVarBindQueue;

typedef struct    _SourceHandleList {
         HINSTANCE   handle;
         TCHAR       sourcename[MAX_PATH+1];
   struct _SourceHandleList   *Next;
} SourceHandleList, *PSourceHandleList;

const   UINT    MAX_TRAP_SIZE=4096;         // a guess provided by Microsoft
const   UINT    BASE_PDU_SIZE=300;          // a guess provided by Microsoft

const   UINT    THRESHOLD_COUNT=500;        // default performance threshold count
const   UINT    THRESHOLD_TIME=300;         // default performance threshold time in seconds

#endif                  // end of snmpelea.h definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelep.h ===
#ifndef SNMPELEA_P_H
#define SNMPELEA_P_H

	// prototype definitions for all log message functions

extern VOID WriteLog(NTSTATUS);
extern VOID WriteLog(NTSTATUS, DWORD);
extern VOID WriteLog(NTSTATUS, DWORD, DWORD);
extern VOID WriteLog(NTSTATUS, LPTSTR, DWORD, DWORD);
extern VOID WriteLog(NTSTATUS, DWORD, LPTSTR, LPTSTR, DWORD);
extern VOID WriteLog(NTSTATUS, DWORD, LPTSTR, DWORD, DWORD);
extern VOID WriteLog(NTSTATUS, LPTSTR, DWORD);
extern VOID WriteLog(NTSTATUS, LPTSTR);
extern VOID WriteLog(NTSTATUS, LPCTSTR, LPCTSTR);

#endif						// end of snmpelep.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelpt.h ===
#ifndef SNMPELPT_H
#define SNMPELPT_H

extern  PVarBindQueue       lpVarBindQueue;                     // pointer to varbind queue
extern  PSourceHandleList   lpSourceHandleList;                     // pointer to source/handle list
extern  DWORD               dwTimeZero;                         // time zero reference
extern  BOOL                fTrimFlag;                          // trimming flag
extern  PHANDLE             phEventLogs;                        // Opened Event Log Handles
extern  PHMODULE            phPrimHandles;                      // PrimaryModule file handle array
extern  UINT                uNumEventLogs;                      // Number of Opened Event Logs
extern  LPTSTR              lpszEventLogs;                      // event log name array
extern  DWORD               nTraceLevel;                        // current trace level

extern  INT                 iLogNameSize;                       // size of event log name array
extern  UINT                nMaxTrapSize;                       // maximum size of trap

extern  VOID                WriteTrace(UINT nLvl, LPSTR CONST szStuff, ...);

extern  HANDLE              hWriteEvent;                        // handle to write log events
extern  HANDLE              hStopAll;                           // handle to global dll shutdown event
extern  HANDLE              hEventNotify;                       // handle to notify dll that trap is ready
extern  HANDLE              hRegChanged;                        // handle to registry key changed event
extern  TCHAR               szBaseOID[MAX_PATH+1];              // base OID from registry
extern  TCHAR               szSupView[MAX_PATH+1];              // supported view from registry
extern  TCHAR               szelMsgModuleName[MAX_PATH+1];      // expanded DLL message module
extern  BOOL                fGlobalTrim;                        // global trim message flag
extern  BOOL                fRegOk;                             // registry notification in effect flag
extern  BOOL                Read_Registry_Parameters(VOID);     // reread registry parameters function
extern  BOOL                fThreshold;                         // global performance threshold reached flag
extern  BOOL                fThresholdEnabled;                  // global threshold enabled flag
extern  BOOL                fDoLogonEvents;
extern  DWORD               dwLastBootTime;
extern  DWORD               dwTrapQueueSize;
extern  BOOL                Position_to_Log_End(HANDLE  hLog);  // set the position of the eventlog to past last record
extern  HKEY                hkRegResult;
extern  DWORD               g_dwEventLogPollTime;               // time in millsecs to poll for event logs

typedef struct  _REGSTRUCT  {
    TCHAR   szOID[2*MAX_PATH+1];        // string area for EnterpriseOID field
    BOOL    fAppend;                    // append flag
    BOOL    fLocalTrim;                 // local message trim flag
    DWORD   nCount;                     // count field
    DWORD   nTime;                      // time field
}   REGSTRUCT, *PREGSTRUCT;

typedef struct  _CNTTABSTRUCT   {
    TCHAR   log[MAX_PATH+1];            // log file for entry
    DWORD   event;                      // event id
    TCHAR   source[MAX_PATH+1];         // source for event
    DWORD   curcount;                   // current count for event
    DWORD   time;                       // last time of event from GetCurrentTime()
    struct  _CNTTABSTRUCT   *lpNext;    // pointer to next entry in the table
}   COUNTTABLE, *PCOUNTTABLE;

        PCOUNTTABLE         lpCountTable = (PCOUNTTABLE) NULL;  // address of count/time table
        HANDLE              hMutex;                             // handle for mutex object

#endif                              // end of snmpelpt.h definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelpt.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    SNMPELPT.CPP


Abstract:

    This routine is the event log processing thread for the SNMP Event Log Agent DLL.
    The function of this routine is to wait for an event to occur, as indicated by an
    event log record, check the registry to determine if the event is being tracked,
    then to return a buffer to the processing agent DLL indicating that an SNMP trap
    should be sent to the extension agent. An event is posted complete when a buffer is
    built and ready for trap processing.

    In order to maintain data integrity between this thread and the processing agent
    thread, a MUTEX object is used to synchronize access to the trap buffer queue. If
    an error occurs, an event log message and trace records are written to indicate the
    problem and the event is ignored.

    When the extension agent is terminated, the processing agent DLL receives control
    in the process detach routine. An event is posted complete to indicate to this thread
    that processing should be terminated and all event logs should be closed.

Author:

    Randy G. Braze  Created 16 October 1994


Revision History:

    7 Feb 96    Restructured building of varbinds to be outside of trap generation.
                Calculated trap buffer length correctly.
                Created varbind queue and removed event log buffer queue.

    28 Feb 96   Added code to support a performance threshold reached indicator.
                Removed inclusion of base OID information from varbind OIDs.
                Added conversion from OEM to current code page for varbind data.
                Removed pointer references to varbindlist and enterpriseoid.
                Fixed memory leak for not freeing storage arrays upon successful build of trap.

    10 Mar 96   Removed OemToChar coding and registry checking.
                Modifications to read log file names from EventLog registry entries and not
                from specific entries in the SNMP Extension Agent's registry entries.
                Included SnmpMgrStrToOid as an internal function, as opposed to using the function
                provided by MGMTAPI.DLL. SNMPTRAP.EXE will be called if MGMTAPI is called, which
                will disable other agents from being able to receive any traps. All references
                to MGMTAPI.DLL and MGMTAPI.H will be removed.
                Added a ThresholdEnabled flag to the registry to indicate if the threshold values
                were to be monitored or ignored.

    15 Mar 96   Modified to move the sources for the eventlog in the registry down below a new
                key called Sources.

    07 May 96   Removed SnmpUtilOidFree and use two SNMP_free. One for the OID's ids array and
                one for the OID itself.

    22 May 96   Edited FreeVarBind to make sure we only freed memory we allocated.

    26 Jun 96   Added code to make sure message dlls were not loaded and unloaded (leaks) just have
                a list of handles to the loaded dlls and free them at the end. Also plugged some other
                memory leaks. Added a function to make sure the CountTable is kept tidy.


--*/

extern "C" {
#include <windows.h>        // basic windows applications information
#include <winperf.h>
#include <stdlib.h>
#include <malloc.h>         // needed for memory allocations
#include <string.h>         // string stuff
#include <snmp.h>           // snmp stuff
// #include <mgmtapi.h>     // snmp mgr definitions
#include <TCHAR.H>
#include <time.h>

#include "snmpelea.h"       // global dll definitions
#include "snmpelpt.h"       // module specific definitions
#include "snmpelmg.h"       // message definitions
}
#include <new> // prefix bug 445191
#include "snmpelep.h"       // c++ definitions and variables
extern  BOOL                StrToOid(PCHAR str, AsnObjectIdentifier *oid);

void
TidyCountTimeTable(
    IN      LPTSTR      lpszLog,            // pointer to log file name
    IN      LPTSTR      lpszSource,         // pointer to source of event
    IN      DWORD       nEventID            // event ID
    )

/*++

Routine Description:

    TidyCountTimeTable is called to remove items from the lpCountTable which no longer
    have a count greater than 1.


Arguments:

    lpszLog     -   Pointer to the log file for this event.

    lpszSource  -   Pointer to source for this event.

    nEventID    -   Event ID.


Return Value:

    None.
    

--*/

{
    PCOUNTTABLE lpTable;                // temporary fields
    PCOUNTTABLE lpPrev;

    WriteTrace(0x0a,"TidyCountTimeTable: Entering TidyCountTimeTable routine\n");
    
    if (lpCountTable == NULL)
    {
        WriteTrace(0x0a,"TidyCountTimeTable: Empty table, exiting TidyCountTimeTable\n");
        return;
    }

    // if we get here, then a table exists and must be scanned for a current entry

    lpTable = lpCountTable;                         // start with first table pointer
    lpPrev = NULL;                                  // set previous to NULL

    while (TRUE)
    {
        WriteTrace(0x0a,"TidyCountTimeTable: Checking entry %08X\n", lpTable);

        if ((strcmp(lpTable->log,lpszLog) != 0) ||
            (strcmp(lpTable->source,lpszSource) != 0) ||
            (lpTable->event != nEventID)
            )
        {
            if (lpTable->lpNext == NULL)
            {
                WriteTrace(0x0a,"TidyCountTimeTable: Entry not found\n");       
                break;
            }

            lpPrev = lpTable;
            lpTable = lpTable->lpNext;              // point to next entry
            continue;                               // continue the loop
        }

        if (lpPrev == NULL)
        {
            WriteTrace(0x0a,"TidyCountTimeTable: Freeing first entry in lpCountTable at %08X\n", lpTable);
            lpCountTable = lpCountTable->lpNext;
            SNMP_free(lpTable);
        }
        else
        {
            WriteTrace(0x0a,"TidyCountTimeTable: Freeing entry in lpCountTable at %08X\n", lpTable);
            lpPrev->lpNext = lpTable->lpNext;
            SNMP_free(lpTable);
        }

        break;
    }
    
    WriteTrace(0x0a,"TidyCountTimeTable: Exiting TidyCountTimeTable\n");
    return;
}

BOOL
CheckCountTime(
    IN      LPTSTR      lpszLog,            // pointer to log file name
    IN      LPTSTR      lpszSource,         // pointer to source of event
    IN      DWORD       nEventID,           // event ID
    IN      DWORD       dwTime,             // time of event
    IN      PREGSTRUCT  regStruct           // pointer to registry structure
    )

/*++

Routine Description:

    CheckCountTime is called to determine if a specific event with count and/or time
    values specified in the registry have met the indicated criteria. If an entry does
    not exist in the current table of entries, a new entry is added for later tracking.


Arguments:

    lpszLog     -   Pointer to the log file for this event.

    lpszSource  -   Pointer to source for this event.

    nEventID    -   Event ID.

    regStruct   -   Pointer to a structure where data read from the registry is provided.


Return Value:

    TRUE    -   If a trap should be sent. Count and/or time value criteria satisified.

    FALSE   -   If no trap should be sent.


--*/

{
    PCOUNTTABLE lpTable;                // temporary field
    DWORD       dwTimeDiff = 0;             // temporary field

    WriteTrace(0x0a,"CheckCountTime: Entering CheckCountTime routine\n");
    if (lpCountTable == NULL)
    {
        WriteTrace(0x0a,"CheckCountTime: Count/Time table is currently empty. Adding entry.\n");
        lpCountTable = (PCOUNTTABLE) SNMP_malloc(sizeof(COUNTTABLE));
        if (lpCountTable == NULL)
        {
            WriteTrace(0x14,"CheckCountTime: Unable to acquire storage for Count/Time table entry.\n");
            WriteLog(SNMPELEA_COUNT_TABLE_ALLOC_ERROR);
            return(FALSE);
        }
        lpCountTable->lpNext = NULL;                // set forward pointer to null
        strcpy(lpCountTable->log,lpszLog);          // copy log file name to table
        strcpy(lpCountTable->source,lpszSource);    // copy source name to table
        lpCountTable->event = nEventID;             // copy event id to table
        lpCountTable->curcount = 0;                 // set table count to 0
        lpCountTable->time = dwTime;                // set table time to event time
        WriteTrace(0x0a,"CheckCountTime: New table entry is %08X\n", lpCountTable);
    }

    // if we get here, then a table exists and must be scanned for a current entry

    lpTable = lpCountTable;                         // start with first table pointer

    while (TRUE)
    {
        WriteTrace(0x0a,"CheckCountTime: Checking entry %08X\n", lpTable);

        if ((strcmp(lpTable->log,lpszLog) != 0) ||
            (strcmp(lpTable->source,lpszSource) != 0) ||
            (lpTable->event != nEventID)
            )
        {
            if (lpTable->lpNext == NULL)
            {
                break;
            }
            lpTable = lpTable->lpNext;              // point to next entry
            continue;                               // continue the loop
        }

        dwTimeDiff = dwTime - lpTable->time;        // compute elapsed time in seconds

        WriteTrace(0x0a,"CheckCountTime: Entry information located in table at %08X\n", lpTable);
        WriteTrace(0x00,"CheckCountTime: Entry count value is %lu\n",lpTable->curcount);
        WriteTrace(0x00,"CheckCountTime: Entry last time value is %08X\n",lpTable->time);
        WriteTrace(0x00,"CheckCountTime: Entry current time value is %08X\n",dwTime);
        WriteTrace(0x00,"CheckCountTime: Time difference is %lu\n",dwTimeDiff);
        WriteTrace(0x00,"CheckCountTime: Registry count is %lu, time is %lu\n",
            regStruct->nCount, regStruct->nTime);

        if (regStruct->nTime)
        {
            WriteTrace(0x0a,"CheckCountTime: Time value is being checked\n");
            if (dwTimeDiff > regStruct->nTime)
            {
                WriteTrace(0x0a,"CheckCountTime: Specified time parameters exceeded for entry. Resetting table information.\n");
                lpTable->time = dwTime;                 // reset time field
                lpTable->curcount = 1;                  // reset count field
                WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
                return(FALSE);
            }
        }

        if (++lpTable->curcount >= regStruct->nCount)
        {
            WriteTrace(0x0a,"CheckCountTime: Count field has been satisfied for entry\n");
            lpTable->curcount = 0;                      // reset count field for event
            lpTable->time = dwTime;                     // reset time field
            WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with TRUE\n");
            return(TRUE);
        }
        else
        {
            WriteTrace(0x0a,"CheckCountTime: Count field not satisfied for entry\n");
            WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
            return(FALSE);
        }
    }

    // if we get here, then a table entry does not exist for the current entry

    lpTable->lpNext = (PCOUNTTABLE) SNMP_malloc(sizeof(COUNTTABLE));    // allocate storage for new entry
    lpTable = lpTable->lpNext;              // set table pointer

    // prefix bug 445190
    if (lpTable == NULL)
    {
        WriteTrace(0x14,"CheckCountTime: Unable to acquire storage for Count/Time table entry.\n");
        WriteLog(SNMPELEA_COUNT_TABLE_ALLOC_ERROR);
        return(FALSE);
    }

    lpTable->lpNext = NULL;                 // set forward pointer to NULL
    strcpy(lpTable->log,lpszLog);           // copy log file name to table
    strcpy(lpTable->source,lpszSource);     // copy source name to table
    lpTable->event = nEventID;              // copy event id to table
    lpTable->curcount = 0;                  // set table count to 0
    lpTable->time = dwTime;                 // set table time to event time
    WriteTrace(0x0a,"CheckCountTime: New table entry added at %08X\n", lpTable);

    if (regStruct->nTime)
    {
        WriteTrace(0x0a,"CheckCountTime: Time value is being checked\n");
        if (dwTimeDiff > regStruct->nTime)
        {
            WriteTrace(0x0a,"CheckCountTime: Specified time parameters exceeded for entry. Resetting table information.\n");
            lpTable->time = dwTime;                 // reset time field
            lpTable->curcount = 1;                  // reset count field
            WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
            return(FALSE);
        }
    }

    if (++lpTable->curcount >= regStruct->nCount)
    {
        WriteTrace(0x0a,"CheckCountTime: Count field has been satisfied for entry\n");
        lpTable->curcount = 0;                      // reset count field for event
        lpTable->time = dwTime;                     // reset time field
        WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with TRUE\n");
        return(TRUE);
    }
    else
    {
        WriteTrace(0x0a,"CheckCountTime: Count field not satisfied for entry\n");
        WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
        return(FALSE);
    }

//  default exit point (should never occur)

    WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
    return(FALSE);
}

BOOL
GetRegistryValue(
    IN      LPTSTR      sourceName,         // source name for event
    IN      LPTSTR      eventID,            // event ID for event
    IN      LPTSTR      logFile,            // log file of event
    IN      DWORD       timeGenerated,      // time this event was generated
    IN  OUT PREGSTRUCT  regStruct           // pointer to registry structure to return
    )

/*++

Routine Description:

    GetRegistryValue is called to read a specific key value from the system registry.


Arguments:

    sourceName      -   Specifies the source name from the event log.

    eventID         -   This the event ID from the event log record.

    regStruct       -   Pointer to a structure where data will be returned from the registry.


Return Value:

    TRUE    -   If a registry entry is located and all parameters could be read.

    FALSE   -   If no registry entry exists or some other error occurs.


--*/

{
    LONG    status;                     // registry read results
    HKEY    hkResult;                   // handle returned from API
    DWORD   iValue;                     // temporary counter
    DWORD   dwType;                     // type of the parameter read
    DWORD   nameSize;                   // length of parameter name
    DWORD   nReadBytes = 0;             // number of bytes read from profile information
    LPTSTR  lpszSourceKey;              // temporary string for registry source key
    LPTSTR  lpszEventKey;               // temporary string for registry event key
    TCHAR   temp[2*MAX_PATH+1];         // temporary string

    WriteTrace(0x0a,"GetRegistryValue: Entering GetRegistryValue function\n");

    if (fThresholdEnabled && fThreshold)
    {
        WriteTrace(0x0a,"GetRegistryValue: Performance threshold flag is on. No data will be processed.\n");
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);
    }

    if ( (lpszSourceKey = (LPTSTR) SNMP_malloc(strlen(EXTENSION_SOURCES)+strlen(sourceName)+2)) == NULL )
    {
        WriteTrace(0x14,"GetRegistryValue: Unable to allocate registry source key storage. Trap not sent.\n");
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);
    }

    if ( (lpszEventKey = (LPTSTR) SNMP_malloc(strlen(EXTENSION_SOURCES)+strlen(sourceName)+strlen(eventID)+3)) == NULL )
    {
        WriteTrace(0x14,"GetRegistryValue: Unable to allocate registry event key storage. Trap not sent.\n");
        SNMP_free(lpszSourceKey);
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);
    }

    strcpy(lpszSourceKey,EXTENSION_SOURCES);    // start with root
    strcat(lpszSourceKey,sourceName);           // append the source name
    strcpy(lpszEventKey,lpszSourceKey);         // build prefix for event key
    strcat(lpszEventKey,TEXT("\\"));			// add the backslash
    strcat(lpszEventKey,eventID);               // complete it with the event ID

    WriteTrace(0x00,"GetRegistryValue: Opening registry key for %s\n",lpszEventKey);

    if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszEventKey, 0,
        (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS), &hkResult))
        != ERROR_SUCCESS)                   // open registry information
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            lpszEventKey, status);
        SNMP_free(lpszSourceKey);           // free storage
        SNMP_free(lpszEventKey);                // free storage
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);                  // show nothing exists
    }

    nameSize = sizeof(iValue);          // set field length
    if ( (status = RegQueryValueEx(     // look up count
        hkResult,                       // handle to registry key
        EXTENSION_COUNT,                // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return count field
        &nameSize) ) != ERROR_SUCCESS)  // size of count field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_COUNT, status);
        regStruct->nCount = 0;          // set default value
    }
    else
    {
        regStruct->nCount = iValue;     // save returned value
        WriteTrace(0x00,"GetRegistryValue: Count field is %lu\n", regStruct->nCount);
    }

    if ( (status = RegQueryValueEx(     // look up local trim
        hkResult,                       // handle to registry key
        EXTENSION_TRIM,                 // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return count field
        &nameSize) ) != ERROR_SUCCESS)  // size of count field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_TRIM, status);
        WriteTrace(0x00,"GetRegistryValue: Using default of global trim message flag of %lu\n",
            fGlobalTrim);
        regStruct->fLocalTrim = fGlobalTrim;    // set default value
    }
    else
    {
        regStruct->fLocalTrim = ((iValue == 1) ? TRUE : FALSE); // save returned value
        WriteTrace(0x00,"GetRegistryValue: Local message trim field is %lu\n", regStruct->fLocalTrim);
    }

    if ( (status = RegQueryValueEx(     // look up time
        hkResult,                       // handle to registry key
        EXTENSION_TIME,                 // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return time field
        &nameSize) ) != ERROR_SUCCESS)  // size of time field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_TIME, status);
        regStruct->nTime = 0;           // set default value
    }
    else
    {
        regStruct->nTime = iValue;      // save returned value
        WriteTrace(0x00,"GetRegistryValue: Time field is %lu\n", regStruct->nTime);
    }

    RegCloseKey(hkResult);              // close registry key for event
    SNMP_free(lpszEventKey);                    // free the storage for the event key

    WriteTrace(0x00,"GetRegistryValue: Opening registry key for %s\n",lpszSourceKey);

    if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszSourceKey, 0,
        (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS), &hkResult))
        != ERROR_SUCCESS)                   // open registry information
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            lpszSourceKey, status);
        SNMP_free(lpszSourceKey);           // free storage
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);                  // show nothing exists
    }

    nameSize = sizeof(regStruct->szOID)-1;  // set field length
    if ( (status = RegQueryValueEx(     // look up EnterpriseOID
        hkResult,                       // handle to registry key
        EXTENSION_ENTERPRISE_OID,       // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) regStruct->szOID,      // where to return OID string field
        &nameSize) ) != ERROR_SUCCESS)  // size of OID string field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_ENTERPRISE_OID, status);
        SNMP_free(lpszSourceKey);           // free storage
        RegCloseKey(hkResult);          // close the registry key
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);                  // indicate error
    }

    WriteTrace(0x00,"GetRegistryValue: EnterpriseOID field is %s\n", regStruct->szOID);

    nameSize = sizeof(iValue);          // set field length
    if ( (status = RegQueryValueEx(     // look up time
        hkResult,                       // handle to registry key
        EXTENSION_APPEND,               // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return time field
        &nameSize) ) != ERROR_SUCCESS)  // size of time field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_APPEND, status);
        regStruct->fAppend = TRUE;      // default to true
    }
    else
    {
        regStruct->fAppend = ((iValue == 1) ? TRUE : FALSE);        // reflect append flag
        WriteTrace(0x00,"GetRegistryValue: Append field is %lu\n", regStruct->fAppend);
    }

    RegCloseKey(hkResult);              // close registry key for source
    SNMP_free(lpszSourceKey);               // free the storage for the source key

    if (regStruct->fAppend)
    {
        strcpy(temp,regStruct->szOID);                          // copy enterprise suffix temporarily
        strcpy(regStruct->szOID, szBaseOID);                    // copy base enterprise oid first
        strcpy(regStruct->szOID+strlen(szBaseOID), TEXT("."));  // add the .
        strcpy(regStruct->szOID+strlen(szBaseOID)+1, temp);     // now add the suffix
        WriteTrace(0x0a,"GetRegistryValue: Appended enterprise OID is %s\n", regStruct->szOID);
    }

    if ((regStruct->nCount > 1) || regStruct->nTime)
    {
        WriteTrace(0x0a,"GetRegistryValue: Values found for Count and/or Time for this entry\n");

        if (regStruct->nCount == 0)
        {
            regStruct->nCount = 2;      // set a default value of 2
        }

        if (!CheckCountTime(logFile, sourceName, atol(eventID), timeGenerated, regStruct))
        {
            WriteTrace(0x0a,"GetRegistryValue: Count/Time values not met for this entry\n");
            WriteTrace(0x0a,"GetRegistryValue: Exiting ReadRegistryValue with FALSE\n");
            return(FALSE);              // indicate nothing to send
        }
    }
    else
    {
        TidyCountTimeTable(logFile, sourceName, atol(eventID));
    }

    WriteTrace(0x0a,"GetRegistryValue: Exiting ReadRegistryValue with TRUE\n");
    return(TRUE);                       // indicate got all of the data
}


VOID
StopAll(
     IN VOID
     )

/*++

Routine Description:

    This routine is called to write trace and log records and notify the
    other DLL threads that this thread is terminating.

Arguments:

    None

Return Value:

    None


--*/

{
    LONG    lastError;              // for GetLastError()

    WriteTrace(0x0a,"StopAll: Signaling DLL shutdown event %08X from Event Log Processing thread.\n",
        hStopAll);

    if ( !SetEvent(hStopAll) )
    {
        lastError = GetLastError(); // save error code status
        WriteTrace(0x14,"StopAll: Error signaling DLL shutdown event %08X in SNMPELPT; code %lu\n",
            hStopAll, lastError);
        WriteLog(SNMPELEA_ERROR_SET_AGENT_STOP_EVENT,
            HandleToUlong(hStopAll), lastError);  // log error message
    }
}


VOID
DoExitLogEv(
     IN DWORD dwReturn
    )

/*++

Routine Description:

    This routine is called to write trace and log records when SnmpEvLogProc is
    terminating.

Arguments:

    dwReturn    -   Value to return in ExitThread.

Return Value:

    None

Notes:

    ExitThread is used to return control to the caller. A return code of 1 is
    supplied to indicate that a problem was encountered. A return code of 0
    is supplied to indicate that no problems were encountered.

--*/

{
    PCOUNTTABLE lpTable;            // pointer to count table address

    if (dwReturn)
    {
        WriteTrace(0x14,"DoExitLogEv: SnmpEvLogProc has encountered an error.\n");
    }

    if (lpCountTable != NULL)
    {
        WriteTrace(0x0a,"DoExitLogEv: Count/Time table has storage allocated. Freeing table.\n");
        lpTable = lpCountTable;     // start at first entry

        while (lpCountTable != NULL)
        {
            WriteTrace(0x00,"DoExitLogEv: Freeing Count/Time table entry at %08X\n", lpCountTable);
            lpTable = lpCountTable->lpNext;             // get pointer to next entry
            SNMP_free(lpCountTable);                            // free this storage
            lpCountTable = lpTable;                     // set to next entry
        }
    }

    WriteTrace(0x0a,"DoExitLogEv: Exiting SnmpEvLogProc routine.....\n");
    ExitThread(dwReturn);
}


VOID
CloseEvents(
     IN PHANDLE phWaitEventPtr
     )

/*++

Routine Description:

    This routine is called to close event handles that are open and to free
    the storage currently allocated to those handles.

Arguments:

    phWaitEventPtr  -   This is the pointer to the array of event handles used
                        for notification of a log event.

Return Value:

    None


--*/

{
    UINT    i;                      // temporary loop counter
    LONG    lastError;              // last API error code

    for (i = 0; i < uNumEventLogs; i++)
    {
        WriteTrace(0x0a,"CloseEvents: Closing handle for wait event %lu - %08X\n",
            i, *(phWaitEventPtr+i));

        if ( !CloseHandle(*(phWaitEventPtr+i)) )
        {
            lastError = GetLastError();     // save error status
            WriteTrace(0x14,"CloseEvents: Error closing event handle %08X is %lu\n",
                *(phWaitEventPtr+i), lastError);    // trace error message
            WriteLog(SNMPELEA_ERROR_CLOSE_WAIT_EVENT_HANDLE,
                HandleToUlong(*(phWaitEventPtr+i)), lastError); // trace error message
        }
    }

    WriteTrace(0x0a,"CloseEvents: Freeing memory for wait event list %08X\n",
        phWaitEventPtr);
    SNMP_free( (LPVOID) phWaitEventPtr );        // Free the memory
}


BOOL
ReopenLog(
    IN DWORD    dwOffset,       // offset into event handle array
    IN PHANDLE  phWaitEventPtr  // event handle array pointer
    )

/*++

Routine Description:

    This routine is called to close and reopen an event log that has been
    cleared. When this happens, the handle becomes invalid and the log must
    be reopened and the NotifyChangeEventLog API must be called again.

Arguments:

    dwOffset    -   This field contains the index into the handle pointer
                    array of the currently invalid handle. This invalid
                    handle will be replaced with the valid handle if the
                    function is successful.

Return Value:

    TRUE    -   If the log was successfully reopened and a new NotifyChangeEventLog
                was issued successfully.

    FALSE   -   If the log could not be opened or the NotifyChangeEventLog failed.


--*/

{
    HANDLE      hLogHandle;         // temporary for log file handle
    LPTSTR      lpszLogName;        // name of this log file
    LONG        lastError;          // temporary for GetLastError;

    hLogHandle = *(phEventLogs+dwOffset);   // load the current handle
    lpszLogName = lpszEventLogs+dwOffset*(MAX_PATH+1);

    WriteTrace(0x14,"ReopenLog: Log file %s has been cleared; reopening log\n",
        lpszLogName);

    CloseEventLog(hLogHandle);  // first, close old handle

    hLogHandle = OpenEventLog( (LPTSTR) NULL, lpszLogName);

    if (hLogHandle == NULL)
    {                         // did log file open?
        lastError = GetLastError(); // save error code
        WriteTrace(0x14,"ReopenLog: Error in EventLogOpen for %s = %lu \n",
            lpszLogName, lastError);

        WriteLog(SNMPELEA_ERROR_OPEN_EVENT_LOG, lpszLogName, lastError);  // log the error message
        return(FALSE);                // failed -- forget this one
    }

    WriteTrace(0x00,"ReopenLog: New handle for %s is %08X\n",
        lpszLogName, hLogHandle);
    *(phEventLogs+dwOffset) = hLogHandle;   // save new handle now

    WriteTrace(0x00,"ReopenLog: Reissuing NotifyChangeEventLog for log\n");
    if (!NotifyChangeEventLog(*(phEventLogs+dwOffset),
        *(phWaitEventPtr+dwOffset)))
    {
        lastError = GetLastError();
        WriteTrace(0x14,"ReopenLog: NotifyChangeEventLog failed with code %lu\n",
            lastError);
        WriteLog(SNMPELEA_ERROR_LOG_NOTIFY, lastError); // log error message
        return(FALSE);
    }

    WriteTrace(0x00,"ReopenLog: ChangeNotify was successful\n");
    return(TRUE);
}


VOID
DisplayLogRecord(
    IN PEVENTLOGRECORD  pEventBuffer,
    IN DWORD            dwSize,
    IN DWORD            dwNeeded
    )

/*++

Routine Description:

    This routine is called to display the event log record after reading it.

Arguments:

    pEventBuffer    -   This is a pointer to an EVENTLOGRECORD structure
                        containing the current event log record.

    dwSize          -   Contains the size in bytes of the amount of data
                        just read into the buffer specified on the
                        ReadEventLog.

    dwNeeded        -   Contains the size in bytes of the amount of storage
                        required to read the next log record if GetLastError()
                        returns ERROR_INSUFFICIENT_BUFFER.

Return Value:

    None

--*/

{
    PCHAR   pcString;               // temporary string pointer
    UINT    j;                      // temporary loop counter

    if (nTraceLevel)                // if not maximum tracing
    {
        return;                     // just get out
    }

    WriteTrace(0x00,"DisplayLogRecord: Values from ReadEventLog follow:\n");
    WriteTrace(0x00,"DisplayLogRecord: EventSize = %lu EventNeeded = %lu\n",
        dwSize, dwNeeded);

    WriteTrace(0x00,"DisplayLogRecord: Event Log Buffer contents follow:\n");
    WriteTrace(0x00,"DisplayLogRecord: Length = %lu Record Number = %lu\n",
        pEventBuffer->Length, pEventBuffer->RecordNumber);
    WriteTrace(0x00,"DisplayLogRecord: Time generated = %08X Time written = %08X\n",
        pEventBuffer->TimeGenerated, pEventBuffer->TimeWritten);
    WriteTrace(0x00,"DisplayLogRecord: Event ID = %lu (%08X) Event Type = %04X\n",
        pEventBuffer->EventID, pEventBuffer->EventID, pEventBuffer->EventType);
    WriteTrace(0x00,"DisplayLogRecord: Num Strings = %lu EventCategory = %04X\n",
        pEventBuffer->NumStrings, pEventBuffer->EventCategory);
    WriteTrace(0x00,"DisplayLogRecord: String Offset = %lu Data Length = %lu\n",
        pEventBuffer->StringOffset, pEventBuffer->DataLength);
    WriteTrace(0x00,"DisplayLogRecord: Data Offset = %lu\n",
        pEventBuffer->DataOffset);

    pcString = (PCHAR) pEventBuffer + EVENTRECSIZE;
    WriteTrace(0x00,"DisplayLogRecord: EventBuffer address is %08X\n", pEventBuffer);
    WriteTrace(0x00,"DisplayLogRecord: EVENTRECSIZE is %lu\n",EVENTRECSIZE);

    WriteTrace(0x00,"DisplayLogRecord: String pointer is assigned address %08X\n",
        pcString);
    WriteTrace(0x00,"DisplayLogRecord: SourceName[] = %s\n", pcString);
    pcString += strlen(pcString) + 1;

    WriteTrace(0x00,"DisplayLogRecord: Computername[] = %s\n", pcString);
    pcString = (PCHAR) pEventBuffer + pEventBuffer->StringOffset;

    WriteTrace(0x00,"DisplayLogRecord: String pointer is assigned address %08X\n",
        pcString);
    for (j = 0; j < pEventBuffer->NumStrings; j++)
    {
        WriteTrace(0x00,"DisplayLogRecord: String #%lu ->%s\n", j, pcString);
        pcString += strlen(pcString) + 1;
    }
}


BOOL
AddBufferToQueue(
     IN PVarBindQueue   lpVarBindEntry  // pointer to varbind entry structure
     )

/*++

Routine Description:

    This routine will add a varbind entry to the queue of traps to send.


Arguments:

    lpVarBindEntry  -   This is a pointer to a varbind entry.

Return Value:

    TRUE    -   The varbind entry was successfully added to the queue.

    FALSE   -   The varbind entry could not be added to the queue.

Notes:


--*/

{
    PVarBindQueue   pBuffer;        // temporary pointer
    HANDLE          hWaitList[2];   // wait event array
    LONG            lastError;      // for GetLastError()
    DWORD           status;         // for wait

    WriteTrace(0x0a,"AddBufferToQueue: Entering AddBufferToQueue function\n");

    if (fThresholdEnabled && fThreshold)
    {
        WriteTrace(0x0a,"AddBufferToQueue: Performance threshold flag is on. No data will be processed.\n");
        WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue function with FALSE\n");
        return(FALSE);
    }

    WriteTrace(0x00,"AddBufferToQueue: Current buffer pointer is %08X\n", lpVarBindQueue);
    WriteTrace(0x00,"AddBufferToQueue: Adding buffer address %08X to queue\n", lpVarBindEntry);

    hWaitList[0] = hMutex;              // mutex handle
    hWaitList[1] = hStopAll;            // DLL termination event handle

    WriteTrace(0x00,"AddBufferToQueue: Handle to Mutex object is %08X\n", hMutex);
    WriteTrace(0x0a,"AddBufferToQueue: Waiting for Mutex object to become available\n");

    while (TRUE)
    {
        status = WaitForMultipleObjects(
            2,                              // only two objects to wait on
            (CONST PHANDLE) &hWaitList,     // address of array of event handles
            FALSE,                          // only one event is required
            1000);                          // only wait one second

        lastError = GetLastError();         // save any error conditions
        WriteTrace(0x0a,"AddBufferToQueue: WaitForMulitpleObjects returned a value of %lu\n", status);
        // bug# 277187 note: status will be 0 if both mutex and hStopAll are in signal state
        // we should check if we have to shutdown first.
        if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
        {
            WriteTrace(0x0a,"AddBufferToQueue: DLL shutdown detected. Wait abandoned.\n");
            WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
            return(FALSE);
        }
        switch (status)
        {
            case WAIT_FAILED:
                WriteTrace(0x14,"AddBufferToQueue: Error waiting for mutex event array is %lu\n",
                    lastError);                 // trace error message
                WriteLog(SNMPELEA_ERROR_WAIT_ARRAY, lastError); // log error message
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);                  // get out now
            case WAIT_TIMEOUT:
                WriteTrace(0x0a,"AddBufferToQueue: Mutex object not available yet. Wait will continue.\n");
                continue;                       // retry the wait
            case WAIT_ABANDONED:
                WriteTrace(0x14,"AddBufferToQueue: Mutex object has been abandoned.\n");
                WriteLog(SNMPELEA_MUTEX_ABANDONED);
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);                  // get out now
            case 1:
                WriteTrace(0x0a,"AddBufferToQueue: DLL shutdown detected. Wait abandoned.\n");
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);
            case 0:
                WriteTrace(0x0a,"AddBufferToQueue: Mutex object acquired.\n");
                break;
            default:
                WriteTrace(0x14,"AddBufferToQueue: Undefined error encountered in WaitForMultipleObjects. Wait abandoned.\n");
                WriteLog(SNMPELEA_ERROR_WAIT_UNKNOWN);
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);                  // get out now
        }   // end switch for processing WaitForMultipleObjects

        if (dwTrapQueueSize > MAX_QUEUE_SIZE)
        {
            WriteTrace(0x14,"AddBufferToQueue: queue too big -- posting notification event %08X\n",
                hEventNotify);
            
            if ( !SetEvent(hEventNotify) )
            {
                lastError = GetLastError();             // get error return codes
                WriteTrace(0x14,"AddBufferToQueue: Unable to post event %08X; reason is %lu\n",
                    hEventNotify, lastError);
                WriteLog(SNMPELEA_CANT_POST_NOTIFY_EVENT, HandleToUlong(hEventNotify), lastError);
            }
            else
            {
                if (!ReleaseMutex(hMutex))
                {
                    lastError = GetLastError();     // get error information
                    WriteTrace(0x14,"AddBufferToQueue: Unable to release mutex object for reason code %lu\n",
                        lastError);
                    WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
                }
                else
                {
                    Sleep(1000);    //try and let the other thread get the mutex
                    continue;       //and try and get the mutex again...
                }
            }
        }
        break;          // if we get here, then we've got the Mutex object

    }   // end while true for acquiring Mutex object

    if (lpVarBindQueue == (PVarBindQueue) NULL)
    {
        dwTrapQueueSize = 1;
        WriteTrace(0x0a,"AddBufferToQueue: Current queue is empty. Adding %08X as first queue entry\n",
            lpVarBindEntry);
        lpVarBindQueue = lpVarBindEntry;        // indicate first in queue

        WriteTrace(0x0a,"AddBufferToQueue: Releasing mutex object %08X\n", hMutex);
        if (!ReleaseMutex(hMutex))
        {
            lastError = GetLastError();     // get error information
            WriteTrace(0x14,"AddBufferToQueue: Unable to release mutex object for reason code %lu\n",
                lastError);
            WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
        }

        WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue function with TRUE\n");
        return(TRUE);                       // show added to queue
    }

    WriteTrace(0x0a,"AddBufferToQueue: Queue is not empty. Scanning for end of queue.\n");
    pBuffer = lpVarBindQueue;           // starting point

    while (pBuffer->lpNextQueueEntry != (PVarBindQueue) NULL)
    {
        WriteTrace(0x00,"AddBufferToQueue: This buffer address is %08X, next buffer pointer is %08X\n",
            pBuffer, pBuffer->lpNextQueueEntry);
        pBuffer = pBuffer->lpNextQueueEntry;    // point to next buffer
    }

    WriteTrace(0x0a,"AddBufferToQueue: Adding buffer address %08X as next buffer pointer in %08X\n",
        lpVarBindEntry, pBuffer);
    pBuffer->lpNextQueueEntry = lpVarBindEntry; // add to end of chain
    dwTrapQueueSize++;

    WriteTrace(0x0a,"AddBufferToQueue: Releasing mutex object %08X\n", hMutex);
    if (!ReleaseMutex(hMutex))
    {
        lastError = GetLastError();     // get error information
        WriteTrace(0x14,"AddBufferToQueue: Unable to release mutex object for reason code %lu\n",
            lastError);
        WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
    }

    WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue function with TRUE\n");
    return(TRUE);                           // show added to queue
}

HINSTANCE
AddSourceHandle(
    IN LPTSTR   lpszModuleName
    )
{
    PSourceHandleList   pNewModule;
    
    pNewModule = (PSourceHandleList) SNMP_malloc(sizeof(SourceHandleList));

    if (pNewModule == NULL)
    {
        WriteTrace(0x14,"AddSourceHandle: Unable to acquire storage for source/handle entry.\n");
        WriteLog(SNMPELEA_COUNT_TABLE_ALLOC_ERROR);

        return NULL;
    }

    pNewModule->handle = NULL;
    _tcscpy(pNewModule->sourcename, lpszModuleName);

    // load the module as a data file; we look only for messages
    pNewModule->handle = LoadLibraryEx(lpszModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    
    // loading the module failed
    if (pNewModule->handle == (HINSTANCE) NULL )
    {
        DWORD dwError = GetLastError();

        WriteTrace(
            0x14,
            "AddSourceHandle: Unable to load message module %s; LoadLibraryEx returned %lu\n",
            lpszModuleName,
            dwError);

        WriteLog(
            SNMPELEA_CANT_LOAD_MSG_DLL,
            lpszModuleName,
            dwError);

        WriteTrace(0x0a,"AddSourceHandle: Exiting AddSourceHandle with NULL.\n");

        SNMP_free(pNewModule);

        return NULL;

    }

    pNewModule->Next = lpSourceHandleList;  // set forward pointer
    lpSourceHandleList = pNewModule;        //add item to list.

    return pNewModule->handle;
}

HINSTANCE
FindSourceHandle(
    IN LPTSTR   lpszSource
    )
{
   PSourceHandleList    lpSource;

    if (lpSourceHandleList == (PSourceHandleList) NULL)
    {
        return ((HINSTANCE) NULL);
    }

    lpSource = lpSourceHandleList;

    while (lpSource != (PSourceHandleList) NULL)
    {
        if (_tcscmp(lpszSource, lpSource->sourcename) == 0)
        {
            return (lpSource->handle);
        }
        lpSource = lpSource->Next;
    }

    return ((HINSTANCE) NULL);
}





VOID
ScanParameters(
    IN  OUT LPTSTR  *lpStringArray,                 // pointer to array of insertion strings
    IN      UINT    nNumStr,                        // number of insertion strings
    IN  OUT PUINT   nStringsSize,                   // address of size of all insertion strings
    IN      LPTSTR  lpszSrc,                        // pointer to source name for event
    IN      LPTSTR  lpszLog,                        // pointer to the registry name for this source
    IN      HMODULE hPrimModule                     // handle to secondary message module DLL
     )

/*++

Routine Description:

    This routine will scan the insertion strings looking for occurances of %%n, where
    n is a number indicating a substitution parameter value. If no occurances of %%n are found,
    then the routine simply returns without making any modifications.

    If any occurance of %%n is found in the buffer, secondary parameter substitution is then
    required. FormatMessage is called, without any insertion strings. The event ID is the
    value of n following the %%. The message module DLL is one of the following:

    Registry
        Machine
            SYSTEM
                CurrentControlSet
                    Services
                        EventLog
                            LogFile (Security, Application, System, etc.)
                                Source
                                    ParameterMessageFile        REG_EXPAND_SZ

                                    - or -

                                PrimaryModule                   REG_SZ

    If the ParameterMessageFile does not exist for the indicated source, then the PrimaryModule
    value will be used for the LogFile key. If this value does not exist, or if any error occurs
    when loading any of these DLL's, or if the parameter value cannot be found, the %%n value is
    replaced with a NULL string and processing continues.

Arguments:

    lpStringArray   -   Pointer to an array of insertion strings.

    nNumStr         -   Number of insertion strings in lpStrArray.

    nStringsSize    -   Pointer to total size of all insertion strings in lpStrArray.

    lpszSrc         -   Pointer to the source name for this event.

    lpszLog         -   Pointer to the registry event source name.

    hPrimModule     -   Secondary parameter module DLL handle for this event.

Return Value:

    None.

Notes:


--*/

{
    LONG            lastError;                          // return code from GetLastError
    TCHAR           szXParmModuleName[MAX_PATH+1];      // space for DLL message module
    TCHAR           szParmModuleName[MAX_PATH+1];       // space for expanded DLL message module
    BOOL            bExistParmModule;                   // says whether a ParmModuleName is specified or not
    DWORD           nFile = MAX_PATH+1;                 // max size for DLL message module name
    DWORD           dwType;                             // type of message module name
    DWORD           status;                             // status from registry calls
    DWORD           cbExpand;                           // byte count for REG_EXPAND_SZ parameters
    HKEY            hkResult;                           // handle to registry information
    HINSTANCE       hParmModule;                        // handle to message module DLL
    UINT            nBytes;                             // temporary field
    UINT            i;                                  // temporary counter
    LPTSTR          lpParmBuffer;
    LPTSTR          lpszString, lpStartDigit, lpNew;
    UINT            nStrSize, nSubNo, nParmSize, nNewSize, nOffset;
    PSourceHandleList   lpsource;                       //pointer to source/handle list


    WriteTrace(0x0a,"ScanParameters: Entering ScanParameters routine\n");
    WriteTrace(0x00,"ScanParameters: Size of original insertion strings is %lu\n", *nStringsSize);

    WriteTrace(0x0a,"ScanParameters: Opening registry for parameter module for %s\n", lpszLog);

    if ( (status = RegOpenKeyEx(        // open the registry to read the name
        HKEY_LOCAL_MACHINE,             // of the message module DLL
        lpszLog,                        // registry key to open
        0,
        KEY_READ,
        &hkResult) ) != ERROR_SUCCESS)
    {
        WriteTrace(0x14,"ScanParameters: Unable to open EventLog service registry key %s; RegOpenKeyEx returned %lu\n",
            lpszLog, status);           // write trace event record
        WriteLog(SNMPELEA_CANT_OPEN_REGISTRY_PARM_DLL, lpszLog, status);
        WriteTrace(0x0a,"ScanParameters: Exiting ScanParameters\n");
        return;                         // return
    }

    if ( (status = RegQueryValueEx(         // look up module name
        hkResult,                           // handle to registry key
        EXTENSION_PARM_MODULE,              // key to look up
        0,                                  // ignored
        &dwType,                            // address to return type value
        (LPBYTE) szXParmModuleName,         // where to return parameter module name
        &nFile) ) != ERROR_SUCCESS)         // size of parameter module name field
    {
        WriteTrace(0x14,"ScanParameters: No ParameterMessageFile registry key for %s; RegQueryValueEx returned %lu\n",
            lpszLog, status);           // write trace event record

        bExistParmModule = FALSE;
    }
    else
    {
        WriteTrace(0x0a,"ScanParameters: ParameterMessageFile value read was %s\n", szXParmModuleName);
        cbExpand = ExpandEnvironmentStrings(    // expand the DLL name
            szXParmModuleName,                  // unexpanded DLL name
            szParmModuleName,                   // expanded DLL name
            MAX_PATH+1);                        // max size of expanded DLL name

        if (cbExpand > MAX_PATH+1)      // if it didn't expand correctly
        {
            WriteTrace(0x14,"ScanParameters: Unable to expand parameter module %s; expanded size required is %lu bytes\n",
                szXParmModuleName, cbExpand);   // log error message
            WriteLog(SNMPELEA_CANT_EXPAND_PARM_DLL, szXParmModuleName, cbExpand);

            bExistParmModule = FALSE;
        }
        else
        {
            WriteTrace(0x0a,"ScanParameters: ParameterMessageFile expanded to %s\n", szParmModuleName);

            bExistParmModule = TRUE;
        }
    }
    // at this point either bExistParmModule = FALSE 
    // or we have the ';' separated list of ParmModules
    // in szParmModuleName

    WriteTrace(0x0a,"ScanParameters: Closing registry key for parameter module\n");
    RegCloseKey(hkResult);      // close the registry key

    // for each insertion string
    for (i = 0; i < nNumStr; i++)
    {
        WriteTrace(0x00,"ScanParameters: Scanning insertion string %lu: %s\n",
            i, lpStringArray[i]);
        nStrSize = strlen(lpStringArray[i]);    // get size of insertion string
        lpszString = lpStringArray[i];          // set initial pointer

        // for each sub string identifier in the insertion string
        while (nStrSize > 2)
        {
            if ( (lpStartDigit = strstr(lpszString, TEXT("%%"))) == NULL )
            {
                WriteTrace(0x00,"ScanParameters: No secondary substitution parameters found\n");
                break;
            }

            nOffset = (UINT)(lpStartDigit - lpStringArray[i]);  // calculate offset in buffer of %%
            lpStartDigit += 2;                  // point to start of potential digit
            lpszString = lpStartDigit;          // set new string pointer
            nStrSize = strlen(lpszString);      // calculate new string length

            if (nStrSize == 0)
            {
                WriteTrace(0x00,"ScanParameters: %% found, but remainder of string is null\n");
                break;
            }

            nSubNo = atol(lpStartDigit);        // convert to long integer

            if (nSubNo == 0 && *lpStartDigit != '0')
            {
                WriteTrace(0x0a,"ScanParameters: %% found, but following characters were not numeric\n");
                lpszString--;                   // back up 1 byte
// DBCS start
// not need
//              if(WHATISCHAR(lpszString-1, 2) == CHAR_DBCS_TRAIL)
//                  lpszString--;
// DBCS end
                nStrSize = strlen(lpszString);  // recalculate length
                continue;                       // continue parsing the string
            }

            // initialize nBytes to 0 to make clear no message formatting was done.
            nBytes = 0;
            lastError = 0;

            // if there is a parameter file, look for into it for the secondary substitution strings
            if (bExistParmModule)
            {
                LPTSTR pNextModule = szParmModuleName;

                // for each module name in ParameterMessageFile list of modules
                while (pNextModule != NULL)
                {
                    // look for the next delimiter and change it with a string terminator
                    // in order to isolate the first module name - pointed by pNextModule
                    LPTSTR pDelim = _tcschr(pNextModule, _T(';'));
                    if (pDelim != NULL)
                        *pDelim = _T('\0');

                    WriteTrace(
                        0x0a,
                        "ScanParameters: Looking up secondary substitution string %lu in ParameterMessageFile %s\n",
                        nSubNo,
                        pNextModule);

                    // get the handle to the module (load the module now if need be)
                    hParmModule = FindSourceHandle(pNextModule);
                    if (!hParmModule)
                        hParmModule = AddSourceHandle(pNextModule);

                    // careful to restore the szParmModuleName string to its original content
                    // we need this as far as the scanning should be done for each of the insertion strings
                    if (pDelim != NULL)
                        *pDelim = _T(';');
                    
                    // it's not clear whether FormatMessage() allocates any memory in lpParmBuffer when it fails
                    // so initialize the pointer here, and free it in case of failure. LocalFree is harmless on
                    // NULL pointer.
                    lpParmBuffer = NULL;

                    // if we have a valid parameter module handle at this point,
                    // format the insertion string using this module
                    if (hParmModule != NULL)
                    {
                        nBytes = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                            FORMAT_MESSAGE_IGNORE_INSERTS |     // ignore inserted strings
                            FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                            (LPVOID) hParmModule,               // use parameter file
                            nSubNo,                             // parameter number to get
                            (ULONG) NULL,                       // specify no language
                            (LPTSTR) &lpParmBuffer,             // address for buffer pointer
                            80,                                 // minimum space to allocate
                            NULL);                              // no inserted strings

                        lastError = GetLastError();
                    }

                    // if the formatting succeeds, break the loop (szParmModuleName should
                    // be at this point exactly as it was when the loop was entered)
                    if (nBytes != 0)
                        break;

                    LocalFree(lpParmBuffer);

                    // move on to the next module name
                    pNextModule = pDelim != NULL ? pDelim + 1 : NULL;
                }
            }

            if (nBytes == 0)
            {

                WriteTrace(0x0a,"ScanParameters: ParameterMessageFile did not locate parameter - error %lu\n",
                    lastError);
//              WriteLog(SNMPELEA_PARM_NOT_FOUND, nSubNo, lastError);
                LocalFree(lpParmBuffer);    // free storage

                WriteTrace(0x0a,"ScanParameters: Searching PrimaryModule for parameter\n");

                nBytes = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                    FORMAT_MESSAGE_IGNORE_INSERTS |     // ignore inserted strings
                    FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                    (LPVOID) hPrimModule,               // use parameter file
                    nSubNo,                             // parameter number to get
                    (ULONG) NULL,                       // specify no language
                    (LPTSTR) &lpParmBuffer,             // address for buffer pointer
                    80,                                 // minimum space to allocate
                    NULL);                              // no inserted strings

                if (nBytes == 0)
                {
                    lastError = GetLastError(); // get error code
                    WriteTrace(0x0a,"ScanParameters: PrimaryModule did not locate parameter - error %lu\n",
                        lastError);
                    WriteLog(SNMPELEA_PRIM_NOT_FOUND, nSubNo, lastError);
                    LocalFree(lpParmBuffer);    // free storage
                }
            }

            nParmSize = 2;                  // set initialize parameter size (%%)

            while (strlen(lpszString))
            {
                if (!isdigit(*lpszString))
                {
                    break;                  // exit if no more digits
                }

                nParmSize++;                // increment parameter size
// DBCS start
                if (IsDBCSLeadByte(*lpszString))
                    lpszString++;
// DBCS end
                lpszString++;               // point to next byte
            }

            nNewSize = strlen(lpStringArray[i])+nBytes-nParmSize+1; // calculate new length
            nStrSize = strlen(lpStringArray[i])+1;  // get original length
            WriteTrace(0x00,"ScanParameters: Original string length is %lu, new string length is %lu\n",
                nStrSize, nNewSize);

            if (nNewSize > nStrSize)
            {
                lpNew = (TCHAR *) SNMP_realloc(lpStringArray[i], nNewSize);

                if ( lpNew == NULL)
                {
                    WriteTrace(0x14,"ScanParameters: Unable to reallocate storage for insertion strings. Scanning terminated.\n");
                    WriteLog(SNMPELEA_REALLOC_INSERTION_STRINGS_FAILED);
                    WriteTrace(0x00,"ScanParameters: Size of new insertion strings is %lu\n", *nStringsSize);
                    return;                 // return
                }

                WriteTrace(0x0a,"ScanParameters: Insertion string reallocated to %08X\n", lpNew);
                lpStringArray[i] = lpNew;                   // set new pointer
                lpStartDigit = lpStringArray[i] + nOffset;  // point to new start of current %%
                lpszString = lpStartDigit+nBytes;           // set new start of scan spot
                *nStringsSize += nBytes-nParmSize;          // calculate new total size
                WriteTrace(0x00,"ScanParameters: Old size of all insertion strings was %lu, new size is %lu\n",
                    *(nStringsSize)-nBytes+nParmSize, *nStringsSize);
            }
            else
            {
                WriteTrace(0x0a,"ScanParameters: New size of string is <= old size of string\n");
                lpStartDigit -= 2;                          // now point to %%
                lpszString = lpStartDigit;                  // set new start of scan spot
            }

            nStrSize = strlen(lpStartDigit)+1;  // calculate length of remainder of string

            if (nBytes)
            {
                memmove(lpStartDigit+nBytes-nParmSize,      // destination address
                    lpStartDigit,                           // source address
                    nStrSize);                              // amount of data to move

                memmove(lpStartDigit,                       // destination address
                    lpParmBuffer,                           // source address
                    nBytes);                                // amount of data to move
                
                LocalFree(lpParmBuffer);
            }
            else
            {
                memmove(lpStartDigit,                       // destination address
                    lpStartDigit+nParmSize,                 // source address
                    nStrSize);                              // amount of data to move
            }
            
            WriteTrace(0x00,"ScanParameters: New insertion string is %s\n",
                lpStringArray[i]);
            nStrSize = strlen(lpszString);  // get length of remainder of string
        }
    }

    WriteTrace(0x00,"ScanParameters: Size of new insertion strings is %lu\n", *nStringsSize);
    WriteTrace(0x0a,"ScanParameters: Exiting ScanParameters routine\n");
}


VOID
FreeArrays(
     IN UINT    nCount,         // number of array entries to free
     IN PUINT   lpStrLenArray,  // pointer to string length array
     IN LPTSTR  *lpStringArray, // pointer to string pointer array
     IN BOOL    DelStrs = TRUE
     )

/*++

Routine Description:

    This routine will free the allocated storage for strings in case of an error when
    building the varbind entries.


Arguments:

    nCount          -   This is a count of the number of entries to free

    lpStrLenArray   -   This is a pointer to the string length array to be freed.

    lpStringArray   -   This is a pointer to the string array to be freed.

    DelStrs         -   Should the strings be deleted?

Return Value:

    None.

Notes:


--*/

{
    if (DelStrs)
    {
        WriteTrace(0x00,"FreeArrays: Freeing storage for strings and string length arrays\n");

        for (UINT j=0; j < nCount+5; j++)
        {
            if (lpStrLenArray[j] != 0)
            {
                WriteTrace(0x0a,"FreeArrays: Freeing string storage at address %08X\n",
                    lpStringArray[j]);
                SNMP_free(lpStringArray[j]);
            }
        }

        WriteTrace(0x0a,"FreeArrays: Freeing storage for string array %08X\n", lpStringArray);
        SNMP_free(lpStringArray);
    }
    else
        WriteTrace(0x00,"FreeArrays: Freeing storage for string length array only\n");

    WriteTrace(0x0a,"FreeArrays: Freeing storage for string length array %08X\n", lpStrLenArray);
    SNMP_free(lpStrLenArray);

    return;
}


VOID
FreeVarBind(
    IN  UINT                count,
    IN  RFC1157VarBindList  *varBind
    )

/*++

Routine Description:

    FreeVarBind will free the storage allocated to the indicated varbind and associated
    varbind list.

Arguments:

    count   -   Number of entries to free.

    varBind -   Pointer to the varbind list structure.

Return Value:

    None.

--*/

{
    UINT    j;                      // counter

    WriteTrace(0x0a,"FreeVarBind: Entering FreeVarBind routine\n");
    WriteTrace(0x00,"FreeVarBind: Varbind list is %08X\n", varBind);
    WriteTrace(0x00,"FreeVarBind: varBind->list is %08X\n", varBind->list);

    for (j=0; j < count; j++)
    {
        WriteTrace(0x00,"FreeVarBind: Freeing OID #%lu ids at %08X\n", j, &varBind->list[j].name.ids);
        SNMP_free((&varBind->list[j].name)->ids);
        WriteTrace(0x00,"FreeVarBind: Freeing  varbind stream #%lu at %08X\n", j, &varBind->list[j].value.asnValue.string.stream);
        SNMP_free((&varBind->list[j].value.asnValue.string)->stream);

//22 May 96****************************************************************************************************
//Varbind was allocated as an array in BuildTrapBuffer and so one SNMP_free should be called after this method

//      WriteTrace(0x0a,"FreeVarBind: Freeing varbind %lu at %08X\n",
//          j, &varBind->list[j]);
//      SnmpUtilVarBindFree(&varBind->list[j]);
    }

//22 May 96***************************************************************************************************
//Let the procedure that calls this procedure delete the varBind object

//  WriteTrace(0x0a,"FreeVarBind: Freeing varbind list %08X\n", varBind);
//  SnmpUtilVarBindListFree(varBind);
    WriteTrace(0x0a,"FreeVarBind: Exiting FreeVarBind routine\n");
    return;                                         // exit
}


UINT
TrimTrap(
    IN  OUT RFC1157VarBindList  *varBind,
    IN  OUT UINT                size,
    IN      BOOL                fTrimMessage
    )

/*++

Routine Description:

    TrimTrap will trim the trap in order to keep the trap size below 4096 bytes (SNMP
    maximum packet size). The global trim flag will be used to determine if data should be
    trimmed or omitted.

Arguments:

    varBind -   Pointer to the varbind list structure.

    size    -   Current size, upon entry, of the entire trap structure.

Return Value:

    None.

Notes:

    This routine does not correctly trim the trap data. Microsoft indicated that this routine
    currently was not required, thus no calls are being made to this routine.

--*/

{
    UINT    i;                          // counter
    UINT    nTrim;                      // temporary variable
    UINT    nVarBind;                   // temporary variable

    WriteTrace(0x0a,"TrimTrap: Entering TrimTrap routine\n");

    nTrim = size - nMaxTrapSize;        // see how much we have to trim
    WriteTrace(0x00,"TrimTrap: Trimming %lu bytes\n", nTrim);
    WriteTrace(0x00,"TrimTrap: Trap size is %lu bytes\n", size);

    if (fTrimMessage)                   // if we're trimming the message text first
    {
        WriteTrace(0x0a,"TrimTrap: Registry values indicate EventLog text to be trimmed first\n");

        nVarBind = varBind->list[0].value.asnValue.string.length;

        if (nVarBind > nTrim)
        {
            WriteTrace(0x0a,"TrimTrap: EventLog text size is greater than amount to trim. Trimming EventLog text only\n");
            WriteTrace(0x00,"TrimTrap: EventLog text size is %lu, trim amount is %lu\n",
                nVarBind, nTrim);

            varBind->list[0].value.asnValue.string.length -= nTrim;
            *(varBind->list[0].value.asnValue.string.stream + nVarBind + 1) = '\0'; // add null pointer for tracing

            WriteTrace(0x00,"TrimTrap: New EventLog text is %s\n",
                varBind->list[0].value.asnValue.string.stream);
            WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine\n");

            size -= nTrim;      // drop by length of string
            return(size);                           // exit
        }

        WriteTrace(0x0a,"TrimTrap: EventLog text size is less than or equal to the amount to trim. Zeroing varbinds.\n");
        WriteTrace(0x0a,"TrimTrap: Zeroing EventLog text.\n");

        size -= nVarBind;

        WriteTrace(0x00,"TrimTrap: Trimming off %lu bytes from EventLog text.\n", nVarBind);
        WriteTrace(0x00,"TrimTrap: New size is now %lu bytes.\n", size);

        varBind->list[0].value.asnValue.string.length = 0;
        *(varBind->list[0].value.asnValue.string.stream) = '\0';    // make it null

        i = varBind->len-1;     // set index counter

        while (size > nMaxTrapSize && i != 0)
        {
            nVarBind = varBind->list[i].value.asnValue.string.length;

            WriteTrace(0x0a,"TrimTrap: Trap size is %lu, max size is %lu. Zeroing varbind entry %lu of size %lu.\n",
                size, nMaxTrapSize, i, nVarBind);

            size -= nVarBind;
            varBind->list[i].value.asnValue.string.length = 0;          // set length
            *(varBind->list[i--].value.asnValue.string.stream) = '\0';  // make it null
        }

        WriteTrace(0x0a,"TrimTrap: Trap size is now %lu.\n", size);

        if (size > nMaxTrapSize)
        {
            WriteTrace(0x14,"TrimTrap: All varbinds have been zeroed, but trap still too large.\n");
            WriteLog(SNMPELEA_TRIM_FAILED);
            return(0);          // exit
        }

        return(size);           // exit
    }
    else
    {
        WriteTrace(0x0a,"TrimTrap: Registry values indicate varbind insertion strings to be trimmed first\n");

        i = varBind->len-1;     // set index counter

        while ( (size > nMaxTrapSize) && (i != 0) )
        {
            nVarBind = varBind->list[i].value.asnValue.string.length;

            WriteTrace(0x0a,"TrimTrap: Trap size is %lu, max size is %lu. Zeroing varbind entry %lu of size %lu.\n",
                size, nMaxTrapSize, i, nVarBind);

            size -= nVarBind;
            varBind->list[i].value.asnValue.string.length = 0;          // set length
            *(varBind->list[i--].value.asnValue.string.stream) = '\0';  // make it null
        }

        if (size <= nMaxTrapSize)
        {
            WriteTrace(0x0a,"TrimTrap: Trap size is now %lu.\n", size);
            WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine\n");
            return(size);
        }

        nVarBind = varBind->list[0].value.asnValue.string.length;   // get length of event log text

        WriteTrace(0x0a,"TrimTrap: All insertion strings removed. Only EventLog text remains of size %lu.\n",
            nVarBind);

        nTrim = size - nMaxTrapSize;        // compute how much to trim

        WriteTrace(0x00,"TrimTrap: Need to trim %lu bytes from Event Log text.\n", nTrim);

        if (nVarBind < nTrim)
        {
            WriteTrace(0x14,"TrimTrap: Data to be trimmed exceeds data in trap.\n");
            WriteLog(SNMPELEA_TRIM_FAILED);
            return(0);
        }

        varBind->list[0].value.asnValue.string.length -= nTrim;

        WriteTrace(0x00,"TrimTrap: EventLog text string length is now %lu\n",
            varBind->list[0].value.asnValue.string.length);

        *(varBind->list[0].value.asnValue.string.stream + nVarBind + 1) = '\0'; // add null pointer for tracing

        WriteTrace(0x00,"TrimTrap: New EventLog text is %s\n",
            varBind->list[0].value.asnValue.string.stream);

        size -= nTrim;      // drop by length of string

        WriteTrace(0x0a,"TrimTrap: Trap size is now %lu.\n", size);
        WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine\n");

        return(size);                           // exit
    }

    WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine. Default return.\n");
    return(size);                           // exit
}


BOOL
BuildTrapBuffer(
     IN PEVENTLOGRECORD EventBuffer,        // Event Record from Event Log
     IN REGSTRUCT       rsRegStruct,        // Registry information structure
     IN LPTSTR          lpszLogFile,        // log file name for event
     IN HMODULE         hPrimModule         // handle to secondary parameter module
     )

/*++

Routine Description:

    This routine will build the buffer that contains the variable bindings for the
    trap data to be sent. Coordination between this routine and the trap sending thread
    is done with a MUTEX object. This thread will block until the object can be acquired
    or until it is notified that the agent DLL is terminating.


Arguments:

    EventBuffer -   This is a pointer to a buffer containing the event log text.

    rsRegStruct -   This is a structure containing registry information that relates
                    to the information contained on the event log buffer.

    lpszLogFile -   The name of the log file read for this event. Used to read the
                    registry to get the message file DLL and then to acquire the text
                    of the message for this event id.

    hPrimModule -   Handle to the module loaded for secondary parameter insertions for
                    secondary insertion strings. This is the PrimaryModule as specified
                    in the registry for each log file.

Return Value:

    TRUE    -   A trap buffer was successfully built and added to the queue.

    FALSE   -   A trap buffer could not be constructed or the DLL is terminating.

Notes:


--*/

{
    LONG            lastError;                          // return code from GetLastError
    TCHAR           szXMsgModuleName[MAX_PATH+1];       // space for DLL message module
    TCHAR           szMsgModuleName[MAX_PATH+1];        // space for expanded DLL message module
    DWORD           nFile = MAX_PATH+1;                 // max size for DLL message module name
    DWORD           dwType;                             // type of message module name
    DWORD           status;                             // status from registry calls
    DWORD           cbExpand;                           // byte count for REG_EXPAND_SZ parameters
    HKEY            hkResult;                           // handle to registry information
    HINSTANCE       hMsgModule;                         // handle to message module DLL
    LPTSTR          *lpStringArray;                     // pointer to array of strings
    PUINT           lpStrLenArray;                      // pointer to array of string lengths
    LPTSTR          lpszSource;                         // pointer to source name
    PSID            psidUserSid;                        // pointer to user sid
    LPTSTR          lpszString;                         // pointer to inserted strings
    UINT            size;                               // size of trap buffer
    UINT            nStringSize;                        // temporary field
    UINT            nBytes;                             // temporary field
    UINT            i, j;                               // temporary counters
    TCHAR           lpszLog[MAX_PATH+1];                // temporary registry name
    LPTSTR          lpBuffer;                           // pointer to event log text
    DWORD           cchReferencedDomain = MAX_PATH*2+1; // size of referenced domain
    TCHAR           lpszReferencedDomain[MAX_PATH+1];   // referenced domain
    TCHAR           szTempBuffer[MAX_PATH*2+1];         // temporary buffer
    DWORD           nBuffer;                            // temporary size field
    SID_NAME_USE    snu;                                // SID name use field
    PVarBindQueue   varBindEntry;                       // pointer to varbind queue entry
    PSourceHandleList   lpsource;                       //pointer to source/handle list
    TCHAR           szTempBuffer2[MAX_PATH*2+1];

    WriteTrace(0x0a,"BuildTrapBuffer: Entering BuildTrapBuffer\n");

    if (fThresholdEnabled && fThreshold)
    {
        WriteTrace(0x0a,"BuildTrapBuffer: Performance threshold flag is on. No data will be processed.\n");
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer function with FALSE\n");
        return(FALSE);
    }

    WriteTrace(0x00,"BuildTrapBuffer: Notify event handle is %08X\n", hEventNotify);

    nBuffer = MAX_PATH*2+1;                             // reset length field to default
    lpszSource = (LPTSTR) EventBuffer + EVENTRECSIZE;   // point to source name
    psidUserSid = (PSID) ( (LPTSTR) EventBuffer + EventBuffer->UserSidOffset);  // point to user sid
    lpszString = (LPTSTR) EventBuffer + EventBuffer->StringOffset;  // point to first string

    WriteTrace(0x00,"BuildTrapBuffer: Source name is %s, length is %u\n", lpszSource, strlen(lpszSource));
    WriteTrace(0x00,"BuildTrapBuffer: Computer name is %s, length is %u\n",
        lpszSource+strlen(lpszSource)+1, strlen(lpszSource+strlen(lpszSource)+1) );
    WriteTrace(0x00,"BuildTrapBuffer: Pointer to User SID is %08X\n", psidUserSid);
    WriteTrace(0x00,"BuildTrapBuffer: First inserted string is %s\n", lpszString);


    strcpy(lpszLog, EVENTLOG_BASE);     // copy base registry name
    strcat(lpszLog, lpszLogFile);       // add on the log file name read
    strcat(lpszLog, TEXT("\\"));		// tack on backslash
    strcat(lpszLog, lpszSource);        // add on the source name

    WriteTrace(0x0a,"BuildTrapBuffer: Opening registry for message module for %s\n", lpszLog);

    if ( (status = RegOpenKeyEx(        // open the registry to read the name
        HKEY_LOCAL_MACHINE,             // of the message module DLL
        lpszLog,                        // registry key to open
        0,
        KEY_READ,
        &hkResult) ) != ERROR_SUCCESS)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to open EventLog service registry key %s; RegOpenKeyEx returned %lu\n",
            lpszLog, status);           // write trace event record
        WriteLog(SNMPELEA_CANT_OPEN_REGISTRY_MSG_DLL, lpszLog, status);
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    if ( (status = RegQueryValueEx( // look up module name
        hkResult,                   // handle to registry key
        EXTENSION_MSG_MODULE,       // key to look up
        0,                          // ignored
        &dwType,                    // address to return type value
        (LPBYTE) szXMsgModuleName,  // where to return message module name
        &nFile) ) != ERROR_SUCCESS) // size of message module name field
    {
        WriteTrace(0x14,"BuildTrapBuffer: No EventMessageFile registry key for %s; RegQueryValueEx returned %lu\n",
            lpszLog, status);           // write trace event record
        WriteLog(SNMPELEA_NO_REGISTRY_MSG_DLL, lpszLog, status);
        RegCloseKey(hkResult);      // close the registry key
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    RegCloseKey(hkResult);      // close the registry key

    cbExpand = ExpandEnvironmentStrings(    // expand the DLL name
        szXMsgModuleName,                   // unexpanded DLL name
        szMsgModuleName,                    // expanded DLL name
        MAX_PATH+1);                        // max size of expanded DLL name

    if (cbExpand > MAX_PATH+1)      // if it didn't expand correctly
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to expand message module %s; expanded size required is %lu bytes\n",
            szXMsgModuleName, cbExpand);    // log error message
        WriteLog(SNMPELEA_CANT_EXPAND_MSG_DLL, szXMsgModuleName, cbExpand);
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }
    //---- at this point, szMsgModuleName is the value for "EventMessageFile" parameter----
    //---- it might be one module name or a ';' separated list of module names

    // alloc here the array of pointer to varbind values
    // the first 5 varbind are:
    // 1.3.1.0 - message description 
    // 1.3.2.0 - user name
    // 1.3.3.0 - system name
    // 1.3.4.0 - event type
    // 1.3.5.0 - event category
    // the rest varbinds are one for each insertion string
    nStringSize = 0;
    lpStringArray = (LPTSTR *) SNMP_malloc((EventBuffer->NumStrings+5) * sizeof(LPTSTR) );

    if (lpStringArray == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for string array\n");
        WriteLog(SNMPELEA_INSERTION_STRING_ARRAY_ALLOC_FAILED);
        return(FALSE);
    }

    WriteTrace(0x00,"BuildTrapBuffer: String array allocated at %08X\n", lpStringArray);
    lpStrLenArray = (PUINT) SNMP_malloc((EventBuffer->NumStrings+5) * sizeof(UINT) );

    if (lpStrLenArray == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for string length array\n");
        WriteLog(SNMPELEA_INSERTION_STRING_LENGTH_ARRAY_ALLOC_FAILED);
        SNMP_free(lpStringArray);
        return(FALSE);
    }

    for (i = 0; i < (UINT) EventBuffer->NumStrings+5; i++)
    {
        lpStrLenArray[i] = 0;
    }

    WriteTrace(0x00,"BuildTrapBuffer: String length array allocated at %08X\n", lpStrLenArray);

    if (EventBuffer->NumStrings)
    {
        for (i = 5; i < (UINT) EventBuffer->NumStrings+5; i++)
        {
            lpStrLenArray[i] = _tcslen(lpszString);     // get size of insertion string
            WriteTrace(0x00,"BuildTrapBuffer: String %lu is %s, size of %lu\n",
                i, lpszString, lpStrLenArray[i]);

            lpStringArray[i] = (TCHAR *) SNMP_malloc(lpStrLenArray[i]+1);

            if ( lpStringArray[i] == NULL)
            {
                WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for insertion string\n");
                WriteLog(SNMPELEA_INSERTION_STRING_ALLOC_FAILED);

                FreeArrays(i, lpStrLenArray, lpStringArray);

                WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
                return(FALSE);                  // return
            }

            WriteTrace(0x00,"BuildTrapBuffer: Insertion string %lu address at %08X\n",
                i, lpStringArray[i]);
            strcpy(lpStringArray[i],lpszString);    // copy string to storage
            
            nStringSize += lpStrLenArray[i]+1;      // accumulate total insertion string length
            lpszString += lpStrLenArray[i]+1;       // point to next insertion string
        }

        ScanParameters(&lpStringArray[5],   // address of insertion string array
            EventBuffer->NumStrings,        // number of insertion strings in array
            &nStringSize,                   // address of size of all insertion strings
            lpszSource,                     // pointer to source name for event
            lpszLog,                        // pointer to registry name
            hPrimModule);                   // handle to secondary parameter scan module

        for (i=5; i < (UINT) EventBuffer->NumStrings+5; i++)
        {
            WriteTrace(0x00,"BuildTrapBuffer: Scanned string %lu is %s\n",
                i, lpStringArray[i]);

            // the insertion string might have been enlarged with substrings. Need to recompute their length
            lpStrLenArray[i] = _tcslen(lpStringArray[i]);
        }

    }

    LPTSTR pNextModule = szMsgModuleName;
    while (pNextModule != NULL)
    {
        LPTSTR pDelim = _tcschr(pNextModule, _T(';'));
        if (pDelim != NULL)
            *pDelim = _T('\0');

        //nadir
        //-------<We need now the 'EventMessageFile'>-----
        if ( _tcscmp(pNextModule, szelMsgModuleName) == 0)
        {
            WriteTrace(0x14,"BuildTrapBuffer: Request to trap extension agent log event ignored.\n");
            WriteLog(SNMPELEA_LOG_EVENT_IGNORED);

            FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);

            WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
            return(FALSE);                  // simply exit now
        }

        if ((hMsgModule = FindSourceHandle(pNextModule)) == NULL)
           hMsgModule = AddSourceHandle(pNextModule);

        if (hMsgModule != NULL)
        {
            //-------<At this point format the message>--------
            lpBuffer = NULL;

            nBytes = FormatMessage(                 // see if we can format the message
                FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                (EventBuffer->NumStrings ? FORMAT_MESSAGE_ARGUMENT_ARRAY : 0 ) | // indicate an array of string inserts
                FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                (LPVOID) hMsgModule,                // handle to message module
                EventBuffer->EventID,               // message number to get
                (ULONG) NULL,                       // specify no language
                (LPTSTR) &lpBuffer,                 // address for buffer pointer
                80,                                 // minimum space to allocate
                EventBuffer->NumStrings ? (va_list*) &lpStringArray[5] : NULL); // address of array of pointers

            // store here the last error encountered while formatting (will be used to catch
            // the error condition at the end of all the iterations)
            lastError = GetLastError();

            // the event was formatted successfully so break the loop
            if (nBytes != 0)
                break;

            // is not clear whether FormatMessage is not allocating the buffer on failure.
            // just in case, free it here. As it was initialized to NULL, this call shouldn't harm
            LocalFree(lpBuffer);
        }

        // try the next module
        pNextModule = pDelim != NULL ? pDelim + 1 : NULL;
        //--------------
    }

    // the event could not be formatted by any of the 'EventMessageFile' modules. Will bail out
    if (nBytes == 0)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Error formatting message number %lu (%08X) is %lu\n",
            EventBuffer->EventID, EventBuffer->EventID, lastError); // trace the problem
        WriteLog(SNMPELEA_CANT_FORMAT_MSG, EventBuffer->EventID, lastError);
        LocalFree(lpBuffer);                    // free storage

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");

        return FALSE;
    }

    WriteTrace(0x00,"BuildTrapBuffer: Formatted message: %s\n", lpBuffer);  // log the message in the trace file

    lpStrLenArray[0] = strlen(lpBuffer);            // set varbind length
    lpStringArray[0] = (TCHAR *) SNMP_malloc(lpStrLenArray[0] + 1); // get storage for varbind string

    if ( lpStringArray[0] == NULL)
    {
        lpStrLenArray[0] = 0;                   // reset so storage isn't freed
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for insertion string\n");
        WriteLog(SNMPELEA_INSERTION_STRING_ALLOC_FAILED);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage
        LocalFree(lpBuffer);                    // free storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 0 address at %08X\n",
        lpStringArray[0]);

    strcpy(lpStringArray[0], lpBuffer);             // copy buffer to varbind

    if ( LocalFree(lpBuffer) != NULL )          // free buffer storage
    {
        lastError = GetLastError();             // get error codes
        WriteTrace(0x14,"BuildTrapBuffer: Error freeing FormatMessage buffer is %lu\n",lastError);
        WriteLog(SNMPELEA_FREE_LOCAL_FAILED, lastError);
    }

    if (EventBuffer->UserSidLength)
    {
        if ( !LookupAccountSid(                     // lookup account name
                NULL,                               // system to lookup account on
                psidUserSid,                        // pointer to SID for this account
                szTempBuffer,                       // return account name in this buffer
                &nBuffer,                           // pointer to size of account name returned
                lpszReferencedDomain,               // domain where account was found
                &cchReferencedDomain,               // pointer to size of domain name
                &snu) )                             // sid name use field pointer
        {
            lastError = GetLastError();             // get reason call failed
            WriteTrace(0x14,"BuildTrapBuffer: Unable to acquire account name for event, reason %lu. Unknown is used.\n",
                lastError);
            WriteLog(SNMPELEA_SID_UNKNOWN, lastError);
            strcpy(szTempBuffer,TEXT("Unknown"));   // set default account name
            nBuffer = strlen(szTempBuffer);         // set default size
        }
    }
    else
    {
        WriteTrace(0x0a,"BuildTrapBuffer: UserSidLength was 0. No SID is present. Unknown is used.\n");
        strcpy(szTempBuffer,TEXT("Unknown"));       // set default account name
        nBuffer = strlen(szTempBuffer);             // set default size
    }

    lpStringArray[1] = (TCHAR *) SNMP_malloc(nBuffer + 1);  // get storage for varbind string

    if ( lpStringArray[1] == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for insertion string\n");
        WriteLog(SNMPELEA_INSERTION_STRING_ALLOC_FAILED);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 1 address at %08X\n",
        lpStringArray[1]);

    strcpy(lpStringArray[1], szTempBuffer);             // copy buffer to varbind
    lpStrLenArray[1] = nBuffer;                         // set varbind length

    lpStringArray[2] = (TCHAR *) SNMP_malloc(strlen(lpszSource + strlen(lpszSource) + 1) + 1);  // allocate storage for string
    if (lpStringArray[2] == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for computer name string. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_COMPUTER_NAME_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 2 address at %08X\n",
        lpStringArray[2]);

    strcpy(lpStringArray[2], lpszSource + strlen(lpszSource) + 1);  // copy to varbind
    lpStrLenArray[2] = strlen(lpStringArray[2]);                // get actual string length

    _ultoa(EventBuffer->EventType, szTempBuffer, 10);   // convert to string
    lpStrLenArray[3] = strlen(szTempBuffer);            // get actual string length

    lpStringArray[3] = (TCHAR *) SNMP_malloc(lpStrLenArray[3] + 1); // allocate storage for string

    if (lpStringArray[3] == NULL)
    {
        lpStrLenArray[3] = 0;                   // reset to 0 so storage isn't freed
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for event type string. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_EVENT_TYPE_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 3 address at %08X\n",
        lpStringArray[3]);

    strcpy(lpStringArray[3], szTempBuffer);     // copy string to varbind

    _ultoa(EventBuffer->EventCategory, szTempBuffer, 10);   // convert to string
    lpStrLenArray[4] = strlen(szTempBuffer);                // get actual string length

    lpStringArray[4] = (TCHAR *) SNMP_malloc(lpStrLenArray[4] + 1); // allocate storage for string

    if (lpStringArray[4] == NULL)
    {
        lpStrLenArray[4] = 0;                   // reset to 0 so storage isn't freed
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for event category string. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_EVENT_CATEGORY_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 4 address at %08X\n",
        lpStringArray[4]);

    strcpy(lpStringArray[4], szTempBuffer);     // copy string to varbind

//
//  At this point, we have everything we need to actually build the varbind entries
//  We will now allocate the storage for the varbind queue entry, allocate the varbind list
//  and point to the data that we have previously constructed.
//
//  Storage allocated will be freed by SNMP or by the TrapExtension routine after the trap
//  has been sent. If an error conditions occurs during the building of the varbind, then
//  any allocated storage must be freed in this routine.
//

    varBindEntry = (PVarBindQueue) SNMP_malloc(sizeof(VarBindQueue));   // get varbind queue entry storage

    if (varBindEntry == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for varbind queue entry. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_VARBIND_ENTRY_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for varbind queue entry at address at %08X\n",
        varBindEntry);

    varBindEntry->lpNextQueueEntry = NULL;                              // set forward pointer to null
    varBindEntry->dwEventID = EventBuffer->EventID;                     // set event id
    varBindEntry->dwEventTime = EventBuffer->TimeGenerated - dwTimeZero;// set event time
    varBindEntry->fProcessed = FALSE;                                   // indicate trap not processed yet

    varBindEntry->lpVariableBindings = (RFC1157VarBindList *) SNMP_malloc(sizeof(RFC1157VarBindList));  // allocate storage for varbind list

    if (varBindEntry->lpVariableBindings == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for varbind list. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOC_VARBIND_LIST_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for varbind list at address at %08X\n",
        varBindEntry->lpVariableBindings);

    varBindEntry->lpVariableBindings->list = (RFC1157VarBind *) SNMP_malloc(
        (EventBuffer->NumStrings+5) * sizeof(RFC1157VarBind));  // allocate storage for varbinds

    if (varBindEntry->lpVariableBindings->list == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for varbind. Trap not sent.\n");
        WriteLog(SNMPELEA_ERROR_ALLOC_VAR_BIND);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for varbind array at address at %08X\n",
        varBindEntry->lpVariableBindings->list);

    varBindEntry->lpVariableBindings->len = EventBuffer->NumStrings+5;      // set # of varbinds

    WriteTrace(0x00,"BuildTrapBuffer: Number of varbinds present set to %lu\n",
        varBindEntry->lpVariableBindings->len);

    varBindEntry->enterprise = (AsnObjectIdentifier *) SNMP_malloc(sizeof(AsnObjectIdentifier));    // allocate storage for entprise OID

    if (varBindEntry->enterprise == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for enterprise OID. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOC_ENTERPRISE_OID);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for enterprise OID at address at %08X\n",
        varBindEntry->enterprise);

    if ( !StrToOid((char *) rsRegStruct.szOID, varBindEntry->enterprise) )
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to convert OID from buffer. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_CONVERT_ENTERPRISE_OID);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry->enterprise);                                // free storage for enterprise OID
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    size = BASE_PDU_SIZE + (varBindEntry->enterprise->idLength) * sizeof(UINT);
    size += varBindEntry->lpVariableBindings->len * sizeof(RFC1157VarBind);

    for (i = 0; i < varBindEntry->lpVariableBindings->len; i++)
    {

//remove the #if 0 if no control characters are to be left in the varbinds
#if 0
        char *tmp = lpStringArray[i];

        for (int m=0; m < lpStrLenArray[i]; m++)
        {
            if (!tmp)
            {
                break;
            }

            if ((*tmp < 32) || (*tmp > 126))
            {
                *tmp = 32; //32 is the space char
            }

            tmp++;
        }
#endif

        WriteTrace(0x00,"BuildTrapBuffer: String %lu is %s\n", i, lpStringArray[i]);

        varBindEntry->lpVariableBindings->list[i].value.asnValue.string.length = lpStrLenArray[i];  // get string length
        size += lpStrLenArray[i];                                                                   // add to total size
        varBindEntry->lpVariableBindings->list[i].value.asnValue.string.stream = (PUCHAR) lpStringArray[i]; // point to string
        varBindEntry->lpVariableBindings->list[i].value.asnValue.string.dynamic = TRUE;             // indicate dynamically allocated
        varBindEntry->lpVariableBindings->list[i].value.asnType = ASN_RFC1213_DISPSTRING;           // indicate type of object

        
        strcpy(szTempBuffer, TEXT("."));
        _ultoa(i+1, szTempBuffer2, 10);                 // convert loop counter to string
        strcat(szTempBuffer, szTempBuffer2);                
        strcat(szTempBuffer, TEXT(".0"));               // stick in the .0
        WriteTrace(0x00,"BuildTrapBuffer: Current OID name is %s\n", szTempBuffer);

        if ( !StrToOid((char *)&szTempBuffer, &varBindEntry->lpVariableBindings->list[i].name) )
        {
            WriteTrace(0x14,"BuildTrapBuffer: Unable to convert appended OID for variable binding %lu. Trap not sent.\n",i);
            FreeVarBind(i+1, varBindEntry->lpVariableBindings);                 // free varbind information
            SNMP_free(varBindEntry->enterprise->ids);                           // free enterprise OID field
            SNMP_free(varBindEntry->enterprise);                            // free enterprise OID field
            SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
            SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
            SNMP_free(varBindEntry);                                            // free varbind entry
                
            for (int k = i + 1; k < EventBuffer->NumStrings + 5; k++)
            {
                if (lpStrLenArray[k] != 0)
                    SNMP_free(lpStringArray[k]);
            }

            FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray, FALSE);   // free allocated storage
            WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
            SNMP_free(lpStringArray);
        }

        WriteTrace(0x00,"BuildTrapBuffer: Current OID address is %08X\n", &varBindEntry->lpVariableBindings->list[i].name);

        size += varBindEntry->lpVariableBindings->list[i].name.idLength * sizeof(UINT);
    }

    WriteTrace(0x0a,"BuildTrapBuffer: All variable bindings have been built, size of %lu\n",
        size);

    if (fTrimFlag)                      // call trim routine if requested
    {
        if (size > nMaxTrapSize)                            // if trap is too big to send
        {
            size = TrimTrap(varBindEntry->lpVariableBindings, size, rsRegStruct.fLocalTrim);    // trim trap data
            WriteTrace(0x0a,"BuildTrapBuffer: TrimTrap returned new size of %lu\n", size);

            if (size == 0 || size > nMaxTrapSize)
            {
                WriteTrace(0x14,"BuildTrapBuffer: TrimTrap could not trim buffer. Trap not sent\n");
                WriteLog(SNMPELEA_TRIM_TRAP_FAILURE);

                FreeVarBind(varBindEntry->lpVariableBindings->len, varBindEntry->lpVariableBindings);   // free varbind information
                SNMP_free(varBindEntry->enterprise->ids);                           // free enterprise OID field
                SNMP_free(varBindEntry->enterprise);                            // free enterprise OID field
                FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray, FALSE);   // free allocated storage
                SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
                SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
                SNMP_free(varBindEntry);                                                // free varbind entry
                WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
                SNMP_free(lpStringArray);
                WriteTrace(0x00,"BuildTrapBuffer: Notify event handle is %08X\n", hEventNotify);
                WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
                return(FALSE);                              // exit, all is not well
            }
        }
    }

    if ( !AddBufferToQueue(varBindEntry) )          // add this buffer to the queue
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to add trap buffer to queue. Trap not sent.\n");

        FreeVarBind(varBindEntry->lpVariableBindings->len, varBindEntry->lpVariableBindings);   // free varbind information
        SNMP_free(varBindEntry->enterprise->ids);                           // free enterprise OID field
        SNMP_free(varBindEntry->enterprise);
        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray, FALSE);   // free allocated storage
        WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
        SNMP_free(lpStringArray);
        SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
    SNMP_free(lpStringArray);

    WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string length array %08X\n", lpStrLenArray);
    SNMP_free(lpStrLenArray);

    WriteTrace(0x00,"BuildTrapBuffer: Notify event handle is %08X\n", hEventNotify);
    WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with TRUE\n");

    return(TRUE);                               // exit, all is well
}

void Position_LogfilesToBootTime(BOOL* fValidHandles, PHANDLE phWaitEventPtr, DWORD* dwRecId)
{
    UINT count;
    HANDLE  hLogHandle;
    PEVENTLOGRECORD EventBuffer;
    PEVENTLOGRECORD pOrigEventBuffer;
    DWORD dwBufferSize = LOG_BUF_SIZE;
    DWORD lastError;
    BOOL fContinue;
    DWORD dwEventSize;
    DWORD dwEventNeeded;

    EventBuffer = (PEVENTLOGRECORD) SNMP_malloc(dwBufferSize);
    pOrigEventBuffer = EventBuffer;     // save start of buffer

    if ( EventBuffer == NULL )
    {
        WriteTrace(0x14,"Position_LogfilesToBootTime: Error allocating memory for log event record\n");
        WriteTrace(0x14,"Position_LogfilesToBootTime: Alert will not be processed\n");
        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
        return;
    }

    for (count = 0; count < uNumEventLogs; count++)
    {
        if (!fValidHandles[count])
        {
            continue;
        }

        hLogHandle = *(phEventLogs+count);
        fContinue = TRUE;

        while(fContinue)    // read event log until EOF or boot time
        {
            EventBuffer = pOrigEventBuffer;
            WriteTrace(0x00,"Position_LogfilesToBootTime: Log event buffer is at address %08X\n",
                EventBuffer);
            WriteTrace(0x0a,"Position_LogfilesToBootTime: Reading log event for handle %08X\n",
                hLogHandle);

            if ( !ReadEventLog(hLogHandle,
                EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,
                0,
                (LPVOID) EventBuffer,
                dwBufferSize,
                &dwEventSize,
                &dwEventNeeded) )
            {
                lastError = GetLastError();     // save error status
                
                if (lastError == ERROR_INSUFFICIENT_BUFFER)
                {
                    EventBuffer = (PEVENTLOGRECORD) SNMP_realloc((void*)EventBuffer, dwEventNeeded);

                    if ( EventBuffer == NULL )
                    {
                        WriteTrace(0x14,"Position_LogfilesToBootTime: Error reallocating memory for log event record\n");
                        WriteTrace(0x14,"Position_LogfilesToBootTime: Alert will not be processed\n");
                        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
                        break;
                    }

                    pOrigEventBuffer = EventBuffer;
                    dwBufferSize = dwEventNeeded;

                    if (!ReadEventLog(hLogHandle, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ, 0,
                        (LPVOID) EventBuffer, dwBufferSize, &dwEventSize, &dwEventNeeded))
                    {
                        lastError = GetLastError();
                    }
                }

                if (lastError != ERROR_SUCCESS)
                {
                    if (lastError == ERROR_HANDLE_EOF)
                    {
                        WriteTrace(0x0a,"Position_LogfilesToBootTime: END OF FILE of event log is reached\n");
                    }
                    else
                    {//doesn't matter what the error was, reset the eventlog handle
                        if ( !ReopenLog(count, phWaitEventPtr) )    // reopen log?
                        {
                            fValidHandles[count]= FALSE; //this log is no good!
                            break;                  // if no reopen, exit loop
                        }

                        if (lastError == ERROR_EVENTLOG_FILE_CHANGED)
                        {       // then log file must have been cleared
                            hLogHandle = *(phEventLogs+count); // load new handle
                            continue;                   // if okay, must reread records
                        }
                        else
                        {//Unknown Error! Get to the last record and continue
                            WriteTrace(0x14,"Position_LogfilesToBootTime: Error reading event log %08X record is %lu\n",
                                hLogHandle, lastError);
                            WriteLog(SNMPELEA_ERROR_READ_LOG_EVENT,
                                HandleToUlong(hLogHandle), lastError);  // log error message

                            DisplayLogRecord(EventBuffer,   // display log record
                                dwEventSize,                // size of this total read
                                dwEventNeeded);             // needed for next read
                            
                            hLogHandle = *(phEventLogs+count); // load new handle

                            if (!Position_to_Log_End(hLogHandle))
                            {
                                fValidHandles[count]= FALSE; //this log is no good!
                                break;
                            }
                        }
                    }
                    break;          // exit: finished reading this event log
                }
            } // end unable to ReadEventLog

            while (dwEventSize)
            {
                DisplayLogRecord(EventBuffer,   // display log record
                    dwEventSize,                // size of this total read
                    dwEventNeeded);             // needed for next read

                if (EventBuffer->TimeGenerated > dwLastBootTime)
                {
                    dwRecId[count] = EventBuffer->RecordNumber;
                }
                else
                {
                    fContinue = FALSE;
                    break;
                }

                dwEventSize -= EventBuffer->Length;     // drop by length of this record
                EventBuffer = (PEVENTLOGRECORD) ((LPBYTE) EventBuffer +
                    EventBuffer->Length);               // point to next record
            }
        } // end while(TRUE) , finished reading this event log
    } //end while(count <= uNumEventLogs)

    WriteTrace(0x0a,"Position_LogfilesToBootTime: Freeing log event buffer %08X\n",
        pOrigEventBuffer);
    SNMP_free(pOrigEventBuffer);  // free event log record buffer
}

DWORD  GetLastBootTime()
{
    HKEY hKeyPerflib009;
    DWORD retVal = 0;

    LONG status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"),
    0, KEY_READ, &hKeyPerflib009);

    if (status != ERROR_SUCCESS)
    {
        return retVal;
    }

    DWORD dwMaxValueLen = 0;
    status = RegQueryInfoKey( hKeyPerflib009,
        NULL, NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, &dwMaxValueLen, NULL, NULL);

    if (dwMaxValueLen == 0)
    {
        return retVal;
    }

    DWORD BufferSize = dwMaxValueLen + 1;
    // prefix bug 445191
    unsigned char* lpNameStrings = new (std::nothrow) unsigned char[BufferSize];
    if (lpNameStrings == NULL)
    {
        return retVal;
    }
    // since we are here the counters should be accessible.
    // in case we fail to load them, just bail out.
    status = RegQueryValueEx( hKeyPerflib009,
                TEXT("Counter"), NULL, NULL, lpNameStrings, &BufferSize );
    if (status != ERROR_SUCCESS || BufferSize == 0)
    {
        delete [] lpNameStrings;
        return retVal;
    }

    DWORD dwTime = 0;
    DWORD dwSystem = 0;

    for(TCHAR* lpCurrentString = (TCHAR*)lpNameStrings; *lpCurrentString;
         lpCurrentString += (_tcslen(lpCurrentString)+1) )
    {
        DWORD dwCounter = _ttol( lpCurrentString );
        lpCurrentString += (_tcslen(lpCurrentString)+1);

        if (0 == _tcsicmp((LPTSTR)lpCurrentString, TEXT("System")))
        {
            dwSystem = dwCounter;

            if (dwTime != 0)
            {
                break;
            }
        }
        else if (0 == _tcsicmp((LPTSTR)lpCurrentString, TEXT("System Up Time")))
        {
            dwTime = dwCounter;

            if (dwSystem != 0)
            {
                break;
            }

        }
    }

    PPERF_DATA_BLOCK PerfData = (struct _PERF_DATA_BLOCK *)lpNameStrings;
    TCHAR sysBuff[40];
    _ultot(dwSystem, (TCHAR*)sysBuff, 10);
    DWORD tmpBuffsz = BufferSize;
    status = RegQueryValueEx(HKEY_PERFORMANCE_DATA,
                               sysBuff,
                               NULL,
                               NULL,
                               (LPBYTE) PerfData,
                               &BufferSize);

    
    while (status == ERROR_MORE_DATA)
    {
        if (BufferSize <= tmpBuffsz)
        {
            tmpBuffsz = tmpBuffsz * 2;
            BufferSize = tmpBuffsz;
        }

        delete [] PerfData;
        // prefix bug 445191
        PerfData = (struct _PERF_DATA_BLOCK *) new (std::nothrow) unsigned char[BufferSize];
        if (PerfData == NULL)
        {
            return retVal;
        }
        status = RegQueryValueEx(HKEY_PERFORMANCE_DATA,
                               sysBuff,
                               NULL,
                               NULL,
                               (LPBYTE) PerfData,
                               &BufferSize);
    }

    if (status == ERROR_SUCCESS)
    {

        // 5/22/98 mikemid Fix for SMS Bug1 #20662
        // SNMP trap agent fails with an invalid event handle only on NT 3.51.
        // Now I have no idea why it fails after we close this key but it does. A
        // debugger shows that the WaitForMultipleObjects() event array contains valid
        // event handles, yet commenting out this next line allows this to work properly.
        // The SNMP trap service doesn't even use this key.
        // According to the docs, we want to close this key after using it "so that
        // network transports and drivers can be removed or installed". Well, since this
        // is an already open system key, and we're local anyway, this shouldn't affect
        // anything else.
        // I'm chalking this one up as "extreme weirdness in NT 3.51".
        //===============================================================================
        RegCloseKey(HKEY_PERFORMANCE_DATA); // Bug# 293912 close this key because it caused  
                                            // problem in cluster-registry replication on Win2K.

        PPERF_OBJECT_TYPE PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfData +
                                                            PerfData->HeaderLength);

        for(DWORD i=0; (i < PerfData->NumObjectTypes) && (retVal == 0); i++ )
        {
            if (PerfObj->ObjectNameTitleIndex == dwSystem)
            {
                PPERF_COUNTER_DEFINITION PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
                                                                    PerfObj->HeaderLength);
                //only ever one instance of system so no need to check
                //for instances of system, just get the counter block.
                PPERF_COUNTER_BLOCK PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                                PerfObj->DefinitionLength );

                // Retrieve all counters.
                for(DWORD j=0; j < PerfObj->NumCounters; j++ )
                {
                    if (dwTime == PerfCntr->CounterNameTitleIndex)
                    {
                        //got the time counter, get the data!
                        FILETIME timeRebootf;
                        memcpy(&timeRebootf, ((PBYTE)PtrToCntr + PerfCntr->CounterOffset), sizeof(FILETIME));
                        SYSTEMTIME timeReboots;

                        if (FileTimeToSystemTime(&timeRebootf, &timeReboots))
                        {
                            struct tm timeReboott;
                            timeReboott.tm_year = timeReboots.wYear - 1900;
                            timeReboott.tm_mon = timeReboots.wMonth - 1;
                            timeReboott.tm_mday = timeReboots.wDay;
                            timeReboott.tm_hour = timeReboots.wHour;
                            timeReboott.tm_min = timeReboots.wMinute;
                            timeReboott.tm_sec = timeReboots.wSecond;
                            timeReboott.tm_isdst = 0;
                            time_t tt = mktime(&timeReboott);
                            
                            if(tt != 0xffffffff)
                            {
                                tt -= _timezone;
                                retVal = (DWORD) tt;
                            }
                        }

                        break;
                    }

                    // Get the next counter.
                    PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
                                    PerfCntr->ByteLength);
                }
            }

            PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj + PerfObj->TotalByteLength);
        }
    }

    if (PerfData != NULL)
    {
        delete [] PerfData;
    }

    return retVal;
}


extern "C" {
DWORD
SnmpEvLogProc(
     IN VOID
     )

/*++

Routine Description:

    This is the log processing routine for the SNMP event log extension agent DLL.
    This is where control is passed from DLL initialization in order to determine
    if an event log entry is to generate an SNMP trap.

    An event is created for every log event handle that is opened.
    NotifyChangeEventLog is then called for each log event handle in turn, to allow
    the associated event to be signaled when a change is made to an event log.

    At this point the function waits on the list of events waiting for a log
    event to occur or for a request from the DLL process termination routine to
    shutdown. If a log eventoccurs, the log event record is analyzed, information
    extracted from the registry and, if requested, a trap buffer is built and sent to
    the trap processing routine. This routine is scheduled via a notification event.

    Once the DLL termination event is signaled, all event handles are
    closed and the thread is terminated. This returns control to process termination
    routine in the main DLL.


Arguments:

    None.

Return Value:

    A double word return value is required by the CreateThread API. This
    routine will return a value of zero (0) if all functions performed as
    expected. A value of 1 is returned if a problem was encountered.


Notes:

    ExitThread is used to return control. The return(0) statementat the end of this
    function is include only to avoid a compiler error.


--*/

{

    PHANDLE         phWaitEventPtr;     // points to Wait Event Handles
    HANDLE          hLogHandle;         // handle to log stuff
    HMODULE         hPrimHandle;        // handle to secondary parameter insertion module
    DWORD           dwEventOccur;       // event number from wait
    PEVENTLOGRECORD EventBuffer;        // Event Record from Event Log
    PEVENTLOGRECORD pOrigEventBuffer;   // original event buffer pointer
    DWORD           dwEventSize;        // for create event
    DWORD           dwEventNeeded;      // for create event
    UINT            i;                  // temporary loop variable
    LPTSTR          lpszThisModuleName; // temporary for module name
    LPTSTR          lpszLogName;        // temporary for log name
    TCHAR           szThisEventID[34];  // temporary for event ID
    ULONG           ulValue;            // temporary for event ID
    DWORD           lastError;          // status of last function error
    REGSTRUCT       rsRegistryInfo;     // structure for registry information
    BOOL            fNewTrap = FALSE;   // trap ready flag
    BOOL*           fValidHandles;
    DWORD*          dwRecId;
    DWORD dwBufferSize = LOG_BUF_SIZE;
    DWORD dwReadOptions;

    WriteTrace(0x0a,"SnmpEvLogProc: Entering SnmpEvLogProc routine....\n");
    WriteTrace(0x00,"SnmpEvLogProc: Value of hStopAll is %08X\n",hStopAll);
    WriteTrace(0x00,"SnmpEvLogProc: Value of phEventLogs is %08X\n",phEventLogs);

    for (i = 0; i < uNumEventLogs; i++)
    {
        WriteTrace(0x00,"SnmpEvLogProc: Event log %s(%lu) has handle of %08X\n",
            lpszEventLogs+i*(MAX_PATH+1), i, *(phEventLogs+i));
    }

//  WaitEvent structure: all notify-event-write first, stop DLL event, registry change event last

    if (fRegOk)
    {
        phWaitEventPtr = (PHANDLE) SNMP_malloc((uNumEventLogs+2) * HANDLESIZE);
    }
    else
    {
        phWaitEventPtr = (PHANDLE) SNMP_malloc((uNumEventLogs+1) * HANDLESIZE);
    }

    if (phWaitEventPtr == (PHANDLE) NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to allocate memory for wait event array\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_WAIT_EVENT_ARRAY);

        StopAll();                      // show dll in shutdown
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message
        DoExitLogEv(1);             // exit this thread
    }

    fValidHandles = (BOOL*) SNMP_malloc((uNumEventLogs) * sizeof(BOOL));
    
    if (fValidHandles == (BOOL*) NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to allocate memory for boolean array\n");
        WriteLog(SNMPELEA_ALLOC_EVENT);

        StopAll();                      // show dll in shutdown
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message
        DoExitLogEv(1);             // exit this thread
    }

    dwRecId = (DWORD*) SNMP_malloc((uNumEventLogs) * sizeof(DWORD));
    
    if (dwRecId == (DWORD*) NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to allocate memory for record ID array\n");
        WriteLog(SNMPELEA_ALLOC_EVENT);

        StopAll();                      // show dll in shutdown
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message
        DoExitLogEv(1);             // exit this thread
    }

    for (i = 0; i < uNumEventLogs; i++)
    {
        WriteTrace(0x00,"SnmpEvLogProc: CreateEvent/ChangeNotify loop pass %lu\n",i);
        fValidHandles[i] = TRUE;
        dwRecId[i] = 0;

        if ( (hLogHandle = CreateEvent(
            (LPSECURITY_ATTRIBUTES) NULL,
            FALSE,
            FALSE,
            (LPTSTR) NULL)) == NULL )
        {
            lastError = GetLastError();     // save error status
            WriteTrace(0x14,"SnmpEvLogProc: Error creating event for log notify is %lu\n",
                lastError);
            WriteLog(SNMPELEA_ERROR_CREATE_LOG_NOTIFY_EVENT, lastError);    // log error message
        }
        else
        {
            *(phWaitEventPtr+i) = hLogHandle;
        }

        WriteTrace(0x00,"SnmpEvLogProc: CreateEvent returned handle of %08X\n",
            hLogHandle);
        WriteTrace(0x00,"SnmpEvLogProc: Handle address is %08X\n",phWaitEventPtr+i);
        WriteTrace(0x00,"SnmpEvLogProc: Handle contents by pointer is %08X\n",
            *(phWaitEventPtr+i));

        // Associate each event log to its notify-event-write event handle
        WriteTrace(0x00,"SnmpEvLogProc: ChangeNotify on log handle %08X\n",
            *(phEventLogs+i));
        WriteTrace(0x00,"SnmpEvLogProc: Address of log handle %08X\n",phEventLogs+i);

        if (!NotifyChangeEventLog(*(phEventLogs+i),*(phWaitEventPtr+i)))
        {
            lastError = GetLastError();
            WriteTrace(0x14,"SnmpEvLogProc: NotifyChangeEventLog failed with code %lu\n",
                lastError);
            WriteLog(SNMPELEA_ERROR_LOG_NOTIFY, lastError); // log error message
        }
        else
        {
            WriteTrace(0x00,"SnmpEvLogProc: ChangeNotify was successful\n");
        }

    } // end for

    *(phWaitEventPtr+uNumEventLogs) = hStopAll; // set shutdown event

    if (fRegOk)
    {
        *(phWaitEventPtr+uNumEventLogs+1) = hRegChanged;    // set registry changed event
    }

    WriteTrace(0x00,"SnmpEvLogProc: Termination event is set to %08X\n",
        *(phWaitEventPtr+uNumEventLogs));
    WriteTrace(0x00,"SnmpEvLogProc: Address of termination event is %08X\n",
        phWaitEventPtr+uNumEventLogs);
    WriteTrace(0x00,"SnmpEvLogProc: On entry, handle value is %08X\n",
        hStopAll);

    if (fRegOk)
    {
        WriteTrace(0x00,"SnmpEvLogProc: Registry notification event is set to %08X\n",
            *(phWaitEventPtr+uNumEventLogs+1));
        WriteTrace(0x00,"SnmpEvLogProc: Address of registry notification event is %08X\n",
            phWaitEventPtr+uNumEventLogs+1);
        WriteTrace(0x00,"SnmpEvLogProc: On entry, handle value is %08X\n",
            hRegChanged);
    }

    hMutex = CreateMutex(                   // create mutex object
        NULL,                               // no security attributes
        TRUE,                               // initial ownership desired
        MUTEX_NAME);                        // name of mutex object

    lastError = GetLastError();             // get any error codes

    WriteTrace(0x0a,"SnmpEvLogProc: CreateMutex returned handle of %08X and reason code of %lu\n",
        hMutex, lastError);

    if (hMutex == NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to create Mutex object %s, reason code %lu\n",
            MUTEX_NAME, lastError);
        WriteLog(SNMPELEA_CREATE_MUTEX_ERROR, MUTEX_NAME, lastError);
        StopAll();                      // indicate dll shutdown
        CloseEvents(phWaitEventPtr);    // close event handles
        DoExitLogEv(1);                 // exit this thread
    }

    WriteTrace(0x0a,"SnmpEvLogProc: Created mutex object handle is %08X\n", hMutex);

    WriteTrace(0x0a,"SnmpEvLogProc: Releasing mutex object %08X\n", hMutex);
    if (!ReleaseMutex(hMutex))
    {
        lastError = GetLastError();     // get error information
        WriteTrace(0x14,"SnmpEvLogProc: Unable to release mutex object for reason code %lu\n",
            lastError);
        WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
    }

    if (fDoLogonEvents)
    {
        DWORD dwboot = GetLastBootTime();

        if ((dwLastBootTime == 0) || (dwboot > dwLastBootTime))
        {
            RegSetValueEx(hkRegResult, EXTENSION_LASTBOOT_TIME, 0, REG_DWORD, (CONST BYTE *)&dwboot, 4);
        }

        if (dwboot > dwLastBootTime)
        {
            dwLastBootTime = dwboot;
        }
        else
        {
            fDoLogonEvents = FALSE;
        }
    }

// Wait repeatedly for any event in phWaitEventPtr to occur
    EventBuffer = (PEVENTLOGRECORD) SNMP_malloc(dwBufferSize);
    pOrigEventBuffer = EventBuffer;     // save start of buffer
    WriteTrace(0x0a,"SnmpEvLogProc: Allocating memory for log event record\n");

    if ( EventBuffer == NULL )
    {
        WriteTrace(0x14,"SnmpEvLogProc: Error allocating memory for log event record\n");
        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
        StopAll();                      // indicate dll shutdown
        CloseEvents(phWaitEventPtr);    // close event handles
        DoExitLogEv(1);                 // exit this thread
    }

    while (TRUE)
    {
        fNewTrap = FALSE;               // reset trap built indicator
        WriteTrace(0x0a,"SnmpEvLogProc: Waiting for event to occur\n");

        WriteTrace(0x0a,"SnmpEvLogProc: Normal event wait in progress\n");

        if (fDoLogonEvents && !(fThresholdEnabled && fThreshold))
        {
            fDoLogonEvents = FALSE;
            dwEventOccur = 0;
            Position_LogfilesToBootTime(fValidHandles, phWaitEventPtr, dwRecId);
        }
        else
        {
            if (!fRegOk)
            {
                if (nTraceLevel == 0)
                {
                    for (i = 0; i < uNumEventLogs+1; i++)
                    {
                        WriteTrace(0x00,"SnmpEvLogProc: Event handle %lu is %08X\n", i, *(phWaitEventPtr+i));
                    }
                }

                dwEventOccur = WaitForMultipleObjects(
                    uNumEventLogs+1,                // number of events
                    phWaitEventPtr,                 // array of event handles
                    FALSE,                          // no overlapped i/o
                    g_dwEventLogPollTime);          // either INFINITE or user specified registry value
            }
            else
            {
                if (nTraceLevel == 0)
                {
                    for (i = 0; i < uNumEventLogs+2; i++)
                    {
                        WriteTrace(0x00,"SnmpEvLogProc: Event handle %lu is %08X\n", i, *(phWaitEventPtr+i));
                    }
                }
                dwEventOccur = WaitForMultipleObjects(
                    uNumEventLogs+2,                // number of events
                    phWaitEventPtr,                 // array of event handles
                    FALSE,                          // no overlapped i/o
                    g_dwEventLogPollTime);          // either INFINITE or user specified registry value
            }
        }

        lastError = GetLastError();     // save error status
        WriteTrace(0x0a,"SnmpEvLogProc: EventOccur value: %lu\n", dwEventOccur);

        if (dwEventOccur == WAIT_FAILED)                        // Wait didn't work
        {
            WriteTrace(0x14,"SnmpEvLogProc: Error waiting for event array is %lu\n",
                lastError);                 // trace error message
            WriteLog(SNMPELEA_ERROR_WAIT_ARRAY, lastError); // log error message
            StopAll();                      // indicate dll shutdown
            CloseEvents(phWaitEventPtr);    // close event handles
            DoExitLogEv(1);                 // exit this thread
        }

        if (dwEventOccur != WAIT_TIMEOUT)
        {
            dwEventOccur -= WAIT_OBJECT_0; // normalize array index
        }
        // note that hStopAll is a manual reset event object
        if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
        {
            WriteTrace(0x0a,"SnmpEvLogProc: Event detected DLL shutdown\n");
            CloseEvents(phWaitEventPtr);    // close event handles

            WriteTrace(0x0a,"SnmpEvLogProc: Closing mutex handle %08X\n", hMutex);
            CloseHandle(hMutex);

            break;                          // exit this loop
        }

        if (fRegOk)
        {
            if (dwEventOccur == uNumEventLogs+1)
            {
                WriteTrace(0x0a,"SnmpEvLogProc: Event detected registry key change. Rereading registry parameters.\n");
                if (!Read_Registry_Parameters())
                {
                    WriteTrace(0x14,"SnmpEvLogProc: Error reading registry information. DLL is terminating.\n");
                    WriteLog(SNMPELEA_REGISTRY_INIT_ERROR);
                    StopAll();                      // indicate dll shutdown
                    CloseEvents(phWaitEventPtr);    // close event handles
                    DoExitLogEv(1);                 // exit this thread
                }
                else
                {
                    WriteTrace(0x0a,"SnmpEvLogProc: Registry parameters have been refreshed.\n");
                    continue;                       // skip other event log processing stuff
                }
            }
        }

        DWORD dwEvnt = 0;
        DWORD count = 0;

        while (count <= uNumEventLogs)
        {
            dwEvnt++;

            if (dwEvnt == uNumEventLogs)
            {
                dwEvnt = 0;
            }

            if (!fValidHandles[dwEvnt])
            {
                count++;
                continue;
            }

            hLogHandle = *(phEventLogs+dwEvnt);
            hPrimHandle = *(phPrimHandles+dwEvnt);
            lpszLogName = lpszEventLogs+dwEvnt*(MAX_PATH+1);

            WriteTrace(0x0a,"SnmpEvLogProc: Event detected log record written for %s - %lu - %08X\n",
                lpszLogName, dwEvnt, hLogHandle);

            if (fThresholdEnabled && fThreshold)
            {
                WriteTrace(0x0a,"SnmpEvLogProc: Performance threshold flag is on. No data will be processed.\n");
                break;
            }

            while(TRUE)                         // read event log until EOF
            {
                EventBuffer = pOrigEventBuffer;
                WriteTrace(0x00,"SnmpEvLogProc: Log event buffer is at address %08X\n",
                    EventBuffer);
                WriteTrace(0x0a,"SnmpEvLogProc: Reading log event for handle %08X\n",
                    hLogHandle);
                
                if (dwRecId[dwEvnt] != 0)
                {
                    dwReadOptions = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
                }
                else
                {
                    dwReadOptions = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
                }

                if ( !ReadEventLog(hLogHandle,
                    dwReadOptions,
                    dwRecId[dwEvnt],
                    (LPVOID) EventBuffer,
                    dwBufferSize,
                    &dwEventSize,
                    &dwEventNeeded) )
                {
                    lastError = GetLastError();     // save error status
                    
                    // mikemid 12/01/97, hotfix for SMS Bug1 # 11963.
                    // If we ran out of buffer space, take the returned value in dwEventNeeded
                    // and realloc a big enough buffer to load in the data.
                    //========================================================================
                    if (lastError == ERROR_INSUFFICIENT_BUFFER)
                    {

                        dwBufferSize = dwEventNeeded;

                        EventBuffer = (PEVENTLOGRECORD) SNMP_realloc((void*)EventBuffer, dwBufferSize);

                        if ( EventBuffer == NULL )
                        {
                            WriteTrace(0x14,"SnmpEvLogProc: Error reallocating memory for log event record\n");
                            WriteTrace(0x14,"SnmpEvLogProc: Alert will not be processed\n");
                            WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
                            dwBufferSize = 0;
                            break;
                        }

                        lastError = ERROR_SUCCESS;
                        
                        pOrigEventBuffer = EventBuffer;

                        if (!ReadEventLog(hLogHandle, dwReadOptions, dwRecId[dwEvnt],
                            (LPVOID) EventBuffer, dwBufferSize, &dwEventSize, &dwEventNeeded))
                        {
                            lastError = GetLastError();
                            dwRecId[dwEvnt] = 0;
                        }
                    }

                    if (lastError != ERROR_SUCCESS)
                    {
                        if (lastError == ERROR_HANDLE_EOF)
                        {
                            WriteTrace(0x0a,"SnmpEvLogProc: END OF FILE of event log is reached\n");
                            count++;
                        }
                        else
                        {//doesn't matter what the error was, reset the eventlog handle
                            if ( !ReopenLog(dwEvnt, phWaitEventPtr) )   // reopen log?
                            {
                                fValidHandles[dwEvnt]= FALSE; //this log is no good!
                                count++;
                                break;                  // if no reopen, exit loop
                            }

                            if (lastError == ERROR_EVENTLOG_FILE_CHANGED)
                            {       // then log file must have been cleared
                                hLogHandle = *(phEventLogs+dwEvnt); // load new handle
                                continue;                   // if okay, must reread records
                            }
                            else
                            {//Unknown Error! Get to the last record and continue
                                WriteTrace(0x14,"SnmpEvLogProc: Error reading event log %08X record is %lu\n",
                                    hLogHandle, lastError);
                                WriteLog(SNMPELEA_ERROR_READ_LOG_EVENT,
                                    HandleToUlong(hLogHandle), lastError);  // log error message

                                DisplayLogRecord(EventBuffer,   // display log record
                                    dwEventSize,                // size of this total read
                                    dwEventNeeded);             // needed for next read
                                
                                hLogHandle = *(phEventLogs+dwEvnt); // load new handle
                                count++;

                                if (!Position_to_Log_End(hLogHandle))
                                {
                                    fValidHandles[dwEvnt]= FALSE; //this log is no good!
                                    break;
                                }
                            }
                        }

                        break;          // exit: finished reading this event log
                    }
                } // end unable to ReadEventLog
                
                dwRecId[dwEvnt] = 0;
                count = 0;
                
                while (dwEventSize)
                {
                    DisplayLogRecord(EventBuffer,   // display log record
                        dwEventSize,                // size of this total read
                        dwEventNeeded);             // needed for next read

                    WriteTrace(0x00,"SnmpEvLogProc: Preparing to read config file values\n");

                    lpszThisModuleName = (LPTSTR) EventBuffer + EVENTRECSIZE;

                    ulValue = EventBuffer->EventID;
    //              ulValue = ulValue & 0x0000FFFF; // trim off high order stuff
                    _ultoa(ulValue, szThisEventID, 10);

                    WriteTrace(0x00,"SnmpEvLogProc: Event ID converted to ASCII\n");
                    WriteTrace(0x00,"SnmpEvLogProc: Source is %s. Event ID is %s.\n",
                        lpszThisModuleName,
                        szThisEventID);

                    if ( GetRegistryValue(
                        lpszThisModuleName,
                        szThisEventID,
                        lpszLogName,
                        EventBuffer->TimeGenerated,
                        &rsRegistryInfo) )
                    {
                        WriteTrace(0x0a,"SnmpEvLogProc: This event is being tracked -- formatting trap buffer\n");
                        if ( !BuildTrapBuffer(EventBuffer, rsRegistryInfo, lpszLogName, hPrimHandle) )
                        {
                            WriteTrace(0x14,"SnmpEvLogProc: Unable to build trap buffer. Trap not sent.\n");
                            if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
                            {
                                WriteTrace(0x0a,"SnmpEvLogProc: Event detected DLL shutdown\n");
                                CloseEvents(phWaitEventPtr);    // close event handles
                                WriteTrace(0x0a,"SnmpEvLogProc: Closing mutex handle %08X\n", hMutex);
                                CloseHandle(hMutex);
                                goto Exit;
                            }
                        }
                        else
                        {
                            fNewTrap = TRUE;            // indicate a new trap buffer built
                        }

                        WriteTrace(0x00,"SnmpEvLogProc: Notify event handle is %08X\n", hEventNotify);  
                    }

                    dwEventSize -= EventBuffer->Length;     // drop by length of this record
                    EventBuffer = (PEVENTLOGRECORD) ((LPBYTE) EventBuffer +
                        EventBuffer->Length);               // point to next record

                }

            } // end while(TRUE) , finished reading this event log

            if (fNewTrap)
            {
                WriteTrace(0x0a,"SnmpEvLogProc: A new trap buffer was added -- posting notification event %08X\n",
                    hEventNotify);
                if ( !SetEvent(hEventNotify) )
                {
                    lastError = GetLastError();             // get error return codes
                    WriteTrace(0x14,"SnmpEvLogProc: Unable to post event %08X; reason is %lu\n",
                        hEventNotify, lastError);
                    WriteLog(SNMPELEA_CANT_POST_NOTIFY_EVENT, HandleToUlong(hEventNotify), lastError);
                }
            }
        } //end while(count < uNumEventLogs)
    } // end while(TRUE) loop
Exit:
    WriteTrace(0x0a,"SnmpEvLogProc: Freeing log event buffer %08X\n",
        pOrigEventBuffer);
    SNMP_free(pOrigEventBuffer);  // free event log record buffer
    SNMP_free(fValidHandles);
    SNMP_free(dwRecId);
    WriteTrace(0x0a,"SnmpEvLogProc: Exiting SnmpEvLogProc via normal shutdown\n");
    DoExitLogEv(0);
    return(0);                      // to appease the compiler

} // end of SnmpEvLogProc

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\errors.h ===
#ifndef _ERRORS_H
#define _ERRORS_H

#define WARN_SILENT     0
#define WARN_ERROR      1
#define WARN_ALERT      3
#define WARN_CHECKPOINT 5
#define WARN_ATTENTION  8
#define WARN_TRACK      10

DWORD _E(DWORD dwErrCode,
         DWORD dwMsgId,
         ...);

DWORD _W(DWORD dwWarnLevel,
         DWORD dwMsgId,
         ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmptrlg.h ===
#ifndef	SNMPELTRLG_H
#define	SNMPELTRLG_H

extern	HANDLE	hWriteEvent;		// handle to write event log records

TCHAR	szTraceFileName[MAX_PATH+1] = TEXT("");	// file name for trace information (from registry)
TCHAR	szelMsgModuleName[MAX_PATH+1] = TEXT("");	// space for expanded DLL message module

BOOL	fTraceFileName = FALSE;		// flag indicating registry read for trace file name
UINT	nTraceLevel = 0x20;			// trace level for message information

HMODULE	hMsgModule;					// handle to message module
BOOL	fMsgModule = FALSE;			// flag indicating registry read for message module

#endif	// end of SNMPTRLG.H definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntagnt\snmptrlg.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

	SNMPTRLG.CPP


Abstract:

	This module is the tracing and logging routines for the SNMP Event Log
	Extension Agent DLL.

Author:

	Randy G. Braze (Braze Computing Services) Created 7 February 1996


Revision History:


--*/

extern "C" {

#include <windows.h>		// windows definitions
#include <stdio.h>			// standard I/O functions
#include <stdlib.h>			// standard library definitions
#include <stdarg.h>			// variable length arguments stuff
#include <string.h>			// string declarations
#include <time.h>			// time declarations

#include <snmp.h>			// snmp definitions
#include "snmpelea.h"		// global dll definitions
#include "snmptrlg.h"		// module specific definitions
#include "snmpelmg.h"		// message definitions

}


VOID
TraceWrite(
	IN CONST BOOL  fDoFormat,	// flag for message formatting
	IN CONST BOOL  fDoTime,		// flag for date/time prefixing
    IN CONST LPSTR szFormat,	// trace message to write
    IN OPTIONAL ...				// other printf type operands
    )

/*++

Routine Description:

	TraceWrite will write information provided to the trace file. Optionally,
	it will prepend the date and timestamp to the information. If requested,
	printf type arguments can be passed and they will be substituted just as
	printf builds the message text. Sometimes this routine is called from
	WriteTrace and sometimes it is called from other functions that need to
	generate a trace file record. When called from WriteTrace, no formatting
	is done on the buffer (WriteTrace has already performed the required
	formatting). When called from other functions, the message text may or
	may not require formatting, as specified by the calling function.


Arguments:

	fDoFormat	-	TRUE or FALSE, indicating if the message text provided
					requires formatting as a printf type function.

	fDoTime		-	TRUE or FALSE, indicating if the date/timestamp should be
					added to the beginning of the message text.

	szFormat	-	NULL terminated string containing the message text to be
					written to the trace file. If fDoFormat is true, then this
					text will be in the format of a printf statement and will
					contain substitution parameters strings and variable names
					to be substituted will follow.

	...			-	Optional parameters that are used to complete the printf
					type statement. These are variables that are substituted
					for strings specified in szFormat. These parameters will
					only be specified and processed if fDoFormat is TRUE.


Return Value:

	None
	

--*/

{
    static CHAR  szBuffer[4096];
    static FILE  *FFile;
    static SYSTEMTIME NowTime;
    va_list arglist;

    // don't even attempt to open the trace file if
    // the name is ""
    if (szTraceFileName[0] == TEXT('\0'))
        return;

    FFile = fopen(szTraceFileName,"a");     // open trace file in append mode
    if ( FFile != NULL )                    // if file opened okay
    {
        if ( fDoTime )                      // are we adding time?
        {
            GetLocalTime(&NowTime);         // yep, get it
            fprintf(FFile, "%02i/%02i/%02i %02i:%02i:%02i ",
                NowTime.wMonth,
                NowTime.wDay,
                NowTime.wYear,
                NowTime.wHour,
                NowTime.wMinute,
                NowTime.wSecond);           // file printf to add date/time
        }

        if ( fDoFormat )                    // if we need to format the buffer
        {
          va_start(arglist, szFormat);
          vsprintf(szBuffer, szFormat, arglist);  // perform substitution
          va_end(arglist);
          fwrite(szBuffer, strlen(szBuffer), 1, FFile);           // write data to the trace file
        }
        else                                // if no formatting required
        {
            fwrite(szFormat, strlen(szFormat), 1, FFile);   // write message to the trace file
        }

		fflush(FFile);						// flush buffers first
        fclose(FFile);                      // close the trace file
    }
}                                           // end TraceWrite function


VOID LoadMsgDLL(
    IN VOID
    )

/*++

Routine Description:

	LoadMsgDLL is called to load the SNMPELMG.DLL module which contains the
	message and format information for all messages in the SNMP extension agent DLL.
	It is necessary to call this routine only in the event that an event log
	record cannot be written. If this situation occurs, then the DLL will be
	loaded in an attempt to call FormatMessage and write this same information
	to the trace file. This routine is called only once and only if the
	event log write fails.


Arguments:

	None


Return Value:

	None
	

--*/

{
    TCHAR szXMsgModuleName[MAX_PATH+1]; // space for DLL message module
    DWORD nFile = MAX_PATH+1;           // max size for DLL message module name
    DWORD dwType;                       // type of message module name
    DWORD status;                       // status from registry calls
	DWORD cbExpand;						// byte count for REG_EXPAND_SZ parameters
    HKEY  hkResult;                     // handle to registry information

    if ( (status = RegOpenKeyEx(		// open the registry to read the name
        HKEY_LOCAL_MACHINE,				// of the message module DLL
        EVENTLOG_SERVICE,
        0,
        KEY_READ,
        &hkResult) ) != ERROR_SUCCESS)
    {
        TraceWrite(TRUE, TRUE,			// if we can't find it
			"LoadMessageDLL: Unable to open EventLog service registry key; RegOpenKeyEx returned %lu\n",
			status);					// write trace event record
        hMsgModule = (HMODULE) NULL;	// set handle null
        return;							// return
    }
    else
    {
        if ( (status = RegQueryValueEx(	// look up module name
            hkResult,					// handle to registry key
            EXTENSION_MSG_MODULE,		// key to look up
            0,							// ignored
            &dwType,					// address to return type value
            (LPBYTE) szXMsgModuleName,	// where to return message module name
            &nFile) ) != ERROR_SUCCESS)	// size of message module name field
        {
            TraceWrite(TRUE, TRUE,		// if we can't find it
				"LoadMessageDLL: Unable to open EventMessageFile registry key; RegQueryValueEx returned %lu\n",
				status);				// write trace event record
            hMsgModule = (HMODULE) NULL;	// set handle null
			RegCloseKey(hkResult);		// close the registry key
            return;						// return
        }

		RegCloseKey(hkResult);		// close the registry key

        cbExpand = ExpandEnvironmentStrings(	// expand the DLL name
            szXMsgModuleName,					// unexpanded DLL name
            szelMsgModuleName,					// expanded DLL name
            MAX_PATH+1);						// max size of expanded DLL name

        if (cbExpand > MAX_PATH+1)		// if it didn't expand correctly
        {
            TraceWrite(TRUE, TRUE,		// didn't have enough space
				"LoadMessageDLL: Unable to expand message module %s; expanded size required is %lu bytes\n",
                szXMsgModuleName, cbExpand);	// log error message
            hMsgModule = (HMODULE) NULL;	// set handle null
            return;							// and exit
        }

        if ( (hMsgModule = (HMODULE) LoadLibraryEx(szelMsgModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE) )   // load the message module name
            == (HMODULE) NULL )			// if module didn't load
        {
            TraceWrite(TRUE, TRUE,		// can't load message dll
				"LoadMessageDLL: Unable to load message module %s; LoadLibraryEx returned %lu\n",
                szelMsgModuleName, GetLastError() );  // log error message
        }
	}

    return;								// exit routine

}


VOID
FormatTrace(
    IN CONST NTSTATUS nMsg,         // message number to format
    IN CONST LPVOID   lpArguments   // strings to insert
    )

/*++

Routine Description:

	FormatTrace will write the message text specified by nMsg to the trace
	file. If supplied, the substitution arguments supplied by lpArguments
	will be inserted in the message. FormatMessage is called to format the
	message text and insert the substitution arguments into the text. The
	text of the message is loaded from the SNMPELMG.DLL message module as
	specified in the Eventlog\Application\Snmpelea registry entry under the key of
	EventMessageFile. This information is read, the file name is expanded and
	the message module is loaded. If the message cannot be formatted, then
	a record is written to the trace file indicating the problem.


Arguments:

	nMsg		-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written.

	lpArguments	-	This is a pointer to an array of strings that will be
					substituted in the message text specified. If this value
					is NULL, there are no substitution values to insert.


Return Value:

	None
	

--*/

{
    static DWORD nBytes;            // return value from FormatMessage
    static LPTSTR lpBuffer;         // temporary message buffer

    if ( !fMsgModule ) {            // if we don't have dll loaded yet
        fMsgModule = TRUE;          // indicate we've looked now
        LoadMsgDLL();				// load the DLL
    }

    if ( hMsgModule ) {

        nBytes = FormatMessage(     // see if we can format the message
            FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
   			FORMAT_MESSAGE_ARGUMENT_ARRAY |		// indicate an array of string inserts
            FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
            (LPVOID) hMsgModule,                // handle to message module
            nMsg,                               // message number to get
            (ULONG) NULL,                       // specify no language
            (LPTSTR) &lpBuffer,                 // address for buffer pointer
            80,                                 // minimum space to allocate
            (va_list* )lpArguments);            // address of array of pointers

        if (nBytes == 0) {              // format is not okay
            TraceWrite(TRUE, TRUE,
				"FormatTrace: Error formatting message number %08X is %lu\n",
                nMsg, GetLastError() ); // trace the problem
        }
        else {                          // format is okay
            TraceWrite(FALSE, TRUE, lpBuffer);       // log the message in the trace file
        }

        if ( LocalFree(lpBuffer) != NULL ) {    // free buffer storage
            TraceWrite(TRUE, TRUE,
				"FormatTrace: Error freeing FormatMessage buffer is %lu\n",
                GetLastError() );
        }
    }
    else {
        TraceWrite(TRUE, TRUE,
			"FormatTrace: Unable to format message number %08X; message DLL handle is null.\n",
            nMsg); // trace the problem
    }

    return;                         // exit routine
}


USHORT
MessageType(
    IN CONST NTSTATUS nMsg
    )

/*++

Routine Description:

	MessageType is used to return the severity type of an NTSTATUS formatted
	message number. This information is needed to log the appropriate event
	log information when writing a record to the system event log. Acceptable
	message types are defined in NTELFAPI.H.


Arguments:

	nMsg		-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be analyzed.


Return Value:

	Unsigned short integer containing the message severity as described in
	NTELFAPI.H. If no message type is matched, the default of informational
	is returned.

--*/

{
    switch ((ULONG) nMsg >> 30) {           // get message type
    case (SNMPELEA_SUCCESS) :
        return(EVENTLOG_SUCCESS);           // success message

    case (SNMPELEA_INFORMATIONAL) :
        return(EVENTLOG_INFORMATION_TYPE);  // informational message

    case (SNMPELEA_WARNING) :
        return(EVENTLOG_WARNING_TYPE);      // warning message

    case (SNMPELEA_ERROR) :
        return(EVENTLOG_ERROR_TYPE);        // error message

    default:
        return(EVENTLOG_INFORMATION_TYPE);  // default to informational
    }
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.


Return Value:

	None

--*/

{
    static USHORT wLogType;			// to hold event log type
    static BOOL   fReportEvent;		// return flag from report event

    if (hWriteEvent != NULL)		// if we have previous log access ability
    {
        wLogType = MessageType(nMsgNumber);	// get message type

        fReportEvent = ReportEvent(	// write message
            hWriteEvent,			// handle to log file
            wLogType,				// message type
            0,						// message category
            nMsgNumber,				// message number
            NULL,					// user sid
            0,						// number of strings
            0,						// data length
            0,						// pointer to string array
            (PVOID) NULL);			// data address

        if ( !fReportEvent )		// did the event log okay?
        {							// not if we get here.....
            TraceWrite(TRUE, TRUE,	// show error in trace file
				"WriteLog: Error writing to system event log is %lu\n",
                GetLastError() );
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else							// if we can't write to event log
    {
        TraceWrite(FALSE, TRUE,		// show error in trace file
			"WriteLog: Unable to write to system event log; handle is null\n");
        FormatTrace(nMsgNumber, NULL);  // format trace information
    }
    return;							// exit the function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,           // message number to log
    IN DWORD dwCode                   // code to pass to message
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	dwCode		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[1];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[34];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( lpszEventString[0] != (TCHAR *) NULL )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);		// get message type

            _ultoa(dwCode, lpszEventString[0], 10);	// convert to string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                1,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write trace file record
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace file record
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( lpszEventString[0] != (TCHAR *) NULL )	// if storage allocated
        {
            _ultoa(dwCode, lpszEventString[0], 10);	// convert to string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
	delete lpszEventString[0];			// free storage
    return;								// exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN DWORD dwCode1,
    IN DWORD dwCode2
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	dwCode1		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.

	dwCode2		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[2];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[34];	// allocate space for string conversion
	lpszEventString[1] = new TCHAR[34];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);	// get message type

            _ultoa(dwCode1, lpszEventString[0], 10);	// convert to string
            _ultoa(dwCode2, lpszEventString[1], 10);	// convert to string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                2,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write a trace file entry
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace file entry
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )	// if storage allocated
        {
            _ultoa(dwCode1, lpszEventString[0], 10);	// convert to string
            _ultoa(dwCode2, lpszEventString[1], 10);	// convert to string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
	delete lpszEventString[0];			// free storage
	delete lpszEventString[1];			// free storage
    return;								// exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN DWORD dwCode1,
    IN LPTSTR lpszText1,
    IN LPTSTR lpszText2,
    IN DWORD dwCode2
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	dwCode1		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.

	lpszText1	-	This contains a string parameter that is to be substituted
					into the message text.

	lpszText2	-	This contains a string parameter that is to be substituted
					into the message text.

	dwCode2		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[4];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[34];	// allocate space for string conversion
	lpszEventString[1] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion
	lpszEventString[2] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion
	lpszEventString[3] = new TCHAR[34];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);			// get message type

            _ultoa(dwCode1, lpszEventString[0], 10);	// convert to string
            strcpy(lpszEventString[1],lpszText1);		// copy the string
            strcpy(lpszEventString[2],lpszText2);		// copy the string
            _ultoa(dwCode2, lpszEventString[3], 10);	// convert to string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                4,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write trace file record
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace file record
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )	// if storage allocated
        {
            _ultoa(dwCode1, lpszEventString[0], 10);	// convert to string
            strcpy(lpszEventString[1],lpszText1);		// copy the string
            strcpy(lpszEventString[2],lpszText2);		// copy the string
            _ultoa(dwCode2, lpszEventString[3], 10);	// convert to string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
	delete lpszEventString[0];			// free storage
	delete lpszEventString[1];			// free storage
	delete lpszEventString[2];			// free storage
	delete lpszEventString[3];			// free storage
    return;								// exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN DWORD dwCode1,
    IN LPTSTR lpszText,
    IN DWORD dwCode2,
    IN DWORD dwCode3
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	dwCode1		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.

	lpszText	-	This contains a string parameter that is to be substituted
					into the message text.

	dwCode2		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.

	dwCode3		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[4];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[34];	// allocate space for string conversion
	lpszEventString[1] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion
	lpszEventString[2] = new TCHAR[34];	// allocate space for string conversion
	lpszEventString[3] = new TCHAR[34];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);	// get message type

            _ultoa(dwCode1, lpszEventString[0], 10);	// convert to string
            strcpy(lpszEventString[1],lpszText);		// copy the string
            _ultoa(dwCode2, lpszEventString[2], 10);	// convert to string
            _ultoa(dwCode3, lpszEventString[3], 10);	// convert to string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                4,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write trace file record
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace file record
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )	// if storage allocated
        {
            _ultoa(dwCode1, lpszEventString[0], 10);	// convert to string
            strcpy(lpszEventString[1],lpszText);		// copy the string
            _ultoa(dwCode2, lpszEventString[2], 10);	// convert to string
            _ultoa(dwCode3, lpszEventString[3], 10);	// convert to string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
	delete lpszEventString[0];			// free storage
	delete lpszEventString[1];			// free storage
	delete lpszEventString[2];			// free storage
	delete lpszEventString[3];			// free storage
    return;								// exit the function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN LPTSTR lpszText,
    IN DWORD dwCode1,
    IN DWORD dwCode2
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	lpszText	-	This contains a string parameter that is to be substituted
					into the message text.

	dwCode1		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.

	dwCode2		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[3];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion
	lpszEventString[1] = new TCHAR[34];	// allocate space for string conversion
	lpszEventString[2] = new TCHAR[34];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);	// get message type

            strcpy(lpszEventString[0],lpszText);		// copy the string
            _ultoa(dwCode1, lpszEventString[1], 10);	// convert to string
            _ultoa(dwCode2, lpszEventString[2], 10);	// convert to string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                3,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write trace file record
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace file record
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) )	// if storage allocated
        {
            strcpy(lpszEventString[0],lpszText);		// copy the string
            _ultoa(dwCode1, lpszEventString[1], 10);	// convert to string
            _ultoa(dwCode2, lpszEventString[2], 10);	// convert to string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace file record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
	delete lpszEventString[0];			// free storage
	delete lpszEventString[1];			// free storage
	delete lpszEventString[2];			// free storage
    return;								// exit the function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN LPTSTR lpszText,
    IN DWORD dwCode
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	lpszText	-	This contains a string parameter that is to be substituted
					into the message text.

	dwCode		-	This is a double word code that is to be converted to a
					string and substituted appropriately in the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[2];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion
	lpszEventString[1] = new TCHAR[34];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);		// get message type

            strcpy(lpszEventString[0],lpszText);	// copy the string
            _ultoa(dwCode, lpszEventString[1], 10);	// convert to string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                2,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write trace record
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace record
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )	// if storage allocated
        {
            strcpy(lpszEventString[0],lpszText);		// copy the string
            _ultoa(dwCode, lpszEventString[1], 10);		// convert to string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
	delete lpszEventString[0];			// free storage
	delete lpszEventString[1];			// free storage
    return;								// exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN LPTSTR lpszText
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	lpszText	-	This contains a string parameter that is to be substituted
					into the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[1];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( lpszEventString[0] != (TCHAR *) NULL )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);		// get message type

            strcpy(lpszEventString[0],lpszText);	// copy the string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                1,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write trace file record
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace record
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( lpszEventString[0] != (TCHAR *) NULL )	// if storage allocated
        {
            strcpy(lpszEventString[0],lpszText);		// copy the string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else
        {
            TraceWrite(FALSE, TRUE,		// write trace record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
	delete lpszEventString[0];			// free storage
    return;								// exit function
}


VOID
WriteLog(
    IN	NTSTATUS	nMsgNumber,
    IN	LPCTSTR		lpszText1,
    IN	LPCTSTR		lpszText2
    )

/*++

Routine Description:

	WriteLog is called to write message text to the system event log. This is
	a C++ overloaded function. In case a log record cannot be written
	to the system event log, TraceWrite is called to write the appropriate
	message text to the trace file.


Arguments:

	nMsgNumber	-	This is the message number in SNMPELMG.H in NTSTATUS format
					that is to be written to the event log.

	lpszText	-	This contains a string parameter that is to be substituted
					into the message text.


Return Value:

	None

--*/

{
    static USHORT wLogType;				// to hold event log type
    static TCHAR  *lpszEventString[2];	// array of strings to pass to event logger
    static BOOL   fReportEvent;			// return flag from report event

	lpszEventString[0] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion
	lpszEventString[1] = new TCHAR[MAX_PATH+1];	// allocate space for string conversion

    if (hWriteEvent != NULL)			// if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL ) &&
			 (lpszEventString[1] != (TCHAR *) NULL ) )	// if storage allocated
        {
            wLogType = MessageType(nMsgNumber);		// get message type

            strcpy(lpszEventString[0],lpszText1);	// copy the string
            strcpy(lpszEventString[1],lpszText2);	// copy the string

            fReportEvent = ReportEvent(	// write message
                hWriteEvent,			// handle to log file
                wLogType,				// message type
                0,						// message category
                nMsgNumber,				// message number
                NULL,					// user sid
                2,						// number of strings
                0,						// data length
                (const char **) lpszEventString,		// pointer to string array
                NULL);					// data address

            if ( !fReportEvent )		// did the event log okay?
            {							// not if we get here.....
                TraceWrite(TRUE, TRUE,	// write trace file record
					"WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);	// format trace information
            }
        }
        else							// if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,		// write trace record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
    else								// if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,			// write trace record
			"WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&	// if storage allocated
			 (lpszEventString[1] != (TCHAR *) NULL ) )
        {
            strcpy(lpszEventString[0],lpszText1);		// copy the string
            strcpy(lpszEventString[1],lpszText2);		// copy the string
            FormatTrace(nMsgNumber, lpszEventString);	// format trace information
        }
        else
        {
            TraceWrite(FALSE, TRUE,		// write trace record
				"WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);	// format trace information
        }
    }
	delete lpszEventString[0];			// free storage
	delete lpszEventString[1];			// free storage
    return;								// exit function
}


extern "C" {
VOID
WriteTrace(
    IN CONST UINT  nLevel,           // level of trace message
    IN CONST LPSTR szFormat,         // trace message to write
    IN ...                           // other printf type operands
    )

/*++

Routine Description:

	WriteTrace is called to write the requested trace information to the trace
	file specified in the configuration registry. The key to the trace file
	name is \SOFTWARE\Microsoft\SNMP_EVENTS\EventLog\Parameters\TraceFile.
	The registry information is only read for the first time WriteTrace is called.

	The TraceLevel parameter is also used to determine if the level of this
	message is part of a group of messages being traced. If the level of this
	message is greater than or equal the TraceLevel parameter, then this
	message will be sent to the file, otherwise the message is ignored.


Arguments:

	nLevel		-	This is the trace level of the message being logged.

	szFormat	-	This is the string text of the message to write to the
					trace file. This string is in the format of printf strings
					and will be formatted accordingly.


Return Value:

	None

--*/

{

    static	CHAR 	szBuffer[4096];
    static	TCHAR	szFile[MAX_PATH+1];
    static	DWORD	nFile = MAX_PATH+1;
    static	DWORD	dwLevel;
    static	DWORD	dwType;
    static	DWORD	nLvl = sizeof(DWORD);
    static	DWORD	status;
    static	HKEY	hkResult;
	static	DWORD	cbExpand;
			va_list arglist;

    if ( !fTraceFileName )           // if we haven't yet read registry
    {
        fTraceFileName = TRUE;       // set flag to not open registry info again
        if ( (status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            EXTENSION_PARM,
            0,
            KEY_READ,
            &hkResult) ) != ERROR_SUCCESS)
        {
            WriteLog(SNMPELEA_NO_REGISTRY_PARAMETERS,status);    // write log/trace event record
        }
        else
        {
            if ( (status = RegQueryValueEx(         // look up trace file name
                hkResult,
                EXTENSION_TRACE_FILE,
                0,
                &dwType,
                (LPBYTE) szFile,
                &nFile) ) == ERROR_SUCCESS)
            {
				if (dwType != REG_SZ)		// we have a bad value.
				{
					WriteLog(SNMPELEA_REGISTRY_TRACE_FILE_PARAMETER_TYPE, szTraceFileName);  // write log/trace event record
				}
				else
					strcpy(szTraceFileName, szFile);
            }
            else
            {
                WriteLog(SNMPELEA_NO_REGISTRY_TRACE_FILE_PARAMETER,szTraceFileName);  // write log/trace event record
            }

            if ( (status = RegQueryValueEx(         // look up trace level
                hkResult,
                EXTENSION_TRACE_LEVEL,
                0,
                &dwType,
                (LPBYTE) &dwLevel,
                &nLvl) ) == ERROR_SUCCESS)
            {
                if (dwType == REG_DWORD)
                	nTraceLevel = dwLevel;	// copy registry trace level
                else
					WriteLog(SNMPELEA_REGISTRY_TRACE_LEVEL_PARAMETER_TYPE, nTraceLevel);  // write log/trace event record
            }
            else
            {
                WriteLog(SNMPELEA_NO_REGISTRY_TRACE_LEVEL_PARAMETER,nTraceLevel); // write log/trace event record
            }

            status = RegCloseKey(hkResult);

        } // end else registry lookup successful

    } // end Trace information registry processing

    // return if we are not supposed to trace this message
    if ( nLevel < nTraceLevel )      // are we tracing this message
    {
        return;                      // nope, just exit
    }

    // if the value could not be read from the registry (we still have the default value)
    // then we have no file name, so return.
    if (szTraceFileName[0] == TEXT('\0'))
        return;

   va_start(arglist, szFormat);
   vsprintf(szBuffer, szFormat, arglist);
   va_end(arglist);

   if (nLevel == MAXDWORD)
	{
		TraceWrite(FALSE, FALSE, szBuffer);
	}
	else
	{
		TraceWrite(FALSE, TRUE, szBuffer);
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\errors.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "EventCmd.h"

DWORD _E(DWORD dwErrCode,
         DWORD dwMsgId,
         ...)
{
    va_list arglist;
    LPSTR   pBuffer;

    gStrMessage.LoadString(dwMsgId);
    pBuffer = NULL;
    va_start(arglist, dwMsgId);
    if (FormatMessageA(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            gStrMessage,
            0,
            0,
            (LPSTR)(&pBuffer),
            1,
            &arglist))
    {
        CharToOemA(pBuffer, pBuffer);

        printf("[Err%05u] %s", dwErrCode, pBuffer);
        fflush(stdout);
        LocalFree(pBuffer);
    }
    return dwErrCode;
}

DWORD _W(DWORD dwWarnLevel,
         DWORD dwMsgId,
         ...)
{
    if (dwWarnLevel <= gCommandLine.GetVerboseLevel())
    {
        va_list arglist;
        LPSTR   pBuffer;

        gStrMessage.LoadString(dwMsgId);
        pBuffer = NULL;
        va_start(arglist, dwMsgId);
        if (FormatMessageA(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                gStrMessage,
                0,
                0,
                (LPSTR)(&pBuffer),
                1,
                &arglist))
        {
            CharToOemA(pBuffer, pBuffer);

            printf("[Wrn%02u] %s", dwWarnLevel, pBuffer);
            fflush(stdout);
            LocalFree(pBuffer);
        }
    }

    return dwWarnLevel;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\eventcmd.h ===
#ifndef _EVENTCMD_H
#define _EVENTCMD_H

#define CMDLINE_DELIM               "-/"
#define CMDLINE_OPTION_HELP         "hH?"
#define CMDLINE_OPTION_VERBOSE      "vV"
#define CMDLINE_OPTION_SYSTEM       "sS"
#define CMDLINE_OPTION_NORESTART    "nN"

#define CMDLINE_FLG_NORESTART       1

#define IDS_MSG_HELP                100
#define IDS_MSG_CPYRGHT             101

#define IDS_CHKP_WRN01              111
#define IDS_CHKP_WRN02              112
#define IDS_CHKP_WRN03              113
#define IDS_CHKP_WRN04              114
#define IDS_ALRT_WRN05              115
#define IDS_ATTN_WRN06              116
#define IDS_CHKP_WRN07              117
#define IDS_CHKP_WRN08              118
#define IDS_CHKP_WRN09              119
#define IDS_ATTN_WRN10              120
#define IDS_ATTN_WRN11              121
#define IDS_ALRT_WRN12              122
#define IDS_ALRT_WRN13              123
#define IDS_ATTN_WRN14              124
#define IDS_ALRT_WRN15              125
#define IDS_ALRT_WRN16              126
#define IDS_ALRT_WRN17              127
#define IDS_ALRT_WRN18              128
#define IDS_ALRT_WRN19              129
#define IDS_ALRT_WRN20              130
#define IDS_ALRT_WRN21              131
#define IDS_ALRT_WRN22              132
#define IDS_ALRT_WRN23              133
#define IDS_ALRT_WRN24              134
#define IDS_ALRT_WRN25              135
#define IDS_ATTN_WRN26              136
#define IDS_TRCK_WRN27              137
#define IDS_TRCK_WRN28              138
#define IDS_ERRO_WRN29              139
#define IDS_ALRT_WRN30              140
#define IDS_ALRT_WRN31              141
#define IDS_ALRT_WRN32              142
#define IDS_TRCK_WRN33              143
#define IDS_ATTN_WRN34              144
#define IDS_ATTN_WRN35              145
#define IDS_ATTN_WRN36              146
#define IDS_ATTN_WRN37              147
#define IDS_ATTN_WRN38              148
#define IDS_TRCK_WRN39              149
#define IDS_TRCK_WRN40              150
#define IDS_TRCK_WRN41              151
#define IDS_ATTN_WRN42              152
#define IDS_ATTN_WRN43              153
#define IDS_ATTN_WRN44              154
#define IDS_ATTN_WRN45              155
#define IDS_ERRO_WRN46              156
#define IDS_TRCK_WRN47              157
#define IDS_TRCK_WRN48              158
#define IDS_TRCK_WRN49              159
#define IDS_TRCK_WRN50              160
#define IDS_ERR01               500
#define IDS_ERR02               501
#define IDS_ERR03               503
#define IDS_ERR04               504
#define IDS_ERR05               505
#define IDS_ERR06               506
#define IDS_ERR07               507
#define IDS_ERR08               508
#define IDS_ERR09               509
#define IDS_ERR10               510
#define IDS_ERR11               511
#define IDS_ERR12               512
#define IDS_ERR13               513
#define IDS_ERR14               514
#define IDS_ERR15               515
#define IDS_ERR16               516
#define IDS_ERR17               517
#define IDS_ERR18               518
#define IDS_ERR19               519
#define IDS_ERR20               520
#define IDS_ERR21               521
#define IDS_ERR22               522
#define IDS_ERR23               523
#define IDS_ERR24               524
#define IDS_ERR25               525
#define IDS_ERR26               526
#define IDS_ERR27               527
#define IDS_ERR28               528
#define IDS_ERR29               529
#define IDS_ERR30               530
#define IDS_ERR31               531

class CCommandLine
{
public:
    char    *m_szFileName;
    char    *m_szSystem;
    DWORD   m_nVerboseLevel;
    DWORD   m_nFlags;

    CCommandLine();
    ~CCommandLine();

    DWORD ParseCmdLine(int argc, char *argv[]);
    DWORD GetVerboseLevel();
};

extern CString      gStrMessage;
extern CCommandLine gCommandLine;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\eventcmd.cpp ===
#include <stdafx.h>
#include "EventCmd.h"
#include "Errors.h"
#include "Parser.h"
#include "Registry.h"
#include "SNMPCtrl.h"

CString      gStrMessage;
CCommandLine gCommandLine;

void PrintUsage(char *szCmdName)
{
    gStrMessage.LoadString(100);
    gStrMessage.AnsiToOem();
    printf("%s", gStrMessage);
}

void PrintBanner()
{
    gStrMessage.LoadString(101);
    gStrMessage.AnsiToOem();
    printf("%s", gStrMessage);
}

int _cdecl main(int argc, char *argv[])
{
    int retCode;
    PrintBanner();

    retCode = gCommandLine.ParseCmdLine(argc, argv);
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN01);

    retCode = gParser.ParseInputFile();
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN02, gCommandLine.m_szFileName);

    retCode = gRegistry.Connect();
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN03, gCommandLine.m_szSystem == NULL ? "localhost" : gCommandLine.m_szSystem);

    retCode = gParser.ProcessCommands();
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN04);

    if (gCommandLine.m_nFlags & CMDLINE_FLG_NORESTART)
    {
        if (gRegistry.m_dwFlags & REG_FLG_NEEDRESTART)
            _W(WARN_ALERT, IDS_ALRT_WRN05);
    }
    else
    {
        if (gRegistry.m_dwFlags & REG_FLG_NEEDRESTART)
        {
            if (!gSNMPController.IsSNMPRunning())
                _W(WARN_ATTENTION, IDS_ATTN_WRN06);

            else
            {
                _W(WARN_CHECKPOINT, IDS_CHKP_WRN07);
                retCode = gSNMPController.StopSNMP();
                if (retCode != ERROR_SUCCESS)
                    return retCode;

                _W(WARN_CHECKPOINT, IDS_CHKP_WRN08);
                retCode = gSNMPController.StartSNMP();
                if (retCode != ERROR_SUCCESS)
                    return retCode;

                _W(WARN_CHECKPOINT, IDS_CHKP_WRN09);
            }
        }
        else
            _W(WARN_ATTENTION, IDS_ATTN_WRN10);
    }

    return retCode;
}

CCommandLine::CCommandLine()
{
    m_szFileName = NULL;
    m_szSystem = NULL;
    m_nVerboseLevel = WARN_CHECKPOINT;
    m_nFlags = 0;
}

CCommandLine::~CCommandLine()
{
    if (m_szFileName)
        delete m_szFileName;
    if (m_szSystem)
        delete m_szSystem;
}

DWORD CCommandLine::ParseCmdLine(int argc, char *argv[])
{
    enum
    {
        STATE_ANY,
        STATE_ARG_VERBOSE,
        STATE_ARG_SYSTEM
    } state = STATE_ANY;

    for (int i=1; i<argc; i++)
    {
        switch(state)
        {
        case STATE_ANY:
            if (strchr(CMDLINE_DELIM,argv[i][0]) != NULL)
            {
                if (strchr(CMDLINE_OPTION_HELP, argv[i][1]) != NULL &&
                    argv[i][2] == '\0')
                {
                    PrintUsage(argv[0]);
                    return ERROR_NO_DATA;
                }
                if (strchr(CMDLINE_OPTION_VERBOSE, argv[i][1]) != NULL)
                {
                    if (argv[i][2] != '\0')
                    {
                        m_nVerboseLevel = atoi(argv[i]+2);
                        _W(WARN_ATTENTION,IDS_ATTN_WRN11, m_nVerboseLevel);
                    }
                    else
                        state = STATE_ARG_VERBOSE;
                    break;
                }
                if (strchr(CMDLINE_OPTION_SYSTEM, argv[i][1]) != NULL &&
                    argv[i][2] == '\0')
                {
                    state = STATE_ARG_SYSTEM;
                    break;
                }
                if (strchr(CMDLINE_OPTION_NORESTART, argv[i][1]) != NULL &&
                    argv[i][2] == '\0')
                {
                    m_nFlags |= CMDLINE_FLG_NORESTART;
                    break;
                }
                else
                    _W(WARN_ALERT,IDS_ALRT_WRN12, argv[i]);
            }
            else
            {
                if (m_szFileName != NULL)
                {
                    _W(WARN_ALERT,
                       IDS_ALRT_WRN13,
                       argv[i]);
                    delete m_szFileName;
                }
                m_szFileName = new char[strlen(argv[i])+1];
                if (m_szFileName == NULL)
                    return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
                strcpy(m_szFileName, argv[i]);
            }
            break;
        case STATE_ARG_VERBOSE:
            m_nVerboseLevel = atoi(argv[i]);
            _W(WARN_ATTENTION,IDS_ATTN_WRN14, m_nVerboseLevel);
            state = STATE_ANY;
            break;
        case STATE_ARG_SYSTEM:
            if (m_szSystem != NULL)
            {
                _W(WARN_ALERT,
                   IDS_ALRT_WRN15,
                   argv[i]);
                delete m_szSystem;
            }
            m_szSystem = new char[strlen(argv[i])+1];
            if (m_szSystem == NULL)
                return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
            strcpy(m_szSystem, argv[i]);
            state = STATE_ANY;
            break;
        }
    }

    if (m_szFileName == NULL)
    {
        PrintUsage(argv[0]);
        return ERROR_NO_DATA;
    }

    return ERROR_SUCCESS;
}

DWORD CCommandLine::GetVerboseLevel()
{
    return m_nVerboseLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\operation.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "Parser.h"
#include "Registry.h"
#include "EventCmd.h"

COperation::COperation(tOperation operation)
{
    m_Operation = operation;
    m_pNextOperation = NULL;
}

COperation::~COperation()
{
    if (m_pNextOperation)
        delete m_pNextOperation;
}

COperation* COperation::Insert(COperation *pOperation)
{
    if (pOperation->m_Operation < m_Operation)
    {
        pOperation->m_pNextOperation = this;
        return pOperation;
    }

    if (m_pNextOperation == NULL)
        m_pNextOperation = pOperation;
    else
        m_pNextOperation = m_pNextOperation->Insert(pOperation);

    return this;
}

COperation* COperation::GetNextOp()
{
    return m_pNextOperation;
}

DWORD COperation::CheckedStrToDword(DWORD & dwDword, char *szDword)
{
    dwDword = 0;
    while (*szDword != '\0')
    {
        if (*szDword < '0' || *szDword > '9')
            return ERROR_BAD_FORMAT;
        dwDword *= 10;
        dwDword += (*szDword++ - '0');
    }

    return ERROR_SUCCESS;
}

COpEvents::COpEvents(tOperation operation) : COperation(operation)
{
    m_szEventSource = NULL;
    m_dwEventID = 0;
    m_dwCount = 1;
    m_dwTime = 0;
}

COpEvents::~COpEvents()
{
    if (m_szEventSource != NULL)
        delete m_szEventSource;
}

DWORD COpEvents::ParseCmdArgs()
{
    DWORD retCode;
    char szToken[INPUT_TOKEN_SZ];

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN16,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
        return retCode;
    }

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN17,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
        return retCode;
    }
    if (m_szEventSource != NULL)
        delete m_szEventSource;
    m_szEventSource = new char[sizeof(szToken) + 1];
    strcpy(m_szEventSource, szToken);

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS ||
        (retCode = CheckedStrToDword(m_dwEventID, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN18,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
        return retCode;
    }

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) == ERROR_SUCCESS)
    {
        if (gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken) != ERROR_SUCCESS)
            goto done;

        if ((retCode = CheckedStrToDword(m_dwCount, szToken)) != ERROR_SUCCESS)
        {
            _W(WARN_ALERT, IDS_ALRT_WRN19,
               gParser.m_nLineNo,
               gParser.m_nTokenNo);
            return retCode;
        }
    }

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) == ERROR_SUCCESS)
    {
        if (gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken) != ERROR_SUCCESS)
            goto done;

        if ((retCode = CheckedStrToDword(m_dwTime, szToken)) != ERROR_SUCCESS)
        {
            _W(WARN_ALERT, IDS_ALRT_WRN20,
               gParser.m_nLineNo,
               gParser.m_nTokenNo);
            return retCode;
        }
    }

    if (m_dwCount <= 1 && m_dwTime > 0)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN21,
           gParser.m_nLineNo,
           gParser.m_nTokenNo,
           m_dwTime);
        m_dwTime = 0;
    }

    if (m_dwCount >= 2 && m_dwTime == 0)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN22,
           gParser.m_nLineNo,
           gParser.m_nTokenNo,
           m_dwCount,
           m_dwTime);
    }

done:
    retCode = ERROR_SUCCESS;

    if (m_dwCount >= 2 && m_dwTime == 0)
        m_dwTime = 1;

    _W(WARN_ATTENTION, IDS_ALRT_WRN23,
        m_Operation == OP_ADD_EVENT ? "ADD" : "DELETE",
        m_szEventSource,
        m_dwEventID,
        m_dwCount,
        m_dwTime);

    return retCode;
};

DWORD COpEvents::ProcessCommand()
{
    DWORD retCode;

    switch(m_Operation)
    {
    case OP_ADD_EVENT:
        retCode = gRegistry.AddEvent(m_szEventSource, m_dwEventID, m_dwCount, m_dwTime);
        break;
    case OP_DEL_EVENT:
        retCode = gRegistry.DelEvent(m_szEventSource, m_dwEventID);
        break;
    default:
        return _E(ERROR_INTERNAL_ERROR, IDS_ERR02, m_Operation);
    }

    return retCode;
}

COpTraps::COpTraps(tOperation operation) : COperation(operation)
{
    m_szCommunity = NULL;
    m_szAddress = NULL;
}

COpTraps::~COpTraps()
{
    if (m_szCommunity != NULL)
        delete m_szCommunity;
    if (m_szAddress != NULL)
        delete m_szAddress;
}

DWORD COpTraps::ParseCmdArgs()
{
    DWORD retCode;
    char szToken[INPUT_TOKEN_SZ];

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN24,
               gParser.m_nLineNo,
               gParser.m_nTokenNo);
        return retCode;
    }
    if (m_szCommunity != NULL)
        delete m_szCommunity;
    m_szCommunity = new char[strlen(szToken)+1];
    if (m_szCommunity == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
    strcpy(m_szCommunity, szToken);

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN25,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
    }
    if (m_szAddress != NULL)
        delete m_szAddress;
    m_szAddress = new char [strlen(szToken) + 1];
    if (m_szAddress == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
    strcpy(m_szAddress, szToken);

    _W(WARN_ATTENTION, IDS_ATTN_WRN26,
        m_Operation == OP_ADD_TRAP ? "ADD_TRAP_DEST" : "DELETE_TRAP_DEST",
        m_szCommunity,
        m_szAddress);
    
    return ERROR_SUCCESS;
}

DWORD COpTraps::ProcessCommand()
{
    DWORD retCode;

    switch(m_Operation)
    {
    case OP_ADD_TRAP:
        retCode = gRegistry.AddTrap(m_szCommunity, m_szAddress);
        break;
    case OP_DEL_TRAP:
        retCode = gRegistry.DelTrap(m_szCommunity, m_szAddress);
        break;
    default:
        return _E(ERROR_INTERNAL_ERROR, IDS_ERR03, m_Operation);
    }

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\operation.h ===
#ifndef _EVENTOP_H
#define _EVENTOP_H

typedef enum
{
    OP_ADD_EVENT,
    OP_DEL_EVENT,
    OP_ADD_TRAP,
    OP_DEL_TRAP
} tOperation;

class COperation
{
protected:
    tOperation m_Operation;
    COperation *m_pNextOperation;

    DWORD CheckedStrToDword(DWORD & dwDword, char *szDword);
public:
    COperation(tOperation operation);
    virtual ~COperation();

    virtual DWORD   ParseCmdArgs() = 0;
    COperation*     Insert(COperation *pOperation);
    COperation*     GetNextOp();

    virtual DWORD   ProcessCommand() = 0;
};

class COpEvents : public COperation
{
    char    *m_szEventSource;
    DWORD   m_dwEventID;
    DWORD   m_dwCount;
    DWORD   m_dwTime;
public:
    COpEvents(tOperation operation);
    ~COpEvents();

    DWORD   ParseCmdArgs();
    DWORD   ProcessCommand();
};

class COpTraps : public COperation
{
    char    *m_szCommunity;
    char    *m_szAddress;
public:
    COpTraps(tOperation operation);
    ~COpTraps();

    DWORD   ParseCmdArgs();
    DWORD   ProcessCommand();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\parser.h ===
#include "Operation.h"

#ifndef _PARSER_H
#define _PARSER_H

#define INPUT_BUFFER_SZ     256
#define INPUT_TOKEN_SZ      80

#define TOKEN_SZ_BLANKS        " \t\n\r"
#define TOKEN_CH_COM_DELIM     ';'
#define TOKEN_CH_NL            '\n'
#define TOKEN_CH_STR_DELIM     '\"'

#define KEYWORD_PRAGMA         "#pragma"
#define KEYWORD_CMD_ADD_EVENT  "ADD"
#define KEYWORD_CMD_DEL_EVENT  "DELETE"
#define KEYWORD_CMD_ADD_TRAP   "ADD_TRAP_DEST"
#define KEYWORD_CMD_DEL_TRAP   "DELETE_TRAP_DEST"

class COperation;

class CParser
{
    COperation  *m_pOperList;

    int          m_fdInput;
    char         m_szInput[INPUT_BUFFER_SZ];
    char        *m_pInput;

    DWORD OpenInputFile();
    DWORD ReloadInputBuffer();
    DWORD AdvanceInputPointer();
public:
    DWORD        m_nLineNo;
    DWORD        m_nTokenNo;

    CParser();
    ~CParser();

    DWORD GetNextToken(char *pToken, int nSizeToken);
    DWORD UnGetToken(char *szToken);
    DWORD CheckUnGetToken(char *pMatchToken, char *pToken);

    DWORD ParseInputFile();
    DWORD ParseCommand(tOperation opType);

    DWORD ProcessCommands();
};

extern CParser gParser;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\parser.cpp ===
#include <stdafx.h>
#include "Parser.h"
#include "EventCmd.h"
#include "Errors.h"

CParser gParser;

CParser::CParser()
{
    m_pOperList = NULL;
    m_fdInput   = -1;
    m_nLineNo   = 1;
    m_nTokenNo  = 0;
    m_pInput    = m_szInput;
}

CParser::~CParser()
{
    if (m_fdInput != -1)
        _close(m_fdInput);
    if (m_pOperList != NULL)
        delete m_pOperList;
}

DWORD CParser::OpenInputFile()
{
    DWORD retCode;

    m_fdInput = _open(gCommandLine.m_szFileName, _O_RDONLY | _O_BINARY);
    retCode = GetLastError();
    if (retCode != ERROR_SUCCESS)
        _E(retCode, IDS_ERR08, gCommandLine.m_szFileName);
    else
        retCode = ReloadInputBuffer();

    return retCode;
}

DWORD CParser::ReloadInputBuffer()
{
    DWORD retCode;
    int   nBuf;

    m_pInput = m_szInput;
    nBuf = _read(m_fdInput, m_szInput, INPUT_BUFFER_SZ);
    retCode = GetLastError();
    if (retCode != ERROR_SUCCESS)
        _E(retCode, IDS_ERR09, m_nLineNo);
    else if (nBuf < INPUT_BUFFER_SZ)
        m_szInput[nBuf] = '\0';
    return retCode;
}

DWORD CParser::AdvanceInputPointer()
{
    DWORD retCode = ERROR_SUCCESS;

    if (*m_pInput == '\0')
    {
        _W(WARN_TRACK, IDS_TRCK_WRN27, m_nLineNo, m_nTokenNo);
        return ERROR_END_OF_MEDIA;
    }

    if (*m_pInput == TOKEN_CH_NL)
    {
        m_nLineNo++;
        m_nTokenNo;
        m_nTokenNo = 0;
    }

    if (m_pInput < m_szInput + INPUT_BUFFER_SZ - 1)
        m_pInput++;
    else
        retCode = ReloadInputBuffer();

    if (retCode == ERROR_SUCCESS && *m_pInput == '\0')
    {
        _W(WARN_TRACK, IDS_TRCK_WRN28, m_nLineNo, m_nTokenNo);
        retCode = ERROR_END_OF_MEDIA;
    }

    return retCode;
}

DWORD CParser::GetNextToken(char * pToken, int nSizeToken)
{
    int   i;
    DWORD nLineStrDelim;
    DWORD nTokenStrDelim;
    enum
    {
        STATE_BLANKS,
        STATE_COMMENT,
        STATE_TOKEN
    } state = STATE_BLANKS;
    DWORD retCode = ERROR_SUCCESS;

    while (retCode == ERROR_SUCCESS)
    {
        if (state == STATE_BLANKS)
        {
            if (*m_pInput == TOKEN_CH_COM_DELIM)
                state = STATE_COMMENT;
            else if (strchr(TOKEN_SZ_BLANKS, *m_pInput) == NULL)
                break;
        }
        else if (state == STATE_COMMENT)
        {
            if (*m_pInput == TOKEN_CH_NL)
                state = STATE_BLANKS;
        }

        retCode = AdvanceInputPointer();
    }

    i = 0;
    state = STATE_BLANKS;
    m_nTokenNo++;

    while (retCode == ERROR_SUCCESS &&
           *m_pInput != TOKEN_CH_COM_DELIM)
    {
        if (state == STATE_BLANKS)
        {
            if (strchr(TOKEN_SZ_BLANKS, *m_pInput) != NULL)
                break;
            if (*m_pInput == TOKEN_CH_STR_DELIM)
            {
                state = STATE_TOKEN;
                nLineStrDelim = m_nLineNo;
                nTokenStrDelim = m_nTokenNo;
                retCode = AdvanceInputPointer();
                continue;
            }
        }
        if (state == STATE_TOKEN)
        {
            if (*m_pInput == TOKEN_CH_STR_DELIM)
            {
                state = STATE_BLANKS;
                retCode = AdvanceInputPointer();
                break;
            }
        }
        pToken[i++] = *m_pInput;
        if (i >= nSizeToken)
        {
            return _E(ERROR_BUFFER_OVERFLOW, IDS_ERR04,
                      m_nLineNo, m_nTokenNo, nSizeToken);
        }
        retCode = AdvanceInputPointer();
    }

    pToken[i] = '\0';

    if (state == STATE_TOKEN)
    {
        _W(WARN_ERROR, IDS_ERRO_WRN29,
           nLineStrDelim, nTokenStrDelim);
    }

    if (i > 0 && retCode == ERROR_END_OF_MEDIA)
        retCode = ERROR_SUCCESS;

    return retCode;
}

DWORD CParser::UnGetToken(char *szToken)
{
    int nTokenLen;
    char *pInsertion;

    nTokenLen = strlen(szToken) + 2;

    if (m_pInput - m_szInput < nTokenLen)
    {
        int nDrift = nTokenLen - (int)(m_pInput - m_szInput);

        memmove(m_pInput + nDrift, m_pInput, INPUT_BUFFER_SZ - (size_t)(m_pInput - m_szInput) - nDrift);
        m_pInput += nDrift;

        if (_lseek(m_fdInput, -nDrift, SEEK_CUR) == -1)
        {
            return _E(GetLastError(), IDS_ERR10);
        }
    }

    pInsertion = m_pInput = m_pInput - nTokenLen;
    *pInsertion++ = '\"';
    strcpy(pInsertion, szToken);
    pInsertion += nTokenLen - 2;
    *pInsertion = '\"';
    m_nTokenNo--;
    return ERROR_SUCCESS;
}

DWORD CParser::CheckUnGetToken(char *pMatchToken, char *pToken)
{
    DWORD retCode = ERROR_SUCCESS;

    if (strcmp(pMatchToken, pToken) == 0 &&
        (retCode = UnGetToken(pToken)) == ERROR_SUCCESS)
        retCode = ERROR_INVALID_PARAMETER;
    return retCode;
}

DWORD CParser::ParseInputFile()
{
    DWORD retCode;
    DWORD dwSkipLine;
    enum
    {
        STATE_READ,
        STATE_SKIP
    } state = STATE_READ;


    retCode = OpenInputFile();

    if (retCode == ERROR_SUCCESS)
    {
        while(1)
        {
            char  szToken[INPUT_TOKEN_SZ];

            retCode = GetNextToken(szToken, INPUT_TOKEN_SZ);
            if (retCode != ERROR_SUCCESS)
                break;

            if (state == STATE_SKIP)
            {
                if (m_nLineNo == dwSkipLine)
                    continue;
                state = STATE_READ;
            }

            if (state == STATE_READ)
            {
                if (strcmp(szToken, KEYWORD_PRAGMA) != 0)
                {
                    _W(WARN_ALERT, IDS_ALRT_WRN30, m_nLineNo, m_nTokenNo);
                    dwSkipLine = m_nLineNo;
                    state = STATE_SKIP;
                    continue;
                }

                retCode = GetNextToken(szToken, INPUT_TOKEN_SZ);
                if (retCode != ERROR_SUCCESS)
                {
                    _W(WARN_ALERT, IDS_ALRT_WRN31, m_nLineNo, m_nTokenNo);
                    dwSkipLine = m_nLineNo;
                    state = STATE_SKIP;
                    continue;
                }

                if (_stricmp(szToken, KEYWORD_CMD_ADD_EVENT) == 0)
                    retCode = ParseCommand(OP_ADD_EVENT);
                else if (_stricmp(szToken, KEYWORD_CMD_DEL_EVENT) == 0)
                    retCode = ParseCommand(OP_DEL_EVENT);
                else if (_stricmp(szToken, KEYWORD_CMD_ADD_TRAP) == 0)
                    retCode = ParseCommand(OP_ADD_TRAP);
                else if (_stricmp(szToken, KEYWORD_CMD_DEL_TRAP) == 0)
                    retCode = ParseCommand(OP_DEL_TRAP);
                else
                {
                    retCode = ERROR_INVALID_OPERATION;
                    _W(WARN_ALERT, IDS_ALRT_WRN32,
                       m_nLineNo, m_nTokenNo, szToken);
                }

                if (retCode != ERROR_SUCCESS)
                {
                    dwSkipLine = m_nLineNo;
                    state = STATE_SKIP;
                    retCode = ERROR_SUCCESS;
                    continue;
                }
            }
        }
    }

    if (retCode == ERROR_END_OF_MEDIA)
        retCode = ERROR_SUCCESS;
    return retCode;
}

DWORD CParser::ParseCommand(tOperation opType)
{
    DWORD       retCode = ERROR_SUCCESS;
    COperation  *pOperation;

    switch(opType)
    {
    case OP_ADD_EVENT:
    case OP_DEL_EVENT:
        pOperation = new COpEvents(opType);
        break;
    case OP_ADD_TRAP:
    case OP_DEL_TRAP:
        pOperation = new COpTraps(opType);
        break;
    }
    if (pOperation == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);

    retCode = pOperation->ParseCmdArgs();
    if (retCode == ERROR_SUCCESS)
    {
        if (m_pOperList == NULL)
            m_pOperList = pOperation;
        else
            m_pOperList = m_pOperList->Insert(pOperation);
    }
    else
        delete pOperation;

    return retCode;
}

DWORD CParser::ProcessCommands()
{
    DWORD retCode = ERROR_SUCCESS;
    COperation *pOperation;

    for (pOperation = m_pOperList;
         retCode == ERROR_SUCCESS && pOperation != NULL;
         pOperation = pOperation->GetNextOp())
        retCode = pOperation->ProcessCommand();

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\registry.h ===
#ifndef _REGISTRY_H
#define _REGISTRY_H

#define REGPATH_SNMPTRAPS   "SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters\\TrapConfiguration"
#define REGPATH_EVNTAGENT   "Software\\Microsoft\\SNMP_EVENTS\\EventLog\\Sources"

#define REG_SRC_ENTOID     "EnterpriseOID"
#define REG_SRC_APPEND     "Append"

#define REG_EVNT_COUNT     "Count"
#define REG_EVNT_ID        "FullID"
#define REG_EVNT_TIME      "Time"

#define REG_FLG_NEEDRESTART 1

class CRegistry
{
    HKEY    m_hRegRoot;
    HKEY    m_hRegSnmpTraps;
    HKEY    m_hRegEvntSources;

    DWORD ConfigureRegSource(HKEY hRegSource, char *szEventSource);
    DWORD ConfigureRegEvent(HKEY hRegEvent, DWORD dwEventID, DWORD dwCount, DWORD dwTime);
    DWORD ScanForTrap(HKEY hRegCommunity, char *szAddress, char *szName, DWORD & nNameLen);

public:
    DWORD   m_dwFlags;

    CRegistry();
    ~CRegistry();

    DWORD Connect();

    DWORD AddEvent(char *szEventSource, DWORD dwEventID, DWORD dwCount, DWORD dwTime);
    DWORD DelEvent(char *szEventSource, DWORD dwEventID);
    DWORD AddTrap(char *szCommunity, char *szAddress);
    DWORD DelTrap(char *szCommunity, char *szAddress);
};

extern CRegistry gRegistry;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\snmpctrl.h ===
#ifndef _SNMPCTRL_H
#define _SNMPCTRL_H

class CSNMPController
{
    SC_HANDLE    m_hServiceController;
    SC_HANDLE    m_hSNMPService;

public:
    CSNMPController();
    ~CSNMPController();

    DWORD LoadSvcHandle();
    BOOL  IsSNMPRunning();
    DWORD StartSNMP();
    DWORD StopSNMP();
};

extern CSNMPController gSNMPController;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\snmpctrl.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "SNMPCtrl.h"
#include "EventCmd.h"

CSNMPController gSNMPController;

CSNMPController::CSNMPController()
{
    m_hSNMPService = NULL;
    m_hServiceController = NULL;
}

CSNMPController::~CSNMPController()
{
    if (m_hSNMPService != NULL)
        CloseServiceHandle(m_hSNMPService);
    if (m_hServiceController != NULL)
        CloseServiceHandle(m_hServiceController);
}

DWORD CSNMPController::LoadSvcHandle()
{
    if (m_hSNMPService == NULL)
    {
        if (m_hServiceController == NULL)
        {
            m_hServiceController = OpenSCManager(
                gCommandLine.m_szSystem,
		        "ServicesActive",
		        GENERIC_EXECUTE);

            if (m_hServiceController == NULL)
                return _E(GetLastError(), IDS_ERR25);
        }
	
	    m_hSNMPService = OpenService(
            m_hServiceController,
            "SNMP",
            SERVICE_CONTROL_INTERROGATE | SERVICE_START | SERVICE_STOP);

        if (m_hSNMPService == NULL)
            return _E(GetLastError(), IDS_ERR26);
    }
    return ERROR_SUCCESS;
}

BOOL CSNMPController::IsSNMPRunning()
{
    SERVICE_STATUS snmpStatus;

    if (LoadSvcHandle() != ERROR_SUCCESS)
        return FALSE;

    if (!QueryServiceStatus(m_hSNMPService, &snmpStatus))
        return _E(GetLastError(), IDS_ERR27);

    _W(WARN_TRACK, IDS_TRCK_WRN49, snmpStatus.dwCurrentState);

    return snmpStatus.dwCurrentState == SERVICE_RUNNING;
}

DWORD CSNMPController::StartSNMP()
{
    DWORD           retCode;
    SERVICE_STATUS  svcStatus;
    DWORD           dwRetries;

    if ((retCode = LoadSvcHandle()) != ERROR_SUCCESS)
        return retCode;

    if (!StartService(m_hSNMPService, 0, NULL))
        return _E(GetLastError(), IDS_ERR28);

    for (dwRetries = 10; dwRetries > 0; dwRetries--)
    {
        printf("."); fflush(stdout);
        if (!QueryServiceStatus(m_hSNMPService, &svcStatus))
            return _E(GetLastError(), IDS_ERR29);
        if (svcStatus.dwCurrentState == SERVICE_RUNNING)
            break;
        if (svcStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            if (svcStatus.dwWaitHint < 200)
                svcStatus.dwWaitHint = 200;
            if (svcStatus.dwWaitHint > 1000)
                svcStatus.dwWaitHint = 1000;
            Sleep(svcStatus.dwWaitHint);
        }
        else
            return _E(ERROR_INVALID_STATE, IDS_ERR06, svcStatus.dwWaitHint);
    }
    printf("\n");

    return retCode;
}

DWORD CSNMPController::StopSNMP()
{
    DWORD           retCode;
    SERVICE_STATUS  svcStatus;
    DWORD           dwRetries;

    if ((retCode = LoadSvcHandle()) != ERROR_SUCCESS)
        return retCode;

    if (!ControlService(m_hSNMPService, SERVICE_CONTROL_STOP, &svcStatus))
    {
        retCode = GetLastError();
        if (retCode == ERROR_SERVICE_NOT_ACTIVE)
        {
            _W(WARN_TRACK, IDS_TRCK_WRN50);
            return ERROR_SUCCESS;
        }
        return _E(GetLastError(), IDS_ERR30);
    }

    for (dwRetries = 10; dwRetries > 0; dwRetries--)
    {
        printf("."); fflush(stdout);
        if (!QueryServiceStatus(m_hSNMPService, &svcStatus))
            return _E(GetLastError(), IDS_ERR31);
        if (svcStatus.dwCurrentState == SERVICE_STOPPED)
            break;
        if (svcStatus.dwCurrentState == SERVICE_STOP_PENDING)
        {
            if (svcStatus.dwWaitHint < 200)
                svcStatus.dwWaitHint = 200;
            if (svcStatus.dwWaitHint > 1000)
                svcStatus.dwWaitHint = 1000;
            Sleep(svcStatus.dwWaitHint);
        }
        else
            return _E(ERROR_INVALID_STATE, IDS_ERR06, svcStatus.dwWaitHint);
    }
    printf("\n");

    if (dwRetries == 0)
        return _E(ERROR_TIMEOUT, IDS_ERR07);

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\registry.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "EventCmd.h"
#include "Registry.h"
#include "Operation.h"

CRegistry gRegistry;

DWORD CRegistry::ConfigureRegSource(HKEY hRegSource, char *szEventSource)
{
    DWORD retCode;
    char *szSourceOID;
    char *szEventDup;
    int   nIndex;
    DWORD dwAppend;

    szSourceOID = new char[4*strlen(szEventSource) + 9];
    if (szSourceOID == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);

    nIndex = sprintf(szSourceOID, "%u.", strlen(szEventSource));
    for (szEventDup = szEventSource; *szEventDup != '\0'; szEventDup++)
        nIndex += sprintf(szSourceOID+nIndex,"%d.",*szEventDup);

    if (nIndex == 0)
    {
        retCode = _E(ERROR_FUNCTION_FAILED, IDS_ERR05, szEventSource);
        goto done;
    }
    szSourceOID[--nIndex]='\0';

    retCode = RegSetValueEx(
                hRegSource,
                REG_SRC_ENTOID,
                0,
                REG_SZ,
                (const BYTE *)szSourceOID,
                nIndex);
    if (retCode != ERROR_SUCCESS)
    {
        retCode = _E(retCode, IDS_ERR11, REG_SRC_ENTOID, szEventSource);
        goto done;
    }

    dwAppend = 1;
    retCode = RegSetValueEx(
                hRegSource,
                REG_SRC_APPEND,
                0,
                REG_DWORD,
                (const BYTE *)&dwAppend,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
    {
        retCode = _E(retCode, IDS_ERR11, REG_SRC_APPEND, szEventSource);
        goto done;
    }

    _W(WARN_TRACK, IDS_TRCK_WRN33, szEventSource);
done:
    delete szSourceOID;
    return retCode;
}

DWORD CRegistry::ConfigureRegEvent(HKEY hRegEvent, DWORD dwEventID, DWORD dwCount, DWORD dwTime)
{
    DWORD retCode = ERROR_SUCCESS;

    retCode = RegSetValueEx(
                hRegEvent,
                REG_EVNT_ID,
                0,
                REG_DWORD,
                (const BYTE *)&dwEventID,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR13, REG_EVNT_ID, dwEventID);
    retCode = RegSetValueEx(
                hRegEvent,
                REG_EVNT_COUNT,
                0,
                REG_DWORD,
                (const BYTE *)&dwCount,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR13, REG_EVNT_COUNT, dwEventID);
    retCode = RegSetValueEx(
                hRegEvent,
                REG_EVNT_TIME,
                0,
                REG_DWORD,
                (const BYTE *)&dwTime,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR13, REG_EVNT_TIME, dwEventID);

    return retCode;
}

DWORD CRegistry::ScanForTrap(HKEY hRegCommunity, char *szAddress, char *szName, DWORD & nNameLen)
{
    DWORD   retCode;
    DWORD   nMaxName = 1;
    char    szDataBuffer[64];

    for (DWORD i = 0, iNameLen = nNameLen, iDataLen = 64;
         (retCode = RegEnumValue(
                     hRegCommunity,
                     i,
                     szName,
                     &iNameLen,
                     0,
                     NULL,
                     (BYTE *)szDataBuffer,
                     &iDataLen)) == ERROR_SUCCESS;
         i++, iNameLen = nNameLen, iDataLen = 64)
    {
        DWORD nNameNum;

        if (strcmp(szDataBuffer, szAddress) == 0)
            return ERROR_ALREADY_EXISTS;

        nNameNum = atoi(szName);
        if (nMaxName <= nNameNum)
            nMaxName = nNameNum+1;
    }

    if (retCode != ERROR_NO_MORE_ITEMS)
        return _E(retCode, IDS_ERR12);

    nNameLen = sprintf(szName, "%u", nMaxName);
    retCode = ERROR_SUCCESS;

    return retCode;
}

CRegistry::CRegistry()
{
    m_hRegRoot = HKEY_LOCAL_MACHINE;
    m_hRegSnmpTraps = NULL;
    m_hRegEvntSources = NULL;
    m_dwFlags = 0;
}

CRegistry::~CRegistry()
{
    if (m_hRegRoot != HKEY_LOCAL_MACHINE)
        RegCloseKey(m_hRegRoot);
    if (m_hRegSnmpTraps != NULL)
        RegCloseKey(m_hRegSnmpTraps);
    if (m_hRegEvntSources != NULL)
        RegCloseKey(m_hRegEvntSources);
}

DWORD CRegistry::Connect()
{
    DWORD retCode = ERROR_SUCCESS;

    if (gCommandLine.m_szSystem != NULL)
    {
        _W(WARN_ATTENTION,IDS_ATTN_WRN34, gCommandLine.m_szSystem);
        retCode = RegConnectRegistry(gCommandLine.m_szSystem, HKEY_LOCAL_MACHINE, &m_hRegRoot);
    }
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR14, gCommandLine.m_szSystem);
    return retCode;
}

DWORD CRegistry::AddEvent(char *szEventSource, DWORD dwEventID, DWORD dwCount, DWORD dwTime)
{
    DWORD retCode;
    DWORD dwDisposition;
    HKEY  hRegSource;
    HKEY  hRegEvent;
    char  szEventID[64];

    if (m_hRegEvntSources == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_EVNTAGENT,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegEvntSources);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR15);
    }

    retCode = RegCreateKeyEx(
                m_hRegEvntSources,
                szEventSource,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hRegSource,
                &dwDisposition);
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR16, szEventSource);
    if (dwDisposition == REG_CREATED_NEW_KEY)
    {
        retCode = ConfigureRegSource(hRegSource, szEventSource);
        if (retCode != ERROR_SUCCESS)
        {
            RegCloseKey(hRegSource);
            return retCode;
        }
    }
    sprintf(szEventID,"%u",dwEventID);
    retCode = RegCreateKeyEx(
                hRegSource,
                szEventID,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hRegEvent,
                &dwDisposition);
    if (retCode != ERROR_SUCCESS)
    {
        RegCloseKey(hRegSource);
        return _E(retCode, IDS_ERR17, szEventSource);
    }

    retCode = ConfigureRegEvent(hRegEvent, dwEventID, dwCount, dwTime);

    _W(WARN_ATTENTION, IDS_ATTN_WRN35,
        dwDisposition == REG_CREATED_NEW_KEY ? "new" : "existing",
        dwEventID);
 
    RegCloseKey(hRegSource);
    RegCloseKey(hRegEvent);

    return retCode;
}

DWORD CRegistry::DelEvent(char *szEventSource, DWORD dwEventID)
{
    DWORD       retCode;
    char        szEventID[64];
    DWORD       nSzEventID = 64;
    HKEY        hRegSource;
    FILETIME    ft;

    if (m_hRegEvntSources == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_EVNTAGENT,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegEvntSources);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR18);
    }

    retCode = RegOpenKeyEx(
                m_hRegEvntSources,
                szEventSource,
                0,
                KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                &hRegSource);
    if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_ATTENTION, IDS_ATTN_WRN36, szEventSource);
        return ERROR_SUCCESS;
    }

    sprintf(szEventID,"%u",dwEventID);

    retCode = RegDeleteKey(hRegSource, szEventID);
    if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_ATTENTION, IDS_ATTN_WRN37, szEventID);
        RegCloseKey(hRegSource);
        return ERROR_SUCCESS;
    }

    _W(WARN_ATTENTION, IDS_ATTN_WRN38, dwEventID);

    retCode = RegEnumKeyEx(
                hRegSource,
                0,
                szEventID,
                &nSzEventID,
                0,
                NULL,
                NULL,
                &ft);
    RegCloseKey(hRegSource);
    if (retCode == ERROR_NO_MORE_ITEMS)
    {
        retCode = RegDeleteKey(m_hRegEvntSources, szEventSource);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR19, szEventSource);
        _W(WARN_TRACK, IDS_TRCK_WRN39, szEventSource);
        retCode = ERROR_SUCCESS;
    }
    else if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_TRACK, IDS_TRCK_WRN40, retCode, szEventSource);
        retCode = ERROR_SUCCESS;
    }

    return retCode;
}

DWORD CRegistry::AddTrap(char *szCommunity, char *szAddress)
{
    DWORD   retCode;
    DWORD   dwDisposition;
    char    szTrapName[64];
    DWORD   nLenTrapName = 64;
    HKEY    hRegCommunity;

    if (m_hRegSnmpTraps == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_SNMPTRAPS,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegSnmpTraps);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR20);
    }

    retCode = RegCreateKeyEx(
                m_hRegSnmpTraps,
                szCommunity,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hRegCommunity,
                &dwDisposition);
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR21, szCommunity);
    if (dwDisposition == REG_CREATED_NEW_KEY)
        _W(WARN_TRACK, IDS_TRCK_WRN41, szCommunity);
        
    retCode = ScanForTrap(hRegCommunity, szAddress, szTrapName, nLenTrapName);
    if (retCode != ERROR_SUCCESS)
    {
        RegCloseKey(hRegCommunity);
        if (retCode == ERROR_ALREADY_EXISTS)
        {
            _W(WARN_ATTENTION, IDS_ATTN_WRN42, szAddress, szTrapName);
            retCode = ERROR_SUCCESS;
        }
        return retCode;
    }

    retCode = RegSetValueEx(
                hRegCommunity,
                szTrapName,
                0,
                REG_SZ,
                (const BYTE*)szAddress,
                strlen(szAddress));
    
    if (retCode != ERROR_SUCCESS)
        _E(retCode, IDS_ERR22, szAddress);
    else
    {
        m_dwFlags |= REG_FLG_NEEDRESTART;
        _W(WARN_ATTENTION, IDS_ATTN_WRN43, szAddress);
    }

    RegCloseKey(hRegCommunity);
    return retCode;
}

DWORD CRegistry::DelTrap(char *szCommunity, char *szAddress)
{
    DWORD   retCode;
    char    szTrapName[64];
    DWORD   nLenTrapName = 64;
    HKEY    hRegCommunity;

    if (m_hRegSnmpTraps == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_SNMPTRAPS,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegSnmpTraps);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR23);
    }

    if ((retCode = RegOpenKeyEx(
                    m_hRegSnmpTraps,
                    szCommunity,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &hRegCommunity)) == ERROR_SUCCESS  &&
        (retCode = ScanForTrap(hRegCommunity, szAddress, szTrapName, nLenTrapName)) == ERROR_ALREADY_EXISTS)
    {
        retCode = RegDeleteValue(
                    hRegCommunity,
                    szTrapName);
    
        if (retCode != ERROR_SUCCESS)
        {
            RegCloseKey(hRegCommunity);
            return _E(retCode, IDS_ERR24, szAddress);
        }
        else
        {
            m_dwFlags |= REG_FLG_NEEDRESTART;
            _W(WARN_ATTENTION, IDS_ATTN_WRN44, szAddress);
        }
    }
    else
    {
        _W(WARN_ATTENTION, IDS_ATTN_WRN45, szAddress, szCommunity);
        retCode = ERROR_SUCCESS;
    }

    retCode =  RegEnumValue(
                hRegCommunity,
                0,
                szTrapName,
                &nLenTrapName,
                0,
                NULL,
                NULL,
                NULL);

    RegCloseKey(hRegCommunity);

    if (retCode == ERROR_NO_MORE_ITEMS)
    {
        retCode = RegDeleteKey(m_hRegSnmpTraps, szCommunity);
        if (retCode != ERROR_SUCCESS)
            _W(WARN_ERROR, IDS_ERRO_WRN46, retCode, szCommunity);
        else
            _W(WARN_TRACK, IDS_TRCK_WRN47, szCommunity);
        retCode = ERROR_SUCCESS;
    }
    else if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_TRACK, IDS_TRCK_WRN48, retCode, szCommunity);
        retCode = ERROR_SUCCESS;
    }
 
    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntcmd\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>		// MFC template classes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\dlgsavep.h ===
// dlgsavep.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgSaveProgress dialog

class CDlgSaveProgress : public CDialog
{
// Construction
public:
	CDlgSaveProgress(BOOL bIsSaving = FALSE);   // standard constructor
    BOOL StepProgress(LONG nSteps = 1);
    void SetStepCount(LONG nSteps);

// Dialog Data
	//{{AFX_DATA(CDlgSaveProgress)
	enum { IDD = IDD_SAVE_PROGRESS };
	CProgressCtrl	m_progress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgSaveProgress)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgSaveProgress)
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void ProgressYield();
    BOOL m_bWasCanceled;
    BOOL m_bIsSaving;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\dlgsavep.cpp ===
// dlgsavep.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "dlgsavep.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgSaveProgress dialog


CDlgSaveProgress::CDlgSaveProgress(BOOL bIsSaving)
	: CDialog(CDlgSaveProgress::IDD, NULL)
{
	//{{AFX_DATA_INIT(CDlgSaveProgress)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_bWasCanceled = FALSE;
    m_bIsSaving = bIsSaving;    // May indicate loading or saving.
}


void CDlgSaveProgress::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgSaveProgress)
	DDX_Control(pDX, IDC_PROGRESS, m_progress);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDlgSaveProgress, CDialog)
	//{{AFX_MSG_MAP(CDlgSaveProgress)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDlgSaveProgress message handlers

void CDlgSaveProgress::OnCancel()
{
	// TODO: Add extra cleanup here
    if (!m_bIsSaving) {
        // Cancel is currently enabled only for a load
        m_bWasCanceled = TRUE;	
    	CDialog::OnCancel();
    }
}

void CDlgSaveProgress::ProgressYield()
{
    MSG msg;

    // Remove all available messages for any window that belongs to
    // the current application.
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        // Translate and siapatch the given message if the window handle is
        // null or the given message is not for the modeless dialog box hwnd.
        if (!m_hWnd || !IsDialogMessage(&msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}


BOOL CDlgSaveProgress::StepProgress(LONG nSteps)
{
    ProgressYield();
    while (--nSteps >= 0) {
        m_progress.StepIt();
    }

    return m_bWasCanceled;
}

void CDlgSaveProgress::SetStepCount(LONG nSteps)
{
#if _MFC_VER >= 0x0600
    m_progress.SetRange32(0, nSteps);
#else
    m_progress.SetRange(0, nSteps);
#endif
    m_progress.SetPos(0);
    m_progress.SetStep(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\busy.cpp ===
//****************************************************************************
//
//  Copyright (c) 1994, Microsoft Corporation
//
//  File:  BUSY.CPP
//
//  Implementation file for the CBusy class.
//
//  History:
//
//      Scott V. Walker, SEA     6/30/94    Created.
//
//****************************************************************************

#include "stdafx.h"

#include "portable.h"

#include "busy.h"

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy(CWnd *pParentWnd, LPCTSTR pszText)
{
    SetBusy(pParentWnd, pszText);
}

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy(CWnd *pParentWnd, UINT nID)
{
    CString sText;

    sText.LoadString(nID);
    SetBusy(pParentWnd, sText);
}

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy(CWnd *pParentWnd)
{
    SetBusy(pParentWnd, _T(""));
}

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy()
{
    SetBusy(NULL, _T(""));
}

//****************************************************************************
//
//  CBusy::SetBusy
//
//****************************************************************************
void CBusy::SetBusy(CWnd *pParentWnd, LPCTSTR pszText)
{
    m_pParentWnd = pParentWnd;

    m_hOldCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

    if (m_pParentWnd != NULL)
    {
        TCHAR szOldText[255];

        // Retrieve the current text and save it 'til later.
        szOldText[0] = '\0';
        m_pParentWnd->SendMessage(WM_BUSY_GETTEXT, 255, (LPARAM)szOldText);
        m_sOldText = szOldText;

        if (pszText == NULL)
            pszText = _T("");

        m_pParentWnd->SendMessage(WM_BUSY_SETTEXT, 0, (LPARAM)pszText);
    }
}

//****************************************************************************
//
//  CBusy::~CBusy
//
//****************************************************************************
CBusy::~CBusy()
{
    ::SetCursor(m_hOldCursor);

    if (m_pParentWnd != NULL)
    {
        m_pParentWnd->SendMessage(WM_BUSY_SETTEXT, 0,
            (LPARAM)(LPCTSTR)m_sOldText);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\eventrap.h ===
// eventrap.h : main header file for the EVENTRAP application
//

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp:
// See eventrap.cpp for the implementation of this class
//

class CEventrapApp : public CWinApp
{
public:
        CEventrapApp();

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CEventrapApp)
	public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
        virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);
	//}}AFX_VIRTUAL

// Implementation

        //{{AFX_MSG(CEventrapApp)
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\busy.h ===
//****************************************************************************
//
//  Copyright (c) 1994, Microsoft Corporation
//
//  File:  BUSY.H
//
//  The classes defined here are:
//
//     CBusy    Utility class to indicate to the user that the app is busy.
//              When an instance is constructed, it changes the cursor to the
//              wait cursor.  If a parent window is provided it will receive a
//              message to set the text of its status indicator to a specified
//              string.  This is useful for windows that have a status bar or
//              some other textual indication of status.  When the instance is
//              destructed, the cursor is restored and the parent window is
//              sent a message to reset its status indicator.
//
//  History:
//
//      Scott V. Walker, SEA    6/30/94    Created.
//
//****************************************************************************
#ifndef _BUSY_H_
#define _BUSY_H_

//****************************************************************************
//
//  Messages sent to parent window.
//
//----------------------------------------------------------------------------
//
//  WM_BUSY_GETTEXT
//
//  This message is sent by the CBusy to retrieve the current status indicator
//  text.  The CBusy will restore this text when it destructs.
//
//  wparam = nLength;           // Length of buffer.
//  lparam = (LPARAM)pStr;      // Pointer to buffer to copy data into.
//
//----------------------------------------------------------------------------
//
//  WM_BUSY_SETTEXT
//
//  This message is sent by the CBusy to inform the window to set its status
//  indicator to the given string.
//
//  wparam is unused.
//  lparam = (LPARAM)pStr;      // Pointer to buffer containing status text.
//
//  Return value = n/a.
//
//****************************************************************************

#define WM_BUSY_GETTEXT     (WM_USER + 0x75)
#define WM_BUSY_SETTEXT     (WM_USER + 0x76)

//****************************************************************************
//
//  CLASS:  CBusy
//
//  When you construct a CBusy, you have the option of specifying a parent
//  window and a string ID.  If these are provided, The CBusy will send
//  WM_BUSY_GETTEXT and WM_BUSY_SETTEXT messages to the window during
//  construction and destruction.  The parent window can respond to these
//  messages by modifying a text status indicator (such as a status bar) to
//  display the specified string.  Use these by constructing a local instance
//  at the top of a function.  When the function goes out of scope (no matter
//  where the return is encountered), the instance will be destructed, causing
//  the busy indications (cursor and text) to be restored.
//
//----------------------------------------------------------------------------
//
//  CBusy::CBusy
//
//  Constructor.  When an instance is constructed, it sets the cursor to the
//  wait cursor and optionally notifies a specified window to change its
//  status indicator.
//
//  Parameters:
//      CWnd *pParentWnd    Optional parent window.  If provided, the CBusy
//                          sends WM_BUSY_GETTEXT and WM_BUSY_SETTEXT
//                          messages to the given window.
//      const char *pszText Optional string.  If provided (and if a parent
//                          window is specified), the CBusy passes it in the
//                          WM_BUSY_SETTEXT message to the parent window.  If
//                          not provided, the parent window is sent an empty
//                          string.
//
//      If parameter 2 is a UINT, CBusy will treat it as a string ID and do a
//      LoadString. 
//
//****************************************************************************

class CBusy : public CObject
{

private:

    CWnd *m_pParentWnd;
    HCURSOR m_hOldCursor;
    CString m_sOldText;

private:

    void SetBusy(CWnd *pParentWnd, LPCTSTR pszText);

public:

    CBusy(CWnd *pParentWnd, LPCTSTR pszText);
    CBusy(CWnd *pParentWnd, UINT nID);
    CBusy(CWnd *pParentWnd);
    CBusy();
    ~CBusy();
};

#endif // _BUSY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\eventrap.cpp ===
// eventrap.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "eventrap.h"
#include "trapdlg.h"
#include "globals.h"
#include "utils.h"
#include "trapreg.h"
#include "busy.h"
#include "dlgsavep.h"

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp

BEGIN_MESSAGE_MAP(CEventrapApp, CWinApp)
        //{{AFX_MSG_MAP(CEventrapApp)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp construction

CEventrapApp::CEventrapApp()
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEventrapApp object

CEventrapApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp initialization


LPCTSTR GetNextParam(LPTSTR pszDst, LPCTSTR pszSrc, LONG nchDst)
{
        // Skip any leading white space
        while((*pszSrc==' ') || (*pszSrc=='\t')) {
                ++pszSrc;
        }

        // Reserve a byte for the null terminator
        ASSERT(nchDst >= 1);
        --nchDst;

        // Copy the next parameter to the destination buffer.
        while (nchDst > 0) {
                INT iCh = *pszSrc;
                if ((iCh == 0) || (iCh==' ') || (iCh=='\t')) {
                        break;
                }
                ++pszSrc;
                *pszDst++ = (TCHAR)iCh;
                --nchDst;
        }
        *pszDst = 0;

        return pszSrc;
}

void ParseParams(CStringArray& asParams, LPCTSTR pszParams)
{
        TCHAR szParam[MAX_STRING];
        while(pszParams != NULL) {
                pszParams = GetNextParam(szParam, pszParams, MAX_STRING);
                if (szParam[0] == 0) {
                        break;
                }
                asParams.Add(szParam);
        }
}


BOOL CEventrapApp::InitInstance()
{

    GetThousandSeparator(&g_chThousandSep);

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    CStringArray asParams;
    ParseParams(asParams, m_lpCmdLine);


    SCODE sc;
    LPCTSTR pszComputerName = NULL;

    switch(asParams.GetSize()) {
    case 0:
        break;
    case 1:
        if (!asParams[0].IsEmpty()) {
            pszComputerName = asParams[0];
        }
        break;
    default:
        AfxMessageBox(IDS_ERR_INVALID_ARGUMENT);
        return FALSE;
        break;
    }


    CBusy busy;

    g_reg.m_pdlgLoadProgress = new CDlgSaveProgress;
    g_reg.m_pdlgLoadProgress->Create(IDD_LOAD_PROGRESS, NULL);
    g_reg.m_pdlgLoadProgress->BringWindowToTop();

	//if the local machine is the same as
	//the machine name passed as an argument
	//don't use a machine name.
	if (NULL != pszComputerName)
	{
		TCHAR t_buff[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;

		if (GetComputerName(t_buff, &dwLen))
		{
			if (_tcsicmp(t_buff, pszComputerName) == 0)
			{
				pszComputerName = NULL;
			}
		}
	}

    sc = g_reg.Connect(pszComputerName);
    if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
        delete g_reg.m_pdlgLoadProgress;
        g_reg.m_pdlgLoadProgress = NULL;
        return FALSE;
    }


    // Read the current event to trap configuration from the registry
    sc = g_reg.Deserialize();
    if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
        delete g_reg.m_pdlgLoadProgress;
        g_reg.m_pdlgLoadProgress = NULL;
        return FALSE;
    }

    CEventTrapDlg* pdlg = new CEventTrapDlg;
    m_pMainWnd = pdlg;
    pdlg->Create(IDD_EVNTTRAPDLG, NULL);
    pdlg->BringWindowToTop();

    // Since we are running a modeless dialog, return TRUE so that the message
    // pump is run.

	return TRUE;
}

int CEventrapApp::ExitInstance()
{
    return CWinApp::ExitInstance();
}

BOOL CEventrapApp::ProcessMessageFilter(int code, LPMSG lpMsg)
{
    // TODO: Add your specialized code here and/or call the base class

    return CWinApp::ProcessMessageFilter(code, lpMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\evntfind.h ===
#ifndef _evntfind_h
#define _evntfind_h

// evntfind.h : header file
//
class CSource;

enum FOUND_WHERE {
    I_FOUND_NOTHING,
    I_FOUND_IN_TREE,
    I_FOUND_IN_LIST
};

/////////////////////////////////////////////////////////////////////////////
// CEventFindDlg dialog
class CEventFindDlg : public CDialog
{
// Construction
public:
	CEventFindDlg(CWnd* pParent = NULL);   // standard constructor
    BOOL Create(CSource* pSource, UINT nIDTemplate, CWnd* pParentWnd=NULL);

    ~CEventFindDlg();
    FOUND_WHERE Find(CSource* pSource);

// Dialog Data
    FOUND_WHERE m_iFoundWhere;

	//{{AFX_DATA(CEventFindDlg)
	enum { IDD = IDD_EVENTFINDDLG };
	CString	m_sFindWhat;
	BOOL	m_bMatchWholeWord;
	BOOL	m_bMatchCase;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventFindDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEventFindDlg)
	afx_msg void OnCheckMatchWholeword();
	afx_msg void OnCheckMatchCase();
	afx_msg void OnChangeEditFindWhat();
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioSearchDescriptions();
	afx_msg void OnRadioSearchSources();
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnOK();
	afx_msg void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CSource* m_pSource;
    BOOL m_bSearchInTree;
//    BOOL m_bMatchCase;
//    BOOL m_bWholeWord;
};


#endif //_evntfind_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\evntfind.cpp ===
// evntfind.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "evntfind.h"
#include "source.h"
#include "globals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEventFindDlg dialog


CEventFindDlg::CEventFindDlg(CWnd* pParent)
	: CDialog(CEventFindDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEventFindDlg)
	m_sFindWhat = _T("");
	m_bMatchWholeWord = FALSE;
	m_bMatchCase = FALSE;
	//}}AFX_DATA_INIT

    m_pSource = NULL;
    m_bSearchInTree = TRUE;
    m_bMatchCase = FALSE;
    m_bMatchWholeWord = FALSE;
    m_iFoundWhere = I_FOUND_NOTHING;
}

CEventFindDlg::~CEventFindDlg()
{
    m_pSource->m_pdlgFind = NULL;
}


BOOL CEventFindDlg::Create(CSource* pSource, UINT nIDTemplate, CWnd* pParentWnd)
{
    m_pSource = pSource;
    return CDialog::Create(nIDTemplate, pParentWnd);
}

void CEventFindDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEventFindDlg)
	DDX_Text(pDX, IDC_EDIT_FIND_WHAT, m_sFindWhat);
	DDX_Check(pDX, IDC_CHECK_MATCH_WHOLEWORD, m_bMatchWholeWord);
	DDX_Check(pDX, IDC_CHECK_MATCH_CASE, m_bMatchCase);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEventFindDlg, CDialog)
	//{{AFX_MSG_MAP(CEventFindDlg)
	ON_BN_CLICKED(IDC_CHECK_MATCH_WHOLEWORD, OnCheckMatchWholeword)
	ON_BN_CLICKED(IDC_CHECK_MATCH_CASE, OnCheckMatchCase)
	ON_EN_CHANGE(IDC_EDIT_FIND_WHAT, OnChangeEditFindWhat)
	ON_BN_CLICKED(IDC_RADIO_SEARCH_DESCRIPTIONS, OnRadioSearchDescriptions)
	ON_BN_CLICKED(IDC_RADIO_SEARCH_SOURCES, OnRadioSearchSources)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_FIND_OK, OnOK)
	ON_BN_CLICKED(IDC_FIND_CANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEventFindDlg message handlers



void CEventFindDlg::OnCheckMatchWholeword() 
{
	CButton *pButton = (CButton*)GetDlgItem(IDC_CHECK_MATCH_WHOLEWORD);
	if (pButton != NULL)
        m_bMatchWholeWord = pButton->GetCheck() != 0;
}

void CEventFindDlg::OnCheckMatchCase() 
{
	CButton *pButton = (CButton*)GetDlgItem(IDC_CHECK_MATCH_CASE);
	if (pButton != NULL)
        m_bMatchCase = pButton->GetCheck() != 0;
}

void CEventFindDlg::OnCancel() 
{
	CDialog::OnCancel();
    delete this;
}

void CEventFindDlg::OnChangeEditFindWhat() 
{
    CWnd* pwndEdit = GetDlgItem(IDC_EDIT_FIND_WHAT);
	CButton* pbtnWholeWord = (CButton*) GetDlgItem(IDC_CHECK_MATCH_WHOLEWORD);
	CString sText;

    // Get the search string and check to see if it contains any spaces.	
	pwndEdit->GetWindowText(sText);
	if (sText.Find(_T(' ')) ==-1) {
        // It does not contain a space.  Enable the window.
		if (!pbtnWholeWord->IsWindowEnabled()) {
			pbtnWholeWord->EnableWindow();
		}
	}
	else {
        // The search string contained a space, disable the whole-word button
        // and uncheck it if necessary.
		if (pbtnWholeWord->IsWindowEnabled()) {
			if (pbtnWholeWord->GetCheck() == 1) {
				// The "whole word" button was checked, so uncheck it and
				// disable the button.
			
				pbtnWholeWord->SetCheck(0);
			}
			pbtnWholeWord->EnableWindow(FALSE);
		}
	}	
	
}

BOOL CEventFindDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
    int idButton = m_bSearchInTree ? IDC_RADIO_SEARCH_SOURCES : IDC_RADIO_SEARCH_DESCRIPTIONS;
	CButton *pButton = (CButton*)GetDlgItem(idButton);
	if (pButton != NULL)
		pButton->SetCheck(1);

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEventFindDlg::OnRadioSearchDescriptions() 
{
    m_bSearchInTree = FALSE;
}

void CEventFindDlg::OnRadioSearchSources() 
{
    m_bSearchInTree = TRUE;
}



BOOL CEventFindDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CDialog::OnCommand(wParam, lParam);
}

void CEventFindDlg::OnOK() 
{
	// Get the Find What text.
	CEdit* pEdit = (CEdit*) GetDlgItem(IDC_EDIT_FIND_WHAT);
	if (pEdit == NULL)
		return; // Can't do anything.

	// Empty Find What string; nothing to do.
	pEdit->GetWindowText(m_sFindWhat);
	if (m_sFindWhat.IsEmpty())
		return;
    pEdit->SetSel(0, -1);

	BOOL bFound = m_pSource->Find(m_bSearchInTree, m_sFindWhat, m_bMatchWholeWord, m_bMatchCase);
    SetFocus();

	// Put the focus on the parent window.
    if (bFound) {
        if (m_bSearchInTree) {
            m_iFoundWhere = I_FOUND_IN_TREE;
        }
        else {
            m_iFoundWhere = I_FOUND_IN_LIST;
        }
    }
	else {
		CString sMsg;
		sMsg.LoadString(IDS_MSG_TEXTNOTFOUND);				
		MessageBox(sMsg, NULL, MB_OK | MB_ICONINFORMATION);
	}
	
}



FOUND_WHERE CEventFindDlg::Find(CSource* pSource)
{
    m_pSource = pSource;
    DoModal();
    return m_iFoundWhere;
}

BOOL CEventFindDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_EVENTFINDDLG);
	}
	
	return TRUE;
}

void CEventFindDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (this == pWnd)
		return;

    ::WinHelp (pWnd->m_hWnd,
		       AfxGetApp()->m_pszHelpFilePath,
		       HELP_CONTEXTMENU,
		       (ULONG_PTR)g_aHelpIDs_IDD_EVENTFINDDLG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\evntprop.h ===
// evntprop.h : header file
//

#ifndef EVNTPROP_H
#define EVNTPROP_H 

class CXEventArray;
class CXEvent;



/////////////////////////////////////////////////////////////////////////////
// CEditField window

class CEditField : public CEdit
{
// Construction
public:
	CEditField();
    SCODE CEditField::GetValue(int& iValue);

// Attributes
public:

// Operations
public:
    BOOL IsDirty() {return m_bIsDirty; }
    void ClearDirty() {m_bIsDirty = FALSE; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditField)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditField();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditField)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
    BOOL m_bIsDirty;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CEditSpin window

class CEditSpin : public CSpinButtonCtrl
{
// Construction
public:
	CEditSpin();

// Attributes
public:
    int SetPos(int iPos);
    void SetRange(int nLower, int nUpper);
    BOOL IsDirty();
    void ClearDirty() {m_bIsDirty = FALSE; }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditSpin)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditSpin();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditSpin)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private: 
    BOOL m_bIsDirty;
    int m_iSetPos;
};




/////////////////////////////////////////////////////////////////////////////
// CEventPropertiesDlg dialog

class CEventPropertiesDlg : public CDialog
{
// Construction
public:
	CEventPropertiesDlg(CWnd* pParent = NULL);   // standard constructor
    BOOL EditEventProperties(CXEventArray& aEvents);

// Dialog Data
	//{{AFX_DATA(CEventPropertiesDlg)
	enum { IDD = IDD_PROPERTIESDLG };
	CButton	m_btnWithinTime;
	CEditSpin	m_spinEventCount;
	CEditSpin	m_spinTimeInterval;
	CEditField	m_edtTimeInterval;
	CEditField	m_edtEventCount;
	CButton	m_btnOK;
	CString	m_sDescription;
	CString	m_sSource;
	CString	m_sEventId;
	CString	m_sLog;
	CString	m_sSourceOID;
	CString	m_sFullEventID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventPropertiesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEventPropertiesDlg)
	virtual void OnOK();
	afx_msg void OnWithintime();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void MakeLabelsBold();
    CXEvent* m_pEvent;
    BOOL m_bDidEditEventCount;
    BOOL m_bDidFlipEventCount;
    
    int m_iEventCount;
    int m_iTimeInterval;
};

#endif // EVNTPROP_H
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\evntprop.cpp ===
//***********************************************************************
// evntprop.cpp
//
// This file contains the implementation of the event properties dialog.
//
// Author: SEA
//
// History:
//      20-Febuary-1996     Larry A. French
//          Made various changes to this code.  However, much of it is
//          legacy code and in dire need of being rewritten.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************


#include "stdafx.h"
#include "resource.h"
#include "eventrap.h"
#include "evntprop.h"
#include "trapreg.h"
#include "globals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define MAX_EVENT_COUNT   32767
#define MAX_TIME_INTERVAL 32767



#define IsWithinRange(value, lower, upper) (((value) >= (lower)) && ((value) <= (upper)))

void RangeError(int iLower, int iUpper)
{
    
    TCHAR szBuffer[1024];
    CString sFormat;
    sFormat.LoadString(IDS_ERR_RANGE);
    _stprintf(szBuffer, (LPCTSTR) sFormat, iLower, iUpper);
    AfxMessageBox(szBuffer);
}


/////////////////////////////////////////////////////////////////////////////
// CEventPropertiesDlg dialog


CEventPropertiesDlg::CEventPropertiesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEventPropertiesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEventPropertiesDlg)
	m_sDescription = _T("");
	m_sSource = _T("");
	m_sEventId = _T("");
	m_sLog = _T("");
	m_sSourceOID = _T("");
	m_sFullEventID = _T("");
	//}}AFX_DATA_INIT
}

BOOL CEventPropertiesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

    m_spinEventCount.SetRange(1, MAX_EVENT_COUNT);
    if (m_iEventCount==0) {
        m_spinEventCount.SetPos(1);
    } else {
        m_spinEventCount.SetPos(m_iEventCount);
    }


    if (m_iTimeInterval == 0) {
        m_btnWithinTime.SetCheck(0);
        m_spinTimeInterval.SetRange(0, MAX_TIME_INTERVAL);
    }
    else {
        m_btnWithinTime.SetCheck(1);
        m_spinTimeInterval.SetRange(1, MAX_TIME_INTERVAL);
    }
    m_spinTimeInterval.SetPos(m_iTimeInterval);

    m_edtTimeInterval.EnableWindow(m_btnWithinTime.GetCheck() == 1);
    m_spinTimeInterval.EnableWindow(m_btnWithinTime.GetCheck() == 1);

    // If this is not a custom configuration, do not let the user
    // modify the configuration.
    if ((g_reg.GetConfigType() != CONFIG_TYPE_CUSTOM) || (g_reg.m_bRegIsReadOnly)) {
        m_btnOK.EnableWindow(FALSE);
    }
    m_bDidEditEventCount = FALSE;

    OnWithintime();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}





void CEventPropertiesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CEventPropertiesDlg)
	DDX_Control(pDX, IDC_WITHINTIME, m_btnWithinTime);
	DDX_Control(pDX, IDC_EVENTCOUNTSPN, m_spinEventCount);
	DDX_Control(pDX, IDC_TIMEINTRVLSPN, m_spinTimeInterval);
	DDX_Control(pDX, IDC_TIMEINTERVAL, m_edtTimeInterval);
	DDX_Control(pDX, IDC_EVENTCOUNT, m_edtEventCount);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Text(pDX, IDC_DESCRIPTION, m_sDescription);
	DDV_MaxChars(pDX, m_sDescription, 2048);
	DDX_Text(pDX, ID_STAT_SOURCE, m_sSource);
	DDV_MaxChars(pDX, m_sSource, 256);
	DDX_Text(pDX, ID_STAT_EVENTID, m_sEventId);
	DDX_Text(pDX, ID_STAT_LOG, m_sLog);
	DDX_Text(pDX, IDC_EDIT_ENTERPRISEOID, m_sSourceOID);
	DDX_Text(pDX, IDC_EDIT_FULL_EVENT_ID, m_sFullEventID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEventPropertiesDlg, CDialog)
	//{{AFX_MSG_MAP(CEventPropertiesDlg)
	ON_BN_CLICKED(IDC_WITHINTIME, OnWithintime)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEventPropertiesDlg message handlers

void CEventPropertiesDlg::OnOK() 
{
	// TODO: Add extra validation here
    int iLower, iUpper;
    CString sText;

    m_spinEventCount.GetRange(iLower, iUpper);

    // Validate the event count edit item and set m_iEventCount
    m_edtEventCount.GetWindowText(sText);
    if (!IsDecimalInteger(sText)) {
        RangeError(iLower, iUpper);
        m_edtEventCount.SetSel(0, -1);
        m_edtEventCount.SetFocus();
        return;
    }

    m_iEventCount = _ttoi(sText);

    if (!IsWithinRange(m_iEventCount, iLower, iUpper)) {
        RangeError(iLower, iUpper);
        sText.Format(_T("%u"), m_iEventCount);
        m_edtEventCount.SetWindowText(sText);
        m_edtEventCount.SetSel(0, -1);
        m_edtEventCount.SetFocus();
        return;
    }

    // Validate the time interval and set m_iTimeInterval        
    m_spinTimeInterval.GetRange(iLower, iUpper);
    m_edtTimeInterval.GetWindowText(sText);
    if (!IsDecimalInteger(sText)) {            
        RangeError(iLower, iUpper);
        m_edtTimeInterval.SetSel(0, -1);
        m_edtTimeInterval.SetFocus();
        return;
    }

    m_iTimeInterval = _ttoi(sText);
	if (m_btnWithinTime.GetCheck() == 1) {                          
		if (m_iEventCount < 2) {
			AfxMessageBox(IDS_ERR_PROP_TIME1);
            m_edtEventCount.SetSel(0, -1);
            m_edtEventCount.SetFocus();
            return;
		}

		if (m_iTimeInterval < 1) {
			AfxMessageBox(IDS_ERR_PROP_TIME2);
            sText.Format(_T("%u"), m_iTimeInterval);
            m_edtTimeInterval.SetWindowText(sText);
            m_edtTimeInterval.SetSel(0, -1);
            m_edtTimeInterval.SetFocus();
            return;
		}

        if (!IsWithinRange(m_iTimeInterval, iLower, iUpper)) {
            RangeError(iLower, iUpper);
            sText.Format(_T("%u"), m_iTimeInterval);
            m_edtTimeInterval.SetWindowText(sText);
            m_edtTimeInterval.SetSel(0, -1);
            m_edtTimeInterval.SetFocus();
            return;
        }
	}
	else if (m_iEventCount < 1) {	
		AfxMessageBox(IDS_ERR_PROP_TIME_LESS_THAN_TWO);
        m_edtEventCount.SetSel(0, -1);
        return;
	}

    CDialog::OnOK();

    // We don't set the g_reg.m_bIsDirty flag here because we want to see if the
    // user actually changed the current settings.  This check is made in 
    // CEventPropertiesDlg::EditEventProperties on a per-event basis.
}


void CEventPropertiesDlg::OnWithintime() 
{
	// The WithinTime checkbox was clicked.
	// Enable/disable the TimeInterval control.

    
    // Check to see if the count field has been edited.  If it has been edited,
    // mark the field as being dirty.

    if (m_edtEventCount.IsDirty() || m_spinEventCount.IsDirty()) {
        m_bDidEditEventCount = TRUE;
    }

    int iEventCount;
    int iTemp;
    SCODE sc = m_edtEventCount.GetValue(iEventCount);
    if (FAILED(sc)) {
        m_spinEventCount.GetRange(iEventCount, iTemp);
        m_spinEventCount.SetPos(iEventCount);
        m_bDidEditEventCount = FALSE;
    }

	if (m_btnWithinTime.GetCheck() == 1) {
        m_edtTimeInterval.EnableWindow(TRUE);
        m_spinTimeInterval.EnableWindow(TRUE);

        if (iEventCount < 2) {
            // If the event count is less than two, it will flip to two when the spin button's
            // range is set.  In this event, we make it appear as if the user never edited the
            // value so that it will flip back when the check box is unchecked.
            m_bDidEditEventCount = FALSE;
            m_bDidFlipEventCount = TRUE;
            m_edtEventCount.ClearDirty();
            m_spinEventCount.ClearDirty();
            m_spinEventCount.SetPos(2);
        }


   	    m_spinEventCount.SetRange(2, MAX_EVENT_COUNT);
	    m_spinTimeInterval.SetRange(1, MAX_TIME_INTERVAL);
	}
	else {
        m_edtTimeInterval.EnableWindow(FALSE);
        m_spinTimeInterval.EnableWindow(FALSE);

   	    m_spinEventCount.SetRange(1, MAX_EVENT_COUNT);
        m_spinEventCount.SetPos(iEventCount);
	    m_spinTimeInterval.SetRange(0, MAX_TIME_INTERVAL);
		m_spinTimeInterval.SetPos(0);


        // If the initial event count was one and we flipped it to two when the "within time"
        // button was clicked, then flip it back to one now if it was not edited.
        if (m_bDidFlipEventCount) {       
            if (!m_bDidEditEventCount) {
                m_spinEventCount.SetPos(1);
            }
            m_bDidFlipEventCount = FALSE;
        }
	}
	m_spinTimeInterval.SetRedraw();
}



//***************************************************************************
//
//  CEventPropertiesDlg::MakeLabelsBold
//
//  This method makes the static labels bold to enhance the appearance of
//  the dialog.
//
//	This method should be called after CDIalog::InitDialog.
//
//  Parameters:
//		None.
//
//  Returns:
//		Nothing.
//
//  Status:
//		The MFC2.0 library makes the labels invisible when an attempt
//		is made to change the font of a static item.  I've tried this with
//		MFC4.0 and it works.  
//      
//***************************************************************************
void CEventPropertiesDlg::MakeLabelsBold()
{
#if 0
	CFont* pfontDefault;
	LOGFONT lf;

 	// Get the LOGFONT for the default static item font and then
	// switch the logfont weight to bold.
	pfontDefault = m_statSource.GetFont();
	pfontDefault->GetObject(sizeof(lf), &lf);
	lf.lfWeight = FW_BOLD;

	// Create a bold font with all other characteristics the same as the
	// default font.  Then switch all labels to a bold font. 
	CFont fontNew;
	if (fontNew.CreateFontIndirect(&lf)) {
		m_statSource.SetFont(&fontNew, TRUE);
		m_statLog.SetFont(&fontNew, TRUE);
		m_statEventID.SetFont(&fontNew, TRUE);
		m_statEnterpriseOID.SetFont(&fontNew, TRUE);		
	}

#endif //0
}





//********************************************************************
// CEventPropertiesDlg::EditEventProperties
//
// Edit the properties of a number of events.
//
// Parameters:
//      CEventArray& aEvents
//          An array of CEvent pointers.  These are the events that
//          are to be edited.
//
// Returns:
//      BOOL
//          TRUE if the user clicked OK and the events were edited.
//          FALSE if the user clicked Cancel and the events were not
//          edited.
//
//******************************************************************
BOOL CEventPropertiesDlg::EditEventProperties(CXEventArray& aEvents)
{
    LONG nEvents = aEvents.GetSize();
    if (nEvents == 0) {
        return TRUE;
    }


    // The first event is taken as a representative of the other
    // events.  Copy the appropriate data from this event to the
    // dialog.
    CString sText;

    CXEvent* pEvent = aEvents[0];
    CXEventSource* pEventSource = pEvent->m_pEventSource;
    CXEventLog* pEventLog = pEventSource->m_pEventLog;

    LONG iEvent;
    BOOL bMultipleSources = FALSE;
    BOOL bMultipleLogs = FALSE;
    for (iEvent=0; iEvent < nEvents; ++iEvent) {
        pEvent = aEvents[iEvent];
        if (pEvent->m_pEventSource != pEventSource) {
            bMultipleSources = TRUE;
        }
        if (pEvent->m_pEventSource->m_pEventLog != pEventLog) {
            bMultipleLogs = TRUE;
        }
    }

    if (bMultipleSources) {
        m_sSource.LoadString(IDS_MULTIPLE_SEL);
        m_sSourceOID.LoadString(IDS_MULTIPLE_SEL);
    }
    else {    
        m_sSource = pEventSource->m_sName;
        pEventSource->GetEnterpriseOID(m_sSourceOID, TRUE);
    }

    if (bMultipleLogs) {        
        m_sLog.LoadString(IDS_MULTIPLE_SEL);
    }
    else {
        m_sLog = pEventSource->m_pEventLog->m_sName;
    }

    // Copy the initial values.
    m_iTimeInterval = (int) pEvent->m_dwTimeInterval;
    m_iEventCount = pEvent->m_dwCount;
    m_bDidFlipEventCount = FALSE;
//    m_bWithinTime = (m_iTimeInterval != 0);


    if (nEvents > 1) {
        m_sEventId.LoadString(IDS_MULTIPLE_SEL);
        m_sDescription.LoadString(IDS_MULTIPLE_SEL);
        m_sFullEventID.LoadString(IDS_MULTIPLE_SEL);
    }
    else {
        pEvent->m_message.GetShortId(m_sEventId);
        m_sDescription = pEvent->m_message.m_sText;
        DecString(m_sFullEventID, pEvent->m_message.m_dwId);
    }

    
    // Put up the dialog and let the user edit the data.
    BOOL bDidCancel = (DoModal() == IDCANCEL);
    if (bDidCancel) {
        // The user canceled the dialog, so do nothing.
        return FALSE;
    }

    // Control comes here if the user clicked OK.  Now we need to copy the
    // user's settings to each event that we are editing and mark the registry
    // as dirty if any of the settings changed.
    for (iEvent=0; iEvent < nEvents; ++iEvent) {
        pEvent = aEvents[iEvent];
        if (pEvent->m_dwTimeInterval != (DWORD) m_iTimeInterval) {
            g_reg.SetDirty(TRUE);
            pEvent->m_dwTimeInterval = (DWORD) m_iTimeInterval;
        }

        if (pEvent->m_dwCount !=  (DWORD) m_iEventCount) {
            g_reg.SetDirty(TRUE);
            pEvent->m_dwCount = m_iEventCount;
        }
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CEditField

CEditField::CEditField()
{
    m_bIsDirty = FALSE;
}

CEditField::~CEditField()
{
}


BEGIN_MESSAGE_MAP(CEditField, CEdit)
	//{{AFX_MSG_MAP(CEditField)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditField message handlers

void CEditField::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default	
	CEdit::OnChar(nChar, nRepCnt, nFlags);
    m_bIsDirty = TRUE;
}

SCODE CEditField::GetValue(int& iValue)
{
    CString sValue;
    GetWindowText(sValue);
    if (!IsDecimalInteger(sValue)) {
        return E_FAIL;
    }

    iValue = _ttoi(sValue);
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CEditSpin

CEditSpin::CEditSpin()
{
    m_bIsDirty = FALSE;
    m_iSetPos = 0;
}

CEditSpin::~CEditSpin()
{
}


BEGIN_MESSAGE_MAP(CEditSpin, CSpinButtonCtrl)
	//{{AFX_MSG_MAP(CEditSpin)
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditSpin message handlers

void CEditSpin::OnLButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	CSpinButtonCtrl::OnLButtonUp(nFlags, point);
    if (GetPos() != m_iSetPos) {
        m_bIsDirty = TRUE;
    }
}


int CEditSpin::SetPos(int iPos)
{
    int iResult = CSpinButtonCtrl::SetPos(iPos);
    m_iSetPos = GetPos();
    m_bIsDirty = FALSE;
    return iResult;
}


void CEditSpin::SetRange(int iLower, int iUpper)
{
	int iPos = GetPos();
    CSpinButtonCtrl::SetRange(iLower, iUpper);

	if (iPos < iLower) {
		iPos = iLower;
	}
	
	if (iPos > iUpper) {
		iPos = iUpper;
	}

	SetPos(iPos);
    SetRedraw();

    m_iSetPos = iLower;
    m_bIsDirty = FALSE;
}


BOOL CEditSpin::IsDirty()
{
    int iCurPos = GetPos();

    return (m_bIsDirty || (m_iSetPos != iCurPos));
}

BOOL CEventPropertiesDlg::OnHelpInfo(HELPINFO *pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW &&
        pHelpInfo->iCtrlId != IDD_NULL)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_PROPERTIESDLG);
	}
	
	return TRUE;
}

void CEventPropertiesDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (pWnd == this)
		return;

    ::WinHelp (pWnd->m_hWnd,
		       AfxGetApp()->m_pszHelpFilePath,
		       HELP_CONTEXTMENU,
		       (ULONG_PTR)g_aHelpIDs_IDD_PROPERTIESDLG);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\export.cpp ===
//***********************************************************************
// export.cpp
//
// This file contains the implementation of the CDlgExport class.  This class
// puts up the "Export Events" dialog and handles writing the events out
// to an export file in the user-selected format.
//
// Author: Larry A. French
//
// History:
//      1-Mar-1996     Larry A. French
//          Wrote it.
//
//      14-May-1996     Larry A. French
//          Fixed a problem where the defines for the file extension included
//          a "." prefix instead of just the base extension.  This caused various
//          problems such as generting file names such as "foo..cnf" when the
//          user just entered "foo".
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************


#include "stdafx.h"
#include "busy.h"
#include "export.h"
#include "globals.h"
#include "trapreg.h"
//#include "smsnames.h"

//**************************************************************************
// CDlgExport::CDlgExport
//
// Constructor for the CDlgExport class.
//
//**************************************************************************
CDlgExport::CDlgExport() : CFileDialog(FALSE)
{
    // We need to strip off the "." prefix for the filename extensions
    // so that it is easier to use them.  Ideally we would just change
    // the defines for these extension strings, but since their definitions
    // are in a global file, we will just fix the problem here.
    m_ofn.Flags |= OFN_PATHMUSTEXIST;
    m_sFileTitle.LoadString(IDS_EXPORT_DEFAULT_FILENAME);
}

//**************************************************************
// CDlgExport::GetFilters
//
// Get the filter strings that will be used in CFileDialog.
// These are the filter strings that appear in the drop-down
// file-type combo.  Each filter is described by a pair of
// adjacent strings.  The first string of each pair specifies the
// "type" string that the user sees.  The second string of each
// pair specifies the file extension associated with the file type.
//
// For more information, please see the CFileDialog documentation.
//
// Parameters:
//      LPTSTR pszDst
//          Pointer to the destination buffer.  The size of this
//          buffer should be MAX_STRING, so there will be plenty
//          of room for the filter strings since they are relatively
//          short.  Note that no bounds checking is done on the
//          buffer size.
//
// Returns:
//      The filter strings are returned in the buffer pointed to
//      by pszDst.
//
//****************************************************************
void CDlgExport::GetFilters(LPTSTR pszDst)
{
    CString sText;

    // Set the type1 filter
    sText.LoadString(IDS_EXPORT_CNF_FILTER);
    _tcscpy(pszDst, (LPCTSTR) sText);
    pszDst += sText.GetLength() + 1;

    // Set the type1 extension
    _tcscpy(pszDst, FILE_DEF_EXT);
    pszDst += _tcslen(FILE_DEF_EXT) + 1;

    *pszDst = 0;
}

//*************************************************************************
// CDlgExport::ExportEvents
//
// Write the events to the specified file in the specified file format.
//
// Parameters:
//      CXEventArray& aEvents
//          The array of events to be written to the file.
//
//      CString& sPath
//          The output file's pathname.
//
//      LONG iFileType
//          The output file's format type. This may be EXPORT_TYPE1 or
//          EXPORT_TYPE2.
//
// Returns:
//      SCODE
//          S_OK if everything was successfule, otherwise E_FAIL.
//
//***************************************************************************
SCODE CDlgExport::ExportEvents(CXEventArray& aEvents, CString& sPath, LONG iFileType)
{
    CBusy busy;
    FILE* pfile;

    // Create the export file
    while (TRUE) {
        pfile = _tfopen(sPath, _T("w"));
        if (pfile != NULL) {
            break;
        }

        CString sText;
        sText.LoadString(IDS_ERR_CANT_CREATE_FILE);
        sText = sText + sPath;
        if (AfxMessageBox(sText, MB_RETRYCANCEL) == IDRETRY) {
            continue;
        }
        return E_FAIL;
    }

    // Write the events to the file in the requested format.
    LONG nEvents = aEvents.GetSize();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent)
    {
        CXEvent* pEvent = aEvents[iEvent];
        CXEventSource* pEventSource = pEvent->m_pEventSource;
        CXEventLog* pEventLog = pEventSource->m_pEventLog;

        _ftprintf(pfile, _T("#pragma add %s \"%s\" %lu %lu %lu\n"),
                (LPCTSTR) pEventLog->m_sName,
                (LPCTSTR) pEventSource->m_sName,
                pEvent->m_message.m_dwId,
                pEvent->m_dwCount,
                pEvent->m_dwTimeInterval
                );
    }

    fclose(pfile);
    return S_OK;
}


//*************************************************************************************
// CDlgExport::DoModal
//
// This is the only public method for CDlgExport.  It displays the "Export Events" dialog
// and does everthing necessary to write out the event file in the proper format.
//
// Parameters:
//      CXEventArray& aEvents
//          The events that the user wants to export.
//
// Returns:
//      int
//          IDOK if the user exported the events and everything went OK.
//          IDCANCEL if the user canceled the export or an error occurred writing
//          the export file.
//
//**************************************************************************************
INT_PTR CDlgExport::DoModal(CXEventArray& aEvents)
{
    ASSERT(aEvents.GetSize() > 0);

    // Put up a custom CFileDialog with a title of "Export Events"
    CString sTitle;
    sTitle.LoadString(IDS_EXPORT_DIALOG_TITLE);
    m_ofn.lpstrTitle = sTitle;

    // The value to initialize the filename edit item to.  A temporary
    // string is used because we only want to save the file title and
    // not its full path.
    CString sFile = m_sFileTitle;
    m_ofn.lpstrFile = sFile.GetBuffer(MAX_STRING);
    m_ofn.nMaxFile = MAX_STRING - 1;

    // Set the file title, so that when the user clicks OK, its
    // value will be set.
    m_ofn.lpstrFileTitle = m_sFileTitle.GetBuffer(MAX_STRING);
    m_ofn.nMaxFileTitle = MAX_STRING - 1;

    // Set the filters for the different file types.
    TCHAR szFilters[MAX_STRING];
    GetFilters(szFilters);
    m_ofn.lpstrFilter = (LPCTSTR) (void*) szFilters;

    // Put up the dialog.
    INT_PTR iStat = CFileDialog::DoModal();
    m_sFileTitle.ReleaseBuffer();
    sFile.ReleaseBuffer();

    sFile = GetPathName();

    // If the user selected "OK", write out the event file in the selected format.
    if (iStat == IDOK)
    {
        SCODE sc = ExportEvents(aEvents, sFile, m_ofn.nFilterIndex);
        if (FAILED(sc)) {
            iStat = IDCANCEL;
        }
    }
    return iStat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\ewhelparr.h ===
#define	IDH_ETD_ADD	10005103
#define	IDH_ETD_BUTTON_EXPORT	10005110
#define	IDH_ETD_EVENTLIST	10005102
#define	IDH_ETD_FIND	10005105
#define	IDH_ETD_LV_SOURCES	10005107
#define	IDH_ETD_PROPERTIES	10005109
#define	IDH_ETD_RADIO_CUSTOM	10005100
#define	IDH_ETD_RADIO_DEFAULT	10005101
#define	IDH_ETD_REMOVE	10005104
#define	IDH_ETD_SETTINGS	10005108
#define	IDH_ETD_TV_SOURCES	10005106
#define	IDH_ETD_VIEW	10005111
#define IDH_ETD_APPLY	10005112
#define	IDH_EVENTFDLG_CHECK_MATCH_CASE	10005004
#define	IDH_EVENTFDLG_CHECK_MATCH_WHOLEWORD	10005003
#define	IDH_EVENTFDLG_EDIT_FIND_WHAT	10005000
#define	IDH_EVENTFDLG_RADIO_SEARCH_DESCRIPTIONS	10005002
#define	IDH_EVENTFDLG_RADIO_SEARCH_SOURCES	10005001
#define	IDH_STDLG_BUTTON_RESET	10005306
#define	IDH_STDLG_EDIT_MESSAGELENGTH	10005301
#define	IDH_STDLG_EDIT_TRAP_COUNT	10005307
#define	IDH_STDLG_EDIT_TRAP_SECONDS	10005308
#define	IDH_STDLG_LIMITMSGLNGTH	10005300
#define	IDH_STDLG_RADIO_DISABLE	10005305
#define	IDH_STDLG_RADIO_ENABLE	10005304
#define	IDH_STDLG_RADIO1	10005302
#define	IDH_STDLG_RADIO2	10005303
#define IDH_FIND_CANCEL 10005005
#define IDH_FIND_OK 10005006
//New IDs for IDD_PROPERTIESDLG
#define IDH_STAT_EVENTID 10005203
#define IDH_PROP_DESCRIPTION 10005208
#define IDH_PROP_EDIT_ENTERPRISEOID 10005201
#define IDH_PROP_EDIT_FULL_EVENT_ID 10005204
#define IDH_PROP_EVENTCOUNT 10005205
#define IDH_PROP_TIMEINTERVAL 10005207
#define IDH_PROP_WITHINTIME 10005206
#define IDH_STAT_LOG 10005202
#define IDH_STAT_SOURCE 10005200
//Disable help on instructional text
#define IDH_DISABLEHELP (DWORD(-1))

const DWORD g_aHelpIDs_IDD_EVENTFINDDLG[]=
{
	IDC_RADIO_SEARCH_SOURCES,IDH_EVENTFDLG_RADIO_SEARCH_SOURCES,
	IDC_RADIO_SEARCH_DESCRIPTIONS,IDH_EVENTFDLG_RADIO_SEARCH_DESCRIPTIONS,
	IDC_CHECK_MATCH_WHOLEWORD,IDH_EVENTFDLG_CHECK_MATCH_WHOLEWORD,
	IDC_CHECK_MATCH_CASE,IDH_EVENTFDLG_CHECK_MATCH_CASE,
	IDC_EDIT_FIND_WHAT,IDH_EVENTFDLG_EDIT_FIND_WHAT,
    IDC_FIND_OK, IDH_FIND_OK,
    IDC_FIND_CANCEL, IDH_FIND_CANCEL,
	0,0
};

const DWORD g_aHelpIDs_IDD_EVNTTRAPDLG[]=
{
	IDC_STAT_LABEL0, IDH_ETD_EVENTLIST,
	IDC_EVENTLIST,IDH_ETD_EVENTLIST,
	ID_SETTINGS,IDH_ETD_SETTINGS,
	IDC_STAT_LABEL2, IDH_ETD_LV_SOURCES,
	IDC_LV_SOURCES,IDH_ETD_LV_SOURCES,
	IDC_STAT_LABEL1, IDH_ETD_TV_SOURCES,
	IDC_TV_SOURCES,IDH_ETD_TV_SOURCES,
	ID_FIND,IDH_ETD_FIND,
	ID_BUTTON_EXPORT,IDH_ETD_BUTTON_EXPORT,
	ID_ADD,IDH_ETD_ADD,
	ID_VIEW,IDH_ETD_VIEW,
	IDC_RADIO_DEFAULT,IDH_ETD_RADIO_DEFAULT,
	IDC_RADIO_CUSTOM,IDH_ETD_RADIO_CUSTOM,
	ID_REMOVE,IDH_ETD_REMOVE,
	ID_PROPERTIES,IDH_ETD_PROPERTIES,
	IDC_APPLY,IDH_ETD_APPLY,
	0,0
};


const DWORD g_aHelpIDs_IDD_PROPERTIESDLG[]=
{
    ID_SOURCE_LABEL, IDH_STAT_SOURCE,
    ID_STAT_SOURCE, IDH_STAT_SOURCE,
    ID_OID_LABEL, IDH_PROP_EDIT_ENTERPRISEOID,
	IDC_EDIT_ENTERPRISEOID,IDH_PROP_EDIT_ENTERPRISEOID,
    ID_LOG_LABEL, IDH_STAT_LOG,
    ID_STAT_LOG, IDH_STAT_LOG,
    ID_EVENTID_LABEL, IDH_STAT_EVENTID,
    ID_STAT_EVENTID, IDH_STAT_EVENTID,
    ID_TRAPID_LABEL, IDH_PROP_EDIT_FULL_EVENT_ID,
	IDC_EDIT_FULL_EVENT_ID,IDH_PROP_EDIT_FULL_EVENT_ID,
    ID_THRESHOLD_LABEL, IDH_PROP_EVENTCOUNT,
    IDC_EVENTCOUNT,IDH_PROP_EVENTCOUNT,
	IDC_WITHINTIME,IDH_PROP_WITHINTIME,
	IDC_TIMEINTERVAL,IDH_PROP_TIMEINTERVAL,
	IDC_DESCRIPTION,IDH_PROP_DESCRIPTION,
	0,0
};


const DWORD g_aHelpIDs_IDD_SETTINGSDLG[]=
{
    IDC_LIMITMSGLNGTH,IDH_STDLG_LIMITMSGLNGTH,
    IDC_STAT_TRAP_LENGTH, IDH_STDLG_EDIT_MESSAGELENGTH,
	IDC_EDIT_MESSAGELENGTH,IDH_STDLG_EDIT_MESSAGELENGTH,
    IDC_RADIO1,IDH_STDLG_RADIO1,
	IDC_RADIO2,IDH_STDLG_RADIO2,
    IDC_RADIO_ENABLE,IDH_STDLG_RADIO_ENABLE,
    IDC_RADIO_DISABLE,IDH_STDLG_RADIO_DISABLE,
	IDC_BUTTON_RESET,IDH_STDLG_BUTTON_RESET,
    IDC_STATIC_NTRAPS, IDH_STDLG_EDIT_TRAP_COUNT,
	IDC_EDIT_TRAP_COUNT,IDH_STDLG_EDIT_TRAP_COUNT,
    IDC_STATIC_INTERVAL, IDH_STDLG_EDIT_TRAP_SECONDS,
    IDC_EDIT_TRAP_SECONDS,IDH_STDLG_EDIT_TRAP_SECONDS,
	IDC_STATIC_MSG, IDH_DISABLEHELP,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\export.h ===
#ifndef _export_h
#define _export_h

class CXEventArray;
class CXEventSource;

class CDlgExport : private CFileDialog
{
public:
    CDlgExport();
    INT_PTR DoModal(CXEventArray& aEvents);

private:
    void GetFilters(LPTSTR pszDst);
    SCODE ExportEvents(CXEventArray& aEvents, CString& sPath, LONG iFileType);

    // Private member data.
    CString m_sFileTitle;
};


#endif //_export_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\globals.cpp ===
#include "stdafx.h"
#include "trapreg.h"
#include "lcsource.h"
#include "lcevents.h"

CTrapReg g_reg;

// The default value for the comma separator is a comma.  This is replaced by the
// thousands separator generated by GetNumberFormat.
TCHAR g_chThousandSep = _T(','); 

// An array of boolean value to indicate whether the columns of the source and events list controls
// should be sorted in ascending or descending order.
BOOL g_abLcSourceSortAscending[ICOL_LcSource_MAX] = {TRUE, TRUE, TRUE, TRUE};        
BOOL g_abLcEventsSortAscending[ICOL_LcEvents_MAX] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\globals.h ===
#ifndef _globals_h

class CTrapReg;
extern CTrapReg g_reg;
extern TCHAR g_chThousandSep;  // The thousands separator character
extern BOOL g_abLcSourceSortAscending[];
extern BOOL g_abLcEventsSortAscending[];

#define MAX_STRING 1024
#define FILE_DEF_EXT    _T("*.*")

#endif //_globals_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\layout.h ===
//******************************************************************
// layout.h
//
// This file contains the declarations for the code hat lays out the 
// CTrapEventDialog. This is neccessary when the edit/view button changes the 
// dialog form its small (main) view to the extended view.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-96  Wrote it
//
//
// Copyright (C) 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#ifndef _layout_h
#define _layout_h

class CEventTrapDlg;
class CMainLayout;
class CExtendedLayout;

class CLayout
{
public:
    CLayout();
    void Initialize(CEventTrapDlg* pdlg);
	void LayoutAndRedraw(BOOL bExtendedView, int cx, int cy);
	void ShowExtendedView(BOOL bShow);
    void LayoutView(BOOL bExtendedView);

private:
    // Private member functions
	void ResizeMainLayout(CMainLayout& layoutMain);
	void ResizeExtendedLayout(CExtendedLayout& layoutExtended);

    // Private member data
    CEventTrapDlg* m_pdlg;
	CSize m_sizeMainViewInitial;
	CSize m_sizeExtendedViewInitial;
	int m_cyMainView;
	int m_cyExtendedView;
};

#endif //_layout_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\lcevents.h ===
#ifndef _lcevents_h
#define _lcevents_h

class CXEventLogArray;
class CXMessageArray;
class CXEventArray;
class CXEvent;
class CSource;
class CLcEvents;



/////////////////////////////////////////////////////////////////////////////
// CLcEvents window
class CEvent;
class CLcEvents : public CListCtrl
{
// Construction
public:
	CLcEvents();
	SCODE CreateWindowEpilogue();


// Attributes
public:

// Operations
public:
    LONG GetSize() {return GetItemCount(); }
    CXEvent* GetAt(LONG iEvent);
    void RemoveAll();
    void RemoveAt(int nIndex, int nCount = 1);
    void AddEvents(CSource& source, CXEventArray& aEvents);
    void AddEvents(CSource& source, CXEventLogArray& aEventLogs);
    void DeleteSelectedEvents(CSource& source);
    void DeleteAt(LONG iEvent);
    BOOL HasSelection() {return GetNextItem(-1, LVNI_SELECTED) != -1; }
    void GetSelectedEvents(CXEventArray& aEvents);
    void RefreshEvents(CXEventArray& aEvents);
    void SetItem(LONG nItem, CXEvent* pEvent);
    LONG FindEvent(CXEvent* pEvent);
    void SortItems(DWORD dwColumn);
    void SelectEvents(CXEventArray& aEvents);

//    BOOL GetItem(LV_ITEM* pItem) const;


// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLcEvents)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLcEvents();

	// Generated message map functions
protected:
	//{{AFX_MSG(CLcEvents)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
    void UpdateDescriptionWidth();
    LONG AddEvent(CXEvent* pEvent);
    void CreateEventsNotTrapped(CXMessageArray& amsg, CXEventArray& aevents);
	void SetColumnHeadings();
    DWORD m_dwSortColumn;
    LONG m_cxWidestMessage;

};

enum {ICOL_LcEvents_LOG = 0, 
	  ICOL_LcEvents_SOURCE,
	  ICOL_LcEvents_ID,
	  ICOL_LcEvents_SEVERITY,
      ICOL_LcEvents_COUNT,
      ICOL_LcEvents_TIME,
      ICOL_LcEvents_DESCRIPTION,
	  ICOL_LcEvents_MAX	  
	  };





#endif //_lcevents_h

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\lcevents.cpp ===
// lcevents.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "lcevents.h"
#include "settings.h"
#include "source.h"
#include "globals.h"
#include "utils.h"
#include "lcsource.h"
#include "busy.h"
#include "trapreg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif




/////////////////////////////////////////////////////////////////////////////
// CLcEvents

CLcEvents::CLcEvents()
{
    m_dwSortColumn = ICOL_LcEvents_LOG;
    m_cxWidestMessage = CX_DEFAULT_DESCRIPTION_WIDTH;
}

CLcEvents::~CLcEvents()
{
}


BEGIN_MESSAGE_MAP(CLcEvents, CListCtrl)
	//{{AFX_MSG_MAP(CLcEvents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


SCODE CLcEvents::CreateWindowEpilogue()
{
	ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT);
	SetColumnHeadings();
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CLcEvents message handlers





//***************************************************************************
//  CLcEvents::SelectEvents
//
//  Select the specified events in the list control.
//
//  Parameters:
//		CXEventArray& aEvents
//          An array of event pointers.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::SelectEvents(CXEventArray& aEventsSel)
{
    int iItemFirstSelection = -1;
    LONG nItems = GetSize();
    for (LONG iItem = 0; iItem < nItems; ++iItem) {
        CXEvent* pEventTrapping = GetAt(iItem);

        // If the event associated with this item is in aEvents, then select the item.
        // Otherwise clear selection on the item.
        BOOL bDidFindEvent = FALSE;
        LONG nEventsSel = aEventsSel.GetSize();
        for (LONG iEventSel = 0; iEventSel < nEventsSel; ++iEventSel) {
            CXEvent* pEventSel;
            pEventSel = aEventsSel[iEventSel];
            if ((pEventSel->m_message.m_dwId == pEventTrapping->m_message.m_dwId) &&
                (pEventSel->m_pEventSource == pEventTrapping->m_pEventSource) &&
                (pEventSel->m_pEventSource->m_pEventLog == pEventTrapping->m_pEventSource->m_pEventLog)) {

                bDidFindEvent = TRUE;
                if (iItemFirstSelection == -1) {
                    iItemFirstSelection = iItem;
                }
                break;
            }
        }

        SetItemState(iItem, bDidFindEvent ? LVIS_SELECTED : 0, LVIS_SELECTED);
    }

    // Scroll the first selected item into view.
    if (iItemFirstSelection > 0) {
        EnsureVisible(iItemFirstSelection, FALSE);
    }
}






//***************************************************************************
//
//  CLcEvents::SetColumnHeadings
//
//  Define's the columns for this list control.  The column title, width, and
//  order is defined here.
//
//  Parameters:
//		None.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::SetColumnHeadings()
{
 	static UINT auiResColumnTitle[ICOL_LcEvents_MAX] = {
        IDS_LcEvents_TITLE_LOG,
        IDS_LcEvents_TITLE_SOURCE,
		IDS_LcEvents_TITLE_ID,
		IDS_LcEvents_TITLE_SEVERITY,
        IDS_LcEvents_TITLE_COUNT,
        IDS_LcEvents_TITLE_TIME,
		IDS_LcEvents_TITLE_DESCRIPTION
	};

	static int aiColWidth[ICOL_LcEvents_MAX] = {75, 60, 60, 60, 50, 50, CX_DEFAULT_DESCRIPTION_WIDTH};


    // Build the columns in the AllEventsList control.
    LV_COLUMN lvcol;
    lvcol.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    for (int iCol=0; iCol<ICOL_LcEvents_MAX; ++iCol)
    {
		CString sColTitle;
		sColTitle.LoadString(auiResColumnTitle[iCol]);

        lvcol.pszText = sColTitle.GetBuffer(sColTitle.GetLength());
        lvcol.iSubItem = iCol;
        lvcol.cx = aiColWidth[iCol];
        InsertColumn(iCol, &lvcol);
		sColTitle.ReleaseBuffer();
    }
}



//********************************************************************
// CLcEvents::AddEvents
//
// Add all the events for all the event sources contained in the
// event-log array.   The source is notified that each of these
// events is being trapped.
//
// Parameters:
//      CSource& source
//          The message source container.
//
//      CEventLogArray& aEventLogs
//          An array of event-logs.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CLcEvents::AddEvents(CSource& source, CXEventLogArray& aEventLogs)
{
    // Iterate though all the event logs.
    LONG nLogs = aEventLogs.GetSize();
    for (LONG iLog=0; iLog < nLogs; ++iLog) {
        CXEventLog* pEventLog = aEventLogs[iLog];

        // Iterate through all the event sources within this event log
        LONG nSources = pEventLog->m_aEventSources.GetSize();
        for (LONG iSource = 0; iSource < nSources; ++iSource) {

            // Add all the events for the source to this list control.
            CXEventSource* pEventSource = pEventLog->m_aEventSources[iSource];
            AddEvents(source, pEventSource->m_aEvents);
        }
    }

	if (GetSize() > 0 && !HasSelection())
	{
		SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
	}
}





//***************************************************************************
//
//  CLcEvents::AddEvents
//
//  Add an array of events to this list control.  This involves the following
//      a. Add each event to the list control
//      b. Notify the CLcSource that the event has been modified so that it
//         can update the trapping flag.
//      c. Sort the events by the most recently selected column.
//      d. Make sure that the first item in CEventArray passed in is visible.
//
//  Parameters:
//      CSource& source
//          A reference to the CSource object.  This object must be notified
//          when the trapping status of an event changes.
//
//		CEventArray& aEvents
//          An array containing pointers to the events to add.  This list control
//          then becomes the owner of these events.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::AddEvents(CSource& source, CXEventArray& aEvents)
{
    CBusy busy;

    // Now add them into this list control.  This is where they actually
    LONG nEvents = aEvents.GetSize();
    LONG iEvent;

    // Unselect all the previous items first
    iEvent = -1;
    do
    {
        iEvent = GetNextItem(iEvent, LVNI_SELECTED);
        if (iEvent == -1)
            break;
        SetItemState(iEvent, ~LVIS_SELECTED, LVIS_SELECTED);
    } while (TRUE);

    for (iEvent = 0; iEvent < nEvents; ++iEvent) {
        if ((iEvent < 40 && (iEvent % 10 == 9)) ||
            (iEvent % 100 == 99)) {
            UpdateWindow();
        }

        CXEvent* pEvent = aEvents[iEvent];
        AddEvent(pEvent);
        source.NotifyTrappingChange(pEvent->m_pEventSource, pEvent->m_message.m_dwId, TRUE);
    }

    UpdateDescriptionWidth();

    // Sort the items by the most recently selected column, and then
    // make sure the first item is visible.
    SortItems(m_dwSortColumn);
    if (nEvents > 0) {
        iEvent = FindEvent(aEvents[0]);
        EnsureVisible(iEvent, TRUE);
    }
}


//***************************************************************************
//
//  CLcEvents::AddEvent
//
//  Add an event to the list control. This sets the text for each column in
//  the list view and sets the lParam field of the list-view item to pEvent
//
//
//  Parameters:
//		CEvent* pEvent
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
LONG CLcEvents::AddEvent(CXEvent* pEvent)
{
    // Insert a new item into this list control.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_TEXT | LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcEvents_LOG;
    lvitem.lParam = (LPARAM)pEvent;
    lvitem.cchTextMax = pEvent->m_message.m_sText.GetLength() + 1;
    lvitem.pszText = (LPTSTR)(void*)(LPCTSTR) (pEvent->m_message.m_sText);
    LONG nItem = CListCtrl::InsertItem(&lvitem);

    SetItem(nItem, pEvent);
    SetItemState(nItem, LVIS_SELECTED, LVIS_SELECTED);
    return nItem;
}



//********************************************************************
// CLcEvents::SetItem
//
// Refresh an item from an event.
//
// Parameters:
//      LONG nItem
//
//      CEvent* pEvent
//          Pointer to the event to copy the data from.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CLcEvents::SetItem(LONG nItem, CXEvent* pEvent)
{


    // Check the item index against the array bounds.
    if (nItem < 0 || nItem >= GetItemCount()) {
        ASSERT(FALSE);
        return;
    }

    ASSERT(GetItemData(nItem) == (DWORD) (void*) pEvent);

    // Get the pointer for brevity.
    CXEventSource* pEventSource = pEvent->m_pEventSource;
	CString sText;

    SetItemData(nItem, (DWORD_PTR) (void*) pEvent);

    SetItemText(nItem, ICOL_LcEvents_LOG, (LPTSTR) (LPCTSTR) pEventSource->m_pEventLog->m_sName);

	SetItemText(nItem, ICOL_LcEvents_SOURCE, (LPTSTR)(LPCTSTR) pEventSource->m_sName);

    pEvent->m_message.GetShortId(sText);
    SetItemText(nItem, ICOL_LcEvents_ID, (LPTSTR)(LPCTSTR)sText);

    pEvent->m_message.GetSeverity(sText);
    SetItemText(nItem, ICOL_LcEvents_SEVERITY, (LPTSTR)(LPCTSTR)sText);

    pEvent->GetCount(sText);
    SetItemText(nItem, ICOL_LcEvents_COUNT, (LPTSTR)(LPCTSTR)sText);

    pEvent->GetTimeInterval(sText);
    SetItemText(nItem, ICOL_LcEvents_TIME, (LPTSTR)(LPCTSTR)sText);

    SetItemText(nItem, ICOL_LcEvents_DESCRIPTION, (LPTSTR)(LPCTSTR)pEvent->m_message.m_sText);

}



//***************************************************************************
//
//  CLcEvents::DeleteSelectedEvents.
//
//  Delete all of the currently selected events and the corresponding items.
//
//  Parameters:
//      None.
//
//  Returns:
//      Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::DeleteSelectedEvents(CSource& source)
{

    // Delete all the selected items from the list control.
    // Build an array of event pointers corresponding to the events that are selected
    // in the list control.  Also notify the event source view that the event is no
    // longer being trapped.
   	while (TRUE) {
		int iItem = GetNextItem(-1, LVNI_SELECTED);
		if (iItem == -1) {
			break;
		}
        CXEvent* pEvent = GetAt(iItem);
        DeleteItem(iItem);
        source.NotifyTrappingChange(pEvent->m_pEventSource, pEvent->m_message.m_dwId, FALSE);
        delete pEvent;
	}
    UpdateDescriptionWidth();
}



//***************************************************************************
//
//  CLcEvents::GetAt
//
//  This method returns the event pointer located at the given item index.
//  This allows CLcEvents to be used much as an array.
//
//  Parameters:
//		LONG iItem
//			The item index.
//
//  Returns:
//		A pointer to the CEvent stored at the specified index.
//
//  Status:
//
//***************************************************************************
CXEvent* CLcEvents::GetAt(LONG iItem)
{

	// Setup the LV_ITEM structure to retrieve the lparam field.
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcEvents_LOG;	
    lvitem.iItem = iItem;
    GetItem(&lvitem);

	CXEvent* pEvent = (CXEvent*) (void*) lvitem.lParam;
	return pEvent;
}










//***************************************************************************
//
//  CLcEvents::GetSelectedEvents
//
//  Get the events corresponding to the selected items in this list control.
//  This list control continues to own the event pointers.
//
//  Parameters:
//		CEventArray& aEvents
//			A reference to the event array where the event pointers are returned.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::GetSelectedEvents(CXEventArray& aEvents)
{

	// Clear the message array
	aEvents.RemoveAll();

	// Setup the LV_ITEM structure to retrieve the lparam field.
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcEvents_LOG;

	// Loop to find all the selected items.	
	int nItem = -1;
	while (TRUE) {
		nItem = GetNextItem(nItem, LVNI_SELECTED);
		if (nItem == -1) {
			break;
		}

		// Get the CMessage pointer for this item and add it to the
		// array.
        lvitem.iItem = nItem;
        GetItem(&lvitem);
		CXEvent* pEvent = (CXEvent*) (void*) lvitem.lParam;
		aEvents.Add(pEvent);
	}
}



//***************************************************************************
//
//  CLcEvents::FindEvent
//
//  Find the specified event and return its item number.
//
//  Parameters:
//		CEvent* pEvent
//			A pointer to the event to search for.
//
//  Returns:
//		The item index if the item was found, otherwise -1.
//
//  Status:
//
//***************************************************************************
LONG CLcEvents::FindEvent(CXEvent* pEvent)
{

    LONG nEvents = GetItemCount();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEventTemp = GetAt(iEvent);
        if (pEventTemp == pEvent) {
            return iEvent;
        }
    }
    return -1;
}



//***************************************************************************
//
//  CLcEvents::RefreshEvents
//
//  This method is called when the properties of some number of events
//  have changed and the corresponding items in the list control need
//  to be updated.
//
//  Parameters:
//		CEventArray& aEvents
//			The events that need to be refreshed.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::RefreshEvents(CXEventArray& aEvents)
{
    // Iterate through each of the events and refresh them.
    LONG nEvents = aEvents.GetSize();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = aEvents[iEvent];
        LONG nEvent = FindEvent(pEvent);
        SetItem(nEvent, pEvent);
    }
}





int CALLBACK CompareEventsProc(LPARAM lParam1, LPARAM lParam2, LPARAM
   lParamSort)
{
    CXEvent* pEvent1 = (CXEvent *)lParam1;
    CXEventSource* pEventSource1 = pEvent1->m_pEventSource;

    CXEvent* pEvent2 = (CXEvent *)lParam2;
    CXEventSource* pEventSource2 = pEvent2->m_pEventSource;


    ASSERT((pEvent1 != NULL) && (pEvent2 != NULL));
    int nResult = 0;
    CString sText1, sText2;

    switch( lParamSort)
    {
    case ICOL_LcEvents_LOG:
        // Sort by log, then by source, then by ID
        nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
            if (nResult == 0) {
                 nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
            }
        }
        break;
    case ICOL_LcEvents_SOURCE:
        // Sort by source, then by Log, then by ID
        nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                 nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
            }
        }
        break;
    case ICOL_LcEvents_ID:
        // Sort by ID, then by log, then by source.
        nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
            }
        }
        break;
    case ICOL_LcEvents_SEVERITY:
        // Sort by severity, then by log, then by source, then by ID
        pEvent1->m_message.GetSeverity(sText1);
        pEvent2->m_message.GetSeverity(sText2);
        nResult = lstrcmp(sText1, sText2);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    case ICOL_LcEvents_COUNT:
        // Sort by count, then by log, then by source, then by ID
        pEvent1->GetCount(sText1);
        pEvent2->GetCount(sText2);
        nResult = lstrcmp(sText1, sText2);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    case ICOL_LcEvents_TIME:
        // Sort by time, then by log, then by source, then by ID
        pEvent1->GetTimeInterval(sText1);
        pEvent2->GetTimeInterval(sText2);
        nResult = lstrcmp(sText1, sText2);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    case ICOL_LcEvents_DESCRIPTION:
        // Sort by description, then by log, then by source, then by ID
        nResult = lstrcmp(pEvent1->m_message.m_sText, pEvent2->m_message.m_sText);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    default:
        ASSERT(FALSE);
        break;
    }


    if (!g_abLcEventsSortAscending[lParamSort]) {
        if (nResult > 0) {
            nResult = -1;
        }
        else if (nResult < 0) {
            nResult = 1;
        }
    }

    return nResult;
}


//***************************************************************************
//
//  CLcEvents::SortItems
//
//  Sort the items in this list control given the column index.  This method
//  hides all details about the sort implementation from this class's clients.
//
//  Parameters:
//		DWORD dwColumn
//			The column to use as the sort key.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::SortItems(DWORD dwColumn)
{
    CListCtrl::SortItems(CompareEventsProc, dwColumn);
    m_dwSortColumn = dwColumn;
}





//****************************************************************************
// CLcEvents::UpdateDescriptionWidth()
//
// Measure the message description string associated with each item and set the
// width of the description column to match the widest message length plus a
// little extra room for slop and appearances.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*****************************************************************************
void CLcEvents::UpdateDescriptionWidth()
{
    LONG cxWidestMessage = CX_DEFAULT_DESCRIPTION_WIDTH;
    LONG nEvents = GetItemCount();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = GetAt(iEvent);
        int cx = GetStringWidth(pEvent->m_message.m_sText);
        if (cx > cxWidestMessage) {
            cxWidestMessage = cx;
        }
    }


    // Set the column width to the width of the widest string plus a little extra
    // space for slop and to make it obvious to the user that the complete string
    // is displayed.
    SetColumnWidth(ICOL_LcEvents_DESCRIPTION, cxWidestMessage + CX_DESCRIPTION_SLOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\lcsource.cpp ===
#include "stdafx.h"
#include "source.h"
#include "lcsource.h"
#include "regkey.h"
#include "source.h"
#include "utils.h"
#include "globals.h"
#include "busy.h"
#include "trapreg.h"




/////////////////////////////////////////////////////////////////////////////
// CLcSource

CLcSource::CLcSource()
{
}

CLcSource::~CLcSource()
{
}




//***************************************************************************
//
//  CLcSource::AddMessage
//
//  Add a message to the list control. This sets the text for each column in
//  the list view and sets the lParam field of the list-view item to pMessage.
//  
//
//  Parameters:
//		CMessage* pMessage
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
void CLcSource::AddMessage(CXMessage* pMessage)
{
	CString sText;
    pMessage->GetShortId(sText);


    // Insert a new item into this list control.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_TEXT | LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcSource_EVENTID;
    lvitem.cchTextMax = MAX_STRING;
    lvitem.lParam = (LPARAM)pMessage;
    lvitem.pszText = (LPTSTR)(LPCTSTR)sText;
    int nItem = InsertItem(&lvitem);

    if (nItem >= 0)
    {
        CXEventSource* pEventSource = pMessage->m_pEventSource;

        // Now set the string value for each sub-item.
		pMessage->GetSeverity(sText); 
		SetItemText(nItem, ICOL_LcSource_SEVERITY, (LPTSTR)(LPCTSTR) sText);

		pMessage->IsTrapping(sText);
        SetItemText(nItem, ICOL_LcSource_TRAPPING, (LPTSTR)(LPCTSTR)sText);
        SetItemText(nItem, ICOL_LcSource_DESCRIPTION, (LPTSTR)(LPCTSTR) pMessage->m_sText);
    }
}


//*******************************************************************
// CXMessageArray::SetDescriptionWidth
//
// Set the width of the description field so that it is wide enough to
// hold the widest message.
//
// Parameters:
//      CXMessageArray& aMessages
//          The message array that will be used to fill the list control.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CLcSource::SetDescriptionWidth(CXMessageArray& aMessages)
{
    LONG cxWidestMessage = CX_DEFAULT_DESCRIPTION_WIDTH;
    LONG nMessages = aMessages.GetSize();
    for (LONG iMessage = 0; iMessage < nMessages; ++iMessage) {
        CXMessage* pMessage = aMessages[iMessage];
        int cx = GetStringWidth(pMessage->m_sText);
        if (cx > cxWidestMessage) {
            cxWidestMessage = cx;
        }
    }

    // Set the column width to the width of the widest string plus a little extra
    // space for slop and to make it obvious to the user that the complete string
    // is displayed.
    SetColumnWidth(ICOL_LcSource_DESCRIPTION, cxWidestMessage + CX_DESCRIPTION_SLOP);
}



//***************************************************************************
//
//  CLcSource::LoadMessages
//
//  Load the messages from the message library module and insert them into
//  this list control.
//
//  Parameters:
//		CMessage* pMessage
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
SCODE CLcSource::SetEventSource(CXEventSource* pEventSource)
{
    CBusy busy;

	DeleteAllItems();

    if (pEventSource == NULL) {
        return S_OK;
    }


    UpdateWindow();
    
    //!!!CR: Should do something with the return code in case the
    //!!!CR: messages weren't loaded.
    SCODE sc = pEventSource->LoadMessages();


	// Iterate through each of the messages and insert them into
	// the list control.
    CXMessageArray& aMessages = pEventSource->m_aMessages;

    // Set the width of the description field so that it is wide enough to contain
    // the widest message.
    SetDescriptionWidth(aMessages);

	LONG nMessages = aMessages.GetSize();
	for (LONG iMessage=0; iMessage < nMessages; ++iMessage) {
        if ((iMessage < 40 && (iMessage % 10 == 9)) ||
            (iMessage % 100 == 99)) {
            // Update the window often for the first few messages and less frequently
            // thereafter for a good response time.
            UpdateWindow();
        }

		AddMessage(aMessages[iMessage]);
	}


    SortItems(ICOL_LcSource_EVENTID);
    SetRedraw(TRUE);
    UpdateWindow();
    EnsureVisible(0, FALSE);

	if (GetSize())
		SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

	return S_OK;
}



BEGIN_MESSAGE_MAP(CLcSource, CListCtrl)
	//{{AFX_MSG_MAP(CLcSource)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLcSource message handlers



//***************************************************************************
//
//  CLcSource::CreateWindowEpilogue()
//
//  This method is called after a window has been created for this list
//  control.  Final initialization is done here.
//
//  Parameters:
//		None.
//
//  Returns:
//		SCODE
//			S_OK if the initialization was successful, otherwise E_FAIL.
//
//  Status:
//      
//***************************************************************************
SCODE CLcSource::CreateWindowEpilogue()
{
	ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT);
	SetColumnHeadings();
	return S_OK;
}

//***************************************************************************
//
//  CLcSource::SetColumnHeadings
//
//  Define's the columns for this list control.  The column title, width, and
//  order is defined here.
//
//  Parameters:
//		None.
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
void CLcSource::SetColumnHeadings()
{
 	static UINT auiResColumnTitle[ICOL_LcSource_MAX] = {
		IDS_LcSource_TITLE_EVENT_ID,
		IDS_LcSource_TITLE_SEVERITY,
		IDS_LcSource_TITLE_TRAPPING,
		IDS_LcSource_TITLE_DESCRIPTION
	};

	static int aiColWidth[ICOL_LcSource_MAX] = {60, 75, 60, CX_DEFAULT_DESCRIPTION_WIDTH};

 
    // Build the columns in the AllEventsList control.
    LV_COLUMN lvcol; 
    lvcol.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    
    for (int iCol=0; iCol<ICOL_LcSource_MAX; ++iCol)
    {
		CString sColTitle;
		sColTitle.LoadString(auiResColumnTitle[iCol]);

        lvcol.pszText = sColTitle.GetBuffer(sColTitle.GetLength());
        lvcol.iSubItem = iCol;
        lvcol.cx = aiColWidth[iCol];
        InsertColumn(iCol, &lvcol);
		sColTitle.ReleaseBuffer();
    }
}




//******************************************************************
// CLcSource::Find
//
// Find the specified event source in this list control.
//
// Parameters:
//		CString& sText
//			A string containing the text to search for.
//
//		BOOL bWholeWord
//			TRUE if this is a "whole word" search.  False if it
//			is OK to match a partial word.
//
//		BOOL bMatchCase
//			TRUE if a case-sensitive comparison should be used.
//
// Returns:
//		BOOL
//			TRUE if the string was found, FALSE otherwise.  If the specified
//			text is found, then the selection is set on the corresponding
//			list control item, the item is scrolled into view and the focus
//			is set on the item.
//
//******************************************************************
BOOL CLcSource::Find(CString sText, BOOL bWholeWord, BOOL bMatchCase)
{
    // Don't do anything if the list is empty.
	if (GetSize() == 0) 
		return FALSE;

	if (!bMatchCase) 
		sText.MakeUpper();

    // Get the selected item.
    LONG iItem = GetNextItem(-1, LVNI_SELECTED);    

    // Nothing selected; start from the top of the list.
    if (iItem == -1)
        iItem = 0;


    // Iterate through all of the items starting at one item past
    // the currently selected item. 
	CXMessage* pMessage;
	CString sDescription;
    BOOL bFound = FALSE;
	LONG nItems = GetSize();
    LONG iItemStart = iItem;
	for (long i=0; !bFound && i<nItems; ++i) {
        // Bump the item index to the next one and wrap it if its past the
        // last item.
		iItem = (iItem + 1) % nItems;

        // Get the message description for this item.
		pMessage = GetAt(iItem);
        sDescription = pMessage->m_sText;

		if (!bMatchCase) 
			sDescription.MakeUpper();
        
        if (bWholeWord)	{
            // Compare the whole word.
			bFound = (FindWholeWord(sText, sDescription) != -1);
        }
        else {
	        // Look for a substring.
            if (sDescription.Find(sText) >= 0)  
                bFound = TRUE;
        } 
    }

    // Found a match.
    if (bFound)
    {
        // Unselect the selected item and select the found item.        
        SetItemState(iItemStart, 0, LVIS_SELECTED | LVIS_FOCUSED);
        SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        EnsureVisible(iItem, FALSE);
        return TRUE;
    }

    return FALSE;
}






//***************************************************************************
//
//  fnCompareCLcSource
//
//  This the item comparison callback method that is called from CLcSource::SortItems. 
//
//  Parameters:
//		LPARAM lParam1
//			This is the lparam for the first item to compare.  This is a pointer to 
//			the associated CMessage object.
//
//		LPARAM lParam2
//			This is the lparam for the second item to compare.  This is a pointer to 
//			the associated CMessage object.
//
//		LPARAM lColumn
//			This is the second parameter that was passed to CListCtrl::SortItems.  This 
//			happens to be the list control column index.
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
int CALLBACK fnCompareCLcSource(LPARAM lParam1, LPARAM lParam2, LPARAM lColumn)
{
    // !!!CR: The LPARAM parameters are not event pointers in all cases because
    // !!!CR: each subitem has its own LPARAM. What should I do?

    CXMessage *pmsg1 = (CXMessage *)lParam1;
    CXMessage *pmsg2 = (CXMessage *)lParam2;

    int nResult = 0;
    CString s1, s2;

    if (pmsg1 && pmsg2)
    {
        switch( lColumn)
        {
        case ICOL_LcSource_EVENTID:
        	nResult = ((LONG) pmsg1->GetShortId()) - ((LONG)pmsg2->GetShortId());			
        	break;
        case ICOL_LcSource_SEVERITY:
         	pmsg1->GetSeverity(s1);
        	pmsg2->GetSeverity(s2);
        	nResult = lstrcmpi(s1, s2);
        	break;
        case ICOL_LcSource_TRAPPING:
        	pmsg1->IsTrapping(s1);
        	pmsg2->IsTrapping(s2);
        	nResult = lstrcmpi(s1, s2);
        	break;
        case ICOL_LcSource_DESCRIPTION:
            nResult = lstrcmpi(pmsg1->m_sText, pmsg2->m_sText);
        	break;
        default:
         	ASSERT(FALSE);
            nResult = 0;
            break;
        }
    }

    if (!g_abLcSourceSortAscending[lColumn]) {
        if (nResult > 0) {
            nResult = -1;
        }
        else if (nResult < 0) {
            nResult = 1;
        }
    }

    return(nResult);
}


//***************************************************************************
//
//  CLcSource::SortItems
//
//  Sort the items in this list control given the column index.  This method
//  hides all details about the sort implementation from this class's clients.
//
//  Parameters:
//		DWORD dwColumn
//			The column to use as the sort key.  
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
void CLcSource::SortItems(DWORD dwColumn)
{
    CListCtrl::SortItems(fnCompareCLcSource, dwColumn);
}




//***************************************************************************
//
//  CLcSource::GetSelectedMessages
//
//  Fill a message array with pointers to the messages that correspond to
//  the selected items in this list control.  
//
//  Note: This list control continues to own the returned pointers.  The
//  caller should not delete them.
//
//  Parameters:
//		CMessageArray& amsg
//			The message array where the pointers to the selected messages are
//			returned.
//
//  Returns:
//		The message array is filled with pointers to the selected messages.  Do
//		not delete them, because they are owned by this object.
//
//  Status:
//      
//***************************************************************************
void CLcSource::GetSelectedMessages(CXMessageArray& amsg)
{
	// Clear the message array
	amsg.RemoveAll();

	// Setup the LV_ITEM structure to retrieve the lparam field.  
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcSource_EVENTID;

	// Loop to find all the selected items.	
	int nItem = -1;
	while (TRUE) {
		nItem = GetNextItem(nItem, LVNI_SELECTED);
		if (nItem == -1) {
			break;
		}

		// Get the CMessage pointer for this item and add it to the
		// array.
        lvitem.iItem = nItem;
        GetItem(&lvitem);
		CXMessage* pmsg = (CXMessage*) (void*) lvitem.lParam;
		amsg.Add(pmsg);
	}
}




//***************************************************************************
//
//  CLcSource::FindItem
//
//  Search through this list-controls's items to find the one with the
//  specified message ID.  
//
//  Parameters:
//		DWORD dwMessageId
//			The message ID to search for.
//
//  Returns:
//		The index of the item with the specified message ID.  If no such message ID
//		was found, -1 is returned.
//
//  Status:
//      
//***************************************************************************
LONG CLcSource::FindItem(DWORD dwMessageId)
{
	LONG nItems = GetItemCount();
	for (LONG iItem = 0; iItem < nItems; ++iItem) {
        CXMessage* pMessage = GetAt(iItem);
        if (pMessage->m_dwId == dwMessageId) {
            return iItem;
        }
	}
	return -1;
}




//***************************************************************************
//
//  CLcSource::RefreshItem
//
//  This method is called when some aspect of the message has changed and
//  the display needs to be updated.  This occurs when the trapping status
//  of an event changes.  
//
//  Parameters:
//		DWORD dwMessageId
//			The message ID to search for.
//
//  Returns:
//		The index of the item with the specified message ID.  If no such message ID
//		was found, -1 is returned.
//
//  Status:
//      
//***************************************************************************
void CLcSource::RefreshItem(LONG iItem)
{
	CXMessage* pMessage = GetAt(iItem);
    CString sText;

	// Now set the text value for each column in the list control.
    pMessage->GetSeverity(sText);
	SetItemText(iItem, ICOL_LcSource_SEVERITY, (LPTSTR)(LPCTSTR) sText);

    // Check if we are trapping this event.
	pMessage->IsTrapping(sText);
    SetItemText(iItem, ICOL_LcSource_TRAPPING, (LPTSTR)(LPCTSTR)sText);

    SetItemText(iItem, ICOL_LcSource_DESCRIPTION, (LPTSTR)(LPCTSTR)pMessage->m_sText);
}



//***************************************************************************
//
//  CLcSource::GetAt
//
//  This method returns the message pointer located at the given item index.
//  This allows CLcSource to be used much as an array.  
//
//  Parameters:
//		LONG iItem
//			The item index.
//
//  Returns:
//		A pointer to the CMessage stored at the specified index.
//
//  Status:
//      
//***************************************************************************
CXMessage* CLcSource::GetAt(LONG iItem) 
{
	// Setup the LV_ITEM structure to retrieve the lparam field.  
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcSource_EVENTID;	
    lvitem.iItem = iItem;
    GetItem(&lvitem);

	CXMessage* pMessage = (CXMessage*) (void*) lvitem.lParam;
	return pMessage;
}



//***************************************************************************
// CLcSource::NotifyTrappingChange
//
// This method is called when a message's trapping status changes.  A message
// is considered trapped if it appears in the CLcEvents listbox.
//
// Parameters:
//      DWORD dwMessageId
//          The ID of the message who's trapping status is changing.
//
//      BOOL bIsTrapping
//          TRUE if the message is being trapped, FALSE otherwise.
//
// Returns:
//      Nothing.     
//      
//***************************************************************************
void CLcSource::NotifyTrappingChange(DWORD dwMessageId, BOOL bIsTrapping)
{
    LONG iItem = FindItem(dwMessageId);
    ASSERT(iItem != -1);

    if (iItem != -1) {
        CString sTrapping;
    	sTrapping.LoadString(bIsTrapping ? IDS_IS_TRAPPING : IDS_NOT_TRAPPING);
        SetItemText(iItem, ICOL_LcSource_TRAPPING, (LPTSTR)(LPCTSTR)sTrapping);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\layout.cpp ===
//******************************************************************
// layout.cpp
//
// This file contains the code that lays out the CTrapEventDialog.
// This is neccessary when the edit/view button changes the 
// dialog form its small (main) view to the extended view.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-96  Wrote it
//
//
// Copyright (C) 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#include "stdafx.h"
#include "layout.h"
#include "trapdlg.h"
#include "trapreg.h"
#include "globals.h"



#define CX_MARGIN 10
#define CY_MARGIN 10
#define CY_LEADING 3
#define CY_DIALOG_FONT 8


class CDlgMetrics
{
public: 
	CDlgMetrics(CEventTrapDlg* pdlg);
	CSize m_sizeMargin;
	CSize m_sizeAddButton;
	CSize m_sizeRemoveButton;
	CSize m_sizeFindButton;
	CSize m_sizeOKButton;
	int m_cyLeading;
    CSize m_sizeLabel0;
	CSize m_sizeLabel1;
	CSize m_sizeLabel2;

    CSize m_sizeConfigTypeBox;
    CSize m_sizeConfigCustomButton;
    CSize m_sizeConfigDefaultButton;
};
		

//*****************************************************************
// CDlgMetrics::CDlgMetrics
//
// Construct an object containing the metrics for the CEventTrapDlg
//
// Parameters:
// 		CEventTrapDlg* pdlg
//			Pointer to an instance of the main event trap dialog.
//			This pointer is used to access members, such as buttons
//			and so on so that they can be measured.
//
// Returns:
//		The members of this class are valid on return.
//
//*****************************************************************
CDlgMetrics::CDlgMetrics(CEventTrapDlg* pdlg)
{
	m_sizeMargin.cx = CX_MARGIN;
	m_sizeMargin.cy = CY_MARGIN;
	m_cyLeading = CY_LEADING;

	CRect rc;

	pdlg->m_btnAdd.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeAddButton = rc.Size();

	pdlg->m_btnFind.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeFindButton = rc.Size();

	pdlg->m_btnRemove.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeRemoveButton = rc.Size();

	pdlg->m_statLabel0.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeLabel0 = rc.Size();

    pdlg->m_statLabel1.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeLabel1 = rc.Size();

	pdlg->m_statLabel2.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeLabel2 = rc.Size();

	pdlg->m_btnOK.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeOKButton = rc.Size();


    if (g_reg.m_bShowConfigTypeBox) {
    	pdlg->m_btnConfigTypeBox.GetWindowRect(&rc);
    	pdlg->ScreenToClient(&rc);
    	m_sizeConfigTypeBox = rc.Size();

    	pdlg->m_btnConfigTypeCustom.GetWindowRect(&rc);
    	pdlg->ScreenToClient(&rc);
    	m_sizeConfigCustomButton = rc.Size();

    	pdlg->m_btnConfigTypeDefault.GetWindowRect(&rc);
    	pdlg->ScreenToClient(&rc);
    	m_sizeConfigDefaultButton = rc.Size();
    }
    else {
        // If the "Configuration type box will not be shown, then the size of the
        // box and the radio buttons in it are all zero.
    	pdlg->m_btnConfigTypeBox.GetWindowRect(&rc);
        m_sizeConfigTypeBox.cx = 0;
        m_sizeConfigTypeBox.cy = 0;

        m_sizeConfigCustomButton.cx = 0;
        m_sizeConfigCustomButton.cy = 0;

        m_sizeConfigDefaultButton.cx = 0;
        m_sizeConfigDefaultButton.cy = 0;
    }
}







//////////////////////////////////////////////////////////////////////
// CLASS: CMainLayout
//
// This class computes the position of various items for the main (small)
// view of the dialog.  The metrics for each of these items is made
// available through public data members.
/////////////////////////////////////////////////////////////////////
class CMainLayout
{
public:
	void Create(CDlgMetrics& metrics, CRect& rc);
	CRect m_rc;
    CRect m_rcLabel0;
	CRect m_rcOKButton;
	CRect m_rcCancelButton;
    CRect m_rcApplyButton;
	CRect m_rcPropertiesButton;
	CRect m_rcSettingsButton;
    CRect m_rcExportButton;
	CRect m_rcViewButton;
	CRect m_rcListView;

    CRect m_rcConfigTypeBox;
    CRect m_rcConfigCustomButton;
    CRect m_rcConfigDefaultButton;
};

//*****************************************************************
// CMainLayout::Create
//
// Construct the layout for the main part of the dialog.  This is
// the part where the add event stuff is hidden. 
//
// Note: The caller is responsible for making sure that the 
// specified rectangle is large enough so that the display 
// still looks good.  For example, it doesn't make sense to shrink
// the listview to a zero size or even negative size.
//
// Parameters:
// 		CDlgMetrics& metrics
//			The dialog metrics containing the size of the things
//			that appear on the dialog and so on.
//
//		CRect& rc
//			The rectangle where the main part of the dialog will be
//			drawn.
//
// Returns:
//		The members of this class are valid on return.
//
//*****************************************************************
void CMainLayout::Create(CDlgMetrics& metrics, CRect& rc)
{
	m_rc = rc;

	// The rectangle for this layout may actually extend beyond the size
	// of the dialog window.  This can occur when the user shrinks the dialog
	// to a size smaller than the minimum for this layout.  
	//
	// Things that are drawn outside of the dialog are clipped.
	//

    // Set the rectangle for the "Configuration Type" groupbox
    m_rcConfigTypeBox.left = rc.left + metrics.m_sizeMargin.cx;
    m_rcConfigTypeBox.top = rc.top + metrics.m_sizeMargin.cy;
    m_rcConfigTypeBox.right = rc.right -  (metrics.m_sizeOKButton.cx + 2 * metrics.m_sizeMargin.cx);
    m_rcConfigTypeBox.bottom = m_rcConfigTypeBox.top + metrics.m_sizeConfigTypeBox.cy;

    // Set the rectangle for the "Custom" radio button within the "Configuration Type" groupbox
    // We place it right in the middle between the top and the bottom of the groupbox.
    m_rcConfigCustomButton.left = m_rcConfigTypeBox.left + metrics.m_sizeMargin.cx;
    m_rcConfigCustomButton.top = m_rcConfigTypeBox.top  + 
                        (metrics.m_sizeConfigTypeBox.cy/2 - metrics.m_sizeConfigCustomButton.cy/2) + CY_DIALOG_FONT/2;
    m_rcConfigCustomButton.right = m_rcConfigCustomButton.left + metrics.m_sizeConfigCustomButton.cx;
    m_rcConfigCustomButton.bottom = m_rcConfigCustomButton.top + metrics.m_sizeConfigCustomButton.cy;

    // Set the rectangle for the "Default" radio button within the "Configuration Type" groupbox
    m_rcConfigDefaultButton.left = m_rcConfigCustomButton.right + metrics.m_sizeMargin.cx;
    m_rcConfigDefaultButton.top = m_rcConfigCustomButton.top;
    m_rcConfigDefaultButton.right = m_rcConfigDefaultButton.left + metrics.m_sizeConfigDefaultButton.cx;
    m_rcConfigDefaultButton.bottom = m_rcConfigCustomButton.bottom;


    m_rcLabel0.left = m_rcConfigTypeBox.left;
    m_rcLabel0.top = m_rcConfigTypeBox.bottom;
    if (metrics.m_sizeConfigTypeBox.cy != 0) {
        // If the configuration type groupbox is present, then the event list
        // should be placed one margin height below it.
    	m_rcLabel0.top += metrics.m_sizeMargin.cy;
    }
    m_rcLabel0.right = m_rcLabel0.left + metrics.m_sizeLabel0.cx;
    m_rcLabel0.bottom = m_rcLabel0.top + metrics.m_sizeLabel0.cy;

	// Set the position of the top events listview.
	m_rcListView.left = m_rcConfigTypeBox.left;
  	m_rcListView.top = m_rcLabel0.bottom + metrics.m_sizeMargin.cy;
	m_rcListView.right = m_rcConfigTypeBox.right;
	m_rcListView.bottom = rc.bottom - metrics.m_sizeMargin.cy;

	// Set the position of the OK button
	m_rcOKButton.left = m_rcListView.right + metrics.m_sizeMargin.cx;
	m_rcOKButton.top = m_rcConfigTypeBox.top;
    if (metrics.m_sizeConfigTypeBox.cy != 0) {
        // If the configuration type groupbox is present, then the OK button should be
        // moved down by half the dialog font height so that it lines up with the
        // top of the groupbox's rectangle instead of the top of the group box's title.
        m_rcOKButton.top += CY_DIALOG_FONT / 2;
    }
	m_rcOKButton.right = m_rcOKButton.left + metrics.m_sizeOKButton.cx;
	m_rcOKButton.bottom = m_rcOKButton.top + metrics.m_sizeOKButton.cy;

	// Compute the vertical distance between buttons.
	int cyDelta = m_rcOKButton.Height() + metrics.m_sizeMargin.cy / 2;
	
	// Set the position of the Cancel button
	m_rcCancelButton = m_rcOKButton;
	m_rcCancelButton.OffsetRect(0, cyDelta);

    // Set the position of the Apply button
    m_rcApplyButton = m_rcCancelButton;
    m_rcApplyButton.OffsetRect(0, cyDelta);

	// Set the position of the settings button	
    m_rcSettingsButton = m_rcApplyButton;
	m_rcSettingsButton.OffsetRect(0, cyDelta);

	// Set the position of the properties button
	m_rcPropertiesButton = m_rcSettingsButton;
	m_rcPropertiesButton.OffsetRect(0, cyDelta);

	// Set the position of the export button	
	m_rcExportButton = m_rcPropertiesButton;
	m_rcExportButton.OffsetRect(0, cyDelta);

	// Set the position of the view button
	m_rcViewButton = m_rcExportButton;
	m_rcViewButton.OffsetRect(0, cyDelta);
}

	

//////////////////////////////////////////////////////////////////////
// CLASS: CExtendedLayout
//
// This class computes the position of various items for the extended
// view of the dialog.  The metrics for each of these items is made
// available through public data members.
/////////////////////////////////////////////////////////////////////
class CExtendedLayout
{
public:
	void Create(CDlgMetrics& metrics, CRect& rc);
	CRect m_rc;
	CRect m_rcTreeView;
	CRect m_rcListView;
	CRect m_rcFindButton;
	CRect m_rcAddButton;
	CRect m_rcRemoveButton;
	CRect m_rcLabel1;
	CRect m_rcLabel2;
private:
};



//*****************************************************************
// CExtendedLayout::Create
//
// Construct the layout for the extended part of the dialog.  This is
// the part where the add event stuff is shown.
//
// Note: The caller is responsible for making sure that the 
// specified rectangle is large enough so that the display 
// still looks good.  For example, it doesn't make sense to shrink
// the listview to a zero size or even negative size.
//
// Parameters:
// 		CDlgMetrics& metrics
//			The dialog metrics containing the size of the things
//			that appear on the dialog and so on.
//
//		CRect& rc
//			The rectangle where the main part of the dialog will be
//			drawn.
//
// Returns:
//		The members of this class are valid on return.
//
//*****************************************************************
void CExtendedLayout::Create(CDlgMetrics& metrics, CRect& rc)
{
	m_rc = rc;

	CRect rcTemp;
	// Calculate the combined width of the treeview and listview.
	// We subtract 3 * CX_MARGIN because there is a margin on 
	// the left and right and another margin to separate the right
	// side of the list view from the button.
	int cxViews = rc.Width() - (2*metrics.m_sizeMargin.cx);
	int cxTreeView = cxViews * 2 / 5;
	int cxListView = cxViews - cxTreeView;


	// Set the location of the add button.  This should be aligned with
	// the left side of the listview and one margin height below the
	// top of the given rectangle.
	m_rcAddButton.left = m_rc.left + metrics.m_sizeMargin.cx/2 + cxTreeView - metrics.m_sizeAddButton.cx;
	m_rcAddButton.top = m_rc.top + metrics.m_cyLeading;
	m_rcAddButton.right = m_rcAddButton.left + metrics.m_sizeAddButton.cx;
	m_rcAddButton.bottom = m_rcAddButton.top + metrics.m_sizeAddButton.cy;

	// Set the location of the remove button.  This should be aligned with the
	// top of the "Add" button and one margin size to the right of the add button.
	m_rcRemoveButton.left = m_rcAddButton.right + metrics.m_sizeMargin.cx;
	m_rcRemoveButton.top = m_rcAddButton.top;
	m_rcRemoveButton.right = m_rcRemoveButton.left + metrics.m_sizeRemoveButton.cx;
	m_rcRemoveButton.bottom = m_rcRemoveButton.top + metrics.m_sizeRemoveButton.cy;


	// Set the location of label1.  This is the label at the top-left
	// of the tree control
	m_rcLabel1.left = m_rc.left + metrics.m_sizeMargin.cx;
	m_rcLabel1.top = m_rcRemoveButton.bottom + metrics.m_cyLeading +  metrics.m_sizeMargin.cy;
	m_rcLabel1.right = m_rcLabel1.left + metrics.m_sizeLabel1.cx; 
	m_rcLabel1.bottom = m_rcLabel1.top + metrics.m_sizeLabel1.cy;


	// Set the location of label2.  This is at the top-left of the list box.
	m_rcLabel2.left = m_rcLabel1.left + cxTreeView;
	m_rcLabel2.top = m_rcLabel1.top;
	m_rcLabel2.right = m_rcLabel2.left + metrics.m_sizeLabel2.cx;
	m_rcLabel2.bottom = m_rcLabel2.top + metrics.m_sizeLabel2.cy;
	
	// Set the location of the tree view.  This is one margin size from
	// the left of m_rc and one margin size below the labels.  The width 
	// has been calulated above.  There is also a margin reserved on the
	// bottom.
	m_rcTreeView.left = m_rc.left + metrics.m_sizeMargin.cx;
	m_rcTreeView.top = m_rcLabel2.bottom + 1; // + metrics.m_sizeMargin.cy;
	m_rcTreeView.right = m_rcTreeView.left + cxTreeView;
	m_rcTreeView.bottom = m_rc.bottom - metrics.m_sizeMargin.cy;
	
	
	// Set the location of the list view.  This is the same height as the
	// tree view and aligned so that its left side is adjacent to the
	// right side of the treeview.  Its width has been calculated above.
	m_rcListView.left = m_rcTreeView.right - 1;
	m_rcListView.top = m_rcTreeView.top;
	m_rcListView.right = m_rcListView.left + cxListView;
	m_rcListView.bottom = m_rcTreeView.bottom;
		

	// Set the location of the find button so that it is aligned with the top of the
	// list view and so that its right side is one margin widh from m_rc.right.
	m_rcFindButton.left = m_rc.right - metrics.m_sizeFindButton.cx - metrics.m_sizeMargin.cx;
	m_rcFindButton.top = m_rcAddButton.top;
	m_rcFindButton.right = m_rcFindButton.left + metrics.m_sizeFindButton.cx;
	m_rcFindButton.bottom = m_rcFindButton.top + metrics.m_sizeFindButton.cy;
}


//************************************************************************
// CLayout::CLayout
//
// Constructor for CLayout. This class is used to layout the items on
// the CEventTrapDialog when it is changed from the large extended view to
// the small main view.  This class also handles resizing the CEventTrapDialog.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//************************************************************************
CLayout::CLayout()
{
    m_pdlg = NULL;
}


//************************************************************************
// CLayout::Initialize
//
// Take a snapshot of various initial attributes of the dialog and its
// items. These attributes are used later to constrain the size of the
// dialog and so on.  
//
// This makes it possible to set certain characteristics of the dialog
// in the resource editor so that they do not need to be hard-coded here.
//
// Parameters:
//      CEventTrapDlg* pdlg
//          Pointer to the dialog that needs to be laid out, resized
//          and so on.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CLayout::Initialize(CEventTrapDlg* pdlg)
{
    ASSERT(m_pdlg == NULL);
    m_pdlg = pdlg;

    // Dialog layout stuff
	CRect rcWindow;
	pdlg->GetWindowRect(&rcWindow);

	CRect rcClient;
	pdlg->GetClientRect(&rcClient);


	CRect rcEventList;	
	pdlg->m_lcEvents.GetWindowRect(&rcEventList);
	pdlg->ScreenToClient(&rcEventList);
	

	m_sizeMainViewInitial.cx = rcClient.right;
	m_sizeMainViewInitial.cy = 	rcEventList.bottom + CY_MARGIN;


	m_sizeExtendedViewInitial.cx = rcClient.right;
	m_sizeExtendedViewInitial.cy = rcClient.bottom;

	m_cyMainView = 0;
	m_cyExtendedView = 0;
}


//*************************************************************************
// CLayout::ResizeMainLayout
//
// This method resizes and repositions the dialog components that appear
// int the small dialog layout.
//
// Parameters:
//      CMainLayout& layoutMain
//          The layout information for the small (main) layout.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CLayout::ResizeMainLayout(CMainLayout& layoutMain)
{
	m_pdlg->m_btnConfigTypeBox.MoveWindow(&layoutMain.m_rcConfigTypeBox, TRUE);
	m_pdlg->m_btnConfigTypeCustom.MoveWindow(&layoutMain.m_rcConfigCustomButton, TRUE);
	m_pdlg->m_btnConfigTypeDefault.MoveWindow(&layoutMain.m_rcConfigDefaultButton, TRUE);
    
	m_pdlg->m_btnOK.MoveWindow(&layoutMain.m_rcOKButton, TRUE);
	m_pdlg->m_btnCancel.MoveWindow(&layoutMain.m_rcCancelButton, TRUE);
    m_pdlg->m_btnApply.MoveWindow(&layoutMain.m_rcApplyButton, TRUE);
	m_pdlg->m_btnProps.MoveWindow(&layoutMain.m_rcPropertiesButton, TRUE);
	m_pdlg->m_btnSettings.MoveWindow(&layoutMain.m_rcSettingsButton, TRUE);
	m_pdlg->m_btnExport.MoveWindow(&layoutMain.m_rcExportButton, TRUE);
	m_pdlg->m_btnView.MoveWindow(&layoutMain.m_rcViewButton, TRUE);
	m_pdlg->m_lcEvents.MoveWindow(&layoutMain.m_rcListView, TRUE);
}



//*************************************************************************
// CLayout::ResizeExtendedLayout
//
// This method resizes and repositions the dialog components that appear
// int the large (extended) dialog layout.
//
// Parameters:
//      CExtendedLayout& layoutExtended
//          The layout information for the large (extended) layout.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CLayout::ResizeExtendedLayout(CExtendedLayout& layoutExtended)
{
	m_pdlg->m_btnAdd.MoveWindow(&layoutExtended.m_rcAddButton, TRUE);
	m_pdlg->m_btnRemove.MoveWindow(&layoutExtended.m_rcRemoveButton, TRUE);
	m_pdlg->m_btnFind.MoveWindow(&layoutExtended.m_rcFindButton, TRUE);
	m_pdlg->m_statLabel1.MoveWindow(&layoutExtended.m_rcLabel1, TRUE);
	m_pdlg->m_statLabel2.MoveWindow(&layoutExtended.m_rcLabel2, TRUE);
	m_pdlg->m_tcSource.MoveWindow(&layoutExtended.m_rcTreeView, TRUE);
	m_pdlg->m_lcSource.MoveWindow(&layoutExtended.m_rcListView, TRUE);
}




//*************************************************************************
// CLayout::LayoutAndRedraw
//
// This lays out the size and position of each component on the dialog and
// then redraws the dialog according to the new layout.
//
// Parameters:
//      BOOL bExtendedView
//          TRUE if the layout should be for the large (extended) view of
//          the dialog, FALSE if the layout should be for the small (main)
//          view of the dialog.
//
//      int cx
//          The desired width of the dialog in screen units.
//
//      int cy
//          The desired height of the dialog in screen units.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CLayout::LayoutAndRedraw(BOOL bExtendedView, int cx, int cy)
{	
	// If the user sizes the window smaller than its original size, then
	// the window will begin to obscure what is already there rather than
	// try to make things smaller.  This avoids the problems that would 
	// occur if buttons and other controls overlapped each other.
	BOOL bLayoutWidth = TRUE;
	BOOL bLayoutHeight = TRUE;

	if (bExtendedView) {
        // Limit the minimum size of the extended view
		if (cx < m_sizeExtendedViewInitial.cx) {
			cx = m_sizeExtendedViewInitial.cx;
			bLayoutWidth = FALSE;
		}

		if (cy < m_sizeExtendedViewInitial.cy) {
			cy = m_sizeExtendedViewInitial.cy;
			bLayoutHeight = FALSE;
		}
		m_cyExtendedView = cy;
	}
	else {
        // Limit the minimum size for the small (main) view
		if (cx < m_sizeMainViewInitial.cx) {
			cx = m_sizeMainViewInitial.cx;
			bLayoutWidth = FALSE;
		}

		if (cy < m_sizeMainViewInitial.cy) {
			cy = m_sizeMainViewInitial.cy;
			bLayoutHeight = FALSE;
		}
		m_cyMainView = cy;
	}



	CDlgMetrics metrics(m_pdlg);
	CMainLayout layoutMain;
	CExtendedLayout layoutExtended;
	CRect rcMain;
	CRect rcExtended;

	int cyMain = cy;
	if (bExtendedView) {
        // For the extended view, half the space if given to the components that
        // appear on the small (main) layout, and the extended components get 
        // half the space.  Thus, the dialog is split horizontally at the half-way
        // point for the extended view.
		cyMain = cy / 2;
		rcMain.SetRect(0, 0, cx, cy / 2);
		layoutMain.Create(metrics, rcMain);
		ResizeMainLayout(layoutMain);

        // The extended component rectangle's top is at the half-way point. The bottom
        // is at the bottom of the dialog.
		rcExtended.SetRect(0, cy / 2, cx, cy);
		layoutExtended.Create(metrics, rcExtended);
		ResizeExtendedLayout(layoutExtended);
	}
	else {
        // For the small (main) view, use the entire dialog.
		rcMain.SetRect(0, 0, cx, cy);
		layoutMain.Create(metrics, rcMain);
		ResizeMainLayout(layoutMain);
	}
		

	// Redraw the entire client area to fix things up since much
	// of the stuff in the client has moved around.
	CRect rcClient;
	m_pdlg->GetClientRect(&rcClient);
	m_pdlg->InvalidateRect(&rcClient);
	
}


//**************************************************************
// CLayout::LayoutView
//
// This method lays out the position and size of the CEventTrap
// dialog and the items that appear on it.
//
// Parameters:
//      BOOL bExtendedView
//          TRUE if this is a request to layout the extended (large)
//          view of the dialog.  FALSE if this is a request to layout
//          the small (main) view of the dialog.
//
// Returns:
//      Nothing.
//**************************************************************
void CLayout::LayoutView(BOOL bExtendedView)
{
	CRect rcWindow;
	m_pdlg->GetWindowRect(&rcWindow);

	CRect rcClient;
	m_pdlg->GetClientRect(&rcClient);
	m_pdlg->ClientToScreen(&rcClient);

    // cx and cy are the width and height of the dialog in client units
    // respectively.  The code below will calculate new values for cx and
    // cy to reflect the change from extended view to small (main) view
    // or vice-versa.
	int cx = rcClient.Width();
	int cy = rcClient.Height();
	int cxInitial = cx;
	int cyInitial = cy;

    // Compute the margins that intervene between the client
    // rectangle and window rectangle.
	int cxLeftMargin = rcClient.left - rcWindow.left;
	int cyTopMargin = rcClient.top - rcWindow.top;
	int cxRightMargin = rcWindow.right - rcClient.right;
	int cyBottomMargin = rcWindow.bottom - rcClient.bottom;


	CRect rc;
	m_pdlg->GetClientRect(&rc);
	
	if (bExtendedView) {
        // Control comes here if we are changing from the small main view
        // to the larger extended view.  This causes the dialog to flip 
        // back to the previous size of the extended view.  However this
        // is constrained to a minimum of the original dialog size.

        // Save the current height of the main view so that we can flip
        // back to it later.  Assume that the new height will be the
        // height of the extended view when it was flipped the last time.
		m_cyMainView = cy;
		cy = m_cyExtendedView;		

        // Constrain the height so that the mimimum height is what it
        // the initial height was for the extended view.
		if (cx < m_sizeExtendedViewInitial.cx) {
			cx = m_sizeExtendedViewInitial.cx;
		}

		if (cy < m_sizeExtendedViewInitial.cy) {
			cy = m_sizeExtendedViewInitial.cy;
		}


        // The extended view should never be smaller than the main view.
        // This check is necessary when the user resizes the window and
        // then flips the view.
        if (cy < m_cyMainView) {
            cy = m_cyMainView;
        }


		
		rc.SetRect(0, 0, cx, cy);

        // Check to see if the size changed, if not then do nothing.
        // Otherwise, resize the window.
		if ((cxInitial != cx) || (cyInitial != cy)) {			
			m_pdlg->ClientToScreen(&rc);
			rc.left -= cxLeftMargin;
			rc.top -= cyTopMargin;
			rc.right += cxRightMargin;
			rc.bottom += cyBottomMargin;
			m_pdlg->MoveWindow(&rc, TRUE);
		}
		else {
			LayoutAndRedraw(bExtendedView, cx, cy);
		}
	}

    // The main view should never be taller than the extended view.  This may
    // check is necessary if the user resized the window and then flipped to the
    // other view.
    if (m_cyMainView > m_cyExtendedView) {
        m_cyMainView = m_cyExtendedView;
    }

    // Show or hide the items in the extended portion of the dialog.
	ShowExtendedView(bExtendedView);


	if (!bExtendedView) {
		// This used to be an extended view, now we need to
		// go back to just the main view.

		// Save the current extended view height and then flip back to the
        // previously saved main (small) view height.
		m_cyExtendedView = cy;
		cy = m_cyMainView;

        // Constrain the size to be at least as large as the initial size for
        // the main (small) view.		
		if (cx < m_sizeMainViewInitial.cx) {
			cx = m_sizeMainViewInitial.cx;
		}
		if (cy < m_sizeMainViewInitial.cy) {
			cy = m_sizeMainViewInitial.cy;
		}


        // Resize the dialog only if the computed size is different
        // from the current size. Moving the window to resize it will automatically
        // cause it to be layed out correctly.
		if ((cxInitial != cx) || (cyInitial != cy)) {
			rc.SetRect(0, 0, cx, cy);
			m_pdlg->ClientToScreen(&rc);
			rc.left -= cxLeftMargin;
			rc.top -= cyTopMargin;
			rc.right += cxRightMargin;
			rc.bottom += cyBottomMargin;
			m_pdlg->MoveWindow(&rc, TRUE);
		}
		else {
			LayoutAndRedraw(bExtendedView, cx, cy);
		}
	}
}


//**************************************************************
// CLayout::ShowExtendedView
//
// This method shows or hides the dialog items that make up the
// extended portion of the dialog.
//
// Parameters:
//      BOOL bShowExtendedItems
//          TRUE if the extended items should be shown, false if
//          they should be hidden.
//
// Returns:
//      Nothing.
//**************************************************************
void CLayout::ShowExtendedView(BOOL bShowExtendedItems)
{
	m_pdlg->m_btnRemove.ShowWindow(bShowExtendedItems);
	m_pdlg->m_btnAdd.ShowWindow(bShowExtendedItems);
	m_pdlg->m_btnFind.ShowWindow(bShowExtendedItems);
	m_pdlg->m_lcSource.ShowWindow(bShowExtendedItems);
	m_pdlg->m_tcSource.ShowWindow(bShowExtendedItems);
	m_pdlg->m_statLabel1.ShowWindow(bShowExtendedItems);
	m_pdlg->m_statLabel2.ShowWindow(bShowExtendedItems);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\lcsource.h ===
#ifndef _lcsource_h
#define _lcsource_h

#define CX_DEFAULT_DESCRIPTION_WIDTH 100
#define CX_DESCRIPTION_SLOP 25


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLcSource window

class CXMessageArray;
class CXEventSource;
class CXMessage;

class CLcSource : public CListCtrl
{
// Construction
public:
	CLcSource();
	SCODE CreateWindowEpilogue();

// Attributes
public:


// Operations
public:
	BOOL Find(CString sText, BOOL bWholeWord, BOOL bMatchCase);
	SCODE SetEventSource(CXEventSource* pEventSource);
	void SortItems(DWORD dwColumn);
	LONG FindItem(DWORD dwMessageId);
	void RefreshItem(LONG iItem);
	CXMessage* operator[](LONG iItem) {return GetAt(iItem); }
	CXMessage* GetAt(LONG iItem);
	LONG GetSize() {return GetItemCount(); }
    void GetSelectedMessages(CXMessageArray& amsg);
    void NotifyTrappingChange(DWORD dwMessageId, BOOL bIsTrapping);
    LONG SetDescriptionWidth();

// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLcSource)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLcSource();

	// Generated message map functions
protected:
	//{{AFX_MSG(CLcSource)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	friend class CSource;
	CSource* m_pSource;

	void SetColumnHeadings();
	SCODE GetMessageLibPath(CString& sLog, CString& sEventSource, CString& sLibPath);
	void AddMessage(CXMessage* pMessage);
    void SetDescriptionWidth(CXMessageArray& aMessages);
	
};

enum {ICOL_LcSource_EVENTID = 0, 
	  ICOL_LcSource_SEVERITY,
	  ICOL_LcSource_TRAPPING,
	  ICOL_LcSource_DESCRIPTION,
	  ICOL_LcSource_MAX	  
	  };


#endif //_lcsource_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\regkey.cpp ===
//****************************************************************************
//
//  Copyright (c) 1993,  Microsoft Corp.
//
//  File:  DOMDLGS.H
//
//  Implementation file for registry management classes
//
//  History:
//      Scott V. Walker 10/5/94
//
//****************************************************************************

#include "stdafx.h"

#include "portable.h"

#include "regkey.h"


BOOL g_bLostConnection = FALSE;


//****************************************************************************
//
//  CRegistryValue Implementation
//
//****************************************************************************

IMPLEMENT_DYNAMIC(CRegistryValue, CObject)

//****************************************************************************
//
//  CRegistryValue::CRegistryValue
//
//****************************************************************************
CRegistryValue::CRegistryValue()
{
    m_dwType = REG_NONE;
    m_dwDataLength = 0;
    m_pData = NULL;
}

//****************************************************************************
//
//  CRegistryValue::CRegistryValue
//
//****************************************************************************
CRegistryValue::CRegistryValue(LPCTSTR pszName, DWORD dwType,
    DWORD dwDataLength, LPBYTE pData)
{
    Set(pszName, dwType, dwDataLength, pData);
}

//****************************************************************************
//
//  CRegistryValue::~CRegistryValue
//
//****************************************************************************
CRegistryValue::~CRegistryValue()
{
    Empty();
}

//****************************************************************************
//
//  CRegistryValue::Set
//
//  Sets the value data fields.  The data pointed to by pData is COPIED!
//
//****************************************************************************
void CRegistryValue::Set(LPCTSTR pszName, DWORD dwType,
    DWORD dwDataLength, LPBYTE pData)
{
    Empty();

    m_sName = pszName;
    m_dwType = dwType;
    m_dwDataLength = dwDataLength;
    if (dwDataLength == 0 || pData == NULL)
        m_pData = NULL;
    else
    {
        m_pData = new BYTE[dwDataLength];
        memcpy(m_pData, pData, dwDataLength);
    }
}

//****************************************************************************
//
//  CRegistryValue::Get
//
//  Gets the value data fields.  The data pointed to by m_pData is COPIED
//  into the buffer pointed to by pData... this buffer better be big enough!
//  If pData is NULL, no copy is performed.
//
//****************************************************************************
void CRegistryValue::Get(CString &sName, DWORD &dwType,
    DWORD &dwDataLength, LPBYTE pData)
{
    sName = m_sName;
    dwType = m_dwType;
    dwDataLength = m_dwDataLength;
    if (dwDataLength != 0 && pData != NULL)
        memcpy(pData, m_pData, m_dwDataLength);
}

//****************************************************************************
//
//  CRegistryValue::Empty
//
//  Clear the value data and deletes its data buffer.
//
//****************************************************************************
void CRegistryValue::Empty()
{
    m_sName.Empty();
    m_dwType = REG_NONE;
    m_dwDataLength = 0;
    if (m_pData != NULL)
        delete m_pData;
    m_pData = NULL;
}

//****************************************************************************
//
//  CRegistryValue::operator=
//
//  Assignment operator.  Copies CRegistryValue object.
//
//****************************************************************************
const CRegistryValue& CRegistryValue::operator=(CRegistryValue &other)
{
    Set(other.m_sName, other.m_dwType, other.m_dwDataLength, other.m_pData);

    return *this;
}

//****************************************************************************
//
//  CRegistryKey Implementation
//
//****************************************************************************

IMPLEMENT_DYNAMIC(CRegistryKey, CObject)

//****************************************************************************
//
//  CRegistryKey::CRegistryKey
//
//****************************************************************************
CRegistryKey::CRegistryKey()
{
    // The lost connection status is initialized only once so that if a connection
    // is ever lost we won't waste any time trying to close keys.

    Initialize();
}

//****************************************************************************
//
//  CRegistryKey::Initialize
//
//****************************************************************************
void CRegistryKey::Initialize()
{
    m_bConnected = FALSE;
    m_bOpen = FALSE;
    m_bLocal = TRUE;
    m_bDirty = FALSE;

    m_hkeyConnect = NULL;
    m_hkeyRemote = NULL;
    m_hkeyOpen = NULL;
    m_Sam = 0;

    m_dwSubKeys = 0;
    m_dwMaxSubKey = 0;
    m_dwMaxClass = 0;
    m_dwValues = 0;
    m_dwMaxValueName = 0;
    m_dwMaxValueData = 0;
    m_dwSecurityDescriptor = 0;

    m_ftLastWriteTime.dwLowDateTime = 0;
    m_ftLastWriteTime.dwHighDateTime = 0;

    m_lResult = ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::~CRegistryKey
//
//  Destructor.
//
//****************************************************************************
CRegistryKey::~CRegistryKey()
{
    if (g_bLostConnection) {
        // If we lost the registry connection, it will be useless to do anything.
        return;
    }

    // If we're currently open, then close.
    if (m_bOpen)
        Close(TRUE);

    // If we're currently connected, then disconnect.
    if (m_bConnected)
        Disconnect(TRUE);
}

//****************************************************************************
//
//  CRegistryKey::Connect
//
//****************************************************************************
LONG CRegistryKey::Connect(LPCTSTR pszComputer, HKEY hkey)
{
    if (g_bLostConnection) {
        return RPC_S_SERVER_UNAVAILABLE;
    }

    TCHAR szName[MAX_COMPUTERNAME_LENGTH + 1];
    CString sComputer;
    HKEY hkeyRemote;
    DWORD dwNumChars;

    m_lResult = ERROR_SUCCESS;

    if (m_bConnected)
    {
        m_lResult = Disconnect(TRUE);
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // Is this the local machine?

    dwNumChars = MAX_COMPUTERNAME_LENGTH + 1;

    sComputer = pszComputer;
    GetComputerName(szName, &dwNumChars);
    if (sComputer.IsEmpty() || !lstrcmpi(pszComputer, szName))
    {
        // Local

        m_bLocal = TRUE;
        hkeyRemote = NULL;
    }
    else
    {
        // Remote

        m_bLocal = FALSE;
        m_lResult = RegConnectRegistry(pszComputer, hkey, &hkeyRemote);

        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
        lstrcpy(szName, pszComputer);
    }

    m_bConnected = TRUE;
    m_hkeyConnect = hkey;
    m_hkeyRemote = hkeyRemote;
    m_sComputer = szName;

    return ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::Disconnect
//
//****************************************************************************
LONG CRegistryKey::Disconnect(BOOL bForce)
{
    m_lResult = ERROR_SUCCESS;

    if (m_bConnected)
    {
        // Close the open key
        if (m_bOpen)
        {
            m_lResult = Close(bForce);
            if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                g_bLostConnection = TRUE;                
            }

            if (!bForce && m_lResult != ERROR_SUCCESS)
                return m_lResult;
        }

        // Close the remote connection
        if (!g_bLostConnection) {
            if (!m_bLocal)
            {
                m_lResult = RegCloseKey(m_hkeyRemote);
                if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                    g_bLostConnection = TRUE;
                }
                if (!bForce && m_lResult != ERROR_SUCCESS)
                    return m_lResult;
            }
        }
    }
    


    
    Initialize();

    return ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::Create
//
//****************************************************************************
LONG CRegistryKey::Create(LPCTSTR pszKeyName, DWORD &dwDisposition,
    LPCTSTR pszClass, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecAttr)
{
    if (g_bLostConnection) {
        return RPC_S_SERVER_UNAVAILABLE;
    }
    
    HKEY hkeyOpen, hkey;

    m_lResult = ERROR_SUCCESS;
    dwDisposition = 0;

    if (m_bOpen)
    {
        m_lResult = Close(TRUE);
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // If not connected, default to \\Local_Machine\HKEY_LOCAL_MACHINE
    if (!m_bConnected)
    {
        m_lResult = Connect();
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // Attempt to create the specified subkey
    if (m_bLocal)
        hkey = m_hkeyConnect;
    else
        hkey = m_hkeyRemote;

    m_lResult = RegCreateKeyEx(hkey, pszKeyName, 0, (LPTSTR)pszClass,
        REG_OPTION_NON_VOLATILE, samDesired, lpSecAttr, &hkeyOpen,
        &dwDisposition);
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }
    if (m_lResult != ERROR_SUCCESS)
        return m_lResult;

    m_lResult = RegCloseKey(hkeyOpen);
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
        return m_lResult;
    }

    return Open(pszKeyName, samDesired);
}

//****************************************************************************
//
//  CRegistryKey::Open
//
//****************************************************************************
LONG CRegistryKey::Open(LPCTSTR pszKeyName, REGSAM samDesired)
{
    if (g_bLostConnection) {
        return RPC_S_SERVER_UNAVAILABLE;
    }


    HKEY hkeyOpen, hkey;
    CString sWork;
    int nPos;

    m_lResult = ERROR_SUCCESS;

    if (m_bOpen)
    {
        m_lResult = Close(TRUE);
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // If not connected, default to \\Local_Machine\HKEY_LOCAL_MACHINE
    if (!m_bConnected)
    {
        m_lResult = Connect();
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // Attempt to open the specified subkey
    if (m_bLocal)
        hkey = m_hkeyConnect;
    else
        hkey = m_hkeyRemote;
    m_lResult = RegOpenKeyEx(hkey, pszKeyName, 0, samDesired, &hkeyOpen);
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }
    if (m_lResult != ERROR_SUCCESS)
        return m_lResult;

    // Attempt to get info about this key.

    TCHAR szBuffer[1024 + 1];
    DWORD dwClass, dwSubKeys, dwMaxSubKey, dwMaxClass, dwValues;
    DWORD dwMaxValueName, dwMaxValueData, dwSecurityDescriptor;
    FILETIME ftLastWriteTime;

    dwClass = 1024 + 1;
    m_lResult = RegQueryInfoKey(hkeyOpen, szBuffer, &dwClass, 0, &dwSubKeys, 
        &dwMaxSubKey, &dwMaxClass, &dwValues, &dwMaxValueName,
        &dwMaxValueData, &dwSecurityDescriptor, &ftLastWriteTime);
    
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
        return m_lResult;
    }

    if (m_lResult != ERROR_SUCCESS)
    {
        RegCloseKey(hkeyOpen);
        return m_lResult;
    }

    // Success! save all the data.

    m_sFullName = pszKeyName;
    nPos = m_sFullName.ReverseFind('\\');
    if (nPos >= 0)
        m_sKeyName = m_sFullName.Mid(nPos + 1);
    else
        m_sKeyName = m_sFullName;

    m_hkeyOpen = hkeyOpen;
    m_bOpen = TRUE;
    m_Sam = samDesired;
    m_sClass = szBuffer;
    m_dwSubKeys = dwSubKeys;
    m_dwMaxSubKey = dwMaxSubKey;
    m_dwMaxClass = dwMaxClass;
    m_dwValues = dwValues;
    m_dwMaxValueName = dwMaxValueName;
    m_dwMaxValueData = dwMaxValueData;
    m_dwSecurityDescriptor = dwSecurityDescriptor;
    m_ftLastWriteTime = ftLastWriteTime;

    return ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::Close
//
//****************************************************************************
LONG CRegistryKey::Close(BOOL bForce)
{
    if (!g_bLostConnection) {

        m_lResult = ERROR_SUCCESS;

        if (!m_bOpen)
            return ERROR_SUCCESS;


        if (m_bDirty)
        {
            m_lResult = RegFlushKey(m_hkeyOpen);
            if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                g_bLostConnection = TRUE;
            }

            if (!bForce && m_lResult != ERROR_SUCCESS)
                return m_lResult;
        }

        if (!g_bLostConnection) {
            m_lResult = RegCloseKey(m_hkeyOpen);
            if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                g_bLostConnection = TRUE;
            }

            if (!bForce && m_lResult != ERROR_SUCCESS)
                return m_lResult;
        }
    }

    m_bDirty = FALSE;

    m_hkeyOpen = NULL;
    m_bOpen = FALSE;
    m_sFullName.Empty();
    m_sClass.Empty();
    m_Sam = 0;

    m_dwSubKeys = 0;
    m_dwMaxSubKey = 0;
    m_dwMaxClass = 0;
    m_dwValues = 0;
    m_dwMaxValueName = 0;
    m_dwMaxValueData = 0;
    m_dwSecurityDescriptor = 0;

    m_ftLastWriteTime.dwLowDateTime = 0;
    m_ftLastWriteTime.dwHighDateTime = 0;

    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return RPC_S_SERVER_UNAVAILABLE;
    }
    else {
        m_lResult = ERROR_SUCCESS;
        return ERROR_SUCCESS;
    }
}

//****************************************************************************
//
//  CRegistryKey::EnumValues
//
//  Returns NULL if unsuccessful, returns empty array if successful but open
//  key has no values.
//  NOTE: Caller is responsible for deleting returned string array.
//
//****************************************************************************
CStringArray* CRegistryKey::EnumValues()
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return NULL;
    }
         
    TCHAR szBuffer[1024 + 1];
    DWORD dwLength;
    CStringArray *pArr;
    int i;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen || g_bLostConnection)
        return NULL;

    // Enumerate all the values into a string array
    pArr = new CStringArray;
    i = 0;
    m_lResult = ERROR_SUCCESS;
    while (TRUE)
    {
        dwLength = 1024 + 1;
        m_lResult = RegEnumValue(m_hkeyOpen, i, szBuffer, &dwLength, NULL,
            NULL, NULL, NULL);

        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }

        if (m_lResult != ERROR_SUCCESS)
            break;
        if (dwLength > 0)
            pArr->Add(szBuffer);
        i++;
    }

    // Did we find a normal end condition?
    if (m_lResult == ERROR_NO_MORE_ITEMS)
        return pArr;

    delete pArr;
    return NULL;
}

//****************************************************************************
//
//  CRegistryKey::EnumSubKeys
//
//  Returns NULL if unsuccessful, returns empty array if successful but open
//  key has no values.
//  NOTE: Caller is responsible for deleting returned string array.
//
//****************************************************************************
CStringArray* CRegistryKey::EnumSubKeys()
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return NULL;
    }



    TCHAR szBuffer[1024 + 1];
    DWORD dwLength;
    CStringArray *pArr;
    int i;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen)
        return NULL;

    // Enumerate all the subkeys into a string array
    pArr = new CStringArray;
    i = 0;

    while (TRUE)
    {
        dwLength = 1024 + 1;
        m_lResult = RegEnumKeyEx(m_hkeyOpen, i, szBuffer, &dwLength, NULL,
            NULL, NULL, NULL);

        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }

        if (m_lResult != ERROR_SUCCESS)
            break;
        if (dwLength > 0)
            pArr->Add(szBuffer);
        i++;
    }

    // Did we find a normal end condition?
    if (m_lResult == ERROR_NO_MORE_ITEMS)
        return pArr;

    delete pArr;
    return NULL;
}

//****************************************************************************
//
//  CRegistryKey::GetValue
//
//  Note: regval is always emptied regardless of success/failure
//
//****************************************************************************
BOOL CRegistryKey::GetValue(LPCTSTR pszValue, CRegistryValue &regval)
{

    DWORD dwLength, dwType;
    BYTE *pBuffer;

    regval.Empty();

    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }

    if (!m_bOpen)
    {
        m_lResult = ERROR_INVALID_FUNCTION;
        return FALSE;
    }

    // Find out how big the data is
    m_lResult = RegQueryValueEx(m_hkeyOpen, (LPTSTR)pszValue, NULL, NULL,
        NULL, &dwLength);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    if (dwLength == 0)
        return TRUE;

    // Now make a buffer big enough for it.
    pBuffer = new BYTE[dwLength];
    if (pBuffer == NULL)
        return FALSE;

    m_lResult = RegQueryValueEx(m_hkeyOpen, (LPTSTR)pszValue, NULL, &dwType,
        pBuffer, &dwLength);


    if (m_lResult == ERROR_SUCCESS)
        regval.Set(pszValue, dwType, dwLength, pBuffer);

    delete pBuffer;

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::SetValue
//
//****************************************************************************
BOOL CRegistryKey::SetValue(CRegistryValue &regval)
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }

    if (!m_bOpen)
    {
        m_lResult = ERROR_INVALID_FUNCTION;
        return FALSE;
    }
    
    if (regval.m_sName.IsEmpty())
    {
        m_lResult = ERROR_INVALID_DATA;
        return FALSE;
    }

    m_lResult = RegSetValueEx(m_hkeyOpen, regval.m_sName, 0, regval.m_dwType,
        regval.m_pData, regval.m_dwDataLength);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    m_bDirty = TRUE;

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::GetSubKey
//
//  Note: If successful, regkey is returned connected and open on the
//  specified key.  If failure, regkey is returned disconnected.
//
//****************************************************************************
BOOL CRegistryKey::GetSubKey(LPCTSTR pszSubKey, CRegistryKey &regkey)
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }


    CString sSubKey;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen)
        return FALSE;

    m_lResult = regkey.Disconnect(TRUE);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    // Try to connect and open same key
    m_lResult = regkey.Connect(m_sComputer, m_hkeyConnect);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;
    sSubKey = pszSubKey;
    m_lResult = regkey.Open(m_sFullName + "\\" + sSubKey, m_Sam);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
    {
        regkey.Disconnect(TRUE);
        return FALSE;
    }

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::CreateSubKey
//
//  Note: If successful, regkey is returned connected and open on the
//  new key; if the key already existed, it is simply opened.  If failure,
//  regkey is returned disconnected.
//
//****************************************************************************
BOOL CRegistryKey::CreateSubKey(
    LPCTSTR pszSubKey, 
    CRegistryKey &regkey,
    LPCTSTR pszClass, 
    LPSECURITY_ATTRIBUTES lpSecAttr,
    BOOL bIsVolatile)
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }
 
 
    CString sSubKey, sClass;
    HKEY hkeyOpen;
    DWORD dwDisposition;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen)
        return FALSE;

    m_lResult = regkey.Disconnect(TRUE);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    // Try to connect and open same key
    m_lResult = regkey.Connect(m_sComputer, m_hkeyConnect);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;
    sSubKey = pszSubKey;
    sClass = pszClass;
    DWORD dwRegOptions = bIsVolatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE;
    m_lResult = RegCreateKeyEx(m_hkeyOpen, sSubKey, 0, (LPTSTR)(LPCTSTR)sClass,
        dwRegOptions, m_Sam, lpSecAttr, &hkeyOpen, &dwDisposition);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
    {
        regkey.Disconnect(TRUE);
        return FALSE;
    }
    m_lResult = RegCloseKey(hkeyOpen);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    m_lResult = regkey.Open(m_sFullName + "\\" + sSubKey, m_Sam);

    if (m_lResult != ERROR_SUCCESS)
    {
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }

        regkey.Disconnect(TRUE);
        return FALSE;
    }

    m_bDirty = TRUE;
    if (dwDisposition == REG_CREATED_NEW_KEY)
        regkey.m_bDirty = TRUE;

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::DeleteSubKey
//
//****************************************************************************
BOOL CRegistryKey::DeleteSubKey(LPCTSTR pszSubKey)
{
    if (g_bLostConnection) {
        return FALSE;
    }

    CString sSubKey;
    CRegistryKey subkey;
    int i;

    m_lResult = ERROR_SUCCESS;
    sSubKey = pszSubKey;

    if (!m_bOpen)
        return FALSE;

    if (!GetSubKey(sSubKey, subkey))
        return FALSE;

    // Delete all subkeys of the specified subkey (RegDeleteKey limitation)
    CStringArray *parr = subkey.EnumSubKeys();
    for (i=0; i<parr->GetSize(); i++)
    {
        if (!subkey.DeleteSubKey(parr->GetAt(i)))
            return FALSE;
    }
    delete parr;

    subkey.Close(TRUE);

    m_lResult = RegDeleteKey(m_hkeyOpen, sSubKey);
    if (m_lResult != ERROR_SUCCESS) {
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\portable.h ===
//****************************************************************************
//
//  Copyright (c) 1992, Microsoft Corporation
//
//  File:  PORTABLE.H
//
//  Definitions to simplify portability between WIN31 and WIN32
//
//****************************************************************************

#ifndef _PORTABLE_H_
#define _PORTABLE_H_

#ifdef _NTWIN
#ifndef WIN32
#define WIN32
#endif
#endif

#ifdef WIN32

#define GET_WM_COMMAND_ID(wp, lp)       LOWORD(wp)
#define GET_WM_COMMAND_CMD(wp, lp)      HIWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)     (HWND)(lp)

#define GET_WINDOW_ID(hwnd)         (UINT)GetWindowLong(hwnd, GWL_ID)
#define GET_WINDOW_INSTANCE(hwnd)   (HINSTANCE)GetWindowLong(hwnd, \
                                        GWL_HINSTANCE)

#define LONG2POINT(l, pt)  ((pt).x=(SHORT)LOWORD(l), (pt).y=(SHORT)HIWORD(l))

#ifdef __cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    (::SendMessage)(::GetParent(hwnd), \
                                        WM_COMMAND, MAKEWPARAM(nID, code), \
                                        (LPARAM)hwnd); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    (::SendMessage)(hwnd, WM_COMMAND, \
                                        MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    (::PostMessage)(hwnd, WM_COMMAND, \
                                        MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#else // !__cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    SendMessage(GetParent(hwnd), WM_COMMAND, \
                                        MAKEWPARAM(nID, code), \
                                        (LPARAM)hwnd); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    SendMessage(hwnd, WM_COMMAND, \
                                        MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    PostMessage(hwnd, WM_COMMAND, \
                 