
{
    Assert(ppkt->_pSpiInfo == NULL);

    CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;
    CEnetHdr *   pEnetHdr       = ppkt->_pEnetHdr;
    CIpHdr *     pIpHdr         = ppkt->_pIpHdr;
    BYTE *       pb             = ppkt->_pb;
    UINT         cb             = ppkt->_cb;
    CIpAddr      ipaSrc         = pIpHdr->_ipaSrc;
    UINT         cbIpLen        = NTOHS(pIpHdr->_wLen);

    if (pIpHdr->_ipaDst != pTransInfoRecv->_ipa)
    {
        if (pIpHdr->_ipaDst.IsBroadcast())
        {
            TraceSz(RecvDiscard, "%s: IP header has broadcast ipaDst %s", ppkt->Str(), pIpHdr->_ipaDst.Str());
            SgEventPacketNoisy(INVALID_IPSEC_PACKET_2, ppkt, pIpHdr->_ipaSrc, 0, cbIpLen, pIpHdr);
            SgPerfdataInc(DropIpHdr, 1);
            goto complete;
        }

        TraceSz(RecvDiscard, "%s: IP header has ipaDst %s but was expecting %s",
                 ppkt->Str(), pIpHdr->_ipaDst.Str(), pTransInfoRecv->_ipa.Str());
        SgEventPacket(INVALID_IPSEC_PACKET_3, ppkt, pIpHdr->_ipaSrc, 0, cbIpLen, pIpHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    // The only acceptable IP protocols are UDP or ICMP.

    if (pIpHdr->_bProtocol != IPPROTOCOL_UDP)
    {
        if (pIpHdr->_bProtocol == IPPROTOCOL_ICMP)
        {
            SgIcmpRecv(ppkt);
            return;
        }

        TraceSz(RecvDiscard, "%s: IP packet has non-UDP protocol (%d)", ppkt->Str(), pIpHdr->_bProtocol);
        SgEventPacketNoisy(INVALID_IPSEC_PACKET_4, ppkt, ppkt->_pIpHdr->_ipaSrc, 0, cbIpLen, pIpHdr);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

#ifdef SG_FEATURE_UDP_ECHO
    CUdpHdr* pUdpHdr = (CUdpHdr*)pb;

    if (pUdpHdr->_ipportDst == XSP_PORT_UDPECHO)
    {
        // Special UDP echo packet for stress test
        SgIRecvUdpEcho(ppkt);
        return;
    }
#endif

    //
    // Process the XSP header (which includes a UDP header)
    //

    if (cb < sizeof(CXspHdr))
    {
        TraceSz(RecvDiscard, "%s: IP payload (%d bytes) is smaller than CXspHdr (%d bytes)",
                 ppkt->Str(), cb, sizeof(CXspHdr));
        SgEventPacketNoisy(INVALID_IPSEC_PACKET_5, ppkt, pIpHdr->_ipaSrc, 0, cbIpLen, pIpHdr);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    CXspHdr * pXspHdr = ppkt->_pXspHdr = (CXspHdr *)pb;

    if (NTOHS(pXspHdr->_wLen) != cb)
    {
        TraceSz(RecvDiscard, "%s: XSP size in header (%d bytes) differs from IP payload size (%d bytes)",
                 ppkt->Str(), NTOHS(pXspHdr->_wLen), cb);
        SgEventPacketLogNoisy(INVALID_IPSEC_PACKET_6, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_IP);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

#ifdef SG_FEATURE_UDP_ECHO
    if (pXspHdr->_ipportDst != XSP_PORT &&
        pXspHdr->_ipportDst != XSP_PORT_XSPECHO)
#else
    if (pXspHdr->_ipportDst != XSP_PORT)
#endif
    {
        TraceSz(RecvDiscard, "%s: XSP header has ipportDst %d but expecting %d",
                 ppkt->Str(), NTOHS(pXspHdr->_ipportDst), NTOHS(XSP_PORT));
        SgEventPacketNoisy(INVALID_IPSEC_PACKET_7, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbIpLen, pIpHdr);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    if (pXspHdr->_ipportSrc == 0)
    {
        TraceSz(RecvDiscard, "%s: XSP header has ipportSrc %d",
                 ppkt->Str(), NTOHS(pXspHdr->_ipportSrc));
        SgEventPacketNoisy(INVALID_IPSEC_PACKET_8, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbIpLen, pIpHdr);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    // We don't bother checking the UDP header checksum at this point because we always
    // have SHA authentication (or self-authenticating KeyEx messages) in our packets.

    ppkt->_pb = (pb += sizeof(CXspHdr));
    ppkt->_cb = (cb -= sizeof(CXspHdr));

    if (pXspHdr->_dwSpiAndFlags == 0)
    {
        // An SPI of zero is marks a key-exchange packet.  The contents of the key-exchange
        // packets starts after the XSP header.

        SgIRecvKeyEx(ppkt);
        return;
    }

    BYTE bXspType = pXspHdr->_bFlags & XSP_TYPE_MASK;

    if (bXspType > XSP_TYPE_MAX)
    {
        TraceSz(RecvDiscard, "%s: XSP header has invalid bFlags (%02X)",
                 ppkt->Str(), bXspType);
        // Log first 16 bytes of payload
        SgEventPacketLogNoisyEx(INVALID_IPSEC_PACKET_9, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_IP, min(cb, 16), pb);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    if (cb < sizeof(CXspTail))
    {
        TraceSz(RecvDiscard, "%s: XSP payload (%d bytes) is smaller than CXspTail (%d bytes)",
                 ppkt->Str(), cb, sizeof(CXspTail));
        SgEventPacketLogNoisyEx(INVALID_IPSEC_PACKET_10, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_IP, min(cb, 16), pb);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    CXspTail *  pXspTail = ppkt->_pXspTail = (CXspTail *)(pb + cb - sizeof(CXspTail));

    // The checks here got moved to the top of SgIRecvWithSpi

    // Find the CSpiInfo associated with dwSpi and continue at SgIRecvWithSpi

    SgSpiInfoAttach(ppkt, SgIRecvWithSpi, pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK);
    return;

complete:
    ppkt->Complete();
    return;
}

void SgIRecvWithSpi(CPacket * ppkt)
{
    CSpiInfo *  pSpiInfo    = ppkt->_pSpiInfo;
    CEnetHdr *  pEnetHdr    = ppkt->_pEnetHdr;
    CIpHdr *    pIpHdr      = ppkt->_pIpHdr;
    CXspHdr *   pXspHdr     = ppkt->_pXspHdr;
    CXspTail *  pXspTail    = ppkt->_pXspTail;
    CXspCtx *   pXspCtx     = (CXspCtx *)ppkt->_abCtx;
    CIpAddr     ipaSrc      = pIpHdr->_ipaSrc;
    DWORD       dwSeq       = pXspTail->_wSeqLo;
    UINT        cbIpLen     = NTOHS(pIpHdr->_wLen);
    CIpPort     ipportSrc, ipportDst;
    CDstInfo *  pDstInfo    = NULL;

    if (pSpiInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: XSP packet from %s has unrecognized dwSpi %08lX",
                 ppkt->Str(), ipaSrc.Str(), pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK);
        // Log first 16 bytes of payload
        SgEventPacketLogNoisyEx(INVALID_IPSEC_PACKET_14, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_XSP, min(ppkt->_cb, 16), ppkt->_pb);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    if (pSpiInfo->_qwTickKeyEx1 == 0)
    {
        TraceSz(RecvDiscard, "%s: inbound packet before key-exchange is complete", ppkt->Str());
        SgEventPacketLogNoisy(INVALID_IPSEC_PACKET_15, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_XSP);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    // Verify that the packet comes from the expected source IP address and port

    if (ipaSrc != pSpiInfo->_ipaI)
    {
        TraceSz(RecvDiscard, "%s: ipaSrc is %s but was expecting %s",
                 ppkt->Str(), ipaSrc.Str(), pSpiInfo->_ipaI.Str());
        SgEventPacketLogNoisy(INVALID_IPSEC_PACKET_16, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_IP);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    if (pXspHdr->_ipportSrc != pSpiInfo->_ipportI)
    {
        TraceSz(RecvDiscard, "%s: ipportSrc is %d but was expecting %d",
                 ppkt->Str(), NTOHS(pXspHdr->_ipportSrc), NTOHS(pSpiInfo->_ipportI));
        SgEventPacketLogNoisy(INVALID_IPSEC_PACKET_17, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_XSP);
        SgPerfdataInc(DropIpHdr, 1);
        goto complete;
    }

    // Get some crypto params, namely the block size

    UINT        uiCipher         = 0; // not used
    UINT        uiBlockLen       = 0;
    UINT        uiTableSize      = 0; // not used

    XcGetCryptParamsFromKeyLength(pSpiInfo->_cbKeyCrypt, &uiCipher, &uiBlockLen, &uiTableSize);

    // This block got moved from the end of SgIRecv() due to us needing the CSpiInfo
    // struct to determine the block length.

    BYTE *      pb       = ppkt->_pb;
    UINT        cb       = ppkt->_cb;
    BYTE        bXspType = pXspHdr->_bFlags & XSP_TYPE_MASK;
    UINT        cbDat    = 0;
    UINT        cbTov    = 0;
    UINT        cbBpp    = 0;
    UINT        cbTex    = 0;
    UINT        cbTvo    = 0;
    UINT        cbPad    = XSP_DECODE_PADDING(pXspHdr->_bFlags);
    Assert(cbPad < 16);

    if (cbPad >= uiBlockLen)
    {
        TraceSz(RecvDiscard, "%s: XSP padding is greater (%d bytes) than blocksize (%d)",
                 ppkt->Str(), cbPad, uiBlockLen);
        SgEventPacketNoisy(INVALID_IPSEC_PACKET_24, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbIpLen, pIpHdr);
        goto complete;
    }

    if (bXspType == XSP_TYPE_SEC)
    {
        cbDat = cb - sizeof(CXspTail);
    }
    else
    {
        cbBpp     = (bXspType - XSP_TYPE_TCP_0) % 3;
        bXspType -= (BYTE)cbBpp;
        cbTex    += 2 * cbBpp;

        if (bXspType == XSP_TYPE_TCP_0)
        {
            cbTex += sizeof(CTcpInfo);
        }

        cbTov = min(cbPad, cbTex);

        if (cb < cbPad + (cbTex - cbTov) + sizeof(CXspTail))
        {
            TraceSz(RecvDiscard, "%s: XSP payload (%d bytes) is smaller than expected (%d bytes) [a]",
                     ppkt->Str(), cb, cbPad + (cbTex - cbTov) + sizeof(CXspTail));
            SgEventPacketNoisy(INVALID_IPSEC_PACKET_11, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbIpLen, pIpHdr);
            goto complete;
        }

        cbDat = cb - (cbTex - cbTov) - sizeof(CXspTail);

        if (bXspType >= XSP_TYPE_VDP_0)
        {
            if (bXspType == XSP_TYPE_VDP_0)
            {
                // Note that we are optimistically reading the cbDat byte before checking that
                // the payload is big enough to hold it.  We can do this because we already
                // know that the payload is at least as big as CXspTail, and that CXspHdr
                // is before the payload and is four bytes long.

                cbDat  = ((BYTE *)pXspTail)[-1];

                // We always use 8 byte blocks, even when using AES. This helps Netmon.
                // AES will, of course, always specify this as an even number to ensure a
                // multiple of 16.
                cbDat *= 8;

                if (cb < cbDat + (cbTex - cbTov) + sizeof(BYTE) + sizeof(CXspTail))
                {
                    TraceSz(RecvDiscard, "%s: XSP payload (%d bytes) is smaller than expected (%d bytes) [b]",
                             ppkt->Str(), cb, cbDat + (cbTex - cbTov) + sizeof(BYTE) + sizeof(CXspTail));
                    SgEventPacketNoisy(INVALID_IPSEC_PACKET_12, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbIpLen, pIpHdr);
                    SgPerfdataInc(DropXspHdr, 1);
                    goto complete;
                }

                cbTvo = cb - cbDat - (cbTex - cbTov) - sizeof(CXspTail);
            }
            else if (bXspType == XSP_TYPE_VDP_VO_0)
            {
                cbTvo = cbDat;
                cbDat = 0;
            }
        }
    }

    if (    (cbDat % uiBlockLen) != 0
       ||   (cbDat < cbPad)
       ||   (cb != cbDat + (cbTex - cbTov) + cbTvo + sizeof(CXspTail)))
    {
        TraceSz(RecvDiscard, "%s: XSP payload (%d bytes) is sized incorrectly (%d,%d,%d)",
                 ppkt->Str(), cb, (cbDat % uiBlockLen) != 0, (cbDat < cbPad),
                 (cb != cbDat + (cbTex - cbTov) + cbTvo + sizeof(CXspTail)));
        SgEventPacketNoisy(INVALID_IPSEC_PACKET_13, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbIpLen, pIpHdr);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    ppkt->_cbDat = cbDat;
    ppkt->_cbPad = cbPad;
    ppkt->_cbTov = cbTov;
    ppkt->_cbBpp = cbBpp;
    ppkt->_cbTex = cbTex;
    ppkt->_cbTvo = cbTvo;

    SgPerfdataInc(XspRecvTotal, 1);

    // Infer the 32-bit sequence number from the 16-bit one in the packet.  We assume that
    // the sender doesn't advance 64K packets without this side receiving some of them, so
    // the sender only transmits the low 16-bits of the sequence number.

    if (dwSeq < LOWORD(pSpiInfo->_dwSeqRecv))
        dwSeq += 0x10000;

    ppkt->_dwSeq = (dwSeq += (pSpiInfo->_dwSeqRecv & 0xFFFF0000));

    // Validate that dwSeq is acceptable (assuming the packet is authentic)

    DWORD dwBit = dwSeq - pSpiInfo->_dwSeqRecv;

    if (dwBit > g_iXspReplayWindow)
    {
        DWORD dwSeqWindowEnd = pSpiInfo->_dwSeqRecv + g_iXspReplayWindow - 1;
        TraceSz(RecvDiscard, "%s #%d: sequence number is greater than window end (%d)",
                 ppkt->Str(), dwSeq, dwSeqWindowEnd);
        SgEventPacketLogNoisyWithText(INVALID_IPSEC_PACKET_18, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc),
                                      PEVT_FILTER_XSP, CTinyStr().Format("%u,%u", dwSeq, dwSeqWindowEnd).cstr());
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

#ifdef SG_FEATURE_INSECURE
    if (!g_fInhibitReplayCheck)
#endif
    {
        if (dwBit < 32 && (pSpiInfo->_dwSeqMask & (1 << dwBit)))
        {
            TraceSz(RecvDiscard, "%s #%d: packet is being replayed", ppkt->Str(), dwSeq);
            SgEventPacketLogNoisy(REPLAYED_PACKET, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), PEVT_FILTER_IP);
            SgPerfdataInc(DropXspHdr, 1);
            goto complete;
        }
    }

    //
    // Authenticate, decrypt (if necessary), and forward this data packet
    //

    TraceSz(RecvXsp, "%s: [UDP %d:%d][XSP %08lX][Dat %d; Pad %d; Ov %d; Ex %d; Vo %d; Vx %d][XSPT #%d]",
              ppkt->Str(), NTOHS(pXspHdr->_ipportDst), NTOHS(pXspHdr->_ipportSrc),
              pXspHdr->_dwSpiAndFlags, ppkt->_cbDat - ppkt->_cbPad, ppkt->_cbPad, ppkt->_cbTov, ppkt->_cbTex,
              ppkt->_cbTvo - ((pXspHdr->_bFlags & XSP_TYPE_MASK) >= XSP_TYPE_VDP_0 && (pXspHdr->_bFlags & XSP_TYPE_MASK) <= XSP_TYPE_VDP_2),
              ((pXspHdr->_bFlags & XSP_TYPE_MASK) >= XSP_TYPE_VDP_0 && (pXspHdr->_bFlags & XSP_TYPE_MASK) <= XSP_TYPE_VDP_2),
              dwSeq);

    Assert(sizeof(pXspCtx->_abHash) >= sizeof(pXspTail->_abHash));
    memcpy(pXspCtx->_abHash, pXspTail->_abHash, sizeof(pXspTail->_abHash));

    pXspTail->_wSeqHi        = HIWORD(dwSeq);
    pXspTail->_dwSpiAndFlags = pXspHdr->_dwSpiAndFlags;
    pXspTail->_dwZero        = 0;

    if (ppkt->_cbDat > 0)
    {
        SgCalcIvAtSeq(KEYMATERIAL(pSpiInfo, _abIvRecv), dwSeq, pXspCtx->_abIv);
        if (uiBlockLen == 16)
        {
            SgCalcIvAtSeq(KEYMATERIAL(pSpiInfo, _abIvRecv) + 8, dwSeq, pXspCtx->_abIv + 8);
        }
    }

    pXspCtx->_pb1 = ppkt->_pb + ppkt->_cbDat;
    pXspCtx->_cb1 = ROUNDUP4((ppkt->_cbTex - ppkt->_cbTov) + ppkt->_cbTvo + offsetof(CXspTail, _dwZero));
    pXspCtx->_pb2 = ppkt->_pb;
    pXspCtx->_cb2 = ppkt->_cbDat;

    // Now that we've decoded the entire packet layout we don't use pb/cb any more.

    ppkt->_pb = NULL;
    ppkt->_cb = 0;

    SgOffloadDecodePacket(ppkt);
    if (!ppkt->_fOffloadSuccess)
    {
        SgPerfdataInc(DropXspHash, 1);
        goto complete;
    }

    dwSeq = ppkt->_dwSeq;

#if 0
    // kgoodier: as far as I can tell, cbShift will always be 0. Look at the definitions
    // of _pb1, _pb2, _cb2 a few lines above this. pb1=pb2+cb2.
    //
    // Since padding can now be 16, I suspect the shift (whatever it used to represent)
    // could also be 16. Rather than change it and guess what the right thing to do is,
    // I'm simply taking this code out.

    // If the encrypted buffer was shifted we need to shift back any overlap data
    // so it will be next to the rest of the unencrypted data.

    UINT cbShift = pXspCtx->_pb1 - (pXspCtx->_pb2 + pXspCtx->_cb2);
    Assert(cbShift < 8);

    if (ppkt->_cbTov > 0 && cbShift > 0)
    {
        BYTE * pbTov = pXspCtx->_pb1 - ppkt->_cbTov;
        memmove(pbTov, pbTov - cbShift, ppkt->_cbTov);
    }
#endif

    if (cbPad > ppkt->_cbTov)
    {
        // Verify that the space between the padding and the overlap is zeroed

        BYTE * pbPadChk = pXspCtx->_pb2 + pXspCtx->_cb2 - ppkt->_cbTov;
        UINT   cbPadChk = cbPad - ppkt->_cbTov;

        while (cbPadChk > 0 && *--pbPadChk == 0)
            cbPadChk--;

        if (cbPadChk > 0)
        {
            TraceSz(RecvDiscard, "%s #%d: invalid padding (%s)", ppkt->Str(), dwSeq,
                     SgHexStr(pXspCtx->_pb2 + pXspCtx->_cb2 - cbPad, cbPad - ppkt->_cbTov));
            SgEventPacket(INVALID_IPSEC_PACKET_19, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbPad - ppkt->_cbTov,
                          pXspCtx->_pb2 + pXspCtx->_cb2 - cbPad);
            SgPerfdataInc(DropXspHdr, 1);
            goto complete;
        }
    }

    pXspCtx->_cb2 -= cbPad;

    // The packet is authentic, so mark the CSpiInfo with the current timer tick to record
    // inbound activity if key exchange is complete.  We may still be waiting for a challenge
    // response at this point which arrives as a SecMsg.

    SgPerfdataInc(XspRecv, 1);

    if (pSpiInfo->_qwTickKeyEx2 != 0)
    {
        pSpiInfo->_qwTickRecv = SgTimerTick();
    }

    // Adjust the receive sequence number mask

    dwBit = dwSeq - pSpiInfo->_dwSeqRecv;

    if (dwBit < 32)
    {
        // Sequence number is within the current window.  Just set the bit.

    #ifdef SG_FEATURE_INSECURE
        Assert((pSpiInfo->_dwSeqMask & (1 << dwBit)) == 0 || g_fInhibitReplayCheck);
    #else
        Assert((pSpiInfo->_dwSeqMask & (1 << dwBit)) == 0);
    #endif

        pSpiInfo->_dwSeqMask |= (1 << dwBit);
    }
    else
    {
        // Sequence number is beyond the edge of the window.  Slide window so that the
        // edge is at the sequence number.

        if (dwBit >= 63)
            pSpiInfo->_dwSeqMask = 0x80000000;
        else
            pSpiInfo->_dwSeqMask = 0x80000000 | (pSpiInfo->_dwSeqMask >> (dwBit - 31));

        pSpiInfo->_dwSeqRecv += dwBit - 31;
    }

    //
    // Process the Security Message (SECMSG) protocol
    //

    if (bXspType == XSP_TYPE_SEC)
    {
        ppkt->_pb = pXspCtx->_pb2;
        ppkt->_cb = pXspCtx->_cb2;

        SgPerfdataInc(SecMsg, 1);
        SgIRecvSecMsgWithSpi(ppkt);
        return;
    }

    if (pSpiInfo->_qwTickKeyEx2 == 0)
    {
        TraceSz(RecvDiscard, "%s: inbound packet before challenge response", ppkt->Str());
        SgEventPacket(INVALID_IPSEC_PACKET_20, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, cbIpLen, pIpHdr);
        SgPerfdataInc(DropXspHdr, 1);
        goto complete;
    }

    //
    // Rewrite the packet to strip the security headers and forward it onto the DMZ
    //

    CNatInfo *   pNatInfo       = pSpiInfo->_pNatInfo;
    CTransInfo * pTransInfoXmit = ppkt->_pTransInfoXmit = pNatInfo->_pTransInfo;
    CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;
    CUdpHdr *    pUdpHdr        = ppkt->_pUdpHdr = (CUdpHdr *)&pXspCtx->_TcpHdr;
    CTcpHdr *    pTcpHdr        = ppkt->_pTcpHdr = &pXspCtx->_TcpHdr;
    BOOL         fTcp           = bXspType == XSP_TYPE_TCP_0;
    BOOL         fVdp           = bXspType >= XSP_TYPE_VDP_0;
    BYTE *       pbDat          = pXspCtx->_pb2;
                 cbDat          = ppkt->_cbDat - ppkt->_cbPad;
    BYTE *       pbVoi          = fVdp ? (pXspCtx->_pb1 + (ppkt->_cbTex - ppkt->_cbTov)) : NULL;
    UINT         cbVoi          = fVdp ? (ppkt->_cbTvo - (bXspType == XSP_TYPE_VDP_0)) : 0;

    if (ppkt->_cbBpp == 0)
        ipportSrc = ipportDst = HTONS(1000);
    else
    {
        BYTE * pbPort = pXspCtx->_pb1 - ppkt->_cbTov;

        if (ppkt->_cbBpp == 1)
        {
            ipportSrc = HTONS(1000 + pbPort[0]);
            ipportDst = HTONS(1000 + pbPort[1]);
        }
        else
        {
            Assert(ppkt->_cbBpp == sizeof(CIpPort));
            ipportSrc = ((CIpPort *)pbPort)[0];
            ipportDst = ((CIpPort *)pbPort)[1];
        }
    }

    SgDstInfoReadLock();

    pDstInfo = SgDstInfoLookup(ipportDst);

    if (pDstInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s #%d: invalid ipportDst (%d)", ppkt->Str(), dwSeq, NTOHS(ipportDst));
        SgEventPacket(IPSEC_BAD_PORT, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, sizeof(CIpPort), &ipportDst);
        SgPerfdataInc(DropXspHdr, 1);
        SgDstInfoReadUnlock();
        goto complete;
    }

    if (!pDstInfo->_svcMask.HasAnyBits(pSpiInfo->_svcMask))
    {
        if (!pDstInfo->_svcMask.HasAnyBits(pSpiInfo->_svcMaskOrig))
        {
            TraceSz(RecvDiscard, "%s #%d: prohibited from accessing ipportDst %d, pDstInfo->_dwSvcMask=%016I64X %016I64X, pSpiInfo->_dwSvcMask=%016I64X %016I64X",
                     ppkt->Str(), dwSeq, NTOHS(ipportDst), pDstInfo->_svcMask.LowPart, pDstInfo->_svcMask.HighPart, pSpiInfo->_svcMask.LowPart, pSpiInfo->_svcMask.HighPart);
            SgEventPacket(IPSEC_ACCESS_DENIED_0, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, sizeof(CIpPort), &ipportDst);
        }
        SgPerfdataInc(DropDenied, 1);
        goto complete;
    }

    if (!!pDstInfo->_fVdpOnly != !!fVdp)
    {
        TraceSz(RecvDiscard, "%s #%d: protocol prohibited from accessing ipportDst %d",
                 ppkt->Str(), dwSeq, NTOHS(ipportDst));
        SgEventPacket(IPSEC_ACCESS_DENIED_1, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, sizeof(CIpPort), &ipportDst);
        SgPerfdataInc(DropDenied, 1);
        goto complete;
    }

#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
    // Arbitration uses 120 client ports and used to map to 120 server ports.  In Xenon the server ports are reduced to one, and we
    // only allow one outstanding Arbitration request from a client at a time.  Here we store which of the 120 ports the client
    // is using, so that when the request completes we can send the response from the appropriate port.
    if( pDstInfo->_fArbitration )
    {
        pSpiInfo->_ipportLastArbitration = ipportDst;
    }
#endif

    CDstTransInfo * pDstTransInfo = &pDstInfo->_aDstTransInfo[pTransInfoXmit->_iTransInfo];

    pEnetHdr->_eaSrc   = pTransInfoXmit->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS(sizeof(CIpHdr) + (fTcp ? sizeof(CTcpHdr) : sizeof(CUdpHdr)) + (fVdp ? sizeof(WORD) : 0) + cbDat + cbVoi);
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = fTcp ? IPPROTOCOL_TCP : IPPROTOCOL_UDP;
    pIpHdr->_ipaSrc    = pNatInfo->_ipaZ;
    pIpHdr->_ipaDst    = pDstTransInfo->_ipaZ;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    if (fTcp)
    {
        pTcpHdr->_info    = ((CTcpInfo *)pXspTail)[-1];
        pTcpHdr->_wUrgent = 0;

        UINT cbTcpHdr = pTcpHdr->_info.GetHdrLen();

        if (cbTcpHdr < sizeof(CTcpHdr))
        {
            TraceSz(RecvDiscard, "%s: cbTcpHdr (%d bytes) is smaller than sizeof(CTcpHdr) (%d bytes)",
                     ppkt->Str(), cbTcpHdr, sizeof(CTcpHdr));
            SgEventPacket(INVALID_IPSEC_PACKET_21, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, sizeof(CTcpHdr), pTcpHdr);
            goto complete;
        }

        if (cbDat < cbTcpHdr - sizeof(CTcpHdr))
        {
            TraceSz(RecvDiscard, "%s: XSP payload (%d bytes) is smaller than TCP header options (%d bytes)",
                     ppkt->Str(), cbDat, cbTcpHdr - sizeof(CTcpHdr));
            SgEventPacket(INVALID_IPSEC_PACKET_22, ppkt, pIpHdr->_ipaSrc, pXspHdr->_ipportSrc, sizeof(CTcpHdr), pTcpHdr);
            goto complete;
        }
    }

    if (ipportSrc == 0 || ipportSrc == 0xFFFF)
    {
        TraceSz(RecvDiscard, "%s #%d: invalid ipportSrc (%d)",
                 ppkt->Str(), dwSeq, NTOHS(ipportSrc));
        SgEventPacketLogNoisyEx(INVALID_IPSEC_PACKET_23, ppkt, pIpHdr->_ipaSrc, NTOHS(pXspHdr->_ipportSrc), 0, sizeof(CIpPort), &ipportSrc);
        goto complete;
    }

    pUdpHdr->_ipportSrc = g_fPortTranslation ? SgNatInfoLookupI(pNatInfo, ipportSrc, pDstInfo) : ipportSrc;
    pUdpHdr->_ipportDst = pDstTransInfo->_ipportZ;

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)ppkt->_pEnetHdr;
    *pcb++ = sizeof(CEnetHdr);
    *ppb++ = (BYTE *)pIpHdr;
    *pcb++ = sizeof(CIpHdr);

    if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
    {
        SgSetTcpHdrChecksum(pIpHdr, pTcpHdr, sizeof(CTcpHdr), pbDat, cbDat);
        *ppb++ = (BYTE *)pTcpHdr;
        *pcb++ = sizeof(CTcpHdr);
    }
    else
    {
        UINT cbUdpHdr = sizeof(CUdpHdr);

        if (fVdp)
        {
            *(WORD *)(pUdpHdr + 1) = (WORD) cbDat;
            cbUdpHdr += sizeof(WORD);
        }

        SgSetUdpHdrChecksum(pIpHdr, pUdpHdr, cbUdpHdr, pbDat, cbDat, pbVoi, cbVoi, NULL, 0, NULL, 0);
        *ppb++ = (BYTE *)pUdpHdr;
        *pcb++ = cbUdpHdr;
    }

    if (cbDat > 0)
    {
        *ppb++ = pbDat;
        *pcb++ = cbDat;
    }

    if (cbVoi > 0)
    {
        *ppb++ = pbVoi;
        *pcb++ = cbVoi;
    }

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

    if (Tag(SpiFlow))
    {
        if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
        {
            UINT cbOpt = pTcpHdr->_info.GetHdrLen() - sizeof(CTcpHdr);

            pbDat += cbOpt;
            cbDat -= cbOpt;

            TraceSz(SpiFlow, "#%d %08lX TCP %c%d/%c%d [%s:%d/%d %s:%d/%d] -> [%s:%d %s:%d] %c%c%c%c%c%c [%d] (+%d)",
                      ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv,
                      pTransInfoRecv ? (char)pTransInfoRecv->_dwType : 'L', pTransInfoRecv->_iTransInfo,
                      pTransInfoXmit ? (char)pTransInfoXmit->_dwType : 'L', pTransInfoXmit->_iTransInfo,
                      pSpiInfo->_ipaI.Str(), NTOHS(pSpiInfo->_ipportI), NTOHS(ipportSrc),
                      pTransInfoRecv->_ipa.Str(), NTOHS(pXspHdr->_ipportDst), NTOHS(ipportDst),
                      pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                      pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
                      pTcpHdr->_info._bFlags & TCP_FIN ? 'F' : '-', pTcpHdr->_info._bFlags & TCP_SYN ? 'S' : '-',
                      pTcpHdr->_info._bFlags & TCP_RST ? 'R' : '-', pTcpHdr->_info._bFlags & TCP_PSH ? 'P' : '-',
                      pTcpHdr->_info._bFlags & TCP_ACK ? 'A' : '-', pTcpHdr->_info._bFlags & TCP_URG ? 'U' : '-',
                      cbOpt, cbDat);

            if (cbOpt > 0)
            {
                TraceSz(SpiFlow, "#%d %08lX TCP OPTS: %s",
                        ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv,
                        SgHexDumpStr(pbDat - cbOpt, cbOpt));
            }

        }
        else
        {
            TraceSz(SpiFlow, "#%d %08lX %s %c%d/%c%d [%s:%d/%d %s:%d/%d] -> [%s:%d %s:%d] (+%d)",
                      ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv, fVdp ? "VDP" : "UDP",
                      pTransInfoRecv ? (char)pTransInfoRecv->_dwType : 'L', pTransInfoRecv->_iTransInfo,
                      pTransInfoXmit ? (char)pTransInfoXmit->_dwType : 'L', pTransInfoXmit->_iTransInfo,
                      pSpiInfo->_ipaI.Str(), NTOHS(pSpiInfo->_ipportI), NTOHS(ipportSrc),
                      pTransInfoRecv->_ipa.Str(), NTOHS(pXspHdr->_ipportDst), NTOHS(ipportDst),
                      pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                      pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
                      (fVdp ? sizeof(WORD) : 0) + cbDat + cbVoi);
        }

        SgHexDumpSpiFlow(ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv,
                         fVdp ? (BYTE *)(pUdpHdr + 1) : NULL, fVdp ? sizeof(WORD) : 0,
                         pbDat, cbDat, pbVoi, cbVoi);
    }

    //
    // Process packet statistics for instrusion detection, DoS prevention, reporting, etc.
    // Function should be very quick.
    //
    SgClientStatsProcessPacket(ppkt, pDstInfo);

    SgSpiInfoDetach(ppkt);
    pSpiInfo = NULL;

#ifdef SG_FEATURE_UDP_ECHO
    // For the stress test case, bypass the actual transmit and instead feed the packet
    // back into the SG, but only when sent to port 3076.
    if (pXspHdr->_ipportDst == XSP_PORT_XSPECHO)
    {
        SgDstInfoReadUnlock();
        pDstInfo = NULL;
        SgIRecvXspEcho(ppkt);
        return;
    }
#endif

#ifdef SG_FEATURE_ARP

    SgArpInfoLock();

    CArpInfo * pArpInfo = SgArpInfoLookup(pDstInfo, pTransInfoXmit);

    SgDstInfoReadUnlock();
    pDstInfo = NULL;

    if (pArpInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s #%d: ARP entry to ipportDst %d on Z%d not found",
                 ppkt->Str(), dwSeq, NTOHS(pUdpHdr->_ipportDst), pTransInfoXmit->_iTransInfo);
        // ARP code logs an event.

        SgArpInfoUnlock();
        goto complete;
    }

    // SgXmitWithArp will release ARP lock

    SgXmitWithArp(ppkt, pArpInfo);

#else // !SG_FEATURE_ARP

    SgDstInfoReadUnlock();
    pDstInfo = NULL;

    pEnetHdr->_eaDst.SetZero();

    SgXmit(ppkt);

#endif // SG_FEATURE_ARP

    return;

complete:

    if (pDstInfo != NULL)
    {
        SgDstInfoReadUnlock();
    }

    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgZRecv
//
// This function continues processing of a packet from SgRecv that arrives on a
// transport connected to the DMZ.
// ---------------------------------------------------------------------------------------

void SgZRecv(CPacket * ppkt)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;
    CEnetHdr *   pEnetHdr       = ppkt->_pEnetHdr;
    CIpHdr *     pIpHdr         = ppkt->_pIpHdr;
    BYTE *       pb             = ppkt->_pb;
    UINT         cb             = ppkt->_cb;
    CUdpHdr *    pUdpHdr        = ppkt->_pUdpHdr = (CUdpHdr *)pb;
    CTcpHdr *    pTcpHdr        = ppkt->_pTcpHdr = (CTcpHdr *)pb;
    DWORD        dwIpaDst       = NTOHL(pIpHdr->_ipaDst);

    if (    dwIpaDst < pTransInfoRecv->_dwIpaBeg
        ||  dwIpaDst > pTransInfoRecv->_dwIpaEnd)
    {
        TraceSz(RecvDiscard, "%s: ipaDst %s outside range for this transport %s thru %s",
                 ppkt->Str(), pIpHdr->_ipaDst.Str(),
                 CIpAddr(HTONL(pTransInfoRecv->_dwIpaBeg)).Str(),
                 CIpAddr(HTONL(pTransInfoRecv->_dwIpaEnd)).Str());
        SgEventPacket(INVALID_PACKETZ_0, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CIpHdr), pIpHdr);
        goto complete;
    }

    if (pIpHdr->_bProtocol == IPPROTOCOL_UDP)
    {
        if (cb < sizeof(CUdpHdr))
        {
            TraceSz(RecvDiscard, "%s: IP payload size (%d bytes) is smaller than CUdpHdr (%d bytes)",
                     ppkt->Str(), cb, sizeof(CUdpHdr));
            SgEventPacket(INVALID_PACKETZ_1, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CIpHdr) + cb, pIpHdr);
            goto complete;
        }

        if (NTOHS(pUdpHdr->_wLen) != cb)
        {
            TraceSz(RecvDiscard, "%s: UDP size in header (%d bytes) differs from IP payload size (%d bytes)",
                     ppkt->Str(), NTOHS(pUdpHdr->_wLen), cb);
            SgEventPacket(INVALID_PACKETZ_2, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, sizeof(CIpHdr) + sizeof(CUdpHdr), pIpHdr);
            goto complete;
        }

#ifdef SG_FEATURE_UDP_ECHO
        CUdpHdr* pUdpHdr = (CUdpHdr*)pb;

        if (pUdpHdr->_ipportDst == XSP_PORT_UDPECHO)
        {
            // Special UDP echo packet for stress test
            SgIRecvUdpEcho(ppkt);
            return;
        }
#endif

    }
    else if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
    {
        if (cb < sizeof(CTcpHdr))
        {
            TraceSz(RecvDiscard, "%s: IP payload size (%d bytes) is smaller than CTcpHdr (%d bytes)",
                     ppkt->Str(), cb, sizeof(CTcpHdr));
            SgEventPacket(INVALID_PACKETZ_3, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CIpHdr) + cb, pIpHdr);
            goto complete;
        }

        UINT cbTcpHdr = pTcpHdr->_info.GetHdrLen();

        if (cbTcpHdr < sizeof(CTcpHdr))
        {
            TraceSz(RecvDiscard, "%s: TCP header size (%d bytes) is smaller than CTcpHdr (%d bytes)",
                     ppkt->Str(), cbTcpHdr, sizeof(CTcpHdr));
            SgEventPacket(INVALID_PACKETZ_4, ppkt, pIpHdr->_ipaSrc, pTcpHdr->_ipportSrc, sizeof(CIpHdr) + cb, pIpHdr);
            goto complete;
        }

        if (cb < cbTcpHdr)
        {
            TraceSz(RecvDiscard, "%s: IP payload size (%d bytes) is smaller than TCP header size (%d bytes)",
                     ppkt->Str(), cb, cbTcpHdr);
            SgEventPacket(INVALID_PACKETZ_5, ppkt, pIpHdr->_ipaSrc, pTcpHdr->_ipportSrc, sizeof(CIpHdr) + cb, pIpHdr);
            goto complete;
        }
    }
    else if (pIpHdr->_bProtocol == IPPROTOCOL_ICMP)
    {
        SgIcmpRecv(ppkt);
        return;
    }
    else
    {
        TraceSz(RecvDiscard, "%s: IP packet has non-UDP/TCP/ICMP protocol (%d)", ppkt->Str(), pIpHdr->_bProtocol);
        SgEventPacket(INVALID_PACKETZ_6, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CIpHdr) + cb, pIpHdr);
        goto complete;
    }

    if (pUdpHdr->_ipportSrc == 0)
    {
        TraceSz(RecvDiscard, "%s: %s packet has invalid ipportSrc (%d)",
                 ppkt->Str(), pIpHdr->_bProtocol == IPPROTOCOL_TCP ? "TCP" : "UDP",
                 NTOHS(pUdpHdr->_ipportSrc));
        SgEventPacket(INVALID_PACKETZ_7, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, sizeof(CIpHdr) + cb, pIpHdr);
        goto complete;
    }

    // Handle traffic for the SGMSG port
    if (pUdpHdr->_ipportDst == 0xFFFF && pIpHdr->_bProtocol == IPPROTOCOL_UDP)
    {
        ppkt->_pb = (pb += sizeof(CUdpHdr));
        ppkt->_cb = (cb -= sizeof(CUdpHdr));
        SgZRecvSgMsg(ppkt);
        return;
    }

    WORD wIpportDst = NTOHS(pUdpHdr->_ipportDst);
    if (    wIpportDst < pTransInfoRecv->_wIpportBeg
        ||  wIpportDst > pTransInfoRecv->_wIpportEnd)
    {
        TraceSz(RecvDiscard, "%s: ipportDst %u outside range for this transport %u thru %u",
                 ppkt->Str(), wIpportDst,
                 pTransInfoRecv->_wIpportBeg,
                 pTransInfoRecv->_wIpportEnd);
        SgEventPacket(INVALID_PACKETZ_8, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, sizeof(CIpHdr) + cb, pIpHdr);
        goto complete;
    }

    CNatInfo * pNatInfo = SgNatInfoLookupZ(pTransInfoRecv, dwIpaDst, NTOHS(pUdpHdr->_ipportDst));

    if (pNatInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: %s packet from %s:%d to %s:%d cannot find CNatInfo",
                 ppkt->Str(), pIpHdr->_bProtocol == IPPROTOCOL_TCP ? "TCP" : "UDP",
                 pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                 pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst));
        SgZXmitRst(ppkt);
        return;
    }

    SgSpiInfoAttach(ppkt, SgZRecvWithSpi, pNatInfo->_dwSpi);
    return;

complete:
    ppkt->Complete();
    return;
}

void SgZRecvWithSpi(CPacket * ppkt)
{
    CSpiInfo *   pSpiInfo       = ppkt->_pSpiInfo;
    CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;
    CEnetHdr *   pEnetHdr       = ppkt->_pEnetHdr;
    CIpHdr *     pIpHdr         = ppkt->_pIpHdr;
    BYTE *       pb             = ppkt->_pb;
    UINT         cb             = ppkt->_cb;
    CUdpHdr *    pUdpHdr        = (CUdpHdr *)pb;
    CTcpHdr *    pTcpHdr        = (CTcpHdr *)pb;
    DWORD        dwIpaDst       = NTOHL(pIpHdr->_ipaDst);
    UINT         cbIpLen        = NTOHS(pIpHdr->_wLen);
    CIpPort      ipportSrc, ipportDst;

    if (pSpiInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: %s packet from %s:%d to %s:%d cannot find client mapping",
                 ppkt->Str(), pIpHdr->_bProtocol == IPPROTOCOL_TCP ? "TCP" : "UDP",
                 pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                 pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst));
        SgZXmitRst(ppkt);
        return;
    }

    BOOL    fVdpOnly;
#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
    BOOL    fArbitration;
#endif
    CIpPort ipportI;

    {
        SgDstInfoReadLock();

        CDstInfo * pDstInfo = SgDstInfoLookup(pTransInfoRecv, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc);


        if (pDstInfo == NULL)
        {
            SgDstInfoReadUnlock();

            TraceSz(RecvDiscard, "%s: %s packet from %s:%d cannot find CDstInfo",
                     ppkt->Str(), pIpHdr->_bProtocol == IPPROTOCOL_TCP ? "TCP" : "UDP",
                     pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc));
            SgEventPacket(INVALID_PACKETZ_9, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cbIpLen, pIpHdr);
            SgZXmitRst(ppkt);
            return;
        }

        fVdpOnly = pDstInfo->_fVdpOnly;
#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
        fArbitration = pDstInfo->_fArbitration;
#endif
        ipportI  = pDstInfo->_ipportI;

        SgDstInfoReadUnlock();
    }

    if (fVdpOnly)
    {
        if (pIpHdr->_bProtocol != IPPROTOCOL_UDP)
        {
            TraceSz(RecvDiscard, "%s: %s packet from %s:%d protocol prohibited from accessing ipportDst %d",
                     ppkt->Str(), pIpHdr->_bProtocol == IPPROTOCOL_TCP ? "TCP" : "UDP",
                     pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc), NTOHS(ipportI));
            SgEventPacket(INVALID_PACKETZ_10, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cbIpLen, pIpHdr);
            SgZXmitRst(ppkt);
            return;
        }

        if (cb < sizeof(CUdpHdr) + sizeof(WORD))
        {
            TraceSz(RecvDiscard, "%s: VDP packet from %s:%d message size is too small (%d bytes)",
                     ppkt->Str(), pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc), cb - sizeof(CUdpHdr));
            SgEventPacket(INVALID_PACKETZ_11, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cbIpLen, pIpHdr);
            SgZXmitRst(ppkt);
            return;
        }

        UINT cbDat = *(WORD *)(pb + sizeof(CUdpHdr));

        if (cb < sizeof(CUdpHdr) + sizeof(WORD) + cbDat)
        {
            TraceSz(RecvDiscard, "%s: VDP packet from %s:%d cbDat (%d bytes) is too large (%d message bytes)",
                     ppkt->Str(), pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc), cbDat, cb - sizeof(CUdpHdr));
            SgEventPacket(INVALID_PACKETZ_12, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cbIpLen, pIpHdr);
            SgZXmitRst(ppkt);
            return;
        }

        pIpHdr->_bProtocol = IPPROTOCOL_VDP;
    }

    if (pSpiInfo->_qwTickRecv == 0)
    {
        TraceSz(RecvDiscard, "%s: %s packet from %s:%d before key-exchange has been acknowledged",
                 ppkt->Str(), pIpHdr->_bProtocol == IPPROTOCOL_TCP ? "TCP" : pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "VDP",
                 pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc));
        SgZXmitRst(ppkt);
        return;
    }

    // Rewrite the UDP/TCP ports based on the CDstInfo and CNatInfo (if necessary)

    ipportSrc = pUdpHdr->_ipportSrc;
    ipportDst = pUdpHdr->_ipportDst;

    if (g_fPortTranslation)
    {
        CNatInfo * pNatInfo = pSpiInfo->_pNatInfo;
        UINT       iNatPort = NTOHS(pUdpHdr->_ipportDst) - pNatInfo->_iBasePortZ;
        CNatPort * pNatPort = iNatPort >= g_cPortsPerNatInfo ? NULL : &pNatInfo->_pNatPort[iNatPort];

        // Should never be NULL, since iNatPort can never really be >= to
        // g_cPortsPerNatInfo (it would have mapped to another SPI otherwise). But _ipporI
        // being 0 indicates it is unallocated, which is what this check used to be before
        // we deprecated _cNatPort.

        if (pNatPort == NULL ||
            pNatPort->_ipportI == 0)
        {
            TraceSz(RecvDiscard, "%s: %s packet from %s:%d to %s:%d cannot find port mapping",
                     ppkt->Str(), pIpHdr->_bProtocol == IPPROTOCOL_TCP ? "TCP" : pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "VDP",
                     pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                     pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst));
            SgZXmitRst(ppkt);
            return;
        }

        pUdpHdr->_ipportDst = pNatPort->_ipportI;
        pNatPort->_qwTick   = SgTimerTick();
    }

#ifdef SG_FEATURE_ARBITRATION_WORKAROUND
    if( fArbitration )
    {
        pUdpHdr->_ipportSrc = pSpiInfo->_ipportLastArbitration;
    }
    else
#endif
    {
        pUdpHdr->_ipportSrc = ipportI;
    }

    if (Tag(SpiFlow))
    {
        CTransInfo * pTransInfoXmit = pSpiInfo->_pTransInfo;
        BYTE *       pbDat;
        UINT         cbDat;

        if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
        {
            UINT cbOpt = pTcpHdr->_info.GetHdrLen() - sizeof(CTcpHdr);

            pbDat = pb + sizeof(CTcpHdr) + cbOpt;
            cbDat = cb - sizeof(CTcpHdr) - cbOpt;

            TraceSz(SpiFlow, "#%d %08lX TCP %c%d/%c%d [%s:%d %s:%d] -> [%s:%d/%d %s:%d/%d] %c%c%c%c%c%c [%d] (+%d)",
                      ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv,
                      pTransInfoRecv ? (char)pTransInfoRecv->_dwType : 'L', pTransInfoRecv->_iTransInfo,
                      pTransInfoXmit ? (char)pTransInfoXmit->_dwType : 'L', pTransInfoXmit->_iTransInfo,
                      pIpHdr->_ipaSrc.Str(), NTOHS(ipportSrc),
                      pIpHdr->_ipaDst.Str(), NTOHS(ipportDst),
                      pTransInfoXmit->_ipa.Str(), NTOHS(XSP_PORT), NTOHS(pUdpHdr->_ipportSrc),
                      pSpiInfo->_ipaI.Str(), NTOHS(pSpiInfo->_ipportI), NTOHS(pUdpHdr->_ipportDst),
                      pTcpHdr->_info._bFlags & TCP_FIN ? 'F' : '-', pTcpHdr->_info._bFlags & TCP_SYN ? 'S' : '-',
                      pTcpHdr->_info._bFlags & TCP_RST ? 'R' : '-', pTcpHdr->_info._bFlags & TCP_PSH ? 'P' : '-',
                      pTcpHdr->_info._bFlags & TCP_ACK ? 'A' : '-', pTcpHdr->_info._bFlags & TCP_URG ? 'U' : '-',
                      cbOpt, cbDat);

            if (cbOpt > 0)
            {
                TraceSz(SpiFlow, "#%d %08lX TCP OPTS: %s",
                        ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv,
                        SgHexDumpStr(pbDat - cbOpt, cbOpt));
            }

        }
        else
        {
            pbDat = pb + sizeof(CUdpHdr);
            cbDat = cb - sizeof(CUdpHdr);

            TraceSz(SpiFlow, "#%d %08lX %s %c%d/%c%d [%s:%d %s:%d] -> [%s:%d/%d %s:%d/%d] (+%d)",
                      ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv, pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "VDP",
                      pTransInfoRecv ? (char)pTransInfoRecv->_dwType : 'L', pTransInfoRecv->_iTransInfo,
                      pTransInfoXmit ? (char)pTransInfoXmit->_dwType : 'L', pTransInfoXmit->_iTransInfo,
                      pIpHdr->_ipaSrc.Str(), NTOHS(ipportSrc),
                      pIpHdr->_ipaDst.Str(), NTOHS(ipportDst),
                      pTransInfoXmit->_ipa.Str(), NTOHS(XSP_PORT), NTOHS(pUdpHdr->_ipportSrc),
                      pSpiInfo->_ipaI.Str(), NTOHS(pSpiInfo->_ipportI), NTOHS(pUdpHdr->_ipportDst),
                      cbDat);
        }

        SgHexDumpSpiFlow(ppkt->_dwPktNum, pSpiInfo->_dwSpiRecv, pbDat, cbDat, NULL, 0, NULL, 0);
    }

    SgIXmitWithSpi(ppkt);

    return;
}

// ---------------------------------------------------------------------------------------
// SgZRecvSgMsg
//
// This function continues processing of SgMsg packet from the DMZ
// ---------------------------------------------------------------------------------------

void SgZRecvSgMsg(CPacket * ppkt)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CTransInfo *    pTransInfoRecv  = ppkt->_pTransInfoRecv;
    CEnetHdr *      pEnetHdr        = ppkt->_pEnetHdr;
    CIpHdr *        pIpHdr          = ppkt->_pIpHdr;
    CUdpHdr *       pUdpHdr         = ppkt->_pUdpHdr;
    BYTE *          pb              = ppkt->_pb;
    UINT            cb              = ppkt->_cb;

    CSgMsgHdr * pSgMsgHdr = (CSgMsgHdr *)pb;

    SgPerfdataInc(SgMsg, 1);

    if (cb < sizeof(CSgMsgHdr) || cb != pSgMsgHdr->_cbEnt)
    {
        TraceSz(RecvDiscard, "%s: SgMsg packet has wrong size (UDP %d, cbEnt %d)",
                 ppkt->Str(), cb, cb < sizeof(CSgMsgHdr) ? 0 : pSgMsgHdr->_cbEnt);
        SgEventPacket(INVALID_SGMSG_0, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cb, pb);
        goto complete;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_SPIDATA_REQ ||
        pSgMsgHdr->_wType == SGMSG_TYPE_SPIDATA_REQ2)
    {
        if (pSgMsgHdr->_cbEnt < sizeof(CSgMsgSpiReq))
        {
            TraceSz(RecvDiscard, "%s: SgMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), pSgMsgHdr->_cbEnt);
            SgEventPacket(INVALID_SGMSG_2, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cb, pb);
            goto complete;
        }

        // These two requests are the same, except REQ2 adds an extra field at the end. We 
        // don't care about that extra field yet.
        C_ASSERT(offsetof(CSgMsgSpiReq, _ipaZ) == offsetof(CSgMsgSpiReq2, _ipaZ));
        C_ASSERT(offsetof(CSgMsgSpiReq, _ipportZ) == offsetof(CSgMsgSpiReq2, _ipportZ));

        CSgMsgSpiReq * pSgMsgSpiReq = (CSgMsgSpiReq *)pb;

        CNatInfo * pNatInfo = SgNatInfoLookupZ(pTransInfoRecv, NTOHL(pSgMsgSpiReq->_ipaZ.s_addr), NTOHS(pSgMsgSpiReq->_ipportZ));

        SgSpiInfoAttach(ppkt, SgZRecvSgMsgWithSpi, pNatInfo ? pNatInfo->_dwSpi : 0);
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_KICK_REQ)
    {
        if (pSgMsgHdr->_cbEnt < sizeof(CSgMsgKickReq))
        {
            TraceSz(RecvDiscard, "%s: SgMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), pSgMsgHdr->_cbEnt);
            SgEventPacket(INVALID_SGMSG_3, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cb, pb);
            goto complete;
        }

        CSgMsgKickReq * pSgMsgKickReq = (CSgMsgKickReq *)pSgMsgHdr;
        SgSpiInfoAttach(ppkt, SgZRecvSgMsgWithSpi, pSgMsgKickReq->_sgaddr.dwSpiSg);
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_SET_QVALS_LAZY || pSgMsgHdr->_wType == SGMSG_TYPE_SET_QVALS_PUSH)
    {
        if (      pSgMsgHdr->_cbEnt < sizeof(CSgMsgSetQValsReq)
             || ((pSgMsgHdr->_cbEnt - sizeof(CSgMsgSetQValsReq)) % sizeof(DWORD)) != 0)
        {
            TraceSz(RecvDiscard, "%s: SgMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), pSgMsgHdr->_cbEnt);
            SgEventPacket(INVALID_SGMSG_5, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cb, pb);
            goto complete;
        }

        CSgMsgSetQValsReq * pSgMsgSetQValsReq = (CSgMsgSetQValsReq *)pSgMsgHdr;
        SgSpiInfoAttach(ppkt, SgZRecvSgMsgWithSpi, pSgMsgSetQValsReq->_sgaddr.dwSpiSg);
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_XBTOXB_FORWARD && g_fEnableConnectionServices)
    {
        if (pSgMsgHdr->_cbEnt < sizeof(CSgMsgXbToXbForward))
        {
            TraceSz(RecvDiscard, "%s: SgMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), pSgMsgHdr->_cbEnt);
            SgEventPacket(INVALID_SGMSG_6, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cb, pb);
            goto complete;
        }

        CSgMsgXbToXbForward * pSgMsgXbToXbForward = (CSgMsgXbToXbForward *)pSgMsgHdr;
        SgSpiInfoAttach(ppkt, SgZRecvSgMsgWithSpi, pSgMsgXbToXbForward->_sgaddr.dwSpiSg);
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_XBTOXB_FORWARD2 && g_fEnableConnectionServices)
    {
        if (pSgMsgHdr->_cbEnt < sizeof(CSgMsgXbToXbForward2))
        {
            TraceSz(RecvDiscard, "%s: SgMsg %04X/%s has incorrect payload size (%d bytes)",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), pSgMsgHdr->_cbEnt);
            SgEventPacket(INVALID_SGMSG_9, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cb, pb);
            goto complete;
        }

        CSgMsgXbToXbForward2 * pSgMsgXbToXbForward2 = (CSgMsgXbToXbForward2 *)pSgMsgHdr;
        SgSpiInfoAttach(ppkt, SgZRecvSgMsgWithSpi, pSgMsgXbToXbForward2->_sgaTarget.dwSpiSg);
        return;
    }

    TraceSz(RecvDiscard, "%s: SgMsg %04X/%s not supported (payload %d bytes)",
             ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), ppkt->_cb);
    SgEventPacket(INVALID_SGMSG_7, ppkt, pIpHdr->_ipaSrc, pUdpHdr->_ipportSrc, cb, pb);
    goto complete;

complete:
    SgPerfdataInc(SgMsgInvalid, 1);
    ppkt->Complete();
    return;
}

void SgZRecvSgMsgWithSpi(CPacket * ppkt)
{
    CSpiInfo *  pSpiInfo    = ppkt->_pSpiInfo;
    CSgMsgHdr * pSgMsgHdr   = (CSgMsgHdr *)ppkt->_pb;

    if (Tag(SpiFlow))
    {
        CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;

        DWORD   dwSpiRecv   = pSpiInfo ? pSpiInfo->_dwSpiRecv : 0;
        CIpAddr ipaSrc      = ppkt->_pIpHdr->_ipaSrc;
        CIpPort ipportSrc   = ppkt->_pUdpHdr->_ipportSrc;

        TraceSz(SpiFlow, "#%d %08lX SGMSG << %c%d [%s:%d %s:%d] %04X/%s (+%d)",
                  ppkt->_dwPktNum, dwSpiRecv, pTransInfoRecv->_dwType, pTransInfoRecv->_iTransInfo,
                  ipaSrc.Str(), NTOHS(ipportSrc), pTransInfoRecv->_ipa.Str(), 0xFFFF,
                  pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), ppkt->_cb - sizeof(CSgMsgHdr));

        SgHexDumpSpiFlow(ppkt->_dwPktNum, dwSpiRecv, ppkt->_pb + sizeof(CSgMsgHdr), ppkt->_cb - sizeof(CSgMsgHdr), NULL, 0, NULL, 0);
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_SPIDATA_REQ ||
        pSgMsgHdr->_wType == SGMSG_TYPE_SPIDATA_REQ2)
    {
        // These two requests are the same, except REQ2 adds an extra field at the end. We 
        // don't care about that extra field just yet, so treat them the same.

        CSgMsgSpiReq * pSgMsgSpiReq = (CSgMsgSpiReq *)pSgMsgHdr;
        CSgMsgSpiRep * pSgMsgSpiRep = (CSgMsgSpiRep *)ppkt->_abCtx;
        BOOL           fFound       = (pSpiInfo != NULL);
        UINT           cbRep        = sizeof(CSgMsgSpiRep);
        WORD           wTypeRep     = SGMSG_TYPE_SPIDATA_REP;

        pSgMsgSpiRep->_wType        = wTypeRep;
        pSgMsgSpiRep->_cbEnt        = sizeof(CSgMsgSpiRep);
        pSgMsgSpiRep->_dwReqNum     = pSgMsgSpiReq->_dwReqNum;
        pSgMsgSpiRep->_ipaZ         = pSgMsgSpiReq->_ipaZ;
        pSgMsgSpiRep->_ipportZ      = pSgMsgSpiReq->_ipportZ;
        pSgMsgSpiRep->_fNotFound    = !fFound;

        if (fFound)
        {
            cbRep += sizeof(CSgMsgSpiData);

            CSgMsgSpiData* pSgMsgSpiData   = (CSgMsgSpiData*)( pSgMsgSpiRep + 1 );
            pSgMsgSpiData->_wType           = SGMSG_TYPE_SPIDATA;
            pSgMsgSpiData->_cbEnt           = sizeof( *pSgMsgSpiData );
            pSgMsgSpiData->_ipportI         = pSpiInfo->_ipportI;
            pSgMsgSpiData->_ipaI            = pSpiInfo->_ipaI;
            pSgMsgSpiData->_wVersionKeyEx   = pSpiInfo->_wVersionInit;
            pSgMsgSpiData->_wFlagsKeyEx     = pSpiInfo->_wFlagsInit;
            pSgMsgSpiData->_liTimeInit.QuadPart = pSpiInfo->_qwTimeInit;
            pSgMsgSpiData->_fCs             = pSpiInfo->_fCs;

            C_ASSERT(sizeof(LARGE_INTEGER) == sizeof(pSpiInfo->_abNonceResp));
            memcpy(&pSgMsgSpiData->_liNonce, &pSpiInfo->_abNonceResp, sizeof(LARGE_INTEGER));
            SgSpiInfoToSgAddr(pSpiInfo, &pSgMsgSpiData->_sgaddr);

            // Determine desired authdata version vs the version we have. If we receive 
            // the old protocol request, then we're going to assume the caller only 
            // understands Authdata v3.
            WORD wHaveAuthDataVersion = pSpiInfo->_AuthData.wAuthDataVersion;
            WORD wWantAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;

            // Latest version assert. Bump this up if we make an AuthdataV5.
            ASSERT(wHaveAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION);

            if (pSgMsgHdr->_wType == SGMSG_TYPE_SPIDATA_REQ2)
            {
                CSgMsgSpiReq2 * pSgMsgSpiReq2 = (CSgMsgSpiReq2 *)pSgMsgHdr;
                wWantAuthDataVersion = pSgMsgSpiReq2->_wAuthDataVersion;

                // Is requestor asking for something newer that we don't understand?
                if (wWantAuthDataVersion > wHaveAuthDataVersion)
                {
                    wWantAuthDataVersion = wHaveAuthDataVersion;
                }
            }

            if (wWantAuthDataVersion == wHaveAuthDataVersion)
            {
                CSgMsgHdr * pSgMsgHdrAuth = (CSgMsgHdr *)(pSgMsgSpiData + 1);

                pSgMsgHdrAuth->_wType = SGMSG_TYPE_AUTHDATA;
                pSgMsgHdrAuth->_cbEnt = sizeof(CSgMsgHdr) + sizeof(pSpiInfo->_AuthData);
                cbRep += pSgMsgHdrAuth->_cbEnt;

                memcpy( pSgMsgHdrAuth + 1, &pSpiInfo->_AuthData, sizeof( pSpiInfo->_AuthData ) );
            }
            else
            {
                // Mismatch in want vs have. Deal with it.
                SgPerfdataInc(SgMsgSpiData2Backcompat, 1);

                // No one should request anything older than v3, v4 is handled above, and 
                // v5 doesn't exist. If we rev again we can make this smarter.
                if (wWantAuthDataVersion == XONLINE_XENON_AUTHDATA_VERSION)
                {

                    CSgMsgHdr * pSgMsgHdrAuth = (CSgMsgHdr *)(pSgMsgSpiData + 1);
                    pSgMsgHdrAuth->_wType = SGMSG_TYPE_AUTHDATA;

                    // Deliver XKERB_AD_XENON (v3) to requestor

#ifdef SG_FEATURE_SGINFO_BACKCOMPAT_CACHE
                    C_ASSERT(sizeof(pSpiInfo->_AuthDataV3) == sizeof(XKERB_AD_XENON));

                    // We've pre-calculated the structure, so just memcpy it.
                    pSgMsgHdrAuth->_cbEnt = sizeof(CSgMsgHdr) + sizeof(pSpiInfo->_AuthDataV3);
                    memcpy( pSgMsgHdrAuth + 1, &pSpiInfo->_AuthDataV3, sizeof( pSpiInfo->_AuthDataV3 ) );
#else
                    // Need to compute the new structure on-the-fly.
                    pSgMsgHdrAuth->_cbEnt = sizeof(CSgMsgHdr) + sizeof(XKERB_AD_XENON);
                    SgConvertAuthData4ToAuthData3(&pSpiInfo->_AuthData, pSgMsgHdrAuth + 1);
#endif
                    cbRep += pSgMsgHdrAuth->_cbEnt;
                }
                else
                {
                    // Well, we don't support anything else right now, and in fact this 
                    // should never happen. 
                    SgPerfdataInc(SgMsgInvalid, 1);
                    TraceSz(RecvDiscard, "%s: SgMsg %04X/%s not supported, authdata version %d invalid",
                            ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), wWantAuthDataVersion);
                    // @@@ TODO do we need to call SgSpiInfoDetach() here?? I think so.
                    SgSpiInfoDetach(ppkt);
                    pSpiInfo = NULL;
                    goto complete;
                }
                    
            }

        }
        else
        {
            SgPerfdataInc(SgMsgNoMatch, 1);
        }

        if (pSgMsgHdr->_wType == SGMSG_TYPE_SPIDATA_REQ2)
        {
            SgPerfdataInc(SgMsgSpiData2, 1);
        }
        // We always have to bump this up, because we made a counter under the Global 
        // category and called it "Autdata Requests Received/sec". By that definition, 
        // both types apply. 
        SgPerfdataInc(SgMsgSpiData, 1);

        SgSpiInfoDetach(ppkt);
        SgZXmitSgMsgRep(ppkt, pSgMsgSpiRep, cbRep);
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_KICK_REQ)
    {
        CSgMsgKickReq * pSgMsgKickReq = (CSgMsgKickReq *)pSgMsgHdr;

        if (pSpiInfo && !SgSpiInfoMatchesSgAddr(pSpiInfo, &pSgMsgKickReq->_sgaddr))
        {
            SgSpiInfoDetach(ppkt);
            pSpiInfo = NULL;
        }

        CSgMsgKickRep * pSgMsgKickRep = (CSgMsgKickRep *)ppkt->_abCtx;
        pSgMsgKickRep->_wType         = SGMSG_TYPE_KICK_REP;
        pSgMsgKickRep->_cbEnt         = sizeof(CSgMsgKickRep);
        pSgMsgKickRep->_sgaddr        = pSgMsgKickReq->_sgaddr;
        pSgMsgKickRep->_fNotFound     = pSpiInfo == NULL;

        if (pSpiInfo != NULL)
        {
            SgSpiInfoKick(pSpiInfo, SECMSG_DELETE_KICK, SPIDEL_KICK);
            SgSpiInfoDetach(ppkt);
            pSpiInfo = NULL;
        }
        else
        {
            SgPerfdataInc(SgMsgNoMatch, 1);
        }
        SgPerfdataInc(SgMsgKick, 1);

        SgZXmitSgMsgRep(ppkt, pSgMsgKickRep, sizeof(CSgMsgKickRep));
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_SET_QVALS_LAZY || pSgMsgHdr->_wType == SGMSG_TYPE_SET_QVALS_PUSH)
    {
        CSgMsgSetQValsReq * pSgMsgSetQValsReq = (CSgMsgSetQValsReq *)pSgMsgHdr;

        if (pSpiInfo == NULL || !SgSpiInfoMatchesSgAddr(pSpiInfo, &pSgMsgSetQValsReq->_sgaddr))
        {
            TraceSz(Warning, "%s: SgMsg %04X/%s cannot find SGADDR %s",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType),
                     SgHexStr(&pSgMsgSetQValsReq->_sgaddr, sizeof(pSgMsgSetQValsReq->_sgaddr)));

            if (pSpiInfo != NULL)
            {
                SgSpiInfoDetach(ppkt);
                pSpiInfo = NULL;
            }
        }

        CSgMsgSetQValsRep * pSgMsgSetQValsRep  = (CSgMsgSetQValsRep *)ppkt->_abCtx;
        pSgMsgSetQValsRep->_wType              = SGMSG_TYPE_SET_QVALS_REP;
        pSgMsgSetQValsRep->_cbEnt              = sizeof(CSgMsgSetQValsRep);
        pSgMsgSetQValsRep->_sgaddr             = pSgMsgSetQValsReq->_sgaddr;
        pSgMsgSetQValsRep->_qwUserId           = pSgMsgSetQValsReq->_qwUserId;
        pSgMsgSetQValsRep->_dwContext          = pSgMsgSetQValsReq->_dwContext;
        pSgMsgSetQValsRep->_fNotFound          = pSpiInfo == NULL;
        pSgMsgSetQValsRep->_fNoSuchUser        = TRUE;

        if (pSpiInfo != NULL)
        {
            CUserInfo * pUserInfo     = pSpiInfo->_aUserInfo;
            CUserInfo * pUserInfoEnd  = pUserInfo + dimensionof(pSpiInfo->_aUserInfo);

            for (; pUserInfo < pUserInfoEnd; ++pUserInfo)
            {
                if (pUserInfo->_qwUserId == pSgMsgSetQValsReq->_qwUserId)
                {
                    pSgMsgSetQValsRep->_fNoSuchUser = FALSE;

                    CQVal * pQValSrc = (CQVal *)(pSgMsgSetQValsReq + 1);
                    UINT    cQValSrc = (pSgMsgSetQValsReq->_cbEnt - sizeof(CSgMsgSetQValsReq)) / sizeof(CQVal);

                    while (cQValSrc > 0)
                    {
                        UINT    iQVal    = QVAL_INDEX(pQValSrc->_dw);
                        UINT    cQVal    = 1 + QVAL_DSIZE(pQValSrc->_dw);
                        CQVal * pQValDst = &pUserInfo->_aQVal[iQVal];
                        DWORD   dwSeqSrc = QVAL_SEQ(pQValSrc->_dw);

                        if (cQVal > cQValSrc)
                            break;

                        if (dwSeqSrc == 0 || iQVal + cQVal > dimensionof(pUserInfo->_aQVal))
                        {
                            TraceSz(Warning, "%s: SgMsg %04X/%s aQValSrc[%d]=%08lX is invalid (%d,%d)",
                                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType),
                                     pQValSrc - (CQVal *)(pSgMsgSetQValsReq + 1), pQValSrc->_dw,
                                     dwSeqSrc == 0, iQVal + cQVal > dimensionof(pUserInfo->_aQVal));
                        }
                        else if (dwSeqSrc > QVAL_SEQ(pQValDst->_dw))
                        {
                            memcpy(pQValDst, pQValSrc, cQVal * sizeof(CQVal));
                            pUserInfo->_dwQValModified |= (1 << iQVal);
                            pSpiInfo->_fSgToXbPulse = TRUE;
                        }

                        pQValSrc += cQVal;
                        cQValSrc -= cQVal;
                    }
                }
            }

            if (pSgMsgSetQValsRep->_fNoSuchUser)
            {
                TraceSz(Warning, "%s: SgMsg %04X/%s cannot find user %s",
                         ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType),
                         SgHexStr(&pSgMsgSetQValsReq->_qwUserId, sizeof(pSgMsgSetQValsReq->_qwUserId)));
            }

            if (pSgMsgHdr->_wType == SGMSG_TYPE_SET_QVALS_PUSH && pSpiInfo->_fSgToXbPulse)
            {
                SgIXmitSecMsgSgToXbPulse(pSpiInfo, NULL);
            }

            SgSpiInfoDetach(ppkt);
            pSpiInfo = NULL;
        }
        else
        {
            SgPerfdataInc(SgMsgNoMatch, 1);
        }

        if (pSgMsgHdr->_wType == SGMSG_TYPE_SET_QVALS_PUSH)
            SgPerfdataInc(SgMsgQvalsPush, 1);
        else
            SgPerfdataInc(SgMsgQvalsLazy, 1);

        SgZXmitSgMsgRep(ppkt, pSgMsgSetQValsRep, sizeof(CSgMsgSetQValsRep));
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_XBTOXB_FORWARD && g_fEnableConnectionServices)
    {
        CSgMsgXbToXbForward * pSgMsgXbToXbForward = (CSgMsgXbToXbForward *)pSgMsgHdr;

        SgPerfdataInc(SgMsgForward, 1);

        if (!pSpiInfo || !SgSpiInfoMatchesSgAddr(pSpiInfo, &pSgMsgXbToXbForward->_sgaddr))
        {
            TraceSz(RecvDiscard, "%s: SgMsg %04X/%s cannot find SGADDR %s",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType),
                     SgHexStr(&pSgMsgXbToXbForward->_sgaddr, sizeof(pSgMsgXbToXbForward->_sgaddr)));

            SgPerfdataInc(SgMsgNoMatch, 1);
            goto complete;
        }

        // There is an assumption here that the layout of CSecMsgHdr and CSgMsgHdr is the same,
        // and that a CSgMsgXbToXbForward is the same as a CSecMsgXbToXbForward.

        pSgMsgXbToXbForward->_wType = SECMSG_TYPE_XBTOXB_FORWARD;
        SgIXmitSecMsgWithSpi(ppkt);
        return;
    }

    if (pSgMsgHdr->_wType == SGMSG_TYPE_XBTOXB_FORWARD2 && g_fEnableConnectionServices)
    {
        CSgMsgXbToXbForward2 * pSgMsgXbToXbForward2 = (CSgMsgXbToXbForward2 *)pSgMsgHdr;

        SgPerfdataInc(SgMsgForward2, 1);

        if (!pSpiInfo || !SgSpiInfoMatchesSgAddr(pSpiInfo, &pSgMsgXbToXbForward2->_sgaTarget))
        {
            TraceSz(RecvDiscard, "%s: SgMsg %04X/%s cannot find SGADDR %s",
                     ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType),
                     SgHexStr(&pSgMsgXbToXbForward2->_sgaTarget, sizeof(pSgMsgXbToXbForward2->_sgaTarget)));

            SgPerfdataInc(SgMsgNoMatch, 1);
            goto complete;
        }

        // There is an assumption here that the layout of CSecMsgHdr and CSgMsgHdr is the same,
        // and that a CSgMsgXbToXbForward2 is the same as a CSecMsgXbToXbForward2.
        C_ASSERT(sizeof(CSgMsgXbToXbForward2) == sizeof(CSecMsgXbToXbForward2));

        pSgMsgXbToXbForward2->_wType = SECMSG_TYPE_XBTOXB_FORWARD2;
        SgIXmitSecMsgWithSpi(ppkt);
        return;
    }

    TraceSz(RecvDiscard, "%s: SgMsg %04X/%s not supported (payload %d bytes)",
             ppkt->Str(), pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), ppkt->_cb);
    SgEventPacket(INVALID_SGMSG_8, ppkt, ppkt->_pIpHdr->_ipaSrc, ppkt->_pUdpHdr->_ipportSrc, ppkt->_cb, ppkt->_pb);
    goto complete;

complete:
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgRecvInit
// ---------------------------------------------------------------------------------------

BOOL SgRecvInit()
{
    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// SgRecvConfig
// ---------------------------------------------------------------------------------------

BOOL SgRecvConfig(CCfgInfo * pci)
{
    CIpAddr ipa;

    UINT fDefaultKeyExDontSendIcmp;

#ifdef SG_FEATURE_LSP
    fDefaultKeyExDontSendIcmp = 1;
#else
    fDefaultKeyExDontSendIcmp = 0;
#endif

    // Read the settings
    if(!pci->GetVar("IpHdrTos", &g_iIpHdrTos, 0, 255, 0) ||
       !pci->GetVar("IpHdrTtl", &g_iIpHdrTtl, 0, 255, 64) ||
       !pci->GetVar("XbToSgReplayWindow", &g_iXspReplayWindow, 1, 0x7FFF, 4096) ||
       !pci->GetVar("KerberosApReqDeltaInMinutes", &g_iKerbApReqTimeDeltaLimitInMinutes, 1, 24*60, 5) ||
       !pci->GetVar("DesKeySize", &g_cbKeyDes, 8, 24, 24) ||
       !pci->GetVar("AesMinClientVersionXbox360", &g_dwAesMinClientVersionXbox360, 0, 0xFFFFFFFF, 0x201C6100) ||  // 02.00.7265.00
       !pci->GetVar("AesMinClientVersionPc", &g_dwAesMinClientVersionPc, 0, 0xFFFFFFFF, 0x20021D00) ||            // 02.00.0541.00
       !pci->GetVar("AesProtocolEnabled", (DWORD*)&g_fAesProtocolEnabled, 0, 1, 1) ||
       !pci->GetVar("KeyExMinRetryInMs", &g_iKeyExMinRetryInterval, 0, 5000, 1000) ||
       !pci->GetVar("KeyExXbToSgInitMinSize", &g_cbKeyExXbToSgInitMin, 0, 1500, 1332) ||
       !pci->GetVar("KeyExDontSendIcmp", (UINT *)&g_fKeyExDontSendIcmp, 0, 1, fDefaultKeyExDontSendIcmp) ||
       !pci->GetIpAddr("KeyExIcmpVip", &ipa, FALSE, TRUE))
    {
        return FALSE;
    }

    // Adjust
    g_ipaKeyExIcmpVip = ipa;
    g_iKeyExMinRetryInterval *= 10000;

    if (g_cbKeyDes != XC_SERVICE_DES_KEYSIZE && g_cbKeyDes != XC_SERVICE_DES3_KEYSIZE)
    {
        g_cbKeyDes = XC_SERVICE_DES3_KEYSIZE;
    }


#ifdef SG_FEATURE_TRACE
    if(!pci->GetVar("SpiFlowDataLimit", &g_cbSpiFlowData, 0, 1500, 0))
    {
        return FALSE;
    }
#endif

    // Trace
    TraceSz( Config, "SgRecvConfig:");
    TraceSz(Config, "    Configured IP Header TOS to %d", g_iIpHdrTos);
    TraceSz(Config, "    Configured IP Header TTL to %d", g_iIpHdrTtl);
    TraceSz(Config, "    Configured XSP replay window to %d", g_iXspReplayWindow);
    TraceSz(Config, "    Configured Kerberos AP Request Time Delta Limit to %d hrs %d min",
             g_iKerbApReqTimeDeltaLimitInMinutes / 60, g_iKerbApReqTimeDeltaLimitInMinutes % 60);


    TraceSz(Config, "    Configured DES key size to %d bytes", g_cbKeyDes);

    XBOX_LIBRARY_VERSION xlv = DWORD_TO_CLIENTVERSION(g_dwAesMinClientVersionXbox360);
    TraceSz(Config, "    Minimum client version that supports AES (Xbox360): 0x%08X (%d.%d.%d.%d)",
             g_dwAesMinClientVersionXbox360, xlv.wMajorVersion, xlv.wMinorVersion, xlv.wBuildNumber, xlv.wQFENumber);
    XBOX_LIBRARY_VERSION xlv2 = DWORD_TO_CLIENTVERSION(g_dwAesMinClientVersionPc);
    TraceSz(Config, "    Minimum client version that supports AES (PC): 0x%08X (%d.%d.%d.%d)",
             g_dwAesMinClientVersionPc, xlv2.wMajorVersion, xlv2.wMinorVersion, xlv2.wBuildNumber, xlv2.wQFENumber);
    TraceSz(Config, "    AES Protocol %s enabled", g_fAesProtocolEnabled ? "is" : "is not");

    TraceSz(Config, "    Configured KeyExMinRetryInMs to %d ms (%ld 100ns periods)",
             g_iKeyExMinRetryInterval / 10000, g_iKeyExMinRetryInterval);
    TraceSz(Config, "    Configured KeyExXbToSgInitMinSize to %d bytes", g_cbKeyExXbToSgInitMin);
    TraceSz(Config, "    Configured KeyExDontSendIcmp to %d (%s)", g_fKeyExDontSendIcmp,
             g_fKeyExDontSendIcmp ? "TRUE" : "FALSE");

    TraceSz(Config, "    Configured KeyExIcmpVip to %s", ipa.Str());

#ifdef SG_FEATURE_TRACE
    TraceSz(Config, "    Configured SpiFlow tracing to %d", t_SpiFlow);
    TraceSz(Config, "    Configured SpiFlow tracing data limit to %d", g_cbSpiFlowData);
#endif

    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// SgCalcIvAtSeq
// ---------------------------------------------------------------------------------------

void SgCalcIvAtSeq(const BYTE * pbIvInit, DWORD dwSeq, BYTE * pbIvCalc)
{
    ULONGLONG qw1 = UInt32x32To64(((DWORD *)pbIvInit)[0], dwSeq);
    ULONGLONG qw2 = UInt32x32To64(((DWORD *)pbIvInit)[1], dwSeq);
    ((DWORD *)pbIvCalc)[0] = ((DWORD *)&qw1)[0] ^ ((DWORD *)&qw2)[1];
    ((DWORD *)pbIvCalc)[1] = ((DWORD *)&qw1)[1] ^ ((DWORD *)&qw2)[0];
}

// ---------------------------------------------------------------------------------------
// SgIcmpRecv
// ---------------------------------------------------------------------------------------

void SgIcmpRecv(CPacket * ppkt)
{
    CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;
    CEnetHdr *   pEnetHdr       = ppkt->_pEnetHdr;
    CIpHdr *     pIpHdr         = ppkt->_pIpHdr;
    CIcmpHdr *   pIcmpHdr       = (CIcmpHdr *)ppkt->_pb;
    UINT         cb             = ppkt->_cb;
    CEnetAddr    eaT;
    CIpAddr      ipaT;

    if (cb < sizeof(CIcmpHdr))
    {
        TraceSz(RecvDiscard, "%s: ICMP header doesn't fit in the packet (%d bytes)", ppkt->Str(), cb);
        SgEventPacketNoisy(INVALID_PACKET_9, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CIpHdr) + cb, pIpHdr);
        goto complete;
    }

    if (tcpipxsum(0, pIcmpHdr, cb) != 0xFFFF)
    {
        TraceSz(RecvDiscard, "%s: ICMP header checksum failed", ppkt->Str());
        SgEventPacketNoisy(INVALID_PACKET_10, ppkt, pIpHdr->_ipaSrc, 0, sizeof(CIpHdr) + cb, pIpHdr);
        goto complete;
    }

    if (pIcmpHdr->_bType != ICMPTYPE_ECHO_REQUEST)
    {
        TraceSz(RecvDiscard, "%s: No support for ICMP <%d/%d>", ppkt->Str(), pIcmpHdr->_bType, pIcmpHdr->_bCode);
        SgEventPacketLogNoisyEx(INVALID_PACKET_11, ppkt, pIpHdr->_ipaSrc, 0, PEVT_FILTER_IP, sizeof(CIcmpHdr), pIcmpHdr);
        goto complete;
    }

    // Reverse the ethernet addresses

    eaT                  = pEnetHdr->_eaSrc;
    pEnetHdr->_eaSrc     = pEnetHdr->_eaDst;
    pEnetHdr->_eaDst     = eaT;

    // Reverse the IP addresses and recompute the checksum

    ipaT                 = pIpHdr->_ipaSrc;
    pIpHdr->_ipaSrc      = pIpHdr->_ipaDst;
    pIpHdr->_ipaDst      = ipaT;
    pIpHdr->_wChecksum   = 0;
    pIpHdr->_wChecksum   = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    // Change the type to ICMPTYPE_ECHO_REPLY and recompute the checksum

    pIcmpHdr->_bType     = ICMPTYPE_ECHO_REPLY;
    pIcmpHdr->_wChecksum = 0;
    pIcmpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIcmpHdr, cb);

    // Transmit the reply on the same transport as it was received

    ppkt->_pTransInfoXmit = ppkt->_pTransInfoRecv;

    SgXmit(ppkt);
    return;

complete:
    ppkt->Complete();
    return;
}

void SgIcmpXmit(CPacket * ppktSrc)
{
    CPacket * ppkt = SgPacketAlloc();

    if (ppkt == NULL)
    {
        TraceSz(Warning, "SgIcmpXmit - Unable to allocate a packet");
        return;
    }

    CEnetHdr *   pEnetHdr   = ppkt->_pEnetHdr = (CEnetHdr *)ppkt->_abCtx;
    CIpHdr *     pIpHdr     = ppkt->_pIpHdr = (CIpHdr *)(pEnetHdr + 1);
    CIcmpHdr *   pIcmpHdr   = (CIcmpHdr *)(pIpHdr + 1);

    pEnetHdr->_eaSrc        = ppktSrc->_pEnetHdr->_eaDst;
    pEnetHdr->_eaDst        = ppktSrc->_pEnetHdr->_eaSrc;
    pEnetHdr->_wType        = ENET_TYPE_IP;

    pIpHdr->_bVerHdr        = 0x45;
    pIpHdr->_bTos           = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen           = HTONS(sizeof(CIpHdr) + sizeof(CIcmpHdr) + sizeof(CIpHdr) + 8);
    pIpHdr->_wId            = 0;
    pIpHdr->_wFragOff       = 0;
    pIpHdr->_bTtl           = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol      = IPPROTOCOL_ICMP;
    pIpHdr->_ipaDst         = ppktSrc->_pIpHdr->_ipaSrc;
    pIpHdr->_ipaSrc         = g_ipaKeyExIcmpVip ? g_ipaKeyExIcmpVip : ppktSrc->_pIpHdr->_ipaDst;
    pIpHdr->_wChecksum      = 0;
    pIpHdr->_wChecksum      = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pIcmpHdr->_bType        = ICMPTYPE_DESTINATION_UNREACHABLE;
    pIcmpHdr->_bCode        = ICMPCODE_PORT_UNREACHABLE;
    pIcmpHdr->_wChecksum    = 0;
    pIcmpHdr->_dwData       = 0;

    memcpy(pIcmpHdr + 1, ppktSrc->_pIpHdr, sizeof(CIpHdr) + 8);

    if (g_ipaKeyExIcmpVip)
    {
        CIpHdr * pIpHdrIcmp     = (CIpHdr *)(pIcmpHdr + 1);
        pIpHdrIcmp->_ipaDst     = g_ipaKeyExIcmpVip;
        pIpHdrIcmp->_wChecksum  = 0;
        pIpHdrIcmp->_wChecksum  = (WORD)~tcpipxsum(0, pIpHdrIcmp, sizeof(CIpHdr));
    }

    pIcmpHdr->_wChecksum    = (WORD)~tcpipxsum(0, pIcmpHdr, sizeof(CIcmpHdr) + sizeof(CIpHdr) + 8);

    CTransInfo * pTransInfoXmit = ppkt->_pTransInfoXmit = ppktSrc->_pTransInfoRecv;

    ppkt->_apb[0] = (BYTE *)pEnetHdr;
    ppkt->_acb[0] = sizeof(CEnetHdr) + sizeof(CIpHdr) + sizeof(CIcmpHdr) + sizeof(CIpHdr) + 8;
    ppkt->_cpb    = 1;

#ifdef SG_FEATURE_ARP
    if ((pIpHdr->_ipaDst & pTransInfoXmit->_ipaMask) != pTransInfoXmit->_ipaSubnet)
    {
        // Send the response via the default gateway.  Must do ARP because the MAC address of
        // the sender might be the VIP, and we want this packet to go out via the gateway.

        SgArpInfoLock();

        CArpInfo * pArpInfo = SgArpInfoInsert(pTransInfoXmit, pIpHdr->_ipaDst, TRUE);

        if (pArpInfo == NULL)
        {
            TraceSz(Warning, "SgIcmpXmit - Out of memory allocating CArpInfo");

            SgArpInfoUnlock();
            goto complete;
        }

        // SgXmitWithArp will release the ARP lock

        SgXmitWithArp(ppkt, pArpInfo);
    }
    else
#endif // SG_FEATURE_ARP
    {
        // If the target is on my subnet, just send directly to his MAC address.

        SgXmit(ppkt);
    }

    return;

#ifdef SG_FEATURE_ARP
complete:
#endif
    ppkt->Complete();
    return;
}

void SgXmit(CPacket * ppkt)
{
    Assert(ppkt->_pSpiInfo == NULL);

    // Update performance counters
    DWORD dwType = ppkt->_pTransInfoXmit ? ppkt->_pTransInfoXmit->_dwType : 0;

    SgPerfdataInc(XmitTotal, 1);
    if (dwType == TRANSTYPE_INTERNET)
        SgPerfdataInc(IXmit, 1);
    else if (dwType == TRANSTYPE_DMZ)
        SgPerfdataInc(ZXmit, 1);

    for(UINT i = 0; i < ppkt->_cpb; i++)
    {
        if (dwType == TRANSTYPE_INTERNET)
            SgPerfdataInc(IXmitBytes, ppkt->_acb[i]);
        else if (dwType == TRANSTYPE_DMZ)
            SgPerfdataInc(ZXmitBytes, ppkt->_acb[i]);
    }

    // Transmit packet
    Assert(ppkt->_pSpiInfo == NULL);
    TransXmit(ppkt);
}

#ifdef SG_FEATURE_UDP_ECHO

void SgIRecvXspEcho(CPacket * ppkt)
{
    // This function basically replicates the rawnic xmit/recv functions loops a decrypted
    // packet from the internet straight back to the SG for re-encryption.

    BYTE ** ppb   = ppkt->_apb;
    UINT *  pcb   = ppkt->_acb;
    UINT    cpb   = ppkt->_cpb;

    BYTE    pbBuffer[1600];
    BYTE *  pb    = pbBuffer;
    UINT    cb    = 0;

    // Collect all buffers into a temporary
    for (; cpb > 0; ++ppb, ++pcb, --cpb)
    {
        memcpy(pb, *ppb, *pcb);
        cb += *pcb;
        pb += *pcb;

        *pcb = 0;
        *ppb = NULL;
    }

    // Copy single temp buffer to final destination, which mostly stomps the source buffer
    memcpy(ppkt->_abTransRecv + ETH_HEADER_ALIGN, pbBuffer, cb);

    ppkt->_apb[0] = ppkt->_abTransRecv + ETH_HEADER_ALIGN;
    ppkt->_acb[0] = cb;
    ppkt->_cpb    = 1;

    CTransInfo * pTransInfoTemp = ppkt->_pTransInfoRecv;
    ppkt->_pTransInfoRecv = ppkt->_pTransInfoXmit;
    ppkt->_pTransInfoXmit = pTransInfoTemp;

    // Reverse the ethernet addresses

    CEnetHdr * pEnetHdr  = (CEnetHdr*)ppkt->_apb[0];
    CEnetAddr eaT        = pEnetHdr->_eaSrc;
    pEnetHdr->_eaSrc     = pEnetHdr->_eaDst;
    pEnetHdr->_eaDst     = eaT;

    // Reverse the IP addresses and recompute the checksum

    CIpHdr * pIpHdr      = (CIpHdr*)(pEnetHdr + 1);
    CIpAddr ipaT         = pIpHdr->_ipaSrc;
    pIpHdr->_ipaSrc      = pIpHdr->_ipaDst;
    pIpHdr->_ipaDst      = ipaT;
    pIpHdr->_wChecksum   = 0;
    pIpHdr->_wChecksum   = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    if (pIpHdr->_bProtocol == IPPROTOCOL_UDP)
    {
        // Revert the UDP ports and recompute checksum

        CUdpHdr * pUdpHdr    = (CUdpHdr*)(pIpHdr + 1);
        CIpPort ippT         = pUdpHdr->_ipportSrc;
        pUdpHdr->_ipportSrc  = pUdpHdr->_ipportDst;
        pUdpHdr->_ipportDst  = ippT;
        pUdpHdr->_wChecksum  = 0;

        SgSetUdpHdrChecksum(pIpHdr,
                            pUdpHdr, sizeof(CUdpHdr),
                            (BYTE*)(pUdpHdr+1), NTOHS(pUdpHdr->_wLen) - sizeof(CUdpHdr),
                            0, NULL, 0, NULL, 0, NULL);
    }
    else if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
    {
        // Revert the TCP ports and recompute checksum

        CTcpHdr * pTcpHdr    = (CTcpHdr*)(pIpHdr + 1);
        CIpPort ippT         = pTcpHdr->_ipportSrc;
        pTcpHdr->_ipportSrc  = pTcpHdr->_ipportDst;
        pTcpHdr->_ipportDst  = ippT;
        pTcpHdr->_wChecksum  = 0;

        SgSetTcpHdrChecksum(pIpHdr,
                            pTcpHdr, sizeof(CTcpHdr),
                            (BYTE*)(pTcpHdr+1), cb - sizeof(CTcpHdr) - sizeof(CIpHdr) - sizeof(CEnetHdr));
    }
    else
    {
        Assert(!"Invalid protocol");
    }

    SgRecv(ppkt);

    // no complete
}

void SgIRecvUdpEcho(CPacket * ppkt)
{
    CTransInfo * pTransInfoRecv = ppkt->_pTransInfoRecv;
    CEnetHdr *   pEnetHdr       = ppkt->_pEnetHdr;
    CIpHdr *     pIpHdr         = ppkt->_pIpHdr;
    CUdpHdr *    pUdpHdr        = (CUdpHdr*) ppkt->_pb;
    UINT         cb             = ppkt->_cb;
    CEnetAddr    eaT;
    CIpAddr      ipaT;
    CIpPort      ippT;

    // Reverse the ethernet addresses

    eaT                  = pEnetHdr->_eaSrc;
    pEnetHdr->_eaSrc     = pEnetHdr->_eaDst;
    pEnetHdr->_eaDst     = eaT;

    // Reverse the IP addresses and recompute the checksum

    ipaT                 = pIpHdr->_ipaSrc;
    pIpHdr->_ipaSrc      = pIpHdr->_ipaDst;
    pIpHdr->_ipaDst      = ipaT;
    pIpHdr->_wChecksum   = 0;
    pIpHdr->_wChecksum   = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    // Revert the UDP ports and recompute checksum

    ippT                 = pUdpHdr->_ipportSrc;
    pUdpHdr->_ipportSrc  = pUdpHdr->_ipportDst;
    pUdpHdr->_ipportDst  = ippT;
    pUdpHdr->_wChecksum  = 0;

    SgSetUdpHdrChecksum(pIpHdr,
            pUdpHdr, sizeof(CUdpHdr),
            (BYTE*)(pUdpHdr+1), NTOHS(pUdpHdr->_wLen) - sizeof(CUdpHdr),
            0, NULL, 0, NULL, 0, NULL);

    // Transmit the reply on the same transport as it was received

    ppkt->_pTransInfoXmit = ppkt->_pTransInfoRecv;

    SgXmit(ppkt);
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsvccore.cpp ===
// ---------------------------------------------------------------------------------------
// sgsvccore.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

BOOL g_fWinsockInited = FALSE;


// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------


// ---------------------------------------------------------------------------------------
// SgServiceInit - start up the SG service layer
// ---------------------------------------------------------------------------------------
BOOL SgServiceInit( HANDLE hShutdownEvent )
{
    BOOL fReturn = FALSE;
    HRESULT hr;

    Assert( FALSE == g_fWinsockInited );

    if(!SgMemInit())
    {
        goto lDone;
    }

    // initialize events
    if(!SgEventInit())
    {
        // can't do much without events
        goto lDone;
    }

#ifdef SG_FEATURE_XMGMT
    hr = g_xomcentral.Init( "SG", NULL, "sgsvc" );
    if( FAILED( hr ) )
    {
        // complain, but start anyway.
        SgEventSz(INIT_ERROR_1, "SGSVC: SgServiceInit() - g_xomcentral.Init failed, hr= 0x%08x", hr );
    }
    else
    {
        hr = g_xomcentral.RegisterControlCallback( &g_SgControlCallback );
        if( FAILED( hr ) )
        {
            // complain, but start anyway.
            SgEventSz(INIT_ERROR_2, "SGSVC: SgServiceInit() - g_xomcentral.RegisterControlCallback failed, hr= 0x%08x", hr );
        }
    }
#endif // SG_FEATURE_XMGMT

    // Initialize Winsock
    WSADATA wsaData;
    int rc = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
    if( 0 != rc )
    {
        SgEventSz(INIT_ERROR_3, "SGSVC: SgServiceInit() - WSAStartup failed, rc = 0x%08x", rc );
        goto lDone;
    }
    g_fWinsockInited = TRUE;

    // Initialize perf counters
    if( !SgServicePerfCountersInit() )
    {
        SgEventSz(INIT_ERROR_4, "SGSVC: SgServiceInit() - SgServicePerfCountersInit failed" );
        goto lDone;
    }
    
    // Initialize the transport layer
    if( !SgInit() )
    {
        SgEventSz(INIT_ERROR_7, "SGSVC: SgServiceInit() - SgInit failed" );
        goto lDone;
    }

    // Initialize Notification layer
    if( !SgServiceNotifyInit() )
    {
        SgEventSz(INIT_ERROR_6, "SGSVC: SgServiceInit() - SgServiceNotifyInit failed" );
        goto lDone;
    }

    // Configure the transport layer
    // NOTE: Do this last since it may call into us and we need the other objects to be ready
    if( !SgConfig() )
    {
        SgEventSz(INIT_ERROR_8, "SGSVC: SgServiceInit() - SgConfig failed" );
        goto lDone;
    }

    fReturn = TRUE;

lDone:
    if( !fReturn )
    {
        SgServiceTerm();
    }

    return fReturn;
}


// ---------------------------------------------------------------------------------------
// SgServiceTerm - shut down the SG service layer
// ---------------------------------------------------------------------------------------
void SgServiceTerm()
{
    SgServiceNotifyTerm();
    SgTerm();
    SgServicePerfCountersTerm();

    if( g_fWinsockInited )
    {
        WSACleanup();
        g_fWinsockInited = FALSE;
    }

#ifdef SG_FEATURE_XMGMT
    g_xomcentral.Term();
#endif

    SgEventTerm();
    SgMemTerm();
}


// ---------------------------------------------------------------------------------------
// SgServiceHeartbeat - called by the service layer periodically (on main thread)
// ---------------------------------------------------------------------------------------
void SgServiceHeartbeat()
{
    // Pump each of the sub-layers
    SgServicePerfCountersHeartbeat();
}


// ---------------------------------------------------------------------------------------
// SgServiceInstall - perform service-specific installation
// ---------------------------------------------------------------------------------------
BOOL SgServiceInstall(OUT BOOL *pfRebootRequired)
{
    // Install the proxy layer
    return SgInstall(pfRebootRequired);
}


// ---------------------------------------------------------------------------------------
// SgServiceUninstall - perform service-specific uninstallation
// ---------------------------------------------------------------------------------------
BOOL SgServiceUninstall(OUT BOOL *pfRebootRequired)
{
    // Uninstall the proxy layer
    return SgUninstall(pfRebootRequired);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsiteinfo.cpp ===
// ---------------------------------------------------------------------------------------
// sgsiteinfo.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// CSiteInfo
// ---------------------------------------------------------------------------------------

DECLARE_HASH_TABLE(SvcInfo);

UINT            g_cSiteInfo;            // Number of CSiteInfo structures
LIST_ENTRY      g_leSiteInfo;           // List of CSiteInfo structures
CLock           g_lockSiteInfo;         // Synchronizes g_leSiteInfo
CSiteInfo       g_SiteInfoNull;         // NULL CSiteInfo (insecure; test only)

BOOL SgSiteInfoInit()
{
    Assert(g_cSiteInfo == 0);
    Assert(g_leSiteInfo.Flink == NULL);
    Assert(g_leSiteInfo.Blink == NULL);
    InitializeListHead(&g_leSiteInfo);
    g_lockSiteInfo.Init();

    return(TRUE);
}

void SgSiteInfoTerm()
{
    if (g_cSiteInfo > 0)
    {
        while (!IsListEmpty(&g_leSiteInfo))
        {
            CSiteInfo * pSiteInfo = (CSiteInfo *)RemoveHeadList(&g_leSiteInfo);
            SgMemFree(pSiteInfo);
        }
    }

    g_cSiteInfo = 0;
    memset(&g_leSiteInfo, 0, sizeof(g_leSiteInfo));
    memset(&g_SiteInfoNull, 0, sizeof(g_SiteInfoNull));
    g_lockSiteInfo.Term();
}

BOOL SgSiteInfoConfig(CCfgInfo* pci)
{
    TraceSz( Config, "SgSiteInfoConfig:" );

    BOOL fReturn = FALSE;
    ULONGLONG qwNow = SgGetSystemTime();
    DWORD cSiteKey = pci->Count("SiteKey");
    CCfgInfo* pciSite = NULL;
    DWORD dwSiteId;
    DWORD dwVersion;
    BYTE abKey[16];
    DWORD cb;

    if(0 == cSiteKey)
    {
#ifdef SG_FEATURE_LSP
        {
            //
            // SGLSP gets its site keys dynamically from Live
            //

            return TRUE;
        }
#else // !SG_FEATURE_LSP
        {
            //
            // can't do much without site keys
            //

            SgEventSz(CONFIG_ERROR,
                      "No sites were configured. At least one site must be configured "
                      "for the SG to start. This is typically done with the sgkey*.ini "
                      "files in the ../sgcfg/ directory.");

            return FALSE;
        }
#endif // SG_FEATURE_LSP
    }

    g_lockSiteInfo.AcquireDpc();

    for( DWORD iKey = 0; iKey < cSiteKey; iKey++ )
    {
        pciSite = pci->FindList("SiteKey", pciSite, TRUE);

        if (pciSite == NULL)
            break;

        if(!pciSite->GetNum("SiteId", &dwSiteId, TRUE) ||
           !pciSite->GetNum("Version", &dwVersion, TRUE) ||
           !pciSite->GetHex("Data", abKey, &cb, ARRAY_SIZE(abKey), TRUE))
        {
            goto Exit;
        }

        if (dwSiteId == 0)
        {
            SgEventSz(CONFIG_ERROR, "line %d. 'SiteId' cannot be zero.", pciSite->_csValue._iLine);
            break;
        }

        if(cb != sizeof(abKey))
        {
            SgEventSz(CONFIG_ERROR, "Key size is invalid. size=%u, correct-size=%u, siteId=%u, version=%u",
                       cb, sizeof(abKey), dwSiteId, dwVersion);
            goto Exit;
        }

        CSiteInfo* pSiteInfo = SgSiteInfoLookup( dwSiteId, dwVersion);
        if( NULL != pSiteInfo )
        {
            // Update the time so we don't delete it below
            pSiteInfo->_qwTimeLastConfig = qwNow;
            continue;
        }

        // A new key is being added, build the CSiteInfo
        pSiteInfo = (CSiteInfo*) SgMemAllocZ( sizeof( CSiteInfo ), PTAG_CSiteInfo );
        if( NULL == pSiteInfo )
        {
            TraceSz( Config, "Config error: Out of memory allocating CSiteInfo (%u bytes)", sizeof( CSiteInfo ) );
            goto Exit;
        }

        pSiteInfo->_dwSiteId  = dwSiteId;
        pSiteInfo->_dwVersion = dwVersion;
        memcpy( pSiteInfo->_abKey, abKey, sizeof( pSiteInfo->_abKey ) );
        pSiteInfo->_qwTimeLastConfig = qwNow;

        // put the new CSiteInfo into the global list
        InsertTailList( &g_leSiteInfo, &pSiteInfo->_le );
        g_cSiteInfo++;

        // NOTE: Never spew key data as it is secure!
        TraceSz( Config, "    SiteId %5u Version %u was added", pSiteInfo->_dwSiteId, pSiteInfo->_dwVersion );
    }

    // Now go through all keys and delete any that are no longer in the config
    UINT        cSiteInfo = g_cSiteInfo;
    CSiteInfo * pSiteInfo = (CSiteInfo*) g_leSiteInfo.Flink;

    for( UINT iSiteInfo = 0; iSiteInfo < cSiteInfo; ++iSiteInfo )
    {
        CSiteInfo* pNext = (CSiteInfo *)pSiteInfo->_le.Flink;

        if( pSiteInfo->_qwTimeLastConfig < qwNow )
        {
            // This entry is old, remove it

            // NOTE: Never spew key data as it is secure!
            TraceSz( Config, "    SiteId %5u Version %u is being deleted", pSiteInfo->_dwSiteId, pSiteInfo->_dwVersion );

            RemoveEntryList( &pSiteInfo->_le );
            SgMemFree( pSiteInfo );
            g_cSiteInfo--;
        }

        pSiteInfo = pNext;
    }

    fReturn = TRUE;

Exit:
    g_lockSiteInfo.ReleaseDpc();

    return fReturn;
}

CSiteInfo * SgSiteInfoLookup(DWORD dwSiteId, DWORD dwVersion)
{
#ifdef SG_FEATURE_INSECURE
    if (dwSiteId == 0)
    {
        return(&g_SiteInfoNull);
    }
#endif

    CSiteInfo * pSiteInfo = (CSiteInfo *)g_leSiteInfo.Flink;
    UINT        cSiteInfo = g_cSiteInfo;

    for (; cSiteInfo > 0; --cSiteInfo, pSiteInfo = (CSiteInfo *)pSiteInfo->_le.Flink)
    {
        if (pSiteInfo->_dwSiteId == dwSiteId && pSiteInfo->_dwVersion == dwVersion)
        {
            return(pSiteInfo);
        }
    }

    return(NULL);
}

BOOL SgSiteInfoLookupKey(DWORD dwSiteId, DWORD dwVersion, BYTE * pbKey)
{
    BOOL        fSuccess  = FALSE;

    g_lockSiteInfo.AcquireDpc();

    CSiteInfo * pSiteInfo = SgSiteInfoLookup(dwSiteId, dwVersion);

    if (pSiteInfo != NULL)
    {
        memcpy(pbKey, pSiteInfo->_abKey, sizeof(pSiteInfo->_abKey));
        fSuccess = TRUE;
    }

    g_lockSiteInfo.ReleaseDpc();

    return(fSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsvcinfo.cpp ===
// ---------------------------------------------------------------------------------------
// sgsvcinfo.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// CSvcInfo
// ---------------------------------------------------------------------------------------

DECLARE_HASH_TABLE(SvcInfo);
UINT            g_cSvcInfo;             // Number of services being mapped
CSvcInfo *      g_pSvcInfo;             // Vector of all CSvcInfo structures
CSvcInfoHash *  g_pSvcInfoHash;         // Hash table mapping _dwSvcId to CSvcInfo *
CLock           g_lockSvcInfo;          // Synchronizes all SvcInfo. Actually protects the hashtable.

BOOL SgSvcInfoInit()
{
    Assert(g_cSvcInfo == 0);
    Assert(g_pSvcInfo == NULL);
    Assert(g_pSvcInfoHash == NULL);
    g_lockSvcInfo.Init();
    return(TRUE);
}

void SgSvcInfoTerm()
{
    SgMemFree(g_pSvcInfo);
    delete g_pSvcInfoHash;

    g_lockSvcInfo.Term();

    g_cSvcInfo     = 0;
    g_pSvcInfo     = NULL;
    g_pSvcInfoHash = NULL;
}

BOOL SgSvcInfoConfig(CCfgInfo* pci)
{
    BOOL fOk = FALSE;

    TraceSz( Config, "SgSvcInfoConfig:" );

    SgSvcInfoLock();

    if (g_pSvcInfo == NULL)
    {
        size_t const cb = CSVCINFOMAX * sizeof(CSvcInfo);
        g_pSvcInfo = (CSvcInfo *)SgMemAllocZ(cb, PTAG_CSvcInfo);

        if (g_pSvcInfo == NULL)
        {
            TraceSz(Config, "Config error: Out of memory allocating vector of %d CSvcInfo (%d bytes)",
                     CSVCINFOMAX, cb);
            goto exit;
        }
    }

    if (g_pSvcInfoHash == NULL)
    {
        g_pSvcInfoHash = new CSvcInfoHash;

        if (g_pSvcInfoHash == NULL || !g_pSvcInfoHash->Init(CSVCINFOMAX, NULL))
        {
            TraceSz(Config, "Config error: Out of memory allocating CSvcInfoHash (%d entries)",
                     CSVCINFOMAX);
            delete g_pSvcInfoHash;
            g_pSvcInfoHash = NULL;
            goto exit;
        }
    }

    DWORD cService = pci->Count("Service");
    CCfgInfo* pciServ = NULL;
    CCfgInfo* pciServName = NULL;
    CSvcInfo* pSvcInfo;
    DWORD dwServId;


    for( UINT iService = 0; iService < cService; iService++ )
    {
        pciServ = pci->FindList("Service", pciServ, FALSE);
        Assert(pciServ != NULL);

        if(!pciServ->GetNum("Id", &dwServId, TRUE))
            goto exit;

        pciServName = pciServ->FindNonList("Name", NULL, TRUE);
        if(!pciServName)
            goto exit;

        if (pciServName->_csValue._cch > sizeof(pSvcInfo->_achName) - 1)
        {
            SgEventSz(CONFIG_ERROR, "line %d. Max service name length is %d.",
                       pciServName->_csValue._iLine, sizeof(pSvcInfo->_achName) - 1);
            continue;
        }

        // Look for duplicates by ID
        pSvcInfo = SgSvcInfoLookup(dwServId);
        if( NULL != pSvcInfo )
        {
            if( !pciServName->_csValue.StrEql(pSvcInfo->_achName) )
            {
                TraceSz( Config, "Config error: Service Id %u is already named '%s'", pSvcInfo->_dwSvcId, pSvcInfo->_achName );
                SgEventSz( CONFIG_ERROR, "Config error: Service Id %u is already named '%s'", pSvcInfo->_dwSvcId, pSvcInfo->_achName );
                goto exit;
            }
            continue;
        }

        // Look for duplicates by Name
        pSvcInfo = SgSvcInfoLookup(pciServName->_csValue.Str());
        if( NULL != pSvcInfo )
        {
            if( pSvcInfo->_dwSvcId != dwServId )
            {
                TraceSz( Config, "Config error: Service '%s' already has Id %u", pSvcInfo->_achName, pSvcInfo->_dwSvcId );
                SgEventSz( CONFIG_ERROR, "Config error: Service '%s' already has Id %u", pSvcInfo->_achName, pSvcInfo->_dwSvcId );
                goto exit;
            }
            continue;
        }

        if( CSVCINFOMAX == g_cSvcInfo )
        {
            TraceSz( Config, "Config error: Service table is full (%u entries)", CSVCINFOMAX );
            SgEventSz( CONFIG_ERROR, "Config error: Service table is full (%u entries)", CSVCINFOMAX );
            goto exit;
        }

        pSvcInfo = &g_pSvcInfo[g_cSvcInfo];
        pSvcInfo->_iSvcInfo = g_cSvcInfo;
        pSvcInfo->_dwSvcId = dwServId;

        // Copy Service name. Gotta memcpy it because _pch is not NULL terminated. Max
        // size was checked earlier.
        {
            const char* pch = pciServName->_csValue._pch;
            DWORD cch = pciServName->_csValue._cch;
            memcpy( pSvcInfo->_achName, pch, cch);
            pSvcInfo->_achName[cch-1];
        }

        g_pSvcInfoHash->Insert(pSvcInfo);
        g_cSvcInfo += 1;
    }

    if(cService > 0)
    {
        TraceSz( Config, "    Configured %u service%s in %u hash buckets",
                 g_cSvcInfo, g_cSvcInfo == 1 ? "" : "s", g_pSvcInfoHash->GetBucketCount());

        UINT        cSvcInfo = g_cSvcInfo;
        CSvcInfo *  pSvcInfo = g_pSvcInfo;

        for (; cSvcInfo > 0; --cSvcInfo, ++pSvcInfo)
        {
            TraceSz(Config, "    Id %5u Name %s", pSvcInfo->_dwSvcId, pSvcInfo->_achName);
        }
    }

    fOk = TRUE;

exit:
    SgSvcInfoUnlock();

    return(fOk);
}

CSvcInfo * SgSvcInfoLookup(DWORD dwSvcId)
{
    if (g_cSvcInfo == 0)
    {
        return NULL;
    }

    CSvcInfo SvcInfo;
    SvcInfo._dwSvcId = dwSvcId;
    return(g_pSvcInfoHash->Lookup(&SvcInfo));
}

CSvcInfo * SgSvcInfoLookup( const char* pchName )
{
    UINT        cSvcInfo = g_cSvcInfo;
    CSvcInfo *  pSvcInfo = g_pSvcInfo;

    for (; cSvcInfo > 0; --cSvcInfo, ++pSvcInfo)
    {
        if( 0 == _stricmp( pchName, pSvcInfo->_achName ) )
        {
            return(pSvcInfo);
        }
    }

    return(NULL);
}

DWORD SgSvcInfoHashCompute(CSvcInfo * pSvcInfo)
{
    return(pSvcInfo->_dwSvcId);
}

BOOL SgSvcInfoHashCompare(CSvcInfo * pSvcInfo1, CSvcInfo * pSvcInfo2)
{
    return(pSvcInfo1->_dwSvcId == pSvcInfo2->_dwSvcId);
}

ServiceMask SgSvcInfoMask( UINT cDwordServiceIds, const DWORD* pDwordServiceIds, ServiceMask const & byteServicesMask)
{
    ServiceMask svcMask;

    SgSvcInfoLock();

    for (; cDwordServiceIds > 0; --cDwordServiceIds, ++pDwordServiceIds)
    {
        CSvcInfo * pSvcInfo = SgSvcInfoLookup(*pDwordServiceIds);

        if (pSvcInfo != NULL)
        {
            Assert(pSvcInfo->_iSvcInfo < 32);
            svcMask.SetBit(pSvcInfo->_iSvcInfo);
        }
    }

    for( DWORD iSvc = 1; iSvc < ServiceMask::SERVICE_BITS; iSvc++ )
    {
        if (byteServicesMask.IsBitSet(iSvc))
        {
            CSvcInfo * pSvcInfo = SgSvcInfoLookup( iSvc );
            if( NULL != pSvcInfo )
            {
                Assert( pSvcInfo->_iSvcInfo < ServiceMask::SERVICE_BITS );
                svcMask.SetBit(pSvcInfo->_iSvcInfo);
            }
        }
    }

    SgSvcInfoUnlock();

    return svcMask;
}

ServiceMask SgSvcInfoMask(DWORD dwSvcId)
{
    ServiceMask svcMask;

    SgSvcInfoLock();

    CSvcInfo * pSvcInfo = SgSvcInfoLookup(dwSvcId);

    if (NULL != pSvcInfo)
    {
        Assert(pSvcInfo->_iSvcInfo < ServiceMask::SERVICE_BITS);
        svcMask.SetBit(pSvcInfo->_iSvcInfo);
    }

    SgSvcInfoUnlock();
 
    return svcMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgstate.cpp ===
// ---------------------------------------------------------------------------------------
// sgstate.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// This seems to live in ntrtl.h (mstcpip.h later), but including that whole file 
// introduces a bunch of compile-time errors and seems like overkill.
extern "C" {
NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressExA (
    IN PCSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );
};

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

BOOL        SgCliInfoConfig(UINT cCliInfo);
void        SgCliInfoDispatch(CCliInfo * pCliInfo);
void        SgCliInfoDispatchComplete(CPacket * ppkt);
void        SgSpiInfoDispatch(CSpiInfo * ppkt);
void        SgSpiInfoDispatchComplete(CPacket * ppkt);
void        SgSpiInfoTimerWithSpi(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// CSpiInfo
// ---------------------------------------------------------------------------------------

CSpiInfo *  g_pSpiInfo;                         // Vector of pointers to all CSpiInfo structures
UINT        g_cSpiInfo;                         // Number of CSpiInfo structures allocated
UINT        g_cSpiInfoInUse;                    // Number of CSpiInfo structures in use
CSpiInfo *  g_pSpiInfoLast;                     // Pointer to last CSpiInfo structure in use
CSpiInfo *  g_pSpiInfoTimer;                    // Pointer to CSpiInfo the timer is scanning
UINT        g_cSpiInfoTimerNumer;               // Timer count numerator (g_cSpiInfoInUse per tick)
UINT        g_cSpiInfoTimerDenom;               // Timer count denominator (ticks per CSpiInfo visit)
UINT        g_cTicksPerSpiInfoTimeout;          // Number of ticks of no inbound data/pulse (after key-ex confirmed) before disconnect
UINT        g_cTicksPerSpiInfoKeyExTimeout;     // Number of ticks of no inbound data/pulse (right after key-ex) before disconnect
UINT        g_cTicksPerSpiInfoPulseTimeout;     // Number of ticks of no outbound data/pulse before SG should send SECMSG_TYPE_SGTOXBPULSE
UINT        g_cTicksPerSpiInfoWatchdog;         // Number of ticks that a CSpiInfo can be attached before watchdog warns
UINT        g_cTicksPerSpiInfoChalResp;         // Number of ticks between challenges to the clients
UINT        g_cTicksPerSpiInfoChalRespAck;      // Number of ticks between re-issuing the challenges to the client
UINT        g_cTicksPerSpiInfoChalRespTimeout;  // Number of ticks after a challenge has been sent, before a timeout
UINT        g_cXbToSgTimeoutInSeconds;          // Number of seconds of no inbound data/pulse before XB should disconnect
UINT        g_cXbToSgPulseTimeoutInSeconds;     // Number of seconds of no outbound data/pulse before XB should send SECMSG_TYPE_XBTOSGPULSE
UINT        g_cNatDetectionDisconnectTimeout;  // Number of ticks after Nat detection response to disconnect client
ULONGLONG   g_qwKeyExBlockInterval;             // Length of Time to block KeyEx for (in 100ns)

UINT        g_cSpiInfoFree;                     // Number of free CSpiInfo in queue
LIST_ENTRY  g_leSpiInfoFree;                    // Queue of free CSpiInfo structures
CLock       g_lockSpiInfoFree;                  // Synchronizes g_leSpiInfoFree and g_cSpiInfoInUse


BOOL SgSpiInfoInit()
{
    Assert(g_pSpiInfo == NULL);
    Assert(g_cSpiInfo == 0);
    Assert(g_cSpiInfoInUse == 0);
    Assert(g_pSpiInfoLast == NULL);
    Assert(g_pSpiInfoTimer == NULL);
    Assert(g_cSpiInfoTimerNumer == 0);
    Assert(g_cSpiInfoTimerDenom == 0);
    Assert(g_cTicksPerSpiInfoTimeout == 0);
    Assert(g_cTicksPerSpiInfoKeyExTimeout == 0);
    Assert(g_cTicksPerSpiInfoPulseTimeout == 0);
    Assert(g_cTicksPerSpiInfoWatchdog == 0);
    Assert(g_cTicksPerSpiInfoChalResp == 0);
    Assert(g_cTicksPerSpiInfoChalRespAck == 0);
    Assert(g_cTicksPerSpiInfoChalRespTimeout == 0);
    Assert(g_cXbToSgTimeoutInSeconds == 0);
    Assert(g_cXbToSgPulseTimeoutInSeconds == 0);
    Assert(g_cNatDetectionDisconnectTimeout == 0);
    Assert(g_qwKeyExBlockInterval == 0);
    Assert(g_cSpiInfoFree == 0);
    Assert(g_leSpiInfoFree.Flink == NULL);
    Assert(g_leSpiInfoFree.Blink == NULL);
    InitializeListHead(&g_leSpiInfoFree);
    g_lockSpiInfoFree.Init();

    return(TRUE);
}

void SgSpiInfoTerm()
{
    if (g_cSpiInfo > 0)
    {
        CSpiInfo * pSpiInfo    = g_pSpiInfo;
        CSpiInfo * pSpiInfoEnd = pSpiInfo + g_cSpiInfo;

        for (; pSpiInfo < pSpiInfoEnd; ++pSpiInfo)
        {
            pSpiInfo->_lock.Term();
        }
    }

    SgMemFree(g_pSpiInfo);

    g_pSpiInfo                       = NULL;
    g_cSpiInfo                       = 0;
    g_cSpiInfoInUse                  = 0;
    g_pSpiInfoLast                   = NULL;
    g_pSpiInfoTimer                  = NULL;
    g_cSpiInfoTimerNumer             = 0;
    g_cSpiInfoTimerDenom             = 0;
    g_cTicksPerSpiInfoTimeout        = 0;
    g_cTicksPerSpiInfoKeyExTimeout   = 0;
    g_cTicksPerSpiInfoPulseTimeout   = 0;
    g_cTicksPerSpiInfoWatchdog       = 0;
    g_cTicksPerSpiInfoChalResp       = 0;
    g_cTicksPerSpiInfoChalRespAck    = 0;
    g_cTicksPerSpiInfoChalRespTimeout= 0;

    g_cXbToSgTimeoutInSeconds        = 0;
    g_cXbToSgPulseTimeoutInSeconds   = 0;
    g_cNatDetectionDisconnectTimeout = 0;
    g_qwKeyExBlockInterval           = 0;
    g_cSpiInfoFree                   = 0;

    g_lockSpiInfoFree.Term();
    memset(&g_leSpiInfoFree, 0, sizeof(g_leSpiInfoFree));
}

BOOL SgSpiInfoConfig(CCfgInfo* pci)
{
    UINT cKeyExBlockInterval = 0;

    TraceSz( Config, "SgSpiInfoConfig:" );

    //
    // The following parameters can be reconfigured at any time
    //

    if (!pci->GetVar("SgToXbScanFrequencyInSeconds",    &g_cSpiInfoTimerDenom,              1,    60*60, 15)  ||
        !pci->GetVar("SgToXbTimeoutInSeconds",          &g_cTicksPerSpiInfoTimeout,         1,    60*60, 120) ||
        !pci->GetVar("SgToXbKeyExTimeoutInSeconds",     &g_cTicksPerSpiInfoKeyExTimeout,    1,    60*60, 20)  ||
        !pci->GetVar("SgToXbPulseTimeoutInSeconds",     &g_cTicksPerSpiInfoPulseTimeout,    1,    60*60, 20)  ||
        !pci->GetVar("XbToSgTimeoutInSeconds",          &g_cXbToSgTimeoutInSeconds,         1,    65535, 120) ||
        !pci->GetVar("XbToSgPulseTimeoutInSeconds",     &g_cXbToSgPulseTimeoutInSeconds,    1,    65535, 20)  ||
        !pci->GetVar("SpiWatchdogTimeoutInSeconds",     &g_cTicksPerSpiInfoWatchdog,        0,    60*60, 0)   ||
        !pci->GetVar("SgToXbChallengePeriodInSeconds",  &g_cTicksPerSpiInfoChalResp,        0, 24*60*60, 0)   ||
        !pci->GetVar("XbToSgChallengeAckInSeconds",     &g_cTicksPerSpiInfoChalRespAck,     0, 24*60*60, 60)  ||
        !pci->GetVar("XbToSgChallengeTimeoutInSeconds", &g_cTicksPerSpiInfoChalRespTimeout, 0, 24*60*60, 599) ||
        !pci->GetVar("NatDetectionDisconnectInSeconds", &g_cNatDetectionDisconnectTimeout,  0,    60*60, 0)   ||
        !pci->GetVar("KeyExBlockIntervalInSeconds",     &cKeyExBlockInterval,               0, 24*60*60, 4*60*60))
    {
        goto err;
    }

    //
    // Adjust scale
    //

    g_cSpiInfoTimerDenom              *= TICKS_PER_SECOND;
    g_cTicksPerSpiInfoTimeout         *= TICKS_PER_SECOND;
    g_cTicksPerSpiInfoKeyExTimeout    *= TICKS_PER_SECOND;
    g_cTicksPerSpiInfoPulseTimeout    *= TICKS_PER_SECOND;
    g_cTicksPerSpiInfoWatchdog        *= TICKS_PER_SECOND;
    g_cTicksPerSpiInfoChalResp        *= TICKS_PER_SECOND;
    g_cTicksPerSpiInfoChalRespAck     *= TICKS_PER_SECOND;
    g_cTicksPerSpiInfoChalRespTimeout *= TICKS_PER_SECOND;
    g_cNatDetectionDisconnectTimeout  *= TICKS_PER_SECOND;

    //
    // BlockInterval is recovered in Seconds, but we need to convert to 100ns
    // 

    g_qwKeyExBlockInterval = cKeyExBlockInterval;
    g_qwKeyExBlockInterval *= 1000; // s to ms
    g_qwKeyExBlockInterval *= 10000; // ms to 100 ns

    //
    // Sanity Adjustment --- if challenges are enabled, ensure that the retry
    // period is shorter than the timeout
    //
    if (g_cTicksPerSpiInfoChalRespAck != 0 &&
        g_cTicksPerSpiInfoChalRespTimeout != 0 &&
        g_cTicksPerSpiInfoChalRespAck >= g_cTicksPerSpiInfoChalRespTimeout)
    {
        g_cTicksPerSpiInfoChalRespAck = g_cTicksPerSpiInfoChalRespTimeout / 2;
    }

    // Trace
    TraceSz(Config, "    Configured SgToXb scan frequency to %d seconds (%d ticks)",
         g_cSpiInfoTimerDenom / TICKS_PER_SECOND, g_cSpiInfoTimerDenom );
    TraceSz(Config, "    Configured SgToXb inbound activity timeout to %d seconds (%d ticks)",
         g_cTicksPerSpiInfoTimeout / TICKS_PER_SECOND, g_cTicksPerSpiInfoTimeout );
    TraceSz(Config, "    Configured SgToXb key-exchange activity timeout to %d seconds (%d ticks)",
        g_cTicksPerSpiInfoKeyExTimeout / TICKS_PER_SECOND, g_cTicksPerSpiInfoKeyExTimeout );
    TraceSz(Config, "    Configured SgToXb pulse timeout to %d seconds (%d ticks)",
         g_cTicksPerSpiInfoPulseTimeout / TICKS_PER_SECOND, g_cTicksPerSpiInfoPulseTimeout );
    TraceSz(Config, "    Configured XbToSg inbound activity timeout to %d seconds",
         g_cXbToSgTimeoutInSeconds );
    TraceSz(Config, "    Configured XbToSg pulse timeout to %d seconds",
        g_cXbToSgPulseTimeoutInSeconds );
    TraceSz(Config, "    Configured watchdog timer to %d seconds (%d ticks)",
         g_cTicksPerSpiInfoWatchdog / TICKS_PER_SECOND, g_cTicksPerSpiInfoWatchdog );
    TraceSz(Config, "    Configured challenge period to %d seconds (%d ticks)",
         g_cTicksPerSpiInfoChalResp / TICKS_PER_SECOND, g_cTicksPerSpiInfoChalResp );
    TraceSz(Config, "    Configured challenge ack to %d seconds (%d ticks)",
         g_cTicksPerSpiInfoChalRespAck / TICKS_PER_SECOND, g_cTicksPerSpiInfoChalRespAck );
    TraceSz(Config, "    Configured challenge timeout to %d seconds (%d ticks)",
         g_cTicksPerSpiInfoChalRespTimeout / TICKS_PER_SECOND, g_cTicksPerSpiInfoChalRespTimeout );
    TraceSz( Config, "   Configured Nat detection disconnect to %u seconds (%u ticks)",
        g_cNatDetectionDisconnectTimeout / TICKS_PER_SECOND, g_cNatDetectionDisconnectTimeout );
    TraceSz( Config, "   Configued Block Interval to %d seconds (%016I64d ns)",
        cKeyExBlockInterval, g_qwKeyExBlockInterval );

    if (g_cTransInfo == 0)
    {
        // Cannot configure CSpiInfo until CTransInfo is configured.
        SgEventSz(CONFIG_WARNING, "Cannot configure clients before network interfaces.");
        goto err;
    }

    if (g_cSpiInfo > 0)
    {
        // Ignore attempt to reconfigure the maximum number of clients.
        return(TRUE);
    }

    // Get the requested number of clients

    UINT cSpiInfo = 0, cCliInfo = 0, cNatInfo = 0, cPortPerNatInfo = 0, cBlockInfo = 0;

    if(!pci->GetVar("ClientLimit", &cSpiInfo, 1, 0xFFFFF, 40000) ||
       !pci->GetVar("ClientHistoryLimit", &cCliInfo, 1, 0x200000, 50000) ||
       !pci->GetVar("ClientPortLimit", &cPortPerNatInfo, 16, 1024, 64) ||
       !pci->GetVar("ConnectionServerPortLimit", &g_dwConnectionServerPortLimit, 0, 1024, 0) ||
       !pci->GetVar("BlockLimit", &cBlockInfo, 1, 0xFFFFF, 40000))
    {
        goto err;
    }

    if (g_dwConnectionServerPortLimit >= cPortPerNatInfo)
    {
        SgEventSz(CONFIG_ERROR, "Config error: ConnectionServerPortLimit must be less than ClientPortLimit");
        goto err;
    }

    if( !SgNatInfoConfig( cSpiInfo, cPortPerNatInfo ) )
    {
        goto err;
    }

    if (cSpiInfo > g_cNatInfoValid)
    {
        cSpiInfo = g_cNatInfoValid;
    }

    if (cCliInfo < cSpiInfo)
    {
        // cCliInfo needs be to larger than cSpiInfo in case all cSpiInfo clients connect;
        // additional connections at that point will fail to allocate a CCliInfo and cause
        // a bad looking event. This can be prevented if you just set cCliInfo
        // sufficiently higher than cSpiInfo;
        cCliInfo = cSpiInfo + 1000;
    }

    if (!SgCliInfoConfig(cCliInfo))
    {
        goto err;
    }

    if (!SgBlockInfoConfig(cBlockInfo)) 
    {
        goto err;
    }

    if (cSpiInfo == 0)
    {
        goto err;
    }

    g_pSpiInfo = (CSpiInfo *)SgMemAllocZ(cSpiInfo * sizeof(CSpiInfo), PTAG_CSpiInfo);

    if (g_pSpiInfo == NULL)
    {
        TraceSz(Config, "Config error: Out of memory allocating vector of %d CSpiInfo (%d bytes). This is controlled by the \"ClientLimit\" setting.",
                 cSpiInfo, cSpiInfo * sizeof(CSpiInfo));
        goto err;
    }

    CSpiInfo * pSpiInfo     = g_pSpiInfo;
    CSpiInfo * pSpiInfoEnd  = pSpiInfo + cSpiInfo;

    for (; pSpiInfo < pSpiInfoEnd; ++pSpiInfo)
    {
        pSpiInfo->_lock.Init();
    }

    g_cSpiInfo = cSpiInfo;
    TraceSz( Config, "    Configured client limit to %u clients", cSpiInfo );

    return(TRUE);

err:
    return(FALSE);
}

CSpiInfo *SgSpiInfoAllocSpiOnly()
{
    CSpiInfo * pSpiInfo;

    g_lockSpiInfoFree.AcquireDpc();

    if (g_cSpiInfoFree == 0)
    {
        if (g_cSpiInfoInUse == g_cSpiInfo)
        {
            g_lockSpiInfoFree.ReleaseDpc();
            SgEventSz(MAX_CLIENT_LIMIT,
                      "Warning: Maximum client limit reached. No more clients can connect. Current configured maximum is %u connections. Please refer to the ClientLimit setting.",
                      g_cSpiInfo);
            return NULL;
        }

        pSpiInfo = g_pSpiInfoLast = &g_pSpiInfo[g_cSpiInfoInUse++];
    }
    else
    {
        Assert(!IsListEmpty(&g_leSpiInfoFree));
        Assert(g_cSpiInfoFree > 0);
        g_cSpiInfoFree -= 1;
        pSpiInfo = (CSpiInfo *)RemoveHeadList(&g_leSpiInfoFree);
    }

    g_lockSpiInfoFree.ReleaseDpc();

    pSpiInfo->_leFree.Flink = NULL;

    memset(&pSpiInfo->_ppkt, 0, sizeof(CSpiInfo) - offsetof(CSpiInfo, _ppkt));

    SgClientStatsAttach(pSpiInfo);

    // Generate a random dwSpiRecv that maps to this CSpiInfo.  The least significant byte
    // is reserved and must be zero.  The remainder of the DWORD is MOD'd with the count of
    // CSpiInfo allocated to compute the iSpiInfo.  This algorithm makes it hard to predict the
    // values for dwSpi the security gateway gives out, and thus helps stop denial of service
    // attacks because validating a dwSpi is extremely fast.

    DWORD dwSpiRecv = 0xBADDFACE;

    do
    {
        SgRand((BYTE *)&dwSpiRecv, sizeof(dwSpiRecv));
        dwSpiRecv &= 0xFFFFFF;
        dwSpiRecv -= (dwSpiRecv % g_cSpiInfo);
        dwSpiRecv += (DWORD)((pSpiInfo - g_pSpiInfo));
    }
    while (dwSpiRecv > 0xFFFFFF || dwSpiRecv == 0);

    // Grab the lock that protects this SPI
    pSpiInfo->_lock.AcquireDpc();

    // Set the generated dwSpiRecv
    pSpiInfo->_dwSpiRecv = (dwSpiRecv << 8);

    // Perf counter
    SgPerfdataInterlockedInc(QueuedSpi);

    // return the point to the spi
    return pSpiInfo;
}

void SgSpiInfoAlloc(CPacket * ppkt, PFNCOMPLETE pfn, DWORD dwSpiOld)
{
    CSpiInfo * pSpiInfo;

    AssertSz(ppkt->_pSpiInfo == NULL, "Cannot attach to more than one CSpiInfo at a time");

    ppkt->CompletePush(pfn);

    // Allocate a new SPI
    pSpiInfo = SgSpiInfoAllocSpiOnly();
    if (pSpiInfo == NULL)
    {
        ppkt->Complete();
        return;
    }

    // Insert the packet to the tail of the list
    Assert(pSpiInfo->_pq.IsEmpty());
    pSpiInfo->_pq.InsertTail(ppkt);

    // Remember what the old spi was (reinit)
    pSpiInfo->_dwSpiOld = dwSpiOld;

    // dispatch the spi
    SgSpiInfoDispatch(pSpiInfo);
}

void SgSpiInfoFree(CSpiInfo * pSpiInfo, DWORD dwReason)
{
    pSpiInfo->_lock.AcquireDpc();

    if (!pSpiInfo->_fDeleted)
    {
        Assert(pSpiInfo->_leFree.Flink == NULL);
        Assert(pSpiInfo->_dwSpiRecv != 0);
        Assert(dwReason < MAX_SPIDEL);

        pSpiInfo->_fDeleted       = TRUE;
        pSpiInfo->_dwDeleteReason = dwReason;

        SgPerfdataInc(LogoffTotal, 1);

        SgCliInfoResetSpiInfo(pSpiInfo->_pCliInfo, pSpiInfo);
        pSpiInfo->_pCliInfo = NULL;

        SgSpiInfoDispatch(pSpiInfo);
        return;
    }

    pSpiInfo->_lock.ReleaseDpc();
}

void SgSpiInfoKick(CSpiInfo * pSpiInfo, DWORD dwReason, DWORD dwDelReason)
{
    CPacket * ppktKick = SgPacketAlloc();

    if (ppktKick == NULL)
    {
        TraceSz(Warning, "SgSpiInfoKick - Unable to allocate a packet");
    }
    else
    {
        CSecMsgDelete * pSecMsgDelete = (CSecMsgDelete *)&ppktKick->_abCtx[CBCTX_SKIP_SECMSG];
        pSecMsgDelete->_wType         = SECMSG_TYPE_DELETE;
        pSecMsgDelete->_cbEnt         = sizeof(CSecMsgDelete);
        pSecMsgDelete->_dwReason      = dwReason;

        ppktKick->_pb = (BYTE *)pSecMsgDelete;
        ppktKick->_cb = pSecMsgDelete->_cbEnt;

        SgSpiInfoAttach(ppktKick, SgIXmitSecMsgWithSpi, pSpiInfo->_dwSpiRecv);
    }

    TraceSz(SpiTrace, "%08lX released PUID %s (%s)", pSpiInfo->_dwSpiRecv,
             SgHexStr(&pSpiInfo->_puid, sizeof(pSpiInfo->_puid)),
             SgSecMsgDelStr(dwReason));

    Assert((dwReason == SECMSG_DELETE_KICK && (dwDelReason == SPIDEL_KICK ||
                                               dwDelReason == SPIDEL_NAT_DETECTION_DISCONNECT ||
                                               dwDelReason == SPIDEL_CHALLENGE_TIMEOUT ||
                                               dwDelReason == SPIDEL_PACKET_LIMIT ||
                                               dwDelReason == SPIDEL_TICKET_EXPIRED ||
                                               dwDelReason == SPIDEL_POLICY)) ||
           (dwReason == SECMSG_DELETE_KILL && dwDelReason == SPIDEL_BLOCK2));

    SgPerfdataInc(LogoffKick, 1);
    SgSpiInfoFree(pSpiInfo, dwDelReason);
}

void SgSpiInfoAttach(CPacket * ppkt, PFNCOMPLETE pfn, DWORD dwSpi)
{
    AssertSz(ppkt->_pSpiInfo == NULL, "Cannot attach to more than one CSpiInfo at a time");

    ppkt->CompletePush(pfn);

    if (g_cSpiInfo == 0 || dwSpi == 0)
        goto complete;

    CSpiInfo * pSpiInfo = &g_pSpiInfo[(dwSpi >> 8) % g_cSpiInfo];

    pSpiInfo->_lock.AcquireDpc();

    if (pSpiInfo->_dwSpiRecv != dwSpi || pSpiInfo->_fDeleted)
    {
        // Either this is the wrong CSpiInfo or it is marked for deletion, so just let
        // go of the lock and call the packet completion routine with ppkt->_pSpiInfo
        // set to NULL to signal that the attach failed.

        pSpiInfo->_lock.ReleaseDpc();
        goto complete;
    }

    if (pSpiInfo->_pq.Count() >= SPI_PACKET_QUEUE_MAX)
    {
        // We reached the limit on the number of packets allowed in the Spi
        // queue. Drop the packet.
        pSpiInfo->_lock.ReleaseDpc();
        SgPerfdataInc(DroppedSpi, 1);
        TraceSz(SpiFlow, "%08lX full queue - dropping packet", pSpiInfo->_dwSpiRecv );
        goto complete;
    }

    // Add the packet to the queue of packets waiting for access to this CSpiInfo and
    // call the dispatcher to process them.

    pSpiInfo->_pq.InsertTail(ppkt);
    SgPerfdataInterlockedInc(QueuedSpi);

    SgSpiInfoDispatch(pSpiInfo);

    return;

complete:
    ppkt->Complete();
    return;
}

void SgSpiInfoDetach(CPacket * ppkt)
{
    CSpiInfo * pSpiInfo = ppkt->_pSpiInfo;

    if (pSpiInfo != NULL)
    {
        // Remove the SgSpiInfoDispatchComplete completion routine from the packet

        PFNCOMPLETE * ppfnSrc = ppkt->_apfn;
        PFNCOMPLETE * ppfnDst = ppkt->_apfn;
        UINT          cpfn    = ppkt->_cpfn;

        for (; cpfn > 0; --cpfn, ++ppfnSrc)
        {
            if ((*ppfnDst = *ppfnSrc) == SgSpiInfoDispatchComplete)
                ppkt->_cpfn -= 1;
            else
                ppfnDst += 1;
        }

        // Acquire the lock on the CSpiInfo to release its reference on the packet

        pSpiInfo->_lock.AcquireDpc();

        Assert(pSpiInfo->_ppkt == ppkt);
        pSpiInfo->_ppkt = NULL;
        ppkt->_pSpiInfo = NULL;
        pSpiInfo->_qwTickWatchdog = 0;

        SgSpiInfoDispatch(pSpiInfo);
    }
}

void SgSpiInfoDispatch(CSpiInfo * pSpiInfo)
{
    // Note: CSpiInfo is locked when this function is called

    // Spi is not currently processing a packet, so we can try to give it a packet.
    // Otheriwse, if it is processing a packet, do nothing - the SgSpiInfoDispatchComplete
    // function, which will eventually get called by the packet, will call into here
    // again.
    if (pSpiInfo->_ppkt == NULL)
    {
        // Spi's packet queue is not empty, so grab top packet and let Spi go process it
        if (!pSpiInfo->_pq.IsEmpty())
        {
            // Pop off top packet in queue
            CPacket * ppkt = pSpiInfo->_pq.RemoveHead();
            SgPerfdataInterlockedDec(QueuedSpi);

            Assert(ppkt->_pSpiInfo == NULL);

            ppkt->_pSpiInfo = pSpiInfo;
            pSpiInfo->_ppkt = ppkt;
            pSpiInfo->_qwTickWatchdog = SgTimerTick();

            pSpiInfo->_lock.ReleaseDpc();

            // The SgSpiInfoDispatchComplete function is not inserted at the top of the
            // packet's function stack, but rather 1 item down. This lets the packet's
            // SgRecv* (decryption, etc) complete BEFORE the DispatchComplete, which will
            // end up dispatching another packet from the spi's queue and cleaning up the
            // packet.
            Assert(ppkt->_cpfn > 0);
            PFNCOMPLETE * ppfn = &ppkt->_apfn[ppkt->_cpfn - 1];
            PFNCOMPLETE   pfn  = *ppfn;
            *ppfn = SgSpiInfoDispatchComplete;
            ppkt->CompletePush(pfn);

            // Queue the packet for the workers
            SgProcBalQueuePacket(ppkt);
            return;
        }

        // The queue of packets is empty.  If this CSpiInfo is marked for deletion, free it now.

        if (pSpiInfo->_fDeleted)
        {
            // The per-cipher perf counters are keyed off the _qwTickKeyEx1 field. This is because 
            // we are responsible for both incrementing and decrementing them, and these need to 
            // sum to zero.
            if (pSpiInfo->_qwTickKeyEx1 != 0)
            {
                switch (pSpiInfo->_cbKeyCrypt)
                {
                case XC_SERVICE_DES_KEYSIZE:
                    SgPerfdataInterlockedDec(ConnectionsCipherDes);
                    break;
                case XC_SERVICE_DES3_KEYSIZE:
                    SgPerfdataInterlockedDec(ConnectionsCipherDes3);
                    break;
                case XC_SERVICE_AES_KEYSIZE:
                    SgPerfdataInterlockedDec(ConnectionsCipherAes);
                    break;
                case XC_SERVICE_NULL_KEYSIZE:
                    SgPerfdataInterlockedDec(ConnectionsCipherNull);
                    break;
                }
            }

            SgIndicateSgSvcClient(pSpiInfo, SGSVC_TYPE_CLIENT_DEL, NULL, NULL);

            Assert(pSpiInfo->_dwSpiRecv != 0);
            Assert(pSpiInfo->_leFree.Flink == NULL);

#ifdef SG_FEATURE_LUA
            // Release Lua storage for this spi
            SgLuaReleaseSpiStorage(pSpiInfo);
#endif

            pSpiInfo->_dwSpiRecv = 0;
            SgNatInfoFree(pSpiInfo->_pNatInfo);

            g_lockSpiInfoFree.AcquireDpc();

            InsertTailList(&g_leSpiInfoFree, &pSpiInfo->_leFree);
            g_cSpiInfoFree += 1;

            g_lockSpiInfoFree.ReleaseDpc();
        }
    }

    pSpiInfo->_lock.ReleaseDpc();
}

void SgSpiInfoDispatchComplete(CPacket * ppkt)
{
    // This function gets called *after* the packet has gone through all its 'hard' work.

    CSpiInfo * pSpiInfo = ppkt->_pSpiInfo;

    Assert(pSpiInfo != NULL);

    pSpiInfo->_lock.AcquireDpc();

    Assert(pSpiInfo->_ppkt == ppkt);

    ppkt->_pSpiInfo = NULL;
    pSpiInfo->_ppkt = NULL;
    pSpiInfo->_qwTickWatchdog = 0;

    // Dispatch another packet on the spi's queue, if there is one
    SgSpiInfoDispatch(pSpiInfo);

    ppkt->Complete();
}

void SgSpiInfoTimer()
{
    if (g_cSpiInfoInUse == 0)
        return;

    g_cSpiInfoTimerNumer += g_cSpiInfoInUse;

    if (g_cSpiInfoTimerNumer < g_cSpiInfoTimerDenom)
        return;

    UINT64  qwTickNow         = SgTimerTick();
    UINT64  qwTickPulse       = qwTickNow - g_cTicksPerSpiInfoPulseTimeout;
    UINT64  qwTickKeyEx       = qwTickNow - g_cTicksPerSpiInfoKeyExTimeout;
    UINT64  qwTickTimeout     = qwTickNow - g_cTicksPerSpiInfoTimeout;
    UINT64  qwTickWatchdog    = qwTickNow - g_cTicksPerSpiInfoWatchdog;
    UINT64  qwTickNatDetect   = qwTickNow - g_cNatDetectionDisconnectTimeout;

    UINT    cSpiInfo          = g_cSpiInfoTimerNumer / g_cSpiInfoTimerDenom;
    g_cSpiInfoTimerNumer     -= cSpiInfo * g_cSpiInfoTimerDenom;

    Assert(g_cSpiInfoTimerNumer < g_cSpiInfoTimerDenom);

    CSpiInfo * pSpiInfo = g_pSpiInfoTimer ? g_pSpiInfoTimer : g_pSpiInfo;

    for (; cSpiInfo > 0; --cSpiInfo, ++pSpiInfo)
    {
        if (pSpiInfo > g_pSpiInfoLast)
            pSpiInfo = g_pSpiInfo;

        if (pSpiInfo->_leFree.Flink != NULL)
        {
            continue;
        }

        // pSpiInfo is not on the free list ...

        if (   (pSpiInfo->_qwTickWatchdog > 0 && pSpiInfo->_qwTickWatchdog <= qwTickWatchdog)
            ||  pSpiInfo->_qwTickRecv  <= qwTickTimeout
            ||  pSpiInfo->_qwTickPulse <= qwTickPulse
#ifdef SG_FEATURE_LUA
            ||  (pSpiInfo->_dwChalAsyncState != SPI_CHAL_ASYNC_STATE_OFF &&
                    pSpiInfo->_qwTickChalAsync != 0 &&
                    pSpiInfo->_qwTickChalAsync <= qwTickNow)
#endif
            ||  (pSpiInfo->_qwTickTicketStart != 0 && 
                    pSpiInfo->_qwTickTicketEnd <= qwTickNow)
            ||  (g_cNatDetectionDisconnectTimeout &&
                    pSpiInfo->_qwTickNatDetect &&
                    pSpiInfo->_qwTickNatDetect <= qwTickNatDetect))
        {
            CPacket * ppkt = SgPacketAlloc();

            if (ppkt == NULL)
            {
                TraceSz(
                    Warning,
                    "SgSpiInfoTimer - Unable to allocate a packet"
                    );
            }
            else
            {
                SgSpiInfoAttach(
                    ppkt,
                    SgSpiInfoTimerWithSpi,
                    pSpiInfo->_dwSpiRecv
                    );
            }
        }
    }

    g_pSpiInfoTimer = pSpiInfo;
}

void SgSpiInfoTimerWithSpi(CPacket * ppkt)
{
    CSpiInfo * pSpiInfo = ppkt->_pSpiInfo;

    if (pSpiInfo != NULL)
    {
        UINT64  qwTickNow         = SgTimerTick();
        UINT64  qwTickPulse       = qwTickNow - g_cTicksPerSpiInfoPulseTimeout;
        UINT64  qwTickKeyEx       = qwTickNow - g_cTicksPerSpiInfoKeyExTimeout;
        UINT64  qwTickTimeout     = qwTickNow - g_cTicksPerSpiInfoTimeout;
        UINT64  qwTickWatchdog    = qwTickNow - g_cTicksPerSpiInfoWatchdog;
        UINT64  qwTickNatDetect   = qwTickNow - g_cNatDetectionDisconnectTimeout;

        if (pSpiInfo->_qwTickWatchdog > 0 && pSpiInfo->_qwTickWatchdog <= qwTickWatchdog)
        {
            // pSpiInfo has been attached to a packet for too long ...

            TraceSz(
                SpiTrace,
                "%08lX watchdog PUID %s (attached for %d secs)",
                pSpiInfo->_dwSpiRecv,
                SgHexStr(&pSpiInfo->_puid,sizeof(pSpiInfo->_puid)),
                SgTickElapsedInSeconds( pSpiInfo->_qwTickWatchdog, qwTickNow )
                );
        }

        if (pSpiInfo->_qwTickTicketStart != 0 && pSpiInfo->_qwTickTicketEnd <= qwTickNow) 
        {
            TraceSz(
                SpiTrace,
                "%08lX kicking PUID %s (Now %I64d - Ticket Expired %d secs ago)",
                pSpiInfo->_dwSpiRecv,
                SgHexStr(&pSpiInfo->_puid, sizeof(pSpiInfo->_puid)),
                qwTickNow,
                SgTickElapsedInSeconds( pSpiInfo->_qwTickTicketEnd, qwTickNow )
                );

            SgSpiInfoKick(
                pSpiInfo,
                SECMSG_DELETE_KICK,
                SPIDEL_TICKET_EXPIRED
                );
            ppkt->Complete();
            return;
        }

        if (g_cNatDetectionDisconnectTimeout &&
            pSpiInfo->_qwTickNatDetect &&
            pSpiInfo->_qwTickNatDetect <= qwTickNatDetect)
        {
            Assert(!pSpiInfo->_fCs);

            TraceSz(
                SpiTrace,
                "%08lX kicking PUID %s (Nat detection happened %d secs ago)",
                pSpiInfo->_dwSpiRecv,
                SgHexStr(&pSpiInfo->_puid, sizeof(pSpiInfo->_puid)),
                SgTickElapsedInSeconds( pSpiInfo->_qwTickNatDetect, qwTickNow )
                );

            SgSpiInfoKick(
                pSpiInfo,
                SECMSG_DELETE_KICK,
                SPIDEL_NAT_DETECTION_DISCONNECT
                );
            ppkt->Complete();
            return;
        }

        if (pSpiInfo->_qwTickRecv <= qwTickTimeout)
        {
            // pSpiInfo has not received a packet in a long time ...

            if (pSpiInfo->_qwTickRecv == 0)
            {
                // pSpiInfo has never received a packet ...

                if (pSpiInfo->_qwTickKeyEx1 > 0 && pSpiInfo->_qwTickKeyEx1 <= qwTickKeyEx)
                {
                    // pSpiInfo has sent a key-exchange response but not
                    // received a packet in a long enough time that the client
                    // should be considered down, or unable to generate an
                    // authenticated response (because it was replaying a valid
                    // key-exchange packet).  Reclaim the entry for reuse.

                    TraceSz(
                        SpiTrace,
                        "%08lX released PUID %s (timeout %d secs after KeyEx)",
                        pSpiInfo->_dwSpiRecv,
                        SgHexStr(&pSpiInfo->_puid, sizeof(pSpiInfo->_puid)),
                        SgTickElapsedInSeconds( pSpiInfo->_qwTickKeyEx1, qwTickNow )
                        );
#ifdef SG_FEATURE_LUA
                    SgChalDropped(pSpiInfo);
#endif
                    SgPerfdataInc(LogoffTimeoutKeyEx, 1);
                    SgSpiInfoFree(pSpiInfo, SPIDEL_TIMEOUT_KEYEX);
                }
            }
            else
            {
                // pSpiInfo has not received a packet in a long enough time that the client
                // should be considered down.

                TraceSz(
                    SpiTrace,
                    "%08lX released PUID %s (timeout %d secs)",
                    pSpiInfo->_dwSpiRecv,
                    SgHexStr(&pSpiInfo->_puid, sizeof(pSpiInfo->_puid)),
                    SgTickElapsedInSeconds( pSpiInfo->_qwTickRecv, qwTickNow )
                    );
#ifdef SG_FEATURE_LUA
                    SgChalDropped(pSpiInfo);
#endif
                SgPerfdataInc(LogoffTimeout, 1);
                SgSpiInfoFree(pSpiInfo, SPIDEL_TIMEOUT);
            }
            ppkt->Complete();
            return;
        }

#ifdef SG_FEATURE_LUA
        if (pSpiInfo->_dwChalAsyncState != SPI_CHAL_ASYNC_STATE_OFF &&
            pSpiInfo->_qwTickChalAsync &&
            pSpiInfo->_qwTickChalAsync <= qwTickNow)
        {
            // Resend/Send a challenge packet to the client
            SgIXmitSecMsgSgToXbChallenge( pSpiInfo,  ppkt );
            return;
        }
#endif // #ifdef SG_FEATURE_LUA

        if (pSpiInfo->_qwTickPulse <= qwTickPulse)
        {
            if (    pSpiInfo->_qwTickXmit <= qwTickPulse
                || (pSpiInfo->_fCs && (pSpiInfo->_dwSeqXbToSg || pSpiInfo->_fSgToXbPulse)))
            {
                // pSpiInfo has not transmitted a packet in a long enough time that we should
                // send a SECMSG_TYPE_SGTOXB_PULSE_2 packet to let the client know that the
                // gateway is still alive.

                SgIXmitSecMsgSgToXbPulse(pSpiInfo, ppkt);
                return;
            }
            ppkt->Complete();
            return;
        }
    }

    ppkt->Complete();
}

void SgSpiInfoToSgAddr(CSpiInfo * pSpiInfo, SGADDR * psgaddr)
{
#ifdef SG_FEATURE_INSECURE
    if (pSpiInfo)
#else
    if (pSpiInfo && pSpiInfo->_fCs)
#endif
    {
        SGADDR2* psgaddr2 = (SGADDR2*) psgaddr;
        C_ASSERT(sizeof(SGADDR2) == sizeof(SGADDR));

        psgaddr2->inaSg     = pSpiInfo->_pNatInfo->_pTransInfo->_ipa;
        psgaddr2->dwSpiSg   = pSpiInfo->_dwSpiRecv;
        psgaddr2->qwXboxID  = pSpiInfo->_AuthData.qwXboxID;
        psgaddr2->bPlatform = pSpiInfo->_AuthData.GetPlatform();
        memset(psgaddr2->abReserved, 0, sizeof(psgaddr2->abReserved));
    }
    else
    {
        memset(psgaddr, 0, sizeof(SGADDR));
    }
}

BOOL SgSpiInfoMatchesSgAddr(CSpiInfo * pSpiInfo, SGADDR * psgaddr)
{
    SGADDR sgaddr;

    SgSpiInfoToSgAddr(pSpiInfo, &sgaddr);

    return(memcmp(&sgaddr, psgaddr, sizeof(SGADDR)) == 0);
}

// ---------------------------------------------------------------------------------------
// CCliInfo
// ---------------------------------------------------------------------------------------

DECLARE_HASH_TABLE(CliInfo);

CCliInfo *      g_pCliInfo;             // Vector of all CCliInfo structures
UINT            g_cCliInfo;             // Number of CCliInfo structures allocated
UINT            g_cCliInfoInUse;        // Number of CCliInfo structures in use
CCliInfoHash *  g_pCliInfoHash;         // Hash table mapping {_dwSiteId|_puid} to CCliInfo *
LIST_ENTRY      g_leCliInfoLru;         // Queue of  CCliInfo structures in use in LRU order
CLock           g_lockCliInfo;          // Synchronizes CCliInfo setup

BOOL SgCliInfoInit()
{
    Assert(g_pCliInfo == NULL);
    Assert(g_cCliInfo == 0);
    Assert(g_cCliInfoInUse == 0);
    Assert(g_pCliInfoHash == NULL);
    Assert(g_leCliInfoLru.Flink == NULL);
    Assert(g_leCliInfoLru.Blink == NULL);
    InitializeListHead(&g_leCliInfoLru);
    g_lockCliInfo.Init();
    return(TRUE);
}

void SgCliInfoTerm()
{
    if (g_cCliInfo > 0)
    {
        CCliInfo * pCliInfo    = g_pCliInfo;
        CCliInfo * ppCliInfoEnd = pCliInfo + g_cCliInfo;

        for (; pCliInfo < ppCliInfoEnd; ++pCliInfo)
        {
            pCliInfo->_lock.Term();
        }
    }

    SgMemFree(g_pCliInfo);
    delete g_pCliInfoHash;

    g_pCliInfo      = NULL;
    g_cCliInfo      = 0;
    g_cCliInfoInUse = 0;
    g_pCliInfoHash  = NULL;

    g_lockCliInfo.Term();
    memset(&g_leCliInfoLru, 0, sizeof(g_leCliInfoLru));
}

BOOL SgCliInfoConfig(UINT cCliInfo)
{
    g_pCliInfo = (CCliInfo *)SgMemAllocZ(cCliInfo * sizeof(CCliInfo), PTAG_CCliInfo);

    if (g_pCliInfo == NULL)
    {
        TraceSz(Config, "Config error: Out of memory allocating vector of %d CCliInfo (%d bytes)",
                 cCliInfo, cCliInfo * sizeof(CCliInfo));
        return(FALSE);
    }

    CCliInfo * pCliInfo     = g_pCliInfo;
    CCliInfo * pCliInfoEnd  = pCliInfo + cCliInfo;

    for (int i = 0; pCliInfo < pCliInfoEnd; ++pCliInfo, ++i)
    {
        pCliInfo->_iCliInfo = i;
        pCliInfo->_lock.Init();
    }

    g_pCliInfoHash = new CCliInfoHash;

    if (g_pCliInfoHash == NULL || !g_pCliInfoHash->Init(cCliInfo, NULL))
    {
        TraceSz(Config, "Config error: Out of memory allocating CCliInfoHash (%d entries)",
                 cCliInfo);
        return(FALSE);
    }

    g_cCliInfo      = cCliInfo;
    g_cCliInfoInUse = 0;

    TraceSz( Config, "    Configured client history with %u clients in %u hash buckets",
              g_cCliInfo, g_pCliInfoHash->GetBucketCount() );

    return(TRUE);
}


void SgCliInfoAttach(CPacket * ppkt, PFNCOMPLETE pfn, DWORD dwSiteId, PUID * ppuid)
{
    AssertSz(ppkt->_pCliInfo == NULL, "Cannot attach to more than one CCliInfo");

    ppkt->CompletePush(pfn);

    CCliInfo CliInfo;
    CliInfo._dwSiteId = dwSiteId;
    CliInfo._puid     = *ppuid;

    SgCliInfoLock();

    if (g_cCliInfo == 0)
    {
        // Not yet initialized
        SgCliInfoUnlock();
        goto complete;
    }

    CCliInfo * pCliInfo = g_pCliInfoHash->Lookup(&CliInfo);

    if (pCliInfo == NULL)
    {
        // Grab an unused CliInfo. This will remove it from the free list
        pCliInfo = SgCliInfoAlloc(dwSiteId, ppuid);
    }
    else if (pCliInfo->_leLru.Flink)
    {
        // We remove it from the free list so that it doesn't get re-used.
        RemoveEntryList(&pCliInfo->_leLru);
        pCliInfo->_leLru.Flink = NULL;
    }

    SgCliInfoUnlock();

    if (pCliInfo == NULL)
        goto complete;

    pCliInfo->_lock.AcquireDpc();
    
    if (pCliInfo->_pq.Count() >= CLI_PACKET_QUEUE_MAX)
    {
        // We reached the limit on the number of packets allowed in the Cli
        // queue. Drop the packet.
        pCliInfo->_lock.ReleaseDpc();
        SgPerfdataInc(DroppedCli, 1);
        goto complete;
    }

    // Add the packet to the queue of packets waiting for access to this CCliInfo and
    // call the dispatcher to process them.

    pCliInfo->_pq.InsertTail(ppkt);
    SgPerfdataInterlockedInc(QueuedCli);

    SgCliInfoDispatch(pCliInfo);

    return;

complete:
    ppkt->Complete();
    return;
}

void SgCliInfoDetach(CPacket * ppkt)
{
    CCliInfo * pCliInfo = ppkt->_pCliInfo;

    if (pCliInfo != NULL)
    {
        // Remove the SgCliInfoDispatchComplete completion routine from the packet

        PFNCOMPLETE * ppfnSrc = ppkt->_apfn;
        PFNCOMPLETE * ppfnDst = ppkt->_apfn;
        UINT          cpfn    = ppkt->_cpfn;

        for (; cpfn > 0; --cpfn, ++ppfnSrc)
        {
            if ((*ppfnDst = *ppfnSrc) == SgCliInfoDispatchComplete)
                ppkt->_cpfn -= 1;
            else
                ppfnDst += 1;
        }

        // Acquire the lock on the CCliInfo to release its reference on the packet

        pCliInfo->_lock.AcquireDpc();

        Assert(pCliInfo->_ppkt == ppkt);
        pCliInfo->_ppkt = NULL;
        ppkt->_pCliInfo = NULL;

        SgCliInfoDispatch(pCliInfo);
    }
}

void SgCliInfoDispatch(CCliInfo * pCliInfo)
{
    // Note: CCliInfo is locked when this function is called

    Assert(pCliInfo->_leLru.Flink == NULL);

    if (pCliInfo->_ppkt == NULL)
    {
        // Dispatch pending key exchange packets

        if (!pCliInfo->_pq.IsEmpty())
        {
            CPacket * ppkt = pCliInfo->_pq.RemoveHead();
            SgPerfdataInterlockedDec(QueuedCli);

            Assert(ppkt->_pCliInfo == NULL);

            ppkt->_pCliInfo = pCliInfo;
            pCliInfo->_ppkt = ppkt;

            pCliInfo->_lock.ReleaseDpc();

            Assert(ppkt->_cpfn > 0);
            PFNCOMPLETE * ppfn = &ppkt->_apfn[ppkt->_cpfn - 1];
            PFNCOMPLETE   pfn  = *ppfn;
            *ppfn = SgCliInfoDispatchComplete;
            ppkt->CompletePush(pfn);

            SgProcBalQueuePacket(ppkt);
            return;
        }

        // The queue of packets is empty.

        if (pCliInfo->_fSpiDeleted)
        {
            Assert(pCliInfo->_dwSpi != 0);

            pCliInfo->_dwSpi = 0;
            pCliInfo->_fSpiDeleted = FALSE;
        }

        if (pCliInfo->_dwSpi == 0)
        {
            Assert(pCliInfo->_leLru.Flink == NULL);

            SgCliInfoLock();
            InsertTailList(&g_leCliInfoLru, &pCliInfo->_leLru);
            SgCliInfoUnlock();
        }
    }

    pCliInfo->_lock.ReleaseDpc();
}

void SgCliInfoDispatchComplete(CPacket * ppkt)
{
    CCliInfo * pCliInfo = ppkt->_pCliInfo;

    Assert(pCliInfo != NULL);

    pCliInfo->_lock.AcquireDpc();

    Assert(pCliInfo->_ppkt == ppkt);

    ppkt->_pCliInfo = NULL;
    pCliInfo->_ppkt = NULL;

    SgCliInfoDispatch(pCliInfo);

    ppkt->Complete();
}

void SgCliInfoSetSpiInfo(CCliInfo * pCliInfo, CSpiInfo * pSpiInfo)
{
    Assert(pSpiInfo != NULL);
    AssertSz(pCliInfo->_ppkt != NULL, "Can't set SPI without holding CLI");
    AssertSz(pCliInfo->_ppkt->_pCliInfo == pCliInfo, "Can't set SPI without holding CLI");
    AssertSz(pCliInfo->_dwSpi == 0 || pCliInfo->_fSpiDeleted, "Can't overrwrite active SPI");
    AssertSz(pSpiInfo->_dwSpiRecv != 0, "dwSpiRecv must not be zero");

    pCliInfo->_dwSpi = pSpiInfo->_dwSpiRecv;
    pCliInfo->_fSpiDeleted = FALSE;
}

void SgCliInfoResetSpiInfo(CCliInfo * pCliInfo, CSpiInfo * pSpiInfo)
{
    if (pCliInfo)
    {
        pCliInfo->_lock.AcquireDpc();

        if (pCliInfo->_dwSpi == pSpiInfo->_dwSpiRecv)
        {
            Assert(!pCliInfo->_fSpiDeleted);
            pCliInfo->_fSpiDeleted = TRUE;
            SgCliInfoDispatch(pCliInfo);
            return;
        }

        pCliInfo->_lock.ReleaseDpc();
    }
}

CCliInfo * SgCliInfoAlloc(DWORD dwSiteId, PUID * ppuid)
{
    CCliInfo * pCliInfo;

    if (g_cCliInfoInUse < g_cCliInfo)
    {
        pCliInfo = &g_pCliInfo[g_cCliInfoInUse++];
    }
    else if (IsListEmpty(&g_leCliInfoLru))
    {
        // We're out of CCliInfos. This can happen if there are a lot of
        // key exchanges going on at once.
        SgEventSz(MAX_KEYEX_LIMIT, "Site id: 0x%08X, machine puid: 0x%016I64X", dwSiteId, ppuid->QuadPart);
        return(NULL);
    }
    else
    {
        LIST_ENTRY * pleLru = RemoveHeadList(&g_leCliInfoLru);
        pCliInfo = SgCliInfoFromLruLink(pleLru);
        g_pCliInfoHash->Delete(pCliInfo);

        Assert(pCliInfo->_ppkt == NULL);
        Assert(pCliInfo->_pq.IsEmpty());
        Assert(!pCliInfo->_fSpiDeleted);
        Assert(pCliInfo->_dwSpi == 0);
    }

    pCliInfo->_leHash.Flink     = NULL;
    pCliInfo->_leLru.Flink      = NULL;
    pCliInfo->_dwSiteId         = dwSiteId;
    pCliInfo->_puid             = *ppuid;

    memset(&pCliInfo->_ppkt, 0, sizeof(CCliInfo) - offsetof(CCliInfo, _ppkt));

    g_pCliInfoHash->Insert(pCliInfo);

    return(pCliInfo);
}

DWORD SgCliInfoHashCompute(CCliInfo * pCliInfo)
{
    return(pCliInfo->_dwSiteId ^ pCliInfo->_puid.HighPart ^ pCliInfo->_puid.LowPart);
}

BOOL SgCliInfoHashCompare(CCliInfo * pCliInfo1, CCliInfo * pCliInfo2)
{
    return(     pCliInfo1->_dwSiteId      == pCliInfo2->_dwSiteId
           &&   pCliInfo1->_puid.QuadPart == pCliInfo2->_puid.QuadPart);
}

// ---------------------------------------------------------------------------------------
// Datacenter Configuration
// ---------------------------------------------------------------------------------------

BOOL                    g_fDatacenterConfigured;        // TRUE after config has been read once
BOOL                    g_fEnableConnectionServices;    // TRUE if gateway provides connection services

BOOL SgDatacenterInit()
{
    Assert(g_fDatacenterConfigured == FALSE);
    Assert(g_fEnableConnectionServices == FALSE);

    return(TRUE);
}

void SgDatacenterTerm()
{
    g_fDatacenterConfigured = FALSE;
    g_fEnableConnectionServices = FALSE;
}

// ---------------------------------------------------------------------------------------
// SgDatacenterConfigNotificationServer
// Fill out a CSgSvcConfig::Server with notification information. It returns TRUE if the
// server does subscribe to the notification type specified by pszNotifyType and the
// function was able to fill out the struct correctly. It returns FALSE if the server does
// not subscribe to the notification type and it additionally sets *pfError to TRUE if it
// there it found some config error.
// ---------------------------------------------------------------------------------------
static BOOL SgDatacenterConfigNotificationServer(
    const char*           pszNotifyType,
    CCfgInfo*             pciServer,
    CSgSvcConfig::Server* pNotifyServer,
    BOOL*                 pfError
)
{
    CCfgInfo* pciT = pciServer->FindNonList(pszNotifyType, NULL, FALSE);
    if(!pciT)
    {
        // This server does is not subscribed to this type of notification.
        return FALSE;
    }

    // Copy URL
    const char* pch = pciT->_csValue._pch;
    DWORD       cch = pciT->_csValue._cch;
    if(cch > ARRAY_SIZE(pNotifyServer->_rgchUrl) - 1)
    {
        SgEventSz(CONFIG_ERROR, " line %u. Url is too big", pciT->_csValue._iLine);
        *pfError = TRUE;
        return FALSE;
    }

    memcpy(pNotifyServer->_rgchUrl, pch, cch);
    pNotifyServer->_rgchUrl[cch] = '\0';

    // Find the Health URL
    CCfgInfo* pciHealthT = pciServer->FindNonList("HealthCheckUrl", NULL, FALSE);
    if (!pciHealthT) 
    {
        SgEventSz(CONFIG_ERROR, " line %u. No HealthCheckUrl", pciT->_csValue._iLine);
        *pfError = TRUE;
        return FALSE;
    }

    // Check the Health URL
    pch = pciHealthT->_csValue._pch;
    cch = pciHealthT->_csValue._cch;
    if(cch > ARRAY_SIZE(pNotifyServer->_rgchHealthUrl) - 1)
    {
        SgEventSz(CONFIG_ERROR, " line %u. Url is too big", pciHealthT->_csValue._iLine);
        *pfError = TRUE;
        return FALSE;
    }

    // Copy the Health URL
    memcpy(pNotifyServer->_rgchHealthUrl, pch, cch);
    pNotifyServer->_rgchHealthUrl[cch] = '\0';

    // Copy Ip and Port
    CCfgInfo* pciAddress;
    CIpAddr ipaddrZ;
    CIpPort ipportZ;
    CIpPort ipportHealthZ;
    CHAR szDnsNameZ[MAX_DNSNAME_LEN] = { };

    if((pciAddress = pciServer->FindList("Address", NULL, TRUE)) == NULL)
    {
        *pfError = TRUE;
        return FALSE;
    }

    if((!(pciAddress->GetString("DnsName", szDnsNameZ, ARRAY_SIZE(szDnsNameZ), FALSE) && szDnsNameZ[0] != '\0') &&
        !pciAddress->GetIpAddr("Ip", &ipaddrZ, TRUE)
       ) ||
       !pciAddress->GetIpPort("Port", &ipportZ, TRUE) ||
       !pciAddress->GetIpPort("HealthPort", &ipportHealthZ, TRUE))
    {
        *pfError = TRUE;
        return FALSE;
    }

    // Override the datacenter IP if the dns name is new and there is no IP set.
    if ( ( _strnicmp( pNotifyServer->_szDnsName, szDnsNameZ, ARRAY_SIZE(szDnsNameZ) - 1 ) != 0 ||
           pNotifyServer->_dwIp == 0 ) &&
         !SgDnsResolveToIP( szDnsNameZ, ipaddrZ ) )
    {
        SgEventSz(CONFIG_ERROR, "Invalid Address information supplied on line %u. Could not resolve DnsName %s",
            pciT->_csValue._iLine,
            szDnsNameZ); 
        *pfError = TRUE;
        return FALSE;
    }

    C_ASSERT(sizeof(pNotifyServer->_szDnsName) == sizeof(szDnsNameZ) );
    memcpy( pNotifyServer->_szDnsName, szDnsNameZ, sizeof(pNotifyServer->_szDnsName) );

    pNotifyServer->_dwIp        = NTOHL(ipaddrZ);
    pNotifyServer->_wPort       = NTOHS(ipportZ);
    pNotifyServer->_wHealthPort = NTOHS(ipportHealthZ);

    // To fill out the service ids array, we're going to get the CDstInfo
    // corresponding to this server and use the service mask from it.

    CIpPort ipportI;
    if (pciServer->GetIpPort("Id", &ipportI, FALSE))
    {
        CDstInfo* pDstInfo;
        ServiceMask serviceMask;
    
        SgDstInfoReadLock();
        pDstInfo = SgDstInfoLookup(ipportI);
    
        if (!pDstInfo)
        {
            // We should have already configured the servers and destinations. This
            // shouldn't have happened.
            SgDstInfoReadUnlock();
            Assert(!"Failed to find CDstInfo for server");
            *pfError = TRUE;
            return FALSE;
        }
    
        serviceMask = pDstInfo->_svcMask;
        SgDstInfoReadUnlock();
    
        // Convert the service mask to service array by mapping each bit in the mask to it's
        // corresponding service id. The bit index corresponds to an index in g_pSvcInfo that
        // contains the service id among other things
    
        SgSvcInfoLock();
        pNotifyServer->_cServiceIds = 0;
        C_ASSERT(_countof(pNotifyServer->_rgdwServiceIds) == ServiceMask::SERVICE_BITS);
        for(DWORD i=0; i < ServiceMask::SERVICE_BITS; i++)
        {
            if (serviceMask.IsBitSet(i))
            {
                pNotifyServer->_rgdwServiceIds[pNotifyServer->_cServiceIds] = g_pSvcInfo[i]._dwSvcId;
                pNotifyServer->_cServiceIds++;
            }
        }
        SgSvcInfoUnlock();
    }
    else
    {
        // Specify that we are using special service 0
        pNotifyServer->_rgdwServiceIds[0] = 0;
        pNotifyServer->_cServiceIds = 1;
    }

    TraceSz(
        Config, 
        "    Send %s notification to http://%s%s",
        pszNotifyType,
        CStrUtil().FormatIpPortH(pNotifyServer->_dwIp, pNotifyServer->_wPort),
        pNotifyServer->_rgchUrl
        );

    return TRUE;
}

BOOL SgDatacenterConfig(CCfgInfo* pci)
{
    TraceSz( Config, "SgDatacenterConfig:" );

    DWORD cServer;
    DWORD dwNotifyBatchIntervalInSeconds;
    DWORD dwNotifyUpdateBatchCount;
    DWORD dwNotifyUpdateQueueCount;
    DWORD dwNotifyTitleChangeBatchCount;
    DWORD dwNotifyTitleChangeQueueCount;
    DWORD dwNotifyDeleteBatchCount;
    DWORD dwNotifyDeleteQueueCount;
    DWORD dwNotifyUserChangeBatchCount;
    DWORD dwNotifyUserChangeQueueCount;
    DWORD dwNotifySpiUpdateBatchCount;
    DWORD dwNotifySpiUpdateQueueCount;

    if( !g_fDatacenterConfigured )
    {
        if(!pci->GetVar("EnableConnectionServices", (UINT *)&g_fEnableConnectionServices, 0, 1, 0))
            return FALSE;

        TraceSz(Config, "    Configured connection services to %d (%s)",
                 g_fEnableConnectionServices, g_fEnableConnectionServices ? "Enabled" : "Disabled");

        g_fDatacenterConfigured = TRUE;
    }

    // Globals
    if(!pci->GetVar("NotifyBatchIntervalInSeconds", &dwNotifyBatchIntervalInSeconds, 0, 600,    3) ||     // npdb
       !pci->GetVar("NotifyUpdateBatchCount",       &dwNotifyUpdateBatchCount,       1, 10000,  100) ||
       !pci->GetVar("NotifyUpdateQueueCount",       &dwNotifyUpdateQueueCount,       1, 100000, 30000) ||
       !pci->GetVar("NotifyTitleChangeBatchCount",  &dwNotifyTitleChangeBatchCount,  1, 10000,  100) ||
       !pci->GetVar("NotifyTitleChangeQueueCount",  &dwNotifyTitleChangeQueueCount,  1, 100000, 10000) ||
       !pci->GetVar("NotifyDeleteBatchCount",       &dwNotifyDeleteBatchCount,       1, 10000,  100) ||
       !pci->GetVar("NotifyDeleteQueueCount",       &dwNotifyDeleteQueueCount,       1, 100000, 10000) ||
       !pci->GetVar("NotifyUserChangeBatchCount",   &dwNotifyUserChangeBatchCount,   1, 10000,  100) ||
       !pci->GetVar("NotifyUserChangeQueueCount",   &dwNotifyUserChangeQueueCount,   1, 100000, 10000) ||
       !pci->GetVar("NotifyUserChangeBatchCount",   &dwNotifySpiUpdateBatchCount,    1, 10000,  100) ||
       !pci->GetVar("NotifyUserChangeQueueCount",   &dwNotifySpiUpdateQueueCount,    1, 100000, 30000))  
    {
        return FALSE;
    }

    cServer = pci->Count("NotifyServer");

    if( 0 == cServer )
    {
        return TRUE;
    }

    DWORD iServer;

    // Figure out how many of each type we have first
    DWORD cUpdateServers = 0;
    DWORD cTitleChangeServers = 0;
    DWORD cDeleteServers = 0;
    DWORD cUserChangeServers = 0;
    DWORD cSpiUpdateServers = 0;

    CCfgInfo* pciServer = NULL;
    DWORD cServers = pci->Count("NotifyServer");
    DWORD dwSize = sizeof( CSgSvcConfig );
    DWORD dwServerSize = sizeof( CSgSvcConfig::Server );

    for( iServer = 0; iServer < cServers; iServer++ )
    {
        pciServer = pci->FindList("NotifyServer", pciServer, FALSE);
        Assert(pciServer);

        if (pciServer->FindNonList("NotifyUpdateUrl", NULL, FALSE))
        {
            cUpdateServers++;
            dwSize += dwServerSize;
        }
        if (pciServer->FindNonList("NotifyTitleChangeUrl", NULL, FALSE))
        {
            cTitleChangeServers++;
            dwSize += dwServerSize;
        }
        if (pciServer->FindNonList("NotifyDeleteUrl", NULL, FALSE))
        {
            cDeleteServers++;
            dwSize += dwServerSize;
        }
        if (pciServer->FindNonList("NotifyUserChangeUrl", NULL, FALSE)) 
        {
            cUserChangeServers++;
            dwSize += dwServerSize;
        }
        if (pciServer->FindNonList("NotifySpiUpdateUrl", NULL, FALSE)) 
        {
            cSpiUpdateServers++;
            dwSize += dwServerSize;
        }
    }

    // @@@ Maybe eventually we can get rid of this intermediate CSgSvcConfig structure and 
    // parse all this directly into actionable items.

    CSgSvcConfig* pConfigMsg = (CSgSvcConfig*) SgMemAllocZ( dwSize, PTAG_CSvcMsgConfig );
    if( NULL == pConfigMsg )
    {
        TraceSz( Warning, "SgDatacenterIndicateConfig - Unable to allocate packet data" );
        return FALSE;
    }

    BOOL fOk = FALSE;

    pConfigMsg->_wType = SGSVC_TYPE_CONFIG;
    pConfigMsg->_cbEnt = (WORD) dwSize;

    // Copy over appropriate global values
    // @@@ todo: split out the batch interval into per-queue settings
    pConfigMsg->_dwNotifyUpdateBatchIntervalInSeconds      = dwNotifyBatchIntervalInSeconds;
    pConfigMsg->_dwNotifyUpdateBatchCount                  = dwNotifyUpdateBatchCount;
    pConfigMsg->_dwNotifyUpdateQueueCount                  = dwNotifyUpdateQueueCount;
    pConfigMsg->_dwNotifyTitleChangeBatchIntervalInSeconds = dwNotifyBatchIntervalInSeconds;
    pConfigMsg->_dwNotifyTitleChangeBatchCount             = dwNotifyTitleChangeBatchCount;
    pConfigMsg->_dwNotifyTitleChangeQueueCount             = dwNotifyTitleChangeQueueCount;
    pConfigMsg->_dwNotifyDeleteBatchIntervalInSeconds      = dwNotifyBatchIntervalInSeconds;
    pConfigMsg->_dwNotifyDeleteBatchCount                  = dwNotifyDeleteBatchCount;
    pConfigMsg->_dwNotifyDeleteQueueCount                  = dwNotifyDeleteQueueCount;
    pConfigMsg->_dwNotifyUserChangeBatchIntervalInSeconds  = dwNotifyBatchIntervalInSeconds;
    pConfigMsg->_dwNotifyUserChangeBatchCount              = dwNotifyUserChangeBatchCount;
    pConfigMsg->_dwNotifyUserChangeQueueCount              = dwNotifyUserChangeQueueCount;
    pConfigMsg->_dwNotifySpiUpdateBatchIntervalInSeconds   = dwNotifyBatchIntervalInSeconds;
    pConfigMsg->_dwNotifySpiUpdateBatchCount               = dwNotifySpiUpdateBatchCount;
    pConfigMsg->_dwNotifySpiUpdateQueueCount               = dwNotifySpiUpdateQueueCount;

    // Tell the service layer all of our Internet facing IP addresses, so that it can send a DeadSg message if we go down
    for( DWORD iInterface = 0; iInterface < g_cTransInfo; iInterface++ )
    {
        CTransInfo* pTransInfo = &g_pTransInfo[iInterface];

        if( TRANSTYPE_INTERNET == pTransInfo->_dwType )
        {
            pConfigMsg->_rgdwInetInterfaces[ pConfigMsg->_cInetInterfaces ] = pTransInfo->_ipa;
            pConfigMsg->_cInetInterfaces++;
        }
    }

    // Set the object counts so that we can safely use GetXXXList
    pConfigMsg->_cNotifyUpdateServers      = cUpdateServers;
    pConfigMsg->_cNotifyTitleChangeServers = cTitleChangeServers;
    pConfigMsg->_cNotifyDeleteServers      = cDeleteServers;
    pConfigMsg->_cNotifyUserChangeServers  = cUserChangeServers;
    pConfigMsg->_cNotifySpiUpdateServers   = cSpiUpdateServers;

    // Copy over the appropriate servers
    cUpdateServers      = 0;
    cTitleChangeServers = 0;
    cDeleteServers      = 0;
    cUserChangeServers  = 0;
    cSpiUpdateServers   = 0;
    pciServer           = NULL;

    for( iServer = 0; iServer < cServer; iServer++ )
    {
        pciServer = pci->FindList("NotifyServer", pciServer, FALSE);

        BOOL fError = FALSE;
        if (SgDatacenterConfigNotificationServer(
                "NotifyUpdateUrl",
                pciServer,
                pConfigMsg->GetUpdateServerList() + cUpdateServers,
                &fError))
        {
            cUpdateServers++;
        }

        if (SgDatacenterConfigNotificationServer(
                "NotifyTitleChangeUrl",
                pciServer,
                pConfigMsg->GetTitleChangeServerList() + cTitleChangeServers,
                &fError))
        {
            cTitleChangeServers++;
        }

        if (SgDatacenterConfigNotificationServer(
                "NotifyDeleteUrl",
                pciServer,
                pConfigMsg->GetDeleteServerList() + cDeleteServers,
                &fError))
        {
            cDeleteServers++;
        }

        if (SgDatacenterConfigNotificationServer(
                "NotifyUserChangeUrl",
                pciServer,
                pConfigMsg->GetUserChangeServerList() + cUserChangeServers,
                &fError)) 
        {
            cUserChangeServers++;
        }

        if (SgDatacenterConfigNotificationServer(
                "NotifySpiUpdateUrl",
                pciServer,
                pConfigMsg->GetSpiUpdateServerList() + cSpiUpdateServers,
                &fError)) 
        {
            cSpiUpdateServers++;
        }      

        if(fError)
        {
            goto Cleanup;
        }
    }

    // send the packet to the service layer
    if (!SgServiceNotifyConfig(pConfigMsg))
    {
        goto Cleanup;
    }

    // Tracing
    TraceSz( Config, "    Configured\r\n");
    if (cUpdateServers != 0) 
    {
        TraceSz( Config, "      %u NotifyUpdate servers\r\n", cUpdateServers );
    }
    if (cTitleChangeServers != 0) 
    {
        TraceSz( Config, "      %u NotifyTitleChange servers\r\n", cTitleChangeServers );
    }
    if (cDeleteServers != 0) 
    {
        TraceSz( Config, "      %u NotifyDelete servers\r\n", cDeleteServers );
    }
    if (cUserChangeServers != 0) 
    {
        TraceSz( Config, "      %u NotifyUserChange servers\r\n", cUserChangeServers );
    }
    if (cSpiUpdateServers != 0) 
    {
        TraceSz( Config, "      %u NotifySpiUpdate servers\r\n", cSpiUpdateServers );
    }

    fOk = TRUE;

Cleanup:

    if (pConfigMsg)
    {
        SgMemFree(pConfigMsg);
        pConfigMsg = NULL;
    }

    return fOk;
}


// ---------------------------------------------------------------------------------------
// CDhInfo
// ---------------------------------------------------------------------------------------

UINT        g_cDhInfo;
CDhInfo *   g_pDhInfo;
LONG        g_lDhInfoNext;

BOOL SgDhInfoInit()
{
    Assert(g_cDhInfo == 0);
    Assert(g_pDhInfo == NULL);
    Assert(g_lDhInfoNext == 0);
    return(TRUE);
}

void SgDhInfoTerm()
{
    SgMemFree(g_pDhInfo);
    g_pDhInfo = NULL;
    g_cDhInfo = 0;
    g_lDhInfoNext = 0;
}

BOOL SgDhInfoConfig(CCfgInfo* pci)
{
    TraceSz( Config, "SgDhInfoConfig:" );

    if (g_cDhInfo == 0)
    {
        if(!pci->GetVar("DhInfoCacheSize", (UINT *)&g_cDhInfo, 16, 32768, 1024))
            return FALSE;

        g_pDhInfo = (CDhInfo *)SgMemAlloc(g_cDhInfo * sizeof(CDhInfo), PTAG_CDhInfo);

        if (g_pDhInfo == NULL)
        {
            TraceSz(Config, "Config error: Out of memory allocating CDhInfo (%d bytes)", g_cDhInfo * sizeof(CDhInfo));
            SgDhInfoTerm();
            return(FALSE);
        }

        CDhInfo * pDhInfo = g_pDhInfo;
        UINT      cDhInfo = g_cDhInfo;

        for (; cDhInfo > 0; --cDhInfo, ++pDhInfo)
        {
            SgRand(pDhInfo->_abX, sizeof(pDhInfo->_abX));
        }

        LARGE_INTEGER liBeg, liFreq, liNow;
        liBeg = SgQueryPerformanceCounter(&liFreq);

        for (cDhInfo = g_cDhInfo, pDhInfo = g_pDhInfo; cDhInfo > 0; --cDhInfo, ++pDhInfo)
        {
            XcModExp((DWORD *)pDhInfo->_abGX, (DWORD *)g_abOakleyGroup1Base,
                     (DWORD *)pDhInfo->_abX, (DWORD *)g_abOakleyGroup1Mod,
                     CBDHG1 / sizeof(DWORD));
        }

        liNow = SgQueryPerformanceCounter(&liNow);

        TraceSz( Config, "    Configured %u CDhInfo in %u seconds (%u DH/sec)", g_cDhInfo,
                 (DWORD)((liNow.QuadPart - liBeg.QuadPart + (liFreq.QuadPart / 2)) / liFreq.QuadPart),
                 (DWORD)((liFreq.QuadPart * g_cDhInfo) / (liNow.QuadPart - liBeg.QuadPart)));
    }

    return(TRUE);
}

void SgDhInfoAssign(BYTE * pbX, BYTE * pbGX)
{
    Assert(g_cDhInfo > 0);
    CDhInfo * pDhInfo = &g_pDhInfo[((DWORD)InterlockedIncrement(&g_lDhInfoNext)) % g_cDhInfo];
    memcpy(pbX, pDhInfo->_abX, sizeof(pDhInfo->_abX));
    memcpy(pbGX, pDhInfo->_abGX, sizeof(pDhInfo->_abGX));
}

#ifdef SG_FEATURE_XMGMT

// -------------------------------------------------------------------------------------
// SgConnectionInfoMgmtCmd
//
// Entry point for xmgmt commands with the "info" command, for reporting details on a 
// single connection.
// -------------------------------------------------------------------------------------
void SgConnectionInfoMgmtCmd(CXomParamList * pxompl, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
#define ERR_MSG(fmt, ...) \
    pResponseInterface->WriteResponse( \
        dwRequestId, \
        (BYTE *)CSmallStr().Format(fmt "\r\n", __VA_ARGS__).cstr(), \
        (DWORD) -1)
        

    // Dynamically allocate and grow memory as needed. Seed it to a reasonable starting 
    // value.

    CLargeStr statsText;
    statsText.SetAllocator(CMemAlloc::Default());

    CSpiInfo * pSpiInfo = NULL;

    //
    // Process commands here
    // 
    
    if (pxompl->GetCount() == 3 &&
             _strcmpi(pxompl->GetParam(1), "mpuid") == 0)
    {
        //
        // Look up machine puid
        //

        ULONGLONG mpuid = _strtoui64(pxompl->GetParam(2), NULL, 0);
        for (DWORD i = 0; i < g_cSpiInfoInUse; i++)
        {
            if (!g_pSpiInfo[i]._fDeleted &&
                g_pSpiInfo[i]._leFree.Flink == NULL &&
                mpuid == g_pSpiInfo[i]._puid.QuadPart)
            {
                pSpiInfo = &g_pSpiInfo[i];
                break;
            }
        }

        if (pSpiInfo == NULL)
        {
            ERR_MSG("Unable to find active connection for machine 0x%016I64X", mpuid);
            goto lDone;
        }
    }
    else if (pxompl->GetCount() == 3 &&
             _strcmpi(pxompl->GetParam(1), "spi") == 0)
    {
        //
        // Look up spi
        //

        DWORD dwSpiRecv = strtoul(pxompl->GetParam(2), NULL, 0);
        DWORD dwSpiIdx = (dwSpiRecv >> 8) % g_cSpiInfo;
        if (!g_pSpiInfo[dwSpiIdx]._fDeleted &&
            g_pSpiInfo[dwSpiIdx]._leFree.Flink == NULL &&
            g_pSpiInfo[dwSpiIdx]._dwSpiRecv == dwSpiRecv &&
            dwSpiRecv > 0)
        {
            pSpiInfo = &g_pSpiInfo[dwSpiIdx];
        }

        if (pSpiInfo == NULL)
        {
            ERR_MSG("Unable to find active connection for spi 0x%08X", dwSpiRecv);
            goto lDone;
        }
    }
    else if (pxompl->GetCount() == 3 &&
             _strcmpi(pxompl->GetParam(1), "ip") == 0)
    {
        //
        // Look up datacenter ip and port
        //

        // Parse IP and port
        IN_ADDR inAddr;
        USHORT  usPort;
        LONG ret = RtlIpv4StringToAddressExA(
            pxompl->GetParam(2),
            TRUE,
            &inAddr,
            &usPort);
        if (ret != NO_ERROR)
        {
            ERR_MSG("Failed to parse IP address %s, NtStatus error 0x%X", pxompl->GetParam(2), ret);
            goto lDone;
        }

        // Find datacenter transport. We don't use failover, so it must be the first one.
        CTransInfo *pTransInfo = NULL;
        for (UINT iTrans = 0; iTrans < g_cTransInfo; ++iTrans)
        {
            CTransInfo * ptrans = &g_pTransInfo[iTrans];
            if (ptrans->_dwType == TRANSTYPE_DMZ)
            {
                pTransInfo = ptrans;
                break;
            }
        }

        if (pTransInfo == NULL)
        {
            ERR_MSG("Unable to find the datacenter transport");
            goto lDone;
        }

        // Look up CNatInfo for this datacenter ip and port
        CNatInfo * pNatInfo = SgNatInfoLookupZ(
            pTransInfo, 
            NTOHL(inAddr.S_un.S_addr),
            NTOHS(usPort));

        if (pNatInfo == NULL || pNatInfo->_dwSpi == 0)
        {
            ERR_MSG("Unable to find active connection for client " DBGINAFMT ":%d", DBGINAPRM(&inAddr), NTOHS(usPort));
            goto lDone;
        }

        // And finally, look up the spi for this CNatInfo
        DWORD dwSpiIdx = (pNatInfo->_dwSpi >> 8) % g_cSpiInfo;
        if (!g_pSpiInfo[dwSpiIdx]._fDeleted &&
            g_pSpiInfo[dwSpiIdx]._leFree.Flink == NULL &&
            g_pSpiInfo[dwSpiIdx]._dwSpiRecv == pNatInfo->_dwSpi)
        {
            pSpiInfo = &g_pSpiInfo[dwSpiIdx];
        }

        if (pSpiInfo == NULL)
        {
            ERR_MSG("Unable to find active connection for spi 0x%08X", pNatInfo->_dwSpi);
            goto lDone;
        }
    }
    else
    {
        ERR_MSG("Invalid params");
        goto lDone;
    }

    Assert(pSpiInfo);

    // Generate report

    CNatInfo *pNatInfo = pSpiInfo->_pNatInfo;

    statsText.Format("CONNECTIONINFO:\r\n");
    statsText.Format("MachineId        0x%016I64X\r\n", pSpiInfo->_puid); 
    statsText.Format("SPI              0x%08X\r\n",     pSpiInfo->_dwSpiRecv); 
    if (pSpiInfo->_dwSpiOld) 
    {
        statsText.Format("Previous SPI     0x%08X\r\n",     pSpiInfo->_dwSpiOld); 
    }
    statsText.Format("TitleId          0x%08X\r\n",     pSpiInfo->_AuthData.dwTitleID); 
    statsText.Format("InternetIp       %s:%d\r\n",      pSpiInfo->_ipaI.Str(), NTOHS(pSpiInfo->_ipportI._w)); 
    statsText.Format("DatacenterIp     %s\r\n",         pNatInfo->_ipaZ.Str()); 
    statsText.Format("NatInfoIndex     %d\r\n",         pNatInfo->_iNatInfo); 
    if (pSpiInfo->_pCliInfo) 
    {
        CCliInfo *pCliInfo = pSpiInfo->_pCliInfo;

        statsText.Format("Site ID          %d\r\n",         pCliInfo->_dwSiteId);
        statsText.Format("Packed Queue Cnt %d\r\n",         pCliInfo->_pq.Count());
        statsText.Format("KeyEx Replay Cnt %d\r\n",         pCliInfo->_cReplay);
        statsText.Format("KeyEx Time       %s\r\n",         SgTimeToStr(pCliInfo->_qwTimeKeyEx));
    }
    statsText.Format("Ticket Expiry    %s\r\n",         SgTickToStr(pSpiInfo->_qwTickTicketEnd));
    statsText.Format("PortTranslation  %s\r\n",         g_fPortTranslation ? "on" : "off"); 
    if (g_fPortTranslation)
    {
        statsText.Format("ZPortBegin       %d 0x%X\r\n", pNatInfo->_iBasePortZ, pNatInfo->_iBasePortZ);
        statsText.Format("ZPortEnd         %d 0x%X\r\n", pNatInfo->_iBasePortZ + g_cPortsPerNatInfo - 1, pNatInfo->_iBasePortZ + g_cPortsPerNatInfo - 1);
        statsText.Format("\r\n"); 
        statsText.Format("PORTMAPPINGS: (I to Z)\r\n"); 
        for (DWORD i = 0; i < g_cPortsPerNatInfo; i++)
        {
            float fTickDiff = (float)(SgTimerTick() - pNatInfo->_pNatPort[i]._qwTick) / (float)TICKS_PER_SECOND;
            statsText.Format("%5d %5d %6.1f secs\r\n",
                             NTOHS(pNatInfo->_pNatPort[i]._ipportI),
                             NTOHS(pNatInfo->_pNatPort[i]._ipportZ),
                             fTickDiff >= 1000.0 ? 999.0 : fTickDiff);
        }
    }
    statsText.Format("\r\n"); 

    // Output

    pResponseInterface->WriteResponse(
        dwRequestId,
        (BYTE *)statsText.cstr(),
        (DWORD)statsText.GetLength()
        );

lDone:

    return;
}

#endif // SG_FEATURE_XMGMT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsvcmgmt.cpp ===
// ---------------------------------------------------------------------------------------
// sgsvcmgmt.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_XMGMT

// Forward declarations
//
extern UINT g_cSpiInfoInUse;
extern UINT g_cSpiInfoFree;
extern UINT g_cSpiInfo;

void SgServiceNotifyHealthCheck(
    DWORD dwRequestId,
    CXomControlResponseInterface *pResponseInterface
    );

void SgChalListChallenges( 
    DWORD dwRequestId,
    CXomControlResponseInterface *pResponseInterface
    );

void SgConfigScheduleReload(DWORD dwDelayInMs);


CSgControlCallback g_SgControlCallback;

HRESULT CSgControlCallback::OnControlRequest(
    LPCSTR pszRequest,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    CXomParamList xompl;
    HRESULT       hr;

    SgEventSz(MGMT_COMMAND, "Control request: %s\n", pszRequest );

    hr = xompl.Parse( pszRequest );
    if ( FAILED( hr ) )
    {
        pResponseInterface->WriteResponse( dwRequestId, (BYTE *)"Command parse error.", (DWORD)-1 );
        goto exit;
    }

    DWORD  cParam = xompl.GetCount();
    LPCSTR pszCmd = xompl.GetParam( 0 );

    if (cParam == 0)
    {
        hr = S_OK;
        goto exit;
    }

//345678901234567890123456789012345678901234567890123456789012345678901234567890
    char * szHelpText = "\n\n \
SG Commands:\n \
  reload_config              : Force config to be reloaded\n \
  reload_challenges          : Force challenges to be reloaded\n \
  list_challenges            : List all active challenges\n \
  numconnections             : Count of active connections\n \
  info mpuid 0x<machine id>  : Connection information for machine\n \
  info spi 0x<spi recv>      : Connection information for spi\n \
  info ip <ip:port>          : Connection information for datacenter ip:port\n \
  blocked [list]             : Blocked client list\n \
  blocked add 0x<puid>       : Add machine to blocked clients list\n \
                             :   Note: Duration of Block is 5 Times Normal\n \
  blocked remove 0x<puid>    : Clear machine from blocked clients list\n \
  stats                      : Report overall client statistics\n \
  stats histogram            : Report histogram of overall client statistics\n \
  stats mpuid <machine id>   : Report stats for a single client based on puid\n \
  stats spi <spi recv>       : Report stats for a single client based on spi\n \
  stats warnings             : Report clients that have been warned\n \
  stats reset                : Reset the running client stats (limits, etc)\n \
  healthcheck                : Verify notification servers are running\n \
";

    if (_strcmpi(pszCmd, "help") == 0)
    {
        pResponseInterface->WriteResponse(
            dwRequestId, 
            (BYTE *) szHelpText,
            (DWORD)-1
            );
        goto exit;
    }
    else if (_strcmpi(pszCmd, "reload_config") == 0)
    {
        // Delay it a little bit to account for batching, the time it may take a previous 
        // SgConfig to finish, etc.
        SgConfigScheduleReload(2000);

        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Config reload initiated, check event log for results\n"
            );
        hr = S_OK;
    }
    else if (_strcmpi(pszCmd, "reload_challenges") == 0) 
    {
        BOOL bResult = SgLuaReloadChallenges();
        if (bResult == TRUE) 
        {
            // Apply (potentially) new filters to all connections
            SgApplyFilterScriptAll();
            SgChalListChallenges(
                dwRequestId,
                pResponseInterface
                );
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else if (_strcmpi(pszCmd, "list_challenges") == 0)
    {
        SgChalListChallenges(
            dwRequestId,
            pResponseInterface
            );
        hr = S_OK;
    }
    else if (_strcmpi(pszCmd, "numconnections") == 0)
    {
        DWORD activeClients = g_cSpiInfoInUse - g_cSpiInfoFree;
        CSmallStr str;
        str.Format("%u connections active out of %u possible.\r\n", activeClients, g_cSpiInfo);
        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            str.cstr(),
            (DWORD)-1
            );
        hr = S_OK;
    }
    else if (_strcmpi(pszCmd, "info") == 0)
    {
        SgConnectionInfoMgmtCmd(
            &xompl,
            dwRequestId,
            pResponseInterface
            );
        hr = S_OK;
    }
    else if (_strcmpi(pszCmd, "blocked") == 0) 
    {
        SgConnectionBlockedMgmtCmd(
            &xompl,
            dwRequestId,
            pResponseInterface
            );
        hr = S_OK;
    }
    else if (_strcmpi(pszCmd, "stats") == 0)
    {
        SgClientStatsMgmtCmd(
            &xompl,
            dwRequestId,
            pResponseInterface
            );
        hr = S_OK;
    }
    else if (_strcmpi(pszCmd, "healthcheck") == 0)
    {
        SgServiceNotifyHealthCheck(
            dwRequestId,
            pResponseInterface
            );
        hr = S_OK;
    }

exit:    
    return hr;
}

#endif // SG_FEATURE_XMGMT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgtransinfo.cpp ===
// ---------------------------------------------------------------------------------------
// sgtransinfo.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// CTransInfo
// ---------------------------------------------------------------------------------------

UINT         g_cTransInfo;              // Number of transports available
UINT         g_cTransInfoZ;             // Number of datacenter transports available
CTransInfo * g_pTransInfo;              // Vector of all CTransInfo structures

BOOL SgTransInfoInit()
{
    Assert(g_cTransInfo == 0);
    Assert(g_cTransInfoZ == 0);
    Assert(g_pTransInfo == NULL);
    return(TRUE);
}

void SgTransInfoTerm()
{
    CTransInfo *    pTransInfo = g_pTransInfo;
    UINT            cTransInfo = g_cTransInfo;

    for (; cTransInfo > 0; --cTransInfo, ++pTransInfo)
    {
        if (pTransInfo->_pvPacketTrans)
        {
            TransTerm(pTransInfo);
        }

        pTransInfo->_lockNatInfoFree.Term();

#ifdef SG_FEATURE_ARP
        SgArpInfoLock();

        if (!IsListNull(&pTransInfo->_leArpAddresses))
        {
            while (!IsListEmpty(&pTransInfo->_leArpAddresses))
            {
                CArpInfo * pArpInfo = (CArpInfo *)RemoveHeadList(&pTransInfo->_leArpAddresses);
                AssertSz(pArpInfo->_fPersistent, "A CDstInfo failed to clean up its ARP");
                SgArpInfoRelease(pArpInfo, pArpInfo->_fPersistent);
            }
        }

        if (!IsListNull(&pTransInfo->_leArpProbes))
        {
            while (!IsListEmpty(&pTransInfo->_leArpProbes))
            {
                CArpInfo * pArpInfo = (CArpInfo *)RemoveHeadList(&pTransInfo->_leArpProbes);
                AssertSz(pArpInfo->_fPersistent, "A CDstInfo failed to clean up its ARP");
                SgArpInfoRelease(pArpInfo, pArpInfo->_fPersistent);
            }
        }

        SgArpInfoUnlock();
#endif // SG_FEATURE_ARP
    }

    SgMemFree(g_pTransInfo);

    g_cTransInfo      = 0;
    g_cTransInfoZ     = 0;
    g_pTransInfo      = NULL;
}

BOOL SgTransInfoFailoverConfig(CCfgInfo * pci)
{
    if (g_cTransInfoZ == 0)
        return(TRUE);

    CCfgInfo * pciFail = pci->FindList("DisableNetworkInterfaces", NULL, FALSE);

    if (pciFail == NULL)
        return(TRUE);

    UINT cDisabled = pciFail->Count("InterfaceId");

    CTransInfo * pTransInfo = g_pTransInfo;

    for (UINT i = 0; i < g_cTransInfo; i++, pTransInfo++)
    {
        pTransInfo->_fActive = TRUE;
    }

    CCfgInfo * pciId = NULL;

    while (1)
    {
        pciId = pciFail->FindNonList("InterfaceId", pciId, FALSE);

        if (pciId == NULL)
                break;
        DWORD dwTransId;

        if (!pciId->_csValue.GetNum(&dwTransId))
            continue;

        if (dwTransId == 0)
        {
            TraceSz(Config, "Config warning (line %d): Zero is not a valid Interface Id", pciId->_csName._iLine);
            SgEventSz(CONFIG_WARNING, "line %d. Zero is not a valid Interface Id.", pciId->_csName._iLine);
            continue;
        }

        pTransInfo = g_pTransInfo;

        for (UINT i = 0; i < g_cTransInfo; i++, pTransInfo++)
        {
            if (pTransInfo->_dwTransId == dwTransId)
                pTransInfo->_fActive = FALSE;
        }
    }

    return(TRUE);
}

BOOL SgTransInfoReady()
{
    return (g_cTransInfo > 0);
}

BOOL SgTransInfoConfig(CCfgInfo* pci)
{
    TraceSz( Config, "SgTransInfoConfig:" );

    if( g_cTransInfo > 0 )
    {
        // Network interfaces can only be configured once.
        return SgTransInfoFailoverConfig( pci );
    }

    UINT cTransInfo = pci->Count("NetworkInterface");

    if( 0 == cTransInfo )
    {
        SgEventSz(CONFIG_ERROR, "No interface configuration was specified. The SG can't be initialized" );
        goto err;
    }

    // Allocate the vector of CTransInfo
    g_pTransInfo = (CTransInfo *)SgMemAllocZ(cTransInfo * sizeof(CTransInfo), PTAG_CTransInfo);
    if (g_pTransInfo == NULL)
    {
        SgEventSz(CONFIG_ERROR, "Config error: Out of memory allocating vector of %d CTransInfo (%d bytes)",
                  cTransInfo, cTransInfo * sizeof(CTransInfo));
        goto err;
    }

    g_cTransInfo = cTransInfo;

    // Init all locks

    for (UINT i = 0; i < cTransInfo; i++)
    {
        g_pTransInfo[i]._lockNatInfoFree.Init();
    }

    // Initialize transport layer

    if(!TransConfig(pci))
    {
        SgEventSz(CONFIG_ERROR, "Config error: failed to initialize transport layer");
        goto err;
    }

    // Configure the vector of CTransInfo

    UINT         iTransInfo  = 0;
    CTransInfo * pTransInfo  = g_pTransInfo;
    UINT         cTransInfoI = 0;
    UINT         cTransInfoZ = 0;
    CCfgInfo*    pciNet      = NULL;
    CCfgInfo*    pciT        = NULL;

    for (; iTransInfo < cTransInfo; ++iTransInfo, ++pTransInfo)
    {
        pciNet = pci->FindList("NetworkInterface", pciNet, TRUE);

        pTransInfo->_iTransInfo = iTransInfo;
        pTransInfo->_fActive    = TRUE;

        pciT = pciNet->FindNonList("Type", NULL, TRUE);

        if(pciT == NULL)
            goto err;

        if (pciT->_csValue.StrEql("Internet"))
        {
            pTransInfo->_dwType = TRANSTYPE_INTERNET;
            cTransInfoI += 1;
        }
        else if (pciT->_csValue.StrEql("Datacenter"))
        {
            pTransInfo->_dwType = TRANSTYPE_DMZ;
            cTransInfoZ += 1;
        }
        else
        {
            SgEventSz(CONFIG_ERROR, "line %d. Types are 'Internet' and 'Datacenter'", pciT->_csName._iLine);
            goto err;
        }

        if(!pciNet->GetIpAddr("Ip", &pTransInfo->_ipa, TRUE, TRUE))
            goto err;

        if (pTransInfo->_ipa == 0)
        {
            SgEventSz(CONFIG_ERROR, "Ip address %s is invalid for the %s transport", 
                      pTransInfo->_ipa.Str(), pTransInfo->_dwType == TRANSTYPE_INTERNET ? "internet" : "datacenter");
            goto err;
        }

        CIpAddr ipaEnd;

        if (pTransInfo->_dwType != TRANSTYPE_DMZ || !pciNet->GetIpAddr("IpEnd", &ipaEnd, FALSE))
        {
            ipaEnd = pTransInfo->_ipa;
        }

        pTransInfo->_dwIpaBeg = NTOHL(pTransInfo->_ipa);
        pTransInfo->_dwIpaEnd = NTOHL(ipaEnd);

        if (!pciNet->GetIpAddr("IpMask", &pTransInfo->_ipaMask, TRUE, TRUE))
            goto err;

        if (!pciNet->GetIpAddr("IpGateway", &pTransInfo->_ipaGateway, TRUE, TRUE))
            goto err;

        pTransInfo->_ipaSubnet = pTransInfo->_ipaGateway & pTransInfo->_ipaMask;

        if (pTransInfo->_dwType == TRANSTYPE_INTERNET)
        {
            pTransInfo->_dwTransId  = 0;
            pTransInfo->_ipaAdmin = 0;
            pTransInfo->_dwIpaEnd = pTransInfo->_dwIpaBeg;
            pTransInfo->_wIpportBeg = 1;
            pTransInfo->_wIpportEnd = 0xFFFF;
        }
        else
        {
            CIpAddr ipaEnd;
            if (pciNet->GetIpAddr("IpEnd", &ipaEnd, FALSE))
            {
                pTransInfo->_dwIpaEnd = NTOHL(ipaEnd);
            }
            else
            {
                pTransInfo->_dwIpaEnd = pTransInfo->_dwIpaBeg;
            }

            if( pTransInfo->_dwIpaEnd < pTransInfo->_dwIpaBeg )
            {
                SgEventSz(CONFIG_ERROR, ". 'Ip' %s must be less than 'IpEnd' %s",
                         pTransInfo->_ipa.Str(), CIpAddr( NTOHL( pTransInfo->_dwIpaEnd ) ).Str());
                goto err;
            }

            if(!pciNet->GetVar("PortBegin", &pTransInfo->_wIpportBeg, 1, 65534, 1) ||
               !pciNet->GetVar("PortEnd", &pTransInfo->_wIpportEnd, 1, 65534, 65534))
            {
                goto err;
            }

            if( pTransInfo->_wIpportEnd < pTransInfo->_wIpportBeg )
            {
                SgEventSz( CONFIG_ERROR, ". 'PortBegin' %u must be less than 'PortEnd' %u",
                         pTransInfo->_wIpportBeg, pTransInfo->_wIpportEnd );
                goto err;
            }

            if(pciNet->FindNonList("IpAdmin", NULL, FALSE))
            {
                if(!pciNet->GetIpAddr("IpAdmin", &pTransInfo->_ipaAdmin, TRUE, TRUE))
                {
                    goto err;
                }
            }
            else if(pciNet->FindNonList("IpRoute", NULL, FALSE))
            {
                if(!pciNet->GetIpAddr("IpRoute", &pTransInfo->_ipaAdmin, TRUE, TRUE))
                {
                    goto err;
                }
            }
            else
            {
                pTransInfo->_ipaAdmin = 0;
            }

#ifdef SG_FEATURE_ARP
            // To make the routers happy we have to provide an address on the right subnet
            // that they can ARP
            if(pTransInfo->_ipaAdmin != 0)
            {
                if ((pTransInfo->_ipaAdmin & pTransInfo->_ipaMask) != pTransInfo->_ipaSubnet)
                {
                    SgEventSz( CONFIG_ERROR, ". 'IpAdmin' %s (subnet %s) differs from 'IpGateway' %s (subnet %s)",
                                pTransInfo->_ipaAdmin.Str(),
                                CIpAddr(pTransInfo->_ipaAdmin & pTransInfo->_ipaMask).Str(),
                                pTransInfo->_ipaGateway.Str(),
                                pTransInfo->_ipaSubnet.Str() );
                    goto err;
                }

                DWORD dwIpaAdmin = NTOHL(pTransInfo->_ipaAdmin);
                if (dwIpaAdmin >= pTransInfo->_dwIpaBeg && dwIpaAdmin <= pTransInfo->_dwIpaEnd)
                {
                    SgEventSz( CONFIG_ERROR, ". 'IpAdmin' %s is inside NAT address range (%s to %s)",
                                pTransInfo->_ipaAdmin.Str(),
                                pTransInfo->_ipa.Str(),
                                CIpAddr( NTOHL( pTransInfo->_dwIpaEnd ) ).Str() );
                    goto err;
                }
            }
#endif

            if (!pciNet->GetNum("Id", (UINT *)&pTransInfo->_dwTransId, TRUE))
                goto err;

            if (pTransInfo->_dwTransId == 0)
            {
                SgEventSz(CONFIG_ERROR, "line %d. Zero is not a valid Interface Id.", pciNet->_csName._iLine);
                goto err;
            }
        }

        DWORD cb = 0;
        if(!pciNet->GetHex("Nic", (BYTE*)&pTransInfo->_eaAdapter, &cb, sizeof(pTransInfo->_eaAdapter), FALSE))
            goto err;

        if(cb != 0 && cb != sizeof(pTransInfo->_eaAdapter))
        {
            SgEventSz(CONFIG_ERROR, "line %d. 'Nic' contains an invalid MAC address",
                       pciNet->_csName._iLine);
            goto err;
        }

        cb = 0;
        if(!pciNet->GetHex("NicVirtual", (BYTE*)&pTransInfo->_ea, &cb, sizeof(pTransInfo->_ea), FALSE))
            goto err;

        if(cb != 0 && cb != sizeof(pTransInfo->_ea))
        {
            SgEventSz(CONFIG_ERROR, "line %d. 'NicVirtual' contains an invalid MAC address",
                       pciNet->_csName._iLine);
            goto err;
        }

        // Setting Share*NicWithWindows 0 is the same as specifying NicVirtual <realmac>,
        // but simpler.
        DWORD fShareNic = 1;
        if (pTransInfo->_dwType == TRANSTYPE_INTERNET)
        {
            if (!pci->GetVar("ShareInternetNicWithWindows", &fShareNic, 0, 1, 1))
                goto err;
        }
        else if (pTransInfo->_dwType == TRANSTYPE_DMZ)
        {
            if (!pci->GetVar("ShareDatacenterNicWithWindows", &fShareNic, 0, 1, 1))
                goto err;
        }

        if (!fShareNic)
        {
            // We get exclusive access to the nic by specifying the NicVirtual (_ea) to be
            // the same as Nic (_eaAdapter). This is more efficient for NDIS.
            pTransInfo->_ea = pTransInfo->_eaAdapter;
        }


#ifdef SG_FEATURE_ARP
        InitializeListHead(&pTransInfo->_leArpAddresses);
        InitializeListHead(&pTransInfo->_leArpProbes);
#endif // SG_FEATURE_ARP
        InitializeListHead(&pTransInfo->_leNatInfoFree);

        // Send configuration to transport. This is when we bind to the network card and
        // all that good stuff

        if(!TransConfigTransport(pci, pTransInfo))
        {
            goto err;
        }
    }

    if (cTransInfoI == 0)
    {
        TraceSz(Config, "Config error: Must configure at least one network interface of type 'Internet'");
        SgEventSz(CONFIG_ERROR, "Internet interface required.");
        goto err;
    }

    if (cTransInfoZ == 0)
    {
        TraceSz(Config, "Config error: Must configure at least one network interface of type 'Datacenter'");
        SgEventSz(CONFIG_ERROR, "Datacenter interface required.");
        goto err;
    }

    g_cTransInfoZ = cTransInfoZ;

    if(!SgTransInfoFailoverConfig(pci))
    {
        goto err;
    }

    TraceSz(Config, "    Configured %u network interfaces", g_cTransInfo);

    for( cTransInfo = g_cTransInfo, pTransInfo = g_pTransInfo; cTransInfo > 0; --cTransInfo, ++pTransInfo )
    {
        TraceSz(Config, "%5d: _eaAdapter     %s", pTransInfo->_iTransInfo, pTransInfo->_eaAdapter.Str());
        TraceSz(Config, "       _ea            %s", pTransInfo->_ea.Str());
        TraceSz(Config, "       _ipa           %s", pTransInfo->_ipa.Str());
        TraceSz(Config, "       _ipaMask       %s", pTransInfo->_ipaMask.Str());
        TraceSz(Config, "       _ipaSubnet     %s", pTransInfo->_ipaSubnet.Str());
        TraceSz(Config, "       _ipaGateway    %s", pTransInfo->_ipaGateway.Str());
        TraceSz(Config, "       _ipaAdmin      %s", pTransInfo->_ipaAdmin.Str());
        TraceSz(Config, "       _dwTransId     %u", pTransInfo->_dwTransId);
        TraceSz(Config, "       _fActive       %s", pTransInfo->_fActive ? "true" : "false");
        TraceSz(Config, "       _dwIpaBeg      %08lX (%s)", pTransInfo->_dwIpaBeg, CIpAddr(HTONL(pTransInfo->_dwIpaBeg)).Str());
        TraceSz(Config, "       _dwIpaEnd      %08lX (%s)", pTransInfo->_dwIpaEnd, CIpAddr(HTONL(pTransInfo->_dwIpaEnd)).Str());
        TraceSz(Config, "       _wIpportBeg    %04lX (%u)", pTransInfo->_wIpportBeg, pTransInfo->_wIpportBeg);
        TraceSz(Config, "       _wIpportEnd    %04lX (%u)", pTransInfo->_wIpportEnd, pTransInfo->_wIpportEnd);
        TraceSz(Config, "       _dwType        %d (%s)", pTransInfo->_dwType, pTransInfo->_dwType == TRANSTYPE_INTERNET ? "Internet" : pTransInfo->_dwType == TRANSTYPE_DMZ ? "Datacenter" : "???");

        if(!TransStart(pTransInfo))
        {
            SgEventSz( CONFIG_ERROR, ". Failed to start transport %s", pTransInfo->_eaAdapter.Str());
            goto err;
        }

        // Announce our IP address(es). These are the "important" ones that will block 
        // startup if the probe fails.
#ifdef SG_FEATURE_ARP
        if (pTransInfo->_dwType == TRANSTYPE_DMZ)
        {
            if (pTransInfo->_ipaAdmin)
            {
                SgArpInfoStartNewProbe(pTransInfo, pTransInfo->_ipaAdmin, FALSE);
            }
        }
#ifndef SG_BUILD_ONEBOX
        else
        {
            SgArpInfoStartNewProbe(pTransInfo, pTransInfo->_ipa, FALSE);
        }
#endif
#endif

    }

    return(TRUE);

err:
    SgTransInfoTerm();
    return(FALSE);
}

CTransInfo * SgTransInfoLookup(UINT iTransInfo)
{
    if (iTransInfo < g_cTransInfo)
    {
        return(&g_pTransInfo[iTransInfo]);
    }

    return(NULL);
}

CTransInfo * SgTransInfoLookupZ(CIpAddr ipa)
{
    CTransInfo * pTransInfo = g_pTransInfo;
    UINT         cTransInfo = g_cTransInfo;

    for (; cTransInfo > 0; --cTransInfo, ++pTransInfo)
    {
        if (    pTransInfo->_dwType == TRANSTYPE_DMZ
            &&  pTransInfo->_ipa == ipa)
        {
            return(pTransInfo);
        }
    }

    return(NULL);
}

CTransInfo * SgTransInfoLookupZ(DWORD dwInterfaceId)
{
    CTransInfo * pTransInfo = g_pTransInfo;
    UINT         cTransInfo = g_cTransInfo;

    for (; cTransInfo > 0; --cTransInfo, ++pTransInfo)
    {
        if (    pTransInfo->_dwType == TRANSTYPE_DMZ
            &&  pTransInfo->_dwTransId == dwInterfaceId)
        {
            return(pTransInfo);
        }
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsvcperf.cpp ===
// ---------------------------------------------------------------------------------------
// sgsvcperf.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ---------------------------------------------------------------------------------------

#include "sg.h"

#ifdef SG_FEATURE_PERFCTRS

#include "sgperf.h"
#include <perfapi.h>

void SgServicePerfCounterSetValuePos( DWORD dwCounterID, ULONGLONG qwVal );
void SgServicePerfCounterSetValue( DWORD dwCounterID, ULONGLONG qwVal );
void SgServicePerfCounterIncrement( DWORD dwCounterID );
void SgServicePerfCounterSetAverage( DWORD dwCounterIDAvg, ULONGLONG qwValAvg, DWORD dwCounterIDBase, DWORD dwValBase );
void SgServicePerfCounterSetFraction( DWORD dwCounterIDFraction, QWORD qwValFraction, DWORD dwCounterIDBase, QWORD qwValBase );
void SgServicePerfCounterSetFraction( DWORD dwCounterIDFraction, DWORD dwValFraction, DWORD dwCounterIDBase, DWORD dwValBase );


//////////////////////////////////////////////////////////////////////////////
enum XQPC_TYPES
{
    XQPC_DWORD = 1,
    XQPC_QWORD = 2,
    XQPC_OBJECT = 3
};

struct PERFCOUNTER
{
    XQPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    BYTE *pbPerfCtrData;
};

// Objects (Categories)
struct PERFOBJECT
{
    DWORD dwPerfIndex;
    HANDLE hPerfObject;
    BYTE *pbPerfCtrDataStart;
};


#define DWORD_AVERAGE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, NULL }

#define DWORD_BASE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, NULL }

#define DWORD_COUNTER( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, NULL }

#define DWORD_RATE( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, NULL }

#define DWORD_RAW_BASE( INDEX ) \
    { XQPC_DWORD, PERF_RAW_BASE, sizeof(DWORD), INDEX, NULL }

#define DWORD_RAW_FRACTION( INDEX ) \
    { XQPC_DWORD, PERF_RAW_FRACTION, sizeof(DWORD), INDEX, NULL }

#define QWORD_AVERAGE( INDEX ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, NULL }

#define QWORD_COUNTER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, NULL }

#define QWORD_RATE( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, NULL }
    
#define QWORD_RAW_BASE( INDEX ) \
    { XQPC_QWORD, PERF_LARGE_RAW_BASE, sizeof(QWORD), INDEX, NULL }

#define QWORD_RAW_FRACTION( INDEX ) \
    { XQPC_QWORD, PERF_LARGE_RAW_FRACTION, sizeof(QWORD), INDEX, NULL }

#define QWORD_100NSTIMER( INDEX ) \
    { XQPC_QWORD, PERF_100NSEC_TIMER, sizeof(QWORD), INDEX, NULL}

#define QWORD_TIMER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_TIMER, sizeof(QWORD), INDEX, NULL}

#define OBJECT( INDEX ) \
    { XQPC_OBJECT, 0, 0, INDEX, NULL }

//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs[] =
{
    #include <sgperf.cpp>
};

PERFOBJECT s_ServerPerfObjects[] =
{
    { SGPERF_SERVER_OBJECT_GLOBAL, NULL, NULL },
    { SGPERF_SERVER_OBJECT_EXTENDED, NULL, NULL },
    { SGPERF_SERVER_OBJECT_DRIVER, NULL, NULL },
    { SGPERF_SERVER_OBJECT_NOTIFICATIONS, NULL, NULL },
#ifdef SG_FEATURE_LUA
    { SGPERF_SERVER_OBJECT_CHALLENGES, NULL, NULL },
    { SGPERF_SERVER_OBJECT_FILTERS, NULL, NULL },
    { SGPERF_SERVER_OBJECT_LUA, NULL, NULL },
#endif
};

#define NUM_SERVER_PERF_COUNTERS    dimensionof(s_ServerPerfCtrs)

#define NUM_SERVER_PERF_OBJECTS     dimensionof(s_ServerPerfObjects)


// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define SG_COUNTER_REFRESH_FREQUENCY 1000 // how often to get updated values in milliseconds


// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

DWORD g_dwLastTickCount;

// ---------------------------------------------------------------------------------------
// SgFindPerfObject
// ---------------------------------------------------------------------------------------
PERFOBJECT* SgFindPerfObject(PERFCOUNTER *pPerfCtr)
{
    Assert(pPerfCtr);
    // Layout should be:
    // 
    // PerfObject1  00
    //  Counter1    02
    //  Counter3    04
    //  Counter3    06
    // PerfObject2  08
    //  Counter4    10
    //
    // So we'll walk the list of perfobjects backwards, and if we find one with an index 
    // less than our counter, then we have a match. Should always terminate at the top 
    // with the first perfobject, which should have index 0.
    for (int idx = ARRAYSIZE(s_ServerPerfObjects) - 1; idx >= 0; idx--)
    {
        if (s_ServerPerfObjects[idx].dwPerfIndex < pPerfCtr->dwPerfIndex)
        {
            return &s_ServerPerfObjects[idx];
        }
    }
    return NULL;
}

// ---------------------------------------------------------------------------------------
// SgServicePerfCountersInit
// ---------------------------------------------------------------------------------------
BOOL SgServicePerfCountersInit()
{
    BOOL fReturn = FALSE;
    BYTE* pbServCtrsStart = NULL;

    // Initialize perf objects
    for( DWORD dwObj = 0; dwObj < NUM_SERVER_PERF_OBJECTS; dwObj++ )
    {
        s_ServerPerfObjects[dwObj].hPerfObject = CreatePerfObject(
            s_ServerPerfObjects[dwObj].dwPerfIndex,
            0,
            (void **)&s_ServerPerfObjects[dwObj].pbPerfCtrDataStart);
        if (s_ServerPerfObjects[dwObj].hPerfObject == NULL)
        {
            SgEventSz(INIT_ERROR_13, "SGSVC: SgServicePerfCountersInit() - Failed to create perf object #%d (index %d)", dwObj, s_ServerPerfObjects[dwObj].dwPerfIndex );
            goto Exit;
        }
    }

    // Initialize perf counters
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        // Ignore any perf object (not counter) entries
        if (s_ServerPerfCtrs[dwCtr].ctrType == XQPC_OBJECT)
        {
            continue;
        }

        // Find relevant perf object
        PERFOBJECT *pPerfObj = SgFindPerfObject(&s_ServerPerfCtrs[dwCtr]);
        if (pPerfObj == NULL)
        {
            SgEventSz(INIT_ERROR_13, "SGSVC: SgServerPerfCountersInit() - Failed to find perf object for counter #%d (index %d). Please examine the ordering of your objects and counters.",
                       dwCtr,
                       s_ServerPerfCtrs[dwCtr].dwPerfIndex);
            goto Exit;
        }

        // Create the counter, attaching it to the correct perf object
        DWORD dwCounterDataOffset = CreatePerfCounter(
            s_ServerPerfCtrs[ dwCtr ].dwPerfType,
            0, // dwScale
            s_ServerPerfCtrs[ dwCtr ].dwDataSize,
            pPerfObj->hPerfObject,
            s_ServerPerfCtrs[ dwCtr ].dwPerfIndex,
            NULL );

        Assert( 0xffffffff != dwCounterDataOffset );
        if( 0xFFFFFFFF == dwCounterDataOffset )
        {
            SgEventSz(INIT_ERROR_13, "SGSVC: SgServicePerfCountersInit() - Failed to initialize performance counter #%d (index %d)", dwCtr, s_ServerPerfCtrs[dwCtr].dwPerfIndex );
            goto Exit;
        }

        s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData = pPerfObj->pbPerfCtrDataStart + dwCounterDataOffset;

        // Zero every counter on startup
        ZeroMemory( s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData, s_ServerPerfCtrs[ dwCtr ].dwDataSize );
    }

    g_dwLastTickCount = GetTickCount();

    fReturn = TRUE;

Exit:
    return fReturn;
}


// ---------------------------------------------------------------------------------------
// SgServicePerfCountersTerm
// ---------------------------------------------------------------------------------------
void SgServicePerfCountersTerm()
{
    DestroyAllPerfObjects();
//     if( NULL != g_hServerPerfObj )
//     {
//         DestroyPerfObject( g_hServerPerfObj );
//         g_hServerPerfObj = NULL;
//     }
}


// ---------------------------------------------------------------------------------------
// SgServicePerfCountersHeartbeat
// ---------------------------------------------------------------------------------------
void SgServicePerfCountersHeartbeat()
{
    DWORD dwNow = GetTickCount();

    // See if it is time to get fresh counters
    if( g_dwLastTickCount - dwNow < SG_COUNTER_REFRESH_FREQUENCY )
    {
        goto Exit;
    }

    CSgPerfData PerfData;

    // Get updated counters from the transport layer
    (void)SgPerfdataQuery( &PerfData );

    SgServicePerfCounterSetFraction(
        SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_PERCENTAGE, PerfData._ullFreeConnections,
        SGPERF_SERVER_MAXIMUM_CONNECTIONS_PERCENTAGE,      PerfData._ullMaximumConnections
        );
    SgServicePerfCounterSetValue(SGPERF_SERVER_CURRENT_CONNECTIONS_COUNTER,      PerfData._ullCurrentConnections);
    SgServicePerfCounterSetValue(SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_COUNTER, PerfData._ullFreeConnections);
    SgServicePerfCounterSetValue(SGPERF_SERVER_CONNECTIONS_CIPHER_DES_COUNTER,   PerfData._ullConnectionsCipherDes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_CONNECTIONS_CIPHER_DES3_COUNTER,  PerfData._ullConnectionsCipherDes3);
    SgServicePerfCounterSetValue(SGPERF_SERVER_CONNECTIONS_CIPHER_AES_COUNTER,   PerfData._ullConnectionsCipherAes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_CONNECTIONS_CIPHER_NULL_COUNTER,  PerfData._ullConnectionsCipherNull);
    SgServicePerfCounterSetValue(SGPERF_SERVER_RECV_TOTAL,                       PerfData._ullRecvTotal);
    SgServicePerfCounterSetValue(SGPERF_SERVER_RECV_BYTES,                       PerfData._ullRecvTotalBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_XMIT_TOTAL,                       PerfData._ullXmitTotal);

    SgServicePerfCounterSetValue(SGPERF_SERVER_QUEUED,                           PerfData._ullQueuedProc
                                                                               + PerfData._ullQueuedCli 
                                                                               + PerfData._ullQueuedSpi);
    SgServicePerfCounterSetValue(SGPERF_SERVER_QUEUED_PROC,                    PerfData._ullQueuedProc),
    SgServicePerfCounterSetValue(SGPERF_SERVER_QUEUED_CLI,                     PerfData._ullQueuedCli),
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROPPED_CLI_RATE,               PerfData._ullDroppedCli),
    SgServicePerfCounterSetValue(SGPERF_SERVER_QUEUED_SPI,                     PerfData._ullQueuedSpi),
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROPPED_SPI_RATE,               PerfData._ullDroppedSpi),
    SgServicePerfCounterSetValue(SGPERF_SERVER_CURRENT_BLOCKED,                PerfData._ullCurrentBlocked);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROPPED_BLOCKED,                PerfData._ullDroppedBlocked);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROPPED_BLOCKED_RATE,           PerfData._ullDroppedBlocked);
    SgServicePerfCounterSetValue(SGPERF_SERVER_CURRENT_FREE_BLOCK_ITEMS,       PerfData._ullCurrentFreeBlockInfo);
    SgServicePerfCounterSetValuePos(SGPERF_SERVER_PACKETS_AVAILABLE,           PerfData._ullPacketsAvailable),
    SgServicePerfCounterSetValue(SGPERF_SERVER_PACKETALLOC_FAIL,               PerfData._ullPacketAllocFail);
    SgServicePerfCounterSetValue(SGPERF_SERVER_PACKETALLOC_FAIL_RATE,          PerfData._ullPacketAllocFail);
    SgServicePerfCounterSetValue(SGPERF_SERVER_PACKETALLOC_SUCCESS_RATE,       PerfData._ullPacketAllocSuccess);

    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_DELETE_RATE,       PerfData._ullNotificationsDelete),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_DELETE_DROP_TOTAL, PerfData._ullNotificationsDeleteDrop),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_DELETE_QUEUE,      PerfData._ullNotificationsDeleteQueue),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_DELETE_BATCHES,    PerfData._ullNotificationsDeleteBatches),

    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_UPDATE_RATE,       PerfData._ullNotificationsUpdate),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_UPDATE_DROP_TOTAL, PerfData._ullNotificationsUpdateDrop),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_UPDATE_QUEUE,      PerfData._ullNotificationsUpdateQueue),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_UPDATE_BATCHES,    PerfData._ullNotificationsUpdateBatches),

    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_RATE,       PerfData._ullNotificationsTitleChange),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_DROP_TOTAL, PerfData._ullNotificationsTitleChangeDrop),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_QUEUE,      PerfData._ullNotificationsTitleChangeQueue),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_BATCHES,    PerfData._ullNotificationsTitleChangeBatches),

    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_RATE,       PerfData._ullNotificationsUserChange),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_DROP_TOTAL, PerfData._ullNotificationsUserChangeDrop),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_QUEUE,      PerfData._ullNotificationsUserChangeQueue),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_BATCHES,    PerfData._ullNotificationsUserChangeBatches),

    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_RATE,       PerfData._ullNotificationsSpiUpdate),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_DROP_TOTAL, PerfData._ullNotificationsSpiUpdateDrop),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_QUEUE,      PerfData._ullNotificationsSpiUpdateQueue),
    SgServicePerfCounterSetValue(SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_BATCHES,    PerfData._ullNotificationsSpiUpdateBatches),

    SgServicePerfCounterSetValue(SGPERF_SERVER_IRECV,                          PerfData._ullIRecv);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IRECV_BYTES,                    PerfData._ullIRecvBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT,                          PerfData._ullIXmit);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_BYTES,                    PerfData._ullIXmitBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IRECV_RATE,                     PerfData._ullIRecv);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IRECV_BYTES_RATE,               PerfData._ullIRecvBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_RATE,                     PerfData._ullIXmit);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_BYTES_RATE,               PerfData._ullIXmitBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IRECV_DRIVER_CALLS_RATE,        PerfData._ullIRecvDriverCalls);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IRECV_PACKETS_DRIVER_RATE,      PerfData._ullIRecvPacketsDriver);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IRECV_BATCH_THRESHOLD,          PerfData._ullIRecvBatchThreshold);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IDROP_PACKETS_DRIVER_RATE,      PerfData._ullIDropPacketsDriver);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_DRIVER_CALLS_RATE,        PerfData._ullIXmitDriverCalls);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_PACKETS_DRIVER_RATE,      PerfData._ullIXmitPacketsDriver);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_STAGE1_COUNT,             PerfData._ullIXmitStage1Count);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_STAGE2_COUNT,             PerfData._ullIXmitStage2Count);
    SgServicePerfCounterSetValue(SGPERF_SERVER_IXMIT_INPROGRESS,               PerfData._ullIXmitInProgress);

    SgServicePerfCounterSetValue(SGPERF_SERVER_KEYEX,                          PerfData._ullKeyEx);
    SgServicePerfCounterSetValue(SGPERF_SERVER_KEYEX_TOTAL,                    PerfData._ullKeyExTotal);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LOGOFF_RATE,                    PerfData._ullLogoffTimeout);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LOGOFF_TIMEOUT,                 PerfData._ullLogoffTimeout);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LOGOFF_TIMEOUT_KEYEX,           PerfData._ullLogoffTimeoutKeyEx);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LOGOFF_TIMEOUT_REINIT,          PerfData._ullLogoffReinit);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LOGOFF_SECMSG,                  PerfData._ullSecDelete);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LOGOFF_KICK,                    PerfData._ullLogoffKick);
    SgServicePerfCounterSetValue(SGPERF_SERVER_XSP_RECV,                       PerfData._ullXspRecv);
    SgServicePerfCounterSetValue(SGPERF_SERVER_XSP_RECV_TOTAL,                 PerfData._ullXspRecvTotal);
    SgServicePerfCounterSetValue(SGPERF_SERVER_XSP_XMIT,                       PerfData._ullXspXmit);
    SgServicePerfCounterSetValue(SGPERF_SERVER_KEYEX_RATE,                     PerfData._ullKeyEx);
    SgServicePerfCounterSetValue(SGPERF_SERVER_KEYEX_TOTAL_RATE,               PerfData._ullKeyExTotal);
    SgServicePerfCounterSetValue(SGPERF_SERVER_XSP_RECV_RATE,                  PerfData._ullXspRecv);
    SgServicePerfCounterSetValue(SGPERF_SERVER_XSP_RECV_TOTAL_RATE,            PerfData._ullXspRecvTotal);
    SgServicePerfCounterSetValue(SGPERF_SERVER_XSP_XMIT_RATE,                  PerfData._ullXspXmit);
    SgServicePerfCounterSetValue(SGPERF_SERVER_AUTHDATAV2,                     PerfData._ullAuthdataV2);
    SgServicePerfCounterSetValue(SGPERF_SERVER_AUTHDATAV2_RATE,                PerfData._ullAuthdataV2);
    SgServicePerfCounterSetValue(SGPERF_SERVER_AUTHDATAV3,                     PerfData._ullAuthdataV3);
    SgServicePerfCounterSetValue(SGPERF_SERVER_AUTHDATAV3_RATE,                PerfData._ullAuthdataV3);
    SgServicePerfCounterSetValue(SGPERF_SERVER_AUTHDATAV4,                     PerfData._ullAuthdataV4);
    SgServicePerfCounterSetValue(SGPERF_SERVER_AUTHDATAV4_RATE,                PerfData._ullAuthdataV4);

    SgServicePerfCounterSetValue(SGPERF_SERVER_ZRECV,                          PerfData._ullZRecv);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZRECV_BYTES,                    PerfData._ullZRecvBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT,                          PerfData._ullZXmit);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_BYTES,                    PerfData._ullZXmitBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZRECV_RATE,                     PerfData._ullZRecv);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZRECV_BYTES_RATE,               PerfData._ullZRecvBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_RATE,                     PerfData._ullZXmit);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_BYTES_RATE,               PerfData._ullZXmitBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZRECV_DRIVER_CALLS_RATE,        PerfData._ullZRecvDriverCalls);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZRECV_PACKETS_DRIVER_RATE,      PerfData._ullZRecvPacketsDriver);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZRECV_BATCH_THRESHOLD,          PerfData._ullZRecvBatchThreshold);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZDROP_PACKETS_DRIVER_RATE,      PerfData._ullZDropPacketsDriver);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_DRIVER_CALLS_RATE,        PerfData._ullZXmitDriverCalls);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_PACKETS_DRIVER_RATE,      PerfData._ullZXmitPacketsDriver);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_STAGE1_COUNT,             PerfData._ullZXmitStage1Count);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_STAGE2_COUNT,             PerfData._ullZXmitStage2Count);
    SgServicePerfCounterSetValue(SGPERF_SERVER_ZXMIT_INPROGRESS,               PerfData._ullZXmitInProgress);

    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG,                          PerfData._ullSgMsg);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_RATE,                     PerfData._ullSgMsg);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_INVALID,                  PerfData._ullSgMsgInvalid);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_INVALID_RATE,             PerfData._ullSgMsgInvalid);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_NOMATCH,                  PerfData._ullSgMsgNoMatch);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_NOMATCH_RATE,             PerfData._ullSgMsgNoMatch);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_KICK,                     PerfData._ullSgMsgKick);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_KICK_RATE,                PerfData._ullSgMsgKick);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_QVALS_LAZY,               PerfData._ullSgMsgQvalsLazy);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_QVALS_LAZY_RATE,          PerfData._ullSgMsgQvalsLazy);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_QVALS_PUSH,               PerfData._ullSgMsgQvalsPush);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_QVALS_PUSH_RATE,          PerfData._ullSgMsgQvalsPush);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_XBTOXB_FORWARD,           PerfData._ullSgMsgForward);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_XBTOXB_FORWARD_RATE,      PerfData._ullSgMsgForward);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_SPIDATA_REQ,              PerfData._ullSgMsgSpiData);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_SPIDATA_REQ_RATE,         PerfData._ullSgMsgSpiData);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_SPIDATA2_REQ,             PerfData._ullSgMsgSpiData2);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_SPIDATA2_REQ_RATE,        PerfData._ullSgMsgSpiData2);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ,     PerfData._ullSgMsgSpiData2Backcompat);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ_RATE,PerfData._ullSgMsgSpiData2Backcompat);

    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG,                         PerfData._ullSecMsg);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_RATE,                    PerfData._ullSecMsg);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_DELETE,                  PerfData._ullSecDelete);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_DELETE_RATE,             PerfData._ullSecDelete);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_PULSE,                   PerfData._ullSecPulse);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_PULSE_RATE,              PerfData._ullSecPulse);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_DATA_PULSE,              PerfData._ullSecDataPulse);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_DATA_PULSE_RATE,         PerfData._ullSecDataPulse);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_XBTOXB_FORWARD,          PerfData._ullSecForward);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_XBTOXB_FORWARD_RATE,     PerfData._ullSecForward);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_QOS,                     PerfData._ullSecQos);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_QOS_RATE,                PerfData._ullSecQos);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_CHANGE_USERS,            PerfData._ullSecChangeUsers);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SECMSG_CHANGE_USERS_RATE,       PerfData._ullSecChangeUsers);

#ifdef SG_FEATURE_LUA
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_ISSUE,                       PerfData._ullChalSyncIssue);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_ISSUE_RATE,                  PerfData._ullChalSyncIssue);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_RESPONSE,                    PerfData._ullChalSyncResponse);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_RESPONSE_RATE,               PerfData._ullChalSyncResponse);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_TIMEOUT,                     PerfData._ullChalSyncTimeout);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_TIMEOUT_RATE,                PerfData._ullChalSyncTimeout);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_OUTCOME_PASS,                PerfData._ullChalSyncPass);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_OUTCOME_PASS_RATE,           PerfData._ullChalSyncPass);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_OUTCOME_FAIL,                PerfData._ullChalSyncFail);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_OUTCOME_FAIL_RATE,           PerfData._ullChalSyncFail);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_OUTCOME_BLOCK,               PerfData._ullChalSyncBlock);
    SgServicePerfCounterSetValue(SGPERF_CHAL_SYNC_OUTCOME_BLOCK_RATE,          PerfData._ullChalSyncBlock);

    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_ISSUE,                      PerfData._ullChalAsyncIssue);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_ISSUE_RATE,                 PerfData._ullChalAsyncIssue);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_RESPONSE,                   PerfData._ullChalAsyncResponse);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_RESPONSE_RATE,              PerfData._ullChalAsyncResponse);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_TIMEOUT,                    PerfData._ullChalAsyncTimeoutAck + 
                                                                               PerfData._ullChalAsyncTimeoutResp +
                                                                               PerfData._ullChalAsyncTimeoutDropped);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_TIMEOUT_RATE,               PerfData._ullChalAsyncTimeoutAck + 
                                                                               PerfData._ullChalAsyncTimeoutResp +
                                                                               PerfData._ullChalAsyncTimeoutDropped);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_TIMEOUT_ACK,                PerfData._ullChalAsyncTimeoutAck);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_TIMEOUT_ACK_RATE,           PerfData._ullChalAsyncTimeoutAck);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_TIMEOUT_RESP,               PerfData._ullChalAsyncTimeoutResp);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_TIMEOUT_RESP_RATE,          PerfData._ullChalAsyncTimeoutResp);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_OUTCOME_PASS,               PerfData._ullChalAsyncPass);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_OUTCOME_PASS_RATE,          PerfData._ullChalAsyncPass);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_OUTCOME_FAIL,               PerfData._ullChalAsyncFail);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_OUTCOME_FAIL_RATE,          PerfData._ullChalAsyncFail);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_OUTCOME_BLOCK,              PerfData._ullChalAsyncBlock);
    SgServicePerfCounterSetValue(SGPERF_CHAL_ASYNC_OUTCOME_BLOCK_RATE,         PerfData._ullChalAsyncBlock);

    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_ISSUE,                     PerfData._ullChalSyncIssue + PerfData._ullChalAsyncIssue);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_ISSUE_RATE,                PerfData._ullChalSyncIssue + PerfData._ullChalAsyncIssue);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_RESPONSE,                  PerfData._ullChalSyncResponse + PerfData._ullChalAsyncResponse);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_RESPONSE_RATE,             PerfData._ullChalSyncResponse + PerfData._ullChalAsyncResponse);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_TIMEOUT,                   PerfData._ullChalSyncTimeout + PerfData._ullChalAsyncTimeoutAck + PerfData._ullChalAsyncTimeoutResp);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_TIMEOUT_RATE,              PerfData._ullChalSyncTimeout + PerfData._ullChalAsyncTimeoutAck + PerfData._ullChalAsyncTimeoutResp);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_OUTCOME_PASS,              PerfData._ullChalSyncPass + PerfData._ullChalAsyncPass);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_OUTCOME_PASS_RATE,         PerfData._ullChalSyncPass + PerfData._ullChalAsyncPass);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_OUTCOME_FAIL,              PerfData._ullChalSyncFail + PerfData._ullChalAsyncFail);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_OUTCOME_FAIL_RATE,         PerfData._ullChalSyncFail + PerfData._ullChalAsyncFail);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_OUTCOME_BLOCK,             PerfData._ullChalSyncBlock + PerfData._ullChalAsyncBlock);
    SgServicePerfCounterSetValue(SGPERF_CHAL_GLOBAL_OUTCOME_BLOCK_RATE,        PerfData._ullChalSyncBlock + PerfData._ullChalAsyncBlock);

    SgServicePerfCounterSetValue(SGPERF_FILTER_KICK,                           PerfData._ullFilterKick);
    SgServicePerfCounterSetValue(SGPERF_FILTER_KICK_RATE,                      PerfData._ullFilterKick);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_DES,                     PerfData._ullFilterSetDES);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_DES_RATE,                PerfData._ullFilterSetDES);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_DES3,                    PerfData._ullFilterSetDES3);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_DES3_RATE,               PerfData._ullFilterSetDES3);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_AES,                     PerfData._ullFilterSetAES);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_AES_RATE,                PerfData._ullFilterSetAES);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_NULL,                    PerfData._ullFilterSetNULL);
    SgServicePerfCounterSetValue(SGPERF_FILTER_CIPHER_NULL_RATE,               PerfData._ullFilterSetNULL);

    SgServicePerfCounterSetValue(SGPERF_SERVER_LUA_CALLS,                      PerfData._ullLuaCalls);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LUA_CALLS_RATE,                 PerfData._ullLuaCalls);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LUA_MEMORY_USAGE_BYTES,         PerfData._ullLuaMemoryUsageBytes);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LUA_STATE_INUSE,                PerfData._ullLuaStateInUse);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LUA_STATE_ACQUIRE_RATE,         PerfData._ullLuaStateAcquire);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LUA_STATE_TIME,                 PerfData._ullLuaStateTime);
    SgServicePerfCounterSetValue(SGPERF_SERVER_LUA_STATE_LOCK_TIME,            PerfData._ullLuaStateLockTime);

    QWORD qwBase = PerfData._ullCurrentConnections != 0 ? PerfData._ullCurrentConnections : 1;
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_ACTIVE,                                PerfData._ullChalActive,     
        SGPERF_CHAL_ACTIVE_BASE,                           qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY,                                 PerfData._ullChalRetry,      
        SGPERF_CHAL_RETRY_BASE,                            qwBase
        );

    qwBase = PerfData._ullChalRetry != 0 ? PerfData._ullChalRetry : 1;
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_ACK_1,                           PerfData._ullChalRetryAck1,      
        SGPERF_CHAL_RETRY_ACK_1_BASE,                      qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_ACK_2,                           PerfData._ullChalRetryAck2,      
        SGPERF_CHAL_RETRY_ACK_2_BASE,                      qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_ACK_3,                           PerfData._ullChalRetryAck3,      
        SGPERF_CHAL_RETRY_ACK_3_BASE,                      qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_ACK_4,                           PerfData._ullChalRetryAck4,      
        SGPERF_CHAL_RETRY_ACK_4_BASE,                      qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_ACK_5,                           PerfData._ullChalRetryAck5,      
        SGPERF_CHAL_RETRY_ACK_5_BASE,                      qwBase
        );

    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_RESP_1,                          PerfData._ullChalRetryResp1,     
        SGPERF_CHAL_RETRY_RESP_1_BASE,                     qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_RESP_2,                          PerfData._ullChalRetryResp2,     
        SGPERF_CHAL_RETRY_RESP_2_BASE,                     qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_RESP_3,                          PerfData._ullChalRetryResp3,     
        SGPERF_CHAL_RETRY_RESP_3_BASE,                     qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_RESP_4,                          PerfData._ullChalRetryResp4,     
        SGPERF_CHAL_RETRY_RESP_4_BASE,                     qwBase
        );
    SgServicePerfCounterSetFraction(
        SGPERF_CHAL_RETRY_RESP_5,                          PerfData._ullChalRetryResp5,     
        SGPERF_CHAL_RETRY_RESP_5_BASE,                     qwBase
        );
#endif

    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_ENET_HDR,                  PerfData._ullDropEnetHdr);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_ENET_HDR_RATE,             PerfData._ullDropEnetHdr);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_IP_HDR,                    PerfData._ullDropIpHdr);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_IP_HDR_RATE,               PerfData._ullDropIpHdr);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_XSP_HDR,                   PerfData._ullDropXspHdr);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_XSP_HDR_RATE,              PerfData._ullDropXspHdr);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_XSP_HASH,                  PerfData._ullDropXspHash);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_XSP_HASH_RATE,             PerfData._ullDropXspHash);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_DENIED,                    PerfData._ullDropDenied);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_DENIED_RATE,               PerfData._ullDropDenied);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_FORMAT,              PerfData._ullDropKeyExFormat);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_FORMAT_RATE,         PerfData._ullDropKeyExFormat);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_KERB,                PerfData._ullDropKeyExKerb);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_KERB_RATE,           PerfData._ullDropKeyExKerb);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR,       PerfData._ullDropAuthenticator);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR_RATE,  PerfData._ullDropAuthenticator);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_TOO_SOON,            PerfData._ullDropKeyExTooSoon);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_TOO_SOON_RATE,       PerfData._ullDropKeyExTooSoon);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_HASH,                PerfData._ullDropKeyExHash);
    SgServicePerfCounterSetValue(SGPERF_SERVER_DROP_KEYEX_HASH_RATE,           PerfData._ullDropKeyExHash);

    SgServicePerfCounterSetValue(SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_CALLS,     PerfData._ullDriverProtocolReceivePacketCalls);
    SgServicePerfCounterSetValue(SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_COPY_CALLS,PerfData._ullDriverProtocolReceivePacketCopyCalls);
    SgServicePerfCounterSetValue(SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_CALLS, PerfData._ullDriverProtocolReceiveIndicationCalls);
    SgServicePerfCounterSetValue(SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_DISCARD, PerfData._ullDriverProtocolReceiveIndicationDiscard);
    SgServicePerfCounterSetValue(SGPERF_DRIVER_PROTOCOL_RECEIVE_COMPLETE_CALLS,   PerfData._ullDriverProtocolReceiveCompleteCalls);
    SgServicePerfCounterSetValue(SGPERF_DRIVER_PACKETS_ALLOCATED,                 PerfData._ullDriverPacketsInUse);
    
    SgServicePerfCounterSetValue(SGPERF_SERVER_THREAD_POOL_WAIT_RATE,          PerfData._ullThreadPoolWaitCount);
    SgServicePerfCounterSetValue(SGPERF_SERVER_THREAD_POOL_ACTIVE,             PerfData._ullThreadPoolActiveCount);
    SgServicePerfCounterSetValue(SGPERF_SERVER_THREAD_POOL_WORKITEMS_MISS_RATE,PerfData._ullThreadPoolWorkItemsMissCount);
    SgServicePerfCounterSetValue(SGPERF_SERVER_THREAD_POOL_WORKITEMS_HIT_RATE, PerfData._ullThreadPoolWorkItemsHitCount);
    SgServicePerfCounterSetAverage(
        SGPERF_SERVER_THREAD_POOL_BATCHSIZE_AVERAGE, PerfData._ullThreadPoolWorkItemsRetrievedCount, 
        SGPERF_SERVER_THREAD_POOL_BATCHSIZE_BASE, (DWORD)PerfData._ullThreadPoolWorkItemsHitCount);
    
    SgServicePerfCounterSetValue(SGPERF_SERVER_SPIN_LOCK_COLLISION_RATE,       PerfData._ullSpinLockCollisions);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SPIN_LOCK_SLEEP_RATE,           PerfData._ullSpinLockSleeps);
    SgServicePerfCounterSetValue(SGPERF_SERVER_SPIN_LOCK_LOCKS_RATE,           PerfData._ullSpinLockLocks);

    SgServicePerfCounterSetValue(SGPERF_SERVER_LOGLINES_FLOWMAP_RATE,          PerfData._ullLoglinesFlowmap);

Exit:
    return;
}

// ---------------------------------------------------------------------------------------
// SgServicePerfCounterSetValuePos
// ---------------------------------------------------------------------------------------
void SgServicePerfCounterSetValuePos( DWORD dwCounterID, ULONGLONG qwVal )
{
    // Some counters, such as PacketsAvailable (SGPERF_SERVER_PACKETS_AVAILABLE), can 
    // actually become negative briefly. This is highly annoying when looking at perfmon 
    // captures at the max/min values, but capping them at time of use can be expensive.  
    // So let's fix them up here.

    if ((LONGLONG)qwVal < (LONGLONG)0)
    {
        qwVal = 0;
    }

    SgServicePerfCounterSetValue(dwCounterID, qwVal);
}

// ---------------------------------------------------------------------------------------
// SgServicePerfCounterSetValue
// ---------------------------------------------------------------------------------------
void SgServicePerfCounterSetValue( DWORD dwCounterID, ULONGLONG qwVal )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    Assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    Assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = qwVal;
}

// ---------------------------------------------------------------------------------------
// SgServicePerfCounterIncrement
// ---------------------------------------------------------------------------------------
void SgServicePerfCounterIncrement( DWORD dwCounterID )
{
    DWORD dwCounterIndex = ( dwCounterID / 2 );
    
    Assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    Assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += 1;
}

// ---------------------------------------------------------------------------------------
// SgServicePerfCounterSetAverage
// ---------------------------------------------------------------------------------------
void SgServicePerfCounterSetAverage( DWORD dwCounterIDAvg, ULONGLONG qwValAvg, DWORD dwCounterIDBase, DWORD dwValBase )
{
    DWORD dwCounterIndex = ( dwCounterIDAvg / 2 );
   
    Assert( dwCounterIDAvg + 2 == dwCounterIDBase);
    Assert( dwCounterIndex + 1 < NUM_SERVER_PERF_COUNTERS );
    // The numerator (average)
    Assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    // The denominator (base)
    Assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex+1 ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = qwValAvg;
    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex+1 ].pbPerfCtrData = dwValBase;
}

// ---------------------------------------------------------------------------------------
// SgServicePerfCounterSetFraction
// ---------------------------------------------------------------------------------------
void SgServicePerfCounterSetFraction( DWORD dwCounterIDFraction, QWORD qwValFraction, DWORD dwCounterIDBase, QWORD qwValBase )
{
    DWORD dwCounterIndex = ( dwCounterIDFraction / 2 );
   
    Assert( dwCounterIDFraction + 2 == dwCounterIDBase);
    Assert( dwCounterIndex + 1 < NUM_SERVER_PERF_COUNTERS );
    // The numerator (average)
    Assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    // The denominator (base)
    Assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex+1 ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex     ].pbPerfCtrData = qwValFraction;
    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex + 1 ].pbPerfCtrData = qwValBase;
}

void SgServicePerfCounterSetFraction( DWORD dwCounterIDFraction, DWORD dwValFraction, DWORD dwCounterIDBase, DWORD dwValBase )
{
    DWORD dwCounterIndex = ( dwCounterIDFraction / 2 );
   
    Assert( dwCounterIDFraction + 2 == dwCounterIDBase);
    Assert( dwCounterIndex + 1 < NUM_SERVER_PERF_COUNTERS );
    // The numerator (average)
    Assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    // The denominator (base)
    Assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex+1 ].ctrType );

    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex     ].pbPerfCtrData = dwValFraction;
    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex + 1 ].pbPerfCtrData = dwValBase;
}


#else // !SG_FEATURE_PERFCTRS

// ---------------------------------------------------------------------------------------
// SgServicePerfCountersInit
// ---------------------------------------------------------------------------------------
BOOL SgServicePerfCountersInit()
{
    return TRUE;
}


// ---------------------------------------------------------------------------------------
// SgServicePerfCountersTerm
// ---------------------------------------------------------------------------------------
void SgServicePerfCountersTerm()
{
}


// ---------------------------------------------------------------------------------------
// SgServicePerfCountersHeartbeat
// ---------------------------------------------------------------------------------------
void SgServicePerfCountersHeartbeat()
{
}

#endif // SG_FEATURE_PERFCTRS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgxmit.cpp ===
// ---------------------------------------------------------------------------------------
// sgrecv.cpp
//
// Receive handler for Transports
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// SgIXmitWithSpi
//
// This function adds security headers to a packet and sends it to a CSpiInfo.
//
// The following diagram, stolen from ip.cpp in the client tree, shows the layout of the
// secure packet format. Note that the CryptPad is 0 to 7 for DES/DES3, or 0 to 15 for
// AES.
//
//    +CXspHdr----------+cbDat-------------+      +cbTvo+CXspTail--------------------------+
// +---------------------------------------------------------------------------------------+
// |IP|UDP|dwSpiAndFlags|CryptData|CryptPad|      |Voice|wSeqLo|abHash                     |
// |20|8  |4            |Var      |0 thru 7|      |Var  |2     |10                         |
// |      |bFlags                   |Ports|TcpInfo|     |      |wSeqHi|dwSpiAndFlags|dwZero|
// |      |1                        |0/2/4|12     |     |      |2     |4            |4     |
// +---------------------------------------------------------------------------------------+
//                                +cbPad---+      |
//                                  +cbTov-+      |
//                                  +cbTex--------+
//
// There is yet more info in ip.cpp if you are curious.
//
// ---------------------------------------------------------------------------------------

void SgIXmitWithSpi(CPacket * ppkt)
{
    CSpiInfo * pSpiInfo = ppkt->_pSpiInfo;

    if (pSpiInfo->_qwTickKeyEx2 == 0)
    {
        // Key exchange has not completed, so nobody should be trying to send a packet
        // back to the client.  Drop the packet right here.

        TraceSz(Warning, "%s: SgIXmitWithSpi before KeyEx is complete", ppkt->Str());
        SgEventPacket(KEYEX_INCOMPLETE, ppkt, ppkt->_pIpHdr->_ipaSrc, 0, ppkt->_cb, ppkt->_pb);
        ppkt->Complete();
        return;
    }

    // Mark the CSpiInfo with the current timer tick to record packet activity

    pSpiInfo->_qwTickXmit = SgTimerTick();

    //
    // Rewrite the packet to add the security headers and forward it onto the client
    //

    CTransInfo * pTransInfoXmit = ppkt->_pTransInfoXmit = pSpiInfo->_pTransInfo;
    CIpHdr *     pIpHdr         = ppkt->_pIpHdr;
    CXspCtx *    pXspCtx        = (CXspCtx *)ppkt->_abCtx;
    CXspHdr *    pXspHdr        = ppkt->_pXspHdr  = &pXspCtx->_XspHdr;
    CXspTail *   pXspTail       = ppkt->_pXspTail = &pXspCtx->_XspTail;
    CEnetHdr *   pEnetHdr       = &pXspCtx->_EnetHdr;
    CUdpHdr *    pUdpHdr        = (CUdpHdr *)ppkt->_pb;
    BYTE         bXspFlags      = 0;
    DWORD        dwSeq          = ppkt->_dwSeq = ++pSpiInfo->_dwSeqXmit;
    UINT         cbPad          = 0;
    UINT         cbTex          = 0;
    UINT         cbTov          = 0;
    WORD         ipportsrc      = XSP_PORT;
    bool         fArp           = false;

    // Get some crypto params, namely the block size

    UINT        uiCipher         = 0; // not used
    UINT        uiBlockLen       = 0;
    UINT        uiTableSize      = 0; // not used

    XcGetCryptParamsFromKeyLength(pSpiInfo->_cbKeyCrypt, &uiCipher, &uiBlockLen, &uiTableSize);
    Assert(uiBlockLen <= 16);  // that's all we have room for in the padding size field

    Assert(     pIpHdr->_bProtocol == IPPROTOCOL_SECMSG
            ||  pIpHdr->_bProtocol == IPPROTOCOL_UDP
            ||  pIpHdr->_bProtocol == IPPROTOCOL_TCP
            ||  pIpHdr->_bProtocol == IPPROTOCOL_VDP);

    pXspCtx->_pb1 = NULL;
    pXspCtx->_cb1 = 0;
    pXspCtx->_pb2 = (BYTE *)pXspTail;
    pXspCtx->_cb2 = offsetof(CXspTail, _dwZero);
    pXspCtx->_pb3 = ppkt->_pb;
    pXspCtx->_cb3 = ppkt->_cb;
    pXspCtx->_pb4 = NULL;
    pXspCtx->_cb4 = 0;

    if (pIpHdr->_bProtocol != IPPROTOCOL_SECMSG)
    {
        if (pIpHdr->_bProtocol == IPPROTOCOL_VDP)
        {
            Assert(pXspCtx->_cb3 >= sizeof(CUdpHdr) + sizeof(WORD));

            UINT cbDat = *(WORD *)(pXspCtx->_pb3 + sizeof(CUdpHdr));

            Assert(pXspCtx->_cb3 >= sizeof(CUdpHdr) + sizeof(WORD) + cbDat);

            pXspCtx->_pb3 += sizeof(CUdpHdr) + sizeof(WORD);
            pXspCtx->_cb3 -= sizeof(CUdpHdr) + sizeof(WORD);

            pXspCtx->_pb1  = pXspCtx->_pb3 + cbDat;
            pXspCtx->_cb1  = pXspCtx->_cb3 - cbDat;

            pXspCtx->_cb3  = cbDat;

            if (pXspCtx->_cb3 > 0 && pXspCtx->_cb1 > 0)
            {
                pXspCtx->_pb2   -= sizeof(BYTE);
                pXspCtx->_cb2   += sizeof(BYTE);

                // We always use the number of 8 byte blocks, even in the case of AES with
                // its 16 byte blocks. This helps out Netmon. This number should always be
                // even for AES. The code written is equivalent to doing the following for
                // each encryption algorithm:
                //    8-byte blocks: pXspCtx->_pb2[0] = (cbDat + 7) / 8;
                //   16-byte blocks: pXspCtx->_pb2[0] = 2 * ((cbDat + 15) / 16);
                pXspCtx->_pb2[0] = (uiBlockLen >> 3) * ((cbDat + (uiBlockLen - 1)) / uiBlockLen);

                bXspFlags += XSP_TYPE_VDP_0;
            }
            else
            {
                bXspFlags += ((pXspCtx->_cb3 == 0) ? XSP_TYPE_VDP_VO_0 : XSP_TYPE_VDP_DO_0);
            }
        }
        else if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
        {
            pXspCtx->_pb2 -= sizeof(CTcpInfo);
            pXspCtx->_cb2 += sizeof(CTcpInfo);

            memcpy(pXspCtx->_pb2, pXspCtx->_pb3 + offsetof(CTcpHdr, _info), sizeof(CTcpInfo));

            pXspCtx->_pb3 += sizeof(CTcpHdr);
            pXspCtx->_cb3 -= sizeof(CTcpHdr);

            cbTex     += sizeof(CTcpInfo);
            bXspFlags += XSP_TYPE_TCP_0;
        }
        else if (pIpHdr->_bProtocol == IPPROTOCOL_UDP)
        {
            pXspCtx->_pb3 += sizeof(CUdpHdr);
            pXspCtx->_cb3 -= sizeof(CUdpHdr);

            bXspFlags += XSP_TYPE_UDP_0;
        }

        WORD wSrc = (WORD)(NTOHS(pUdpHdr->_ipportSrc) - 1000);
        WORD wDst = (WORD)(NTOHS(pUdpHdr->_ipportDst) - 1000);
        WORD wOr  = wSrc | wDst;

        if (wOr > 255)
        {
            pXspCtx->_pb2 -= 2 * sizeof(CIpPort);
            pXspCtx->_cb2 += 2 * sizeof(CIpPort);

            memcpy(pXspCtx->_pb2, &pUdpHdr->_ipportSrc, 2 * sizeof(CIpPort));

            cbTex     += 2 * sizeof(CIpPort);
            bXspFlags += 2;
        }
        else if (wOr > 0)
        {
            pXspCtx->_pb2   -= 2 * sizeof(BYTE);
            pXspCtx->_cb2   += 2 * sizeof(BYTE);
            pXspCtx->_pb2[0] = (BYTE)wSrc;
            pXspCtx->_pb2[1] = (BYTE)wDst;

            cbTex     += 2 * sizeof(BYTE);
            bXspFlags += 1;
        }
    }
    else
    {
        CSecMsgHdr * pSecMsgHdr = (CSecMsgHdr *)ppkt->_pb;

        if (pSecMsgHdr->_wType == SECMSG_TYPE_SGTOXB_NATDET_REP)
        {
            ipportsrc++;

            // Ops wants us to ARP for this message type. I know, they are evil.
            // bug 30189.

            fArp = true;
        }
    }

    // Align padding to block size of cipher

    cbPad = pXspCtx->_cb3 % uiBlockLen;

    if (cbPad > 0)
    {
        memset(pXspCtx->_abPad, 0, sizeof(pXspCtx->_abPad));
        memcpy(pXspCtx->_abPad, pXspCtx->_pb3 + pXspCtx->_cb3 - cbPad, cbPad);

        pXspCtx->_cb3 -= cbPad;

        pXspCtx->_pb4  = pXspCtx->_abPad;
        pXspCtx->_cb4  = uiBlockLen;

        cbPad = uiBlockLen - cbPad;

        // If we're "old school" DES/DES3 with 8 byte blocklen, then we do the old thing.
        // If we're "new school" AES with 16 byte blocklen, then we do the new thing and
        // steal an extra bit.
        Assert(cbPad < 16);  // that's all the bits we have..
        bXspFlags |= (BYTE)XSP_ENCODE_PADDING(cbPad);
    }

    cbTov = min(cbPad, cbTex);

    if (cbTov > 0)
    {
        memcpy(pXspCtx->_pb4 + uiBlockLen - cbTov, pXspCtx->_pb2, cbTov);

        pXspCtx->_pb2 += cbTov;
        pXspCtx->_cb2 -= cbTov;
        cbTex         -= cbTov;
    }

    // This statement checks if we still have ports hanging out into the unencrypted
    // portion AND we have voice data. If so, the current layout means we'll have
    //
    //     data | padding | voice | extra ports | tail
    //
    // but we really need
    //
    //     data | padding | extra ports | voice | tail
    //
    // We accomplish this by moving the extra ports data to just before the beginning of
    // the voice data. Since the data is immediately followed by voice data, this means we
    // may end up stomping the data.
    //
    // This won't happen if we moved enough data bytes into the padding block earlier, but
    // if we didn't move enough, then we need to move a full block's worth of data to the
    // padding block.
    //
    // Yeesh.
    //
    if (cbTex > 0 && pXspCtx->_cb1 > 0)
    {

        // Do we need to move a full block's worth of encrypted bytes to the padding block
        // to make room for the extra ports that are moving in?

        if (cbTex > cbPad && pXspCtx->_cb3 > 0)
        {
            // So, remaining unencrypted headers are larger than current padding and there
            // remains encrypted data to be moved

            Assert((pXspCtx->_cb3 % uiBlockLen) == 0);

            // Notice this walks a block length before the _abPad member.

            pXspCtx->_pb4  = (pXspCtx->_cb4 == 0) ? pXspCtx->_abPad : pXspCtx->_pb4 - uiBlockLen;
            pXspCtx->_cb4 += uiBlockLen;
            pXspCtx->_cb3 -= uiBlockLen;

            memcpy(pXspCtx->_pb4, pXspCtx->_pb3 + pXspCtx->_cb3, uiBlockLen);
        }

        // move Tex bytes (ports) to the beginning of the voice data in pb1 since pb2
        // comes after pb1 and thus the ports would be after the voice data, which is
        // wrong.

        pXspCtx->_pb1 -= cbTex;
        pXspCtx->_cb1 += cbTex;

        memcpy(pXspCtx->_pb1, pXspCtx->_pb2, cbTex);

        pXspCtx->_pb2 += cbTex;
        pXspCtx->_cb2 -= cbTex;
    }

    if (pXspCtx->_cb3 > 0 || pXspCtx->_cb4 > 0)
    {
        SgCalcIvAtSeq(KEYMATERIAL(pSpiInfo, _abIvXmit), dwSeq, pXspCtx->_abIv);
        if (uiBlockLen == 16)
        {
            SgCalcIvAtSeq(KEYMATERIAL(pSpiInfo, _abIvXmit) + 8, dwSeq, pXspCtx->_abIv + 8);
        }
    }

    // Align the first SHA buffer to a multiple of four bytes by pushing any excess
    // to the beginning of the second SHA buffer.

    cbPad = pXspCtx->_cb1 % 4;

    if (cbPad > 0)
    {
        pXspCtx->_pb2 -= cbPad;
        pXspCtx->_cb2 += cbPad;
        pXspCtx->_cb1 -= cbPad;
        memcpy(pXspCtx->_pb2, pXspCtx->_pb1 + pXspCtx->_cb1, cbPad);
    }


    // Align the second SHA buffer by rounding up.  This will consume some of the
    // zero DWORD added to the tail.

    pXspCtx->_cb2               = ROUNDUP4(pXspCtx->_cb2);

    pXspHdr->_ipportSrc         = ipportsrc;
    pXspHdr->_ipportDst         = pSpiInfo->_ipportI;
    pXspHdr->_dwSpiAndFlags     = pSpiInfo->_dwSpiXmit;
    pXspHdr->_bFlags            = bXspFlags;

    pXspTail->_wSeqLo           = LOWORD(dwSeq);
    pXspTail->_wSeqHi           = HIWORD(dwSeq);
    pXspTail->_dwSpiAndFlags    = pXspHdr->_dwSpiAndFlags;
    pXspTail->_dwZero           = 0;

    DWORD cbPadXsp = XSP_DECODE_PADDING(bXspFlags);
    TraceSz(XmitXsp, "%s: [UDP %d:%d][XSP %08lX][Dat %d; Pad %d; Ov %d; Ex %d; Vo %d; Vx %d][XSPT #%d]",
              ppkt->Str(), NTOHS(pXspHdr->_ipportDst), NTOHS(pXspHdr->_ipportSrc),
              pXspHdr->_dwSpiAndFlags, pXspCtx->_cb3 + pXspCtx->_cb4 - cbPadXsp,
              cbPadXsp, cbTov, cbTex + cbTov,
              (pXspCtx->_cb1 + cbPad) > 0 ? (pXspCtx->_cb1 + cbPad - cbTex) : 0,
              ((bXspFlags & XSP_TYPE_MASK) >= XSP_TYPE_VDP_0 && (bXspFlags & XSP_TYPE_MASK) <= XSP_TYPE_VDP_2),
              dwSeq);

    // Send the packet to the crypto card to be encoded

    SgOffloadEncodePacket(ppkt);

    if (!ppkt->_fOffloadSuccess)
    {
        TraceSz(RecvDiscard, "%s #%d: SgOffloadEncodePacket failed", ppkt->Str(), ppkt->_dwSeq);
        goto complete;
    }

    SgPerfdataInc(XspXmit, 1);

    // Now make pIpHdr refer to the packet we are sending, not the one we just received
    pIpHdr             = &pXspCtx->_IpHdr;

    // Adjust the second SHA buffer to include the entire CXspTail

    pXspCtx->_cb2      = ((BYTE *)pXspTail - pXspCtx->_pb2) + sizeof(CXspTail);

    pEnetHdr->_eaDst   = pSpiInfo->_eaI;
    pEnetHdr->_eaSrc   = pTransInfoXmit->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS((WORD)(sizeof(CIpHdr) + sizeof(CXspHdr) + pXspCtx->_cb1 + pXspCtx->_cb2 + pXspCtx->_cb3 + pXspCtx->_cb4));
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_UDP;
    pIpHdr->_ipaSrc    = pTransInfoXmit->_ipa;
    pIpHdr->_ipaDst    = pSpiInfo->_ipaI;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    SgSpiInfoDetach(ppkt);
    pSpiInfo = NULL;

    SgSetUdpHdrChecksum(pIpHdr, pXspHdr, sizeof(CXspHdr),
                        pXspCtx->_pb3, pXspCtx->_cb3,
                        pXspCtx->_pb4, pXspCtx->_cb4,
                        pXspCtx->_pb1, pXspCtx->_cb1,
                        pXspCtx->_pb2, pXspCtx->_cb2);

    // Fill in the pointers to the various packet buffers for reassembly

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)pEnetHdr;
    *pcb++ = sizeof(CEnetHdr) + sizeof(CIpHdr) + sizeof(CXspHdr);

    if (pXspCtx->_cb3 > 0)
    {
        *ppb++ = pXspCtx->_pb3;
        *pcb++ = pXspCtx->_cb3;
    }

    if (pXspCtx->_cb4 > 0)
    {
        *ppb++ = pXspCtx->_pb4;
        *pcb++ = pXspCtx->_cb4;
    }

    if (pXspCtx->_cb1 > 0)
    {
        *ppb++ = pXspCtx->_pb1;
        *pcb++ = pXspCtx->_cb1;
    }

    if (pXspCtx->_cb2 > 0)
    {
        *ppb++ = pXspCtx->_pb2;
        *pcb++ = pXspCtx->_cb2;
    }

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitIXmit)
        goto complete;
#endif

#ifdef SG_FEATURE_ARP
    if(fArp)
    {
        // Fix _pEnetHdr for SgXmitWithArp
        ppkt->_pEnetHdr = pEnetHdr;

        SgArpInfoLock();

        CArpInfo * pArpInfo = SgArpInfoInsert(pTransInfoXmit, pIpHdr->_ipaDst, TRUE);

        if (pArpInfo == NULL)
        {
            TraceSz(Warning, "SgIcmpXmit - Out of memory allocating CArpInfo");

            SgArpInfoUnlock();
            goto complete;
        }

        // SgXmitWithArp will release the ARP lock
        SgXmitWithArp(ppkt, pArpInfo);
    }
    else
#endif
    {
        SgXmit(ppkt);
    }

    return;

complete:
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgZXmitSgMsgRep
// ---------------------------------------------------------------------------------------

void SgZXmitSgMsgRep(CPacket * ppkt, CSgMsgHdr * pSgMsgHdr, UINT cbSgMsg)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CTransInfo *    pTransInfoRecv  = ppkt->_pTransInfoRecv;
    CEnetHdr *      pEnetHdr        = ppkt->_pEnetHdr;
    CIpHdr *        pIpHdr          = ppkt->_pIpHdr;
    CUdpHdr *       pUdpHdr         = ppkt->_pUdpHdr;
    CIpAddr         ipaDstT         = pIpHdr->_ipaDst;
    CIpPort         ipportDstT      = pUdpHdr->_ipportDst;

    pEnetHdr->_eaDst   = pEnetHdr->_eaSrc;
    pEnetHdr->_eaSrc   = pTransInfoRecv->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS((WORD)(sizeof(CIpHdr) + sizeof(CUdpHdr) + cbSgMsg));
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_UDP;
    pIpHdr->_ipaDst    = pIpHdr->_ipaSrc;
    pIpHdr->_ipaSrc    = ipaDstT;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pUdpHdr->_ipportDst = pUdpHdr->_ipportSrc;
    pUdpHdr->_ipportSrc = ipportDstT;
    pUdpHdr->_wLen      = HTONS(sizeof(CUdpHdr) + cbSgMsg);

    SgSetUdpHdrChecksum(pIpHdr, pUdpHdr, sizeof(CUdpHdr), (BYTE *)pSgMsgHdr, cbSgMsg, NULL, 0, NULL, 0, NULL, 0);

    // Fill in the pointers to the various packet buffers for reassembly

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)pEnetHdr;
    *pcb++ = sizeof(CEnetHdr);
    *ppb++ = (BYTE *)pIpHdr;
    *pcb++ = sizeof(CIpHdr);
    *ppb++ = (BYTE *)pUdpHdr;
    *pcb++ = sizeof(CUdpHdr);
    *ppb++ = (BYTE *)pSgMsgHdr;
    *pcb++ = cbSgMsg;

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

    ppkt->_pTransInfoXmit = ppkt->_pTransInfoRecv;

    if (Tag(SpiFlow))
    {
        CTransInfo * pTransInfoXmit = ppkt->_pTransInfoXmit;

        TraceSz(SpiFlow, "#%d %08lX SGMSG >> %c%d [%s:%d %s:%d] %04X/%s (+%d)",
                  ppkt->_dwPktNum, 0,
                  pTransInfoXmit ? (char)pTransInfoXmit->_dwType : 'L', pTransInfoXmit->_iTransInfo,
                  pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                  pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
                  pSgMsgHdr->_wType, SgMsgStr(pSgMsgHdr->_wType), cbSgMsg - sizeof(CSgMsgHdr));

        SgHexDumpSpiFlow(ppkt->_dwPktNum, 0, (BYTE *)(pSgMsgHdr + 1), cbSgMsg - sizeof(CSgMsgHdr), NULL, 0, NULL, 0);
    }

    SgXmit(ppkt);
    return;
}

// ---------------------------------------------------------------------------------------
// SgZXmitSgMsgForward
// ---------------------------------------------------------------------------------------

void SgZXmitSgMsgForward(CPacket * ppkt, CTransInfo * pTransInfoXmit, SGADDR * psgaddr, void * pvMsg, UINT cbMsg)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CEnetHdr *              pEnetHdr            = ppkt->_pEnetHdr = (CEnetHdr *)ppkt->_abCtx;
    CIpHdr *                pIpHdr              = ppkt->_pIpHdr   = (CIpHdr *)(pEnetHdr + 1);
    CUdpHdr *               pUdpHdr             = ppkt->_pUdpHdr  = (CUdpHdr *)(pIpHdr + 1);
    CSgMsgXbToXbForward *   pSgMsgXbToXbForward = (CSgMsgXbToXbForward *)(pUdpHdr + 1);

    pEnetHdr->_eaSrc   = pTransInfoXmit->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS((WORD)(sizeof(CIpHdr) + sizeof(CUdpHdr) + sizeof(CSgMsgXbToXbForward) + cbMsg));
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_UDP;
    pIpHdr->_ipaDst    = psgaddr->inaSg;
    pIpHdr->_ipaSrc    = pTransInfoXmit->_ipa;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pUdpHdr->_ipportDst = 0xFFFF;
    pUdpHdr->_ipportSrc = 0xFFFF;
    pUdpHdr->_wLen      = HTONS((WORD)(sizeof(CUdpHdr) + sizeof(CSgMsgXbToXbForward) + cbMsg));

    pSgMsgXbToXbForward->_wType  = SGMSG_TYPE_XBTOXB_FORWARD;
    pSgMsgXbToXbForward->_cbEnt  = sizeof(CSgMsgXbToXbForward) + cbMsg;
    pSgMsgXbToXbForward->_sgaddr = *psgaddr;

    SgSetUdpHdrChecksum(pIpHdr, pUdpHdr, sizeof(CUdpHdr), (BYTE *)pSgMsgXbToXbForward,
                        sizeof(CSgMsgXbToXbForward), (BYTE *)pvMsg, cbMsg, NULL, 0, NULL, 0);

    // Fill in the pointers to the various packet buffers for reassembly

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)pEnetHdr;
    *pcb++ = sizeof(CEnetHdr) + sizeof(CIpHdr) + sizeof(CUdpHdr) + sizeof(CSgMsgXbToXbForward);

    if (cbMsg > 0)
    {
        *ppb++ = (BYTE *)pvMsg;
        *pcb++ = cbMsg;
    }

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

    ppkt->_pTransInfoXmit = pTransInfoXmit;

    // Do ARP lookup and send the packet

#ifdef SG_FEATURE_ARP

    SgArpInfoLock();

    CArpInfo * pArpInfo = SgArpInfoInsert(pTransInfoXmit, pIpHdr->_ipaDst, TRUE);

    if (pArpInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: SgZXmitSgMsgForward: Out of memory allocating CArpInfo", ppkt->Str());

        SgArpInfoUnlock();
        goto complete;
    }

    // SgXmitWithArp will release the ARP lock

    SgXmitWithArp(ppkt, pArpInfo);

#else // !SG_FEATURE_ARP

    pEnetHdr->_eaDst.SetZero();

    SgXmit(ppkt);

#endif // SG_FEATURE_ARP

    return;

#ifdef SG_FEATURE_ARP
complete:
#endif
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgZXmitSgMsgForward2
// ---------------------------------------------------------------------------------------

void SgZXmitSgMsgForward2(
    CPacket*        ppkt,
    CTransInfo*     pTransInfoXmit,
    SGADDR*         psgaSender,
    SGADDR*         psgaTarget,
    void*           pvMsg,
    UINT            cbMsg)
{
    Assert(ppkt->_pSpiInfo == NULL);

    CEnetHdr *              pEnetHdr            = ppkt->_pEnetHdr = (CEnetHdr *)ppkt->_abCtx;
    CIpHdr *                pIpHdr              = ppkt->_pIpHdr   = (CIpHdr *)(pEnetHdr + 1);
    CUdpHdr *               pUdpHdr             = ppkt->_pUdpHdr  = (CUdpHdr *)(pIpHdr + 1);
    CSgMsgXbToXbForward2 *  pSgMsgXbToXbForward2 = (CSgMsgXbToXbForward2 *)(pUdpHdr + 1);

    pEnetHdr->_eaSrc   = pTransInfoXmit->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS((WORD)(sizeof(CIpHdr) + sizeof(CUdpHdr) + sizeof(CSgMsgXbToXbForward2) + cbMsg));
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_UDP;
    pIpHdr->_ipaDst    = psgaTarget->inaSg;
    pIpHdr->_ipaSrc    = pTransInfoXmit->_ipa;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pUdpHdr->_ipportDst = 0xFFFF;
    pUdpHdr->_ipportSrc = 0xFFFF;
    pUdpHdr->_wLen      = HTONS((WORD)(sizeof(CUdpHdr) + sizeof(CSgMsgXbToXbForward2) + cbMsg));

    pSgMsgXbToXbForward2->_wType  = SGMSG_TYPE_XBTOXB_FORWARD2;
    pSgMsgXbToXbForward2->_cbEnt  = sizeof(CSgMsgXbToXbForward2) + cbMsg;
    pSgMsgXbToXbForward2->_sgaSender = *psgaSender;
    pSgMsgXbToXbForward2->_sgaTarget = *psgaTarget;

    SgSetUdpHdrChecksum(pIpHdr, pUdpHdr, sizeof(CUdpHdr), (BYTE *)pSgMsgXbToXbForward2,
                        sizeof(CSgMsgXbToXbForward2), (BYTE *)pvMsg, cbMsg, NULL, 0, NULL, 0);

    // Fill in the pointers to the various packet buffers for reassembly

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)pEnetHdr;
    *pcb++ = sizeof(CEnetHdr) + sizeof(CIpHdr) + sizeof(CUdpHdr) + sizeof(CSgMsgXbToXbForward2);

    if (cbMsg > 0)
    {
        *ppb++ = (BYTE *)pvMsg;
        *pcb++ = cbMsg;
    }

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

    ppkt->_pTransInfoXmit = pTransInfoXmit;

    // Do ARP lookup and send the packet

#ifdef SG_FEATURE_ARP

    SgArpInfoLock();

    CArpInfo * pArpInfo = SgArpInfoInsert(pTransInfoXmit, pIpHdr->_ipaDst, TRUE);

    if (pArpInfo == NULL)
    {
        TraceSz(RecvDiscard, "%s: SgZXmitSgMsgForward2: Out of memory allocating CArpInfo", ppkt->Str());

        SgArpInfoUnlock();
        goto complete;
    }

    // SgXmitWithArp will release the ARP lock

    SgXmitWithArp(ppkt, pArpInfo);

#else // !SG_FEATURE_ARP

    pEnetHdr->_eaDst.SetZero();

    SgXmit(ppkt);

#endif // SG_FEATURE_ARP

    return;

#ifdef SG_FEATURE_ARP
complete:
#endif
    ppkt->Complete();
    return;
}

// ---------------------------------------------------------------------------------------
// SgXmitWithArp
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_ARP

void SgXmitWithArp(CPacket * ppkt, CArpInfo * pArpInfo)
{
    Assert(ppkt->_pSpiInfo == NULL);

    // Note: this function's caller acquires the ARP lock

    CEnetHdr * pEnetHdr = ppkt->_pEnetHdr;

#ifdef SG_FEATURE_INSECURE
    if (g_fInhibitZXmit && ppkt->_pTransInfoXmit->_dwType == TRANSTYPE_DMZ)
        goto complete;
#endif

    if (pArpInfo->_wState != ARP_STATE_GOOD)
    {
        if (pArpInfo->_wState == ARP_STATE_BAD)
        {
            TraceSz(RecvDiscard, "%s: SgXmitWithArp: %s is unreachable", ppkt->Str(), pArpInfo->_ipa.Str());
            goto complete;
        }

        pArpInfo->_pqWait.InsertTail(ppkt);

        if (pArpInfo->_wState == ARP_STATE_IDLE)
        {
            // SgArpInfoXmit will release the ARP lock

            SgArpInfoXmit(pArpInfo);
        }
        else
        {
            SgArpInfoUnlock();
        }

        return;
    }

    pEnetHdr->_eaDst = pArpInfo->_ea;

    SgArpInfoUnlock();

    SgXmit(ppkt);

    return;

complete:
    SgArpInfoUnlock();

    ppkt->Complete();
    return;
}

#endif // SG_FEATURE_ARP

// ---------------------------------------------------------------------------------------
// SgZXmitRst
//
// This function is called when a packet arrives from the datacenter that cannot be mapped
// to a client.  This could be because the client never existed, has disconnected, is in
// the middle of key exchange, or the port mapping can't be found.  To clean up state more
// quickly, we send back a RST to the server when an errant TCP packet is received.
// ---------------------------------------------------------------------------------------

void SgZXmitRst(CPacket * ppkt)
{
    CIpHdr *    pIpHdr      = ppkt->_pIpHdr;
    CTcpHdr *   pTcpHdr     = ppkt->_pTcpHdr;
    CIpAddr     ipaDstT     = pIpHdr->_ipaDst;
    CIpPort     ipportDstT  = pTcpHdr->_ipportDst;

    if (pIpHdr->_bProtocol != IPPROTOCOL_TCP)
        goto complete;

    SgSpiInfoDetach(ppkt);

    CTransInfo *    pTransInfoXmit  = ppkt->_pTransInfoXmit = ppkt->_pTransInfoRecv;
    CEnetHdr *      pEnetHdr        = ppkt->_pEnetHdr;
    UINT            cb              = ppkt->_cb;
    DWORD           dwAckNum        = 0;
    DWORD           dwSeqNum        = 0;
    BYTE            bFlags          = TCP_RST;

    if ((pTcpHdr->_info._bFlags & TCP_RST)  != 0)
    {
        // Don't send a RST segment in response to a RST segment

        goto complete;
    }

    if (pTcpHdr->_info._bFlags & TCP_ACK)
    {
        dwSeqNum = pTcpHdr->_info._dwAckNum;
    }
    else
    {
        dwAckNum  = NTOHL(pTcpHdr->_info._dwSeqNum) + (cb - pTcpHdr->_info.GetHdrLen());
        dwAckNum += !!(pTcpHdr->_info._bFlags & TCP_SYN);
        dwAckNum += !!(pTcpHdr->_info._bFlags & TCP_FIN);
        dwAckNum  = HTONL(dwAckNum);
        bFlags   |= TCP_ACK;
    }

    pEnetHdr->_eaDst   = pEnetHdr->_eaSrc;
    pEnetHdr->_eaSrc   = pTransInfoXmit->_ea;
    pEnetHdr->_wType   = ENET_TYPE_IP;

    pIpHdr->_bVerHdr   = 0x45;
    pIpHdr->_bTos      = (BYTE) g_iIpHdrTos;
    pIpHdr->_wLen      = HTONS(sizeof(CIpHdr) + sizeof(CTcpHdr));
    pIpHdr->_wId       = 0;
    pIpHdr->_wFragOff  = 0;
    pIpHdr->_bTtl      = (BYTE) g_iIpHdrTtl;
    pIpHdr->_bProtocol = IPPROTOCOL_TCP;
    pIpHdr->_ipaDst    = pIpHdr->_ipaSrc;
    pIpHdr->_ipaSrc    = ipaDstT;
    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    pTcpHdr->_ipportDst       = pTcpHdr->_ipportSrc;
    pTcpHdr->_ipportSrc       = ipportDstT;
    pTcpHdr->_info._dwSeqNum  = dwSeqNum;
    pTcpHdr->_info._dwAckNum  = dwAckNum;
    pTcpHdr->_info._bFlags    = bFlags;
    pTcpHdr->_info._wWindow   = 0;
    pTcpHdr->_wUrgent         = 0;
    pTcpHdr->_wChecksum       = 0;
    pTcpHdr->_info.SetHdrLen(sizeof(CTcpHdr));

    SgSetTcpHdrChecksum(pIpHdr, pTcpHdr, sizeof(CTcpHdr), NULL, 0);

    TraceSz(SpiFlow, "#%d %08lX TCP >> %c%d [%s:%d %s:%d] %c%c%c%c%c%c (+%d)",
              ppkt->_dwPktNum, 0, pTransInfoXmit->_dwType, pTransInfoXmit->_iTransInfo,
              pIpHdr->_ipaSrc.Str(), NTOHS(pTcpHdr->_ipportSrc),
              pIpHdr->_ipaDst.Str(), NTOHS(pTcpHdr->_ipportDst),
              pTcpHdr->_info._bFlags & TCP_FIN ? 'F' : '-', pTcpHdr->_info._bFlags & TCP_SYN ? 'S' : '-',
              pTcpHdr->_info._bFlags & TCP_RST ? 'R' : '-', pTcpHdr->_info._bFlags & TCP_PSH ? 'P' : '-',
              pTcpHdr->_info._bFlags & TCP_ACK ? 'A' : '-', pTcpHdr->_info._bFlags & TCP_URG ? 'U' : '-',
              0);

    // Fill in the pointers to the various packet buffers for reassembly

    BYTE ** ppb = ppkt->_apb;
    UINT *  pcb = ppkt->_acb;

    *ppb++ = (BYTE *)pEnetHdr;
    *pcb++ = sizeof(CEnetHdr);
    *ppb++ = (BYTE *)pIpHdr;
    *pcb++ = sizeof(CIpHdr);
    *ppb++ = (BYTE *)pTcpHdr;
    *pcb++ = sizeof(CTcpHdr);

    ppkt->_cpb = (DWORD)(ppb - ppkt->_apb);
    Assert(ppkt->_cpb <= dimensionof(ppkt->_apb));

    SgXmit(ppkt);
    return;

complete:
    ppkt->Complete();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsvcnot.cpp ===
// ---------------------------------------------------------------------------------------
// sgsvcnot.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ---------------------------------------------------------------------------------------

#include "sg.h"


// ---------------------------------------------------------------------------------------
// Forward Declarations
// ---------------------------------------------------------------------------------------

BOOL SgServiceNotifySendHttp( DWORD dwIpNet, WORD wPortNet, DWORD dwServiceId, const char* pszUrl, const BYTE* pb, DWORD cb );
void SgServiceNotifySendQueued( BOOL fForce );
void SgServiceNotifySgDelete();

#ifdef SG_FEATURE_XMGMT
void
SgServiceNotifySendHealthHttp(
    DWORD dwRequestId,
    CXomControlResponseInterface *pResponseInterface,
    DWORD dwIpNet,
    WORD  wPortNet,
    DWORD dwServiceId,
    const char *pszUrl
    );
#endif


// ---------------------------------------------------------------------------------------
// Structures
// ---------------------------------------------------------------------------------------

struct CNotifyServerInfo
{
    CNotifyServerInfo* _pNext;

    DWORD _dwVersion;                         // Used to know when to remove servers
    DWORD _dwIp;                              // The IP address to reach this server, in network byte order
    WORD  _wPort;                             // The port to reach this server, in network byte order
    WORD  _wHealthPort;                       // The port the health check is on, in network byte order
    DWORD _dwServiceId;                       // The service ID to be notified
    char  _szUrl[ MAX_NOTIFY_URL_LEN ];       // The URL to use to notify the service
    char  _szHealthUrl[ MAX_NOTIFY_URL_LEN ]; // The URL to use to get the healthcheck 
    char  _szDnsName[ MAX_DNSNAME_LEN ];      // The server name used to resolve to an IP for processing
};

// ---------------------------------------------------------------------------------------
// CNotification
//
// Encapsulates the information and functionality for a notification type. There are 
// currently only 3 notification types. This class includes an incoming queuing mechanism, 
// an outgoing batch buffer, and the ability to actually send the queued notifications 
// when it is time.
// ---------------------------------------------------------------------------------------
class CNotification
{

public:

#define NOTI_TYPE_UPDATE      0
#define NOTI_TYPE_TITLECHANGE 1
#define NOTI_TYPE_DELETE      2
#define NOTI_TYPE_USERCHANGE  3
#define NOTI_TYPE_SPIUPDATE   4
#define NOTI_TYPE_MAX         5

    void            Init(DWORD dwNotiType);
    void            Term();
    BOOL            Config(
                        DWORD dwBatchCount, 
                        DWORD dwQueueCount, 
                        DWORD dwBatchIntervalInSeconds,
                        CSgSvcConfig::Server *pServerList, 
                        DWORD cServers
                    );

    BOOL            RefreshDns();
    BOOL            SendQueued(BOOL fForce);

#ifdef SG_FEATURE_XMGMT
    void            SendHealth(DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
#endif

    // Accessors, helpers
    const LPCSTR    TypeStr();
    CSgMsgQueue*    Queue()   { return &_MsgQueue; }

    static void     IncrementVersion() { s_dwCurrentVersion++; }


private:
    
    DWORD                   _dwType;
    DWORD                   _dwBatchCount;
    DWORD                   _dwQueueCount;
    DWORD                   _dwMsgSize;
    DWORD                   _dwBatchSize;
    DWORD                   _dwBatchInterval;

    DWORD                   _dwLastSendTime;
    CSgMsgQueue             _MsgQueue;

    CNotifyServerInfo       _Servers;
    CReaderWriterLock3      _ServersLock;
    
    BYTE *                  _BatchBuffer;
    volatile LONG           _lSendInProgress;

    static DWORD            s_dwCurrentVersion;


};


// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

// Http
const char g_szHttpPostHeader[] = 
"POST %s HTTP/1.0\r\nSG-UpdateSeqNum: %I64u\r\nUser-Agent: %x/1.0.5849\r\nContent-Type: xon/%x\r\nContent-Length: %u\r\n\r\n";
#define MAKEPOSTBUFFER( buffer, buflen, url, seqnum, serviceid, length ) \
    sprintf_s( (char*) buffer, buflen, g_szHttpPostHeader, url, seqnum, serviceid, serviceid, length )

const char g_szHttpGetHeader[] = 
    "GET %s HTTP/1.0\r\nUser-Agent: %x/1.0.5849\r\n\r\n";
#define MAKEGETBUFFER( buffer, buflen, url ) \
    sprintf_s( (char*) buffer, buflen, g_szHttpGetHeader, url )

// SG Internet Interfaces
DWORD g_cInetInterfaces = 0;
DWORD g_rgdwInetInterfaces[ MAX_NETWORK_INTERFACES ];

CNotification g_UpdateNotification;
CNotification g_TitleChangeNotification;
CNotification g_DeleteNotification;
CNotification g_UserChangeNotification;
CNotification g_SpiUpdateNotification;

DWORD CNotification::s_dwCurrentVersion = 1;

// Timer stuff
CServerTimer                g_timerNotifications;
SERVER_TIMER_APPOINTMENT    g_timerNotificationsAppt;
BOOL                        g_timerNotificationsStarted;

void
CNotification::Init(DWORD dwNotiType)
{
    _dwType = dwNotiType;
    _dwBatchCount = 0;
    _dwQueueCount = 0;
    _dwMsgSize = 0;
    _dwBatchSize = 0;
    _dwBatchInterval = 0;
    _lSendInProgress = 0;

    // GetTickCount()isn't ideal because it rolls over every 49 days, but using it
    // to time the duration of two events that occur less than 49 days apart is 
    // acceptable.  The subtraction across a rollover will also work.
    _dwLastSendTime = GetTickCount();
    
    _Servers._pNext = NULL;
    _BatchBuffer = NULL;
    _MsgQueue.Init();

    switch (_dwType)
    {
    case NOTI_TYPE_UPDATE:
        _dwMsgSize = sizeof(CSgMsgNotifyCliUpdate);
        break;
    case NOTI_TYPE_TITLECHANGE:
        _dwMsgSize = sizeof(CSgMsgNotifyCliTitleChange);
        break;
    case NOTI_TYPE_DELETE:
        _dwMsgSize = sizeof(CSgMsgNotifyCliDelete);
        break;
    case NOTI_TYPE_USERCHANGE:
        _dwMsgSize = sizeof(CSgMsgNotifyCliUserChange);
        break;
    case NOTI_TYPE_SPIUPDATE:
        _dwMsgSize = sizeof(CSgMsgNotifySpiUpdate);
        break;
    default:
        _dwMsgSize = 0;
        break;
    }

}

BOOL
CNotification::Config(
    DWORD dwBatchCount, 
    DWORD dwQueueCount, 
    DWORD dwBatchIntervalInSeconds,
    CSgSvcConfig::Server *pServerList, 
    DWORD cServers)
{
    TraceSz(Config, "    Configuring %s notifications:", TypeStr());

    // dynamic config
    _dwQueueCount = dwQueueCount;
    _dwBatchInterval = dwBatchIntervalInSeconds * 1000;
    _MsgQueue.Config(_dwQueueCount);

    if (dwBatchCount != _dwBatchCount)
    {
        _ServersLock.WriteLock();
        if (NULL != _BatchBuffer)
        {
            free(_BatchBuffer);
        }

        _dwBatchCount = dwBatchCount;
        _dwBatchSize = _dwBatchCount * _dwMsgSize;
        
        _BatchBuffer = (BYTE*)malloc(_dwBatchSize);
        _ServersLock.WriteUnlock();

        if (NULL == _BatchBuffer)
        {
            SgEventSz(CODE_ERROR_12, "CNotification::Config() - out of memory allocating %d bytes for the %s notification batch buffer",
                       _dwBatchSize, TypeStr());
            return FALSE;
        }
    }

    TraceSz(Config, "      Configured batch interval to %d seconds", dwBatchIntervalInSeconds); 
    TraceSz(Config, "      Configured batch count to %d items", _dwBatchCount);
    TraceSz(Config, "      Configured batch size to %d bytes", _dwBatchSize);
    TraceSz(Config, "      Configured queue count to %d items", _dwQueueCount);

    // Clear perf counter values
    switch (_dwType)
    {
    case NOTI_TYPE_UPDATE:
        SgPerfdataSet(NotificationsUpdateQueue,      _MsgQueue.SlotsRemaining());
        break;
    case NOTI_TYPE_TITLECHANGE:
        SgPerfdataSet(NotificationsTitleChangeQueue, _MsgQueue.SlotsRemaining());
        break;
    case NOTI_TYPE_DELETE:
        SgPerfdataSet(NotificationsDeleteQueue,      _MsgQueue.SlotsRemaining());
        break;
    case NOTI_TYPE_USERCHANGE:
        SgPerfdataSet(NotificationsUserChangeQueue,  _MsgQueue.SlotsRemaining());
        break;
    case NOTI_TYPE_SPIUPDATE:
        SgPerfdataSet(NotificationsSpiUpdateQueue,   _MsgQueue.SlotsRemaining());
        break;
    }

    DWORD iServer;
    CNotifyServerInfo* pNotifyServerPrev;
    CNotifyServerInfo* pNotifyServer;

    // Add any new notification servers. No readlock (or write) is necessary here because 
    // config calls are guaranteed to be single-threaded, and the only thing that grabs a 
    // writelock is here, in the config call. We don't need to protect ourself from 
    // ourself.
    for( iServer = 0; iServer < cServers; iServer++ )
    {
        CSgSvcConfig::Server* pServer = pServerList + iServer;

        for( DWORD iServiceId = 0; iServiceId < pServer->_cServiceIds; iServiceId++ )
        {
            // Look for an existing matching entry
            pNotifyServer = _Servers._pNext;
            while( NULL != pNotifyServer )
            {
                if( pNotifyServer->_dwIp == htonl( pServer->_dwIp ) &&
                    pNotifyServer->_wPort == htons( pServer->_wPort ) &&
                    pNotifyServer->_wHealthPort == htons( pServer->_wHealthPort ) &&
                    pNotifyServer->_dwServiceId == pServer->_rgdwServiceIds[ iServiceId ] &&
                    0 == _strnicmp( pNotifyServer->_szUrl, pServer->_rgchUrl, sizeof( pNotifyServer->_szUrl ) - 1 ) &&
                    0 == _strnicmp( pNotifyServer->_szHealthUrl, pServer->_rgchHealthUrl, sizeof( pNotifyServer->_szHealthUrl ) - 1 ) &&
                    0 == _strnicmp( pNotifyServer->_szDnsName, pServer->_szDnsName, ARRAY_SIZE( pNotifyServer->_szDnsName ) - 1 ) )
                {
                    // We already have it
                    break;
                }

                pNotifyServer = pNotifyServer->_pNext;
            }
            if( NULL == pNotifyServer )
            {
                // Add it
                pNotifyServer = (CNotifyServerInfo*) malloc( sizeof( CNotifyServerInfo ) );
                if( NULL == pNotifyServer )
                {
                    SgEventSz(CODE_ERROR_12, "CNotification::Config() - out of memory allocating %d bytes for CNotifyServerInfo",
                              sizeof(CNotifyServerInfo));
                    return FALSE;
                }

                pNotifyServer->_pNext = _Servers._pNext;
                pNotifyServer->_dwIp = htonl( pServer->_dwIp );
                pNotifyServer->_wPort = htons( pServer->_wPort );
                pNotifyServer->_wHealthPort = htons( pServer->_wHealthPort );
                pNotifyServer->_dwServiceId = pServer->_rgdwServiceIds[ iServiceId ];
                strncpy( pNotifyServer->_szUrl, pServer->_rgchUrl, sizeof( pNotifyServer->_szUrl ) - 1 );
                pNotifyServer->_szUrl[ sizeof( pNotifyServer->_szUrl ) - 1 ] = 0;
                strncpy( pNotifyServer->_szHealthUrl, pServer->_rgchHealthUrl, sizeof( pNotifyServer->_szHealthUrl ) - 1 );
                pNotifyServer->_szHealthUrl[ sizeof( pNotifyServer->_szHealthUrl ) - 1 ] = 0;
                strncpy( pNotifyServer->_szDnsName, pServer->_szDnsName, ARRAY_SIZE( pNotifyServer->_szDnsName ) - 1 );
                pNotifyServer->_szDnsName[ ARRAY_SIZE( pNotifyServer->_szDnsName ) - 1 ] = 0;

                _Servers._pNext = pNotifyServer;

                TraceSz(
                    Config, 
                    "    Added new %s destination http://%s%s",
                    TypeStr(),
                    CStrUtil().FormatIpPortN(pNotifyServer->_dwIp, pNotifyServer->_wPort),
                    pNotifyServer->_szUrl
                    );
            }

            // Whether new or old, update the version stamp
            pNotifyServer->_dwVersion = s_dwCurrentVersion;
        }
    }

    // Remove stale servers. Get count first to save locking.
    DWORD staleCount = 0;
    pNotifyServer = _Servers._pNext;
    while( NULL != pNotifyServer )
    {
        if( s_dwCurrentVersion != pNotifyServer->_dwVersion )
        {
            staleCount++;
        }
        else
        {
            if (pNotifyServer->_szDnsName[0] == '\0')
            {
                TraceSz(Config, "    Send %s notification to http://%s%s",
                         TypeStr(),
                         CStrUtil().FormatIpPortN(pNotifyServer->_dwIp, pNotifyServer->_wPort),
                         pNotifyServer->_szUrl);
            }
            else
            {
                TraceSz(Config, "    Send %s notification to http://%s:%d%s",
                         TypeStr(),
                         pNotifyServer->_szDnsName,
                         ntohs(pNotifyServer->_wPort),
                         pNotifyServer->_szUrl);
            }
        }
        pNotifyServer = pNotifyServer->_pNext;
    }

    if (staleCount > 0)
    {
        // We're changing the list, and freeing memory... writelock FTW!
        _ServersLock.WriteLock();
        pNotifyServerPrev = &_Servers;
        pNotifyServer = _Servers._pNext;
        while( NULL != pNotifyServer )
        {
            if( s_dwCurrentVersion != pNotifyServer->_dwVersion )
            {
//                 TraceSz(Config, "    Removed old %s destination http://%s%s",
//                          TypeStr(),
//                          CStrUtil().FormatIpPortN(pNotifyServer->_dwIp, pNotifyServer->_wPort),
//                          pNotifyServer->_szUrl);

                pNotifyServerPrev->_pNext = pNotifyServer->_pNext;
                free( pNotifyServer );
            }
            else
            {
                pNotifyServerPrev = pNotifyServer;
            }
            pNotifyServer = pNotifyServerPrev->_pNext;
        }
        _ServersLock.WriteUnlock();
    }

    return TRUE;
}

BOOL
CNotification::RefreshDns()
{
    BOOL fOk = TRUE;

    _ServersLock.ReadLock();

    CNotifyServerInfo* pNotifyServer = _Servers._pNext;
    while( NULL != pNotifyServer )
    {
        if (pNotifyServer->_szDnsName[0] != '\0')
        {
            CIpAddr ipa;
            BOOL fSuccess = SgDnsResolveToIP(pNotifyServer->_szDnsName, ipa);

            if (fSuccess && (pNotifyServer->_dwIp != (DWORD)ipa))
            {
                TraceSz(DnsResolve, "Updating IP entry for %s notification http://%s:%d%s : %s -> %s",
                    TypeStr(),
                    pNotifyServer->_szDnsName,
                    ntohs(pNotifyServer->_wPort),
                    pNotifyServer->_szUrl,
                    CStrUtil().FormatIpN(pNotifyServer->_dwIp),
                    ipa.Str());

                pNotifyServer->_dwIp = (DWORD)ipa;
            }
            fOk &= fSuccess;
        }

        pNotifyServer = pNotifyServer->_pNext;
    }

    _ServersLock.ReadUnlock();

    return fOk;
}

void
CNotification::Term()
{
    _ServersLock.WriteLock();

    // Free the update server list
    CNotifyServerInfo *pNotifyServer = _Servers._pNext;
    while( NULL != pNotifyServer )
    {
        CNotifyServerInfo* pVictim = pNotifyServer;
        pNotifyServer = pNotifyServer->_pNext;

        free( pVictim );
    }
    _Servers._pNext = NULL;

    // Free packets on the queue
    _MsgQueue.Term();

    // Free the batch buffer
    _dwBatchCount = 0;
    _dwBatchSize = 0;
    if (_BatchBuffer != NULL)
    {
        free(_BatchBuffer);
        _BatchBuffer = NULL;
    }
    
    _ServersLock.WriteUnlock();
}

// ---------------------------------------------------------------------------------------
// CNotification::SendQueued - sends a single batch of messages *if* the time is right, or 
// the batch is full, or you explicitly ask for it. Returns true if there is another full 
// batch remaining to be sent, or false if there is nothing left to do.
// ---------------------------------------------------------------------------------------
BOOL
CNotification::SendQueued(BOOL fForce)
{
    // quick check
    if (_MsgQueue.Count() == 0)
    {
        return FALSE;
    }

    DWORD dwNow = GetTickCount();

    if( fForce ||
        _MsgQueue.Count() >= _dwBatchCount || 
        dwNow - _dwLastSendTime > _dwBatchInterval )
    {
        // If already sending, don't.
        LONG lAlreadySending = InterlockedExchange(&_lSendInProgress, 1);
        if (lAlreadySending)
        {
            TraceSz(
                Notification, 
                "[abort] %s notification already in progress",
                TypeStr()
                );
            return FALSE;
        }

        _ServersLock.ReadLock();

        // Build buffer. Packet queue -> linear array. 
        DWORD dwBufferSize = _MsgQueue.DequeueMultiToBuffer(_BatchBuffer, _dwBatchSize);
        DWORD dwItemsDequeued = dwBufferSize / _dwMsgSize;
        Assert(dwItemsDequeued <= _dwBatchCount);

        if (dwItemsDequeued == 0)
        {
            // A re-config may have trashed our batch buffer, or maybe something else went 
            // wrong.
            _ServersLock.ReadUnlock();
            TraceSz(
                Notification, 
                "[abort] %s notification dequeued 0 items",
                TypeStr()
                );
            return FALSE;
        }

        // Remember the perf ctr
        switch (_dwType)
        {
        case NOTI_TYPE_UPDATE:
            SgPerfdataSet(NotificationsUpdateQueue, _MsgQueue.SlotsRemaining());
            SgPerfdataInc(NotificationsUpdateBatches, 1);
            break;
        case NOTI_TYPE_TITLECHANGE:
            SgPerfdataSet(NotificationsTitleChangeQueue, _MsgQueue.SlotsRemaining());
            SgPerfdataInc(NotificationsTitleChangeBatches, 1);
            break;
        case NOTI_TYPE_DELETE:
            SgPerfdataSet(NotificationsDeleteQueue, _MsgQueue.SlotsRemaining());
            SgPerfdataInc(NotificationsDeleteBatches, 1);
            break;
        case NOTI_TYPE_USERCHANGE:
            SgPerfdataSet(NotificationsUserChangeQueue, _MsgQueue.SlotsRemaining());
            SgPerfdataInc(NotificationsUserChangeBatches, 1);
            break;
        case NOTI_TYPE_SPIUPDATE:
            SgPerfdataSet(NotificationsSpiUpdateQueue, _MsgQueue.SlotsRemaining());
            SgPerfdataInc(NotificationsSpiUpdateBatches, 1);
            break;
        }

        TraceSz(
            Notification, 
            "[send] %d %s notifications about to be sent",
            dwItemsDequeued,
            TypeStr()
            );

        CNotifyServerInfo* pNotifyServer = _Servers._pNext;
        while( NULL != pNotifyServer )
        {
            CSmallStr endpoint;

            if (pNotifyServer->_szDnsName[0] == '\0')
            {
                endpoint = CStrUtil().FormatIpPortN(pNotifyServer->_dwIp, pNotifyServer->_wPort);
            }
            else
            {
                endpoint.Format("%s:%d", pNotifyServer->_szDnsName, ntohs(pNotifyServer->_wPort));
            }

            BOOL fOk = SgServiceNotifySendHttp( 
                pNotifyServer->_dwIp,
                pNotifyServer->_wPort,
                pNotifyServer->_dwServiceId,
                pNotifyServer->_szUrl,
                (const BYTE*) _BatchBuffer,
                dwBufferSize);

            // 1 retry for now. At least we'll hit a different server through the VIP, 
            // though it is still pretty ghetto. Better would be to retry indefinitely and 
            // use async sockets.
        
            if (!fOk)
            {
                TraceSz(
                    Notification, 
                    "[retry] %d %s notifications (%d bytes) http://%s%s",
                    dwItemsDequeued,
                    TypeStr(),
                    dwBufferSize,
                    endpoint.cstr(),
                    pNotifyServer->_szUrl
                    );

                SgEventSz(NOTIFICATION_RETRY,
                           "Failed to send %s notification (%d messages, %d bytes) to "
                           "http://%s%s. The previous error will have a detailed status code. "
                           "This batch will be retried 1 time.",
                           TypeStr(),
                           dwItemsDequeued,
                           dwBufferSize,
                           endpoint.cstr(),
                           pNotifyServer->_szUrl);

                fOk = SgServiceNotifySendHttp( 
                    pNotifyServer->_dwIp,
                    pNotifyServer->_wPort,
                    pNotifyServer->_dwServiceId,
                    pNotifyServer->_szUrl,
                    (const BYTE*) _BatchBuffer,
                    dwBufferSize);
            }

            if (!fOk)
            {
                TraceSz(
                    Notification, 
                    "[failed] %d %s notifications (%d bytes) http://%s%s",
                    dwItemsDequeued,
                    TypeStr(),
                    dwBufferSize,
                    endpoint.cstr(),
                    pNotifyServer->_szUrl
                    );

                SgEventSz(NOTIFICATION_FAILED,
                           "Failed to send %s notification (%d messages, %d bytes) to "
                           "http://%s%s. The previous error will have a detailed status code. "
                           "This batch of messages is being dropped.",
                           TypeStr(),
                           dwItemsDequeued,
                           dwBufferSize,
                           endpoint.cstr(),
                           pNotifyServer->_szUrl);

                switch (_dwType)
                {
                case NOTI_TYPE_UPDATE:
                    SgPerfdataInc(NotificationsUpdateDrop, dwItemsDequeued);
                    break;
                case NOTI_TYPE_TITLECHANGE:
                    SgPerfdataInc(NotificationsTitleChangeDrop, dwItemsDequeued);
                    break;
                case NOTI_TYPE_DELETE:
                    SgPerfdataInc(NotificationsDeleteDrop, dwItemsDequeued);
                    break;
                case NOTI_TYPE_USERCHANGE:
                    SgPerfdataInc(NotificationsUserChangeDrop, dwItemsDequeued);
                    break;
                case NOTI_TYPE_SPIUPDATE:
                    SgPerfdataInc(NotificationsSpiUpdateDrop, dwItemsDequeued);
                    break;
                }
            }
            else
            {
                TraceSz(
                    Notification, 
                    "[success] %d %s notifications (%d bytes) http://%s%s",
                    dwItemsDequeued,
                    TypeStr(),
                    dwBufferSize,
                    endpoint.cstr(),
                    pNotifyServer->_szUrl
                    );
            }

            pNotifyServer = pNotifyServer->_pNext;
            
        }
        _ServersLock.ReadUnlock();
        
        _dwLastSendTime = GetTickCount();

        // Done sending
        InterlockedExchange(&_lSendInProgress, 0);
    }

    return _MsgQueue.Count() >= _dwBatchCount;
}

#ifdef SG_FEATURE_XMGMT

void
CNotification::SendHealth(DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
    _ServersLock.ReadLock();
    CNotifyServerInfo* pNotifyServer = _Servers._pNext;
    while( NULL != pNotifyServer )
    {
        SgServiceNotifySendHealthHttp( 
            dwRequestId,
            pResponseInterface,
            pNotifyServer->_dwIp,
            pNotifyServer->_wHealthPort,
            pNotifyServer->_dwServiceId,
            pNotifyServer->_szHealthUrl
            );
        pNotifyServer = pNotifyServer->_pNext;
    }
    _ServersLock.ReadUnlock();
}

#endif

const LPCSTR
CNotification::TypeStr()
{
    switch (_dwType)
    {
    case NOTI_TYPE_UPDATE:
        return "Update";
    case NOTI_TYPE_TITLECHANGE:
        return "TitleChange";
    case NOTI_TYPE_DELETE:
        return "Delete";
    case NOTI_TYPE_USERCHANGE:
        return "UserChange";
    case NOTI_TYPE_SPIUPDATE:
        return "SpiUpdate";
    default:
        return "Unknown";
    }
}


// ---------------------------------------------------------------------------------------
// SgServiceNotifyInit - start up the notification layer
// ---------------------------------------------------------------------------------------

BOOL SgServiceNotifyInit()
{
    g_UpdateNotification.Init(NOTI_TYPE_UPDATE);
    g_TitleChangeNotification.Init(NOTI_TYPE_TITLECHANGE);
    g_DeleteNotification.Init(NOTI_TYPE_DELETE);
    g_UserChangeNotification.Init(NOTI_TYPE_USERCHANGE);
    g_SpiUpdateNotification.Init(NOTI_TYPE_SPIUPDATE);

    // Timer
    g_timerNotificationsStarted = FALSE;
    if (!g_timerNotifications.Init(false, CMemAlloc::Default()))
    {
        SgEventSz(INIT_ERROR, "Failed to initialize notification timer");
        return FALSE;
    }

    return TRUE;
}


// ---------------------------------------------------------------------------------------
// SgServiceNotifyTerm - shut down the notification layer
// ---------------------------------------------------------------------------------------

void SgServiceNotifyTerm()
{
    // Send out DeadSg messages
    SgServiceNotifySgDelete();

    // Send any remaining queued messages before we clear the server list
    SgEventSz(NOTIFICATION_TERM, 
              "Draining all notification queues. If the TCP connection is unreliable, "
              "this may take several minutes to complete. Be patient, watch the "
              "notification perf counters; it is important the SG delete notification "
              "gets sent.");
    SgServiceNotifySendQueued( TRUE );

    // Kill timer. It's graceful.
    g_timerNotifications.Term();
    g_timerNotificationsStarted = FALSE;

    g_UpdateNotification.Term();
    g_TitleChangeNotification.Term();
    g_DeleteNotification.Term();
    g_UserChangeNotification.Term();
    g_SpiUpdateNotification.Term();
}


// ---------------------------------------------------------------------------------------
// SgServiceNotifyHeartbeat - called periodically to do processing
// ---------------------------------------------------------------------------------------

void WINAPI SgServiceNotifyHeartbeat(VOID*)
{
    // Send any queued messages
    SgServiceNotifySendQueued( FALSE );

    // Reschedule timer
    if (!g_timerNotifications.CreateAppointment(
           SgServiceNotifyHeartbeat,
           NULL,
           100,
           &g_timerNotificationsAppt))
    {
        SgEventSz(NOTIFICATION_TIMER, "Failed to reschedule the timer.");
    }
        
}


// ---------------------------------------------------------------------------------------
// SgServiceNotifyRefreshDns - update server -> IP mappings in the notification servers.
// ---------------------------------------------------------------------------------------

BOOL SgServiceNotifyRefreshDns()
{
    BOOL fOk = TRUE;

    fOk = g_UpdateNotification.RefreshDns();
    fOk &= g_TitleChangeNotification.RefreshDns();
    fOk &= g_DeleteNotification.RefreshDns();
    fOk &= g_UserChangeNotification.RefreshDns();
    fOk &= g_SpiUpdateNotification.RefreshDns();

    return fOk;
}

// ---------------------------------------------------------------------------------------
// SgServiceNotifyConfig - add or remove servers to notify
// ---------------------------------------------------------------------------------------

BOOL SgServiceNotifyConfig( const CSgSvcConfig* pSgSvcConfig )
{
    CNotifyServerInfo* pNotifyServerPrev;
    CNotifyServerInfo* pNotifyServer;

    g_cInetInterfaces = pSgSvcConfig->_cInetInterfaces;
    memcpy( g_rgdwInetInterfaces, pSgSvcConfig->_rgdwInetInterfaces, sizeof( g_rgdwInetInterfaces ) );

    CNotification::IncrementVersion();

    // Config the notification types
    if (!g_UpdateNotification.Config(
            pSgSvcConfig->_dwNotifyUpdateBatchCount,
            pSgSvcConfig->_dwNotifyUpdateQueueCount,
            pSgSvcConfig->_dwNotifyUpdateBatchIntervalInSeconds,
            pSgSvcConfig->GetUpdateServerList(),
            pSgSvcConfig->_cNotifyUpdateServers))
    {
    }
    if (!g_TitleChangeNotification.Config(
            pSgSvcConfig->_dwNotifyTitleChangeBatchCount,
            pSgSvcConfig->_dwNotifyTitleChangeQueueCount,
            pSgSvcConfig->_dwNotifyTitleChangeBatchIntervalInSeconds,
            pSgSvcConfig->GetTitleChangeServerList(),
            pSgSvcConfig->_cNotifyTitleChangeServers))
    {
    }
    if (!g_DeleteNotification.Config(
            pSgSvcConfig->_dwNotifyDeleteBatchCount,
            pSgSvcConfig->_dwNotifyDeleteQueueCount,
            pSgSvcConfig->_dwNotifyDeleteBatchIntervalInSeconds,
            pSgSvcConfig->GetDeleteServerList(),
            pSgSvcConfig->_cNotifyDeleteServers))
    {
    }
    if (!g_UserChangeNotification.Config(
            pSgSvcConfig->_dwNotifyUserChangeBatchCount,
            pSgSvcConfig->_dwNotifyUserChangeQueueCount,
            pSgSvcConfig->_dwNotifyUserChangeBatchIntervalInSeconds,
            pSgSvcConfig->GetUserChangeServerList(),
            pSgSvcConfig->_cNotifyUserChangeServers)) 
    {
    }
    if (!g_SpiUpdateNotification.Config(
            pSgSvcConfig->_dwNotifySpiUpdateBatchCount,
            pSgSvcConfig->_dwNotifySpiUpdateQueueCount,
            pSgSvcConfig->_dwNotifySpiUpdateBatchIntervalInSeconds,
            pSgSvcConfig->GetSpiUpdateServerList(),
            pSgSvcConfig->_cNotifySpiUpdateServers)) 
    {
    }

    // Send out DeadSg messages the first time through
    static BOOL fDeadSgOnStartupDone = FALSE;
    if( !fDeadSgOnStartupDone )
    {
        SgServiceNotifySgDelete();
        fDeadSgOnStartupDone = TRUE;
    }

    // Start the notification sending timer the first time
    if (!g_timerNotificationsStarted)
    {
        g_timerNotificationsStarted = TRUE;
        if (!g_timerNotifications.CreateAppointment(
                SgServiceNotifyHeartbeat,
                NULL,
                100,
                &g_timerNotificationsAppt))
        {
            SgEventSz(NOTIFICATION_TIMER, "Failed to schedule the initial timer.");
            return FALSE;
        }
    }


    return TRUE;
}


// ---------------------------------------------------------------------------------------
// SgServiceNotifyCliUpdate - send client updates out to registered servers
// ---------------------------------------------------------------------------------------

void 
SgServiceNotifyCliUpdate( 
    const SGADDR*   psgaddr, 
          ULONGLONG qwUserId, 
          ULONGLONG qwXnkid, 
          DWORD     dwAuthFlags, 
          DWORD     dwState, 
          DWORD     dwTitleId, 
          WORD      cbTitleData, 
    const BYTE*     pbTitleData 
    )
{
    CSgMsgNotifyCliUpdate msg;
    CSgMsgNotifyCliUpdate* pMsg = &msg;

    pMsg->_wType = SGMSG_TYPE_NOTIFY_CLI_UPD;
    pMsg->_cbEnt = sizeof( *pMsg );
    pMsg->_sgaddr = *psgaddr;
    pMsg->_qwUserId = qwUserId;
    pMsg->_qwXnkid = qwXnkid;
    pMsg->_dwAuthFlags = dwAuthFlags;
    pMsg->_dwState = dwState;
    pMsg->_dwTitleId = dwTitleId;
    pMsg->_cbTitleData = min( sizeof( pMsg->_rgbTitleData ), cbTitleData );
    memcpy( pMsg->_rgbTitleData, pbTitleData, pMsg->_cbTitleData );

    if (!g_UpdateNotification.Queue()->Enqueue(pMsg))
    {
        SgPerfdataInterlockedInc(NotificationsUpdateDrop);

        TraceSz(
            Notification, 
            "%08lX FAILED to queue Update for machine 0x%016I64X, %d slots remaining",
            psgaddr->dwSpiSg,
            psgaddr->qwXboxID,
            g_UpdateNotification.Queue()->SlotsRemaining()
            );
    }
    else
    {
        SgPerfdataInterlockedInc(NotificationsUpdate);
        SgPerfdataSet(NotificationsUpdateQueue, g_UpdateNotification.Queue()->SlotsRemaining());

        TraceSz(
            Notification, 
            "%08lX Update queued [%d total] for machine 0x%016I64X",
            psgaddr->dwSpiSg,
            g_UpdateNotification.Queue()->Count(),
            psgaddr->qwXboxID
            );
    }
}


// ---------------------------------------------------------------------------------------
// SgServiceNotifyCliTitleChange - send client title changes out to registered servers
// ---------------------------------------------------------------------------------------

void 
SgServiceNotifyCliTitleChange( 
    const SGADDR* psgaddr, 
          DWORD   dwLastTitleId, 
          DWORD   dwTitleId 
    )
{
    CSgMsgNotifyCliTitleChange msg;
    CSgMsgNotifyCliTitleChange* pMsg = &msg;

    pMsg->_wType = SGMSG_TYPE_NOTIFY_CLI_TCHG;
    pMsg->_cbEnt = sizeof( *pMsg );
    pMsg->_sgaddr = *psgaddr;
    pMsg->_dwOldTitleId = dwLastTitleId;
    pMsg->_dwNewTitleId = dwTitleId;

    if (!g_TitleChangeNotification.Queue()->Enqueue(pMsg))
    {
        SgPerfdataInterlockedInc(NotificationsTitleChangeDrop);

        TraceSz(
            Notification, 
            "%08lX FAILED to queue TitleChange for machine 0x%016I64X, %d slots remaining",
            psgaddr->dwSpiSg,
            psgaddr->qwXboxID,
            g_TitleChangeNotification.Queue()->SlotsRemaining()
            );
    }
    else
    {
        SgPerfdataInterlockedInc(NotificationsTitleChange);
        SgPerfdataSet(NotificationsTitleChangeQueue, g_TitleChangeNotification.Queue()->SlotsRemaining());

        TraceSz(
            Notification, 
            "%08lX TitleChange queued [%d total] for machine 0x%016I64X",
            psgaddr->dwSpiSg,
            g_TitleChangeNotification.Queue()->Count(),
            psgaddr->qwXboxID
            );
    }
}

// ---------------------------------------------------------------------------------------
// SgServiceNotifyCliUserChange - send client user changes out to registered servers
// ---------------------------------------------------------------------------------------

void 
SgServiceNotifyCliUserChange( 
    const SGADDR*   psgaddr, 
          ULONGLONG qwUser0, 
          ULONGLONG qwUser1, 
          ULONGLONG qwUser2, 
          ULONGLONG qwUser3, 
          IN_ADDR   ipaI, 
          DWORD     dwFlags
    )
{
    CSgMsgNotifyCliUserChange msg;
    CSgMsgNotifyCliUserChange *pMsg = &msg;

    // Do nothing in the case where there are actually no users in the message
    if (qwUser0 == 0 && qwUser1 == 0 && qwUser2 == 0 && qwUser3 == 0) 
    {
        return;
    }

    pMsg->_wType       = SGMSG_TYPE_NOTIFY_CLI_UCHG;
    pMsg->_cbEnt       = sizeof( *pMsg );
    pMsg->_sgaddr      = *psgaddr;
    pMsg->_qwUserId[0] = qwUser0;
    pMsg->_qwUserId[1] = qwUser1;
    pMsg->_qwUserId[2] = qwUser2;
    pMsg->_qwUserId[3] = qwUser3;
    pMsg->_ipaI        = ipaI;
    pMsg->_dwFlags     = dwFlags;

    if (!g_UserChangeNotification.Queue()->Enqueue(pMsg)) 
    {
        SgPerfdataInterlockedInc(NotificationsUserChangeDrop);
        TraceSz(
            Notification, 
            "%08lX FAILED to queue UserChange for machine 0x%016I64X, %d slots remaining",
            psgaddr->dwSpiSg,
            psgaddr->qwXboxID,
            g_UserChangeNotification.Queue()->SlotsRemaining()
            );
    }
    else
    {
        SgPerfdataInterlockedInc(NotificationsUserChange);
        SgPerfdataSet(NotificationsUserChangeQueue, g_UserChangeNotification.Queue()->SlotsRemaining());

        TraceSz(
            Notification, 
            "%08lX UserChange queued [%d total] for machine 0x%016I64X",
            psgaddr->dwSpiSg,
            g_UserChangeNotification.Queue()->Count(),
            psgaddr->qwXboxID
            );

    }
}

// ---------------------------------------------------------------------------------------
// SgServiceNotifyCliDelete - send client deletes out to registered servers
// ---------------------------------------------------------------------------------------

void 
SgServiceNotifyCliDelete( 
    const SGADDR* psgaddr, 
    DWORD dwTitleId 
    )
{
    CSgMsgNotifyCliDelete msg;
    CSgMsgNotifyCliDelete* pMsg = &msg;

    pMsg->_wType = SGMSG_TYPE_NOTIFY_CLI_DEL;
    pMsg->_cbEnt = sizeof( *pMsg );
    pMsg->_sgaddr = *psgaddr;
    pMsg->_dwTitleId = dwTitleId;

    if (!g_DeleteNotification.Queue()->Enqueue(pMsg))
    {
        SgPerfdataInterlockedInc(NotificationsDeleteDrop);

        TraceSz(
            Notification, 
            "%08lX FAILED to queue Delete for machine 0x%016I64X, %d slots remaining",
            psgaddr->dwSpiSg,
            psgaddr->qwXboxID,
            g_DeleteNotification.Queue()->SlotsRemaining()
            );
    }
    else
    {
        SgPerfdataInterlockedInc(NotificationsDelete);
        SgPerfdataSet(NotificationsDeleteQueue, g_DeleteNotification.Queue()->SlotsRemaining());

        TraceSz(
            Notification, 
            "%08lX Delete queued [%d total] for machine 0x%016I64X",
            psgaddr->dwSpiSg,
            g_DeleteNotification.Queue()->Count(),
            psgaddr->qwXboxID
            );
    }
}

// ---------------------------------------------------------------------------------------
// SgServiceNotifySpiUpdate - send spi update out to registered servers
// ---------------------------------------------------------------------------------------

void SgServiceNotifySpiUpdate( const SGADDR* psgaddr, DWORD dwSpiOld )
{
    CSgMsgNotifySpiUpdate msg;
    CSgMsgNotifySpiUpdate* pMsg = &msg;

    pMsg->_wType    = SGMSG_TYPE_NOTIFY_SPI_UPD;
    pMsg->_cbEnt    = sizeof( *pMsg );
    pMsg->_sgaddr   = *psgaddr;
    pMsg->_dwSpiOld = dwSpiOld;

    if (!g_SpiUpdateNotification.Queue()->Enqueue(pMsg))
    {
        SgPerfdataInterlockedInc(NotificationsSpiUpdateDrop);

        TraceSz(
            Notification, 
            "%08lX FAILED to queue SpiUpdate for machine 0x%016I64X, %d slots remaining",
            psgaddr->dwSpiSg,
            psgaddr->qwXboxID,
            g_SpiUpdateNotification.Queue()->SlotsRemaining()
            );
    }
    else
    {
        SgPerfdataInterlockedInc(NotificationsSpiUpdate);
        SgPerfdataSet(NotificationsSpiUpdateQueue, g_SpiUpdateNotification.Queue()->SlotsRemaining());

        TraceSz(
            Notification, 
            "%08lX SpiUpdate queued [%d total] for machine 0x%016I64X",
            psgaddr->dwSpiSg,
            g_SpiUpdateNotification.Queue()->Count(),
            psgaddr->qwXboxID
            );
    }
}


// ---------------------------------------------------------------------------------------
// SgServiceNotifySgDelete - the whole SG is going offline, tell registered servers
// ---------------------------------------------------------------------------------------

void SgServiceNotifySgDelete()
{
    SGADDR sgaddr;
    ZeroMemory(&sgaddr, sizeof(sgaddr));

    // An SG delete is the same as sending out a deadxbox for each client on this SG. So, 
    // suppose our deadxbox queue is full. We would drop the SG delete below. That's quite 
    // bad. Instead, we're going to empty that queue completely and then enqueue the SG 
    // delete. Should be no difference.

    g_DeleteNotification.Queue()->Complete();

    for( DWORD iAddr = 0; iAddr < g_cInetInterfaces; iAddr++ )
    {
        // All zeroes is what makes an "SG Delete" message
        SgServiceNotifyCliDelete(&sgaddr, 0);
    }

    TraceSz(
        Notification, 
        "[queued] %d SgDelete notifications sent",
        g_cInetInterfaces
        );
}

// ---------------------------------------------------------------------------------------
// SgServiceNotifySendHttp - sends HTTP messages out to registered servers. Returns TRUE 
// if success, FALSE if the connect/send failed.
// ---------------------------------------------------------------------------------------

BOOL SgServiceNotifySendHttp( DWORD dwIpNet, WORD wPortNet, DWORD dwServiceId, const char* pszUrl, const BYTE* pb, DWORD cb )
{
    BOOL fOk = FALSE;
    SOCKET s = INVALID_SOCKET;
    sockaddr_in server;

    // Make 2 sends: one for the http headers, and 1 for the payload. All we need is the 
    // headers buffer. Pick an arbitrarily large enough size for it. Sigh.

    BYTE rgbBuffer[ 8192 ];

    // Create a new socket
    s = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if( INVALID_SOCKET == s )
    {
        SgEventSz(INIT_ERROR_9, "SGSVC: Failed creating new socket, err=%u", WSAGetLastError() );
        goto Exit;
    }

    // Construct sequence number based on datetimestamp down to milliseconds.
    // fits within a QWORD, and may be useful for future debugging, to see the
    // time of the actual update message delivery, so constructing this as opposed
    // to a 64bit tick count.
    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    UINT64 qwSeqNum;

    // Decimal value:                  YYYYMMDDHHMMSSmmm
    qwSeqNum =  (UINT64)sysTime.wMilliseconds;
    qwSeqNum += (UINT64)sysTime.wSecond *           1000L;
    qwSeqNum += (UINT64)sysTime.wMinute *         100000L;
    qwSeqNum += (UINT64)sysTime.wHour   *       10000000L;
    qwSeqNum += (UINT64)sysTime.wDay    *     1000000000L;
    qwSeqNum += (UINT64)sysTime.wMonth  *   100000000000L;
    qwSeqNum += (UINT64)sysTime.wYear   * 10000000000000L;

    // Build up the send buffer
    int cbHeader = MAKEPOSTBUFFER( rgbBuffer, sizeof( rgbBuffer ), pszUrl, qwSeqNum, dwServiceId, cb ); 
    if(  cbHeader == -1 )
    {
        SgEventSz(INIT_ERROR_10, "SGSVC: Failed sending buffer that is too long(> %u)", 
            sizeof( rgbBuffer ) );
        goto Exit;
    }

    // Connect to the remote server
    server.sin_family = AF_INET;
    server.sin_port = wPortNet;
    server.sin_addr.S_un.S_addr = dwIpNet;

    if( SOCKET_ERROR == connect(s, (sockaddr*) &server, sizeof( server ) ) )
    {
        SgEventSz(INIT_ERROR_11, "SGSVC: Failed connecting to server %s:%u, err=%u", 
            inet_ntoa( *((in_addr*) &dwIpNet) ), ntohs( wPortNet ), WSAGetLastError() );
        goto Exit;
    }

    // Send the headers 
    int nBytesSent = 0;
    int nBytesToSend = cbHeader;
    while (nBytesSent < nBytesToSend)
    {
        int n = send( s, (char*) &rgbBuffer[nBytesSent], nBytesToSend - nBytesSent, 0 );
        if( SOCKET_ERROR == n)
        {
            SgEventSz(INIT_ERROR_12, "SGSVC: Failed sending HTTP headers to server %s:%u (%u bytes), err=%u", 
                inet_ntoa( *((in_addr*) &dwIpNet) ), ntohs( wPortNet ), cbHeader, WSAGetLastError() );
            goto Exit;
        }
        nBytesSent += n;
    }

    // Send the payload
    nBytesSent = 0;
    nBytesToSend = cb;
    while (nBytesSent < nBytesToSend)
    {
        int n = send( s, (char*) &pb[nBytesSent], nBytesToSend - nBytesSent, 0 );
        if( SOCKET_ERROR == n)
        {
            SgEventSz(INIT_ERROR_12, "SGSVC: Failed sending HTTP payload to server %s:%u (%u bytes), err=%u", 
                inet_ntoa( *((in_addr*) &dwIpNet) ), ntohs( wPortNet ), cb, WSAGetLastError() );
            goto Exit;
        }
        nBytesSent += n;
    }

    // @@@ um, maybe look for an HTTP 200?

    fOk = TRUE;

Exit:
    if( INVALID_SOCKET != s )
    {
        closesocket( s );
        s = INVALID_SOCKET;
    }

    return fOk;
}

// ---------------------------------------------------------------------------------------
// SgServiceNotifySendHealthHttp - sends Health HTTP messages out to registered servers
// ---------------------------------------------------------------------------------------

#ifdef SG_FEATURE_XMGMT

#define MAX_MGMT_RESPONSE_SIZE 2048

void
SgServiceNotifySendHealthHttp(
    DWORD dwRequestId,
    CXomControlResponseInterface *pResponseInterface,
    DWORD dwIpNet,
    WORD  wPortNet,
    DWORD dwServiceId,
    const char *pszUrl
    )
{
    const char * pszHealthOp = "?op=heartbeat";

    // We will need a string buffer that can dynamically grow to 1 MB
    CSmallStr   strAnswer;

    BYTE        szBuffer[ 1024 ];
    char        pszHealthUrl[ MAX_NOTIFY_URL_LEN ];
    char        pszResponse[ MAX_MGMT_RESPONSE_SIZE ];
    char       *pszTemp;
    int         cbHeader;
    int         cbResponse = 0 ;
    SOCKET      s = INVALID_SOCKET;
    sockaddr_in server;

    // Create a copy of the url with the correct opcode
    sprintf( pszHealthUrl, "%s%s", pszUrl, pszHealthOp );

    // Create a new socket
    s = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if (INVALID_SOCKET == s )
    {
        cbResponse += _snprintf(
            pszResponse + cbResponse,
            MAX_MGMT_RESPONSE_SIZE - cbResponse,
            "socket() err=%u - URL [%s] Service [%d]\n",
            WSAGetLastError(),
            pszUrl,
            dwServiceId
            );
        goto Exit;
    }

    // Build up the send buffer
    cbHeader = MAKEGETBUFFER( szBuffer, sizeof ( szBuffer ), pszHealthUrl ); 

    // Connect to the remote server
    server.sin_family           = AF_INET;
    server.sin_port             = wPortNet;
    server.sin_addr.S_un.S_addr = dwIpNet;

    if (SOCKET_ERROR == connect(s, (sockaddr*) &server, sizeof( server ) ) )
    {
        cbResponse += _snprintf(
            pszResponse + cbResponse,
            MAX_MGMT_RESPONSE_SIZE - cbResponse,
            "connect() [%s:%u] err=%u - URL [%s] Service [%d]\n",
            inet_ntoa( *((in_addr*) &dwIpNet) ),
            ntohs( wPortNet ),
            WSAGetLastError(),
            pszUrl,
            dwServiceId
            );
        goto Exit;
    }

    // Send the message
    int nBytesSent = 0;
    int nBytesToSend = cbHeader;
    while (nBytesSent < nBytesToSend)
    {
        int n = send( s, (char*) &szBuffer[nBytesSent], nBytesToSend - nBytesSent, 0 );
        if( SOCKET_ERROR == n)
        {
            cbResponse += _snprintf(
                pszResponse + cbResponse,
                MAX_MGMT_RESPONSE_SIZE - cbResponse,
                "send() [%s:%u] (%u bytes ) err=%u - URL [%s] Service [%d]\n",
                inet_ntoa( *((in_addr*) &dwIpNet) ),
                ntohs( wPortNet ),
                cbHeader,
                WSAGetLastError(),
                pszUrl,
                dwServiceId
                );
            goto Exit;
        }
        nBytesSent += n;
    }

    // State information for the receive process
    int nBytesRecv = 0;
    int nTotalRecv = 0;

    strAnswer.SetAllocator(CMemAlloc::Default());
    if (strAnswer.SetCapacity( 0x100000) == FALSE) 
    {
        cbResponse += _snprintf(
            pszResponse + cbResponse,
            MAX_MGMT_RESPONSE_SIZE - cbResponse,
            "CSmallStr.SetCapacity( 0x100000 ) failed\n"
            );
        goto Exit;
    }
    strAnswer.Reset();
    
    // Receive the answer
    while (nBytesRecv != SOCKET_ERROR)
    {
        memset( szBuffer, 0, dimensionof(szBuffer) );
        nBytesRecv = recv( s, (char *) szBuffer, dimensionof(szBuffer) - 1, 0 );
        if (nBytesRecv == 0)
        {
            break;
        }
        nTotalRecv += nBytesRecv;
        
        // Add the answer to the text string
        strAnswer.Format("%s", szBuffer );
    }

    if (strstr( strAnswer.cstr(),"HTTP/1.1 200 OK" ) != NULL)
    {
        cbResponse += _snprintf(
            pszResponse + cbResponse,
            MAX_MGMT_RESPONSE_SIZE - cbResponse,
            "[%s:%u] - URL [%s] Service [%d] - OK\n",
            inet_ntoa( *((in_addr*) &dwIpNet) ),
            ntohs( wPortNet ),
            pszUrl,
            dwServiceId
            );
        goto Exit;
    } 
    
    if (strstr( strAnswer.cstr(),"HTTP/1.1 500" ) != NULL)
    {
        // find the X-Err: section
        pszTemp = (char*)strstr (strAnswer.cstr(), "X-Err:" );
        if (pszTemp != NULL)
        {
            DWORD dwXerr = 0;
            char *pszResult;

            // skip of the text
            pszTemp += 7; 

            // conver to hex
            dwXerr = strtoul( pszTemp, &pszResult, 16 );

            cbResponse += _snprintf(
                pszResponse + cbResponse,
                MAX_MGMT_RESPONSE_SIZE - cbResponse,
                "[%s:%u] - URL [%s] Service [%d] - X-Err: 0x%08x\n",
                inet_ntoa( *((in_addr*) &dwIpNet) ),
                ntohs( wPortNet ),
                pszUrl,
                dwServiceId,
                dwXerr
                );
            goto Exit;
        }
    }

    // Just dump the first line
    pszTemp = (char *) strAnswer.cstr();
    if (pszTemp)
    {
        while (*pszTemp != '\0' && *pszTemp != '\n')
        {
            pszTemp++;
        }
        *pszTemp = '\0';
    }

    // failure cases
    cbResponse += _snprintf(
        pszResponse + cbResponse,
        MAX_MGMT_RESPONSE_SIZE - cbResponse,
        "[%s:%u] - URL [%s] Service [%d] - %s\n",
        inet_ntoa( *((in_addr*) &dwIpNet) ),
        ntohs( wPortNet ),
        pszUrl,
        dwServiceId,
        strAnswer.cstr()
        );

Exit:
    
    if (cbResponse && pResponseInterface)
    {
        pResponseInterface->WriteResponse(
            dwRequestId,
            (BYTE *)pszResponse,
            (DWORD) -1
            );
    }

    if( INVALID_SOCKET != s )
    {
        closesocket( s );
        s = INVALID_SOCKET;
    }

}

void SgServiceNotifyHealthCheck(
    DWORD dwRequestId,
    CXomControlResponseInterface *pResponseInterface
    )
{
    g_UpdateNotification.SendHealth(dwRequestId, pResponseInterface);
    g_TitleChangeNotification.SendHealth(dwRequestId, pResponseInterface);
    g_DeleteNotification.SendHealth(dwRequestId, pResponseInterface);
    g_UserChangeNotification.SendHealth(dwRequestId, pResponseInterface);
    g_SpiUpdateNotification.SendHealth(dwRequestId, pResponseInterface);
}

#endif

// ---------------------------------------------------------------------------------------
// SgServiceNotifySendQueued - sends batched messages if its time. Batches are limited in 
// size, so if our queue grew rather large, we may need to make multiple sends to drain 
// it. Since our thread is now dedicated to this sole task, let it loop indefinitely as 
// long as there is work to do.
// ---------------------------------------------------------------------------------------

void SgServiceNotifySendQueued( BOOL fForce )
{
    BOOL fMore;
    // We're running at 10 Hz, sending up to 100 messages (Notify*BatchCount default) at a 
    // time. That means we can handle at most 1000 messages/sec. This loop increases that 
    // to 10000 messages/sec, which seems like plenty.
    do
    {
        fMore = FALSE;
        // Order kinda matters, Updates are less critical than Delete or TitleChange.
        fMore = fMore || g_DeleteNotification.SendQueued(fForce);
        fMore = fMore || g_SpiUpdateNotification.SendQueued(fForce);
        fMore = fMore || g_UserChangeNotification.SendQueued(fForce);
        fMore = fMore || g_TitleChangeNotification.SendQueued(fForce);
        fMore = fMore || g_UpdateNotification.SendQueued(fForce);
        // Stop if nothing left to send, OR our timer has been turned off, implying we're 
        // shutting down.
    }
    while (fMore && g_timerNotificationsStarted);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgutil.cpp ===
// ---------------------------------------------------------------------------------------
// sgutil.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "sg.h"
#include <bcrypt.h>
#include <search.h>

// Sigh. BCRYPT_USE_SYSTEM_PREFERRED_RNG isn't defined in the standard sdk, only in platform-specific sdks.
#ifndef BCRYPT_USE_SYSTEM_PREFERRED_RNG
#define BCRYPT_USE_SYSTEM_PREFERRED_RNG 2
#endif

XomImportArea(SgClientStats);

#define THROTTLE_ASSERT(x)  Assert(x)
#include "eventthrottle.h"

typedef CEventThrottle
        <
            50000,      // wBaseEventId
            5000,        // wNumEvents
            5009,       // wIPHashSize - each IP-tracked event will consume ~20KB
            2000000,    // 2MB of IP tracking hash tables (about 100 events worth)
            10000000    // 10MB of hash entries (about 240K IPs across all events)
        > CNtEventThrottle;

CSgMemAlloc CSgMemAlloc::_sgAlloc;

// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

LONG g_lPktNum = 0;

void CPacket::CompletePush(PFNCOMPLETE pfn)
{
    Assert(_cpfn < dimensionof(_apfn));
    _apfn[_cpfn++] = pfn;
}

void CPacket::Complete()
{
    Assert(_cpfn > 0);
    (*_apfn[--_cpfn])(this);
}

void CPacket::Reset()
{
#if DBG
    memset(this, '*', sizeof(CPacket));
#endif

    memset(this, 0, offsetof(CPacket, _dwPktNum));

    // _dwPktNum is only used as a serial number for tracing. Since we won't really use 
    // tracing in production, we can save a few CPU cycles by not using the 
    // InterlockFunctions. It's OK if the packet num gets off by a little.
#if DBG
    _dwPktNum = (DWORD)InterlockedIncrement((LONG *)&g_lPktNum);
#else
    _dwPktNum = g_lPktNum++;
#endif

}

char * CPacket::Str() const
{
    STATIC_BUFFER(CPacketStr, 64, 64);

    if (_pSpiInfo)
        _snprintf(pch, cch, "#%d %c%d %08lX", _dwPktNum,
                  _pTransInfoRecv ? (char)_pTransInfoRecv->_dwType : 'L',
                  _pTransInfoRecv ? _pTransInfoRecv->_iTransInfo : 0, _pSpiInfo->_dwSpiRecv);
    else
        _snprintf(pch, cch, "#%d %c%d", _dwPktNum,
                  _pTransInfoRecv ? (char)_pTransInfoRecv->_dwType : 'L',
                  _pTransInfoRecv ? _pTransInfoRecv->_iTransInfo : 0);

    return(pch);
}

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

void CPacketQueue::InsertHead(CPacket * ppkt)
{
    if ((ppkt->_ppktNext = _ppktHead) == NULL)
        _ppktTail = ppkt;
    _ppktHead = ppkt;
    _cPacket++;
}

void CPacketQueue::InsertTail(CPacket * ppkt)
{
    if (_ppktTail)
        _ppktTail->_ppktNext = ppkt;
    else
        _ppktHead = ppkt;

    _ppktTail = ppkt;
    ppkt->_ppktNext = NULL;
    _cPacket++;
}

void CPacketQueue::InsertHead(CPacketQueue * ppq)
{
    Assert(!ppq->IsEmpty());
    if (_ppktTail == NULL)
        _ppktTail = ppq->_ppktTail;
    ppq->_ppktTail->_ppktNext = _ppktHead;
    _ppktHead = ppq->_ppktHead;
    _cPacket += ppq->_cPacket;
    ppq->Init();
}

CPacket * CPacketQueue::RemoveHead()
{
    Assert(!IsEmpty());

    CPacket * ppkt = _ppktHead;

    if ((_ppktHead = ppkt->_ppktNext) == NULL)
        _ppktTail = NULL;
    else
        ppkt->_ppktNext = NULL;

    _cPacket--;

    return(ppkt);
}

void CPacketQueue::Complete()
{
    while (!IsEmpty())
    {
        RemoveHead()->Complete();
    }
}

BOOL CPacketQueue::Dequeue(CPacket * ppktDequeue)
{
    CPacket **  pppkt    = &_ppktHead;
    CPacket *   ppktPrev = NULL;
    CPacket *   ppkt;

    for (; (ppkt = *pppkt) != NULL; ppktPrev = ppkt, pppkt = &ppkt->_ppktNext)
    {
        if (ppkt == ppktDequeue)
        {
            *pppkt = ppkt->_ppktNext;

            if (_ppktHead == NULL)
                _ppktTail = NULL;
            else if (_ppktTail == ppkt)
                _ppktTail = ppktPrev;

            _cPacket--;

            return(TRUE);
        }
    }

    return(FALSE);
}

UINT CPacketQueue::Count()
{
    return _cPacket;
}

// ---------------------------------------------------------------------------------------
// CSgMsgQueue
//
// This is thread-safe. And it does not store the CSgMsg structures passed in -- it copies 
// the memory. Remember this.
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// CSgMsgQueue::Enqueue - returns TRUE if successful, else FALSE if failed
// ---------------------------------------------------------------------------------------
BOOL
CSgMsgQueue::Enqueue(const CSgMsgHdr * pSgMsg)
{
    CPacket *   ppkt = NULL;
    BOOL        fRet = FALSE;

    // Fast check
    if (SlotsRemaining() == 0)
    {
        return FALSE;
    }

    ppkt = SgPacketAlloc();
    if (ppkt == NULL)
    {
        TraceSz(Warning, "CSgMsgQueue::Enqueue - Unable to allocate a packet");
        return FALSE;
    }

    Assert(pSgMsg->_cbEnt <= sizeof(ppkt->_abCtx));
    memcpy(ppkt->_abCtx, pSgMsg, pSgMsg->_cbEnt);

    // fill out packet fields to show where the data is
    ppkt->_apb[0] = ppkt->_abCtx;
    ppkt->_acb[0] = pSgMsg->_cbEnt;
    ppkt->_cpb    = 1;

    _lock.AcquireLock();

    // Second, reliable, check
    if (SlotsRemaining() == 0)
    {
        goto Cleanup;
    }

    _pq.InsertTail(ppkt);

    fRet = TRUE;

Cleanup:

    _lock.ReleaseLock();

    if (!fRet && ppkt != NULL)
    {
        ppkt->Complete();
    }

    return fRet;
}


// ---------------------------------------------------------------------------------------
// CSgMsgQueue::DequeueMultiToBuffer - returns size, in bytes, of all items dequeued
// ---------------------------------------------------------------------------------------
DWORD
CSgMsgQueue::DequeueMultiToBuffer(BYTE * abBuffer, DWORD cbBuffer)
{
    CPacketQueue   pqComplete;
    BYTE*          pbCursor;
    DWORD          cbLeft;

    pqComplete.Init();

    pbCursor = abBuffer;
    cbLeft = cbBuffer;

    _lock.AcquireLock();

    while( !_pq.IsEmpty() )
    {
        CPacket* ppkt = _pq.GetHead();
        DWORD cbPacket = 0;
        UINT iBuffer;

        // Find out the total size of this packet
        for( iBuffer = 0; iBuffer < ppkt->_cpb; iBuffer++ )
        {
            cbPacket += ppkt->_acb[ iBuffer ];
        }

        // Check if the packet will fit
        if( cbPacket > cbLeft )
        {
            // That's all we can fit, so we're done
            break;
        }

        // We're going to consume the packet, so pull it from the queue
        _pq.Dequeue( ppkt );

        // We're only calculating sizes, not copying yet
        cbLeft -= cbPacket;

        // Add the packet to a local queue for copy & completion outside of the lock
        pqComplete.InsertTail( ppkt );

    }

    _lock.ReleaseLock();

    // Copy & complete any packets we dequeued
    cbLeft = cbBuffer;
    while ( !pqComplete.IsEmpty() )
    {
        CPacket* ppkt = pqComplete.RemoveHead();
        
        // Copy the packet into the caller's buffer
        for( UINT iBuffer = 0; iBuffer < ppkt->_cpb; iBuffer++ )
        {
            memcpy( pbCursor, ppkt->_apb[ iBuffer ], ppkt->_acb[ iBuffer ] );
            pbCursor += ppkt->_acb[ iBuffer ];
            cbLeft -= ppkt->_acb[ iBuffer ];
            Assert(cbLeft <= cbBuffer);
        }

        ppkt->Complete();
    }


    return cbBuffer - cbLeft;
}


// ---------------------------------------------------------------------------------------
// Packet support
// ---------------------------------------------------------------------------------------

CLookAsideList  g_packetPool;
DWORD           g_cPacketInUse;
DWORD           g_cPacketPoolMax;

void SgPacketComplete( CPacket * ppkt )
{
    Assert( NULL == ppkt->_pSpiInfo );
    Assert( NULL == ppkt->_pCliInfo );

    g_packetPool.Free(ppkt);
    InterlockedDecrement((volatile LONG*)&g_cPacketInUse);
    SgPerfdataSet(PacketsAvailable, g_cPacketPoolMax - g_cPacketInUse);
}

CPacket* SgPacketAlloc()
{
    CPacket* ppkt = NULL;
    
    if(g_cPacketInUse >= g_cPacketPoolMax)
    {
        goto Exit;
    }

    ppkt = (CPacket*) g_packetPool.Alloc();

    if(!ppkt)
    {
        goto Exit;
    }

    ppkt->Reset();
    ppkt->CompletePush( SgPacketComplete );
    InterlockedIncrement((volatile LONG*)&g_cPacketInUse);
    SgPerfdataSet(PacketsAvailable, g_cPacketPoolMax - g_cPacketInUse);

    // @@@ instrumented build only?
    SgPerfdataInterlockedInc(PacketAllocSuccess);

    // Make sure our buffer is aligned as we think it should be.
    Assert( ( (UINT)ppkt->_abTransRecv & (BUFFER_ALIGNMENT - 1) ) == 0);

Exit:
    
    if(!ppkt)
    {
        SgPerfdataInterlockedInc(PacketAllocFail);
        SgEventSz(PACKET_ALLOCATION_ERROR, "Packets-in-use(%u), Packet-pool-max(%u). Refer to setting PacketPoolMax.",
                   g_cPacketInUse, g_cPacketPoolMax);
    }

    return ppkt;
}

BOOL SgPacketInit()
{
    Assert(g_cPacketInUse == 0);
    Assert(g_cPacketPoolMax == 0);
    
    return TRUE;
}

BOOL SgPacketConfig(CCfgInfo* pci)
{
    TraceSz( Config, "SgPacketConfig:" );

    // Only configure the packet pool once
    if(g_cPacketPoolMax == 0)
    {
        DWORD packetPool;

        if(!pci->GetVar("PacketPool", &packetPool, 1, 0xFFFFFFFF, 10000) ||
           !pci->GetVar("PacketPoolMax", &g_cPacketPoolMax, 100, 0xFFFFFFFF, 100000))
        {
            return FALSE;
        }

        g_packetPool.Init(sizeof(CPacket), g_cPacketPoolMax, CSgMemAlloc::GetAlloc());

        if(!g_packetPool.PreAlloc(packetPool))
        {
            return FALSE;
        }
    
        TraceSz(Config, "    Configured packet pool to %u packets", packetPool );
        TraceSz(Config, "    Configured packet pool limit to %u packets", g_cPacketPoolMax);
    }

    return TRUE;
}

void SgPacketTerm()
{
    g_packetPool.Term();
}

// ---------------------------------------------------------------------------------------
// SgTimer
// ---------------------------------------------------------------------------------------

CServerTimer g_timerShort;                   // timer thread for fast, small appointments
CServerTimer g_timerLong;                   // timer thread for slow, large appointments
QWORD        g_qwTickNow;                   
BOOL         g_fTimerStarted;
SERVER_TIMER_APPOINTMENT g_tickTimerAppt;

// ---------------------------------------------------------------------------------------
// SgTimerInit
// Initializes timer thread globals
// ---------------------------------------------------------------------------------------
BOOL SgTimerInit()
{
    LARGE_INTEGER liTime;
    LARGE_INTEGER liTicksPerSystemTime;

    // Get the current time
    liTime.QuadPart = SgGetSystemTime();

    // Create a QWORD value that will allow us to convert between system time
    // and tick time
    liTicksPerSystemTime.QuadPart = 10000000 / TICKS_PER_SECOND;

    // Convert System Time into Tick Time;
    g_qwTickNow = liTime.QuadPart / liTicksPerSystemTime.QuadPart;

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// SgTimerTerm
// Terminate timer thread
// ---------------------------------------------------------------------------------------
void SgTimerTerm()
{
    g_timerLong.Term();
    g_timerShort.Term();
    g_fTimerStarted = FALSE;
    g_qwTickNow     = 0;
}

// ---------------------------------------------------------------------------------------
// SgTimerTickCallback
// Everything that uses time in the SG uses SgTimerTick. And SgTimerTick uses g_qwTickNow, 
// a QWORD that's incremented approximatelly TICKS_PER_SECOND times per second. This is 
// where g_qwTickNow is incremented.
// ---------------------------------------------------------------------------------------
void WINAPI SgTimerTickCallback(VOID*)
{
    //
    // increment master tick counter
    //
    
    g_qwTickNow++;

    //
    // execute Spi timer
    //
    
    SgSpiInfoTimer();

    //
    // reschedule. On shutdown CreateAppointment will fail gracefully
    //

    g_timerShort.CreateAppointment(SgTimerTickCallback, NULL, 1000 / TICKS_PER_SECOND, 
                                   &g_tickTimerAppt);
}

// ---------------------------------------------------------------------------------------
// SgTimerConfig
// Configure and start timer thread
// ---------------------------------------------------------------------------------------
BOOL SgTimerConfig(CCfgInfo* pci)
{
    UNREFERENCED_PARAMETER(pci);
    TraceSz( Config, "SgTimerConfig:" );

    if(g_fTimerStarted)
    {
        return TRUE;
    }

    //
    // initialize timer threads. g_timerShort is dedicated to fast, short-lived 
    // non-blocking appointments
    //
    if(!g_timerShort.Init(true, CMemAlloc::Default()))
    {
        SgEventSz(INIT_ERROR, "Failed to initialize fast timer");
        return FALSE;
    }

    // 
    // g_timerLong is dedicated to not so fast, generally IO-related, blocking 
    // appointments that are not time critical. It does not need to run at ABOVENORMAL 
    // priority.
    //
    
    if(!g_timerLong.Init(false, CMemAlloc::Default()))
    {
        SgEventSz(INIT_ERROR, "Failed to initialize slow timer");
        return FALSE;
    }

    //
    // schedule the tick callback in the fast timer
    //
    
    if(!g_timerShort.CreateAppointment(SgTimerTickCallback, NULL, 1000 / TICKS_PER_SECOND, &g_tickTimerAppt))
    {
        SgEventSz(INIT_ERROR, "Failed to initialized tick timer");
        return FALSE;
    }

    g_fTimerStarted = TRUE;

    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// SgTimerStop
// Stop timer thread
// ---------------------------------------------------------------------------------------
void SgTimerStop()
{
    g_timerShort.Term();
    g_timerLong.Term();
}

// ---------------------------------------------------------------------------------------
// SgTimerSet
// Schedule a timer to be executed.
//   - pTimer must point to a CTimer structure to store the appointment
//   - pfn is a pointer to a function to be called when the timer is due
//   - qwTickDue is the time in SG ticks of when pfn should be called. Use SgTimerTick to 
//   retrieve the current time in ticks. The constant TICKS_PER_SECOND represents the 
//   number of ticks in a second.
// ---------------------------------------------------------------------------------------
void SgTimerSet(CTimer * pTimer, PFNTIMER pfn, UINT64 qwTickDue, BOOL fLong)
{
    AssertSz(qwTickDue >= g_qwTickNow, "Attempt to set timer in the past");

    //
    // cancel a previous appointment
    //
    
    if(pTimer->_pServerTimer)
    {
        Assert(pTimer->_pServerTimer == &g_timerShort || 
               pTimer->_pServerTimer == &g_timerLong);
        
        pTimer->_pServerTimer->CancelAppointment(pTimer);
    }

    if(qwTickDue != TIMER_INFINITE)
    {
        //
        // schedule appointment
        //

        CServerTimer* pServerTimer = fLong ? &g_timerLong : &g_timerShort;

        UINT64 qwTickDelta = (qwTickDue - g_qwTickNow);
        if (qwTickDue < g_qwTickNow)
        {
            // Wrapped, let's fire immediately
            qwTickDelta = 0;
        }
        else if (qwTickDelta > TIMER_MAX_TICK_DUE_DELTA)
        {
            AssertSz(false, "qwTickDue is too large");
            
            SgEventSz(INTERNAL_USERMODE_ERROR, 
                       "Timer delta is too large %u (%u seconds). Using maximum %u. ", 
                       qwTickDelta, qwTickDelta / TICKS_PER_SECOND, 
                       TIMER_MAX_TICK_DUE_DELTA);
            
            qwTickDelta = TIMER_MAX_TICK_DUE_DELTA;
        }
        DWORD dwTickDelta = (DWORD) qwTickDelta;

        pTimer->_pfn          = pfn;
        pTimer->_pServerTimer = pServerTimer;
        
        if (!pServerTimer->CreateAppointment(CTimer::TimerCallback, pTimer, 
                                             dwTickDelta * 1000 / TICKS_PER_SECOND, pTimer))
        {
            TraceSz(Timer, "Failed to create appointment. pTimer=0x%08X, pfn=0x%08X, dwTickDue=%I64u",
                    pTimer, pfn, qwTickDue);
        }
    }
}

// ---------------------------------------------------------------------------------------
// Random Number Generation Support
// ---------------------------------------------------------------------------------------

BYTE    g_abRandRc4Struct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
CLock   g_lockRand;
BOOL    g_fRandInitialized;

BOOL SgRandInit()
{
    Assert( !g_fRandInitialized );

    g_lockRand.Init();

    // Init our own random number generator that can be called at DPC
    BYTE    abRand[512];

    // Get some good randomness.
    BCryptGenRandom( NULL, abRand, sizeof( abRand ), BCRYPT_USE_SYSTEM_PREFERRED_RNG );

    // Initialize an RC4 machine with the given random bits as a key
    XcRC4Key( g_abRandRc4Struct, sizeof( abRand ), abRand );

    // Throw away the first 256 bytes of the RC4 machine
    XcRC4Crypt( g_abRandRc4Struct, 256, abRand );

    g_fRandInitialized = TRUE;

    return TRUE;
}

BOOL SgRandConfig(CCfgInfo* pci)
{ 
    UNREFERENCED_PARAMETER(pci);
    TraceSz(Config, "SgRandConfig:"); 
    return(TRUE);
}

void SgRandTerm()
{
    if( g_fRandInitialized )
    {
        g_lockRand.Term();
        g_fRandInitialized = FALSE;
    }
}

BOOL SgRand(BYTE * pb, UINT cb)
{
    g_lockRand.AcquireDpc();

    XcRC4Crypt(g_abRandRc4Struct, cb, pb);

    g_lockRand.ReleaseDpc();

    return TRUE;
}

DWORD SgQuickRand(DWORD dwMin, DWORD dwMax)
{
    if (dwMin >= dwMax)
    {
        return dwMax;
    }
    DWORD dwRange = dwMax - dwMin;
    return dwMin + (rand() % dwRange);
}

// ---------------------------------------------------------------------------------------
// SgSetUdpHdrChecksum
// ---------------------------------------------------------------------------------------

void SgSetUdpHdrChecksum(CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3, BYTE * pb4, UINT cb4, BYTE * pb5, UINT cb5)
{
    CPseudoHeader pseudohdr;
    WORD          wChecksum;
    BYTE          ab[8];
    UINT          cb = 0;

    pseudohdr._ipaSrc    = pIpHdr->_ipaSrc;
    pseudohdr._ipaDst    = pIpHdr->_ipaDst;
    pseudohdr._bZero     = 0;
    pseudohdr._bProtocol = IPPROTOCOL_UDP;
    pseudohdr._wLen      = HTONS(cb1 + cb2 + cb3 + cb4 + cb5);

    pUdpHdr->_wLen       = pseudohdr._wLen;
    pUdpHdr->_wChecksum  = 0;

    // The tcpipxsum function sums up 2-byte words.  If a buffer is odd, we need to place the
    // last byte in ab for summing later, and we need to capture the first byte of the
    // next non-zero buffer to go with it.  The first buffer is always 2-byte aligned.

    Assert((cb1 & 1) == 0);

    wChecksum = tcpipxsum(tcpipxsum(0, &pseudohdr, sizeof(pseudohdr)), pUdpHdr, cb1);

    if (cb2 > 0)
    {
        if (cb2 & 1) { ab[cb++] = pb2[--cb2]; }
        wChecksum = tcpipxsum(wChecksum, pb2, cb2);
    }

    if (cb3 > 0)
    {
        if (cb  & 1) { ab[cb++] = *pb3++; --cb3; }
        if (cb3 & 1) { ab[cb++] = pb3[--cb3]; }
        wChecksum = tcpipxsum(wChecksum, pb3, cb3);
    }

    if (cb4 > 0)
    {
        if (cb  & 1) { ab[cb++] = *pb4++; --cb4; }
        if (cb4 & 1) { ab[cb++] = pb4[--cb4]; }
        wChecksum = tcpipxsum(wChecksum, pb4, cb4);
    }

    if (cb5 > 0)
    {
        if (cb  & 1) { ab[cb++] = *pb5++; --cb5; }
        if (cb5 & 1) { ab[cb++] = pb5[--cb5]; }
        wChecksum = tcpipxsum(wChecksum, pb5, cb5);
    }

    if (cb > 0)
    {
        wChecksum = tcpipxsum(wChecksum, ab, cb);
    }

    wChecksum = ~wChecksum;

    pUdpHdr->_wChecksum = wChecksum - (wChecksum == 0);
}

// ---------------------------------------------------------------------------------------
// SgSetTcpHdrChecksum
// ---------------------------------------------------------------------------------------

void SgSetTcpHdrChecksum(CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cb1, BYTE * pb2, UINT cb2)
{
    CPseudoHeader pseudohdr;
    WORD          wChecksum;

    pseudohdr._ipaSrc    = pIpHdr->_ipaSrc;
    pseudohdr._ipaDst    = pIpHdr->_ipaDst;
    pseudohdr._bZero     = 0;
    pseudohdr._bProtocol = IPPROTOCOL_TCP;
    pseudohdr._wLen      = HTONS(cb1 + cb2);

    pTcpHdr->_wChecksum  = 0;

    // The tcpipxsum function sums up 2-byte words.  If cb1 is odd, this function does not
    // compensate.  Fortunately, all of our callers set cb1 to an even number (sizeof(CTcpHdr)).

    Assert((cb1 % 1) == 0);

    wChecksum = tcpipxsum(tcpipxsum(0, &pseudohdr, sizeof(pseudohdr)), pTcpHdr, cb1);

    if (cb2 > 0)
    {
        wChecksum = tcpipxsum(wChecksum, pb2, cb2);
    }

    pTcpHdr->_wChecksum  = ~wChecksum;
}

// ---------------------------------------------------------------------------------------
// CIpAddr
// ---------------------------------------------------------------------------------------

BOOL CIpAddr::IsValidAddr(CIpAddr ipaMask) const
{
    DWORD mask = ~( (DWORD) ipaMask);

    // IP Addresses are valid if they aren't the all 0s or all 1s address for their
    // given subnet
    return ( (mask & _dw) != 0 && (mask & _dw) != mask );
}

// ---------------------------------------------------------------------------------------
// Time functions
// ---------------------------------------------------------------------------------------

char * SgTimeToStr( ULONGLONG qwTime )
{
    STATIC_BUFFER(CTimeStr, 64, 64);

    TIME_FIELDS tfTime;

    LARGE_INTEGER liTime;
    liTime.QuadPart = qwTime;

    SgTimeToTimeFields(&liTime, &tfTime);

    _snprintf(pch, cch, "%I64X (%d/%d/%d %02d:%02d:%02d.%03d)", liTime.QuadPart, tfTime.Month, tfTime.Day, tfTime.Year,
              tfTime.Hour, tfTime.Minute, tfTime.Second, tfTime.Milliseconds);

    return(pch);

}

char * SgTickToStr( QWORD qwTickTime )
{
    QWORD qwTime = qwTickTime * (10000000 / TICKS_PER_SECOND);

    // Return the correct string
    return SgTimeToStr( qwTime );
}

DWORD SgTickElapsedInSeconds( UINT64 qwTick, UINT64 qwTickNow )
{
    return (DWORD) (qwTickNow - qwTick) / TICKS_PER_SECOND;
}

DWORD SgTickElapsedInSeconds( UINT64 qwTick )
{
    return SgTickElapsedInSeconds( qwTick, SgTimerTick() );
}



// ---------------------------------------------------------------------------------------
// Events
// ---------------------------------------------------------------------------------------

CNtEventThrottle *g_pEventThrottle;
CLock g_lockEventThrottle;
static const char g_szEventSource[] = "SG_";
static const char g_szEventDll[]    = "sgevent.dll";
char   g_achMachineName[]           = "TUKPRSECUINH001";
HANDLE g_hLogFile;
LONG   g_iEvent;
HANDLE g_hEventLog;


BOOL SgEventInit()
{
    Assert(g_hLogFile == NULL);
    Assert(g_hEventLog == NULL);
    Assert(g_iEvent == 0);
    
    g_lockEventThrottle.Init();
    
    g_hEventLog = RegisterEventSourceA(NULL, g_szEventSource);

    if (g_hEventLog == NULL)
    {
        TraceSz( Config, "Failed calling RegisterEventSource, error=%d", GetLastError() );
        return FALSE;
    }

    Assert(NULL == g_pEventThrottle);
    g_pEventThrottle = new CNtEventThrottle();

    if(!g_pEventThrottle)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL SgEventConfig(CCfgInfo * pci)
{
    TraceSz(Config, "SgEventConfig:");

    CCfgInfo * pciEvent = NULL;
    CCfgInfo * pciT;
    
    if(!g_pEventThrottle)
    {
        return TRUE;
    }

#define EVCFG_SOMETIMES(x) EVCFG_SOMETIMES2(x,1)

#define EVCFG_SOMETIMES2(x,sec) \
    g_pEventThrottle->Initialize( \
        x, \
        NULL, \
        CNtEventThrottle::SOMETIMES_ALLOW, \
        FALSE, \
        0, \
        sec * CNtEventThrottle::HNS_PER_SECOND, \
        FALSE);

#define EVCFG_ALWAYS(x) \
    g_pEventThrottle->Initialize( \
        x, \
        NULL, \
        CNtEventThrottle::ALWAYS_ALLOW);
        
    g_lockEventThrottle.AcquireDpc();
    
    // Configure a default throttle for all events. Most events shouldn't be fired more 
    // than once a second. This can be overriden.

    // TODO: until we fix the event throttler, this is a bad idea. It throws all events 
    // into a pool and throttles that.. so 2 different events in the same second will get 
    // throttled and lumped together.  What we really want is throttling on a per-event 
    // group basis. 
    //EVCFG_SOMETIMES(CNtEventThrottle::ALL_EVENTS);

    // Throttle to once per second 

    EVCFG_SOMETIMES(EVENT_SG_PACKET_ALLOCATION_ERROR);
    EVCFG_SOMETIMES(EVENT_SG_INTERNAL_ERROR);
    EVCFG_SOMETIMES(EVENT_SG_FILTER_SCRIPT_FAILED);

    // These events are easily triggered by fuzzing
    EVCFG_SOMETIMES(EVENT_SG_INVALID_IPSEC_PACKET_6);    // 53806: ip payload not match udp payload
    EVCFG_SOMETIMES(EVENT_SG_INVALID_IPSEC_PACKET_9);    // 53809: invalid xsp flags
    EVCFG_SOMETIMES(EVENT_SG_INVALID_IPSEC_PACKET_14);   // 53814: unknown spi
    EVCFG_SOMETIMES(EVENT_SG_TOOSMALL_KEYEX_PACKET);     // 50064: keyex packet has too small payload
    EVCFG_SOMETIMES(EVENT_SG_INVALID_KERBEROS_TICKET_1); // 53848: aprequest failed (generic)

    // Don't require specific knowledge but a bit harder
    EVCFG_SOMETIMES(EVENT_SG_INVALID_PACKET_8);          // 53832: ip packet is fragmented
    EVCFG_SOMETIMES(EVENT_SG_INVALID_PACKET_11);         // 53835: non-echo ICMP request

    // Require knowing/guessing a valid SPI
    EVCFG_SOMETIMES(EVENT_SG_INVALID_IPSEC_PACKET_16);    // 53816: source ip does not match
    EVCFG_SOMETIMES(EVENT_SG_INVALID_IPSEC_PACKET_17);    // 53817: source port does not match
    EVCFG_SOMETIMES(EVENT_SG_INVALID_IPSEC_PACKET_18);    // 53818: xsp sequence number outside window

    // Require knowing/guessing a valid SPI and other connection info

    EVCFG_SOMETIMES(EVENT_SG_INVALID_IPSEC_PACKET_1);           // 53801: sha authentication failed
    EVCFG_SOMETIMES(EVENT_SG_REPLAYED_PACKET);                  // 50053: replayed xsp sequence number
    EVCFG_SOMETIMES(EVENT_SG_REPLAYED_KERBEROS_AUTHENTICATOR);  // 50052: replayed kerberos authenticator

    // IP address conflicts
    EVCFG_SOMETIMES2(EVENT_SG_IP_CONFLICT_INTERNET, 60);    // 53916
    EVCFG_SOMETIMES2(EVENT_SG_IP_CONFLICT_DATACENTER, 60);  // 53917
    EVCFG_SOMETIMES2(EVENT_SG_IP_CONFLICT_CLIENTPOOL, 60);  // 53918


    // Exceptions, always log these

    EVCFG_ALWAYS(EVENT_SG_INIT_ERROR);
    EVCFG_ALWAYS(EVENT_SG_CONFIG_WARNING);
    EVCFG_ALWAYS(EVENT_SG_CONFIG_SUCCESS);
    EVCFG_ALWAYS(EVENT_SG_CONFIG_RELOAD_SUCCESS);
    EVCFG_ALWAYS(EVENT_SG_CONFIG_FAILURE);
    EVCFG_ALWAYS(EVENT_SG_CONFIG_ERROR);
    
    g_lockEventThrottle.ReleaseDpc();
    
#undef EVCFG_SOMETIMES
#undef EVCFG_SOMETIMES2
#undef EVCFG_ALWAYS

    while(1)
    {
        // Read all event-specific config settings
        UINT uiEventID = 0;
        CNtEventThrottle::ALLOW_TYPE eAllowType = CNtEventThrottle::SOMETIMES_ALLOW;
        BOOL fRateUnitsAreBytes = FALSE;
        UINT uiAlertUnitsPerSec = 0;
        LARGE_INTEGER hnsAlertInterval = { 0 };
        BOOL fTrackPerIP = FALSE;

        pciEvent = pci->FindList("Event", pciEvent, FALSE);

        if (pciEvent == NULL)
            break;

        // Get event ID
        pciT = pciEvent->FindNonList("Id", NULL, TRUE);

        if ((pciT == NULL) ||
            (!pciT->_csValue.StrEql( "default" ) && !pciT->_csValue.GetNum((DWORD*)&uiEventID)))
            goto err;

        if (0 == uiEventID)
        {
            uiEventID = CNtEventThrottle::ALL_EVENTS;
        }

        // Get event frequency [optional]
        pciT = pciEvent->FindNonList("Freq", NULL, FALSE);

        if (pciT != NULL)
        {
            if( pciT->_csValue.StrEql( "maybe" ) ||
                pciT->_csValue.StrEql( "some" ) ||
                pciT->_csValue.StrEql( "sometimes" ) )
            {
                eAllowType = CNtEventThrottle::SOMETIMES_ALLOW;
            }
            else if( pciT->_csValue.StrEql( "no" ) ||
                     pciT->_csValue.StrEql( "none" ) ||
                     pciT->_csValue.StrEql( "never" ) )
            {
                eAllowType = CNtEventThrottle::NEVER_ALLOW;
            }
            else if( pciT->_csValue.StrEql( "all" ) ||
                     pciT->_csValue.StrEql( "always" ) ||
                     pciT->_csValue.StrEql( "yes" ) )
            {
                eAllowType = CNtEventThrottle::ALWAYS_ALLOW;
            }
            else
            {
                goto err;
            }
        }

        // Get rate units [optional]
        pciT = pciEvent->FindNonList("RateUnits", NULL, FALSE);

        if (pciT != NULL)
        {
            if( pciT->_csValue.StrEql( "bytes" ) ||
                pciT->_csValue.StrEql( "data" ) )
            {
                fRateUnitsAreBytes = TRUE;
            }
            else if( pciT->_csValue.StrEql( "events" ) ||
                     pciT->_csValue.StrEql( "packets" ) )
            {
                fRateUnitsAreBytes = FALSE;
            }
            else
            {
                goto err;
            }
        }

        // Get alert rate (units/sec) [optional]
        pciT = pciEvent->FindNonList("AlertRate", NULL, FALSE);

        if (pciT != NULL)
        {
            if (!pciT->_csValue.GetNum((DWORD*)&uiAlertUnitsPerSec))
                goto err;
        }

        // Get alert interval in seconds or hundred-nanoseconds [optional]
        pciT = pciEvent->FindNonList("IntervalSecs", NULL, FALSE);

        if (pciT != NULL)
        {
            if (!pciT->_csValue.GetNum((ULONGLONG*)&hnsAlertInterval.QuadPart))
                goto err;

            hnsAlertInterval.QuadPart *= CNtEventThrottle::HNS_PER_SECOND;
        }

        pciT = pciEvent->FindNonList("IntervalHns", NULL, FALSE);

        if (pciT != NULL)
        {
            if (!pciT->_csValue.GetNum((ULONGLONG*)&hnsAlertInterval.QuadPart))
                goto err;
        }

        // Get per-IP tracking setting [optional]
        pciT = pciEvent->FindNonList("TrackPerIP", NULL, FALSE);

        if (pciT != NULL)
        {
            if( pciT->_csValue.StrEql( "0" ) ||
                pciT->_csValue.StrEql( "n" ) ||
                pciT->_csValue.StrEql( "no" ) ||
                pciT->_csValue.StrEql( "f" ) ||
                pciT->_csValue.StrEql( "false" ) )
            {
                fTrackPerIP = FALSE;
            }
            else if( pciT->_csValue.StrEql( "1" ) ||
                     pciT->_csValue.StrEql( "y" ) ||
                     pciT->_csValue.StrEql( "yes" ) ||
                     pciT->_csValue.StrEql( "t" ) ||
                     pciT->_csValue.StrEql( "true" ) )
            {
                fTrackPerIP = TRUE;
            }
            else
            {
                goto err;
            }
        }

        // Pass the settings along to the in-memory throttling class
        BOOL fOk = TRUE;
        
        TraceSz(Config, "    Event throttle: ID[%5u], Allow[%9s], Units[%6s], Rate[%4u events/sec], Interval[%4u secs], ByIp[%s]",
                uiEventID,
                eAllowType == CNtEventThrottle::NEVER_ALLOW ? "never" :
                    eAllowType == CNtEventThrottle::SOMETIMES_ALLOW ? "sometimes" :
                    "always",
                fRateUnitsAreBytes ? "bytes" : "events",
                uiAlertUnitsPerSec,
                (DWORD)(hnsAlertInterval.QuadPart / CNtEventThrottle::HNS_PER_SECOND),
                fTrackPerIP ? "true" : "false" );

        g_lockEventThrottle.AcquireDpc();

        if (NULL != g_pEventThrottle)
        {
            fOk = g_pEventThrottle->Initialize(
                                        uiEventID,
                                        NULL, 
                                        eAllowType,
                                        fRateUnitsAreBytes,
                                        uiAlertUnitsPerSec,
                                        hnsAlertInterval.QuadPart,
                                        fTrackPerIP );
        }

        g_lockEventThrottle.ReleaseDpc();

        if (!fOk)
        {
            SgEventSz(CONFIG_ERROR, "Failed to configure Nt event %u", uiEventID);
            goto err;
        }
    }


    return(TRUE);

err:

    return(FALSE);
}

void SgEventTerm()
{
    CNtEventThrottle *pvFree = NULL;

    if( NULL != g_hLogFile )
    {
        CloseHandle(g_hLogFile);
        g_hLogFile = NULL;
    }

    if( NULL != g_hEventLog )
    {
        DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }

    g_iEvent = 0;

    g_lockEventThrottle.AcquireDpc();

    // NOTE: If SgInit fails, we can get here with NULL in g_pEventThrottle during SgTerm
    pvFree = g_pEventThrottle;
    g_pEventThrottle = NULL;

    g_lockEventThrottle.ReleaseDpc();

    delete pvFree;
}

void __cdecl SgLogEvent(DWORD dwId, ULONG cbPkt, CIpAddr *pipaSrc, ULONG cb, PVOID pv, const char * pszFmt, ...)
{
    char ach[MAX_EVENT_LENGTH];
    va_list va;
    PSTR psz = NULL;

    int id = dwId & 0xFFFF;
    int iType = dwId >> 30;
    char * pszType;

    switch (iType)
    {
    case 0: pszType = "Success"; break;
    case 1: pszType = "Informational"; break;
    case 2: pszType = "Warning"; break;
    case 3: pszType = "Error"; break;
    }

    if (pszFmt)
    {
        memset(ach, 0, sizeof(ach));

        va_start(va, pszFmt);
        _vsnprintf(ach, sizeof(ach) - 2, pszFmt, va);
        va_end(va);

        TraceSz(Event, "%s id %d cb %d string %s", pszType, id, cb, ach);

        psz = ach;
    }
    else
    {
        TraceSz(Event, "%s id %d cb %d", pszType, id, cb);
    }

    ULONG cbString = psz ? (strlen(psz) + 1): 0;

    if (cbString + cb > MAX_EVENT_LENGTH)
    {
        TraceSz(Event, "Event id %d contains too much data for one event. d %d s %d",
                 id, cb, cbString);

        // Truncate the event to make it fit. Favor data over strings.
        if (cb < MAX_EVENT_LENGTH)
        {
            Assert(psz);

            psz[(MAX_EVENT_LENGTH - cb - 1)] = '\0';
        }
        else
        {
            psz = NULL;
            cb = MAX_EVENT_LENGTH;
        }
    }

    // -----------------------------------------------------------------------
    // Check to see if this event should not reach the NT event log
    BOOL fFireThisEvent = TRUE;
    DWORD dwNumSkips = 0;
    DWORD dwNumSkipsTotal = 0;
    DWORD dwRecentRate = 0;

    g_lockEventThrottle.AcquireDpc();

    if (NULL != g_pEventThrottle)
    {
        BOOL fOk;
        ULONGLONG qwNow = SgGetSystemTime();

        fOk = g_pEventThrottle->ProcessEvent(
                                    qwNow,
                                    dwId,
                                    psz,
                                    (WORD)cbPkt,
                                    (DWORD *) pipaSrc,
                                    &fFireThisEvent,
                                    &dwNumSkips,
                                    &dwNumSkipsTotal,
                                    &dwRecentRate );

        if (!fOk)
        {
            fFireThisEvent = TRUE;
        }
    }

    g_lockEventThrottle.ReleaseDpc();

    if (!fFireThisEvent)
    {
        return;
    }

    // -----------------------------------------------------------------------


    SgWriteEventLogEntry(dwId, cb, pv, psz);

    if (dwNumSkips != 0)
    {
        char ach2[100];
        memset(ach2, 0, sizeof(ach2));

        _snprintf(ach2, sizeof(ach2) - 2, "EvtThrottle [%d]: skipped %d (%d total)",
            id, dwNumSkips, dwNumSkipsTotal );

        SgWriteEventLogEntry(EVENT_SG_EXTRA_DATA, 0, NULL, ach2);
    }
}

void SgWriteEventLogEntry(DWORD dwId, ULONG cb, PVOID pv, LPCSTR psz)
{
    BOOL     fOk;
    WORD     wType;
    WORD     csz;
    LPCSTR * ppsz;
    LPCSTR   apsz[1] = {psz};

    if (psz == NULL)
    {
        csz  = 0;
        ppsz = NULL;
    }
    else
    {
        csz  = 1;
        ppsz = apsz;
    }
        

    if (NT_INFORMATION(dwId))
    {
        wType = EVENTLOG_INFORMATION_TYPE;
    }
    else if (NT_WARNING(dwId))
    {
        wType = EVENTLOG_WARNING_TYPE;
    }
    else
    {
        Assert(NT_ERROR(dwId));
        wType = EVENTLOG_ERROR_TYPE;
    }

    fOk = ReportEventA(g_hEventLog, wType, 0, dwId, NULL, csz, cb, ppsz, pv);

    if (!fOk)
    {
        DWORD dwErr = GetLastError();
        TraceSz(Warning, "Could not log event id %d, error %lu", dwId, dwErr);
    }
}

// ---------------------------------------------------------------------------------------
// Writes to event log, with a common footer
// ---------------------------------------------------------------------------------------
void __cdecl SgLogPacketEvent(DWORD dwId, CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, ULONG cb, PVOID pb, LPCSTR pszText)
{
    // XCS bug 154908: there exist edge cases where ppkt->_pTransInfoRecv is not valid.  
    // This happens when the SG is trying to send a SECMSG_TYPE_DELETE as the result of an 
    // SGMSG_TYPE_KICK, for instance. 

    Assert(ppkt);

    CSpiInfo* pSpiInfo = ppkt->_pSpiInfo;

    SgLogEvent(dwId, cb, &ipaSrc, cb, pb, 
               "%s {{ mpuid[0x%I64X] spi[%X] ip[%s] tt[%c] }}",
               pszText ? pszText : "",
               (pSpiInfo == NULL) ? 0 : pSpiInfo->_puid.QuadPart,
               (pSpiInfo == NULL) ? 0 : pSpiInfo->_dwSpiRecv,
               CStrUtil().FormatIpPortN(ipaSrc, ipportSrc),
               (char) (ppkt->_pTransInfoRecv == NULL ? TRANSTYPE_NONE : ppkt->_pTransInfoRecv->_dwType));
}

// ---------------------------------------------------------------------------------------
// Writes to logfile, with a trace-like level, and event-like throttling.
//
// level 0: L_LOW
// level 1: L_NORMAL
// level 2: L_HIGH
// level 3: L_ERROR
// ---------------------------------------------------------------------------------------
void __cdecl    SgLogPacketToLog(char level,
                                 DWORD dwId, 
                                 CPacket * ppkt, 
                                 CIpAddr ipaSrc, 
                                 CIpPort ipportSrc, 
                                 DWORD dwPacketEventFilter, 
                                 LPCSTR szText)
{
    Assert(ppkt);
    Assert(ppkt->_pTransInfoRecv);

    CSpiInfo* pSpiInfo   = ppkt->_pSpiInfo;
    DWORD     id         = dwId & 0xFFFF;
    DWORD     dwNumSkips = 0;


    // -----------------------------------------------------------------------
    // Check to see if this event should not reach the log
    // @@@ optional for logfile?
    
    BOOL fFireThisEvent = TRUE;
    DWORD dwNumSkipsTotal = 0;
    DWORD dwRecentRate = 0;

    g_lockEventThrottle.AcquireDpc();

    if (NULL != g_pEventThrottle)
    {
        BOOL fOk;
        ULONGLONG qwNow = SgGetSystemTime();

        fOk = g_pEventThrottle->ProcessEvent(
                                    qwNow,
                                    dwId,
                                    NULL,
                                    0,
                                    (DWORD *) &ipaSrc,
                                    &fFireThisEvent,
                                    &dwNumSkips,
                                    &dwNumSkipsTotal,
                                    &dwRecentRate );

        if (!fOk)
        {
            fFireThisEvent = TRUE;
        }
    }

    g_lockEventThrottle.ReleaseDpc();

    if (!fFireThisEvent)
    {
        return;
    }

    // -----------------------------------------------------------------------

    // Figure out which headers the caller wants us to log. Later versions of this 
    // function could perhaps figure this out automatically.
    VOID * pEnetHdr  = NULL;
    VOID * pIpHdr    = NULL;
    VOID * pUdpHdr   = NULL;
    VOID * pXspHdr   = NULL;
    DWORD  cbEnetHdr = 0;
    DWORD  cbIpHdr   = 0;
    DWORD  cbUdpHdr  = 0;
    DWORD  cbXspHdr  = 0;

    if (dwPacketEventFilter & PEVT_FILTER_ENET)
    {
        pEnetHdr = ppkt->_pEnetHdr;
        cbEnetHdr = sizeof(CEnetHdr);
    }
    if (dwPacketEventFilter & PEVT_FILTER_IP)
    {
        pIpHdr = ppkt->_pIpHdr;
        cbIpHdr = sizeof(CIpHdr);
    }
    if (dwPacketEventFilter & PEVT_FILTER_UDP)
    {
        // XspHdr is actually the packet's UDP header. We won't show the SpiAndFlags 
        // DWORD, though, so sizeof() is only the UDP header.
        pUdpHdr = ppkt->_pXspHdr;
        cbUdpHdr = sizeof(CUdpHdr);
    }
    if (dwPacketEventFilter & PEVT_FILTER_XSP)
    {
        // Not the UDP header, just the SpiAndFlags DWORD.
        pXspHdr = &ppkt->_pXspHdr->_dwSpiAndFlags;
        cbXspHdr = sizeof(ppkt->_pXspHdr->_dwSpiAndFlags);
    }

    ULONGLONG qwMachinePuid = 0;
    if (pSpiInfo)
    {
        qwMachinePuid = pSpiInfo->_puid.QuadPart;
        // If spi info doesn't yet have the machine puid, let's try peeking in the cli 
        // info.
        if (qwMachinePuid == 0 && pSpiInfo->_pCliInfo)
        {
            qwMachinePuid = pSpiInfo->_pCliInfo->_puid.QuadPart;
        }
    }

    // Build logline. Format:
    // 
    // PEVT | eventid | numskipped | srcIp | srcPort | transporttype | mpuid | spi | 
    // enethdr | iphdr | udphdr | xsphdr | extraData 
    // 
    // Special: xmgmt logging (tracing) that we can control the level of. Not the same as 
    // the SG's "SzTrace" commands.
    SvcLogLvl(SgClientStats, level,
            "PEVT|%u|%u|%s|%hu|%c|%I64X|%X|%s|%s|%s|%s|%s",
            id,
            dwNumSkips,
            CStrUtil().FormatIpN(ipaSrc),
            ipportSrc,
            (char) ppkt->_pTransInfoRecv->_dwType,
            qwMachinePuid,
            pSpiInfo       ? pSpiInfo->_dwSpiRecv : 0,
            cbEnetHdr > 0  ? SgHexStr(pEnetHdr, cbEnetHdr) : "",
            cbIpHdr > 0    ? SgHexStr(pIpHdr, cbIpHdr) : "",
            cbUdpHdr > 0   ? SgHexStr(pUdpHdr, cbUdpHdr) : "",
            cbXspHdr > 0   ? SgHexStr(pXspHdr, cbXspHdr) : "",
            szText != NULL ? szText : "");

}


BOOL SgEventInstall()
{
    BOOL fRet    = FALSE;
    HKEY hKeyApp = NULL;
    HKEY hKeySub = NULL;
    CHAR szModuleName[MAX_PATH];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR szEventDll[MAX_PATH];
    
    static const CHAR szSvcEventRoot[] = 
        "System\\CurrentControlSet\\Services\\EventLog\\Application\\";

    // Use the path to this module to build the path to the event dll which 
    // should be located in the same directory
    if(0 == ::GetModuleFileNameA(NULL, szModuleName, dimensionof(szModuleName)))
    {
        TraceSz(Config, "GetModuleFileName failed. Error = %u", GetLastError());
        goto Exit;
    }
    
    szDrive[0]    = '\0';
    szDir[0]      = '\0';
    szEventDll[0] = '\0';
    _splitpath(szModuleName, szDrive, szDir, NULL, NULL);
    _snprintf(szEventDll, dimensionof(szEventDll), "%s%s%s", szDrive, szDir, 
        g_szEventDll);
    
    // Open the eventlog\application regkey
    if(::RegOpenKeyA(HKEY_LOCAL_MACHINE, szSvcEventRoot, &hKeyApp) != ERROR_SUCCESS)
    {
        TraceSz(Config, "RegOpenKey failed. Error = %u", GetLastError());
        goto Exit;
    }
    
    // Best effort to delete old key
    ::RegDeleteKeyA(hKeyApp, g_szEventSource);
    
    // Create the source subkey. The source is the same string we pass to 
    // RegisterEventSource when we want to send events. It's also the string
    // that will show up in the source column on Event Viewer
    if(::RegCreateKeyA(hKeyApp, g_szEventSource, &hKeySub) != ERROR_SUCCESS)
    {
        TraceSz(Config, "RegCreateKey failed. Error = %u", GetLastError());
        goto Exit;
    }
    
    // Point events from g_szEventSource to szEventDll
    if(::RegSetValueExA(hKeySub, "EventMessageFile", NULL,REG_SZ,(BYTE*)szEventDll, 
        strlen(szEventDll)+sizeof(CHAR)) != ERROR_SUCCESS)
    {
        TraceSz(Config, "RegSetValueEx failed. Error = %u", GetLastError());
        goto Exit;
    }
    
    DWORD dwVal = 0x0000000b;
    if(::RegSetValueExA(hKeySub, "TypesSupported", NULL, REG_DWORD, 
        (BYTE*)&dwVal, sizeof(DWORD)) != ERROR_SUCCESS)
    {
        TraceSz(Config, "RegSetValueEx failed. Error = %u", GetLastError());
        goto Exit;
    }
    
    fRet = TRUE;
    
Exit:

    if(hKeyApp != NULL)
        ::RegCloseKey(hKeyApp);
    
    if(hKeySub != NULL)
        ::RegCloseKey(hKeySub);

    return fRet;
}


// ---------------------------------------------------------------------------------------
// CHashTable
// ---------------------------------------------------------------------------------------

UINT g_iHashTableOverheadPct;           // Percent overhead to add to hash tables

BOOL CHashTable::Init(UINT cEnt, ULONG tag, PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare, PFNHFREE pfnFree, PFNHDUMP pfnDump)
{
    // Base the number of buckets we allocate on the maximum number of entries, scaled
    // up by a constant factor and then rounded up to the next highest prime number.
    // The idea is to keep hash collisions to a minimum at the cost of additional memory.

    Assert(g_iHashTableOverheadPct > 0);
    UINT cBucket = cEnt * (100 + g_iHashTableOverheadPct) / 100;

    static DWORD s_adwPrimes[] = { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

    DWORD * pdwPrime = s_adwPrimes;
    for (; cBucket > *pdwPrime; pdwPrime++) ;
    cBucket = *pdwPrime;

    _ple = (LIST_ENTRY *)SgMemAlloc(cBucket * sizeof(LIST_ENTRY), tag);

    if (_ple == NULL)
    {
        return(FALSE);
    }

    _cBucket    = cBucket;
    _cEnt       = 0;
    _pfnCompute = pfnCompute;
    _pfnCompare = pfnCompare;
    _pfnFree    = pfnFree;
    _pfnDump    = pfnDump;

    for (LIST_ENTRY * ple = _ple; cBucket > 0; --cBucket, ++ple)
    {
        InitializeListHead(ple);
    }

    return(TRUE);
}

void CHashTable::Term()
{
    SgMemFree(_ple);
    _ple = NULL;
}

void CHashTable::Free()
{
    if (_pfnFree == NULL)
        return;

    UINT         cBucket = _cBucket;
    LIST_ENTRY * pleHead;

    for (pleHead = _ple; cBucket > 0; cBucket--, pleHead++)
    {
        LIST_ENTRY * pleNext;

        for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = pleNext)
        {
            pleNext = ple->Flink;
            _pfnFree(ple);
        }
        InitializeListHead(pleHead);
    }
}

void CHashTable::Dump()
{
    if (_pfnDump == NULL)
        return;

    UINT         cBucket = _cBucket;
    LIST_ENTRY * pleHead;

    for (pleHead = _ple; cBucket > 0; cBucket--, pleHead++)
    {
        LIST_ENTRY * pleNext;

        for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = pleNext)
        {
            pleNext = ple->Flink;
            _pfnDump(ple);
        }
    }
}

LIST_ENTRY * CHashTable::Lookup(LIST_ENTRY * pleLok)
{
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleLok) % _cBucket];

    for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        if (_pfnCompare(pleLok, ple))
        {
            return(ple);
        }
    }

    return(NULL);
}

void CHashTable::Insert(LIST_ENTRY * pleIns)
{
    Assert(pleIns->Flink == NULL);
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleIns) % _cBucket];
    InsertTailList(pleHead, pleIns);
    _cEnt += 1;
}

void CHashTable::Delete(LIST_ENTRY * pleDel)
{
    Assert(pleDel->Flink != NULL);
    Assert(Lookup(pleDel) == pleDel);

    RemoveEntryList(pleDel);
    pleDel->Flink = NULL;

    Assert(_cEnt > 0);
    _cEnt -= 1;
}

BOOL SgHashConfig(CCfgInfo* pci)
{
    TraceSz( Config, "SgHashConfig:" );

    if(!pci->GetVar("HashTableOverheadInPercent", &g_iHashTableOverheadPct, 20, 200, 60))
        return FALSE;
    
    TraceSz(Config, "Configured hash table overhead to %d%%", g_iHashTableOverheadPct);

    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// SgMemAlloc
// ---------------------------------------------------------------------------------------

HANDLE g_hHeap;

BOOL SgMemInit()
{
    BOOL success;

    g_hHeap = HeapCreate(
        0,      // flOptions
        0,      // dwInitialSize
        0       // dwMaximumSize
        );

    if(g_hHeap == NULL)
    {
        // Nt events cannot be logged at this point yet
        return FALSE;
    }

    ULONG HeapInformation = 2; // Enable low-fragmenting-heap

    HeapSetInformation(
        g_hHeap,
        HeapCompatibilityInformation,
        &HeapInformation,
        sizeof(HeapInformation));

    return TRUE;
}

BOOL SgMemConfig(CCfgInfo* pci)
{
    UNREFERENCED_PARAMETER(pci);
    TraceSz( Config, "SgMemConfig:" );
    return(TRUE);
}

void SgMemTerm()
{
    if(g_hHeap)
    {
        HeapDestroy(g_hHeap);
        g_hHeap = NULL;
    }
}

void * SgMemAlloc(size_t cb, ULONG tag)
{
    void * pv = HeapAlloc(g_hHeap, 0, cb);

    return(pv);
}

void * SgMemReAlloc(void * pv, size_t cb, ULONG tag)
{
    void * newpv = HeapReAlloc(g_hHeap, 0, pv, cb);

    return newpv;
}

void * SgMemAllocZ(size_t cb, ULONG tag)
{
    void * pv = HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, cb);

    return(pv);
}

void SgMemFree(void * pv)
{
    if (pv)
    {
        HeapFree(g_hHeap, 0, pv);
    }
}

// ---------------------------------------------------------------------------------------
// Time functions
// ---------------------------------------------------------------------------------------

ULONGLONG g_qwSystemTimeOffset;

ULONGLONG SgGetSystemTime()
{ 
    ULONGLONG qw; 
    GetSystemTimeAsFileTime( (LPFILETIME) &qw ); 
    return qw + g_qwSystemTimeOffset; 
}

BOOLEAN
SgTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )
{
    SYSTEMTIME sysTime;
    sysTime.wYear = TimeFields->Year;
    sysTime.wMonth = TimeFields->Month;
    sysTime.wDayOfWeek = TimeFields->Weekday;
    sysTime.wDay = TimeFields->Day;
    sysTime.wHour = TimeFields->Hour;
    sysTime.wMinute = TimeFields->Minute;
    sysTime.wSecond = TimeFields->Second;
    sysTime.wMilliseconds = TimeFields->Milliseconds;
    return (BOOLEAN) SystemTimeToFileTime( (CONST SYSTEMTIME *)&sysTime, (LPFILETIME) Time );
}

VOID
SgTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )
{
    SYSTEMTIME sysTime;
    FileTimeToSystemTime( (LPFILETIME)Time, (LPSYSTEMTIME)&sysTime );
    TimeFields->Year = sysTime.wYear;
    TimeFields->Month = sysTime.wMonth;
    TimeFields->Weekday = sysTime.wDayOfWeek;
    TimeFields->Day = sysTime.wDay;
    TimeFields->Hour = sysTime.wHour;
    TimeFields->Minute = sysTime.wMinute;
    TimeFields->Second = sysTime.wSecond;
    TimeFields->Milliseconds = sysTime.wMilliseconds;
}

// ---------------------------------------------------------------------------------------
// NULL cipher override functions
// ---------------------------------------------------------------------------------------

struct CNullCipherMachineInfo
{
    ULONGLONG machineId;
};

int __cdecl CompareNullMachineInfo(void *context, const void *pElem1, const void *pElem2)
{
    UNREFERENCED_PARAMETER(context);

    CNullCipherMachineInfo *p1 = (CNullCipherMachineInfo*)pElem1;
    CNullCipherMachineInfo *p2 = (CNullCipherMachineInfo*)pElem2;

    if (p1->machineId < p2->machineId)
        return -1;
    else if (p1->machineId > p2->machineId)
        return 1;
    else
        return 0;
}


CNullCipherMachineInfo  *g_pNullMachineInfo;
DWORD                   g_cNullMachineInfo;
CReaderWriterLock3      g_lockNull;

BOOL SgNullCipherInit()
{
    g_pNullMachineInfo = NULL;
    g_cNullMachineInfo = 0;

    return TRUE;
}

void SgNullCipherTerm()
{
    if (g_pNullMachineInfo)
    {
        SgMemFree(g_pNullMachineInfo);
        g_pNullMachineInfo = NULL;
    }
    g_cNullMachineInfo = 0;
}

BOOL SgNullCipherConfig(CCfgInfo* pci)
{ 
    TraceSz(Config, "SgNullCipherConfig:"); 

    // @@@ reload case, be smarter

    DWORD                   cNullMachineInfo = 0;
    CNullCipherMachineInfo  *pNullMachineInfo = NULL;

    DWORD cMachines = pci->Count("NullMachineId");

    if (cMachines == 0)
    {
        goto Exit;
    }

    // Allocate the memory

    pNullMachineInfo = (CNullCipherMachineInfo*)SgMemAlloc(cMachines * sizeof(CNullCipherMachineInfo), PTAG_NullCipher);
    
    if (!pNullMachineInfo)
    {
        SgEventSz(CONFIG_ERROR, "Failed allocating %d bytes for %d NullMachineId objects", 
                   cMachines * sizeof(CNullCipherMachineInfo), cMachines);
        return FALSE;
    }


    // Loop through and parse each setting

    ULONGLONG machineId = 0;
    CCfgInfo * pciMachine = NULL;
    CCfgInfo * pciT;

    while (1)
    {
        pciMachine = pci->FindNonList("NullMachineId", pciMachine, FALSE);

        if (pciMachine == NULL)
            break;

        // Get machine ID
        if (!pciMachine->_csValue.GetNum(&machineId))
        {
            SgEventSz(CONFIG_ERROR, "'%hs' has invalid value '%hs'. It must be a 64-bit number.",
                       pciMachine->_csName.Str(), pciMachine->_csValue.Str());
            TraceSz(Config, "  Invalid value '%hs'", pciMachine->_csValue.Str());
            continue;
        }

        Assert(cNullMachineInfo < cMachines);
        pNullMachineInfo[cNullMachineInfo++].machineId = machineId;

        TraceSz(Config, "  Machine 0x%016I64X is NULL enabled", machineId);
    }

    // Sort the list

    qsort_s(
        pNullMachineInfo, 
        cNullMachineInfo, 
        sizeof(CNullCipherMachineInfo), 
        CompareNullMachineInfo, 
        NULL);

Exit:

    // Swap in/out memory

    g_lockNull.WriteLock();
    if (g_pNullMachineInfo)
    {
        SgMemFree(g_pNullMachineInfo);
    }
    g_pNullMachineInfo = pNullMachineInfo;
    g_cNullMachineInfo = cNullMachineInfo;
    g_lockNull.WriteUnlock();

    return(TRUE);
}

BOOL SgNullCipherCheckMachine(ULONGLONG machineId)
{
    // Optimize mainline case
    if (g_cNullMachineInfo == 0 || !g_pNullMachineInfo)
    {
        return FALSE;
    }

    CNullCipherMachineInfo key = { machineId };
    CNullCipherMachineInfo *pInfo = NULL;

    g_lockNull.ReadLock();
    if (g_pNullMachineInfo)
    {
        // binary search...
        pInfo = (CNullCipherMachineInfo*)bsearch_s(
            &key, 
            g_pNullMachineInfo, 
            g_cNullMachineInfo, 
            sizeof(CNullCipherMachineInfo), 
            CompareNullMachineInfo,
            NULL);
    }
    g_lockNull.ReadUnlock();

    return pInfo != NULL;

}


#if 0

//
// C implementation of the tcpipxsum that we have in i386 assembly. This was copied and 
// modified from \private\server\presence\test\ptncore\NetStruct.cpp, which was made
// from http://www.ietf.org/rfc/rfc1071.txt.
// 
// I found a 64-bit implementation in assembly for tcpipxsum, so it no longer appears we 
// need to use this C version. Leaving it here in case we decide to move from ASM to C in 
// the future.
//
// @@@kgoodier PLEASE TEST THIS BEFORE USING! IT MAY NOT WORK.

WORD tcpipxsum(WORD xsum, const void *pb, UINT cb)
{
    WORD *sdata = (WORD*)pb;
    register unsigned long sum = (unsigned long)xsum;

    // Accumulate 16 bit values from data
    while(cb > 1)
    {
        sum += *sdata++;
        cb -= 2;
    }

    // Add left-over byte if any
    if(cb > 0) 
    {
        sum += *((BYTE*)sdata);
    }

    // Fold 32-bit sum to 16 bits
    while(sum>>16)
    {
        sum = (sum & 0xffff) + (sum >> 16);
    }

    //return ~(sum & 0xffff);
    return (WORD)(sum);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgsvcmsg.cpp ===
// ---------------------------------------------------------------------------------------
// sgsvcmsg.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ---------------------------------------------------------------------------------------

#include "sg.h"

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

DWORD g_fLogClientUpdates;

// ---------------------------------------------------------------------------------------
// Forward Declarations
// ---------------------------------------------------------------------------------------



// ---------------------------------------------------------------------------------------
// SgServiceMsgHandlerConfig - configure message handling layer
// ---------------------------------------------------------------------------------------
BOOL SgServiceMsgHandlerConfig(CCfgInfo* pci)
{
    TraceSz(Config, "SgServiceMsgHandlerConfig:");

    if(!pci->GetVar("LogClientUpdates", &g_fLogClientUpdates, 0, 1, 0))
        return FALSE;

    TraceSz(Config, "    Configured LogClientUpdates to %u (%s)", g_fLogClientUpdates,
             g_fLogClientUpdates ? "TRUE" : "FALSE");

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// SgIndicateSgSvcClient
// ---------------------------------------------------------------------------------------

void 
SgIndicateSgSvcClientAdd(
    CSpiInfo * pSpiInfo,
    WORD       wType,
    PVOID      pv
    )
{
    Assert(pv != NULL);
    CAuthData4 *            pAuthData   = &pSpiInfo->_AuthData;
    CKeyExCtx *             pKeyExCtx   = (CKeyExCtx *)(pv);
    LARGE_INTEGER           liNonce     = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);
    SGADDR                  sgaddr;

    SgSpiInfoToSgAddr(pSpiInfo, &sgaddr);

    // Convert the Kerberos FILETIME 64-bit integer to a more meaningful SYSTEMTIME
    // structure. We'll do our own formatting.
    SYSTEMTIME EndTime;
    FileTimeToSystemTime((FILETIME*)&pKeyExCtx->_liEndTime, &EndTime);

#define ADDCHGLOGFORMAT \
"%s|%I64X|%I64X|%X|%X|%X|%X|%X|%X|%X|%X|%X|%X|%X|%X|%I64X|%X|%f|%X|%X|%X|%I64X|%X|%f|%X|%X|%X|%I64X|%X|%f|%X|%X|%X|%I64X|%X|%f|%X|%X|%X|%X|%X|%X|%X|%X|%X|%X|%X|"INAFMT"|%X|"INAFMT"|%X|%X|%d.%d.%d.%d|%X|"SYSTEMTIMEFMT

#define ADDCHGLOGTEXT \
(wType == SGSVC_TYPE_CLIENT_ADD ? "ADD" : "CHG"), \
pAuthData->qwXboxID,  \
liNonce.QuadPart, \
pAuthData->dwTitleID, \
pAuthData->dwTitleVersion, \
pAuthData->dwTitleRegion,  \
pAuthData->dwConsoleRegion, \
pAuthData->dwMediaID, \
pAuthData->wLanguageID, \
pAuthData->dwAuthDataFlags, \
pAuthData->dwBaseServices[0], \
pAuthData->dwBaseServices[1],  \
pAuthData->dwBaseServices[2], \
pAuthData->dwBaseServices[3],  \
pAuthData->dwMachinePrivileges[0], \
pAuthData->users[0].qwUserID, \
pAuthData->users[0].dwUserFlags, \
pAuthData->afltTrustFactor[0], \
pAuthData->dwUserPrivileges[0][0], \
pAuthData->dwUserPrivileges[0][1], \
pAuthData->dwUserPrivileges[0][2], \
pAuthData->users[1].qwUserID, \
pAuthData->users[1].dwUserFlags,  \
pAuthData->afltTrustFactor[1], \
pAuthData->dwUserPrivileges[1][0], \
pAuthData->dwUserPrivileges[1][1], \
pAuthData->dwUserPrivileges[1][2], \
pAuthData->users[2].qwUserID,  \
pAuthData->users[2].dwUserFlags,  \
pAuthData->afltTrustFactor[2], \
pAuthData->dwUserPrivileges[2][0], \
pAuthData->dwUserPrivileges[2][1], \
pAuthData->dwUserPrivileges[2][2], \
pAuthData->users[3].qwUserID,  \
pAuthData->users[3].dwUserFlags,  \
pAuthData->afltTrustFactor[3], \
pAuthData->dwUserPrivileges[3][0], \
pAuthData->dwUserPrivileges[3][1], \
pAuthData->dwUserPrivileges[3][2], \
pAuthData->dwExtendedServices[0],  \
pAuthData->dwExtendedServices[1],   \
pAuthData->dwExtendedServices[2],  \
pAuthData->dwExtendedServices[3], \
pAuthData->dwAltTitleID[0],  \
pAuthData->dwAltTitleID[1], \
pAuthData->dwAltTitleID[2],  \
pAuthData->dwAltTitleID[3], \
INAPRM((IN_ADDR*)&pSpiInfo->_ipaI),  \
ntohs(pSpiInfo->_ipportI), \
INAPRM((IN_ADDR*)&(pSpiInfo->_pNatInfo ? pSpiInfo->_pNatInfo->_ipaZ : 0)),  \
ntohs((g_fPortTranslation && pSpiInfo->_pNatInfo) ? HTONS((USHORT) pSpiInfo->_pNatInfo->_iBasePortZ) : 0), \
sgaddr.dwSpiSg, \
pAuthData->clientVersion.wMajorVersion, \
pAuthData->clientVersion.wMinorVersion, \
pAuthData->clientVersion.wBuildNumber, \
(pAuthData->clientVersion.wQFENumber & 0x7FFF), \
pKeyExCtx->_dwSiteId, \
SYSTEMTIMEPRM(&EndTime)

    //
    // log a message
    //
    if (pAuthData->GetPlatform() != XPLT_PC)
    {
        SvcLogFT(log, pAuthData->flowToken, ADDCHGLOGFORMAT, ADDCHGLOGTEXT);
    }
    else
    {
        SvcLogFT(LogWindows, pAuthData->flowToken, ADDCHGLOGFORMAT, ADDCHGLOGTEXT);
    }
    // }}}

#undef ADDCHGLOGFORMAT
#undef ADDCHGLOGTEXT

    // Send notification of changed users if connection services are enabled.
    if (pSpiInfo->_fCs) 
    {
        SGADDR sgaddr;

        SgSpiInfoToSgAddr( pSpiInfo, &sgaddr );

        // If the spi was reinitialized, then send the correct notify
        if (pSpiInfo->_dwSpiOld != 0) 
        {
            SgServiceNotifySpiUpdate(
                &sgaddr,
                pSpiInfo->_dwSpiOld
                );
        }

        // Send the user change notification
        SgServiceNotifyCliUserChange(
            &sgaddr,
            (XOnlineIsUserGuest(pAuthData->users[0].dwUserFlags) == FALSE ? pAuthData->users[0].qwUserID : 0),
            (XOnlineIsUserGuest(pAuthData->users[1].dwUserFlags) == FALSE ? pAuthData->users[1].qwUserID : 0),
            (XOnlineIsUserGuest(pAuthData->users[2].dwUserFlags) == FALSE ? pAuthData->users[2].qwUserID : 0),
            (XOnlineIsUserGuest(pAuthData->users[3].dwUserFlags) == FALSE ? pAuthData->users[3].qwUserID : 0),
            pSpiInfo->_ipaI,
            SECMSG_CLIUSERCHANGE_TYPE_ADD
            );
    }

}


void
SgIndicateSgSvcClientChallenge(
    CSpiInfo      * pSpiInfo,
    CLogChallenge * pLogChallenge,
    BYTE          * pbExe,
    UINT            cbExe
    )
{
    BYTE          * pbEndExe  = pbExe + cbExe - 1;
    CAuthData4    * pAuthData = &pSpiInfo->_AuthData;
    LARGE_INTEGER   liNonce   = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);

    // Remove the empty bytes at the end of the buffer
    while ((*pbEndExe == 0) && (pbEndExe > pbExe))
    {
        pbEndExe--;
        cbExe--;
    }

    if (pAuthData->GetPlatform() != XPLT_PC)
    {
        SvcLog(LogCode, "%I64X|%I64X|%X|%X|%X|%X|%s|%X|%X|%X|%d.%d.%d.%d|%I64X|%I64X|%I64X|%I64X|"INAFMT,
            pAuthData->qwXboxID,
            liNonce.QuadPart,
            pLogChallenge->_fCodeLog,
            pLogChallenge->_fCodeKick,
            pLogChallenge->_dwChalCodeId,
            pLogChallenge->_iChalCodeParam,
            SgSvcHexStr(pbExe, cbExe),
            pAuthData->dwTitleID,
            pAuthData->dwTitleRegion,
            pAuthData->dwTitleVersion,
            pAuthData->clientVersion.wMajorVersion,
            pAuthData->clientVersion.wMinorVersion,
            pAuthData->clientVersion.wBuildNumber,
            (pAuthData->clientVersion.wQFENumber & 0x7FFF),
            pAuthData->users[0].qwUserID,
            pAuthData->users[1].qwUserID,
            pAuthData->users[2].qwUserID,
            pAuthData->users[3].qwUserID,
            INAPRM((IN_ADDR*)&pSpiInfo->_ipaI)
            );
    }
    else
    {
        SvcLog(LogCodeWindows, "%I64X|%I64X|%X|%X|%X|%X|%s|%X|%X|%X|%d.%d.%d.%d",
            pAuthData->qwXboxID,
            liNonce.QuadPart,
            pLogChallenge->_fCodeLog,
            pLogChallenge->_fCodeKick,
            pLogChallenge->_dwChalCodeId,
            pLogChallenge->_iChalCodeParam,
            SgSvcHexStr(pbExe, cbExe),
            pAuthData->dwTitleID,
            pAuthData->dwTitleRegion,
            pAuthData->dwTitleVersion,
            pAuthData->clientVersion.wMajorVersion,
            pAuthData->clientVersion.wMinorVersion,
            pAuthData->clientVersion.wBuildNumber,
            (pAuthData->clientVersion.wQFENumber & 0x7FFF)
            );
    }
}

void
SgIndicateSgSvcClientChallenge(
    CSpiInfo      * pSpiInfo,
    CLogChallenge * pLogChallenge,
    PVOID           pv
    )
{
    BYTE       * pbBuffer = NULL; 
    UINT         cbBuffer = 0; 
    CSecMsgHdr * pSecMsgHdr = (CSecMsgHdr *) pv;

    // log code response
    if (pLogChallenge->_fCodeLog  == FALSE &&
        pLogChallenge->_fCodeKick == FALSE)
    {
        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP) 
    {
        CSecMsgXbToSgChalResp * pSecMsgChal = (CSecMsgXbToSgChalResp *)pSecMsgHdr;

        pbBuffer = pSecMsgChal->_abExecute;
        cbBuffer = sizeof(pSecMsgChal->_abExecute);
    }
    else if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP_2)
    {
        CSecMsgXbToSgChalResp2 * pSecMsgChal = (CSecMsgXbToSgChalResp2 *)pSecMsgHdr;

        pbBuffer = pSecMsgChal->_abExecute;
        cbBuffer = sizeof(pSecMsgChal->_abExecute);
    }
    else if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOSG_CHALRESP_3) 
    {
        CSecMsgXbToSgChalResp3 * pSecMsgChal = (CSecMsgXbToSgChalResp3 *)pSecMsgHdr;

        pbBuffer = pSecMsgChal->_abExecute;
        cbBuffer = sizeof(pSecMsgChal->_abExecute);
    }
    else
    {
        return;
    }

    SgIndicateSgSvcClientChallenge( pSpiInfo, pLogChallenge, pbBuffer, cbBuffer );
}

void
SgIndicateSgSvcClientLua(
    CSpiInfo * pSpiInfo,
    PVOID      pv
    )
{
    CAuthData4 * pAuthData = &pSpiInfo->_AuthData;
    LARGE_INTEGER liNonce  = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);
    char       * pMsg      = (char *)(pv);

    char szFloken[2 + sizeof(FLOKEN)*2 + 1];
    if (pAuthData->flowToken.IsValid())
    {
        safe_snprintf(szFloken, ARRAYSIZE(szFloken), "FT%016I64X", pAuthData->flowToken.flowToken);
    }
    else
    {
        safe_snprintf(szFloken, ARRAYSIZE(szFloken), "FT0");
    }

    // Copy the data to the output buffer
    SvcLog(lua,"%016I64X|%I64X|%s|%s", pAuthData->qwXboxID, liNonce, szFloken, pMsg );
}

void
SgIndicateSgSvcClientDelete(
    CSpiInfo * pSpiInfo
    )
{
    CAuthData4 *  pAuthData = &pSpiInfo->_AuthData;
    LARGE_INTEGER liNonce   = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);

    Assert(pSpiInfo->_dwDeleteReason < MAX_SPIDEL);

    // log a message and send a notification. There are 2 extra fields at the end if
    // the reason is SPIDEL_CHALLENGE_LUA, aka the client got kicked by a challenge.
    if (pSpiInfo->_dwDeleteReason != SPIDEL_CHALLENGE_LUA)
    {
        if (pAuthData->GetPlatform() != XPLT_PC)
        {
            SvcLogFT(log, pAuthData->flowToken, "DEL|%I64X|%I64X|%X|||"INAFMT,
                pAuthData->qwXboxID,
                liNonce.QuadPart,
                pSpiInfo->_dwDeleteReason,
                INAPRM((IN_ADDR*)&pSpiInfo->_ipaI)
                );
        }
        else
        {
            SvcLogFT(LogWindows, pAuthData->flowToken, "DEL|%I64X|%I64X|%X|||"INAFMT,
                pAuthData->qwXboxID,
                liNonce.QuadPart,
                pSpiInfo->_dwDeleteReason,
                INAPRM((IN_ADDR*)&pSpiInfo->_ipaI)
                );
        }
    }
    else
    {
        if (pAuthData->GetPlatform() != XPLT_PC)
        {
            SvcLogFT(log, pAuthData->flowToken, "DEL|%I64X|%I64X|%X|%X|%X|"INAFMT,
                pAuthData->qwXboxID,
                liNonce.QuadPart,
                pSpiInfo->_dwDeleteReason,
                pSpiInfo->_dwLuaChalCodeId,
                pSpiInfo->_dwLuaChalCodeParamId,
                INAPRM((IN_ADDR*)&pSpiInfo->_ipaI)
                );
        }
        else
        {
            SvcLogFT(LogWindows, pAuthData->flowToken, "DEL|%I64X|%I64X|%X|%X|%X|"INAFMT,
                pAuthData->qwXboxID,
                liNonce.QuadPart,
                pSpiInfo->_dwDeleteReason,
                pSpiInfo->_dwLuaChalCodeId,
                pSpiInfo->_dwLuaChalCodeParamId,
                INAPRM((IN_ADDR*)&pSpiInfo->_ipaI)
                );
        }
    }

    // Send notification if connection services is enabled. The client only uses the
    // SGADDR from the CS SG, so this makes sense.
    if (pSpiInfo->_fCs)
    {
        SGADDR        sgaddr;

        SgSpiInfoToSgAddr(pSpiInfo, &sgaddr);
        SgServiceNotifyCliUserChange(
            &sgaddr,
            (XOnlineIsUserGuest(pAuthData->users[0].dwUserFlags) == FALSE ? pAuthData->users[0].qwUserID : 0),
            (XOnlineIsUserGuest(pAuthData->users[1].dwUserFlags) == FALSE ? pAuthData->users[1].qwUserID : 0),
            (XOnlineIsUserGuest(pAuthData->users[2].dwUserFlags) == FALSE ? pAuthData->users[2].qwUserID : 0),
            (XOnlineIsUserGuest(pAuthData->users[3].dwUserFlags) == FALSE ? pAuthData->users[3].qwUserID : 0),
            pSpiInfo->_ipaI,
            SECMSG_CLIUSERCHANGE_TYPE_DEL
            );
        SgServiceNotifyCliDelete(
            &sgaddr,
            pAuthData->dwTitleID 
            );

    }
}

void
SgIndicateSgSvcClientFlowmap(
    CSpiInfo * pSpiInfo
    )
{
    CAuthData4 *  pAuthData = &pSpiInfo->_AuthData;
    LARGE_INTEGER liNonce   = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);

    char szFloken[2 + sizeof(FLOKEN)*2 + 1];
    if (pAuthData->flowToken.IsValid())
    {
        safe_snprintf(szFloken, ARRAYSIZE(szFloken), "FT%016I64X", pAuthData->flowToken.flowToken);
    }
    else
    {
        safe_snprintf(szFloken, ARRAYSIZE(szFloken), "FT0");
    }


    // Find first real user and use the countryid of her. It should be noted that 
    // users are possibily in reverse-controller order. That is, the "main" user with 
    // the first controller is likely at pAuthData->users[3]. It's backwards, but this 
    // logic of looping from 0-3 is consistent with what stringserver is doing.
    DWORD dwCountryId = 0;
    for (DWORD i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
    {
        XUID *pUser = &pAuthData->users[i];
        if (pUser->qwUserID != 0 && !XOnlineIsUserGuest(pUser->dwUserFlags))
        {
            dwCountryId = XOnlineUserCountryId(pUser->dwUserFlags);
            break;
        }
    }

    SgPerfdataInterlockedInc(LoglinesFlowmap);
    SvcLog(Reporting, "SGFLOWMAP|%016I64X|%s|%I64X|%I64X|%I64X|%I64X|%I64X|%X|%X|%X|%X",
        liNonce.QuadPart,
        szFloken,
        pAuthData->qwXboxID,
        pAuthData->users[0].qwUserID,
        pAuthData->users[1].qwUserID,
        pAuthData->users[2].qwUserID,
        pAuthData->users[3].qwUserID,
        dwCountryId,
        pAuthData->dwTitleID,
        pAuthData->dwTitleVersion,
        CLIENTVERSION_TO_DWORD(pAuthData->clientVersion)
        );
}

void
SgIndicateSgSvcClientServiceChange(
    CSpiInfo * pSpiInfo
    )
{
    CAuthData4    * pAuthData     = &pSpiInfo->_AuthData;
    LARGE_INTEGER   liNonce       = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);

#define SCHGLOGFORMAT \
"%s|%I64X|%I64X|%X|%X|%X|%X|%X|%X|%X|%X|%X|%X"

#define SCHGLOGTEXT \
"SCHG", \
pAuthData->qwXboxID, \
liNonce.QuadPart, \
pAuthData->dwAuthDataFlags, \
pAuthData->dwBaseServices[0], \
pAuthData->dwBaseServices[1], \
pAuthData->dwBaseServices[2], \
pAuthData->dwBaseServices[3], \
pAuthData->dwMachinePrivileges[0], \
pAuthData->dwExtendedServices[0], \
pAuthData->dwExtendedServices[1], \
pAuthData->dwExtendedServices[2], \
pAuthData->dwExtendedServices[3]

    // log a message and send a notification
    if (pAuthData->GetPlatform() != XPLT_PC)
    {
        SvcLogFT(log, pAuthData->flowToken, SCHGLOGFORMAT, SCHGLOGTEXT );
    }
    else
    {
        SvcLogFT(LogWindows, pAuthData->flowToken, SCHGLOGFORMAT, SCHGLOGTEXT );
    }

#undef SCHGLOGFORMAT
#undef SCHGLOGTEXT
}

void
SgIndicateSgSvcClientTitleChange(
    CSpiInfo * pSpiInfo
    )
{
    CAuthData4    * pAuthData     = &pSpiInfo->_AuthData;
    LARGE_INTEGER   liNonce       = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);

#define TCHGLOGFORMAT \
"%s|%I64X|%I64X|%X|%X|%X|%X|%X|%X|%X"

#define TCHGLOGTEXT \
"TCHG", \
pAuthData->qwXboxID, \
liNonce.QuadPart, \
pAuthData->dwTitleID, \
pAuthData->dwTitleVersion, \
pAuthData->dwTitleRegion, \
pAuthData->dwAltTitleID[0], \
pAuthData->dwAltTitleID[1], \
pAuthData->dwAltTitleID[2], \
pAuthData->dwAltTitleID[3]

    // log a message and send a notification
    if (pAuthData->GetPlatform() != XPLT_PC)
    {
        SvcLogFT(log, pAuthData->flowToken, TCHGLOGFORMAT, TCHGLOGTEXT );
    }
    else
    {
        SvcLogFT(LogWindows, pAuthData->flowToken, TCHGLOGFORMAT, TCHGLOGTEXT );
    }

#undef TCHGLOGFORMAT
#undef TCHGLOGTEXT

    if (pSpiInfo->_fCs)
    {
        SGADDR        sgaddr;

        SgSpiInfoToSgAddr(pSpiInfo, &sgaddr);
        SgServiceNotifyCliTitleChange(
            &sgaddr,
            pSpiInfo->_dwLastTitleId,
            pSpiInfo->_AuthData.dwTitleID 
            );
    }

    // We only want to send notification once
    pSpiInfo->_dwLastTitleId = pSpiInfo->_AuthData.dwTitleID;
}

void
SgIndicateSgSvcClientUserChange(
    CSpiInfo * pSpiInfo,
    PVOID      pv
    )
{
    CAuthData4    * pAuthData     = &pSpiInfo->_AuthData;
    LARGE_INTEGER   liNonce       = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);
    CUserInfo     * pUserInfo     = (CUserInfo *) pv;

#define UCHGLOGFORMAT \
"%s|%I64X|%I64X|%I64X|%X|%f|%X|%X|%X|%I64X|%X|%f|%X|%X|%X|%I64X|%X|%f|%X|%X|%X|%I64X|%X|%f|%X|%X|%X"

#define UCHGLOGTEXT \
"UCHG", \
pAuthData->qwXboxID, \
liNonce.QuadPart, \
pAuthData->users[0].qwUserID, \
pAuthData->users[0].dwUserFlags, \
pAuthData->afltTrustFactor[0], \
pAuthData->dwUserPrivileges[0][0], \
pAuthData->dwUserPrivileges[0][1], \
pAuthData->dwUserPrivileges[0][2], \
pAuthData->users[1].qwUserID, \
pAuthData->users[1].dwUserFlags, \
pAuthData->afltTrustFactor[1], \
pAuthData->dwUserPrivileges[1][0], \
pAuthData->dwUserPrivileges[1][1], \
pAuthData->dwUserPrivileges[1][2], \
pAuthData->users[2].qwUserID, \
pAuthData->users[2].dwUserFlags, \
pAuthData->afltTrustFactor[2], \
pAuthData->dwUserPrivileges[2][0], \
pAuthData->dwUserPrivileges[2][1], \
pAuthData->dwUserPrivileges[2][2], \
pAuthData->users[3].qwUserID, \
pAuthData->users[3].dwUserFlags, \
pAuthData->afltTrustFactor[3], \
pAuthData->dwUserPrivileges[3][0], \
pAuthData->dwUserPrivileges[3][1], \
pAuthData->dwUserPrivileges[3][2]

    // log a message
    if (pAuthData->GetPlatform() != XPLT_PC)
    {
        SvcLogFT(log, pAuthData->flowToken, UCHGLOGFORMAT, UCHGLOGTEXT );
    }
    else
    {
        SvcLogFT(LogWindows, pAuthData->flowToken, UCHGLOGFORMAT, UCHGLOGTEXT );
    }

#undef UCHGLOGFORMAT
#undef UCHGLOGTEXT

    if (pSpiInfo->_fCs)
    {
        BOOL          bFound;
        INT           i, j;
        SGADDR        sgaddr;
        ULONGLONG     qwUserID[XONLINE_MAX_LOGON_USERS];

        SgSpiInfoToSgAddr(pSpiInfo, &sgaddr);

        //
        // Determine all the users that disappeared.
        // 
        bFound = FALSE;
        for (i = 0 ; i < XONLINE_MAX_LOGON_USERS; ++i) 
        {
            qwUserID[i] = pUserInfo[i]._qwUserId;
            if (qwUserID[i] == 0) 
            {
                continue;
            }

            // Note that we don't have to worry about guest
            // users since they aren't stored in the pUserInfo 
            // array

            for (j = 0; j < XONLINE_MAX_LOGON_USERS; ++j) 
            {
                if (pAuthData->users[j].qwUserID == qwUserID[i]) 
                {
                    qwUserID[i] = 0;
                    break;
                }
            }

            if (qwUserID[i] != 0) 
            {
                bFound = TRUE;
            }
        }
        if (bFound == TRUE) 
        {
            SgServiceNotifyCliUserChange(
                &sgaddr,
                qwUserID[0],
                qwUserID[1],
                qwUserID[2],
                qwUserID[3],
                pSpiInfo->_ipaI,
                SECMSG_CLIUSERCHANGE_TYPE_DEL
                );
            bFound = FALSE;
        }

        //
        // Determine all the users that appeared.
        // 
        for (i = 0; i < XONLINE_MAX_LOGON_USERS; ++i) 
        {
            qwUserID[i] = pAuthData->users[i].qwUserID;
            if (qwUserID[i] == 0) 
            {
                continue;
            }

            // Skip guest users. Since we are looking at the authdata
            // and we added a fake entry for guests, we have to ignore
            // any puid that we setup for those guests

            if (XOnlineIsUserGuest(pAuthData->users[i].dwUserFlags))
            {
                qwUserID[i] = 0;
                continue;
            }

            for (j = 0; j < XONLINE_MAX_LOGON_USERS; ++j) 
            {
                if (pUserInfo[j]._qwUserId == qwUserID[i]) 
                {
                    qwUserID[i] = 0;
                    break;
                }
            }

            if (qwUserID[i] != 0) 
            {
                bFound = TRUE;
            }
        }
        if (bFound == TRUE) 
        {
            SgServiceNotifyCliUserChange(
                &sgaddr,
                qwUserID[0],
                qwUserID[1],
                qwUserID[2],
                qwUserID[3],
                pSpiInfo->_ipaI,
                SECMSG_CLIUSERCHANGE_TYPE_ADD
                );
            bFound = FALSE;
        }
    }


}

void 
SgIndicateSgSvcClientUpdate(
    CSpiInfo * pSpiInfo
    )
{
    CAuthData4    * pAuthData     = &pSpiInfo->_AuthData;
    CUserInfo     * pUserInfo     = pSpiInfo->_aUserInfo;
    CUserInfo     * pUserInfoEnd  = pUserInfo + dimensionof(pSpiInfo->_aUserInfo);
    LARGE_INTEGER   liNonce       = *((LARGE_INTEGER*)pSpiInfo->_abNonceResp);
    SGADDR          sgaddr;
    UINT            iUser         = 0;
    UINT            uiUserMask    = 0;

    SgSpiInfoToSgAddr(pSpiInfo, &sgaddr);

    for (; pUserInfo < pUserInfoEnd; ++pUserInfo, ++iUser)
    {
        // Bug 29762 don't send state updates for an invalid user id
        if (pUserInfo->_qwUserId == 0) 
        {
            continue;
        }
        if (pUserInfo->_fUpdated)
        {
            pUserInfo->_fUpdated = FALSE;

            uiUserMask |= (1 << iUser);

            SgServiceNotifyCliUpdate(
                &sgaddr,
                pUserInfo->_qwUserId,
                *((ULONGLONG *)&pUserInfo->_xnkid),
                pAuthData->dwAuthDataFlags,
                pUserInfo->_dwPState,
                pUserInfo->_dwTitleId != 0 ? pUserInfo->_dwTitleId : pAuthData->dwTitleID,
                pUserInfo->_cbData,
                pUserInfo->_abData );
        }
    }

    if(g_fLogClientUpdates)
    {
        if (pAuthData->GetPlatform() != XPLT_PC)
        {
            SvcLogFT(log, pAuthData->flowToken, "UPD|%I64X|%I64X|%X",
                pAuthData->qwXboxID,
                liNonce,
                uiUserMask
                );
        }
        else
        {
            SvcLogFT(LogWindows, pAuthData->flowToken, "UPD|%I64X|%I64X|%X",
                pAuthData->qwXboxID,
                liNonce,
                uiUserMask
                );
        }
    }
}

void
SgIndicateSgSvcClient(
    CSpiInfo                    * pSpiInfo,
    WORD                          wType,
    CLogChallenge               * pLogChallenge,
    PVOID                         pv
    )
{
    switch (wType) 
    {
    case SGSVC_TYPE_CLIENT_ADD:
    case SGSVC_TYPE_CLIENT_CHG:
        SgIndicateSgSvcClientAdd( pSpiInfo, wType, pv );
        break;
    case SGSVC_TYPE_CLIENT_DEL:
        SgIndicateSgSvcClientDelete( pSpiInfo );
        break;
    case SGSVC_TYPE_CLIENT_FLOWMAP:
        SgIndicateSgSvcClientFlowmap( pSpiInfo );
        break;
    case SGSVC_TYPE_CLIENT_LOGLUA:
        SgIndicateSgSvcClientLua( pSpiInfo, pv );
        break;
    case SGSVC_TYPE_CLIENT_LOGCHAL:
        SgIndicateSgSvcClientChallenge( pSpiInfo, pLogChallenge, pv );
        break;
    case SGSVC_TYPE_CLIENT_SCHG:
        SgIndicateSgSvcClientServiceChange( pSpiInfo );
        break;
    case SGSVC_TYPE_CLIENT_TCHG:
        SgIndicateSgSvcClientTitleChange( pSpiInfo );
        break;
    case SGSVC_TYPE_CLIENT_UCHG:
        SgIndicateSgSvcClientUserChange( pSpiInfo, pv );
        break;
    case SGSVC_TYPE_CLIENT_UPD:
        SgIndicateSgSvcClientUpdate( pSpiInfo );
        break;
    }
}




// ---------------------------------------------------------------------------------------
// SgSvcHexStr
// ---------------------------------------------------------------------------------------
char * SgSvcHexStr(const void * pv, size_t cb)
{
    STATIC_BUFFER(HexStr, 256, 2049);
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    UINT   ui;

    if (cb > ((cch - 1) / 2))
        cb = ((cch - 1) / 2);

    for (; cb > 0; --cb, ++pb)
    {
        ui = (*pb) >> 4;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        ui = (*pb) & 0x0F;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
    }

    *pchDst = 0;

    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\amd64\tcpipxsum.asm ===
title  "Compute Checksum"
;++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
; Module Name:
;
;   xsum.amd
;
; Abstract:
;
;   This module implements the platform specific function to compute the
;   checksum of a buffer.
;
; Author:
;
;   David N. Cutler (davec) 6-Jul-2000
;
; Environment:
;
;   Any mode.
;
;--

include ksamd64.inc

;++
;
; ULONG
; tcpipxsum(
;    IN ULONG Checksum,
;    IN PUCHAR Source,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer and combines
;    the computed checksum with the specified checksum.
;
; Arguments:
;
;    Checksum (ecx) - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    Source (rdx) - Supplies a pointer to the checksum buffer.
;
;    Length (r8d) - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum, in 16-bit form, with the high word set to 0.
;
;--

        NESTED_ENTRY tcpipxsum, _TEXT$00

        alloc_stack 8                   ; allocate stack frame
        save_reg rbx, 0                 ; save nonvolatile register

        END_PROLOGUE

        prefetchnta 0[rdx]              ; prefetch first two 64-byte blocks
        prefetchnta 64[rdx]             ;
        prefetchnta 127[rdx]            ;
        mov     r11, rdx                ; save initial buffer address
        mov     bx, cx                  ; save initial checksum
        mov     r10, rdx                ; set checksum buffer address
        mov     ecx, r8d                ; set buffer length
        xor     eax, eax                ; clear computed checksum
        test    ecx, ecx                ; test if any bytes to checksum
        jz      combine                 ; if z, no bytes to checksum

;
; If the checksum buffer is not word aligned, then add the first byte of
; the buffer to the checksum.
;
; N.B. First buffer address check is done using rdx rather than r10 so
;      the register ah can be used.
;

        test    dl, 1                   ; test if buffer word aligned
        jz      short word_aligned      ; if z, buffer word aligned
        mov     ah, [rdx]               ; get first byte of checksum
        inc     r10                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      done                    ; if z set, no more bytes

;
; If the buffer is not an even number of bytes, then add the last byte of
; the buffer to the checksum.
;

word_aligned:                           ;
        shr     ecx, 1                  ; convert to word count
        jnc     short word_count        ; if nc, even number of bytes
        mov     al, [r10][rcx * 2]      ; initialize the computed checksum
        jz      done                    ; if z set, no more bytes

;
; If the buffer is not quadword aligned, then add words to the checksum until
; the buffer is quadword aligned.
;

word_count:                             ;
        test    r10b, 6                 ; test if buffer quadword aligned
        jz      short qword_aligned     ; if z, buffer quadword aligned
qword_align:                            ;
        add     ax, [r10]               ; add next word of checksum
        adc     eax, 0                  ; propagate carry
        add     r10, 2                  ; increment buffer address
        dec     ecx                     ; decrement number of words
        jz      done                    ; if z, no more words
        test    r10b, 6                 ; test if buffer qword aligned
        jnz     short qword_align       ; if nz, buffer not qword aligned

;
; Compute checksum in large blocks of qwords.
;

qword_aligned:                          ;
        mov     edx, ecx                ; copy number or words remaining
        shr     edx, 2                  ; compute number of quadwords
        jz      residual_words          ; if z, no quadwords to checksum
        mov     r8d, edx                ; compute number of loop iterations
        shr     r8d, 4                  ;
        and     edx, 16 - 1             ; isolate partial loop iteration
        jz      short checksum_loop     ; if z, no partial loop iteration
        sub     rdx, 16                 ; compute negative loop top offset
        lea     r10, [r10][rdx * 8]     ; bias initial buffer address
        neg     rdx                     ; compute positive loop top offset
        add     r8d, 1                  ; increment loop iteration count
        lea     r9, checksum_start      ; get address of checksum array
        lea     r9, [r9][rdx * 4]       ; compute initial iteration address
        jmp     r9                      ; start checksum

;
; Checksum quadwords.
;
; N.B. This loop is entered with carry clear.
;

        align   16
checksum_loop:                          ;
        prefetchnta 64[r10]             ; prefetch next 64-byte block
        prefetchnta 127[r10]            ;

;
; N.B. The first 16 of following instructions are exactly 4 bytes long.
;

checksum_start:

;       adc     rax, 0[r10]             ; Compute checksum
                                        ;
        db      049h                    ; Manually encode the 4-byte
        db      013h                    ; version of the instruction
        db      042h                    ;
        db      000h                    ; adc rax, 0[r10]

        adc     rax, 8[r10]             ;
        adc     rax, 16[r10]            ;
        adc     rax, 24[r10]            ;
        adc     rax, 32[r10]            ;
        adc     rax, 40[r10]            ;
        adc     rax, 48[r10]            ;
        adc     rax, 56[r10]            ;
        adc     rax, 64[r10]            ;
        adc     rax, 72[r10]            ;
        adc     rax, 80[r10]            ;
        adc     rax, 88[r10]            ;
        adc     rax, 96[r10]            ;
        adc     rax, 104[r10]           ;
        adc     rax, 112[r10]           ;
        adc     rax, 120[r10]           ;

        .errnz  (($ - checksum_start) - (4 * 16))

        lea     r10, 128[r10]           ; update source address
        dec     r8d                     ; decrement loop count
        jnz     short checksum_loop     ; if nz, more iterations
        adc     rax, 0                  ; propagate last carry

;
; Compute checksum of residual words.
;

residual_words:                         ;
        and     ecx, 3                  ; isolate residual words
        jz      short done              ; if z, no residual words
add_word:                               ;
        add     ax, [r10]               ; add word to checksum
        adc     ax, 0                   ; propagate carry
        add     r10, 2                  ; increment buffer address
        dec     ecx                     ; decrement word count
        jnz     short add_word          ; if nz, more words remaining

;
; Fold the computed checksum to 32-bits and then to 16-bits.
;

done:                                   ;
        mov     rcx, rax                ; fold the checksum to 32-bits
        ror     rcx, 32                 ; swap high and low dwords
        add     rax, rcx                ; produce sum + carry in high 32-bits
        shr     rax, 32                 ; extract 32-bit checksum
        mov     ecx, eax                ; fold the checksum to 16-bits
        ror     ecx, 16                 ; swap high and low words
        add     eax, ecx                ; produce sum + carry in high 16-bits
        shr     eax, 16                 ; extract 16-bit check sum
        test    r11b, 1                 ; test if buffer word aligned
        jz      short combine           ; if z set, buffer word aligned
        ror     ax, 8                   ; swap checksum bytes

;
; Combine the input checksum with the computed checksum.
;

combine:                                ;
        add     ax, bx                  ; combine checksums
        adc     eax, 0                  ; add carry to low 16-bits
        mov     rbx, [rsp]              ; restore nonvolatile register
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END tcpipxsum, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sources.inc ===
C_DEFINES=\
    $(C_DEFINES) \
    -D_UNICODE \
    -DUNICODE \
    -DNT

USE_ASMMETA=0

USER_C_FLAGS=$(USER_C_FLAGS) /fp:fast

LINKER_FLAGS=$(LINKER_FLAGS) /LARGEADDRESSAWARE

INCLUDES=\
    $(INCLUDES); \
    ..\; \
    ..\inc; \
    $(INETROOT)\private\server\perfapp\sgperf; \
    ..\event\$(O);


TARGETLIBS=\
    $(TARGETLIBS) \
    $(INETROOT)\private\server\perfapp\sgperf\$(O)\sgperf.lib \
    $(INETROOT)\public\ext\sdk\win2k8\ddk\lib\*\ntdll.lib \
    $(INETROOT)\public\ext\sdk\win2k8\sdk\lib\amd64\bcrypt.lib \

SOURCES=\
    ..\ServiceMask.cpp     \
    ..\sgasn1.cpp          \
    ..\sgarpinfo.cpp       \
    ..\sgblockinfo.cpp     \
    ..\sgchal.cpp          \
    ..\sgconfig.cpp        \
    ..\sgclientstats.cpp   \
    ..\sgcrypt.cpp         \
    ..\sgdebug.cpp         \
    ..\sgdstinfo.cpp       \
    ..\sgfilter.cpp        \
    ..\sgiocfgparse.cpp    \
    ..\sghealth.cpp        \
    ..\sgkerb.cpp          \
    ..\sgkeyex.cpp         \
    ..\sgkrb5.cpp          \
    ..\sglbinary.cpp       \
    ..\sglbuffer.cpp       \
    ..\sglchal.cpp         \
    ..\sgldebug.cpp        \
    ..\sglfilter.cpp       \
    ..\sgllog.cpp          \
    ..\sglperf.cpp         \
    ..\sglqword.cpp        \
    ..\sglua.cpp           \
    ..\sglspi.cpp          \
    ..\sgnatinfo.cpp       \
    ..\sgoffload.cpp       \
    ..\sgperfdata.cpp      \
    ..\sgprocbal.cpp       \
    ..\sgrecv.cpp          \
    ..\sgsecmsg.cpp        \
    ..\sgsiteinfo.cpp      \
    ..\sgstate.cpp         \
    ..\sgsvc.cpp           \
    ..\sgsvccore.cpp       \
    ..\sgsvcinfo.cpp       \
    ..\sgsvcmgmt.cpp       \
    ..\sgsvcmsg.cpp        \
    ..\sgsvcnot.cpp        \
    ..\sgsvcperf.cpp       \
    ..\sgtransinfo.cpp     \
    ..\sgutil.cpp          \
    ..\sgxmit.cpp          \
    ..\tcpipxsum.asm       \

!message Building $(SOURCES)

USE_LIBCMT=1
USE_STL=1
#USE_NTDLL=1
XLUSE_XMGMT=1   # For eventthrottle.h
XLUSE_DSTRUCT=1
XLUSE_CRYPTO=1
XLUSE_RSA=1
XLUSE_RAWNIC=1
XLUSE_CUTIL=1
XLUSE_CONFIG=1
XLUSE_LUA=1
XLUSE_OLEDBW=1
XLUSE_HEALTH=1

PRECOMPILED_INCLUDE=..\sg.h
PRECOMPILED_CXX=1

NO_PRECOMPILED_OPTION=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\rnio.h ===
// ---------------------------------------------------------------------------------------
// rnio.h
//
// Interface between RAWNIC.SYS and RAWNIC.LIB
// ---------------------------------------------------------------------------------------

#ifndef __RNIO_H__
#define __RNIO_H__

// ---------------------------------------------------------------------------------------
// Version - should be updated for breaking API changes
// ---------------------------------------------------------------------------------------

#define RN_VERSION                  7

// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define RN_DEVICE_NAME              L"\\Device\\RAWNIC"
#define RN_SYMBOLIC_NAME            L"\\DosDevices\\RAWNIC"
#define RN_PROTOCOL_NAME            L"RAWNIC"

//
// The name of the EA (Extended Attribute) passed to NtCreateFile(). This
// allows us to pass adapter properties at the time we create the handle.
//
// N.B. The EA name (including the terminator) must be a multiple of eight
// to ensure natural alignment of the RN_OPEN_PACKET structure used as
// the EA value.
//

//                                       7654321076543210
#define RN_OPEN_PACKET_NAME             "RnOpenPacket000"
#define RN_OPEN_PACKET_NAME_LENGTH      (sizeof(RN_OPEN_PACKET_NAME) - 1)
C_ASSERT( ((RN_OPEN_PACKET_NAME_LENGTH + 1) & 7) == 0 );

// passed in Create calls
struct RN_OPEN_PACKET
{
    DWORD       _dwVersion;
    DWORD       _dwOptions;
    BYTE        _abEaNic[6];
    BYTE        _abEaVirtual[6];
    DWORD       _recvMaxLatency;
    DWORD       _recvDesiredLatency;
};

//
// RAWNIC IOCTL code definitions.
//
// N.B. To ensure the efficient of the code generated by RAWNIC's
//      IOCTL dispatcher, these IOCTL codes should be contiguous
//      (no gaps).
//
// N.B. If new IOCTLs are added here, update the lookup table in
//      rnmain.cpp.
//

#define _RN_CTL_CODE(request, method, access)                 \
    CTL_CODE( FILE_DEVICE_NETWORK, request, method, access )

#define _RN_REQUEST(ioctl)                                    \
   ((((ULONG)(ioctl)) >> 2) & 0x03FF)

#define RN_READ_COUNTERS                                    0
#define RN_READ_ADAPTERS                                    1

#define RN_NUM_IOCTLS                                       2

#define IOCTL_RN_READ_COUNTERS                              \
    _RN_CTL_CODE( RN_READ_COUNTERS,                         \
                  METHOD_BUFFERED,                          \
                  FILE_WRITE_ACCESS )

#define IOCTL_RN_READ_ADAPTERS                              \
    _RN_CTL_CODE( RN_READ_ADAPTERS,                         \
                  METHOD_BUFFERED,                          \
                  FILE_WRITE_ACCESS )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\lib\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

$(BASEDIR)\private\lib$(BUILD_ALT_DIR)\i386\$(TARGETNAME).lib: $(O)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\inc\rawnic.h ===
// ---------------------------------------------------------------------------------------
// rawnic.h
//
// Raw NIC Access Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __RAWNIC_H__
#define __RAWNIC_H__

#ifdef EXPORTME
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT
#endif

#include <rncommon.h>
#include <cutil.h>

// ---------------------------------------------------------------------------------------
// RawnicDetectDriver
//
// Detects the presence of the rawnic driver by attempting to start it. This will fail if 
// the driver doesn't exist, but it will also fail if the current user lacks permissions 
// to start the driver (for example).  
//
// Returns NO_ERROR on success, else it returns a Win32 error code.
// ---------------------------------------------------------------------------------------
DLLEXPORT DWORD WINAPI RawnicDetectDriver();

// ---------------------------------------------------------------------------------------
// RawAdapterOpen
//
// Opens a handle to the rawnic driver. pbEaNic must be a valid MAC address of a NIC that 
// has rawnic bound to to, or else ERROR_UNEXP_NET_ERROR will be returned.
//
// ---------------------------------------------------------------------------------------
DLLEXPORT DWORD WINAPI RawAdapterOpen(
    IN PBYTE pbEaNic,
    IN PBYTE pbEaVirtual,
    IN DWORD dwOptions,
    IN DWORD dwRecvMaxLatency,
    IN DWORD dwRecvDesiredLatency,
    OUT PHANDLE ph);

// ---------------------------------------------------------------------------------------
// RawAdapterSend
//
// Sends one or more packets to the nic. Each packet must be prefixed by a WORD that 
// specifies the length of the packet.  
// ---------------------------------------------------------------------------------------
DLLEXPORT DWORD WINAPI RawAdapterSend(
    IN HANDLE h,
    IN DWORD cb,
    IN PBYTE pb,
    IN LPOVERLAPPED lpo OPTIONAL);

// ---------------------------------------------------------------------------------------
// RawAdapterRecv
//
// Retrieves one or more packets from the nic. Each packet will be prefixed by a WORD that 
// specifies the length of the packet.
// ---------------------------------------------------------------------------------------
DLLEXPORT DWORD WINAPI RawAdapterRecv(
    IN HANDLE h,
    IN DWORD cb,
    IN PBYTE pb,
    IN LPOVERLAPPED lpo OPTIONAL,
    OUT PDWORD pcbReceived OPTIONAL);

// ---------------------------------------------------------------------------------------
// RawAdapterReadCounters
//
// Retrieve current perf counter information from rawnic.
// ---------------------------------------------------------------------------------------
DLLEXPORT DWORD WINAPI RawAdapterReadCounters(
    IN HANDLE h,
    IN DWORD cbCounters,
    OUT RAWNIC_COUNTERS* pCounters,
    IN LPOVERLAPPED lpo OPTIONAL);

// ---------------------------------------------------------------------------------------
// RawnicReadAdapters
//
// Retrieves a list of adapters with information about them that rawnic is currently bound 
// to. 
// 
// - cAdapters : size of adapter info input array, as array size
// - aAdapters : buffer to hold adapter info, as an array
// - pcAdaptersCopied : number of elements in aAdapters actually filled.
//
// Returns ERROR_MORE_DATA warning if aAdapters is not large enough. aAdapters will be 
// filled as much as possible, and pcAdaptersCopied will only indicate the number of 
// elements copied. 
//
// Returns ERROR_INSUFFICIENT_BUFFER error if aAdapters is too small for even 1 element or 
// null.  No data is copied.
//
// Returns ERROR_INVALID_PARAMETER if any parameters are invalid.
//
// If you need to know the current number of adapters in the system, you are unfortunately 
// out of luck. This functionality has not been implemented yet due to technical 
// difficulties. 
// 
// ---------------------------------------------------------------------------------------
DLLEXPORT DWORD WINAPI RawnicReadAdapters(
    IN DWORD cAdapters,
    IN OUT RAWNIC_ADAPTER_INFO * aAdapters,
    OUT DWORD * pcAdaptersCopied);

// ---------------------------------------------------------------------------------------
// RawnicInstallDriver
//
// Installs the rawnic driver.
// ---------------------------------------------------------------------------------------
DLLEXPORT BOOL WINAPI RawnicInstallDriver( 
    const WCHAR* pwszProduct,
    OUT BOOL *pfRebootRequired = NULL,
    CStr *perror = NULL);

// ---------------------------------------------------------------------------------------
// RawnicUninstallDriver
//
// Uninstalls the rawnic driver.
// ---------------------------------------------------------------------------------------
DLLEXPORT BOOL WINAPI RawnicUninstallDriver( 
    const WCHAR* pwszProduct,
    OUT BOOL *pfRebootRequired = NULL,
    CStr *perror = NULL);

// ---------------------------------------------------------------------------------------
// RawAdapterQueryStatus
//
// Not implemented.
// ---------------------------------------------------------------------------------------
DLLEXPORT DWORD WINAPI RawAdapterQueryStatus(
    IN HANDLE h);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\event\makefile.inc ===
!include $(INETROOT)\build\makefile.inc


event.rc : sgevent.h msg00001.bin sgevent.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\i386\tcpipxsum.asm ===
title  "Compute TCP/IP Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    tcpipxsum.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
;--*/



LOOP_UNROLLING_BITS equ     4
LOOP_UNROLLING      equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        .list

XNET    SEGMENT DWORD PUBLIC 'CODE'

;++
;
; USHORT
; tcpipxsum(
;   IN USHORT xsum,
;   IN const VOID* buf,
;   IN UINT len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    xsum - Suppiles the initial checksum value, in 16-bit form,
;           with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

xsum    equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpipxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 32-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax, word ptr [esp + xsum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpipxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM

stdENDP tcpipxsum

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\lib\rnlib.cpp ===
// ---------------------------------------------------------------------------------------
// rnlib.cpp
//
// Interface between RAWNIC.SYS and RAWNIC.LIB
// ---------------------------------------------------------------------------------------

// ----------------------------------------------------------------
// Includes
// ----------------------------------------------------------------

extern "C" {
#define WIN32_NO_STATUS
#include <winternl.h>
#undef WIN32_NO_STATUS
#include <windows.h>
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>
#include <wincrypt.h>

typedef LONG SECURITY_STATUS;


#define OBJ_CASE_INSENSITIVE    0x00000040L

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020

#define FILE_OPEN                       0x00000001

typedef PVOID HINF;

#include <netcfgx.h>

#include <setupapi.h>

#include <devguid.h>
};

#include <rawnic.h>
#include <rnio.h>

#include <assert.h>


typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

// ----------------------------------------------------------------
// Utilities
// ----------------------------------------------------------------

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))

#define LOG_HR(x)           x; if (perror) perror->Format("CALL[%d]  %s : hr=0x%X\n", __LINE__, #x, hr)
#define RnTrace(fmt, ...)      if (perror) perror->Format("INFO[%d]  %s: " fmt "\n", __LINE__, __FUNCTION__, __VA_ARGS__)
#define RnError(fmt, ...)      if (perror) perror->Format("ERROR[%d] %s: " fmt "\n", __LINE__, __FUNCTION__, __VA_ARGS__) 


// ---------------------------------------------------------------------------------------
// I/O macros
// ---------------------------------------------------------------------------------------

#define OVERLAPPED_TO_IO_STATUS( pOverlapped )                  \
    ((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)

#define SET_STATUS_OVERLAPPED_TO_IO_STATUS( pOverlapped, ntstatus ) \
    do { \
        (((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)->Pointer = (PVOID)(ntstatus)); \
        assert( ntstatus == OVERLAPPED_TO_IO_STATUS(pOverlapped)->Status ); \
    } while (0)


#define RawNicNtStatusToWin32Status(Status)  (((Status) == STATUS_SUCCESS) ? NO_ERROR : RtlNtStatusToDosError(Status))

// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define EA_REAL_BUFFER_LENGTH   (sizeof(RN_OPEN_PACKET) + RN_OPEN_PACKET_NAME_LENGTH + 1 + \
                                 FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) )

#define EA_BUFFER_LENGTH        (sizeof(RN_OPEN_PACKET) + RN_OPEN_PACKET_NAME_LENGTH + 1 + \
                                 sizeof(FILE_FULL_EA_INFORMATION) )

#define RAWNIC_INF_PATH1                L"netrawnic.inf"
#define RAWNIC_INF_PATH2                L"rawnic\\netrawnic.inf"
#define RAWNIC_COMPONENT_NAME           L"ms_rawnic"
#define RAWNIC_SERVICE_NAME             L"rawnic"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

NTSTATUS
RnDeviceControl(
    HANDLE hVNet, 
    LPOVERLAPPED lpo, 
    ULONG ctl, 
    PVOID pbIn, 
    ULONG cbIn, 
    PVOID pbOut, 
    ULONG cbOut,
    PULONG pcbTransferred OPTIONAL
    );

DWORD
RnStartDriver();

// ---------------------------------------------------------------------------------------
// Low level API
// ---------------------------------------------------------------------------------------

DWORD
RnStartDriver()
{
    SC_HANDLE schScm   = NULL;
    SC_HANDLE schRn    = NULL;
    DWORD     dwErr    = NO_ERROR;

    schScm = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT);

    if (schScm == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }

    schRn = OpenServiceW(schScm, L"RAWNIC", SERVICE_START);

    if (schRn == NULL)
    {
        dwErr = GetLastError();
        goto exit;
    }

    if (StartService(schRn, 0, NULL))
    {
        // give the driver a couple of seconds to initialize
        Sleep(2000);
    }
    else
    {
        dwErr = GetLastError();

        if (ERROR_SERVICE_ALREADY_RUNNING == dwErr)
        {
            dwErr = NO_ERROR;
        }
    }
        

exit:
    if (schScm != NULL)
        CloseServiceHandle(schScm);

    if (schRn != NULL)
        CloseServiceHandle(schRn);
    
    return(dwErr);
}


NTSTATUS 
RnDeviceControl(
    HANDLE hVNet, 
    LPOVERLAPPED lpo, 
    ULONG ctl, 
    PVOID pbIn, 
    ULONG cbIn, 
    PVOID pbOut, 
    ULONG cbOut,
    PULONG pcbTransferred OPTIONAL
    )
{
    NTSTATUS Status;

    if (lpo)
    {
        SET_STATUS_OVERLAPPED_TO_IO_STATUS(lpo, STATUS_PENDING);
    
        Status = NtDeviceIoControlFile(
                        hVNet,                          // FileHandle
                        lpo->hEvent,                    // Event
                        NULL,                           // ApcRoutine
                        (ULONG_PTR)lpo->hEvent & 1      // ApcContext
                            ? NULL : lpo,
                        OVERLAPPED_TO_IO_STATUS(lpo),   // IoStatusBlock
                        ctl,                            // IoControlCode
                        pbIn,                           // InputBuffer
                        cbIn,                           // InputBufferLength
                        pbOut,                          // OutputBuffer
                        cbOut                           // OutputBufferLength
                        );
    }
    else
    {
        IO_STATUS_BLOCK ioStatusBlock;

        ioStatusBlock.Status = STATUS_PENDING;
        ioStatusBlock.Information = 0;

        Status = NtDeviceIoControlFile(
                        hVNet,                          // FileHandle
                        NULL,                           // Event
                        NULL,                           // ApcRoutine
                        NULL,                           // ApcContext
                        &ioStatusBlock,                 // IoStatusBlock
                        ctl,                            // IoControlCode
                        pbIn,                           // InputBuffer
                        cbIn,                           // InputBufferLength
                        pbOut,                          // OutputBuffer
                        cbOut                           // OutputBufferLength
                        );

        if (Status == STATUS_PENDING)
        {
            while (ioStatusBlock.Status == STATUS_PENDING)
            {
                Sleep(0);
            }
            Status = ioStatusBlock.Status;
        }

        if (pcbTransferred)
        {
            *pcbTransferred = (ULONG)ioStatusBlock.Information;
        }
     }
    
    return(Status);

}

// ---------------------------------------------------------------------------------------
// Windowsy API
// ---------------------------------------------------------------------------------------

DWORD WINAPI RawnicDetectDriver()
{
    DWORD dwRes = ERROR_SUCCESS;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hSC = NULL;
    BYTE* buffer = NULL;

    hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );

    if (NULL == hSCM)
    {
        dwRes = GetLastError();
        goto Error;
    }

    hSC = OpenService( hSCM, L"RAWNIC", SERVICE_QUERY_STATUS );

    if (NULL == hSC)
    {
        dwRes = GetLastError();
        goto Error;
    }

    SERVICE_STATUS status;
    if (!QueryServiceStatus(hSC, &status))
    {
        dwRes = GetLastError();
        goto Error;
    }

    if (status.dwCurrentState != SERVICE_RUNNING)
    {
        dwRes = RnStartDriver();
    }

Error:

    if (hSC) CloseServiceHandle(hSC);

    if (hSCM) CloseServiceHandle(hSCM);

    return dwRes;
}

DWORD WINAPI RawAdapterOpen(
    IN PBYTE pbEaNic,
    IN PBYTE pbEaVirtual,
    IN DWORD dwOptions,
    IN DWORD dwRecvMaxLatency,
    IN DWORD dwRecvDesiredLatency,
    OUT PHANDLE ph)
{
    NTSTATUS status = STATUS_SUCCESS;
    
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    ULONG createOptions = 0;

    BYTE EaBuffer[EA_BUFFER_LENGTH];
    RN_OPEN_PACKET * pOpenPacket;
    PFILE_FULL_EA_INFORMATION pEaInfo;
    
    if (ph == NULL)
    {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Make sure the driver is started
    //

    status = RawnicDetectDriver();
    if ( status != NO_ERROR )
    {
        // status is already a Win32 Error code, no need to convert.
        // NOTE:  Explicitly not going to exit because the conversion is being
        // avoided.  If cleanup code needs to be added later, should fix this
        // code as well.
        return status;
    }

    //
    // Build the object attributes.
    //
    
    RtlInitUnicodeString( &deviceName, RN_DEVICE_NAME );

    InitializeObjectAttributes(
       &objectAttributes,                      // ObjectAttributes
       &deviceName,                            // ObjectName
       OBJ_CASE_INSENSITIVE,                   // Attributes
       NULL,                                   // RootDirectory
       NULL                                    // SecurityDescriptor
       );

    //
    // Build the EA info
    //

    pEaInfo= (PFILE_FULL_EA_INFORMATION)EaBuffer;
    pEaInfo->NextEntryOffset = 0;
    pEaInfo->Flags = 0;
    pEaInfo->EaNameLength = RN_OPEN_PACKET_NAME_LENGTH;
    pEaInfo->EaValueLength = sizeof(RN_OPEN_PACKET);

    RtlCopyMemory(
        pEaInfo->EaName,
        RN_OPEN_PACKET_NAME,
        RN_OPEN_PACKET_NAME_LENGTH + 1
        );

    pOpenPacket = (RN_OPEN_PACKET *)
                    (pEaInfo->EaName + pEaInfo->EaNameLength + 1);

    //
    // Build the open packet.
    //

    pOpenPacket->_dwVersion = RN_VERSION;
    pOpenPacket->_dwOptions = dwOptions;
    memcpy(pOpenPacket->_abEaNic, pbEaNic, sizeof(pOpenPacket->_abEaNic));
    memcpy(pOpenPacket->_abEaVirtual, pbEaVirtual, sizeof(pOpenPacket->_abEaVirtual));
    pOpenPacket->_recvMaxLatency = dwRecvMaxLatency;
    pOpenPacket->_recvDesiredLatency = dwRecvDesiredLatency;

    if ((dwOptions & RN_OPTION_OVERLAPPED) == 0)
    {
        createOptions |= FILE_SYNCHRONOUS_IO_NONALERT;
    }

    //
    // Open the device.
    //

    status = NtCreateFile(
                ph,                             // FileHandle
                GENERIC_READ |                  // DesiredAccess
                    GENERIC_WRITE |
                    SYNCHRONIZE,
                &objectAttributes,              // ObjectAttributes
                &ioStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0,                              // FileAttributes
                FILE_SHARE_READ |               // ShareAccess
                    FILE_SHARE_WRITE,
                FILE_OPEN,                      // CreateDisposition
                createOptions,                  // CreateOptions
                EaBuffer,                       // EaBuffer
                EA_REAL_BUFFER_LENGTH           // EaLength
                );


    if (!NT_SUCCESS(status))
    {
        *ph = NULL;
    }    

exit:    
    return RawNicNtStatusToWin32Status(status);
}

DWORD WINAPI RawAdapterSend(IN HANDLE h,
                            IN DWORD cb,
                            IN PBYTE pb,
                            IN LPOVERLAPPED lpo OPTIONAL)
{
    DWORD dwError = NO_ERROR;
    DWORD cbWritten = 0;
    
    // If lpo == NULL, we must provide a pcbWritten
    DWORD* pcbWritten = lpo ? NULL : &cbWritten;

    if(!WriteFile(h, pb, cb, pcbWritten, lpo))
    {
        dwError = GetLastError();
    }

    return dwError;
}

DWORD WINAPI RawAdapterRecv(IN HANDLE h,
                            IN DWORD cb,
                            IN PBYTE pb,
                            IN LPOVERLAPPED lpo OPTIONAL,
                            OUT PDWORD pcbReceived OPTIONAL)
{
    DWORD dwError = NO_ERROR;

    if(!ReadFile(h, pb, cb, pcbReceived, lpo))
    {
        dwError = GetLastError();
    }

    return dwError;
}

DWORD WINAPI RawAdapterReadCounters(IN HANDLE h,
                                    IN DWORD cbCounters,
                                    OUT RAWNIC_COUNTERS* pCounters,
                                    IN LPOVERLAPPED lpo OPTIONAL)
{
    NTSTATUS Status = RnDeviceControl(h,                        // FileHandle
                                      lpo,                      // Overlapped
                                      IOCTL_RN_READ_COUNTERS,   // ioctl
                                      NULL,                     // pbIn
                                      0,                        // cbIn
                                      pCounters,                // pbOut
                                      cbCounters,               // cbOut
                                      NULL);                    // pcbTransferred
    
    return RawNicNtStatusToWin32Status(Status);
}

DWORD WINAPI RawnicReadAdapters(
    IN DWORD cAdapters,
    IN OUT RAWNIC_ADAPTER_INFO * aAdapters,
    OUT DWORD * pcAdaptersCopied)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE h = NULL;
    DWORD cbTransferred = 0;

    // Don't tell me your buffer exists when NULL is passed in
    if (cAdapters > 0 && aAdapters == NULL)
    {
        return RawNicNtStatusToWin32Status(STATUS_INVALID_PARAMETER);
    }

    // Don't care about the MAC we're "binding" to, we just need a handle to rawnic so we 
    // can make the GetAdapters call. Bit of a hack, but rawnic has been architected 
    // around the idea that a handle represents a vnet.
    BYTE ea[6];
    memset(ea, 0, sizeof(ea));
    DWORD cbAdapters = cAdapters * sizeof(RAWNIC_ADAPTER_INFO);

    Status = RawAdapterOpen(ea, ea, RN_OPTION_IGNORE_MAC, 0, 0, &h);
    if (!NT_SUCCESS(Status))
    {
        return RawNicNtStatusToWin32Status(Status);
    }

    Status = RnDeviceControl(
        h,                        // FileHandle
        NULL,                     // Overlapped
        IOCTL_RN_READ_ADAPTERS,   // ioctl
        NULL,                     // pbIn
        0,                        // cbIn
        aAdapters,                // pbOut
        cbAdapters,               // cbOut
        &cbTransferred);          // pcbTransferred

    if (pcAdaptersCopied)
    {
        *pcAdaptersCopied = cbTransferred / sizeof(RAWNIC_ADAPTER_INFO);
    }

    if (h)
    {
        CloseHandle(h);
    }

    return RawNicNtStatusToWin32Status(Status);
}

DWORD WINAPI RawAdapterQueryStatus(IN HANDLE h)
{
    // @@@ implement adapter query
    return ERROR_CALL_NOT_IMPLEMENTED;
}

BOOL WINAPI RawnicInstallDriver( const WCHAR* pwszProduct, OUT BOOL *pfRebootRequired, CStr* perror )
{
    BOOL fReturn = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    INetCfg* pINetCfg = NULL;
    INetCfgLock* pINetCfgLock = NULL;
    INetCfgClassSetup* pINetCfgClassSetup = NULL;
    INetCfgComponent* pINetCfgComponent = NULL;
    BOOL fLocked = FALSE;
    HRESULT hr;
    INFCONTEXT infCtx;
    WCHAR wzPath[ MAX_PATH ];
    WCHAR wzInfSystemPath[ MAX_PATH ];
    WCHAR* pwzSlash;
    WCHAR* pwzLockedBy;
    OBO_TOKEN OboToken;

    if (pfRebootRequired)
    {
        *pfRebootRequired = FALSE;
    }

    // -- Set up the path to the INF file ------------------------------------------------

    
    if( !GetModuleFileNameW( NULL, wzPath, dimensionof( wzPath ) ) )
    {
        RnError( "GetModuleFileName failed, error %d", GetLastError() );
        goto Exit;
    }

    wzPath[ dimensionof( wzPath ) - 1 ] = L'\0';

    pwzSlash = wcsrchr( wzPath, L'\\' );
    if( NULL == pwzSlash )
    {
        pwzSlash = wzPath;
    }

    if( dimensionof( wzPath ) < ( pwzSlash - wzPath ) + dimensionof( RAWNIC_INF_PATH2 ) )
    {
        *pwzSlash = L'\0';
        RnError( "Path name '%ls\\' + '%ls' is too long", wzPath, RAWNIC_INF_PATH2 );
        goto Exit;
    }

    wcscpy( pwzSlash + 1, RAWNIC_INF_PATH1 );

    if(GetFileAttributes(wzPath) == INVALID_FILE_ATTRIBUTES)
    {
        //
        // couldn't find rawnic on the first path option. Try the next one.
        //

        wcscpy( pwzSlash + 1, RAWNIC_INF_PATH2 );
    }

    RnTrace( "RAWNIC: RawnicInstallDriver() - Installing component %ls from %ls", RAWNIC_COMPONENT_NAME, wzPath );

    // -- Copy files so setup knows where to find them -----------------------------------
    
    if( !SetupCopyOEMInf( wzPath, NULL, SPOST_PATH, 0, wzInfSystemPath, dimensionof( wzInfSystemPath ), NULL, NULL ) )
    {
        RnError( "SetupCopyOEMInf returned error %d", GetLastError() );
        goto Exit;
    }

    RnTrace( "Copied '%ls' to '%ls'", wzPath, wzInfSystemPath );

    // -- Get INetConfig interface -------------------------------------------------------

    LOG_HR(hr = CoCreateInstance( CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER, IID_INetCfg, (void**) &pINetCfg ));
    if( FAILED( hr ) )
    {
        RnError( "CoCreateInstance(INetCfg) failed, hr=0x%08X", hr );
        goto Exit;
    }

    LOG_HR(hr = pINetCfg->QueryInterface( IID_INetCfgLock, (void**) &pINetCfgLock ));
    if( FAILED( hr ) )
    {
        RnError( "QueryInterface(INetCfgLock) failed, hr=0x%08X", hr );
        goto Exit;
    }

    LOG_HR(hr = pINetCfgLock->AcquireWriteLock( 15000, RAWNIC_COMPONENT_NAME, &pwzLockedBy ));
    if( S_FALSE == hr )
    {
        RnError( "INetCfgLock.AcquireWriteLock lock already held by '%ls'", pwzLockedBy );
        goto Exit;
    }
    else if( FAILED( hr ) )
    {
        RnError( "INetCfgLock.AcquireWriteLock failed, hr=0x%08X", hr );
        goto Exit;
    }

    fLocked = TRUE;        

    LOG_HR(hr = pINetCfg->Initialize( NULL ));
    if( FAILED( hr ) )
    {
        RnError( "INetCfg.Initialize failed, hr=0x%08X", hr );
        goto Exit;
    }

    // -- Get the INetConfigClassSetup interface and install -----------------------------

    LOG_HR(hr = pINetCfg->QueryNetCfgClass( &GUID_DEVCLASS_NETTRANS, IID_INetCfgClassSetup, (void**) &pINetCfgClassSetup ));
    if( FAILED( hr ) )
    {
        RnError( "INetCfg.QueryNetCfgClass failed, hr=0x%08X", hr );
        goto Exit;
    }

    ZeroMemory( &OboToken, sizeof( OboToken ) );
    OboToken.Type = OBO_SOFTWARE;
    OboToken.pszwManufacturer = L"Microsoft";
    OboToken.pszwProduct = pwszProduct;
    OboToken.pszwDisplayName = pwszProduct;
    
    LOG_HR(hr = pINetCfgClassSetup->Install( RAWNIC_COMPONENT_NAME, &OboToken, 0, 0, NULL, NULL, &pINetCfgComponent ));

    if (NETCFG_E_NEED_REBOOT == hr ||
        NETCFG_S_REBOOT == hr)
    {
        RnTrace("RAWNIC: Install says we need to reboot, hr=0x%08X.", hr);
        if (pfRebootRequired)
        {
            *pfRebootRequired = TRUE;
        }
    }

    if( FAILED( hr ) )
    {
        RnError( "INetCfgClassSetup.Install failed, hr=0x%08X", hr );
        goto Exit;
    }

    // Apply changes
    LOG_HR(hr = pINetCfg->Apply());
    if( FAILED( hr ) )
    {
        RnError( "INetCfg.Apply failed, hr=0x%08X", hr );
        goto Exit;
    }

    RnTrace( "Service install succeeded" );

    fReturn = TRUE;

Exit:
    if( pINetCfgComponent != NULL )
    {
        pINetCfgComponent->Release();
        pINetCfgComponent = NULL;
    }
    if( NULL != pINetCfgClassSetup )
    {
        pINetCfgClassSetup->Release();
        pINetCfgClassSetup = NULL;
    }
    if( fLocked )
    {
        pINetCfgLock->ReleaseWriteLock();
        fLocked = FALSE;
    }
    if( NULL != pINetCfgLock )
    {
        pINetCfgLock->Release();
        pINetCfgLock = NULL;
    }
    if( NULL != pINetCfg )
    {
        pINetCfg->Release();
        pINetCfg = NULL;
    }
    if( INVALID_HANDLE_VALUE != hInf )
    {
        SetupCloseInfFile( hInf );
        hInf = INVALID_HANDLE_VALUE;
    }

    return fReturn;
}

BOOL WINAPI RawnicUninstallDriver( const WCHAR* pwszProduct, OUT BOOL *pfRebootRequired, CStr *perror )
{
    BOOL fReturn = FALSE;
    INetCfg* pINetCfg = NULL;
    INetCfgLock* pINetCfgLock = NULL;
    INetCfgClassSetup* pINetCfgClassSetup = NULL;
    INetCfgComponent* pINetCfgComponent = NULL;
    BOOL fLocked = FALSE;
    HRESULT hr;
    WCHAR* pwzLockedBy;

    if (pfRebootRequired)
    {
        *pfRebootRequired = FALSE;
    }

    RnTrace( "Removing component '%ls'", RAWNIC_COMPONENT_NAME );

    // -- Get INetConfig interface -------------------------------------------------------

    LOG_HR(hr = CoCreateInstance( CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER, IID_INetCfg, (void**) &pINetCfg ));
    if( FAILED( hr ) )
    {
        RnError( "CoCreateInstance(INetCfg) failed, hr=0x%08X", hr );
        goto Exit;
    }

    LOG_HR(hr = pINetCfg->QueryInterface( IID_INetCfgLock, (void**) &pINetCfgLock ));
    if( FAILED( hr ) )
    {
        RnError( "QueryInterface(INetCfgLock) failed, hr=0x%08X", hr );
        goto Exit;
    }

    LOG_HR(hr = pINetCfgLock->AcquireWriteLock( 15000, RAWNIC_COMPONENT_NAME, &pwzLockedBy ));
    if( S_FALSE == hr )
    {
        RnError( "INetCfgLock.AcquireWriteLock lock already held by '%ls'", pwzLockedBy );
        goto Exit;
    }
    else if( FAILED( hr ) )
    {
        RnError( "INetCfgLock.AcquireWriteLock failed, hr=0x%08X", hr );
        goto Exit;
    }

    fLocked = TRUE;

    LOG_HR(hr = pINetCfg->Initialize( NULL ));
    if( FAILED( hr ) )
    {
        RnError( "INetCfg.Initialize failed, hr=0x%08X", hr );
        goto Exit;
    }

    // -- Get the INetConfigClassSetup interface and uninstall ---------------------------

    LOG_HR(hr = pINetCfg->QueryNetCfgClass( &GUID_DEVCLASS_NETTRANS, IID_INetCfgClassSetup, (void**) &pINetCfgClassSetup ));
    if( FAILED( hr ) )
    {
        RnError( "INetCfg.QueryNetCfgClass failed, hr=0x%08X", hr );
        goto Exit;
    }

    LOG_HR(hr = pINetCfg->FindComponent( RAWNIC_COMPONENT_NAME, &pINetCfgComponent ));
    if( FAILED( hr ) )
    {
        RnError( "INetCfg.FindComponent failed to find '%ls', hr=0x%08X", RAWNIC_COMPONENT_NAME, hr );
        goto Exit;
    }

    // NOTE: If FindComponent returned S_FALSE, then there is nothing to uninstall
    if( S_FALSE == hr )
    {
        RnTrace( "RAWNIC: RawnicUninstallDriver() - Driver not found, nothing to uninstall" );
    }
    else
    {
        OBO_TOKEN OboToken;
        SC_HANDLE hSCManager;
        SC_HANDLE hService;
        SERVICE_STATUS serviceStatus;

        ZeroMemory( &OboToken, sizeof( OboToken ) );
        OboToken.Type = OBO_SOFTWARE;
        OboToken.pszwManufacturer = L"Microsoft";
        OboToken.pszwProduct = pwszProduct;
        OboToken.pszwDisplayName = pwszProduct;
    
        //
        // Uninstall rawnic
        //

        LOG_HR(hr = pINetCfgClassSetup->DeInstall( pINetCfgComponent, &OboToken, NULL ));
        
        if (NETCFG_E_NEED_REBOOT == hr ||
            NETCFG_S_REBOOT == hr)
        {
            RnTrace("RAWNIC: DeInstall says we need to reboot, hr=0x%08X.", hr);
            if (pfRebootRequired)
            {
                *pfRebootRequired = TRUE;
            }
        }

        // failed should include the NETCFG_E_NEED_REBOOT case
        if( FAILED( hr ) )
        {
            RnError( "DeInstall failed, hr=0x%08X", hr );
            goto Exit;
        }

        if (NETCFG_S_STILL_REFERENCED == hr)
        {
            RnTrace("Warning, DeInstall returned NETCFG_S_STILL_REFERENCED, hr=0x%08X. Rawnic is still in use.", hr);
        }

        // Apply changes
        LOG_HR(hr = pINetCfg->Apply());
        if( FAILED( hr ) )
        {
            RnError( "INetCfg.Apply failed, hr=0x%08X", hr );
            goto Exit;
        }


        //
        // Stop the service.
        //
        // At this point the service has been 'marked for deletion', but unless we stop it it won't
        // be removed until the next reboot.
        //

        hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
        if( NULL == hSCManager )
        {
            RnError( "OpenSCManager failed, error=%d", GetLastError() );
            goto Exit;
        }

        hService = OpenServiceW( hSCManager, RAWNIC_SERVICE_NAME, SERVICE_ALL_ACCESS );
        if( NULL == hService )
        {
            // NOTE: If the driver was installed, but never used, then it won't be running.
            DWORD dwError = GetLastError();
            if( ERROR_SERVICE_DOES_NOT_EXIST == dwError )
            {
                RnError( "RAWNIC: RawnicUninstallDriver() - Service not found, nothing to stop" );
            }
            else
            {
                RnError( "OpenService failed, error=%d", GetLastError() );
                CloseServiceHandle( hSCManager );
                goto Exit;
            }
        }
        else
        {
            if( !ControlService( hService, SERVICE_CONTROL_STOP, &serviceStatus ) )
            {
                DWORD err = GetLastError();
                if (ERROR_SERVICE_CANNOT_ACCEPT_CTRL == err)
                {
                    RnTrace("Unable to stop the Rawnic service. It is likely in use by another component. error=%d", err);
                }
                else if (ERROR_SERVICE_NOT_ACTIVE == err)
                {
                    RnTrace("Rawnic service already stopped. This is ok. error=%d", err);
                }
                else
                {
                    RnError( "ControlService failed, error=%d", err );
                    CloseServiceHandle( hService );
                    CloseServiceHandle( hSCManager );
                    goto Exit;
                }
            }

            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSCManager );

    }

    RnTrace( "RAWNIC: RawnicUninstallDriver() - Uninstall succeeded" );

    fReturn = TRUE;

Exit:
    if( pINetCfgComponent != NULL )
    {
        pINetCfgComponent->Release();
        pINetCfgComponent = NULL;
    }
    if( NULL != pINetCfgClassSetup )
    {
        pINetCfgClassSetup->Release();
        pINetCfgClassSetup = NULL;
    }
    if( fLocked )
    {
        pINetCfgLock->ReleaseWriteLock();
        fLocked = FALSE;
    }
    if( NULL != pINetCfgLock )
    {
        pINetCfgLock->Release();
        pINetCfgLock = NULL;
    }
    if( NULL != pINetCfg )
    {
        pINetCfg->Release();
        pINetCfg = NULL;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\inc\rncommon.h ===
// ---------------------------------------------------------------------------------------
// rncommon.h
//
// Raw NIC Access Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __RNCOMMON_H__
#define __RNCOMMON_H__

#ifdef EXPORTME
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT
#endif

#define RN_OPTION_OVERLAPPED        0x00000001      // handle will be used for overlapped I/O
#define RN_OPTION_BROADCAST_ARP     0x00000002      // handle will receive ARP broadcasts
#define RN_OPTION_BROADCAST_DHCP    0x00000004      // handle will receive DHCP broadcasts
#define RN_OPTION_BROADCAST_XBOX    0x00000008      // handle will receive XBOX broadcasts
#define RN_OPTION_BROADCAST_ANY     0x00000010      // handle will receive any broadcast
#define RN_OPTION_PROMISCUOUS       0x00000020      // handle will receive any packet on the wire
#define RN_OPTION_IGNORE_MAC        0x00000040      // create handle even if mac address is invalid

struct RAWNIC_COUNTERS_ADAPTER
{
    DWORD cReceiveCalls;
    DWORD cSendCalls;
    DWORD cPacketReceived;
    DWORD cPacketDropped;
    DWORD cPacketSent;
    DWORD cXmitStage1;
    DWORD cXmitStage2;
    DWORD cRecvBatchThreshold;
    DWORD cOverlappedsAllocated;
};
    
struct RAWNIC_COUNTERS_GLOBAL
{
    DWORD cProtocolReceivePacket;
    DWORD cProtocolReceivePacketCopy;
    DWORD cProtocolReceiveIndication;
    DWORD cProtocolReceiveIndicationDiscard;
    DWORD cProtocolReceiveComplete;
    DWORD cPacketsInUse;
};

struct RAWNIC_COUNTERS
{
    RAWNIC_COUNTERS_ADAPTER adapter;
    RAWNIC_COUNTERS_GLOBAL global;
};

struct RAWNIC_ADAPTER_INFO
{
    BYTE    MacAddress[6];
    DWORD   State;
    DWORD   MacOptions;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\lib\lib\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

$(BASEDIR)\private\lib$(BUILD_ALT_DIR)\i386\$(TARGETNAME).lib: $(O)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\lib\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rawnic_none_12.4.56.0_none_4dfb921801141584
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rawnic
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_MANIFEST_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_CATALOG_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_PAYLOAD_PATH=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rawnic,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\lib\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rawnic_none_12.4.56.0_none_4dfb921801141584
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rawnic
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_MANIFEST_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_CATALOG_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_PAYLOAD_PATH=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rawnic,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

$(BASEDIR)\private\lib\i386\$(TARGETNAME).sys: $(O)\$(TARGETNAME).sys
    copy /y $** $@

$(BASEDIR)\private\lib\i386\netrawnic.inf : netrawnic.inf
    copy /y $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\lib\lib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rawnic_none_12.4.56.0_none_4dfb921801141584
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rawnic
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_MANIFEST_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_CATALOG_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_PAYLOAD_PATH=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rawnic,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\lib\lib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rawnic_none_12.4.56.0_none_4dfb921801141584
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rawnic
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_MANIFEST_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_CATALOG_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_PAYLOAD_PATH=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rawnic,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnadapt.cpp ===
// ---------------------------------------------------------------------------------------
// rnadapt.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "rnp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

ExternTag(RnInit);
ExternTag(RnIoctl);

DefineTag(RnAdapter,        TAG_ENABLE);        // Trace misc adapter calls
DefineTag(RnRecv,           TAG_DISABLE);       // Trace packets received
DefineTag(RnDhcpDiscard,    TAG_DISABLE);       // Trace potential DHCP packets discarded

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void RnAddAdapter(CAdapter * pAdapt);
void RnRemoveAdapter(CAdapter * pAdapt);
void RnDeleteAdapter(CAdapter * pAdapt);
BOOL RnDoesAdapterExist(CEnetAddr *peaNic);

// ---------------------------------------------------------------------------------------
// CNdisRequest
// ---------------------------------------------------------------------------------------

struct CNdisRequest
{
    NDIS_REQUEST    _req;                       // The request we're sending to NDIS

    // result of the request
    PDWORD          _pBytesNeeded;
    PDWORD          _pBytesReadOrWritten;
    
};


// ---------------------------------------------------------------------------------------
// ProtocolBindAdapter - called once for each active adapter
// ---------------------------------------------------------------------------------------
void
ProtocolBindAdapter(
    PNDIS_STATUS pStatus,
    NDIS_HANDLE BindContext,
    PNDIS_STRING DeviceName,
    PVOID SystemSpecific1,
    PVOID SystemSpecific2
    )
{
    CAdapter * pAdapt = NULL;

    TraceSz2(RnInit,
        "Opening adapter \n"
        "    %ws\n"
        "    %ws",
        DeviceName->Buffer,
        ((PNDIS_STRING)SystemSpecific1)->Buffer
        );

    //
    // allocate adapter structure
    //

    pAdapt = new CAdapter;
    if (!pAdapt)
    {
        TraceSz(RnInit, "Failed to allocate memory for an adapter");
        
        *pStatus = NDIS_STATUS_RESOURCES;
        return;
    }

    pAdapt->_le.Flink       = NULL;
    pAdapt->_le.Blink       = NULL;
    
    pAdapt->_dwState        = ADAPT_STATE_INIT;
    pAdapt->_powerState     = NetDeviceStateD0;

    pAdapt->_hLowerBinding  = NULL;
    
    pAdapt->_ea.SetZero();
    pAdapt->_dwMacOptions   = 0;
    pAdapt->_dwTdiRecvFlags = 0;

    pAdapt->_bRequestActive = FALSE;
    
    NdisInitializeEvent(&pAdapt->_evtInitTerm);

    //
    // open the lower miniport
    //

    NDIS_STATUS Sts;
    
    UINT MediumIndex;
    NDIS_MEDIUM Medium = NdisMedium802_3; // Ethernet
     
    NdisOpenAdapter(
        pStatus,                    // NDIS status code
        &Sts,                       // Adapter error code
        &pAdapt->_hLowerBinding,    // NdisBindingHandle
        &MediumIndex,               // SelectedMediumIndex
        &Medium,                    // MediumArray
        1,                          // MediumArraySize
        g_hNdisProtocol,            // NdisProtocolHandle
        pAdapt,                     // ProtocolBindingContext
        DeviceName,                 // AdapterName
        0,                          // OpenOptions
        NULL                        // AddressingInformation
        );
    
    if(*pStatus == NDIS_STATUS_PENDING)
    {
        //
        // PtOpenAdapterComplete will signal this event
        // when NdisOpenAdapter is done.
        //
        
        NdisWaitEvent(&pAdapt->_evtInitTerm, 0);
        NdisResetEvent(&pAdapt->_evtInitTerm);
        
        *pStatus = pAdapt->_statusInitTerm;
    }

    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        pAdapt->_dwState      = ADAPT_STATE_CLEANUP;
        RnDeleteAdapter(pAdapt);
        
        TraceSz1(RnInit, "NdisOpenAdapter failed %x", *pStatus);
        return;
    }
    
    //
    // get EA from lower miniport
    //

    *pStatus = pAdapt->MakeSynchronousNdisRequest(NdisRequestQueryInformation,
                                                  OID_802_3_CURRENT_ADDRESS,
                                                  &pAdapt->_ea,
                                                  sizeof(CEnetAddr));

    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        TraceSz1(RnInit, "NdisRequest (EA) failed %x", *pStatus);
        return;
    }

    TraceSz2(RnInit, "    Read EA (%s) for adapter %p", pAdapt->_ea.Str(), pAdapt);
    
    //
    // get MAC options from lower miniport
    //

    *pStatus = pAdapt->MakeSynchronousNdisRequest(NdisRequestQueryInformation,
                                                  OID_GEN_MAC_OPTIONS,
                                                  &pAdapt->_dwMacOptions,
                                                  sizeof(DWORD));

    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        TraceSz1(RnInit, "NdisRequest (MAC_OPTIONS) failed %x", *pStatus);
        return;
    }

    if (pAdapt->_dwMacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA)
    {
        pAdapt->_dwTdiRecvFlags = TDI_RECEIVE_COPY_LOOKAHEAD;
    }

    //
    // Done!
    //

    pAdapt->_dwState = ADAPT_STATE_READY;

    // put the adapter in a global list
    RnAddAdapter(pAdapt);
    
    Assert(*pStatus == NDIS_STATUS_SUCCESS);
    
    return;

}


// ---------------------------------------------------------------------------------------
// ProtocolOpenAdapterComplete
//
// Just signals the event so ProtocolBindAdapter can resume.
// ---------------------------------------------------------------------------------------
void        
ProtocolOpenAdapterComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS Status, 
    NDIS_STATUS OpenErrorStatus
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;

    pAdapt->_statusInitTerm = Status;
    NdisSetEvent(&pAdapt->_evtInitTerm);
}


// ---------------------------------------------------------------------------------------
// ProtocolUnbindAdapter
// ---------------------------------------------------------------------------------------
void        
ProtocolUnbindAdapter(
    PNDIS_STATUS pStatus,
    NDIS_HANDLE ProtocolBindingContext,
    NDIS_HANDLE UnbindContext
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;

    // remove adapter from global list
    TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
    RnRemoveAdapter(pAdapt);
    
    pAdapt->_dwState = ADAPT_STATE_CLEANUP;

    // close lower miniport

    TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
    if (pAdapt->_hLowerBinding)
    {
        TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
        NdisCloseAdapter(pStatus, pAdapt->_hLowerBinding);

        TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
        if(*pStatus == NDIS_STATUS_PENDING)
        {
            //
            // ProtocolCloseAdapterComplete will signal this event
            // when NdisCloseAdapter is done.
            //
            
            TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
            NdisWaitEvent(&pAdapt->_evtInitTerm, 0);
            TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
            NdisResetEvent(&pAdapt->_evtInitTerm);
            
            *pStatus = pAdapt->_statusInitTerm;
        }

        TraceSz3(RnInit, "ProtocolUnbindAdapter closed binding handle %p for adapter %p with status %x",
                 pAdapt->_hLowerBinding, pAdapt, *pStatus);

        pAdapt->_hLowerBinding = NULL;
    }

    TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
    RnDeleteAdapter(pAdapt);
    
    TraceSz1(RnInit, "ProtocolUnbindAdapter: %d", __LINE__); 
}


// ---------------------------------------------------------------------------------------
// ProtocolCloseAdapterComplete
//
// Just signals the event so ProtocolUnbindAdapter can resume.
// ---------------------------------------------------------------------------------------
void        
ProtocolCloseAdapterComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS Status
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;

    pAdapt->_statusInitTerm = Status;
    NdisSetEvent(&pAdapt->_evtInitTerm);
}

// ---------------------------------------------------------------------------------------
// ProtocolRequestComplete
//
// A call to NdisRequest completes by calling this function.
// ---------------------------------------------------------------------------------------
void        
ProtocolRequestComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    PNDIS_REQUEST pNdisRequest, 
    NDIS_STATUS Status
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;
    CNdisRequest * pReq = CONTAINING_RECORD(pNdisRequest, CNdisRequest, _req);

    // Wake up the caller.
    pAdapt->_statusInitTerm = Status;
    NdisSetEvent(&pAdapt->_evtInitTerm);

    RnMemFree(pReq);
}

// ---------------------------------------------------------------------------------------
// ProtocolResetComplete
//
// If we ever issued a reset, which we do not, Ndis would call this function on
// the completion of that reset.
// ---------------------------------------------------------------------------------------
void        
ProtocolResetComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS Status
    )
{
    AssertSz(FALSE, "Unexpected call to PtResetComplete!");
}

// ---------------------------------------------------------------------------------------
// ProtocolStatus
//
// This call tells me that the NIC is going down temporarily. We ignore this call.
// @@@ This probably shouldn't be ignored. The client may need this notification.
// ---------------------------------------------------------------------------------------
void        
ProtocolStatus(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS GeneralStatus, 
    PVOID StatusBuffer, 
    UINT StatusBufferSize
    )
{
}

// ---------------------------------------------------------------------------------------
// ProtocolStatusComplete
//
// This tells me that the NIC is back online. We ignore this call.
// ---------------------------------------------------------------------------------------
void        
ProtocolStatusComplete(
    NDIS_HANDLE ProtocolBindingContext
    )
{
}

// ---------------------------------------------------------------------------------------
// ProtocolPNPHandler
//
// Ndis calls this function to pass us plug-and-play events. We ignore all but two.
// First are power events, for which NDIS requires support. 
// Second are global reconfiguration events that could screw up our protocol bindings.
// ---------------------------------------------------------------------------------------
NDIS_STATUS 
ProtocolPNPHandler(
    NDIS_HANDLE ProtocolBindingContext, 
    PNET_PNP_EVENT pNetPnPEvent
    )
{
    CAdapter *  pAdapt = (CAdapter *) ProtocolBindingContext;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    TraceSz2(RnAdapter, "ProtocolPNPHandler pAdapt %p, NetEvent 0x%x",
             pAdapt, pNetPnPEvent->NetEvent);

    switch(pNetPnPEvent->NetEvent)
    {
     case NetEventSetPower:
        pAdapt->_powerState = *(PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;
        break;

     case NetEventReconfigure :
        if(pAdapt == NULL)
        {
            // This was a global reconfiguration event.
            // Make sure our protocol is bound to underlying miniports and get out.
            NdisReEnumerateProtocolBindings(g_hNdisProtocol);
        }
        break;

    case NetEventQueryPower:
    case NetEventQueryRemoveDevice:
    case NetEventCancelRemoveDevice:
    case NetEventBindList:
    case NetEventPnPCapabilities:
        break;

    default:
        Status = NDIS_STATUS_NOT_SUPPORTED;
        break;

    }

    return Status;
}

BOOL
CAdapter::IndicatePacket(
    BYTE *pbHeader,
    DWORD cbHeader
    )
{
    CEnetHdr * pEnetHdr = (CEnetHdr *)pbHeader;
   
    if (cbHeader < sizeof(CEnetHdr))
    {
        TraceSz2(RnRecv, "IndicatePacket: size (%d bytes) is smaller than CEnetHdr (%d bytes)", 
                 cbHeader, sizeof(CEnetHdr));
        return FALSE;
    }

    return RnVnetIndicate(&_ea, &pEnetHdr->_eaDst);

}

void     
CAdapter::RecvPacket(
    CPacket * ppkt
    )
{
    TraceSz3(RnRecv, "CAdapter::RecvPacket processing packet %p, adapter %p, cb %u",
             ppkt, this, ppkt->_cb);

    //
    // See what type of packet we have
    //

    // The pb/cb variables scan down the buffer as headers are validated.  They always
    // specify the amount of the original data is remaining to be processed.

    BYTE *  pb = ppkt->_pb;
    UINT    cb = ppkt->_cb;

    // Process the Ethernet header

    CEnetHdr * pEnetHdr = ppkt->_pEnetHdr = (CEnetHdr *)pb;

    if (cb < sizeof(CEnetHdr))
    {
        TraceSz3(RnRecv, "%s: Frame (%d bytes) is smaller than CEnetHdr (%d bytes)",
                 ppkt->Str(), cb, sizeof(CEnetHdr));

        goto drop;
    }

    USHORT usType = pEnetHdr->_wType;

    // @@@ This looks suspicious. Why are we comparing the type to the max ethernet data 
    // size (1500)?
    if (NTOHS(usType) <= ENET_DATA_MAXSIZE)
    {
        CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;
        
        if (cb < sizeof(CIeeeHdr))
        {
            TraceSz3(RnRecv, "%s: Frame (%d bytes) is smaller than CIeeeHdr (%d bytes)",
                     ppkt->Str(), cb, sizeof(CIeeeHdr));
            goto drop;
        }

        if (!pIeeeHdr->IsEnetFrame())
        {
            TraceSz1(RnRecv, "%s: Frame has unrecognized ethernet header", ppkt->Str());
            goto drop;
        }

        // Update the frame type from the IEEE header

        usType = pIeeeHdr->_wTypeIeee;

        // Skip over the difference between the IEEE header and the normal ethernet header

        pb += sizeof(CIeeeHdr);
        cb -= sizeof(CIeeeHdr);
    }
    else
    {
        pb += sizeof(CEnetHdr);
        cb -= sizeof(CEnetHdr);
    }

    if (ppkt->_pEnetHdr->_eaDst.IsBroadcast())
    {
        ppkt->_uiFlags |= PKTF_BROADCAST;
    }
    
    if (usType == ENET_TYPE_ARP)
    {
        ppkt->_uiFlags |= PKTF_ARP;
    }
    else if (usType == ENET_TYPE_XBOX)
    {
        ppkt->_uiFlags |= PKTF_XBOX;
    }
    else if (usType == ENET_TYPE_IP)
    {
        // See if this is a DHCP packet

        // process the IP header
        
        if (cb < sizeof(CIpHdr))
        {
            TraceSz1(RnDhcpDiscard, "not enough bytes for IP header %s", ppkt->Str());
            goto xmit;
        }

        CIpHdr * pIpHdr = (CIpHdr *)pb;
        UINT cbIpHdrLen = (pIpHdr->_bVerHdr & 0x0F) << 2;

        if (pIpHdr->_bProtocol != IPPROTOCOL_UDP)
        {
            TraceSz2(RnDhcpDiscard, "Protocol %d is not UDP %s", pIpHdr->_bProtocol, ppkt->Str());
            goto xmit;
        }

        pb += cbIpHdrLen;
        cb -= cbIpHdrLen;

        // process UDP header

        if (cb < sizeof(CUdpHdr))
        {
            TraceSz1(RnDhcpDiscard, "not enough bytes for UDP header %s", ppkt->Str());
            goto xmit;
        }

        CUdpHdr * pUdpHdr = (CUdpHdr *) pb;

        if (pUdpHdr->_ipportDst != DHCP_CLIENT_PORT && pUdpHdr->_ipportDst != DHCP_SERVER_PORT)
        {
            TraceSz2(RnDhcpDiscard, "Port %d is not for DHCP %s", pUdpHdr->_ipportDst, ppkt->Str());
            goto xmit;
        }

        ppkt->_uiFlags |= PKTF_DHCP;
    }

xmit:

    RnVnetXmit(_ea, ppkt);
    return;

drop:
    ppkt->Complete();
}


void CAdapter::SetFilterMode(DWORD dwFilter)
{
    NDIS_STATUS Status;
    
    TraceSz1(RnAdapter, "switch on promiscuous mode for adapter %p", this);

    // set the new packet filter

    Status = MakeSynchronousNdisRequest(NdisRequestSetInformation,
                                        OID_GEN_CURRENT_PACKET_FILTER, 
                                        &dwFilter, 
                                        sizeof(dwFilter));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TraceSz1(RnInit, "SetPromiscuousMode set (GEN_CURRENT_PACKET_FILTER) failed %x", Status);
    }

    TraceSz2(RnAdapter, "Adapter %p filter switched to %x", this, dwFilter);


}

BOOL            
CAdapter::MakeNdisRequest(
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid, 
    PVOID InformationBuffer, 
    ULONG InformationBufferLength
    )
{
    NDIS_STATUS Status;
    CNdisRequest * pReq;

    if (_dwState == ADAPT_STATE_CLEANUP)
    {
        return FALSE;
    }

    pReq = (CNdisRequest *) RnMemAllocZ(sizeof(CNdisRequest), PTAG_CNdisRequest);

    if (!pReq)
    {
        return FALSE;
    }

    pReq->_req.RequestType = RequestType;
    pReq->_req.DATA.QUERY_INFORMATION.Oid = Oid;
    pReq->_req.DATA.QUERY_INFORMATION.InformationBuffer = InformationBuffer;
    pReq->_req.DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;
    
    NdisRequest(
        &Status,
        _hLowerBinding,
        &pReq->_req
        );
    
    if(Status != NDIS_STATUS_PENDING)
    {
        ProtocolRequestComplete(
            (NDIS_HANDLE) this,
            &pReq->_req,
            Status
            );
    }

    return TRUE;
}


NDIS_STATUS
CAdapter::MakeSynchronousNdisRequest(
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid, 
    PVOID InformationBuffer, 
    ULONG InformationBufferLength
    )
{
    BOOL fRet;
    NDIS_STATUS Status;

    fRet = MakeNdisRequest(RequestType,
                           Oid,
                           InformationBuffer,
                           InformationBufferLength);

    if (fRet)
    {
        //
        // PtRequestComplete will signal this event
        // when NdisRequest is done.
        //
        
        NdisWaitEvent(&_evtInitTerm, 0);
        NdisResetEvent(&_evtInitTerm);
        
        Status = _statusInitTerm;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
    
}

void
RnDeleteAdapter(CAdapter * pAdapter)
{
    TraceSz1(RnInit, "Adapter %p deleted", pAdapter);
    Assert(pAdapter->_dwState == ADAPT_STATE_CLEANUP);

    delete pAdapter;
}


// ---------------------------------------------------------------------------------------
// List of available adapters
// ---------------------------------------------------------------------------------------

CReaderWriterLock g_rwlockAdapters; // synchronize adapter list
LIST_ENTRY g_lhAdapters;            // list of CAdapters
DWORD      g_cAdapt;                // number of adapters

void RnAdaptInit()
{
    InitializeListHead(&g_lhAdapters);
    g_rwlockAdapters.Init();
    g_cAdapt = 0;
}

void RnAdaptTerm()
{
    Assert(g_cAdapt == 0);
}

void RnAddAdapter(CAdapter * pAdapt)
{
    LOCK_STATE ls;
    g_rwlockAdapters.WriteLock(&ls);

    g_cAdapt++;
    InsertTailList(&g_lhAdapters, &pAdapt->_le);

    g_rwlockAdapters.WriteUnlock(&ls);

    RnResetAdaptersFilterMode();
}

void RnResetAdaptersFilterMode()
{
    LOCK_STATE ls;
    g_rwlockAdapters.ReadLock(&ls);
    
    for (LIST_ENTRY* pEntry = g_lhAdapters.Flink; pEntry != &g_lhAdapters; pEntry = pEntry->Flink)
    {
        CAdapter * pAdapt = CONTAINING_RECORD(pEntry, CAdapter, _le);
        pAdapt->SetFilterMode(RnVnetGetFilterMode(&pAdapt->_ea));
    }

    g_rwlockAdapters.ReadUnlock(&ls);
}

void RnRemoveAdapter(CAdapter * pAdapt)
{
    LOCK_STATE ls;
    g_rwlockAdapters.WriteLock(&ls);

    g_cAdapt--;
    RemoveEntryList(&pAdapt->_le);

    g_rwlockAdapters.WriteUnlock(&ls);
}

NTSTATUS RnNicXmit(CEnetAddr eaNic, CPacketQueue * ppq)
{
    NTSTATUS status = STATUS_NOT_FOUND;
    LIST_ENTRY * pEntry;
    
    LOCK_STATE ls;
    g_rwlockAdapters.ReadLock(&ls);

    for (pEntry = g_lhAdapters.Flink; pEntry != &g_lhAdapters; pEntry = pEntry->Flink)
    {
        CAdapter * pAdapt = CONTAINING_RECORD(pEntry, CAdapter, _le);

        if (eaNic.IsEqual(pAdapt->_ea))
        {
            status = pAdapt->NicXmit(ppq);
            Assert(ppq->IsEmpty());
            break;
        }
    }

    g_rwlockAdapters.ReadUnlock(&ls);
    return status;
}

BOOL RnDoesAdapterExist(CEnetAddr *peaNic)
{
    LIST_ENTRY * pEntry;
    BOOL fFound = FALSE;
    
    LOCK_STATE ls;
    g_rwlockAdapters.ReadLock(&ls);

    for (pEntry = g_lhAdapters.Flink; pEntry != &g_lhAdapters; pEntry = pEntry->Flink)
    {
        CAdapter * pAdapt = CONTAINING_RECORD(pEntry, CAdapter, _le);

        if (peaNic->IsEqual(pAdapt->_ea))
        {
            fFound = TRUE;
            break;
        }
    }

    g_rwlockAdapters.ReadUnlock(&ls);
    return fFound;
}

NTSTATUS
RnReadAdaptersIoctl(
    PIRP pIrp, 
    CVirtualNet * pvnet
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    TraceSz2(RnIoctl, "RnGetAdaptersIoctl(pIrp = %p, pvnet = %p)",
             pIrp, pvnet);

    BYTE* pb = (PBYTE)pIrp->AssociatedIrp.SystemBuffer;
    DWORD cb = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
    // Need lock b/c we're checking the output buffer size against the adapter count, then 
    // copying the data. This is not atomic.
    DWORD dwAdapterIdx = 0;
    LOCK_STATE ls;
    g_rwlockAdapters.ReadLock(&ls);

    if (pb == NULL || cb == 0)
    {
        // User just wants a count of adapters, or buffer is too small. Remember, the 
        // number of buffers *could* change between this call and the next.. oh well.  
        // Unfortunately, we can't provide the count of adapters to the caller in this 
        // case, as the I/O manager is blocking our attempts to set IoStatus.Information.  
        // So we get to return an error, and no matter what we set .Information to, it 
        // will be returned as 0. Sigh.
        //
        // Returning an error here, like STATUS_BUFFER_TOO_SMALL, will prevent the io 
        // manager from copying any data. Any non-error, including warnings, WILL cause 
        // bytes to be copied (IoStatus.Information specifies how many).  
        // STATUS_BUFFER_OVERFLOW is a warning, by the way.
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // Copy the adapter info into IRP
    RAWNIC_ADAPTER_INFO * pAdapters = (RAWNIC_ADAPTER_INFO*) pb;
    for (LIST_ENTRY * pEntry = g_lhAdapters.Flink; pEntry != &g_lhAdapters; pEntry = pEntry->Flink)
    {
        CAdapter * pAdapt = CONTAINING_RECORD(pEntry, CAdapter, _le);
    
        // make sure the IRP is big enough for the adapters structure
        if(cb < sizeof(RAWNIC_ADAPTER_INFO) * (dwAdapterIdx + 1))
        {
            // Out of space. We've copied in what we can, tell the user the buffer was 
            // insufficient. This is a warning, so the IO manager should still copy the 
            // data for us.
            Status = STATUS_BUFFER_OVERFLOW;
            goto Exit;
        }

        C_ASSERT(sizeof(pAdapters[dwAdapterIdx].MacAddress) == sizeof(pAdapt->_ea._ab));
        memcpy(pAdapters[dwAdapterIdx].MacAddress, pAdapt->_ea._ab, sizeof(pAdapt->_ea._ab));
        pAdapters[dwAdapterIdx].State = pAdapt->_dwState;
        pAdapters[dwAdapterIdx].MacOptions = pAdapt->_dwMacOptions;

        dwAdapterIdx++;
    }

Exit:
    // Return the buffer size we filled
    pIrp->IoStatus.Information = sizeof(RAWNIC_ADAPTER_INFO) * dwAdapterIdx;
    g_rwlockAdapters.ReadUnlock(&ls);

    // DeviceControl will complete the IRP
    return Status;
}


// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(KmXmitFail,       TAG_ENABLE);        // Trace failed sends


// ---------------------------------------------------------------------------------------
// CAdapter::NicXmit
//
// Transmits packets to the network.
// ---------------------------------------------------------------------------------------
NTSTATUS
CAdapter::NicXmit(CPacketQueue * ppq)
{
    PNDIS_PACKET apnpacket[MAX_BATCH_SEND_SIZE];

    if(ppq->Count() > MAX_BATCH_SEND_SIZE)
    {
        Assert("CAdapter::NicXmit, ppq->Count() > MAX_SEND_BATCH_SIZE");
        return STATUS_INVALID_PARAMETER;
    }
    
    // Make sure we're active.
    if (_dwState != ADAPT_STATE_READY)
    {
        TraceSz1(KmXmitFail, "[DISCARD] CAdapter::NicXmit adapter %p not ready", this);
        return STATUS_DEVICE_NOT_READY;
    }

    DWORD cPackets = ppq->Count();
    DWORD i;

    for(i=0; i < cPackets; i++)
    {
        CPacket* ppkt = ppq->RemoveHead();

        MmInitializeMdl(
            (PMDL)ppkt->_pnbXmit,
            ppkt->_pb,
            ppkt->_cb
            );

        MmBuildMdlForNonPagedPool((PMDL)ppkt->_pnbXmit);
        NdisChainBufferAtBack(ppkt->_pnpXmit, ppkt->_pnbXmit);

        ppkt->CompletePush(&CAdapter::NicXmitComplete);

        // Save a pointer to the packetinfo in the NDIS packet
        SET_NDIS_PACKET_CONTEXT(ppkt->_pnpXmit, ppkt);

        apnpacket[i] = ppkt->_pnpXmit;
    }
    Assert(ppq->IsEmpty());

    NdisSendPackets(
        _hLowerBinding,
        apnpacket,
        cPackets
        );

    return STATUS_SUCCESS;
}


// ---------------------------------------------------------------------------------------
// CAdapter::NicXmitComplete (static)
//
// Resets the embedded NDIS_PACKET and associated MDLs so it can be reused.
// ---------------------------------------------------------------------------------------
void
CAdapter::NicXmitComplete(CPacket * ppkt)
{
    MmPrepareMdlForReuse(ppkt->_pnbXmit);
    
    NdisReinitializePacket(ppkt->_pnpXmit);
    ppkt->Complete();
}


// ---------------------------------------------------------------------------------------
// ProtocolSendComplete
//
// Called by Ndis when a pending NdisSend call completes.
// ---------------------------------------------------------------------------------------
void
ProtocolSendComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET pnp,
    IN NDIS_STATUS  Status
    )
{
    CPacket * ppkt = GET_PACKET_FROM_NDIS_PACKET(pnp);

    Assert(ppkt->_pBatch);
    CPacketBatch* pBatch = ppkt->_pBatch;

    if (Status != NDIS_STATUS_SUCCESS)
    {
        pBatch->_status = Status; // remember, don't overwrite errors with SUCCESS
        TraceSz2(KmXmitFail, "Packet %p xmit failed async with status %x\n",
                 ppkt, Status);
    }

    ppkt->Complete();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnlocks.h ===
// ---------------------------------------------------------------------------------------
// rnlocks.h
//
// Raw Nic Driver locks (kernel mode versions)
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __RNLOCKS_H_
#define __RNLOCKS_H_


// Refer to CReaderWriterLock2 in \private\common\inc\locks.h
//
// This class is based on that.
//
//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.
//--------------------------------------------------------------------

ExternTag(RnLocks);

// The NDIS read/write lock looks great. However, quick testing indicates it crashes the 
// kernel when stopping or unbinding rawnic. My first guess says this is due to IRQL 
// issues. Rather than investigate, we're just going to revert back to our custom 
// reader/writer lock which has already been tested and seems to work fine.
//
// I'm leaving the code in for reference, however, in case we want to do this in the 
// future.
//

#ifndef RNLOCKS_USE_NDIS_RWLOCK

class CReaderWriterLock
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

private:
    void _LockSpin(bool fWrite)
    {
        LARGE_INTEGER sleepTime = { -1 };
        LONG cBaseSpins = 10000;

        if (KeNumberProcessors < 2)
            cBaseSpins = 1; // must loop once to call _TryRWLock
        // Was:
//         if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
//             cSpins = 1; // must loop once to call _TryRWLock

        for (;;)
        {
            for (int i = cBaseSpins;  --i >= 0;  )
            {
                bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

                if (fLock)
                {
                    // yay
                    return;
                }
                YieldProcessor();
            }

            // @@@ review this What do we do here while in kernel mode? Is this ok?
            // Negative units for sleepTime mean relative time. Expressed as 
            // 100-nanosecond intervals.
            if (KeGetCurrentIrql() <= APC_LEVEL)
            {
                TraceSz2(RnLocks, "%p _LockSpin sleeping... (state = 0x%08X)", this, m_lRW);
                NTSTATUS status = KeDelayExecutionThread(KernelMode, FALSE, &sleepTime);
            }
            else
            {
                TraceSz2(RnLocks, "%p _LockSpin would sleep but current IRQL is > APC_LEVEL (state = 0x%08X)", this, m_lRW);
            }
            // Was:
//             Sleep(dwSleepTime);
//             dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        }
    }

    INLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent == InterlockedCompareExchange(
                                 const_cast<LONG*>(&m_lRW), lNew, lCurrent);
    }

    INLINE void _WriteLockSpin()
    {
        // Add ourselves to the queue of waiting writers
        for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
        {
            YieldProcessor();
        }

        _LockSpin(true);
    }
   
    INLINE void _ReadLockSpin()  
    { 
        _LockSpin(false); 
    }

    INLINE bool _TryWriteLock(
        LONG nIncr)
    {
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        return ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
    }

    INLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        return ((l & SL_WRITERS_MASK) == 0
                &&  _CmpExch(l + SL_READER_INCR, l));
    }

public:

    void Init()
    {
        m_lRW = SL_FREE;
    }

    INLINE void WriteLock(PLOCK_STATE pLockState)
    {
        UNREFERENCED_PARAMETER(pLockState);
        // Optimize for the common case
        //TraceSz2(RnLocks, "%p WriteLock (state = 0x%08X)", this, m_lRW);
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            //TraceSz2(RnLocks, "%p WriteLock _TryWriteLock succeeded (state = 0x%08X)", 
            //this, m_lRW);
            return;
        }

        //TraceSz2(RnLocks, "%p WriteLock spinning... (state = 0x%08X)", this, m_lRW);
        _WriteLockSpin();
    } 

    INLINE void ReadLock(PLOCK_STATE pLockState)
    {
        UNREFERENCED_PARAMETER(pLockState);
        // Optimize for the common case
        //TraceSz2(RnLocks, "%p ReadLock (state = 0x%08X)", this, m_lRW);
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    INLINE void WriteUnlock(PLOCK_STATE pLockState)
    {
        UNREFERENCED_PARAMETER(pLockState);
        //TraceSz2(RnLocks, "%p WriteUnlock (state = 0x%08X)", this, m_lRW);
        for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
             !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
             l = m_lRW)
        {
            YieldProcessor();
        }
    }

    INLINE void ReadUnlock(PLOCK_STATE pLockState)
    {
        UNREFERENCED_PARAMETER(pLockState);
        //TraceSz2(RnLocks, "%p ReadUnlock (state = 0x%08X)", this, m_lRW);
        for (LONG l = m_lRW;  
             !_CmpExch(l - SL_READER_INCR, l);  
             l = m_lRW)
        {
            YieldProcessor();
        }
    }

    INLINE bool IsWriteLocked() const
    {
        return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;
    }

    INLINE bool IsReadLocked() const
    {
        return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;
    }
};

#else

class CReaderWriterLock
{
private:

    NDIS_RW_LOCK _lock;

public:

    void Init()
    {
        NdisInitializeReadWriteLock(&_lock);     
    }

    INLINE void WriteLock(PLOCK_STATE pLockState)
    {
        NdisAcquireReadWriteLock(&_lock, TRUE, pLockState);
    }

    INLINE void ReadLock(PLOCK_STATE pLockState)
    {
        NdisAcquireReadWriteLock(&_lock, FALSE, pLockState);
    }

    INLINE void WriteUnlock(PLOCK_STATE pLockState)
    {
        NdisReleaseReadWriteLock(&_lock, pLockState);
    }
    
    INLINE void ReadUnlock(PLOCK_STATE pLockState)
    {
        NdisReleaseReadWriteLock(&_lock, pLockState);
    }
};

#endif

#endif  // __RNLOCKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnp.h ===
// ---------------------------------------------------------------------------------------
// rnp.h
//
// Raw Nic Access Driver
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __RNP_H_
#define __RNP_H_

// ---------------------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------------------

#if DBG
#define RN_FEATURE_ASSERT
#endif

#define RN_FEATURE_TRACE

#ifdef RN_FEATURE_ASSERT
#pragma message("  RN_FEATURE_ASSERT")
#endif

#ifdef RN_FEATURE_TRACE
#pragma message("  RN_FEATURE_TRACE")
#endif

// ---------------------------------------------------------------------------------------
// System Includes
// ---------------------------------------------------------------------------------------

extern "C"
{
#define NDIS_WDM 1
#include <ntddk.h>
#include <ntintsafe.h>
#include <ndis.h>
#include <tdikrnl.h>
#define _INC_WINDOWS
}

typedef CHAR BOOL;
typedef BYTE * PBYTE;
typedef DWORD * PDWORD;

#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>

#include <rnio.h>

#define LPOVERLAPPED PVOID
#include <rncommon.h>

// ---------------------------------------------------------------------------------------
// Pool Tags
// ---------------------------------------------------------------------------------------

#define PTAG_CAdapter           NTOHL_('RnAD')
#define PTAG_ExternalDataBuffer NTOHL_('RnED')
#define PTAG_CPacket            NTOHL_('RnPk')
#define PTAG_CNdisRequest       NTOHL_('RnNR')
#define PTAG_CVirtualNet        NTOHL_('RnVN')
#define PTAG_CPacketBatch       NTOHL_('RnPB')

// ---------------------------------------------------------------------------------------
// Assert
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

INLINE
void RnDbgBreak()
{
    DbgBreakPoint();
}

#ifdef RN_FEATURE_ASSERT

    #define RnDbgAssert(expr,file,line,msg) \
            RtlAssert((PVOID)((msg)?(msg):(expr)),file,line,NULL)

    char * __cdecl RnDbgAssertFmt(char const * pszFmt, ...);
    const char * RnDbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire);

    #define ASSERT_BEG(x)   do { if (!(x)) { char * __pch__ = RnDbgAssertFmt(
    #define ASSERT_END(x)   ); RnDbgAssert(#x,__FILE__,__LINE__,__pch__); } } while (0)

    #define Assert(x) \
            do { if (!(x)) { RnDbgAssert(#x,__FILE__,__LINE__,NULL); } } while (0)
    #define AssertSz(x,sz) \
            ASSERT_BEG(x) sz ASSERT_END(x)
    #define AssertSz1(x,sz,a1) \
            ASSERT_BEG(x) sz,a1 ASSERT_END(x)
    #define AssertSz2(x,sz,a1,a2) \
            ASSERT_BEG(x) sz,a1,a2 ASSERT_END(x)
    #define AssertSz3(x,sz,a1,a2,a3) \
            ASSERT_BEG(x) sz,a1,a2,a3 ASSERT_END(x)
    #define AssertSz4(x,sz,a1,a2,a3,a4) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4 ASSERT_END(x)
    #define AssertSz5(x,sz,a1,a2,a3,a4,a5) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5 ASSERT_END(x)
    #define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6 ASSERT_END(x)
    #define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7 ASSERT_END(x)
    #define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8 ASSERT_END(x)
    #define AssertSz9(x,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 ASSERT_END(x)
    #define AssertList(ple) \
            do { const char * __psz__ = RnDbgVerifyList(ple,NULL); \
            if (__psz__) { RnDbgAssert("AssertList("#ple")",__FILE__,__LINE__,__psz__); } } while (0)
    #define AssertListEntry(ple,pleReq) \
            do { const char * __psz__ = RnDbgVerifyList(ple,pleReq); \
            if (__psz__) { RnDbgAssert("AssertListEntry("#ple","#pleReq")",__FILE__,__LINE__,__psz__); } } while (0)

#else

    #define Assert(x)
    #define AssertSz(x,sz)
    #define AssertSz1(x,sz,a1)
    #define AssertSz2(x,sz,a1,a2)
    #define AssertSz3(x,sz,a1,a2,a3)
    #define AssertSz4(x,sz,a1,a2,a3,a4)
    #define AssertSz5(x,sz,a1,a2,a3,a4,a5)
    #define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6)
    #define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7)
    #define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8)
    #define AssertSz9(x,sz, a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define AssertList(ple)
    #define AssertListEntry(ple,pleReq)

#endif

#undef  ASSERT
#define ASSERT(x)   Assert(x)

// ---------------------------------------------------------------------------------------
// Trace
// ---------------------------------------------------------------------------------------

#ifdef RN_FEATURE_TRACE

    void __cdecl RnDbgTrace(const char * szTag, const char * szFmt, ...);

    #define TAG_DISABLE     0
    #define TAG_ENABLE      1
    #define TAG_BREAK       2
    #define Tag(t)  t_##t
    
    #define DefineTag(t,i)  int Tag(t) = (i)
        
    #define ExternTag(t)    extern int Tag(t)
    #define TRACE_BEG(t)    do { if (Tag(t) > 0) { RnDbgTrace(#t,
    #define TRACE_END(t)    ); if (Tag(t) > 1) RnDbgBreak(); } } while (0)

    #define TraceSz(t,sz) \
            TRACE_BEG(t) sz TRACE_END(t)
    #define TraceSz1(t,sz,a1) \
            TRACE_BEG(t) sz,a1 TRACE_END(t)
    #define TraceSz2(t,sz,a1,a2) \
            TRACE_BEG(t) sz,a1,a2 TRACE_END(t)
    #define TraceSz3(t,sz,a1,a2,a3) \
            TRACE_BEG(t) sz,a1,a2,a3 TRACE_END(t)
    #define TraceSz4(t,sz,a1,a2,a3,a4) \
            TRACE_BEG(t) sz,a1,a2,a3,a4 TRACE_END(t)
    #define TraceSz5(t,sz,a1,a2,a3,a4,a5) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5 TRACE_END(t)
    #define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6 TRACE_END(t)
    #define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7 TRACE_END(t)
    #define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8 TRACE_END(t)
    #define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 TRACE_END(t)
    #define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 TRACE_END(t)
    #define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11 TRACE_END(t)
    #define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12 TRACE_END(t)
    #define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13 TRACE_END(t)
    #define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14 TRACE_END(t)
    #define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15 TRACE_END(t)
    #define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 TRACE_END(t)
#else

    #define Tag(t)  0

    #define DefineTag(t,i)
    #define ExternTag(t)
    #define TraceSz(t,sz)
    #define TraceSz1(t,sz,a1)
    #define TraceSz2(t,sz,a1,a2)
    #define TraceSz3(t,sz,a1,a2,a3)
    #define TraceSz4(t,sz,a1,a2,a3,a4)
    #define TraceSz5(t,sz,a1,a2,a3,a4,a5)
    #define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6)
    #define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7)
    #define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8)
    #define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
    #define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
    #define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
    #define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
    #define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)
    #define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
    #define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)

#endif

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

class   CPacket;
struct  CAdapter;
struct  CVirtualNet;
struct  CPacketBatch;

extern RAWNIC_COUNTERS_GLOBAL g_counters;

// ---------------------------------------------------------------------------------------
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
// ---------------------------------------------------------------------------------------

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

// ---------------------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------------

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)
#define IsListNull(_ple)        ((_ple)->Flink == NULL)

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

#define DECLARE_NEW_DELETE(class) \
   INLINE void * operator new(size_t cb) { return(RnMemAlloc(cb, PTAG_##class)); } \
   INLINE void operator delete(void * pv) { RnMemFree(pv); }

#define DECLARE_NEW_DELETE_ZERO(class) \
   INLINE void * operator new(size_t cb) { return(RnMemAllocZ(cb, PTAG_##class)); } \
   INLINE void operator delete(void * pv) { RnMemFree(pv); }

char *          RnHexStr(const void * pv, size_t cb);

#define STRING_CONST(x)         {sizeof(x)-2, sizeof(x), x}

#define GET_PACKET_FROM_NDIS_PACKET(pnp)    *((CPacket **)((pnp)->ProtocolReserved))
#define SET_NDIS_PACKET_CONTEXT(pnp, ppkt)  (*((CPacket **)((pnp)->ProtocolReserved)) = (ppkt))



// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------


#define MAX_BATCH_SEND_SIZE     1000
#define MAX_QUEUED_PACKETS      20000

#define MAX_PACKET_POOL_SIZE    0x0000FFFF
#define MIN_PACKET_POOL_SIZE    0x000000FF
#define MAX_BUFFER_POOL_SIZE    0x0000FFFF
#define MAX_SND_BUFFER_SIZE     1048576

#define ENET_DATA_MAXSIZE       1500
#define ENET_FRAME_MAXSIZE      (ENET_DATA_MAXSIZE + sizeof(CIeeeHdr))
#define ENET_TYPE_IP            HTONS_(0x0800)
#define ENET_TYPE_ARP           HTONS_(0x0806)
#define ENET_TYPE_XBOX          HTONS_(0x886F)

#define IPPROTOCOL_UDP          17

#define MAXIPHDRLEN             (15*4)
#define DONT_FRAGMENT           BIT(14)
#define MORE_FRAGMENTS          BIT(13)
#define FRAGOFFSET_MASK         0x1FFF

#define DHCP_SERVER_PORT        HTONS(67)
#define DHCP_CLIENT_PORT        HTONS(68)

// Get all the yummy macros into rnlocks
#include <rnlocks.h>

// ---------------------------------------------------------------------------------------
// CEnetAddr
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    char * Str() const;
};

#include <poppack.h>

// Ethernet Headers ----------------------------------------------------------------------


#include <pshpack1.h>

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    INLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    INLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

#include <poppack.h>

// IP Header in Network Byte Order -------------------------------------------------------

#include <pshpack1.h>

typedef DWORD CIpAddr;
typedef WORD CIpPort;

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address

    INLINE UINT     GetHdrLen()     { return((_bVerHdr & 0xF) << 2); }
};

#include <poppack.h>



// UDP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum
};

#include <poppack.h>


// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

typedef void (*PFNCOMPLETE)(class CPacket * ppkt);

#define PKTF_BROADCAST      0x00000001
#define PKTF_ARP            0x00000002
#define PKTF_DHCP           0x00000004
#define PKTF_XBOX           0x00000008

class CPacket
{
    // Member Functions ------------------------------------------------------------------

public:

    INLINE CPacket *    GetNextPkt()                { return(_ppktNext); }

    void                Reset();
    void                Complete();
    void                CompletePush(PFNCOMPLETE pfn);
    char *              Str() const;

    // Data ------------------------------------------------------------------------------

public:

    // NDIS fields -----------------------------------------------------------------------

    SINGLE_LIST_ENTRY   _sle;               // for lookaside list. MUST BE FIRST

    // recv information (allocated as needed)
    PNDIS_PACKET        _pnpRecv;           // received data descriptor
    PBYTE               _pbExternal;        // external data buffer

    // send information (preallocated)
    PNDIS_PACKET        _pnpXmit;           // sent data descriptor
    PNDIS_BUFFER        _pnbXmit;           // NDIS_BUFFER to describe a packet

    // NDIS independant fields -----------------------------------------------------------    
    DWORD               _dwPktNum;          // Serial number of packet for tracing
    
    // fields below here are zeroed by Reset()

    CPacket *           _ppktNext;          // Next packet in packet queue
    
    PIRP                _pSendIrp;          // for outgoing vadapter packets
    
    BYTE *              _pb;                // Scanning byte pointer during processing
    UINT                _cb;                // Scanning byte count during processing
    CEnetHdr *          _pEnetHdr;          // Pointer to CEnetHdr in the packet buffers
    UINT                _uiFlags;           // see RN_OPTION_BROADCAST_*

    UINT                _cpfn;              // Number of completion functions pushed
    PFNCOMPLETE         _apfn[9];           // Vector of completion functions
    CPacketBatch*       _pBatch;            // Pointer to CPacketBatch during batched sends

};

BOOL            RnPacketInit();
void            RnPacketTerm();
CPacket *       RnPacketAlloc();
CPacket*        RnPacketCopy(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

class CPacketQueue
{

public:

    void                InsertHead(CPacket * ppkt);
    void                InsertTail(CPacket * ppkt);
    void                InsertHead(CPacketQueue * ppq);
    CPacket *           RemoveHead();
    BOOL                Dequeue(CPacket * ppktDequeue);
    void                Complete();
    UINT                Count();

    INLINE void         Init()      { _ppktHead = NULL; _ppktTail = NULL; _cPackets=0; }
    INLINE BOOL         IsEmpty()   { return(_ppktHead == NULL); }
    INLINE CPacket *    GetHead()   { return(_ppktHead); }

private:

    CPacket *           _ppktHead;
    CPacket *           _ppktTail;
    volatile DWORD      _cPackets;

};

// ---------------------------------------------------------------------------------------
// CPacketBatchSend
// Used to track an ongoing packet send.  
// ---------------------------------------------------------------------------------------

struct CPacketBatch
{
    LIST_ENTRY          _le;                // For the look-aside list 
    PIRP                _pSendIrp;
    LONG                _lPackets;
    UINT                _cb;
    BOOL                _fNeedsCompletion;  // Is this batch responsible for calling IoCompleteRequest?
    NDIS_STATUS         _status;            // Represents the status from NDIS on send completion
};

VOID            RnPacketBatchInit();
VOID            RnPacketBatchTerm();
CPacketBatch*   RnPacketBatchAlloc();
void            RnPacketBatchRelease(CPacketBatch* pBatch);

// ---------------------------------------------------------------------------------------
// Memory
// ---------------------------------------------------------------------------------------

void *          RnMemAlloc(size_t size, ULONG tag);
void *          RnMemAllocZ(size_t size, ULONG tag);
void            RnMemFree(void * pv);


// ---------------------------------------------------------------------------------------
// NDIS entry points
// ---------------------------------------------------------------------------------------

struct CAdapter;

// incoming packets
INT         ProtocolReceivePacket(NDIS_HANDLE ProtocolBindingContext, PNDIS_PACKET Packet);
NDIS_STATUS ProtocolReceiveIndication(NDIS_HANDLE ProtocolBindingContext, NDIS_HANDLE MacReceiveContext, PVOID HeaderBuffer, UINT HeaderBufferSize, PVOID LookAheadBuffer, UINT LookaheadBufferSize, UINT PacketSize);
void        ProtocolReceiveComplete(NDIS_HANDLE ProtocolBindingContext);
void        ProtocolTransferDataComplete(NDIS_HANDLE ProtocolBindingContext, PNDIS_PACKET Packet, NDIS_STATUS Status, UINT BytesTransferred);

// outgoing packets
void        ProtocolSendComplete(NDIS_HANDLE ProtocolBindingContext, PNDIS_PACKET pnp, NDIS_STATUS  Status);

// init/term
void        ProtocolBindAdapter(PNDIS_STATUS Status, NDIS_HANDLE BindContext, PNDIS_STRING DeviceName, PVOID SystemSpecific1, PVOID SystemSpecific2);
void        ProtocolUnbindAdapter(PNDIS_STATUS Status, NDIS_HANDLE ProtocolBindingContext, NDIS_HANDLE UnbindContext);
void        ProtocolOpenAdapterComplete(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS Status, NDIS_STATUS OpenErrorStatus);
void        ProtocolCloseAdapterComplete(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS Status);

// set/query information
void        ProtocolRequestComplete(NDIS_HANDLE ProtocolBindingContext, PNDIS_REQUEST NdisRequest, NDIS_STATUS Status);

// adapter state changes
void        ProtocolResetComplete(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS Status);
void        ProtocolStatus(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS GeneralStatus, PVOID StatusBuffer, UINT StatusBufferSize);
void        ProtocolStatusComplete(NDIS_HANDLE ProtocolBindingContext);
NDIS_STATUS ProtocolPNPHandler(NDIS_HANDLE ProtocolBindingContext, PNET_PNP_EVENT pNetPnPEvent);

// driver and device entry points
void            DriverUnload(PDRIVER_OBJECT pDriverObject);
extern "C"
{
    NTSTATUS        DeviceCreate(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceCleanup(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceClose(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceControl(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceRead(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceWrite(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
}


// ---------------------------------------------------------------------------------------
// Locks
// ---------------------------------------------------------------------------------------
class CSpinLock
{
public:
    CSpinLock()
        { KeInitializeSpinLock(&_lock); }
    
    VOID
    Acquire(KIRQL * oldIrql)
        { ASSERT(oldIrql); KeAcquireSpinLock(&_lock, oldIrql); }

    VOID
    Release(KIRQL oldIrql)
        { KeReleaseSpinLock(&_lock, oldIrql); }

    VOID
    AcquireAtDpc()
        { KeAcquireSpinLockAtDpcLevel(&_lock); }

    VOID
    ReleaseAtDpc()
        { KeReleaseSpinLockFromDpcLevel(&_lock); }

private:
    KSPIN_LOCK _lock;
};


// ---------------------------------------------------------------------------------------
// Driver and device objects
// ---------------------------------------------------------------------------------------

extern HANDLE                       g_hNdisProtocol;        // Protocol Driver Handle
extern PDRIVER_OBJECT               g_pDriverObject;


// ---------------------------------------------------------------------------------------
// CAdapter
// ---------------------------------------------------------------------------------------


struct CAdapter
{
    DECLARE_NEW_DELETE(CAdapter);

    LIST_ENTRY              _le;                // links adapter into global list

    #define ADAPT_STATE_INIT    0
    #define ADAPT_STATE_READY   1
    #define ADAPT_STATE_CLEANUP 2

    DWORD                   _dwState;           // See ADAPT_STATE_*
    NET_DEVICE_POWER_STATE  _powerState;        // PnP power state

    NDIS_HANDLE             _hLowerBinding;     // BindingHandle for lower miniport

    NDIS_EVENT              _evtInitTerm;       // synchronizes init/term
    NDIS_STATUS             _statusInitTerm;    // init/term status

    CEnetAddr               _ea;                // our address
    DWORD                   _dwMacOptions;      // card options
    DWORD                   _dwTdiRecvFlags;    // ok to copy lookahead data directly?

    BOOL                    _bRequestActive;

    // Call this to see if a packet matches any listeners for this adapter. It is used to 
    // quickly reject packets in the NDIS ProtocolReceive function.
    BOOL                    IndicatePacket(BYTE *pbHeader, DWORD cbHeader);

    void                    RecvPacket(CPacket * ppkt);

    NTSTATUS                NicXmit(CPacketQueue * ppq);
    static void             NicXmitComplete(CPacket * ppkt);

    void                    SetFilterMode(DWORD dwFilter);

    BOOL                    MakeNdisRequest(
                                NDIS_REQUEST_TYPE RequestType,
                                NDIS_OID Oid, 
                                PVOID InformationBuffer, 
                                ULONG InformationBufferLength);

    NDIS_STATUS             MakeSynchronousNdisRequest(
                                NDIS_REQUEST_TYPE RequestType,
                                NDIS_OID Oid, 
                                PVOID InformationBuffer, 
                                ULONG InformationBufferLength);
        

};

void RnAdaptInit();
void RnAdaptTerm();
void RnResetAdaptersFilterMode();

// ---------------------------------------------------------------------------------------
// CIrpQueue
// ---------------------------------------------------------------------------------------

class CIrpQueue
{

public:

    BOOL                InsertTail(PIRP pIrp);
    PIRP                RemoveHead();
    void                CancelAll();

    INLINE void         Init(CSpinLock * pLock) { InitializeListHead(&_lh); _pLock = pLock; }
    INLINE BOOL         IsEmpty()               { return IsListEmpty(&_lh); }

private:

    static void         IrpCancelRoutine(PDEVICE_OBJECT pDevice, PIRP pIrp);

    LIST_ENTRY          _lh;
    CSpinLock *         _pLock;

};

// ---------------------------------------------------------------------------------------
// Adapter handle
// ---------------------------------------------------------------------------------------

#define RN_VNET_CONTEXT        NTOHL_('VNET')
#define RN_VNET_CONTEXT_X      NTOHL_('Xvnt')

// This should give us around a 100 ms update interval for the auto-tune adjustment 
// function.
#define RN_BATCHTHRESHOLD_TIMER_PERIOD_IN_MS 100

// What is auto-tuning of the batch threshold?
//
// The _recvDesiredLatency parameter can be specified be the caller to throttle back the 
// recv io completions. This is achieved by Rawnic by adjusting the _recvBatchThreshold 
// parameter on a regular basis, as determined by RN_BATCHTHRESHOLD_TIMER_PERIOD_IN_MS.  
// ThresholdUpdate() will automatically adjust the _recvBatchThreshold for the next 
// interval, based on the number of packets received in the previous interval, to try to 
// achieve the _recvDesiredLatency.
//
// If _recvDesiredLatency is 0, no auto-tuning will be performed. The forced batch size 
// will always be 1.
//
// Please note the _recvBatchThreshold is really only a suggestion; at high load, packets 
// will naturally get batched. The same applies for the desired latency -- it is really 
// only useful for forcefully modelling the low and mid-load behavior.
//

struct CVirtualNet
{
    DECLARE_NEW_DELETE(CVirtualNet);

    LIST_ENTRY      _le;                // links vnet into global list

    CEnetAddr       _eaNic;             // ea of the physical NIC to use
    CEnetAddr       _eaVirtual;         // virtual ea to use
    UINT            _uiRecvMask;        // determines what packets are acceptable
    BOOL            _fPromiscuous;      // grab all packets on the wire?
    RAWNIC_COUNTERS_ADAPTER _counters;  // perf-counter related storage
    LARGE_INTEGER   _recvMaxLatency;    // max latency allowed, in microseconds
    UINT            _recvBatchThreshold;// number of packets to batch before completing recv (auto-tuned)
    KTIMER          _recvTimer;         // timer to enforce max latency
    BOOL            _recvTimerSet;      // has max latency timer been set already?
    KDPC            _cmpltRecvDpc;      // dpc to represent max latency callback function
    volatile LONG   _cmpltInProgress;   // Is a Complete() currently in progress?
    
    UINT            _recvDesiredLatency;            // caller-supplied desired latency, in us
    LARGE_INTEGER   _recvIntervalLastUpdateTime;    // last time batch threshold was tuned
    UINT            _recvIntervalPacketCount;       // number of packets batched since last tune
    KTIMER          _thresholdUpdateTimer;          // timer to auto-tune _recvBatchThreshold
    KDPC            _thresholdUpdateDpc;            // dpc for auto-tune callback function

    CSpinLock       _lock;          // syncronizes the queues
    CPacketQueue    _pq;            // queued incoming packets
    CIrpQueue       _iq;            // queued IRPs

    NTSTATUS        InitVnet(PBYTE pbEaNic, PBYTE pbEaVirtual, DWORD dwOptions, DWORD recvMaxLatency, DWORD recvDesiredLatency);
    void            TermVnet();

    void            Xmit(CPacket * ppkt);   // Copies packets received off the net to user-mode
    BOOL            MatchPacketType(CPacket * ppkt);
    void            Complete(BOOL force);

    // auto-tunes the _recvBatchThreshold parameter to make it match the 
    // _recvDesiredLatency parameter. 
    void            ThresholdUpdate();  
   
    // Callbacks for timer functions
    static VOID     CompleteRecvDpc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID, PVOID);                        
    static VOID     ThresholdUpdateDpc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID, PVOID);                        
};

void RnVnetInit();
void RnVnetTerm();
DWORD RnVnetGetFilterMode(const CEnetAddr* pea);

// ---------------------------------------------------------------------------------------
// Adapter Handle Macros
// ---------------------------------------------------------------------------------------

#define MARK_VALID_VNET( pFileObject )                                      \
    ( (pFileObject)->FsContext2 = (PVOID)RN_VNET_CONTEXT )

#define MARK_INVALID_VNET( pFileObject )                                    \
    ( (pFileObject)->FsContext2 = (PVOID)RN_VNET_CONTEXT_X )

#define GET_VNET( pFileObject )                                             \
    ((CVirtualNet *)((pFileObject)->FsContext))

#define GET_PP_VNET( pFileObject )                                          \
    ((CVirtualNet **)&((pFileObject)->FsContext))

#define IS_VNET( pFileObject )                                              \
    ( (pFileObject)->FsContext2 == (PVOID)RN_VNET_CONTEXT )

#define IS_EX_VNET( pFileObject )                                           \
    ( (pFileObject)->FsContext2 == (PVOID)RN_VNET_CONTEXT_X )

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

NTSTATUS        RnReceiveIoctl(PIRP pIrp, CVirtualNet * pVnet);
NTSTATUS        RnSendIoctl(PIRP pIrp, CVirtualNet * pVnet);
NTSTATUS        RnReadCountersIoctl( PIRP pIrp, CVirtualNet * pVnet);
NTSTATUS        RnReadAdaptersIoctl( PIRP pIrp, CVirtualNet * pVnet);

NTSTATUS        RnNicXmit(CEnetAddr eaNic, CPacketQueue * ppq);
BOOL            RnVnetIndicate(CEnetAddr * pEaNic, CEnetAddr * pEaDst);
void            RnVnetXmit(CEnetAddr eaNic, CPacket * ppkt);
void            RnVnetComplete();

extern BOOL     g_fForceIndicationPath;
extern BOOL     g_fForceTransferDataPath;
extern BOOL     g_fForceCopyPacketPath;


// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rawnic_none_12.4.56.0_none_4dfb921801141584
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rawnic
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_MANIFEST_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_CATALOG_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_PAYLOAD_PATH=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rawnic,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnpacket.cpp ===
// ---------------------------------------------------------------------------------------
// rnpacket.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------


#include "rnp.h"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

PVOID       RnAllocPoolPacket(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
void        RnFreePoolPacket(PVOID pv);
void        RnPacketFree(CPacket * ppkt);
void        RnFreePacketCopy(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

BYTE                        g_abDummyPacket[ENET_FRAME_MAXSIZE];        // For RnAllocPoolPacket

HANDLE                      g_hNdisBufferPool;
NPAGED_LOOKASIDE_LIST       g_laCPacket;
HANDLE                      g_hNdisPacketPool;

#if _DEBUG
LONG                        g_lPacketCount;
#endif

// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

LONG g_lPktNum = 0;

void CPacket::CompletePush(PFNCOMPLETE pfn)
{
    Assert(_cpfn < dimensionof(_apfn));
    _apfn[_cpfn++] = pfn;
}

void CPacket::Complete()
{
    Assert(_cpfn > 0);
    (*_apfn[--_cpfn])(this);
}

void CPacket::Reset()
{
    memset(&this->_ppktNext, 0, sizeof(CPacket) - offsetof(CPacket, _ppktNext));

    // pktnum is just used for tracing and debugging. ok if number is off a little.
#if DBG
    _dwPktNum = (DWORD)InterlockedIncrement((LONG *)&g_lPktNum);
#else
    _dwPktNum = g_lPktNum++;
#endif

}

char * CPacket::Str() const
{
    STATIC_BUFFER(CPacketStr, 64, 64);

    if (_pEnetHdr)
    {
        _snprintf(pch, cch, "%08lX [src %s dst %s wtype %X cb %d]",
                  _dwPktNum, _pEnetHdr->_eaSrc.Str(), _pEnetHdr->_eaDst.Str(), NTOHS(_pEnetHdr->_wType), _cb);
    }
    else
    {
        _snprintf(pch, cch, "%08lX", _dwPktNum);
    }

    return(pch);
}

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

void CPacketQueue::InsertHead(CPacket * ppkt)
{
    if ((ppkt->_ppktNext = _ppktHead) == NULL)
        _ppktTail = ppkt;
    _ppktHead = ppkt;
    _cPackets++;
}

void CPacketQueue::InsertTail(CPacket * ppkt)
{
    if (_ppktTail)
        _ppktTail->_ppktNext = ppkt;
    else
        _ppktHead = ppkt;

    _ppktTail = ppkt;
    ppkt->_ppktNext = NULL;
    _cPackets++;
}

void CPacketQueue::InsertHead(CPacketQueue * ppq)
{
    Assert(!ppq->IsEmpty());
    if (_ppktTail == NULL)
        _ppktTail = ppq->_ppktTail;
    ppq->_ppktTail->_ppktNext = _ppktHead;
    _ppktHead = ppq->_ppktHead;
    _cPackets += ppq->_cPackets;
    ppq->Init();
}

CPacket * CPacketQueue::RemoveHead()
{
    Assert(!IsEmpty());

    CPacket * ppkt = _ppktHead;

    if ((_ppktHead = ppkt->_ppktNext) == NULL)
        _ppktTail = NULL;
    else
        ppkt->_ppktNext = NULL;

    _cPackets--;

    return(ppkt);
}

void CPacketQueue::Complete()
{
    while (!IsEmpty())
    {
        RemoveHead()->Complete();
    }
}

BOOL CPacketQueue::Dequeue(CPacket * ppktDequeue)
{
    CPacket **  pppkt    = &_ppktHead;
    CPacket *   ppktPrev = NULL;
    CPacket *   ppkt;

    for (; (ppkt = *pppkt) != NULL; ppktPrev = ppkt, pppkt = &ppkt->_ppktNext)
    {
        if (ppkt == ppktDequeue)
        {
            *pppkt = ppkt->_ppktNext;

            if (_ppktHead == NULL)
                _ppktTail = NULL;
            else if (_ppktTail == ppkt)
                _ppktTail = ppktPrev;

            _cPackets--;
            return(TRUE);
        }
    }

    return(FALSE);
}

UINT CPacketQueue::Count()
{
    return(_cPackets);
}

// ---------------------------------------------------------------------------------------
// CPacketBatch
// Used to track an ongoing packet send.  
// ---------------------------------------------------------------------------------------

KSPIN_LOCK g_lockPacketBatch;
LIST_ENTRY g_lhPacketBatch;
LONG       g_cPacketBatch;

VOID RnPacketBatchInit()
{
    InitializeListHead(&g_lhPacketBatch);
    KeInitializeSpinLock(&g_lockPacketBatch);
    g_cPacketBatch = 0;
}

VOID RnPacketBatchTerm()
{
    while(!IsListEmpty(&g_lhPacketBatch))
    {
        LIST_ENTRY* ple = RemoveHeadList(&g_lhPacketBatch);
        CPacketBatch* pBatch = CONTAINING_RECORD(ple, CPacketBatch, _le);
        RnMemFree(pBatch);
    }
}

CPacketBatch* RnPacketBatchAlloc()
{
    KIRQL oldIrql;
    CPacketBatch* pBatch = NULL;
    
    // Try look aside list first
    KeAcquireSpinLock(&g_lockPacketBatch, &oldIrql);
    if(!IsListEmpty(&g_lhPacketBatch))
    {
        LIST_ENTRY* ple = RemoveHeadList(&g_lhPacketBatch);
        pBatch = CONTAINING_RECORD(ple, CPacketBatch, _le);
    }
    KeReleaseSpinLock(&g_lockPacketBatch, oldIrql);

    if(pBatch)
    {
        NdisZeroMemory(pBatch, sizeof(CPacketBatch));
    }
    else
    {
        // No cigar. Allocate a new buffer
        pBatch = (CPacketBatch*)RnMemAllocZ(sizeof(CPacketBatch), PTAG_CPacketBatch);
        InterlockedIncrement(&g_cPacketBatch);
    }

    return pBatch;
}

void RnPacketBatchRelease(CPacketBatch* pBatch)
{
    KIRQL oldIrql;
    
    // Add entry to look-aside
    KeAcquireSpinLock(&g_lockPacketBatch, &oldIrql);
    InsertHeadList(&g_lhPacketBatch, &pBatch->_le);
    KeReleaseSpinLock(&g_lockPacketBatch, oldIrql);
}

// ---------------------------------------------------------------------------------------
// CPacket allocator
// ---------------------------------------------------------------------------------------

BOOL
RnPacketInit()
{
    NDIS_STATUS NdisStatus;

#if _DEBUG
    g_lPacketCount = 0;
#endif

    //
    // Set up the lookaside lists of CPackets.
    //
    
    NdisInitializeNPagedLookasideList(
        &g_laCPacket,                   // Lookaside
        &RnAllocPoolPacket,
        &RnFreePoolPacket,
        0,                              // Reserved
        sizeof(CPacket),                // Size
        PTAG_CPacket,                   // Tag
        0                               // Reserved
        );
    
    //
    // Set up the NDIS_PACKET pools
    //

    NdisAllocatePacketPoolEx(
        &NdisStatus,
        &g_hNdisPacketPool,
        MIN_PACKET_POOL_SIZE,
        MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
        sizeof(PVOID)
        );

    if (!NT_SUCCESS(NdisStatus))
    {
        goto fatal;
    }

    //
    // Set up the NDIS_BUFFER pools
    //

    NdisAllocateBufferPool(
        &NdisStatus,
        &g_hNdisBufferPool,
        MAX_BUFFER_POOL_SIZE
        );

    if (!NT_SUCCESS(NdisStatus))
    {
        goto fatal;
    }
    
    return TRUE;

fatal:

    RnPacketTerm();
    return FALSE;
}


void
RnPacketTerm()
{
    NdisDeleteNPagedLookasideList(&g_laCPacket);

    if (g_hNdisBufferPool)
    {
        NdisFreeBufferPool(g_hNdisBufferPool);
    }
    
    if (g_hNdisPacketPool)
    {
        NdisFreePacketPool(g_hNdisPacketPool);
    }

}


// ---------------------------------------------------------------------------------------
// CPacket private functions
// ---------------------------------------------------------------------------------------

CPacket *
RnPacketAlloc()
{
    CPacket * ppkt;

    ppkt = (CPacket *)NdisAllocateFromNPagedLookasideList(&g_laCPacket);
    
    if (ppkt)
    {
#if _DEBUG
        InterlockedIncrement(&g_lPacketCount);
#endif

        ppkt->Reset();

        ASSERT(ppkt->_pnbXmit);

        // remember how to clean up the packet.
        ppkt->CompletePush(&RnPacketFree);
    }
    
    return ppkt;
}


PVOID
RnAllocPoolPacket(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    CPacket * ppkt;
    NDIS_STATUS Status;
    
    ASSERT(PoolType == NonPagedPool);
    ASSERT(NumberOfBytes == sizeof(CPacket));
    ASSERT(Tag == PTAG_CPacket);

    ppkt = (CPacket *)RnMemAllocZ(sizeof(CPacket), PTAG_CPacket);

    if (ppkt)
    {
        // init the packet

        NdisAllocatePacket(
            &Status,
            &ppkt->_pnpXmit,
            g_hNdisPacketPool
            );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            goto fatal;
        }

        // allocate buffer descriptors big enough to hold a frame
        NdisAllocateBuffer(
            &Status,                                // Status
            &ppkt->_pnbXmit,                        // Buffer
            g_hNdisBufferPool,                      // PoolHandle
            g_abDummyPacket,                        // VirtualAddress
            ENET_FRAME_MAXSIZE                      // Length
            );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            goto fatal;
        }            
        
    }
    
    return ppkt;

fatal:
    
    RnPacketFree(ppkt);
    return NULL;
}

VOID
RnFreePoolPacket(
    IN PVOID pv
    )
{
    CPacket * ppkt = (CPacket *) pv;

    // clean up packet data

    if (ppkt->_pnpXmit)
    {
        NdisFreePacket(ppkt->_pnpXmit);
        ppkt->_pnpXmit = NULL;
    }

    if (ppkt->_pnbXmit)
    {
        NdisFreeBuffer(ppkt->_pnbXmit);
    }

    // other fields should already be clear
    Assert(ppkt->_pnpRecv == NULL);
    Assert(ppkt->_pbExternal == NULL);

    RnMemFree(ppkt);

}


void
RnPacketFree(CPacket * ppkt)
{
    ASSERT(ppkt);
    ASSERT(ppkt->_cpfn == 0);

    // fields should already be clear
    Assert(ppkt->_pnpRecv == NULL);
    Assert(ppkt->_pbExternal == NULL);

    // put packet back on lookaside list

    NdisFreeToNPagedLookasideList(&g_laCPacket, ppkt);
    
#if _DEBUG
    InterlockedDecrement(&g_lPacketCount);
#endif
}

// ---------------------------------------------------------------------------------------
// RnPacketCopy
// Makes a copy of a packet using shared kernel pool memory - yes, this is not the most 
// efficient way to do this
// ---------------------------------------------------------------------------------------

CPacket*
RnPacketCopy(CPacket * ppkt)
{
    ASSERT(ppkt);

    CPacket* pcopy = NULL;

    // Get a CPacket from the pool

    pcopy = RnPacketAlloc();

    if(!pcopy)
    {
        goto Exit;
    }

    // Allocate memory for the data - warning this is not very efficient

    pcopy->_pbExternal = (PBYTE)RnMemAlloc(ppkt->_cb, PTAG_ExternalDataBuffer);

    if(!pcopy->_pbExternal)
    {
        goto Exit;
    }

    // Copy the data

    NdisMoveMemory(pcopy->_pbExternal, ppkt->_pb, ppkt->_cb);

    // Initialize remaining fields

    pcopy->_dwPktNum = ppkt->_dwPktNum;
    pcopy->_pb       = pcopy->_pbExternal;
    pcopy->_cb       = ppkt->_cb;
    pcopy->_pEnetHdr = (CEnetHdr*)(pcopy->_pb + (((BYTE*)ppkt->_pEnetHdr) - ppkt->_pb));
    pcopy->_uiFlags  = ppkt->_uiFlags;

    pcopy->CompletePush(RnFreePacketCopy);

Exit:

    return pcopy;
}

// ---------------------------------------------------------------------------------------
// RnFreePacketCopy
//
// Frees a packet allocated by RnPacketCopy
// ---------------------------------------------------------------------------------------
void
RnFreePacketCopy(CPacket * ppkt)
{
    Assert(!ppkt->_pnpRecv);
    Assert(ppkt->_pbExternal);

    RnMemFree(ppkt->_pbExternal);
    ppkt->_pbExternal = 0;

    ppkt->Complete();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rawnic_none_12.4.56.0_none_4dfb921801141584
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rawnic
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_MANIFEST_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_CATALOG_PATH=manifests\x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96.cat
XP_PAYLOAD_PATH=x86_rawnic_no-public-key_12.4.56.0_x-ww_21733b96
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rawnic,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnmain.cpp ===
// ---------------------------------------------------------------------------------------
// rnmain.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "rnp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(RnInit,           TAG_ENABLE);        // Trace init/term
DefineTag(RnIoctl,          TAG_DISABLE);       // Trace IOCTL calls
DefineTag(RnCreateClose,    TAG_ENABLE);        // Trace Create/Close/Cleanup calls
DefineTag(RnXmit,           TAG_DISABLE);       // Trace send path
DefineTag(RnVnet,           TAG_DISABLE);       // Trace vnet calls
DefineTag(RnDrop,           TAG_DISABLE);       // Trace packets dropped from queue
DefineTag(RnMatch,          TAG_DISABLE);       // Trace the packet filtering process
DefineTag(RnBatch,          TAG_DISABLE);       // ThresholdUpdate calls
DefineTag(RnLocks,          TAG_DISABLE);       // Trace lock calls

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

PDRIVER_OBJECT g_pDriverObject;
PDEVICE_OBJECT g_pDeviceObject;
NDIS_HANDLE    g_hNdisProtocol;

BOOL           g_fForceIndicationPath;
BOOL           g_fForceTransferDataPath;
BOOL           g_fForceCopyPacketPath;

RAWNIC_COUNTERS_GLOBAL g_counters;

// ---------------------------------------------------------------------------------------
// Driver entry points
// ---------------------------------------------------------------------------------------

EXTERN_C
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject,
                     PUNICODE_STRING pRegistryPath)
{
    NDIS_PROTOCOL_CHARACTERISTICS     protocolChar;
    NDIS40_PROTOCOL_CHARACTERISTICS * pprotocolChar40 = &protocolChar.Ndis40Chars;
    NTSTATUS                          status          = STATUS_SUCCESS;
    NDIS_STRING                       protoName       = NDIS_STRING_CONST("RAWNIC");
    UNICODE_STRING                    ntDeviceName;
    UNICODE_STRING                    win32DeviceName;
    BOOLEAN                           fSymbolicLink   = FALSE;
    PDEVICE_OBJECT                    deviceObject    = NULL;

    UNREFERENCED_PARAMETER(pRegistryPath);

    TraceSz(RnInit, "RAWNIC DriverEntry");

    g_pDriverObject = pDriverObject;

    if (!RnPacketInit())
    {
        status = NDIS_STATUS_FAILURE;
        goto exit;
    }
    
    RnPacketBatchInit();
    RnVnetInit();
    RnAdaptInit();

    //
    // Create our device object using which an application can
    // access NDIS devices.
    //
    RtlInitUnicodeString(&ntDeviceName, RN_DEVICE_NAME);

    status = IoCreateDevice (pDriverObject,
                             0,
                             &ntDeviceName,
                             FILE_DEVICE_NETWORK,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &deviceObject);


    if (!NT_SUCCESS (status))
    {
        //
        // Either not enough memory to create a deviceobject or another
        // deviceobject with the same name exits. This could happen
        // if you install another instance of this device.
        //
        goto exit;
    }

    RtlInitUnicodeString(&win32DeviceName, RN_SYMBOLIC_NAME);

    status = IoCreateSymbolicLink(&win32DeviceName, &ntDeviceName);

    if (!NT_SUCCESS(status))
    {
        goto exit;
    }

    fSymbolicLink = TRUE;

    TraceSz1(RnInit, "DeviceObject flags: 0x%X", deviceObject->Flags);

    deviceObject->Flags |= DO_DIRECT_IO;
    g_pDeviceObject = deviceObject;

    //
    // Initialize the protocol characterstic structure
    //

    NdisZeroMemory(&protocolChar,sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    pprotocolChar40->MajorNdisVersion            = 5;
    pprotocolChar40->MinorNdisVersion            = 0;
    pprotocolChar40->Name                        = protoName;
    pprotocolChar40->OpenAdapterCompleteHandler  = ProtocolOpenAdapterComplete;
    pprotocolChar40->CloseAdapterCompleteHandler = ProtocolCloseAdapterComplete;
    pprotocolChar40->SendCompleteHandler         = ProtocolSendComplete;
    pprotocolChar40->TransferDataCompleteHandler = ProtocolTransferDataComplete;
    pprotocolChar40->ResetCompleteHandler        = ProtocolResetComplete;
    pprotocolChar40->RequestCompleteHandler      = ProtocolRequestComplete;
    pprotocolChar40->ReceiveHandler              = ProtocolReceiveIndication;
    pprotocolChar40->ReceiveCompleteHandler      = ProtocolReceiveComplete;
    pprotocolChar40->StatusHandler               = ProtocolStatus;
    pprotocolChar40->StatusCompleteHandler       = ProtocolStatusComplete;
    
    pprotocolChar40->BindAdapterHandler          = ProtocolBindAdapter;
    pprotocolChar40->UnbindAdapterHandler        = ProtocolUnbindAdapter;
    pprotocolChar40->UnloadHandler               = NULL;
    pprotocolChar40->ReceivePacketHandler        = ProtocolReceivePacket;
    pprotocolChar40->PnPEventHandler             = ProtocolPNPHandler;

    if (g_fForceIndicationPath)
        pprotocolChar40->ReceivePacketHandler = NULL;

    //
    // Register as a protocol driver
    //

    NdisRegisterProtocol(
        (PNDIS_STATUS)&status,
        &g_hNdisProtocol,
        &protocolChar,
        sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    if (status != NDIS_STATUS_SUCCESS)
    {
        TraceSz(RnInit, "Failed to register protocol with NDIS");
        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }


    //
    // Now set only the dispatch points we would like to handle.
    //
    pDriverObject->MajorFunction[IRP_MJ_CREATE]         = DeviceCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = DeviceClose;
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP]        = DeviceCleanup;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
    pDriverObject->MajorFunction[IRP_MJ_READ]           = DeviceRead;
    pDriverObject->MajorFunction[IRP_MJ_WRITE]          = DeviceWrite;
    pDriverObject->DriverUnload                         = DriverUnload;

    status = STATUS_SUCCESS;

exit:

    if (!NT_SUCCESS(status))
    {
        if (deviceObject)
        {
            IoDeleteDevice(deviceObject);
            g_pDeviceObject = NULL;
        }

        if (fSymbolicLink)
        {
            IoDeleteSymbolicLink(&win32DeviceName);
        }

    }

    TraceSz1(RnInit, "RAWNIC DriverEntry exit %x", status);
    
    return status;
}


// ---------------------------------------------------------------------------------------
// DriverUnload
// ---------------------------------------------------------------------------------------
void
DriverUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
{
    NDIS_STATUS     Status;
    UNICODE_STRING  win32DeviceName;

    TraceSz(RnInit, "DriverUnload called");

    // clean up stuff allocated in DriverEntry

    //
    // First delete the Control deviceobject and the corresponding
    // symbolicLink
    //
    RtlInitUnicodeString(&win32DeviceName, RN_SYMBOLIC_NAME);
    IoDeleteSymbolicLink(&win32DeviceName);           

    if (g_pDeviceObject)
    {
        IoDeleteDevice(g_pDeviceObject);
        g_pDeviceObject = NULL;
    }

    if (g_hNdisProtocol)
    {
        NdisDeregisterProtocol(&Status, g_hNdisProtocol);
        g_hNdisProtocol = NULL;
        Assert(Status == NDIS_STATUS_SUCCESS);
    }

    RnAdaptTerm();
    RnVnetTerm();
    RnPacketBatchTerm();
    RnPacketTerm();

    TraceSz(RnInit, "DriverUnload exit");
    
}


// ---------------------------------------------------------------------------------------
// DeviceCreate - control channel Create entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceCreate(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_FULL_EA_INFORMATION pEaBuffer;
    RN_OPEN_PACKET * pOpenPacket;
    STRING OpenPacketName;
    ULONG NextOffset;
    
    CVirtualNet * pVnet;
    PIO_STACK_LOCATION pIrpSp;

    pEaBuffer = (PFILE_FULL_EA_INFORMATION)(pIrp->AssociatedIrp.SystemBuffer);

    if (!pEaBuffer)
    {
        TraceSz(RnCreateClose, "DeviceCreate couldn't find EA block");
        
        Status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    RtlInitString(&OpenPacketName, RN_OPEN_PACKET_NAME);
    pOpenPacket = NULL;

    do
    {
        STRING EaName;

        EaName.MaximumLength = pEaBuffer->EaNameLength + 1;
        EaName.Length        = pEaBuffer->EaNameLength;
        EaName.Buffer        = pEaBuffer->EaName;

        if (RtlEqualMemory(OpenPacketName.Buffer, EaName.Buffer, EaName.Length))
        {
            // found a block with the right name

            if (pEaBuffer->EaValueLength < sizeof(RN_OPEN_PACKET))
            {
                // buffer too small
                Status = STATUS_ACCESS_VIOLATION;
                goto complete;
            }

            pOpenPacket = (RN_OPEN_PACKET *) ( pEaBuffer->EaName +
                                                 pEaBuffer->EaNameLength + 1);

            break;
        }

        //
        // Goto the chained EA
        //

        NextOffset = pEaBuffer->NextEntryOffset;

        pEaBuffer = (PFILE_FULL_EA_INFORMATION)
                        ((PUCHAR) pEaBuffer + NextOffset);
        
    } while (NextOffset != 0);

    if (!pOpenPacket)
    {
        TraceSz(RnCreateClose, "DeviceCreate couldn't find EA block with matching name");
        
        Status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (pOpenPacket->_dwVersion != RN_VERSION)
    {
        TraceSz2(RnCreateClose, "DeviceCreate version mismatch. Expected %d, received %d",
                 RN_VERSION, pOpenPacket->_dwVersion);

        Status = STATUS_REVISION_MISMATCH;
        goto complete;
    }

    // create the thing

    pVnet = new CVirtualNet;

    if (!pVnet)
    {
        TraceSz1(RnCreateClose, "DeviceCreate couldn't allocate %d bytes for CVirtualNet", sizeof(CVirtualNet));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto complete;
    }

    TraceSz3(RnCreateClose, "DeviceCreate opening a vnet %p on adapter %s (virtual ea %s)", pVnet, pVnet->_eaNic.Str(), pVnet->_eaVirtual.Str());

    Status = pVnet->InitVnet(
        pOpenPacket->_abEaNic, 
        pOpenPacket->_abEaVirtual, 
        pOpenPacket->_dwOptions,
        pOpenPacket->_recvMaxLatency,
        pOpenPacket->_recvDesiredLatency);

    if (!NT_SUCCESS(Status))
    {
        TraceSz1(RnCreateClose, "DeviceCreate failed initializing vnet with NTSTATUS 0x%08X", Status);
        delete pVnet;
        goto complete;
    }

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    *GET_PP_VNET(pIrpSp->FileObject) = pVnet;

    MARK_VALID_VNET(pIrpSp->FileObject);

complete:
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}


// ---------------------------------------------------------------------------------------
// DeviceCleanup - control channel Close entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceCleanup(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    CVirtualNet * pVnet;

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    ASSERT( IS_VNET(pIrpSp->FileObject) );

    if (IS_VNET(pIrpSp->FileObject))
    {
        MARK_INVALID_VNET(pIrpSp->FileObject);
        pVnet = GET_VNET(pIrpSp->FileObject);

        TraceSz3(RnCreateClose, "DeviceCleanup cleaning a vnet %p on adapter %s (virtual ea %s)",
                 pVnet, pVnet->_eaNic.Str(), pVnet->_eaVirtual.Str());

        pVnet->TermVnet();
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceClose - control channel Close entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceClose(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    CVirtualNet * pVnet;

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    ASSERT( IS_EX_VNET(pIrpSp->FileObject) );

    if (IS_EX_VNET(pIrpSp->FileObject))
    {
        pVnet = GET_VNET(pIrpSp->FileObject);
        delete pVnet;
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceControl - control channel IOCTL entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceControl(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    ULONG code;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    code = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    if (!IS_VNET(pIrpSp->FileObject))
    {
        ASSERT(IS_EX_VNET(pIrpSp->FileObject));

        TraceSz1(RnIoctl, "DeviceControl invalid file object %p!", pIrpSp->FileObject);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete;
    }

    TraceSz3(RnIoctl, "DeviceControl IOCTL code 0x%08X RN_REQUEST %d irp %p", code, _RN_REQUEST(code), pIrp);

    // Should switch on 'code', not simplified rawnic ioctl code, so some malicious user 
    // doesn't send us an invalid IOCTL..  That is, every single bit needs to match.
    switch (code)
    {
    case IOCTL_RN_READ_COUNTERS:
        Status = RnReadCountersIoctl(pIrp, GET_VNET(pIrpSp->FileObject));
        break;

    case IOCTL_RN_READ_ADAPTERS:
        Status = RnReadAdaptersIoctl(pIrp, GET_VNET(pIrpSp->FileObject));
        break;

    default:
        //
        // shouldn't be able to get here.
        //
       
        TraceSz2(RnIoctl, "DeviceControl invalid IOCTL code 0x%08X (RN_REQUEST %d)!", code, _RN_REQUEST(code));
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

complete:
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceNoop - control channel major function entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceNoop(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceNoop - control channel unsupported function entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceUnsupported(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

NTSTATUS
DeviceRead(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if (!IS_VNET(pIrpSp->FileObject))
    {
        ASSERT(IS_EX_VNET(pIrpSp->FileObject));

        TraceSz1(RnIoctl, "DeviceControl invalid file object %p!", pIrpSp->FileObject);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto Exit;
    }

    Status = RnReceiveIoctl(pIrp, GET_VNET(pIrpSp->FileObject));

Exit:

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
DeviceWrite(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if (!IS_VNET(pIrpSp->FileObject))
    {
        ASSERT(IS_EX_VNET(pIrpSp->FileObject));

        TraceSz1(RnIoctl, "DeviceControl invalid file object %p!", pIrpSp->FileObject);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto Exit;
    }

    Status = RnSendIoctl(pIrp, GET_VNET(pIrpSp->FileObject));

Exit:

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rndebug.cpp ===
// ----------------------------------------------------------------------------
// rndebug.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "rnp.h"

// ---------------------------------------------------------------------------------------
// Assert
// ---------------------------------------------------------------------------------------

#ifdef RN_FEATURE_ASSERT


char * __cdecl RnDbgAssertFmt(char const * pszFmt, ...)
{
    #define ASSERT_ENTRY_SIZE   512
    #define ASSERT_ENTRY_COUNT  8
    static char s_achAssert[ASSERT_ENTRY_SIZE * ASSERT_ENTRY_COUNT];
    static LONG s_lAssert = 0;
    char * pchBuf = &s_achAssert[(InterlockedIncrement(&s_lAssert) % ASSERT_ENTRY_COUNT) * ASSERT_ENTRY_SIZE];
    pchBuf[0] = 0;
    va_list va;
    va_start(va, pszFmt);
    _vsnprintf(pchBuf, ASSERT_ENTRY_SIZE - 1, pszFmt, va);
    va_end(va);
    pchBuf[ASSERT_ENTRY_SIZE - 1] = 0;
    return(pchBuf);
}

#endif



// ---------------------------------------------------------------------------------------
// RnDbgTrace
// ---------------------------------------------------------------------------------------

void __cdecl RnDbgTrace(const char * pszTag, const char * pszFmt, ...)
{
    char         ach[256];
    char *       pchBuf = ach;
    int          cchBuf = sizeof(ach);
    const char * psz    = (char *)pszFmt;
    va_list      va;

    memset(ach, 0, sizeof(ach));

    if (*psz == '+')
        ++psz;
    else 
    {
        if (*psz == '\n')
        {
            *pchBuf++ = *psz++;
            cchBuf -= 1;
        }

        _snprintf(pchBuf, cchBuf - 3, "[RAWNIC] %s: ", pszTag);
    }

    // Oacr warning 6053 tells us to not trust _snprintf. However, because we first
    // zero out ach, and then pass in cchBuf - 3 as the buffer size of pchBuf, we
    // are gauranteed to have a null-terminated string here.
    // TobiasB
    va_start(va, pszFmt);
#pragma warning ( push )
#pragma warning ( disable : 6053)
    int cch = strlen(pchBuf);
#pragma warning ( pop )
    _vsnprintf(&pchBuf[cch], cchBuf - cch - 2, psz, va);
    va_end(va);

    cch = strlen(pchBuf);

    if (cch > 0 && *pszFmt && pszFmt[strlen(pszFmt) - 1] == '+')
        pchBuf[cch - 1] = 0;
    else
        strcpy(pchBuf + cch, "\n");

    DbgPrint("%s", ach);
}

// ---------------------------------------------------------------------------------------
// RnDbgVerifyList
// ---------------------------------------------------------------------------------------

const char * RnDbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire)
{
    LIST_ENTRY * plePrev;
    LIST_ENTRY * pleThis;
    BOOL fFound = FALSE;
    UINT cEnt = 0;

    if (ple->Flink == NULL || ple->Blink == NULL)
        return("List Flink is NULL");
    else if (ple->Blink == NULL)
        return("List Blink is NULL");

    if (ple->Flink == ple || ple->Blink == ple)
    {
        if (ple->Flink != ple->Blink)
        {
            return("List head corrupt");
        }

        return((!pleRequire) ? NULL : "Required entry not found");
    }

    plePrev = ple;
    pleThis = ple->Flink;

    while (1)
    {
        if (pleThis == NULL)
        {
            return("List entry has an Flink that points to NULL");
        }

        if (plePrev != pleThis->Blink)
        {
            return("List entry has a Blink that doesn't point to previous entry");
            return(FALSE);
        }

        if (pleThis == ple)
            break;

        if (pleThis == pleRequire)
        {
            if (fFound)
            {
                return("List has required entry twice.  Cycle detected.");
            }

            fFound = TRUE;
        }

        plePrev = pleThis;
        pleThis = plePrev->Flink;

        if (++cEnt > 1000)
        {
            return("List has cycle");
        }
    }

    return((!pleRequire || fFound) ? NULL : "Required entry not found");
}

// ---------------------------------------------------------------------------------------
// Trace Utilities
// ---------------------------------------------------------------------------------------

char * CEnetAddr::Str() const
{
    STATIC_BUFFER(CEnetAddrStr, 32, 18);
    _snprintf(pch, cch, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnvnet.cpp ===
// ---------------------------------------------------------------------------------------
// RnVnet.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------


#include "rnp.h"

#if _DEBUG
extern LONG g_lPacketCount;
#endif

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

ExternTag(RnVnet);
ExternTag(RnRecv);
ExternTag(RnXmit);
ExternTag(RnIoctl);
ExternTag(RnBatch);
ExternTag(RnMatch);

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void RnSendIoctlComplete(CPacket * ppkt);
BOOL RnDoesAdapterExist(CEnetAddr *peaNic);

// ---------------------------------------------------------------------------------------
// RnReceiveIoctl - handles RnReceive IOCTL. METHOD_BUFFERED.
// ---------------------------------------------------------------------------------------
NTSTATUS        
RnReceiveIoctl(
    PIRP pIrp, 
    CVirtualNet * pvnet
    )
{
    KIRQL oldIrql;

    TraceSz2(RnRecv, "RnReceiveIoctl(pIrp = %p, pvnet = %p)",
             pIrp, pvnet);

    // make sure the IRP is big enough to hold a full size packet
    if(MmGetMdlByteCount(pIrp->MdlAddress) < ENET_FRAME_MAXSIZE)
    {
        // nope. DeviceControl will complete the IRP
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    IoMarkIrpPending(pIrp);

    // Queue the Irp
    pvnet->_lock.Acquire(&oldIrql);
    pvnet->_iq.InsertTail(pIrp);
    pvnet->_lock.Release(oldIrql);

    // Attempt to complete pending Irps (including this one)
    pvnet->Complete(FALSE);

    // Counters
    pvnet->_counters.cReceiveCalls++;

    return STATUS_PENDING;
}

NTSTATUS        
RnSendIoctl(
    PIRP pIrp, 
    CVirtualNet * pvnet
    )
{
    CPacket * ppkt;
    CPacketQueue pq;
    CPacketBatch* pBatch = NULL;
    PBYTE pb;
    DWORD cb;
    DWORD cPackets;
    NTSTATUS status = STATUS_INTERNAL_ERROR;
    
    pq.Init();
    
    // make sure the IRP is a reasonable size
    cb = MmGetMdlByteCount(pIrp->MdlAddress);
    
    TraceSz3(RnXmit, "RnSendIoctl(pIrp = %p, pvnet = %p, cb = %u)",
             pIrp, pvnet, cb);

    if ((cb < sizeof(WORD)) || (cb > MAX_SND_BUFFER_SIZE))
    {
        TraceSz3(RnXmit, "RnSendIoctl(pIrp = %p, pvnet = %p) invalid size %d",
                 pIrp, pvnet, cb);
        // DeviceControl will complete the IRP
        status =  STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    // grab the IRP buffer
    pb = (PBYTE)MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
    if (!pb)
    {
        // couldn't allocate an address. DeviceControl will complete the IRP.
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }          

    // allocate a packet batch request
    pBatch = RnPacketBatchAlloc();
    if(!pBatch)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    pBatch->_pSendIrp = pIrp;
    pBatch->_lPackets = 0;
    pBatch->_cb       = cb;

    // Buffer contains one or more packets prefixed by a WORD containing the 
    // packet lenght

    while(cb > 0)
    {
        if(cb < sizeof(WORD))
        {
            TraceSz2(RnXmit, "RnSendIoctl(pIrp = %p, pvnet = %p) invalid buffer format(cb < sizeof(WORD))",
                    pIrp, pvnet);
            status = STATUS_INVALID_PARAMETER;
            goto cleanup;
        }

        WORD cbPacket = *(WORD*)pb;

        if(cbPacket == 0 ||
           cbPacket > ENET_FRAME_MAXSIZE ||
           cb < sizeof(WORD) + cbPacket)
        {
            TraceSz2(RnXmit, "RnSendIoctl(pIrp = %p, pvnet = %p) invalid buffer format. Invalid packet size",
                    pIrp, pvnet);
            status = STATUS_INVALID_PARAMETER;
            goto cleanup;
        }

        // get a packet
        ppkt = RnPacketAlloc();
        if (!ppkt)
        {
            // DeviceControl will complete the IRP.
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        ppkt->_pBatch = pBatch;
        ppkt->CompletePush(RnSendIoctlComplete);

        // set up the packet buffers
        ppkt->_pb = pb + sizeof(WORD);
        ppkt->_cb = cbPacket;

        // put packet in queue
        pq.InsertTail(ppkt);
        ppkt = NULL;

        // adjust
        pb += sizeof(WORD) + cbPacket;
        cb -= sizeof(WORD) + cbPacket;
        pBatch->_lPackets++;
    }
    
    if(pBatch->_lPackets == 0 || pBatch->_lPackets > MAX_BATCH_SEND_SIZE) 
    {
        TraceSz2(RnXmit, "RnSendIoctl(pIrp = %p, pvnet = %p) invalid buffer format. Too many packets",
                pIrp, pvnet);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }
    
    // increment counters
    pvnet->_counters.cSendCalls++;
    pvnet->_counters.cPacketSent += pBatch->_lPackets;
    
    // mark Irp pending. It will be completed when all packets in the batch 
    // request are completed.
    
    IoMarkIrpPending(pIrp);
    
    // send packets to the network
    
    pBatch->_fNeedsCompletion = TRUE;
    status = RnNicXmit(pvnet->_eaNic, &pq);
    if (status != STATUS_SUCCESS)
    {
        goto cleanup;
    }
    
    pBatch = NULL;
    Assert(pq.IsEmpty());

    status = STATUS_PENDING;

cleanup:

    if (status != STATUS_PENDING)
    {
        // when any error occurs in this function or our children, we are responsible for 
        // completing the packets and freeing the batch. The caller is responsible for 
        // calling IoCompleteRequest.
        
        pBatch->_fNeedsCompletion = FALSE;
        if(!pq.IsEmpty())
        {
            pq.Complete();
        }

        if(pBatch)
        {
            RnPacketBatchRelease(pBatch);
        }
    
    }

    return status;
}

void
RnSendIoctlComplete(
    CPacket * ppkt
    )
{
    Assert(ppkt->_pBatch);
    CPacketBatch* pBatch = ppkt->_pBatch;
    Assert(pBatch->_lPackets);
    
    if(InterlockedDecrement(&pBatch->_lPackets) == 0 &&
       pBatch->_fNeedsCompletion)
    {
        // this is the last packet. Complete the IRP and release resources.
        // FYI, NDIS_STATUS_SUCCESS is equal to STATUS_SUCCESS.

        PIRP pIrp = pBatch->_pSendIrp;
 
        // @@@ We *should* trickle up any errors back to user mode. But don't want to make 
        // this change this release because I can't figure out how to trigger any errors 
        // for testing, and I don't want to create mysterious event spam. Better to check 
        // this in later and let it bake.
        //pIrp->IoStatus.Status = pBatch->_status;
        pIrp->IoStatus.Status = STATUS_SUCCESS;

        pIrp->IoStatus.Information = pBatch->_cb;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        RnPacketBatchRelease(pBatch);
    }

    ppkt->Complete();
}

NTSTATUS
RnReadCountersIoctl(
    PIRP pIrp, 
    CVirtualNet * pvnet
    )
{
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    TraceSz2(RnIoctl, "RnGetCountersIoctl(pIrp = %p, pvnet = %p)",
             pIrp, pvnet);

    BYTE* pb = (PBYTE)pIrp->AssociatedIrp.SystemBuffer;
    DWORD cb = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if(!pb)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // make sure the IRP is big enough for the counters structure
    if(cb < sizeof(RAWNIC_COUNTERS))
    {
        // DeviceControl will complete the IRP
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Any on-demand counters to collect
#if _DEBUG
    g_counters.cPacketsInUse = g_lPacketCount;
#endif

    // Copy the counters structure into IRP
    RAWNIC_COUNTERS* pCounters = (RAWNIC_COUNTERS*) pb;
    pCounters->adapter = pvnet->_counters;
    pCounters->global  = g_counters;
    pIrp->IoStatus.Information = sizeof(RAWNIC_COUNTERS);

    // DeviceControl will complete the IRP
    return STATUS_SUCCESS;
}

void
RnTraceDroppedPacket(CPacket * ppkt)
{
//     LARGE_INTEGER liNow;
//     LARGE_INTEGER liAge;
//     KeQuerySystemTime(&liNow);
// 
//     liAge.QuadPart = liNow.QuadPart - ppkt->_liTime.QuadPart;
//     liAge.QuadPart /= 10000000;
//     
//     TraceSz2(RnDrop, "Dropping packet %s, age %I64d",
//              ppkt->Str(), liAge.QuadPart);

    ppkt->Complete();
}

BOOL
CVirtualNet::MatchPacketType(CPacket * ppkt)
{
    CEnetAddr * pea = &ppkt->_pEnetHdr->_eaDst;

    if (_fPromiscuous)
    {
        return(TRUE);
    }
    if (pea->IsEqual(_eaVirtual))
    {
        // we always want packets unicast to us
        TraceSz2(RnMatch, "%s: Unicast match %s", ppkt->Str(), _eaVirtual.Str());
        return(TRUE);
    }
    if (pea->IsBroadcast() && ((ppkt->_uiFlags & _uiRecvMask) != 0))
    {
        // also take user specified set of broadcast messages
        TraceSz3(RnMatch, "%s %s: Broadcast match, %X:%X", ppkt->Str(), ppkt->_uiFlags, _uiRecvMask);
        return(TRUE);
    }

    return(FALSE);
}

void
CVirtualNet::Xmit(
    CPacket * ppkt
    )
{
    KIRQL oldIrql;
    LARGE_INTEGER liNow;

    if(_pq.Count() < MAX_QUEUED_PACKETS)
    {
        // Queue the packet
        _lock.Acquire(&oldIrql);
        _pq.InsertTail(ppkt);
        _lock.Release(oldIrql);
        _counters.cPacketReceived++;
    }
    else
    {
        // discard the packet
        ppkt->Complete();
        _counters.cPacketDropped++;
    }
}

BOOL                
CIrpQueue::InsertTail(
    PIRP pIrp
    )
{
    PIO_STACK_LOCATION pIrpSp;
    
    // Save a pointer to the queue in the IRP. This allows us to
    // clean up properly if the IRP is cancelled.

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = this;

    // Set to these to null just in case the cancel routine runs.

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    // Set the cancel routine. The routine may run as soon as it is set.
    
    IoSetCancelRoutine(pIrp, &CIrpQueue::IrpCancelRoutine);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        // darn it, need to make sure the irp get's completed

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  caller
            // must complete it
            //
            
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = STATUS_CANCELLED;

            return FALSE;
        }

        // our cancel routine will run and complete the irp,
        // don't touch it

        return TRUE;
    }

    
    // now we are safe to queue the IRP for real

    InsertTailList(
        &_lh,
        &pIrp->Tail.Overlay.ListEntry
        );

    return TRUE;
}

PIRP                
CIrpQueue::RemoveHead()
{
    PIRP pIrp = NULL;

    while (!IsListEmpty(&_lh))
    {
        PLIST_ENTRY        pEntry;

        // Found a free irp

        pEntry = RemoveHeadList(&_lh);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        // pop the cancel routine

        if (IoSetCancelRoutine(pIrp, NULL) != NULL)
        {
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            
            // we are free to use this irp

            Assert(this == pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                
            break;
        }
        else
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been popped off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }

    }
    
    return pIrp;
}

void                
CIrpQueue::CancelAll()
{
    PIRP pIrp;
    
    while (pIrp = RemoveHead())
    {
        TraceSz1(RnVnet, "CIrpQueue::CancelAll pIrp = %p", pIrp);
        
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }
}


void
CIrpQueue::IrpCancelRoutine(
    PDEVICE_OBJECT pDevice, 
    PIRP pIrp
    )
{
    KIRQL oldIrql;
    PIO_STACK_LOCATION pIrpSp;
    CIrpQueue * pq;

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // Grab the queue off the IRP.
    
    pq = (CIrpQueue *)pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    // Remove this IRP.

    pq->_pLock->Acquire(&oldIrql);

    if (pIrp->Tail.Overlay.ListEntry.Flink)
    {
        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    pq->_pLock->Release(oldIrql);

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    // Complete the IRP.

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

}

CReaderWriterLock g_rwlockVnet; // synchronize vnet list

LIST_ENTRY g_lhVnet;            // list of CVirtualNet
DWORD      g_cVnet;             // number of vnets

void RnVnetInit()
{
    InitializeListHead(&g_lhVnet);
    g_rwlockVnet.Init();
    g_cVnet = 0;
}

void RnVnetTerm()
{
    Assert(g_cVnet == 0);
}

DWORD RnVnetGetFilterMode(const CEnetAddr* pea)
{
    DWORD dwFilter = 0;
   
    LOCK_STATE ls;
    g_rwlockVnet.ReadLock(&ls);

    // determine the number of vnets that this packet should be sent to

    for (LIST_ENTRY* pEntry = g_lhVnet.Flink; pEntry != &g_lhVnet; pEntry = pEntry->Flink)
    {
        CVirtualNet* pvnet = CONTAINING_RECORD(pEntry, CVirtualNet, _le);

        if(pvnet->_eaNic.IsEqual(*pea))
        {
            if(pvnet->_eaNic.IsEqual(pvnet->_eaVirtual))
            {
                dwFilter |= 
                    NDIS_PACKET_TYPE_DIRECTED |
                    NDIS_PACKET_TYPE_ALL_MULTICAST |
                    NDIS_PACKET_TYPE_BROADCAST;
            }
            else
            {
                dwFilter |= NDIS_PACKET_TYPE_PROMISCUOUS;
            }
        }
    }

    g_rwlockVnet.ReadUnlock(&ls);

    return dwFilter;
}

// Parameters:
// - pbEaNic - real MAC address of NIC to bind to
// - pbEaVirtual - fake MAC address to use
// - dwOptions - see RN_OPTION_*
// - recvMaxLatency - maximum allowed latency, in microseconds (@@@ go away?)
// - recvDesiredLatency - average desired latency, in microseconds (see auto-tuning 
// comments)
// Returns:
// - STATUS_SUCCESS if ok
// - STATUS_INVALID_ADDRESS if mac address doesn't exist (pbEaNic)
NTSTATUS CVirtualNet::InitVnet(
    PBYTE pbEaNic, 
    PBYTE pbEaVirtual, 
    DWORD dwOptions, 
    DWORD recvMaxLatency,
    DWORD recvDesiredLatency
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    _pq.Init();
    _iq.Init(&_lock);
    memcpy(_eaNic._ab, pbEaNic, sizeof(_eaNic._ab));
    memcpy(_eaVirtual._ab, pbEaVirtual, sizeof(_eaVirtual._ab));
    _uiRecvMask = 0;
    memset(&_counters, 0, sizeof(_counters));
    _cmpltInProgress = FALSE;

    // @@@ Perhaps we should check if _eaNic is actually present in the list of adapters.  
    // However, uncoupling vnets and adapters has the benefit of allowing one to unbind & 
    // rebind rawnic from a NIC, without needing to destory/recreate the vnet. But 
    // wouldn't it be nice to know the nic you thought you were opening actually exists on 
    // the machine?
    //
    // OK, done. If caller specified a bad mac address, we will fail. We also fail if the 
    // mac address is valid but rawnic isn't currently bound to the nic.

    if (!(dwOptions & RN_OPTION_IGNORE_MAC) &&
        !RnDoesAdapterExist(&_eaNic))
    {
        return STATUS_INVALID_ADDRESS;
    }

    if (dwOptions & RN_OPTION_BROADCAST_ANY)
    {
        _uiRecvMask |= PKTF_BROADCAST;
    }
    if (dwOptions & RN_OPTION_BROADCAST_ARP)
    {
        _uiRecvMask |= PKTF_ARP;
    }
    if (dwOptions & RN_OPTION_BROADCAST_DHCP)
    {
        _uiRecvMask |= PKTF_DHCP;
    }
    if (dwOptions & RN_OPTION_BROADCAST_XBOX)
    {
        _uiRecvMask |= PKTF_XBOX;
    }

    _fPromiscuous = (dwOptions & RN_OPTION_PROMISCUOUS) != 0;

    // Convert to 100-nanosecond units. Negative values, for the timer interval, means 
    // relative time (vs absolute time).
    _recvMaxLatency.QuadPart     = ((LONGLONG)recvMaxLatency) * -10;
    _recvDesiredLatency          = recvDesiredLatency;
    _recvBatchThreshold          = 1;
    _recvIntervalPacketCount     = 0;
    
    KeQuerySystemTime(&_recvIntervalLastUpdateTime);

    TraceSz4(RnVnet, "%p Init: Options: %u, MaxLatency: %u, DesiredLatency: %u",
             this,
             dwOptions,
             recvMaxLatency,
             recvDesiredLatency);

    // Safety net receive timer

    KeInitializeTimer(&_recvTimer);
    // if _recvTimerSet is FALSE, the timer will end up getting set. If TRUE, it will 
    // never be set. Kinda backwards..
    _recvTimerSet = (recvMaxLatency == 0);
    KeInitializeDpc(&_cmpltRecvDpc, CompleteRecvDpc, this);

    TraceSz4(RnVnet, "%p Init: RecvTimer timer: %p, dpc: %p, timerenabled: %u",
             this,
             &_recvTimer,
             &_cmpltRecvDpc,
             !_recvTimerSet);  // backwards..

    // Threshold Update timer

    LARGE_INTEGER thresholdUpdatePeriod;
    thresholdUpdatePeriod.QuadPart = ((LONGLONG)RN_BATCHTHRESHOLD_TIMER_PERIOD_IN_MS) * -10000;

    KeInitializeTimer(&_thresholdUpdateTimer);
    KeInitializeDpc(&_thresholdUpdateDpc, ThresholdUpdateDpc, this);

    // Don't enable timer unless user has enabled auto-tuning
    if (recvDesiredLatency > 0)
    {
        KeSetTimerEx(&_thresholdUpdateTimer, 
                     thresholdUpdatePeriod,
                     RN_BATCHTHRESHOLD_TIMER_PERIOD_IN_MS,
                     &_thresholdUpdateDpc);
    }

    TraceSz5(RnVnet, "%p Init: ThresholdUpdateTimer period: %u ms, timer: %p, dpc: %p, timerenabled: %u",
             this,
             RN_BATCHTHRESHOLD_TIMER_PERIOD_IN_MS,
             &_thresholdUpdateTimer,
             &_thresholdUpdateDpc,
             recvDesiredLatency > 0);

    LOCK_STATE ls;
    g_rwlockVnet.WriteLock(&ls);
    InsertTailList(&g_lhVnet, &_le);
    g_rwlockVnet.WriteUnlock(&ls);

    RnResetAdaptersFilterMode();

    return Status;
}

void CVirtualNet::TermVnet()
{
    Assert(KeGetCurrentIrql() == PASSIVE_LEVEL);

    TraceSz1(RnVnet, "%p TermVnet called", this);

    // remove this object from global list
    KIRQL oldIrql;
    LOCK_STATE ls;
    g_rwlockVnet.WriteLock(&ls);
    RemoveEntryList(&_le);
    g_rwlockVnet.WriteUnlock(&ls);

    KeCancelTimer(&_recvTimer);
    KeCancelTimer(&_thresholdUpdateTimer);
    KeFlushQueuedDpcs();

    // clean up I/O

    CPacketQueue pq;
    
    pq.Init();

    _lock.Acquire(&oldIrql);

    if (!_pq.IsEmpty())
    {
        // move queued packets to private list so they can be completed
        // outside the spin lock.
        pq.InsertHead(&_pq);
    }

    // complete queued IRPs
    _iq.CancelAll();

    _lock.Release(oldIrql);

    // complete queued packets
    pq.Complete();
}

// This will quickly determine whether a packet matches any listeners. Returns FALSE if we 
// don't want the packet, or TRUE if at least 1 vnet wants it.
// - pEaNic: MAC address of the NIC this packet was received on
// - pEaDst: MAC address the packet is destined for
BOOL RnVnetIndicate(CEnetAddr * pEaNic, CEnetAddr * pEaDst)
{
    BOOL         fMatch = TRUE;
    LIST_ENTRY * pEntry;

    LOCK_STATE ls;
    g_rwlockVnet.ReadLock(&ls);

    // determine the number of vnets that this packet should be sent to

    for (pEntry = g_lhVnet.Flink; pEntry != &g_lhVnet; pEntry = pEntry->Flink)
    {
        CVirtualNet* pvnet = CONTAINING_RECORD(pEntry, CVirtualNet, _le);

        if (pEaNic->IsEqual(pvnet->_eaNic))
        {
            if (pvnet->_fPromiscuous ||
                pEaDst->IsEqual(pvnet->_eaVirtual) ||
                pEaDst->IsBroadcast())
            {
                goto exit;
            }
        }
    }

    // No match
    fMatch = FALSE;

exit:

    g_rwlockVnet.ReadUnlock(&ls);

    return fMatch;
}

void RnVnetXmit(CEnetAddr eaNic, CPacket * ppkt)
{
    LIST_ENTRY * pEntry;
    DWORD        matchCount = 0;
    CVirtualNet* pvnetMatch = NULL;
    
    LOCK_STATE ls;
    g_rwlockVnet.ReadLock(&ls);

    // determine the number of vnets that this packet should be sent to

    for (pEntry = g_lhVnet.Flink; pEntry != &g_lhVnet; pEntry = pEntry->Flink)
    {
        CVirtualNet* pvnet = CONTAINING_RECORD(pEntry, CVirtualNet, _le);

        if (eaNic.IsEqual(pvnet->_eaNic) && pvnet->MatchPacketType(ppkt))
        {
            pvnetMatch = pvnet;
            matchCount++;
        }

    }

    if(matchCount != 0)
    {
        if(matchCount == 1)
        {
            // only one match - send packet right away
            
            pvnetMatch->Xmit(ppkt);
            ppkt = NULL;
        }
        else
        {
            // multiple matches - we need copies of the packet. This is NOT the most 
            // efficient way to do this but the case of having multiple vnets attached to the 
            // same adapter is a test only scenario. First xmit all the copies.

            for(pEntry = g_lhVnet.Flink; 
                matchCount > 0 && pEntry != &g_lhVnet; 
                pEntry = pEntry->Flink)
            {
                CVirtualNet* pvnet = CONTAINING_RECORD(pEntry, CVirtualNet, _le);

                if (eaNic.IsEqual(pvnet->_eaNic) && pvnet->MatchPacketType(ppkt))
                {
                    CPacket* pcopy = RnPacketCopy(ppkt);

                    if(pcopy)
                    {
                        pvnet->Xmit(pcopy);
                    }

                    matchCount--;
                }
            }

            // for the last match, xmit the original packet

            for(; pEntry != &g_lhVnet; pEntry = pEntry->Flink)
            {
                CVirtualNet* pvnet = CONTAINING_RECORD(pEntry, CVirtualNet, _le);

                if (eaNic.IsEqual(pvnet->_eaNic) && pvnet->MatchPacketType(ppkt))
                {
                    pvnet->Xmit(ppkt);
                    ppkt = NULL;
                    break;
                }
            }
        }
    }

    g_rwlockVnet.ReadUnlock(&ls);

    if (ppkt)
    {
        ppkt->Complete();
    }
}

void RnVnetComplete()
{
    // @@@ Look at this. Two problems:
    // 1. The locks serializes ALL calls to this, and this gets called quite a lot. It 
    // allows for no parallelism across nics, for instances.
    // - fixed with the read/write lock.
    // 2. ProtocolReceiveComplete is called for every single packet ndis sees. Including 
    // tcp/ip packets. That's a lot of calls going through this code path, and a lot of 
    // calls that end up doing nothing.
    // - mitigated by a thread-safe flag and quick bailout when no packets queued
    LOCK_STATE ls;
    g_rwlockVnet.ReadLock(&ls);

    for (LIST_ENTRY* pEntry = g_lhVnet.Flink; pEntry != &g_lhVnet; pEntry = pEntry->Flink)
    {
        CVirtualNet* pvnet = CONTAINING_RECORD(pEntry, CVirtualNet, _le);

        pvnet->Complete(FALSE);
    }
    g_rwlockVnet.ReadUnlock(&ls);
}

void CVirtualNet::Complete(BOOL force)
{
    // Bail out super fast if we can't do anything. It's OK if a race condition occurs 
    // here and more than 1 thread sneaks in.
    // Try to set to 1. Succeeded if 0 was returned, failed if 1 returned.
    if (_pq.IsEmpty() ||
        _cmpltInProgress ||
        InterlockedCompareExchange(&_cmpltInProgress, 1, 0) == 1)
    {
        return;
    }

    for(;;)
    {
        if(!force)
        {
            if(_pq.Count() < _recvBatchThreshold)
            {
                if(!_recvTimerSet)
                {
                    _recvTimerSet = TRUE;
                    KeSetTimer(&_recvTimer, _recvMaxLatency, &_cmpltRecvDpc);
                }

                TraceSz3(RnVnet, "%p Complete: Skipping due to packet count %u less than threshold %u", 
                         this,
                         _pq.Count(),
                         _recvBatchThreshold);
                break;
            }
        }
        else
        {
            Assert(KeReadStateTimer(&_recvTimer));
            _recvTimerSet = FALSE;
        }

        KIRQL           oldIrql;
        PIRP            pIrp = NULL;
        PBYTE           pb = NULL; 

        CPacketQueue    pqCopy;
        pqCopy.Init();
   
        // This lock protects the packet queue _pq and the irp queue _iq
        _lock.Acquire(&oldIrql);

        // Got packets?
        UINT origPacketCount = _pq.Count();
        if(!_pq.IsEmpty())
        {
            // Got IRP?
            pIrp = _iq.RemoveHead();
            if(pIrp != NULL)
            {
                // Build a list with as many packets as we can make fit in the Irp 
                // buffer

                pb = (PBYTE) MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
                DWORD available = MmGetMdlByteCount(pIrp->MdlAddress);

                if(pb != NULL)
                {
                    while(true)
                    {
                        CPacket * ppkt = _pq.GetHead();
                        if(!ppkt)
                            break;

                        Assert(ppkt->_cb <= ENET_FRAME_MAXSIZE);

                        UINT needed = ppkt->_cb + sizeof(WORD);

                        if(needed > available)
                            break;

                        pqCopy.InsertTail(_pq.RemoveHead());
                        available -= needed;
                    }
                }
            }
        }

        _lock.Release(oldIrql);
        
        if(NULL == pIrp)
        {
            TraceSz1(RnVnet, "%p Complete: No IRP available", this);
            break;
        }

        // Keep a running total of the packets being sent up for the automatic threshold 
        // adjuster.
        InterlockedExchangeAdd((LONG*)&_recvIntervalPacketCount, pqCopy.Count());
        UINT packetCount = pqCopy.Count();
        DWORD cb = 0;

        if(pb != NULL)
        {
            // Now copy the packets we put aside to the Irp's buffer. Each 
            // packet will be prefixed by a WORD containing the size of the 
            // packet

            while(true)
            {
                if(pqCopy.IsEmpty())
                    break;

                CPacket * ppkt = pqCopy.RemoveHead();

                *((WORD*)pb) = (WORD)ppkt->_cb;
                cb += sizeof(WORD);
                pb += sizeof(WORD);

                // copy packet into the IRP
                RtlCopyMemory(pb, ppkt->_pb, ppkt->_cb);
                cb += ppkt->_cb;
                pb += ppkt->_cb;

                ppkt->Complete();
            }

            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = cb;
        }
        else
        {
            // system is out of resources

            pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            pIrp->IoStatus.Information = 0;
        }

        TraceSz6(RnVnet, "%p Complete done: %u packets, %u bytes (%u packets remaining, %u bytes total, force=%u)",
                 this,
                 packetCount,
                 cb,
                 origPacketCount - packetCount,
                 MmGetMdlByteCount(pIrp->MdlAddress),
                 force);

        // complete the IRP
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }

    // Reset the flag
    _cmpltInProgress = 0;
}

void CVirtualNet::ThresholdUpdate()
{
    // Has user specified no automatic tuning of receive batch threshold?
    if (_recvDesiredLatency == 0)
    {
        TraceSz1(RnBatch, "%p ThresholdUpdate: exit, desired latency is 0", this);
        return;
    }

    LARGE_INTEGER liCurrentUpdateTime;
    UINT timeDiffInUs;

    // Units are in 100-nanosecond intervals, but we'll store them as microseconds
    KeQuerySystemTime(&liCurrentUpdateTime);
    timeDiffInUs = (UINT)((liCurrentUpdateTime.QuadPart - _recvIntervalLastUpdateTime.QuadPart) / 10);

    // We're supposed to be running every 100 ms, so our time difference *should* always 
    // be greater than zero. Hmm.
    if (timeDiffInUs == 0)
    {
        TraceSz1(RnBatch, "%p ThresholdUpdate: exit, time difference is 0", this);
        return;
    }
    else
    {
        _recvIntervalLastUpdateTime = liCurrentUpdateTime;
    }
    
    // Snapshot of packet count. Also reset counter to 0.
    UINT packetCount = InterlockedExchange((LONG*)&_recvIntervalPacketCount, 0);
    
    // So we have 3 inputs:
    // - Packets in last interval
    // - DesiredLatency, in 1-microsecond units
    // - ElapsedTime, in 1-microsecond units
    //
    // And we want 1 output:
    // - new BatchThreshold, which is # of packets desired per call
    //
    // Formula goes something like:
    // 
    //   BatchThreshold = Packets * DesiredLatency / ElapsedTime
    //
    // This will set a fixed latency all the time. TODO: we may want to consider scaling 
    // this based on CPU load, or packet load.

    UINT newRecvBatchThreshold = (UINT)((packetCount * _recvDesiredLatency) / (timeDiffInUs));

    // Let's go up in increments slowly, instead of just thunking down a new value
    if (newRecvBatchThreshold > _recvBatchThreshold)
    {
        _recvBatchThreshold++;
    }
    else if (newRecvBatchThreshold < _recvBatchThreshold)
    {
        _recvBatchThreshold--;
    }

    // Safety catch
    if (_recvBatchThreshold > 1000)
        _recvBatchThreshold = 1000;

    // Update perf counter
    _counters.cRecvBatchThreshold = _recvBatchThreshold;

    TraceSz5(RnBatch, "%p ThresholdUpdate: packets: %u, time-diff: %u ms, new threshold: %u, adjusted threshold: %u",
             this,
             packetCount,
             timeDiffInUs / 1000,
             newRecvBatchThreshold,
             _recvBatchThreshold);
}


VOID CVirtualNet::CompleteRecvDpc(IN struct _KDPC *Dpc, IN PVOID DeferredContext, IN PVOID, IN PVOID)
{
    Assert(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    CVirtualNet* pvnet = (CVirtualNet*) DeferredContext;

    TraceSz1(RnVnet, "%p CompleteRecvDpc", pvnet);

    pvnet->Complete(TRUE);
}


VOID CVirtualNet::ThresholdUpdateDpc(IN struct _KDPC *Dpc, IN PVOID DeferredContext, IN PVOID, IN PVOID)
{
    Assert(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    CVirtualNet* pvnet = (CVirtualNet*) DeferredContext;
    
    pvnet->ThresholdUpdate();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnrecv.cpp ===
// ---------------------------------------------------------------------------------------
// rnrecv.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "rnp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(KmRecv,           TAG_DISABLE);
DefineTag(KmRecvDiscard,    TAG_DISABLE);        // Trace discarded packets


// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void        RnFreeNdisPacket(CPacket * ppkt);
void        RnFreeIndicatedPacketBuffer(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// ProtocolReceivePacket
//
// This is the primary entry point NDIS uses to pass packets to us.
// ---------------------------------------------------------------------------------------

INT
ProtocolReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pnp
    )
{
    CAdapter * pAdapt = (CAdapter *) ProtocolBindingContext;
    CPacket * ppkt;

    INT PacketRefs = 0;

    // Make sure we're active.

    if (pAdapt->_dwState != ADAPT_STATE_READY || pAdapt->_powerState != NetDeviceStateD0)
    {
        TraceSz1(KmRecvDiscard, "[DISCARD] PtReceivePacket adapter %p not ready", pAdapt);
        
        // nope, drop the packet
        goto exit;
    }

    g_counters.cProtocolReceivePacket++;

    // figure out ndis info
    
    PNDIS_BUFFER    pNdisBuffer;
    PVOID           pvNdisBuffer;
    UINT            cbNdisBuffer;
    UINT            cbTotalBuffer;

    NdisGetFirstBufferFromPacket(
        pnp,
        &pNdisBuffer,
        &pvNdisBuffer,
        &cbNdisBuffer,
        &cbTotalBuffer
        );

    TraceSz4(KmRecv, "PtReceivePacket received %p size %d, first buffer %p, %d",
             pnp, cbTotalBuffer, pvNdisBuffer, cbNdisBuffer);

    // get a CPacket and initialize it

    ppkt = RnPacketAlloc();

    if (!ppkt)
    {
        goto exit;
    }
    
    if (   cbNdisBuffer == cbTotalBuffer
        && NDIS_GET_PACKET_STATUS(pnp) != NDIS_STATUS_RESOURCES
        && !g_fForceCopyPacketPath)
    {
        // Save a pointer to the NDIS_PACKET so we can return it later.

        ppkt->_pnpRecv = pnp;
        PacketRefs = 1;
        
        ppkt->CompletePush(&RnFreeNdisPacket);

        // set up the pointers for the upper layers.
        
        ppkt->_cb = cbNdisBuffer;
        ppkt->_pb = (PBYTE) pvNdisBuffer;    
    }
    else
    {
        // Either the packet is not all in one buffer or the miniport
        // driver is low on resources. Copy all the data into another
        // buffer and return immediately.

        g_counters.cProtocolReceivePacketCopy++;

        ppkt->_pbExternal = (PBYTE)RnMemAlloc(cbTotalBuffer, PTAG_ExternalDataBuffer);

        if (!ppkt->_pbExternal)
            goto exit;

        // copy the data
        PBYTE pb = ppkt->_pbExternal;

        while (pNdisBuffer != NULL)
        {
            NdisQueryBufferSafe(pNdisBuffer, &pvNdisBuffer, &cbNdisBuffer, NormalPagePriority);

            if (pvNdisBuffer == NULL)
                goto exit;

            NdisMoveMemory(pb, pvNdisBuffer, cbNdisBuffer);
            pb += cbNdisBuffer;

            NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
        }
        Assert(pb == ppkt->_pbExternal + cbTotalBuffer);

        // remember how to free this packet
        ppkt->CompletePush(&RnFreeIndicatedPacketBuffer);        

        Assert(ppkt->_pnpRecv == NULL);
        Assert(PacketRefs == 0);  // we must return 0 for the NDIS_STATUS_RESOURCES case

        // set up the pointers for the upper layers.

        ppkt->_cb = cbTotalBuffer;
        ppkt->_pb = ppkt->_pbExternal;
    }

    pAdapt->RecvPacket(ppkt);

exit:
    return PacketRefs;
}


// ---------------------------------------------------------------------------------------
// ProtocolReceiveIndication
//
// This is a secondary entry point NDIS uses to pass packets to us.
// Ndis calls this function instead of PtReceivePacket when it is running
// low on memory. We have to copy the data into our own buffers before
// passing the packet on.
// ---------------------------------------------------------------------------------------

NDIS_STATUS
ProtocolReceiveIndication(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               HeaderBuffer,
    IN  UINT                HeaderBufferSize,
    IN  PVOID               LookAheadBuffer,
    IN  UINT                LookAheadBufferSize,
    IN  UINT                PacketSize
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    CAdapter * pAdapt = (CAdapter *) ProtocolBindingContext;
    UINT TotalSize = HeaderBufferSize + PacketSize;
    
    CPacket * ppkt = NULL;
    
    
    //
    // Make sure we're active.
    //

    if (pAdapt->_dwState != ADAPT_STATE_READY || pAdapt->_powerState != NetDeviceStateD0)
    {
        TraceSz1(KmRecvDiscard, "[DISCARD] PtReceiveIndication adapter %p not ready", pAdapt);
        
        // nope, drop the packet
        goto fatal;
    }

    g_counters.cProtocolReceiveIndication++;

    TraceSz5(KmRecv, "PtReceiveIndication received packet size %d, header %p (%d bytes), first buffer %p (%d bytes)",
             PacketSize, HeaderBuffer, HeaderBufferSize, LookAheadBuffer, LookAheadBufferSize);

    // Do we even want this packet? Why allocate memory and waste resources if no one even 
    // wants this poor packet? Smarter to bail out early and leave the packet in the NDIS 
    // gutter.

    if (!pAdapt->IndicatePacket((BYTE*)HeaderBuffer, HeaderBufferSize))
    {
        TraceSz2(KmRecvDiscard, "[DISCARD] PtReceiveIndication returning NDIS_STATUS_NOT_ACCEPTED. header %p (%d bytes)",
                HeaderBuffer, HeaderBufferSize);
        g_counters.cProtocolReceiveIndicationDiscard++;
        Status = NDIS_STATUS_NOT_ACCEPTED;
        goto fatal;
    }

    // allocate a packet info

    ppkt = RnPacketAlloc();

    if (!ppkt)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto fatal;
    }

    // allocate a buffer
    // @@@ Note: this actually allocates memory from the system. Would be nice to manage 
    // our own memory probably, but it's tricky since the size varies. Not touching for 
    // now..
    ppkt->_pbExternal = (PBYTE)RnMemAlloc(TotalSize, PTAG_ExternalDataBuffer);

    if (!ppkt->_pbExternal)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto fatal;
    }        

    // remember how to free this packet
    ppkt->CompletePush(&RnFreeIndicatedPacketBuffer);

    NdisMoveMappedMemory(ppkt->_pbExternal, HeaderBuffer, HeaderBufferSize);

    if (LookAheadBufferSize == PacketSize && !g_fForceTransferDataPath)
    {    
        // copy the data
        TdiCopyLookaheadData(
            ppkt->_pbExternal + HeaderBufferSize,
            LookAheadBuffer,
            LookAheadBufferSize,
            pAdapt->_dwTdiRecvFlags
            );
    }
    else
    {
        // This indication does not include the entire packet, so we must
        // call NdisTransferData to get the rest.

        MmInitializeMdl(
            (PMDL)ppkt->_pnbXmit,
            ppkt->_pbExternal + HeaderBufferSize,
            PacketSize
            );

        MmBuildMdlForNonPagedPool((PMDL)ppkt->_pnbXmit);
        NdisChainBufferAtBack(ppkt->_pnpXmit, ppkt->_pnbXmit);

        SET_NDIS_PACKET_CONTEXT(ppkt->_pnpXmit, ppkt);

        ppkt->_pb     = ppkt->_pbExternal;
        ppkt->_cb     = TotalSize;

        UINT cbTransfer = 0;

        NdisTransferData(&Status,
                         pAdapt->_hLowerBinding,
                         MacReceiveContext,
                         0,
                         PacketSize,
                         ppkt->_pnpXmit,
                         &cbTransfer);

        if (Status != NDIS_STATUS_PENDING)
        {
            ProtocolTransferDataComplete(ProtocolBindingContext,
                                         ppkt->_pnpXmit,
                                         Status,
                                         cbTransfer);
        }

        return Status;
    }

    // indicate the packet
    ppkt->_cb = TotalSize;
    ppkt->_pb = ppkt->_pbExternal;

    pAdapt->RecvPacket(ppkt);

    return NDIS_STATUS_SUCCESS;
    
fatal:

    if (ppkt)
    {
        ppkt->Complete();
    }
    
    return Status;
}


// ---------------------------------------------------------------------------------------
// ProtocolReceiveComplete
//
// Ndis calls this function every now and then to let us know that we
// can do post-processing steps on previously indicated packets. We
// have no post processing to do.
// ---------------------------------------------------------------------------------------
void
ProtocolReceiveComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
    g_counters.cProtocolReceiveComplete++;

    RnVnetComplete();
}

// ---------------------------------------------------------------------------------------
// ProtocolTransferDataComplete
//
// Ndis calls this function to complete an async call to NdisTransferData, which
// we sometimes must call from ProtocolReceiveIndication to get the full contents of a packet
// ---------------------------------------------------------------------------------------
void
ProtocolTransferDataComplete(
    NDIS_HANDLE ProtocolBindingContext,
    PNDIS_PACKET Packet,
    NDIS_STATUS Status,
    UINT BytesTransferred
    )
{
    CAdapter *    pAdapt = (CAdapter *)ProtocolBindingContext;
    CPacket *     ppkt   = GET_PACKET_FROM_NDIS_PACKET(Packet);

    MmPrepareMdlForReuse(ppkt->_pnbXmit);    
    NdisReinitializePacket(ppkt->_pnpXmit);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pAdapt->RecvPacket(ppkt);
    }
    else
    {
        ppkt->Complete();
    }
}

// ---------------------------------------------------------------------------------------
// RnFreeNdisPacket
//
// Frees a packet allocated by ProtocolReceivePacket.
// ---------------------------------------------------------------------------------------
void
RnFreeNdisPacket(CPacket * ppkt)
{
    Assert(ppkt->_pnpRecv);
    Assert(!ppkt->_pbExternal);

    NdisReturnPackets(&ppkt->_pnpRecv, 1);
    ppkt->_pnpRecv = NULL;

    ppkt->Complete();
}

// ---------------------------------------------------------------------------------------
// RnFreeIndicatedPacketBuffer
//
// Frees a packet allocated by ProtocolReceiveIndication.
// ---------------------------------------------------------------------------------------
void
RnFreeIndicatedPacketBuffer(CPacket * ppkt)
{
    Assert(!ppkt->_pnpRecv);
    Assert(ppkt->_pbExternal);

    RnMemFree(ppkt->_pbExternal);
    ppkt->_pbExternal = 0;

    ppkt->Complete();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\sys\rnutil.cpp ===
// ---------------------------------------------------------------------------------------
// rnutil.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "rnp.h"


void *          
RnMemAlloc(
    size_t size, 
    ULONG tag
    )
{
    PVOID pv;
    
    pv = ExAllocatePoolWithTag(
                NonPagedPool,
                size,
                tag
                );

    return pv;
}

void *          
RnMemAllocZ(
    size_t size, 
    ULONG tag
    )
{
    PVOID pv = RnMemAlloc(size, tag);

    if (pv)
    {
        NdisZeroMemory(pv, size);
    }

    return pv;
}

void
RnMemFree(
    void * pv
    )
{
    if (pv)
    {
        ExFreePool(pv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\test\dvt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rntest_none_12.4.56.0_none_25932b6f4e8bca60
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rntest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.manifest
XP_MANIFEST_PATH=manifests\x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.cat
XP_CATALOG_PATH=manifests\x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.cat
XP_PAYLOAD_PATH=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rntest,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\test\dvt\rntest.cpp ===
// ---------------------------------------------------------------------------------------
// rntest.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stddef.h>
#include <rawnic.h>
#include <comdef.h>

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

BOOL        g_fBreakOnError = FALSE;
BOOL        g_fTestRecv = TRUE;

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

INLINE
void DbgBreak()
{
    DebugBreak();
}

#define Verify2(err, x) \
    do { if ((err) != (dwErr = (x))) { \
        printf("[Error]: [%s:%u] %s Expected %s, got %u\n", __FUNCTION__, __LINE__, #x, #err, dwErr); \
        if (g_fBreakOnError) DbgBreak();  \
    } } while (0) 

#define Verify(x) \
    do { if (!(x)) { \
        printf("[Error]: [%s:%u] %s\n", __FUNCTION__, __LINE__, #x); \
        if (g_fBreakOnError) DbgBreak();  \
    } } while (0) 

#define SafeClose(h) if (h) { CloseHandle(h); h = NULL; }

#define TestHeader() \
    HANDLE h     = NULL; \
    DWORD dwErr  = 0; \
    printf("\n===== %s ======\n", __FUNCTION__);

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
#endif

// ---------------------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

#define ETHERFMT "%02X-%02X-%02X-%02X-%02X-%02X"
#define ETHERPRM(x) \
    x[0], \
    x[1], \
    x[2], \
    x[3], \
    x[4], \
    x[5]

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    char * Str() const;
};

struct CEnetFrame
{
    CEnetAddr   _eaDst;
    CEnetAddr   _eaSrc;
    BYTE        _ab[1500 - sizeof(CEnetAddr) * 2];
};

#include <poppack.h>

// Ethernet Headers ----------------------------------------------------------------------

#define ENET_DATA_MAXSIZE       1500
#define ENET_TYPE_IP            HTONS_(0x0800)
#define ENET_TYPE_ARP           HTONS_(0x0806)
#define ENET_TYPE_XBOX          HTONS_(0x886F)

#include <pshpack1.h>

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    INLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    INLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

#include <poppack.h>

char * CEnetAddr::Str() const
{
    STATIC_BUFFER(CEnetAddrStr, 32, 18);
    _snprintf(pch, cch, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}

// ---------------------------------------------------------------------------------------
// More globals
// ---------------------------------------------------------------------------------------

CEnetAddr   g_eaAdapter;

void ShowCounters(RAWNIC_COUNTERS * pCounters);
void ShowAdapters(RAWNIC_ADAPTER_INFO * pAdapters, DWORD cAdapters);

BOOL ParseEthernetAddr(LPCSTR eastr, CEnetAddr* pEa)
{
    const char* p = eastr;
    BYTE digit;

#define MATCH_HEX_DIGIT() \
    if(*p >= '0' && *p <= '9') { \
        digit |= *p - '0'; \
    } else if (*p >= 'A' && *p <= 'F') { \
        digit |= 10 + (*p - 'A'); \
    } else if (*p >= 'a' && *p <= 'f') { \
        digit |= 10 + (*p - 'a'); \
    } else { \
        return FALSE; \
    } \
    p++;

#define MATCH_DIGIT() \
    digit = 0; \
    MATCH_HEX_DIGIT(); \
    digit <<= 4; \
    MATCH_HEX_DIGIT(); 

#define MATCH_DASH() \
    if(*p != '-') { \
        return FALSE; \
    } \
    p++;

#define MATCH_EOS() \
    for(;*p == ' '; p++) \
        ; \
    if(*p != 0) { \
        return FALSE; \
    } 

    MATCH_DIGIT();
    pEa->_ab[0] = digit;
    MATCH_DASH();
    MATCH_DIGIT();
    pEa->_ab[1] = digit;
    MATCH_DASH();
    MATCH_DIGIT();
    pEa->_ab[2] = digit;
    MATCH_DASH();
    MATCH_DIGIT();
    pEa->_ab[3] = digit;
    MATCH_DASH();
    MATCH_DIGIT();
    pEa->_ab[4] = digit;
    MATCH_DASH();
    MATCH_DIGIT();
    pEa->_ab[5] = digit;
    MATCH_EOS();

#undef MATCH_HEX_DIGIT
#undef MATCH_DIGIT
#undef MATCH_EOS

    return TRUE;
}

void TestAttach()
{
    TestHeader();
    
    CEnetAddr ea;

    // Case 1: bogus mac, don't ignore, should fail
    h = NULL;
    memset(ea._ab, 2, sizeof(ea._ab));
    Verify2(ERROR_UNEXP_NET_ERR, RawAdapterOpen(ea._ab, ea._ab, 0, 0, 0, &h));
    SafeClose(h);
   
    // Case 2: bogus mac, ignore, should succeed
    h = NULL;
    memset(ea._ab, 2, sizeof(ea._ab));
    Verify2(NO_ERROR, RawAdapterOpen(ea._ab, ea._ab, RN_OPTION_IGNORE_MAC, 0, 0, &h));
    SafeClose(h);

    // Case 3: real mac, don't ignore, should succeed 
    h = NULL;
    memcpy(ea._ab, g_eaAdapter._ab, sizeof(ea._ab));
    Verify2(NO_ERROR, RawAdapterOpen(ea._ab, ea._ab, 0, 0, 0, &h));
    SafeClose(h);
   
    // Case 4: real mac, ignore, should succeed
    h = NULL;
    memcpy(ea._ab, g_eaAdapter._ab, sizeof(ea._ab));
    Verify2(NO_ERROR, RawAdapterOpen(ea._ab, ea._ab, RN_OPTION_IGNORE_MAC, 0, 0, &h));
    SafeClose(h);

    printf("[OK]\n");
}

void TestReadAdapters(BOOL fShow = FALSE)
{
    TestHeader();

    DWORD cAdapters = 0;

#if 0
    // This functionality isn't implemented in rawnic yet due to my difficulties with the 
    // I/O manager. So this test code is useless now, but perhaps in the future we can fix 
    // this in rawnic.

    // Case 1: request size, then dynamically allocate
    printf("  == TestReadAdapters #1 - Dynamic size ==\n");
    Verify2(NO_ERROR, RawnicReadAdapters(0, NULL, &cAdapters));
    Verify(cAdapters > 0);
    
    if (cAdapters > 0 && cAdapters <= 16)
    {
        RAWNIC_ADAPTER_INFO * pAdapters;
        pAdapters = new RAWNIC_ADAPTER_INFO[cAdapters];

        Verify2(NO_ERROR, RawnicReadAdapters(cAdapters, pAdapters, NULL));
        if (dwErr == NO_ERROR)
        {
            if (fShow)
            {
                ShowAdapters(pAdapters, cAdapters);
                printf("\n");
            }
        }

        delete [] pAdapters;
    }
    else
    {
        printf("[Fail] Invalid number of adapters returned for null case, got %d\n", cAdapters);
    }
#endif

    // Case: static large size
    printf("  == TestReadAdapters - Static size ==\n");
    RAWNIC_ADAPTER_INFO aAdapters[16];
    memset(aAdapters, 0, sizeof(aAdapters));
    Verify2(NO_ERROR, RawnicReadAdapters(ARRAYSIZE(aAdapters), aAdapters, &cAdapters));
    Verify(cAdapters > 0);
    if (cAdapters > 0 && dwErr == NO_ERROR)
    {
        if (fShow)
        {
            ShowAdapters(aAdapters, cAdapters);
            printf("\n");
        }
    }
    
    // Case: small static
    printf("  == TestReadAdapters - Too-small (1 nic) static size ==\n");
    RAWNIC_ADAPTER_INFO aAdapters2[2];
    memset(aAdapters2, 0, sizeof(aAdapters2));
    Verify2(ERROR_MORE_DATA, RawnicReadAdapters(1, aAdapters2, &cAdapters));
    Verify(cAdapters == 1);

    Verify(aAdapters2[0].MacAddress[0] == aAdapters[0].MacAddress[0] &&
           aAdapters2[0].MacAddress[1] == aAdapters[0].MacAddress[1] &&
           aAdapters2[0].MacAddress[2] == aAdapters[0].MacAddress[2] &&
           aAdapters2[0].MacAddress[3] == aAdapters[0].MacAddress[3] &&
           aAdapters2[0].MacAddress[4] == aAdapters[0].MacAddress[4] &&
           aAdapters2[0].MacAddress[5] == aAdapters[0].MacAddress[5]);

    Verify(aAdapters2[1].MacAddress[0] == 0 &&
           aAdapters2[1].MacAddress[1] == 0 &&
           aAdapters2[1].MacAddress[2] == 0 &&
           aAdapters2[1].MacAddress[3] == 0 &&
           aAdapters2[1].MacAddress[4] == 0 &&
           aAdapters2[1].MacAddress[5] == 0);

    // Case 4: invalid params
    printf("  == TestReadAdapters #4 - Invalid params\n");
    Verify2(ERROR_INSUFFICIENT_BUFFER, RawnicReadAdapters(0, NULL, &cAdapters));
    Verify2(NO_ERROR,                  RawnicReadAdapters(ARRAYSIZE(aAdapters), aAdapters, NULL));
    Verify2(ERROR_INVALID_PARAMETER,   RawnicReadAdapters(1, NULL, NULL));
    Verify2(ERROR_INSUFFICIENT_BUFFER, RawnicReadAdapters(0, aAdapters, NULL));
    Verify2(ERROR_INSUFFICIENT_BUFFER, RawnicReadAdapters(0, NULL, NULL));

}

void TestRead()
{
    TestHeader();

    RAWNIC_COUNTERS counters;
    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, g_eaAdapter._ab, 0, 0, 0, &h));
    Verify2(NO_ERROR, RawAdapterReadCounters(h, sizeof(counters), &counters, NULL));
    if (dwErr == NO_ERROR)
    {
        ShowCounters(&counters);
    }

    // Leave 'valid' handle open while doing this call.
    TestReadAdapters(FALSE);

    SafeClose(h);

    // Try with no handle open
    TestReadAdapters(TRUE);

    printf("[OK]\n");
}

void TestXmit()
{
    TestHeader();
    
    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, g_eaAdapter._ab, 0, 0, 0, &h));

    CEnetAddr eaDst;
    eaDst.SetBroadcast();

    BYTE       abFrame[sizeof(WORD)+sizeof(CEnetHdr) + 16];
    *(WORD*)abFrame = (WORD) sizeof(abFrame) - sizeof(WORD);
    CEnetHdr * phdr = (CEnetHdr *)(abFrame + sizeof(WORD));

    phdr->_eaDst = eaDst;
    phdr->_eaSrc = g_eaAdapter;
    phdr->_wType = 0x7777;

    BYTE * pb = (BYTE *)(phdr + 1);
    UINT   cb = 16;

    for (; cb > 0; cb--)
    {
        *pb++ = (BYTE) cb;
    }

    BYTE abSndBuffer[(sizeof(abFrame)+sizeof(WORD))*10];

    for(DWORD i=0; i < 10; i++)
    {
        memcpy(abSndBuffer + i * sizeof(abFrame),
               abFrame,
               sizeof(abFrame));
    }

    for(DWORD i=1; i <= 10; i++)
    {
        Verify2(NO_ERROR, RawAdapterSend(h, sizeof(abFrame) * i, abSndBuffer, NULL));
    }
    
    printf("[OK]\n");

    if (h)
    {
        CloseHandle(h);
    }
}

HANDLE g_hTestXmitOverlappedAsyncWait = NULL;

void CALLBACK TestXmitOverlappedAsyncCallback(
    DWORD error,
    DWORD numberOfBytes, 
    OVERLAPPED* pOverlapped
    )
{
    printf("  TestXmitOverlappedAsyncCallback error=0x%08X, numberOfBytes=0x%08X\n", error, numberOfBytes);
    SetEvent(g_hTestXmitOverlappedAsyncWait);
}

void TestXmitOverlappedAsync()
{
    TestHeader();
   
    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, g_eaAdapter._ab, RN_OPTION_OVERLAPPED, 0, 0, &h));

    g_hTestXmitOverlappedAsyncWait = CreateEventA(NULL, TRUE, FALSE, NULL);
    Verify(g_hTestXmitOverlappedAsyncWait != NULL);

    Verify(BindIoCompletionCallback(h, TestXmitOverlappedAsyncCallback, 0));

    CEnetAddr eaDst;
    eaDst.SetBroadcast();

    BYTE       abFrame[sizeof(WORD)+sizeof(CEnetHdr) + 16];
    *(WORD*)abFrame = (WORD) sizeof(abFrame) - sizeof(WORD);
    CEnetHdr * phdr = (CEnetHdr *)(abFrame + sizeof(WORD));

    phdr->_eaDst = eaDst;
    phdr->_eaSrc = g_eaAdapter;
    phdr->_wType = 0x7777;

    BYTE * pb = (BYTE *)(phdr + 1);
    UINT   cb = 16;

    for (; cb > 0; cb--)
    {
        *pb++ = (BYTE) cb;
    }

    BYTE abSndBuffer[(sizeof(abFrame)+sizeof(WORD))*10];

    for(DWORD i=0; i < 10; i++)
    {
        memcpy(abSndBuffer + i * sizeof(abFrame),
               abFrame,
               sizeof(abFrame));
    }

    printf(">>Testing NULL overlapped, waiting for callback function\n");
    for(DWORD i=1; i <= 10; i++)
    {
        OVERLAPPED ov;
        memset(&ov, 0, sizeof(ov));
        ResetEvent(g_hTestXmitOverlappedAsyncWait);

        DWORD cbSent = 0;
        Verify2(ERROR_IO_PENDING, RawAdapterSend(h, sizeof(abFrame) * i, abSndBuffer, &ov));

        WaitForSingleObject(g_hTestXmitOverlappedAsyncWait, INFINITE);
        Verify(::GetOverlappedResult(h, &ov, &cbSent, FALSE));
    }
    printf("[OK]\n");
    
    printf(">>Testing overlapped with event, waiting with GetOverlappedResult\n");
    OVERLAPPED ov;
    Verify((ov.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL)) != NULL);
    for(DWORD i=1; i <= 10; i++)
    {
        ov.Internal = 0;
        ov.InternalHigh = 0;
        ov.Offset = 0;
        ov.OffsetHigh = 0;

        ResetEvent(g_hTestXmitOverlappedAsyncWait);

        DWORD cbSent = 0;
        Verify2(ERROR_IO_PENDING, RawAdapterSend(h, sizeof(abFrame) * i, abSndBuffer, &ov));
        Verify(::GetOverlappedResult(h, &ov, &cbSent, TRUE));
    }
    printf("[OK]\n");

    if (h)
    {
        CloseHandle(h);
    }

    if(g_hTestXmitOverlappedAsyncWait)
    {
        CloseHandle(g_hTestXmitOverlappedAsyncWait);
    }
}

void TestXmitOverlappedSync()
{
    TestHeader();
    
    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, g_eaAdapter._ab, RN_OPTION_OVERLAPPED, 0, 0, &h));

    CEnetAddr eaDst;
    eaDst.SetBroadcast();

    BYTE       abFrame[sizeof(WORD)+sizeof(CEnetHdr) + 16];
    *(WORD*)abFrame = (WORD) sizeof(abFrame) - sizeof(WORD);
    CEnetHdr * phdr = (CEnetHdr *)(abFrame + sizeof(WORD));

    phdr->_eaDst = eaDst;
    phdr->_eaSrc = g_eaAdapter;
    phdr->_wType = 0x7777;

    BYTE * pb = (BYTE *)(phdr + 1);
    UINT   cb = 16;

    for (; cb > 0; cb--)
    {
        *pb++ = (BYTE) cb;
    }

    BYTE abSndBuffer[(sizeof(abFrame)+sizeof(WORD))*10];

    for(DWORD i=0; i < 10; i++)
    {
        memcpy(abSndBuffer + i * sizeof(abFrame),
               abFrame,
               sizeof(abFrame));
    }

    for(DWORD i=1; i <= 10; i++)
    {
        Verify2(ERROR_INVALID_PARAMETER, RawAdapterSend(h, sizeof(abFrame) * i, abSndBuffer, NULL));
        // Prior to checkin 228098 this would succeed. Now it fails.
        //Verify(dwErr == NO_ERROR);
    }
    
    printf("[OK]\n");

    if (h)
    {
        CloseHandle(h);
    }
}

void TestRecv()
{
    TestHeader();
    
    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, g_eaAdapter._ab, 0, 0, 0, &h));

    BYTE       abFrame[2048];
    CEnetHdr * phdr = (CEnetHdr *)abFrame;

    for (UINT i = 0; i < 10; i++)
    {
        DWORD cbRecv;
        Verify2(NO_ERROR, RawAdapterRecv(h, sizeof(abFrame), abFrame, NULL, &cbRecv));
        printf("[src %s dst %s wtype %X] cb = %d\n", phdr->_eaSrc.Str(), phdr->_eaDst.Str(), NTOHS(phdr->_wType), cbRecv);
    }

    printf("[OK]\n");

    if (h)
    {
        CloseHandle(h);
    }
}

void TestRecvPromiscuous()
{
    TestHeader();

#define TAssert(x) \
    { \
        if(!(x)) { \
            printf("Test assert failed: %s\n", #x); \
            goto Cleanup; \
        } \
    }

    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, g_eaAdapter._ab, RN_OPTION_PROMISCUOUS, 0, 0, &h));

    BYTE       abFrame[10240];
    CEnetHdr * phdr = (CEnetHdr *)abFrame;

//     for (UINT i = 0; i < 10; i++)
    for(;;)
    {
        DWORD cbRecv;
        Verify2(NO_ERROR, RawAdapterRecv(h, sizeof(abFrame), abFrame, NULL, &cbRecv));

        DWORD cPackets = 0;
        DWORD cb       = cbRecv;
        BYTE* pb       = abFrame;

        while(cb > 0)
        {
            TAssert(cb >= sizeof(WORD));
            WORD cbPacket = *(WORD*)pb;
            TAssert(cb >= sizeof(WORD) + cbPacket);
            
            cPackets++;
            pb += cbPacket + sizeof(WORD);
            cb -= cbPacket + sizeof(WORD);
        }

        if(cPackets > 1)
        {
            printf("cbTotal %u cPackets %u\n", cbRecv, cPackets);
        }
//         printf("[src %s dst %s wtype %X] cb = %d\n", phdr->_eaSrc.Str(), phdr->_eaDst.Str(), NTOHS(phdr->_wType), cbRecv);
    }

    printf("[OK]\n");

Cleanup:
    if (h)
    {
        CloseHandle(h);
    }
}

void TestRecvArp()
{
    TestHeader();
    
    CEnetAddr eav = {0x00, 0x02, 0xB4, 0x40, 0x96, 0xA9};

    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, eav._ab, RN_OPTION_BROADCAST_ARP, 0, 0, &h));

    BYTE       abFrame[2048];
    CEnetHdr * phdr = (CEnetHdr *)abFrame;

    for (UINT i = 0; i < 100; i++)
    {
        DWORD cbRecv;
        Verify2(NO_ERROR, RawAdapterRecv(h, sizeof(abFrame), abFrame, NULL, &cbRecv));
        printf("[src %s dst %s wtype %X] cb = %d\n", phdr->_eaSrc.Str(), phdr->_eaDst.Str(), NTOHS(phdr->_wType), cbRecv);
    }

    printf("[OK]\n");

    if (h)
    {
        CloseHandle(h);
    }
}

HANDLE g_hTestRecvArpExWait = NULL;

void CALLBACK TestRecvArpExCallback(
    DWORD error,
    DWORD numberOfBytes, 
    OVERLAPPED* pOverlapped
    )
{
    SetEvent(g_hTestRecvArpExWait);
}

void TestRecvArpEx()
{
    TestHeader();
    
    CEnetAddr eav = {0x00, 0x02, 0xB4, 0x40, 0x96, 0xA9};

    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, eav._ab, RN_OPTION_OVERLAPPED | RN_OPTION_BROADCAST_ARP, 0, 0, &h));

    BYTE       abFrame[2048];
    CEnetHdr * phdr = (CEnetHdr *)abFrame;
    
    g_hTestRecvArpExWait = CreateEventA(NULL, TRUE, FALSE, NULL);
    Verify(g_hTestRecvArpExWait != NULL);

    Verify(BindIoCompletionCallback(h, TestRecvArpExCallback, 0));

    for (UINT i = 0; i < 10; i++)
    {
        OVERLAPPED ov;
        memset(&ov, 0, sizeof(ov));
        ResetEvent(g_hTestRecvArpExWait);

        DWORD cbRecv;
        dwErr = RawAdapterRecv(h, sizeof(abFrame), abFrame, &ov, NULL);
        printf("  RawAdapterRecv returned 0x%08x", dwErr);
        
        WaitForSingleObject(g_hTestRecvArpExWait, INFINITE);
        Verify(::GetOverlappedResult(h, &ov, &cbRecv, FALSE));

        printf("[src %s dst %s wtype %X] cb = %d\n", phdr->_eaSrc.Str(), phdr->_eaDst.Str(), NTOHS(phdr->_wType), cbRecv);
    }

    printf("[OK]\n");

    if (h)
    {
        CloseHandle(h);
    }

    if(g_hTestRecvArpExWait)
    {
        CloseHandle(g_hTestRecvArpExWait);
    }
}

DWORD CALLBACK RecvArpThread(void* param)
{
    UINT threadndx = (UINT)((UINT_PTR)param);

    printf("thread %u started\n", threadndx);

    CEnetAddr eav = {0x00, 0x02, 0xB4, 0x40, 0x96, 0xA9};

    HANDLE h     = NULL;
    DWORD dwErr  = 0;
    Verify2(NO_ERROR, RawAdapterOpen(g_eaAdapter._ab, eav._ab, RN_OPTION_BROADCAST_ARP, 0, 0, &h));

    BYTE       abFrame[2048];
    CEnetHdr * phdr = (CEnetHdr *)abFrame;

    for (UINT i = 0; i < 100; i++)
    {
        DWORD cbRecv;
        Verify2(NO_ERROR, RawAdapterRecv(h, sizeof(abFrame), abFrame, NULL, &cbRecv));
        printf("[t %u src %s dst %s wtype %X] cb = %d\n", threadndx, phdr->_eaSrc.Str(), phdr->_eaDst.Str(), NTOHS(phdr->_wType), cbRecv);
    }

    printf("[OK]\n");

    if (h)
    {
        CloseHandle(h);
    }

    return 0;
}

void TestRecvArp2Thread()
{
    TestHeader();

    HANDLE threads[2];

    for(int i=0; i < ARRAY_SIZE(threads); i++)
    {
        threads[i] = CreateThread(NULL, 0, RecvArpThread, (void*)(UINT_PTR((UINT)(i + 1))), 0, NULL);
        Verify(threads[i]);
    }
    
    WaitForMultipleObjects(2, threads, TRUE, INFINITE);

    for(int i=0; i < ARRAY_SIZE(threads); i++)
    {
        CloseHandle(threads[i]);
    }
}

void TestInstall()
{
    printf("Install...");

    CoInitialize( NULL );

    if( !RawnicInstallDriver( L"Xbox Live Security Gateway" ) )
    {
        printf( "[FAILED]\n" );
        goto Exit;
    }

    printf("[OK]\n");

Exit:
    CoUninitialize();
}

void TestUninstall()
{
    printf("Uninstall...");

    CoInitialize( NULL );

    if( !RawnicUninstallDriver(L"Xbox Live Security Gateway") )
    {
        printf( "[FAILED]\n" );
        goto Exit;
    }

    printf("[OK]\n");

Exit:
    CoUninitialize();
}

// ---------------------------------------------------------------------------------------
// main
// ---------------------------------------------------------------------------------------

void ShowCounters(RAWNIC_COUNTERS * pCounters)
{
#define P(x) printf(" %-45s : %u\n", #x, pCounters->x)
    printf("Rawnic counters:\n");
    P(global.cProtocolReceivePacket);
    P(global.cProtocolReceivePacketCopy);
    P(global.cProtocolReceiveIndication);
    P(global.cProtocolReceiveIndicationDiscard);
    P(global.cProtocolReceiveComplete);
    P(global.cPacketsInUse);
    P(adapter.cReceiveCalls);
    P(adapter.cSendCalls);
    P(adapter.cPacketReceived);
    P(adapter.cPacketDropped);
    P(adapter.cPacketSent);
    P(adapter.cXmitStage1);
    P(adapter.cXmitStage2);
    P(adapter.cRecvBatchThreshold);
    P(adapter.cOverlappedsAllocated);
#undef P
}

void ShowAdapters(RAWNIC_ADAPTER_INFO * pAdapters, DWORD cAdapters)
{
    for (DWORD i = 0; i < cAdapters; i++)
    {
        printf("\nRawnic Adapter #%u:\n", i);
        printf(" %-21s : " ETHERFMT "\n", "Ethernet MAC Address", ETHERPRM(pAdapters[i].MacAddress));
        printf(" %-21s : 0x%08X\n", "State", pAdapters[i].State);
        printf(" %-21s : 0x%08X\n", "Options", pAdapters[i].MacOptions);
    }
}

void ShowHelp()
{
    //   0         1         2         3         4         5         6         7
    //   01234567890123456789012345678901234567890123456789012345678901234567890123456789
    printf(
        "Usage: \n"
        "\n"
        " rntest install \n"
        "   Install rawnic driver. Driver files must be located in the same directory.\n"
        "\n"
        " rntest uninstall \n"
        "   Uninstall rawnic driver. \n"
        "\n"
        " rntest list \n"
        "   List network adapters that rawnic is bound to. \n "
        "\n"
        " rntest <mac-address> [/break] [/norecv]\n"
        "   Run tests. <mac-address> is the mac-address of the network adapter in the \n"
        "   local machine. E.g. 00-06-5B-84-81-E8 \n"
        "     /break  : break into the debugger on error \n"
        "     /norecv : do not test recvs \n"
        "\n");
};

int __cdecl main(int argc, char * argv[])
{
    if(argc < 2) 
    {
        ShowHelp();
        return 1;
    }

    if( 0 == _stricmp( argv[ 1 ], "install" ) )
    {
        TestInstall();
        return 0;
    }

    if( 0 == _stricmp( argv[ 1 ], "uninstall" ) )
    {
        TestUninstall();
        return 0;
    }

    if( 0 == _stricmp( argv[ 1 ], "list" ) )
    {
        DWORD dwErr;
        RAWNIC_ADAPTER_INFO aAdapters[16];
        DWORD cAdapters = 0;
        Verify2(NO_ERROR, RawnicReadAdapters(ARRAYSIZE(aAdapters), aAdapters, &cAdapters));
        Verify(cAdapters > 0);
        if (cAdapters > 0)
        {
            ShowAdapters(aAdapters, cAdapters);
        }
        return 0;
    }

    if(!ParseEthernetAddr(argv[1], &g_eaAdapter))
    {
        printf("Invalid ethernet address.\n");
        ShowHelp();
        return 1;
    }

    for (int i = 2; i < argc; i++)
    {
        if ( 0 == _stricmp( argv[ i ], "/break" ) )
        {
            g_fBreakOnError = TRUE;
        }
        else if ( 0 == _stricmp( argv[ i ], "/norecv" ) )
        {
            g_fTestRecv = FALSE;
        }
    }

    printf("RAWNIC Unit Test\n");
    printf("  Using ethernet address: %s\n", g_eaAdapter.Str());
    printf("  Breaking on errors: %s\n", g_fBreakOnError ? "yes" : "no");
    printf("\n");

    DWORD dwErr = RawnicDetectDriver();
    
    if (dwErr != NO_ERROR)
    {
        printf("RawnicDetectDriver returned error %d.\n", dwErr);
        return(dwErr);
    }

    TestAttach();
    TestRead();
    TestXmit();
    TestXmitOverlappedAsync();
    TestXmitOverlappedSync();

    if (g_fTestRecv)
    {
        TestRecvArpEx();
        TestRecv();
        TestRecvPromiscuous();
        TestRecvArp2Thread();
    }

    printf("[DONE]\n");

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\rawnic\test\dvt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_rntest_none_12.4.56.0_none_25932b6f4e8bca60
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=rntest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.manifest
XP_MANIFEST_PATH=manifests\x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.cat
XP_CATALOG_PATH=manifests\x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64.cat
XP_PAYLOAD_PATH=x86_rntest_no-public-key_12.4.56.0_x-ww_35700c64
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=rntest,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sginstrumentation\lspservice.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "sg.h"
#include "ntsecapi.h"
#include "msxml2.h"
#include "rawnic.h"
#include <atlbase.h>
#include <atlcom.h>
#include <loadperf.h>

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

#ifndef SAFE_CLOSEHANDLE
#define SAFE_CLOSEHANDLE( h )  if( NULL != h ) { CloseHandle( h ); h = NULL; }
#endif

//////////////////////////////////////////////////////////////////////////////
CLspService::CLspService(
                LPCWSTR pszServiceName,
                LPCWSTR pszServiceDisplayName,
                LPCWSTR pszServiceDescription,
                LPCWSTR pszPerfBaseName,
                CComBSTR bstrReserved
) :
    m_pszServiceName( pszServiceName ),
    m_pszServiceDisplayName( pszServiceDisplayName ),
    m_pszServiceDescription( pszServiceDescription ),
    m_pszPerfBaseName( pszPerfBaseName ),
    m_fRunningAsService( TRUE ),
    m_hServiceStatus( NULL ),
    m_pszInstallAccountName( NULL ),
    m_pszInstallAccountPassword( NULL )
{
    UNREFERENCED_PARAMETER(bstrReserved);

    Assert( NULL != m_pszServiceName );
    ZeroMemory( &m_Status, sizeof(m_Status) );

    m_Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_Status.dwCurrentState = SERVICE_STOPPED;
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    m_hevtShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
}


//////////////////////////////////////////////////////////////////////////////
CLspService::~CLspService()
{
    SAFE_CLOSEHANDLE( m_hevtShutdown );
}

BOOL
AmIAService(
    PBOOL IsAService
    )
{

    PSID Service = NULL;
    PSID LocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL IsService = FALSE ;
    BOOL IsLocalSystem = FALSE ;
    BOOL Success = FALSE ;

    if ( !AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 
            0, 0, 0, 0, 0, 0, 0, &LocalSystem ) )
    {
        return FALSE ;
    }

    if ( !AllocateAndInitializeSid( &NtAuthority, 1, SECURITY_SERVICE_RID, 
            0, 0, 0, 0, 0, 0, 0, &Service ) )
    {
        FreeSid( LocalSystem );
        return FALSE ;
        
    }

    *IsAService = FALSE ;

    if ( CheckTokenMembership(NULL, Service, &IsService ) )
    {
        if ( !IsService )
        {
            if ( CheckTokenMembership(NULL, LocalSystem, &IsLocalSystem ) )
            {
                Success = TRUE ;

                if ( IsLocalSystem )
                {
                    *IsAService = TRUE ;
                }
            }
            
        }
        else 
        {
            Success = TRUE ;

            *IsAService = TRUE ;
        }

    }

    FreeSid ( LocalSystem );
    FreeSid ( Service );
    return Success ;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ProcessMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //
    // process parameters
    //

    if(dwArgc > 1)
    {
        LPCWSTR pszCommand = pszArgv[1];

        if(_wcsicmp(pszArgv[1], L"install") == 0)
        {
            return ProcessCommandInstall(dwArgc-2, pszArgv+2);
        }
        else if(_wcsicmp(pszArgv[1], L"uninstall") == 0)
        {
            return ProcessCommandUninstall(dwArgc-2, pszArgv+2);
        }
        else if(_wcsicmp(pszArgv[1], L"list") == 0)
        {
            return ProcessCommandList(dwArgc-2, pszArgv+2);
        }
        else
        {
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // no parameters - run the service
    //

    AmIAService( &m_fRunningAsService );

    //
    // Run the service main routine either on this thread (if running as
    // a console app) or on a new thread (if running as a service).
    //
    if( m_fRunningAsService )
    {
        OutputDebugStringA("Running in service mode\n");

        SERVICE_TABLE_ENTRYW DispatchTable[] =
        {
            { (WCHAR *) m_pszServiceName, StaticServiceMain },
            { NULL, NULL }
        };

        if( !StartServiceCtrlDispatcherW( DispatchTable ) )
        {
            return( GetLastError() );
        }
    }
    else
    {
        printf("Running in console mode\n");

        // Allow Ctrl+C to exit the console app
        SetConsoleCtrlHandler( StaticConsoleCtrlHandler, TRUE );
        ServiceMain( dwArgc, pszArgv );
    }

    CoUninitialize();

    //
    // The service has been stopped (or the console has been shut down).
    //
    return( m_Status.dwWin32ExitCode );
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandInstall
// Process the command-line command 'install'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv)
{
    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    if(dwArgc > 0)
    {
        if(dwArgc != 2)
        {
            InstallInfo("Invalid number of parameters for Install");
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }

        m_pszInstallAccountName     = pArgv[0];
        m_pszInstallAccountPassword = pArgv[1];
    }

    DWORD status = Install();

    if(m_pszInstallAccountPassword)
    {
        memset(m_pszInstallAccountPassword, 0, wcslen(m_pszInstallAccountPassword));
    }

    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    return status;
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandUninstall
// Process the command-line command 'uinstall'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv)
{
    if(dwArgc != 0)
    {
        InstallInfo("Invalid number of parameters for Uninstall");
        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }

    return Uninstall();
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandList
// Process the command-line command 'list'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandList(DWORD dwArgc, LPWSTR* pArgv)
{
    DWORD                 dwRes = ERROR_SUCCESS;
    DWORD                 cAdapters = 0;
    RAWNIC_ADAPTER_INFO   aAdapters[16];  // arbitrarily large

    memset(aAdapters, 0, sizeof(aAdapters));

    // Hopefully 16 is big enough.
    dwRes = RawnicReadAdapters(ARRAYSIZE(aAdapters), aAdapters, &cAdapters);
            
    if (NT_ERROR(dwRes) || cAdapters == 0)
    {
        InstallInfo("Error retrieving list of adapters, Win32 error %u", dwRes);
        return dwRes;
    }
    
    if (dwRes == ERROR_MORE_DATA)
    {
        InstallInfo("Too many adapters found (more than %u), showing partial list", ARRAYSIZE(aAdapters));
    }

    Assert(cAdapters <= ARRAYSIZE(aAdapters));
    for (DWORD i = 0; i < cAdapters; i++)
    {
        InstallInfo("\nRawnic Adapter #%u:", i);
        InstallInfo(" %-21s : " ETHERFMT, "Ethernet MAC Address", ETHERPRM(aAdapters[i].MacAddress));
        InstallInfo(" %-21s : 0x%08X", "State", aAdapters[i].State);
        InstallInfo(" %-21s : 0x%08X", "Options", aAdapters[i].MacOptions);
    }

    return ERROR_SUCCESS;
}

void CLspService::PrintUsage()
{
    CSmallStr moduleFullName;
    CTinyStr  serviceName;  

    CSystem::GetModuleName(NULL, &moduleFullName);
    CSystem::ParseFileName(moduleFullName.cstr(), CSystem::PARSE_NAME_WITHOUT_EXTENSION,
                           &serviceName);

    //           0123456789012345678901234567890123456789012345678901234567890123456789
    InstallInfo("Usage:");
    InstallInfo("");
    InstallInfo("  %s install [<account-name> <account-password]", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Installs service. If account-name and account-password is not");
    InstallInfo("     specified, the service will use the system account.");
    InstallInfo("");
    InstallInfo("  %s uninstall", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Uninstalls service.");
    InstallInfo("");
    InstallInfo("  %s list", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     List network adapters Rawnic is bound to.");
    InstallInfo("");
    InstallInfo("  %s", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Run in console mode.");
    InstallInfo("");
}

//////////////////////////////////////////////////////////////////////////////
BOOL CLspService::IsServiceInstalled(LPCWSTR pszServiceName)
{
    BOOL fResult = FALSE;

    SC_HANDLE hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

    if( NULL != hSCM )
    {
        SC_HANDLE hService = ::OpenServiceW( hSCM, pszServiceName, SERVICE_QUERY_CONFIG );

        if( NULL != hService )
        {
            fResult = TRUE;
            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSCM );
    }

    return( fResult );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Install()
{
    DWORD dwRes = ERROR_SUCCESS;
    
    InstallInfo( "Configurator performing Install");

    do
    {
        //
        // the original SG-LSP's service name was LSPSG and the original MSI did 
        // not uinstall the service correctly. To prevent problems, delete the 
        // LSPSG service if it exists.
        //
        
        UninstallService(L"LSPSG");

        //
        // Optionally uninstall the service - is this necessary?
        //
        if( IsServiceInstalled(m_pszServiceName) )
        {
            InstallInfo( "Removing pre-existing service");

            dwRes = UninstallService(m_pszServiceName);

            if( ERROR_SUCCESS != dwRes )
            {
                break;
            }
        }

        //
        // Optionally install into the SCM
        //
        dwRes = InstallService();

        if( ERROR_SUCCESS != dwRes )
        {
            break;
        }
    }
    while( FALSE );

    return( dwRes );
}



//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Uninstall()
{
    DWORD dwRes = ERROR_SUCCESS;

    InstallInfo( "Configurator performing Uninstall");

    //
    // Remove the perfmon counters
    //
    UninstallCounters(m_pszServiceName);
    UninstallCounters(L"sgsvc");

    //
    // Remove the service from the SCM
    //
    if( IsServiceInstalled(m_pszServiceName) )
    {
        UninstallService(m_pszServiceName);
    }
    else
    {
        InstallInfo( "Service was not present and did not have to be removed");
    }

    return( dwRes );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::InstallCounters()
{
    DWORD dwRes = ERROR_SUCCESS;

    do
    {
        // Skip this step if the service doesn't have a counter dll
        if(NULL == m_pszPerfBaseName)
            break;
        
        if(0 == wcslen(m_pszPerfBaseName))
            break;
        
        InstallInfo( "Installing performance counters specified in %S", m_pszPerfBaseName);

        //
        // Construct name of perf DLL from this EXE's base name
        //
        WCHAR szPerfDLL[ MAX_PATH ];
        wcscpy(szPerfDLL, m_pszPerfBaseName);
        wcscat(szPerfDLL, L".dll");

        //
        // Get the perf DLL to register its entry points
        //
        HMODULE hmodPerf = LoadLibraryW( szPerfDLL );

        if( NULL == hmodPerf )
        {
            dwRes = GetLastError();
            break;
        }

        FARPROC DllRegServ = (FARPROC) GetProcAddress( hmodPerf, "DllRegisterServer" );

        if( NULL != DllRegServ )
        {
            DllRegServ();
        }

        FreeLibrary( hmodPerf );

    }
    while( FALSE );

    return( dwRes );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::UninstallCounters(LPCWSTR pszCounterServiceName)
{
    DWORD dwRes = ERROR_SUCCESS;


    do
    {
        // Skip this step if the service doesn't have a counter dll
        if(NULL == m_pszPerfBaseName)
            break;
        
        InstallInfo( "Removing performance counters from service '%S'", pszCounterServiceName);

        //
        // Use the same routine as unlodctr.exe to do the proper registry
        // grovelling necessary to remove our counters
        //
        WCHAR szCmdLine[ MAX_PATH ];
        wcscpy(szCmdLine, L"unlodctr.exe ");
        wcscat(szCmdLine, pszCounterServiceName);

        dwRes = UnloadPerfCounterTextStringsW( szCmdLine, TRUE );

        if( ERROR_BADKEY == dwRes || ERROR_FILE_NOT_FOUND == dwRes )
        {
            InstallInfo("No counters were found");
        }
        else if( ERROR_SUCCESS != dwRes )
        {
            InstallError( "Failed to unload performance counters strings (0x%08x)\n", dwRes );
            break;
        }
    }
    while( FALSE );

    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::InstallService()
{
    DWORD       dwRes = ERROR_SUCCESS;
    SC_HANDLE   hSCM      = NULL;
    SC_HANDLE   hService  = NULL;
    HANDLE      hToken    = NULL;
    LPCWSTR     pszSvcDependencies = L"RPCSS\0";

    do
    {
        InstallInfo( "Installing NT service");

        //
        // Anything to do?
        //
        if( IsServiceInstalled(m_pszServiceName) )
        {
            InstallInfo( "WARNING: Service is already installed!  Pre-existance check didn't work?");
            break;
        }

        //
        // Figure out where this .EXE lives
        //
        WCHAR szFileName[MAX_PATH + 1];
        GetModuleFileNameW(NULL, szFileName, MAX_PATH);
        szFileName[MAX_PATH] = L'\0';
 
        // If there was a service account specified, make sure that account is granted
        // rights to logon as a service
        if (m_pszInstallAccountName != NULL)
        {
            dwRes = GrantLogonRights(m_pszInstallAccountName);
            if ( ERROR_SUCCESS != dwRes )
            {
                if (dwRes == 0x80070534)
                    InstallError( "Failed granting SeLogonServiceRight to %S because account could not be resolved (0x%08x)\n", m_pszInstallAccountName, dwRes );
                else
                    InstallError( "Failed granting SeLogonServiceRight to %S (0x%08x)\n", m_pszInstallAccountName, dwRes );
                break;
            }
        }

        //
        // Contact the SCM and attempt to add a new service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        DWORD dwFlags = SERVICE_WIN32_OWN_PROCESS;

#if DBG
        // $REVIEW (michion):  Can't specify a service account and interactive process
        //                     at the same time
        if (m_pszInstallAccountName == NULL)
        {
            dwFlags |= SERVICE_INTERACTIVE_PROCESS;
        }

#endif

        hService = CreateServiceW(
            hSCM,
            m_pszServiceName,
            m_pszServiceDisplayName,
            SERVICE_ALL_ACCESS,
            dwFlags,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_NORMAL,
            szFileName,
            NULL,
            NULL,
            pszSvcDependencies,
            m_pszInstallAccountName,
            m_pszInstallAccountPassword ? m_pszInstallAccountPassword : NULL);

        if( NULL == hService )
        {
            // common errors:  1057 = ERROR_INVALID_SERVICE_ACCOUNT
            dwRes = GetLastError();
            InstallError( "Failed to create service %S (0x%08x)\n", m_pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service '%S' (%S) successfully created", m_pszServiceDisplayName, m_pszServiceName);

        //
        // Associate our descriptive string with the newly installed service
        //
        SERVICE_DESCRIPTIONW scDescription;
        scDescription.lpDescription = (LPWSTR) m_pszServiceDescription;

        if( !ChangeServiceConfig2(
                        hService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (void *) &scDescription ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed to change service description (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // Now, reconfigure the service retry configuration.  This turns out to
        // be a bit of a PITA because it requires the process token to have
        // the SE_SHUTDOWN_NAME privilege enabled which isn't (apparently)
        // present by default, even for machine/domain admins.
        //
        InstallInfo( "Setting service retry configuration");

        TOKEN_PRIVILEGES         tkPrivileges;
        SERVICE_FAILURE_ACTIONSW scFailureActions;
        SC_ACTION                rgActions[3];
    
        if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling OpenProcessToken (0x%08x)\n", dwRes );
            break;
        }
     
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkPrivileges.Privileges[0].Luid); 

        tkPrivileges.PrivilegeCount           = 1;
        tkPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
     
        if( !AdjustTokenPrivileges(hToken, FALSE, &tkPrivileges, 0, (PTOKEN_PRIVILEGES)NULL, 0) ||
            ERROR_SUCCESS != GetLastError() ) // Not all privileges were adjusted
        {
            dwRes = GetLastError();
            InstallError( "Failed calling AdjustTokenPrivileges (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // With that out of the way, we can set the restart configuration
        // (the privilege switch above is needed in order to set an
        // SC_ACTION_REBOOT Type entry)
        //
        rgActions[0].Type  = SC_ACTION_NONE;     // $REVIEW (michion): parameterize these into member vars
        rgActions[0].Delay = 5000;
        rgActions[1].Type  = SC_ACTION_NONE;
        rgActions[1].Delay = 5000;
        rgActions[2].Type  = SC_ACTION_NONE;
        rgActions[2].Delay = 5000;
        rgActions[3].Type  = SC_ACTION_NONE;
        rgActions[3].Delay = 5000;

        scFailureActions.dwResetPeriod = 1800;
        scFailureActions.lpRebootMsg   = L"";
        scFailureActions.lpCommand     = L"";
        scFailureActions.cActions      = sizeof(rgActions)/sizeof(rgActions[0]);
        scFailureActions.lpsaActions   = rgActions;

        if( !ChangeServiceConfig2(
                        hService,
                        SERVICE_CONFIG_FAILURE_ACTIONS,
                        (void *) &scFailureActions ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling ChangeServiceConfig2 (0x%08x)\n", dwRes );
            break;
        }

        dwRes = InstallCounters();

        if( ERROR_SUCCESS != dwRes )
        {
            InstallError( "Failed calling InstallCounters (0x%08x)\n", dwRes );
            break;
        }
    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hToken )
    {
        CloseHandle( hToken );
    }

    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }
    
    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::UninstallService(LPCWSTR pszServiceName)
{
    DWORD dwRes = ERROR_SUCCESS;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    BOOL      fOK = FALSE;

    do
    {
        InstallInfo( "Uninstalling NT service %S", pszServiceName);

        //
        // Anything to do?
        //
        if( !IsServiceInstalled(pszServiceName) )
        {
            InstallInfo( "Service is not installed. Nothing to do here.");
            break;
        }

        //
        // Contact the SCM and attempt to open the existing service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        hService = OpenServiceW( hSCM, pszServiceName, SERVICE_STOP | DELETE | SERVICE_QUERY_STATUS );

        if( NULL == hService )
        {
            dwRes = GetLastError();
            InstallError( "Failed retrieving service handle for %S (0x%08x)\n", pszServiceName, dwRes );
            break;
        }

        //
        // Stop and delete the service
        //
        SERVICE_STATUS status;

        fOK = ControlService( hService, SERVICE_CONTROL_STOP, &status );
        if (!fOK)
        {
            dwRes = GetLastError();

            if (dwRes != 0x00000426)   // if the service isn't running, we should get back 0x0426 (ERROR_SERVICE_NOT_ACTIVE)
            {
                InstallError( "Failed to stop service %S.  Service delete will probably fail as well (0x%08x)\n", pszServiceName, dwRes );
            }
            else
            {
                dwRes = 0;  // reset the exit code so that XMGMT doesn't think this was an actual error
            }
        }

        //
        // wait until the service has stopped
        //

        InstallInfo("Waiting for service to stop");
        
        for(;;)
        {
            SERVICE_STATUS_PROCESS serviceStatus;
            DWORD dwNeeded;
            BOOL ok;

            ok = QueryServiceStatusEx(hService, 
                                      SC_STATUS_PROCESS_INFO, 
                                      (BYTE*)&serviceStatus, 
                                      sizeof(serviceStatus), 
                                      &dwNeeded);

            if(!ok)
            {
                InstallError("QueryServiceStatusEx failed. Error = %u", GetLastError());
                break;
            }

            if(SERVICE_STOPPED == serviceStatus.dwCurrentState)
            {
                break;
            }

            InstallInfo("Service hasn't stopped yet. Current state=%u", serviceStatus.dwCurrentState);
            Sleep(1000);
        }

        if( !DeleteService( hService ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed deleting service %S (0x%08x)\n", pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service %S successfully stopped and deleted", pszServiceName);

    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }

    return( dwRes );
}

////////////////////////////////////////////////////////////////////////////
void CLspService::InstallError( char* pszFmt, ... )
{
    char szFmt[ 1024 ];
    va_list marker;

    va_start( marker, pszFmt );
    _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
    printf("InstallError: %s\n", szFmt);
    va_end( marker );

    return;
}


////////////////////////////////////////////////////////////////////////////
void CLspService::InstallInfo( char* pszFmt, ... )
{
    if (pszFmt == NULL)
    {
        printf("CLspService configurator intializing\n");
    }
    else
    {
        char szFmt[ 1024 ];
        va_list marker;

        va_start( marker, pszFmt );
        _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
        printf("   %s\n", szFmt);
        va_end( marker );
    }

    return;
}

////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ChangeState( DWORD dwState )
{
    m_Status.dwCheckPoint = (DWORD) -1; // will be inc. in Checkpoint()
    m_Status.dwCurrentState = dwState;

    return( Checkpoint() );
}


///////////////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Checkpoint( DWORD dwWaitHint /* = 0 */ )
{
    if( m_fRunningAsService )
    {
        m_Status.dwWaitHint = dwWaitHint;
        m_Status.dwCheckPoint++;
        
        if( !SetServiceStatus( m_hServiceStatus, &m_Status ) )
        {
            return( GetLastError() );
        }
    }

    return( ERROR_SUCCESS );
}


////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ReportError( DWORD dwErr )
{
    m_Status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    m_Status.dwServiceSpecificExitCode = dwErr;

    return( Checkpoint() );
}


//////////////////////////////////////////////////////////////////////////////
void CLspService::ServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    // CONSIDER: Move mgmt initialization here

    if( m_fRunningAsService )
    {
        m_hServiceStatus = RegisterServiceCtrlHandlerW(
                                            m_pszServiceName,
                                            StaticServiceControlHandler );

        if( NULL == m_hServiceStatus )
        {
            m_Status.dwWin32ExitCode = GetLastError();
            return;
        }
    }

    ChangeState( SERVICE_START_PENDING );

    m_Status.dwWin32ExitCode = S_OK;
    m_Status.dwCheckPoint = 0;
    m_Status.dwWaitHint = 0;

    HRESULT hr = S_OK;
    BOOL fServiceRan = FALSE;

    do
    {
        Checkpoint();

        hr = InitService( dwArgc, pszArgv );

        if( FAILED( hr ) )
        {
            break;
        }

        Checkpoint();

        ChangeState( SERVICE_RUNNING );

        hr = RunService( &fServiceRan );

        if( FAILED( hr ) )
        {
            break;
        }
    }
    while( FALSE );

    if ( FAILED( hr ) && !fServiceRan )
    {
        ChangeState( SERVICE_STOP_PENDING );
        ReportError( hr );
    }

    ChangeState( SERVICE_STOPPED );
}

//////////////////////////////////////////////////////////////////////////////
void CLspService::TermService()
{
    // wake up the RunService thread
    SetEvent( m_hevtShutdown );
}

//////////////////////////////////////////////////////////////////////////////
void CLspService::ServiceControlHandler( DWORD dwOpcode )
{
    if( SERVICE_CONTROL_STOP == dwOpcode )
    {
        // tell scm we're stopping
        ChangeState( SERVICE_STOP_PENDING );

        // wake up any sockets that are waiting to connect
//        g_SocketConnectWatchdog.Shutdown();

        TermService();
    }
    else
    {
        //
        // Unknown service control opcode?
        //
        OutputDebugStringA(CSmallStr().Format(
                           "ServiceControlHandler: unknown opcode %d", 
                           dwOpcode).cstr());
    }
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CLspService::StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    Assert( NULL != g_pService );
    g_pService->ServiceMain( dwArgc, pszArgv );
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CLspService::StaticServiceControlHandler( DWORD dwOpcode )
{
    Assert( NULL != g_pService );
    g_pService->ServiceControlHandler( dwOpcode );
}

//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CLspService::StaticConsoleCtrlHandler( DWORD dwCtrlType )
{
    Assert( NULL != g_pService );
    g_pService->ServiceControlHandler( SERVICE_CONTROL_STOP );
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::GrantLogonRights(LPCWSTR szAccount)
{
    DWORD       dwRes       = ERROR_SUCCESS;
    NTSTATUS    ntStatus    = 0;

    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    LSA_UNICODE_STRING      PrivilegeString;
    LSA_HANDLE              PolicyHandle = NULL;

    CSIDLookup              sidLookup;

    dwRes = sidLookup.Lookup(szAccount);
    if (FAILED(dwRes))
    {
        goto lCleanup;
    }
    //
    // It is very unfortunate that at this point dwRes holds a HRESULT
    // while this function returns a Win32 error by contract. The best
    // compromise is to have the function return a value that honors the
    // win32 success/failure semantics (0 -> success, failure otherwise),
    // but could potentially return hresults/ntstatus's as failure. This
    // ensures that returns such as S_FALSE are sanitized, but that doesn't
    // fix callers that use FAILED(dwRes). Those need to be fixed case by
    // case
    //
    dwRes = ERROR_SUCCESS;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    ntStatus = ::LsaOpenPolicy(
                    NULL,
                    &ObjectAttributes,
                    POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                    &PolicyHandle
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = ::LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }

    

    PrivilegeString.Buffer        = L"SeServiceLogonRight";
    PrivilegeString.Length        = (USHORT) wcslen(PrivilegeString.Buffer) * sizeof(WCHAR);
    PrivilegeString.MaximumLength = (USHORT)(wcslen(PrivilegeString.Buffer)+1) * sizeof(WCHAR);


    ntStatus = ::LsaAddAccountRights(
                    PolicyHandle,
                    sidLookup.GetPSID(),
                    &PrivilegeString,
                    1
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }


lCleanup:
    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
        PolicyHandle = NULL;
    }

    return( dwRes );
}

CSIDLookup::CSIDLookup()
{
    m_cbSID            = 0;
    m_cchRefDomainName = 0;
    m_pSID             = NULL;
    m_szRefDomainName  = NULL;
}


CSIDLookup::~CSIDLookup()
{
    if (m_pSID)
    {
        ::LocalFree(m_pSID);
        m_pSID = NULL;
    }

    if (m_szRefDomainName)
    {
        ::LocalFree(m_szRefDomainName);
        m_szRefDomainName = NULL;
    }
}


HRESULT CSIDLookup::Lookup(LPCWSTR szAccount)
{
    BOOL    fRet    = false;
    HRESULT hr      = S_OK;
    DWORD   dwRes   = ERROR_SUCCESS;
    SID     sidDummy;
    WCHAR   wstrDummy[2];

    // Get the required buffer sizes

    // N.B.: This is royally F*(&@#D up!  The MSDN docs claim that passing
    //       NULL for the PSID and ReferenceDomainName parameters will,
    //       in conjunction with passing pointers to zero'd out DWORDs for
    //       cbSid and cchReferenceDomainName, return the amount of
    //       space needed for these two buffers.  Total BS!  Unless the
    //       pointers are non-NULL, the function won't return anything in
    //       the cb/cch DWORDS except zero


    fRet = LookupAccountNameW(
            NULL,
            szAccount,
            &sidDummy,
            &m_cbSID,
            wstrDummy,
            &m_cchRefDomainName,
            &m_SIDNameUse
            );

    if (!fRet)
    {
        dwRes = ::GetLastError();
        if (dwRes == ERROR_INSUFFICIENT_BUFFER)
        {
            //-----------------------------------------------------------------
            // this is ok, we expected the function to complain about buffer
            // sizes being too small.  Just keep going now that we have the
            // actual buffer sizes we need in m_cbSID and m_cchRefDomainName
            //
            dwRes = ERROR_SUCCESS;
        }
        else
        {
            //-----------------------------------------------------------------
            // Gotta convert errors into HRESULTS (caller is checking FAILED()
            // which doesn't pick up on regular win32 errors
            //
            hr = HRESULT_FROM_WIN32(dwRes);
            goto lCleanup;
        }
    }
    
    
    m_szRefDomainName = (LPWSTR)::LocalAlloc(LPTR, m_cchRefDomainName * sizeof(TCHAR));
    if (m_szRefDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    m_pSID = (PSID)::LocalAlloc(LPTR, m_cbSID);
    if (m_pSID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    // Do the lookup for real now
    fRet = LookupAccountNameW(
             NULL,
             szAccount,
             m_pSID,
             &m_cbSID,
             m_szRefDomainName,
             &m_cchRefDomainName,
             &m_SIDNameUse
             );
    
    if (!fRet)
    {
        dwRes = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwRes);
        goto lCleanup;
    }
    

lCleanup:
    if (FAILED(hr))
    {
        if (m_pSID)
        {
            ::LocalFree(m_pSID);
            m_pSID = NULL;
        }
        
        if (m_szRefDomainName)
        {
            ::LocalFree(m_szRefDomainName);
            m_szRefDomainName = NULL;
        }
    }

    return hr;
}

PSID    CSIDLookup::GetPSID(void)
{
    return m_pSID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sgonebox\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sginstrumentation\lspservice.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

#include <atlbase.h>

#define MAX_SERVICE_NAME        128
#define MAX_SERVICE_ACCT_PWD    128

//////////////////////////////////////////////////////////////////////////////
//
// Base class for an NT service that runs in its own process.
//
class CLspService
{
public:
    
    CLspService(
            LPCWSTR pszServiceName,
            LPCWSTR pszServiceDisplayName,
            LPCWSTR pszServiceDescription,
            LPCWSTR pszPerfBaseName,
            CComBSTR bstrReserved
            ); 
    virtual ~CLspService();

    //
    // Call this function as the body of the service's main() routine.
    //
    DWORD ProcessMain( DWORD dwArgc, LPWSTR *pszArgv );

protected:
    
    DWORD ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv);
    DWORD ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv);
    DWORD ProcessCommandList(DWORD dwArgc, LPWSTR* pArgv);
    void PrintUsage();
    
    //
    // Utility function that determines if the service has been registered
    // with the SCM
    //
    BOOL IsServiceInstalled(LPCWSTR pszServiceName);

    //
    // Derived classes must implement this initialization method
    //
    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv ) = 0;

    //
    // Derived classes must do run their service in this routine
    //
    virtual HRESULT RunService( BOOL *pfServiceRan ) = 0;

    //
    // Derived classes can override this termination method
    //
    virtual void TermService();

    //
    // Handle all aspects of service installation
    //
    virtual DWORD Install();

    //
    // Handle all aspects of service uninstallation
    //
    virtual DWORD Uninstall();

    //
    // Register perfmon counters using perf DLL with same base name as the EXE
    //
    DWORD InstallCounters();

    //
    // Unregister any previously registered perfmon counters
    //
    DWORD UninstallCounters(LPCWSTR pszCounterServiceName);

    //
    // Register the service with the SCM
    //
    DWORD InstallService();

    //
    // Unregister the service with the SCM
    //
    DWORD UninstallService(LPCWSTR pszServiceName);

    //
    // Grant the service account rights to logon as a service
    //
    virtual DWORD GrantLogonRights(LPCWSTR szAccount);

    //
    // Various service status reporting methods
    //
    DWORD ChangeState( DWORD dwState );

    DWORD Checkpoint( DWORD dwWaitHint = 0 );

    DWORD ReportError( DWORD dwErr );

    //
    // Runs the main thread of the service/console app
    //
    virtual void ServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    //
    // Called by the service control handler routine to process notifications
    // and commands from the SCM.
    //
    virtual void ServiceControlHandler( DWORD dwOpcode );

    //
    // Gives derived classes access to our shutdown notification event
    //
    HANDLE ShutdownEvent()
    {
        return( m_hevtShutdown );
    }

    //
    // Report installation progress/error
    //
    void InstallError( char* pszFmt, ... );
    void InstallInfo( char* pszFmt = NULL, ... );

private:
    static void WINAPI StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    static void WINAPI StaticServiceControlHandler( DWORD dwOpcode );

    static BOOL WINAPI StaticConsoleCtrlHandler( DWORD dwCtrlType );

protected:
    LPCWSTR m_pszServiceName;
    LPCWSTR m_pszServiceDisplayName;
    LPCWSTR m_pszServiceDescription;
    LPCWSTR m_pszPerfBaseName;

    BOOL m_fRunningAsService;

    HANDLE m_hevtShutdown;

    SERVICE_STATUS_HANDLE m_hServiceStatus;

    SERVICE_STATUS m_Status;

    LPWSTR m_pszInstallAccountName;
    LPWSTR m_pszInstallAccountPassword;
};

class CSIDLookup
{
public:
    CSIDLookup();
    ~CSIDLookup();

    HRESULT Lookup(LPCWSTR szAccount);
    PSID    GetPSID(void);

private:
    DWORD           m_cbSID;
    DWORD           m_cchRefDomainName;
    PSID            m_pSID;
    LPWSTR          m_szRefDomainName;
    SID_NAME_USE    m_SIDNameUse;
};

//////////////////////////////////////////////////////////////////////////////
//
// There must always be only one global service object; it is pointed to
// by the following global pointer;  the actual object can be a derived class.
//
extern CLspService *g_pService;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglsp\lspservice.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

#include <atlbase.h>

#define MAX_SERVICE_NAME        128
#define MAX_SERVICE_ACCT_PWD    128

//////////////////////////////////////////////////////////////////////////////
//
// Base class for an NT service that runs in its own process.
//
class CLspService
{
public:
    
    CLspService(
            LPCWSTR pszServiceName,
            LPCWSTR pszServiceDisplayName,
            LPCWSTR pszServiceDescription,
            LPCWSTR pszPerfBaseName,
            CComBSTR bstrReserved
            ); 
    virtual ~CLspService();

    //
    // Call this function as the body of the service's main() routine.
    //
    DWORD ProcessMain( DWORD dwArgc, LPWSTR *pszArgv );

protected:
    
    DWORD ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv);
    DWORD ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv);
    DWORD ProcessCommandList(DWORD dwArgc, LPWSTR* pArgv);
    void PrintUsage();
    
    //
    // Utility function that determines if the service has been registered
    // with the SCM
    //
    BOOL IsServiceInstalled(LPCWSTR pszServiceName);

    //
    // Derived classes must implement this initialization method
    //
    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv ) = 0;

    //
    // Derived classes must do run their service in this routine
    //
    virtual HRESULT RunService( BOOL *pfServiceRan ) = 0;

    //
    // Derived classes can override this termination method
    //
    virtual void TermService();

    //
    // Handle all aspects of service installation
    //
    virtual DWORD Install();

    //
    // Handle all aspects of service uninstallation
    //
    virtual DWORD Uninstall();

    //
    // Register perfmon counters using perf DLL with same base name as the EXE
    //
    DWORD InstallCounters();

    //
    // Unregister any previously registered perfmon counters
    //
    DWORD UninstallCounters(LPCWSTR pszCounterServiceName);

    //
    // Register the service with the SCM
    //
    DWORD InstallService();

    //
    // Unregister the service with the SCM
    //
    DWORD UninstallService(LPCWSTR pszServiceName);

    //
    // Grant the service account rights to logon as a service
    //
    virtual DWORD GrantLogonRights(LPCWSTR szAccount);

    //
    // Various service status reporting methods
    //
    DWORD ChangeState( DWORD dwState );

    DWORD Checkpoint( DWORD dwWaitHint = 0 );

    DWORD ReportError( DWORD dwErr );

    //
    // Runs the main thread of the service/console app
    //
    virtual void ServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    //
    // Called by the service control handler routine to process notifications
    // and commands from the SCM.
    //
    virtual void ServiceControlHandler( DWORD dwOpcode );

    //
    // Gives derived classes access to our shutdown notification event
    //
    HANDLE ShutdownEvent()
    {
        return( m_hevtShutdown );
    }

    //
    // Report installation progress/error
    //
    void InstallError( char* pszFmt, ... );
    void InstallInfo( char* pszFmt = NULL, ... );

private:
    static void WINAPI StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    static void WINAPI StaticServiceControlHandler( DWORD dwOpcode );

    static BOOL WINAPI StaticConsoleCtrlHandler( DWORD dwCtrlType );

protected:
    LPCWSTR m_pszServiceName;
    LPCWSTR m_pszServiceDisplayName;
    LPCWSTR m_pszServiceDescription;
    LPCWSTR m_pszPerfBaseName;

    BOOL m_fRunningAsService;

    HANDLE m_hevtShutdown;

    SERVICE_STATUS_HANDLE m_hServiceStatus;

    SERVICE_STATUS m_Status;

    LPWSTR m_pszInstallAccountName;
    LPWSTR m_pszInstallAccountPassword;
};

class CSIDLookup
{
public:
    CSIDLookup();
    ~CSIDLookup();

    HRESULT Lookup(LPCWSTR szAccount);
    PSID    GetPSID(void);

private:
    DWORD           m_cbSID;
    DWORD           m_cchRefDomainName;
    PSID            m_pSID;
    LPWSTR          m_szRefDomainName;
    SID_NAME_USE    m_SIDNameUse;
};

//////////////////////////////////////////////////////////////////////////////
//
// There must always be only one global service object; it is pointed to
// by the following global pointer;  the actual object can be a derived class.
//
extern CLspService *g_pService;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\aes\aestest.cpp ===
// ---------------------------------------------------------------------------------------
// aestest.cpp
//
// Copyright (C) Microsoft Corporation
//
// Compare speedz
// ---------------------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stddef.h>
#include <crypto\aes.h>
#include <crypto\rc4.h>
#include <crypto\sha.h>
#include <crypto\md5.h>
#include <crypto\modes.h>
#include <crypto\des.h>
#include <crypto\tripldes.h>
#include <crypto\benaloh.h>
#include <randlib.h>
#include <assert.h>

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

#define HMAC_K_PADSIZE              64
#define XC_SERVICE_SHA_CONTEXT_SIZE  116

typedef void (* CipherFunction)(BYTE *, BYTE *, void *, int);

BYTE    g_abRandRc4Struct[sizeof(RC4_KEYSTRUCT)];
BOOL    g_fRandInitialized = FALSE;

DWORD   g_dwDataSize;
DWORD   g_cIterations;
DWORD   g_aesKeySize;
BOOL    g_fUseKeyTable;


// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

void PrintUsage();

// ---------------------------------------------------------------------------------------
// Timer stuff
// ---------------------------------------------------------------------------------------

class CTimeMeasurement
{
public:
    CTimeMeasurement()
    {
        QueryPerformanceFrequency(&_liFreq);
    }

    void TimerStart()
    {
        QueryPerformanceCounter(&_liStartTime);
    }

    void TimerStop(DWORD cIterations)
    {
        QueryPerformanceCounter(&_liStopTime);
        ElapsedTicks = (_liStopTime.QuadPart - _liStartTime.QuadPart);
        ElapsedMs = (1000 * ElapsedTicks / _liFreq.QuadPart);
        ElapsedUs = (1000000 * ElapsedTicks / _liFreq.QuadPart);
        ElapsedNs = (1000000000 * ElapsedTicks / _liFreq.QuadPart);
        Tps = (DWORD)((ULONGLONG)cIterations * _liFreq.QuadPart / ElapsedTicks);
        if (ElapsedNs <= 1)
        {
            printf("%I64u ticks\n",
                   ElapsedTicks);
        }
        else if (ElapsedUs <= 1)
        {
            assert(ElapsedNs > 0);
            printf("%I64u nanoseconds (%u tps)\n",
                   ElapsedNs,
                   Tps);
        }
        else if (ElapsedMs <= 1)
        {
            assert(ElapsedUs > 0);
            printf("%I64u microseconds (%u tps)\n",
                   ElapsedUs,
                   Tps);
        }
        else
        {
            assert(ElapsedMs > 0);
            printf("%I64u milliseconds (%u tps)\n",
                   ElapsedMs,
                   Tps);
        }
    }

    DWORD       Tps;
    ULONGLONG   ElapsedTicks;
    ULONGLONG   ElapsedMs;
    ULONGLONG   ElapsedUs;
    ULONGLONG   ElapsedNs;

private:
    LARGE_INTEGER _liFreq;
    LARGE_INTEGER _liStartTime;
    LARGE_INTEGER _liStopTime;
};

// Globally accessible
CTimeMeasurement timer;


// ---------------------------------------------------------------------------------------
// Random numbers
// ---------------------------------------------------------------------------------------

BOOL SgRandInit()
{
    assert( !g_fRandInitialized );

    // Init the library random number generator.
    InitializeRNG( NULL );

    // Init our own random number generator that can be called at DPC
    BYTE    abRand[512];

    // Get some good randomness.
    NewGenRandom( NULL, NULL, abRand, sizeof( abRand ) );

    // Initialize an RC4 machine with the given random bits as a key
    rc4_key((RC4_KEYSTRUCT*)g_abRandRc4Struct, sizeof( abRand ), abRand);

    // Throw away the first 256 bytes of the RC4 machine
    rc4((RC4_KEYSTRUCT*)g_abRandRc4Struct, 256, abRand );

    g_fRandInitialized = TRUE;

    return TRUE;
}

void SgRandTerm()
{
    if( g_fRandInitialized )
    {
        ShutdownRNG( NULL );
        g_fRandInitialized = FALSE;
    }
}

BOOL SgRand(BYTE * pb, UINT cb)
{
    rc4((RC4_KEYSTRUCT*)g_abRandRc4Struct, cb, pb);
    return TRUE;
}

// ---------------------------------------------------------------------------------------
// Crypto helper functions
// ---------------------------------------------------------------------------------------

void BlockCryptCBC(
    int op,  // ENCRYPT or DECRYPT
    CipherFunction func,
    IN ULONG dwBlockLen,
    IN ULONG dwInputLength, 
    IN PUCHAR pbOutput, 
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable, 
    IN PUCHAR pbFeedback)
{
    BYTE *pbInputEnd = pbInput + dwInputLength;
    while (pbInput < pbInputEnd)
    {
        CBC(func, dwBlockLen, pbOutput, pbInput, pbKeyTable, op, pbFeedback);
        pbInput += dwBlockLen;
        pbOutput += dwBlockLen;
    }
}

void XcHMAC4(BYTE * pbKeyMaterial, UINT cbKeyMaterial, BYTE * pbData, UINT cbData,
             BYTE * pbData2, UINT cbData2, BYTE * pbData3, UINT cbData3, BYTE * pbData4, UINT cbData4,
             BYTE * HmacData)
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
        A_SHAUpdate(&shaHash, pbData, cbData);
    if (cbData2 != 0)
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    if (cbData3 != 0)
        A_SHAUpdate(&shaHash, pbData3, cbData3);
    if (cbData4 != 0)
        A_SHAUpdate(&shaHash, pbData4, cbData4);

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

void XcHMACMakeKeyTable(BYTE * pbKeyMaterial, UINT cbKeyMaterial, BYTE * pbKeyTable)
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    memcpy(pbKeyTable, &shaHash, sizeof(A_SHA_CTX));

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kopad, HMAC_K_PADSIZE);
    memcpy(pbKeyTable + sizeof(A_SHA_CTX), &shaHash, sizeof(A_SHA_CTX));
}

void XcHMACWithKeyTable(BYTE * pbKeyTable, BYTE * pbData, UINT cbData,
             BYTE * pbData2, UINT cbData2, BYTE * pbData3, UINT cbData3, BYTE * pbData4, UINT cbData4,
             BYTE * HmacData)
{
    A_SHA_CTX shaHash;

    memcpy(&shaHash, pbKeyTable, sizeof(A_SHA_CTX));

    if (cbData != 0)
        A_SHAUpdate(&shaHash, pbData, cbData);
    if (cbData2 != 0)
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    if (cbData3 != 0)
        A_SHAUpdate(&shaHash, pbData3, cbData3);
    if (cbData4 != 0)
        A_SHAUpdate(&shaHash, pbData4, cbData4);

    A_SHAFinal(&shaHash,HmacData);

    memcpy(&shaHash, pbKeyTable + sizeof(A_SHA_CTX), sizeof(A_SHA_CTX));

    A_SHAUpdate(&shaHash, HmacData, A_SHA_DIGEST_LEN);

    A_SHAFinal(&shaHash, HmacData);
}


BOOL Go(
    int op,  // ENCRYPT or DECRYPT
    CipherFunction func,
    DWORD dwKeySize,
    DWORD dwDataSize,
    DWORD cIterations,
    BOOL  fUseKeyTable)
{
    DWORD c_KeySize;
    DWORD c_BlockLen;
    DWORD c_AesRounds;

    BYTE  keyTable[AES_TABLESIZE_256];
    BYTE* rawKey;
    BYTE* iv;
    BYTE* pData;
    DWORD cData;

    switch (op)
    {
    case ENCRYPT:
        printf("Encrypting ");
        break;
    case DECRYPT:
        printf("Decrypting ");
        break;
    default:
        printf("Unknown op %d\n", op);
        return FALSE;
    }

    if (func == aes)
    {
        printf("AES%-4u ", dwKeySize * 8);
        c_KeySize = dwKeySize;
        c_BlockLen = AES_BLOCKLEN;
        switch (dwKeySize)
        {
        case AES_KEYSIZE_128:
            c_AesRounds = AES_ROUNDS_128;
            break;
        case AES_KEYSIZE_192:
            c_AesRounds = AES_ROUNDS_192;
            break;
        case AES_KEYSIZE_256:
            c_AesRounds = AES_ROUNDS_256;
            break;
        default:
            printf("Invalid key size %u\n", dwKeySize);
            return FALSE;
        }
    }
    else if (func == des)
    {
        printf("DES     ");
        c_KeySize = DES_KEYSIZE;
        c_BlockLen = DES_BLOCKLEN;
    }
    else if (func == tripledes)
    {
        printf("DES3    ");
        c_KeySize = DES3_KEYSIZE;
        c_BlockLen = DES_BLOCKLEN;
    }
    else
    {
        printf("Unknown cipher function\n");
        return FALSE;
    }

    rawKey = new BYTE[c_KeySize];
    iv = new BYTE[c_BlockLen];
    cData = dwDataSize + (c_BlockLen - (dwDataSize % c_BlockLen)) % c_BlockLen;
    pData = new BYTE[cData];

    printf(": keylen %2u, blocksize %2u, data %4u : ", c_KeySize, c_BlockLen, cData);
    
    // Create random raw key
    SgRand(rawKey, sizeof(rawKey));
    
    timer.TimerStart();
    for (ULONG iter = 0; iter < cIterations; ++iter)
    {
        if (!fUseKeyTable || iter == 0)
        {
            // Create key table
            if (func == aes)
            {
                aeskey((AESTable*)keyTable, rawKey, c_AesRounds);
            }
            else if (func == des)
            {
                deskey((DESTable*)keyTable, rawKey);
            }
            else if (func == tripledes)
            {
                tripledes3key((DES3TABLE*)keyTable, rawKey);
            }
        }

        BlockCryptCBC(
            op,
            func,
            c_BlockLen,
            cData,
            pData,  // output
            pData,  // input
            keyTable,
            iv);
    }
    timer.TimerStop(cIterations);

    delete [] rawKey;
    delete [] iv;
    delete [] pData;

    return TRUE;
}

BOOL GoHmac(
    DWORD dwDataSize,
    DWORD cIterations,
    BOOL  fUseKeyTable)
{
    DWORD c_KeySize = 16;
    BYTE  keyTable[XC_SERVICE_SHA_CONTEXT_SIZE * 2];
    BYTE  abHmacData[20];
    BYTE* rawKey;
    BYTE* pData;
    DWORD cData;

    rawKey = new BYTE[c_KeySize];
    cData = dwDataSize;
    pData = new BYTE[cData];

    //      Encrypting DES3    : keylen 24, blocksize  8, data   16 :
    printf("Hashing HMAC-SHA1  : keylen %2u,             , data %4u : ", c_KeySize, cData);

    // Create random raw key
    SgRand(rawKey, sizeof(rawKey));
    
    timer.TimerStart();
    if (fUseKeyTable)
    {
        XcHMACMakeKeyTable(rawKey, 16, keyTable);
    }
    for (ULONG iter = 0; iter < cIterations; ++iter)
    {
        if (fUseKeyTable)
        {
            XcHMACWithKeyTable(keyTable,
                               pData, cData,
                               NULL, 0,
                               NULL, 0,
                               NULL, 0,
                               abHmacData);
        }
        else
        {
            XcHMAC4(rawKey, 16,
                    pData, cData,
                    NULL, 0,
                    NULL, 0,
                    NULL, 0,
                    abHmacData);
        }
    }
    timer.TimerStop(cIterations);

    delete [] rawKey;
    delete [] pData;

    return TRUE;
}

// ---------------------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------------------

int __cdecl main(int argc, char * argv[])
{
    printf("[AES Speed Comparison Test]\n\n");

    if(argc < 3)
    {
        PrintUsage();
        return 1;
    }
        
    g_fUseKeyTable = TRUE;  // meh, lazy

    g_cIterations = atoi(argv[1]);
    g_dwDataSize = atoi(argv[2]);
    if (argc >= 4)
    {
        g_aesKeySize = atoi(argv[3]) / 8;
    }
    else
    {
        g_aesKeySize = 256 / 8;
    }

    if (g_cIterations == 0 ||
        g_dwDataSize == 0 ||
        (g_aesKeySize != 16 && g_aesKeySize != 24 && g_aesKeySize != 32))
    {
        printf("Invalid parameters\n");
        PrintUsage();
        return 1;
    }

    printf("     Iterations: %u\n", g_cIterations);
    printf("      Data size: %u\n", g_dwDataSize);
    printf("Using key table: %u\n", g_fUseKeyTable);

    DWORD tpsAes;
    DWORD tpsDes;
    DWORD tpsDes3;

    printf("\n===== ENCRYPT =====\n");
    Go(ENCRYPT, aes, g_aesKeySize, g_dwDataSize, g_cIterations, g_fUseKeyTable);
    tpsAes = timer.Tps;
    Go(ENCRYPT, des, DES_KEYSIZE, g_dwDataSize, g_cIterations, g_fUseKeyTable);
    tpsDes = timer.Tps;
    Go(ENCRYPT, tripledes, DES3_KEYSIZE, g_dwDataSize, g_cIterations, g_fUseKeyTable);
    tpsDes3 = timer.Tps;
    GoHmac(g_dwDataSize, g_cIterations, g_fUseKeyTable);

//     printf("AES%u is %u%% the speed of DES3\n", 8 * g_aesKeySize, (100 * tpsAes / tpsDes3));
//     printf("AES%u is %u%% the speed of DES\n", 8 * g_aesKeySize, (100 * tpsAes / tpsDes));
//     printf("DES is %u%% the speed of DES3\n", (100 * tpsDes / tpsDes3));

    printf("\n===== DECRYPT =====\n");
    Go(DECRYPT, aes, g_aesKeySize, g_dwDataSize, g_cIterations, g_fUseKeyTable);
    tpsAes = timer.Tps;
    Go(DECRYPT, des, DES_KEYSIZE, g_dwDataSize, g_cIterations, g_fUseKeyTable);
    tpsDes = timer.Tps;
    Go(DECRYPT, tripledes, DES3_KEYSIZE, g_dwDataSize, g_cIterations, g_fUseKeyTable);
    tpsDes3 = timer.Tps;
    GoHmac(g_dwDataSize, g_cIterations, g_fUseKeyTable);

//     printf("AES%u is %u%% the speed of DES3\n", 8 * g_aesKeySize, (100 * tpsAes / tpsDes3));
//     printf("AES%u is %u%% the speed of DES\n", 8 * g_aesKeySize, (100 * tpsAes / tpsDes));
//     printf("DES is %u%% the speed of DES3\n", (100 * tpsDes / tpsDes3));

    printf("[DONE]\n");
    return(0);
}

void PrintUsage()
{
#define P(s) printf(s "\n");

    P("Usage:");
    P("");
    P("  aestest.exe numiterations datasize [aeskeysize]");
    P("");
    P("Notes:");
    P("");
    P("  datasize will always be rounded up to the appropriate block size.");
    P("  aeskeysize must be 128, 192, or 256.");
    P("");
    P("Examples:");
    P("");
    P("  aestest 1000 16");
    P("  aestest 10000 1440");
    P("  aestest 10000 16 128");
    P("  aestest 10000 1440 256");
    P("");

#undef P

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\sglsp\lspservice.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "sg.h"
#include "ntsecapi.h"
#include "msxml2.h"
#include "rawnic.h"
#include <atlbase.h>
#include <atlcom.h>
#include <loadperf.h>

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

#ifndef SAFE_CLOSEHANDLE
#define SAFE_CLOSEHANDLE( h )  if( NULL != h ) { CloseHandle( h ); h = NULL; }
#endif

//////////////////////////////////////////////////////////////////////////////
CLspService::CLspService(
                LPCWSTR pszServiceName,
                LPCWSTR pszServiceDisplayName,
                LPCWSTR pszServiceDescription,
                LPCWSTR pszPerfBaseName,
                CComBSTR bstrReserved
) :
    m_pszServiceName( pszServiceName ),
    m_pszServiceDisplayName( pszServiceDisplayName ),
    m_pszServiceDescription( pszServiceDescription ),
    m_pszPerfBaseName( pszPerfBaseName ),
    m_fRunningAsService( TRUE ),
    m_hServiceStatus( NULL ),
    m_pszInstallAccountName( NULL ),
    m_pszInstallAccountPassword( NULL )
{
    UNREFERENCED_PARAMETER(bstrReserved);

    Assert( NULL != m_pszServiceName );
    ZeroMemory( &m_Status, sizeof(m_Status) );

    m_Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_Status.dwCurrentState = SERVICE_STOPPED;
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    m_hevtShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
}


//////////////////////////////////////////////////////////////////////////////
CLspService::~CLspService()
{
    SAFE_CLOSEHANDLE( m_hevtShutdown );
}

BOOL
AmIAService(
    PBOOL IsAService
    )
{

    PSID Service = NULL;
    PSID LocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL IsService = FALSE ;
    BOOL IsLocalSystem = FALSE ;
    BOOL Success = FALSE ;

    if ( !AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 
            0, 0, 0, 0, 0, 0, 0, &LocalSystem ) )
    {
        return FALSE ;
    }

    if ( !AllocateAndInitializeSid( &NtAuthority, 1, SECURITY_SERVICE_RID, 
            0, 0, 0, 0, 0, 0, 0, &Service ) )
    {
        FreeSid( LocalSystem );
        return FALSE ;
        
    }

    *IsAService = FALSE ;

    if ( CheckTokenMembership(NULL, Service, &IsService ) )
    {
        if ( !IsService )
        {
            if ( CheckTokenMembership(NULL, LocalSystem, &IsLocalSystem ) )
            {
                Success = TRUE ;

                if ( IsLocalSystem )
                {
                    *IsAService = TRUE ;
                }
            }
            
        }
        else 
        {
            Success = TRUE ;

            *IsAService = TRUE ;
        }

    }

    FreeSid ( LocalSystem );
    FreeSid ( Service );
    return Success ;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ProcessMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //
    // process parameters
    //

    if(dwArgc > 1)
    {
        LPCWSTR pszCommand = pszArgv[1];

        if(_wcsicmp(pszArgv[1], L"install") == 0)
        {
            return ProcessCommandInstall(dwArgc-2, pszArgv+2);
        }
        else if(_wcsicmp(pszArgv[1], L"uninstall") == 0)
        {
            return ProcessCommandUninstall(dwArgc-2, pszArgv+2);
        }
        else if(_wcsicmp(pszArgv[1], L"list") == 0)
        {
            return ProcessCommandList(dwArgc-2, pszArgv+2);
        }
        else
        {
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // no parameters - run the service
    //

    AmIAService( &m_fRunningAsService );

    //
    // Run the service main routine either on this thread (if running as
    // a console app) or on a new thread (if running as a service).
    //
    if( m_fRunningAsService )
    {
        OutputDebugStringA("Running in service mode\n");

        SERVICE_TABLE_ENTRYW DispatchTable[] =
        {
            { (WCHAR *) m_pszServiceName, StaticServiceMain },
            { NULL, NULL }
        };

        if( !StartServiceCtrlDispatcherW( DispatchTable ) )
        {
            return( GetLastError() );
        }
    }
    else
    {
        printf("Running in console mode\n");

        // Allow Ctrl+C to exit the console app
        SetConsoleCtrlHandler( StaticConsoleCtrlHandler, TRUE );
        ServiceMain( dwArgc, pszArgv );
    }

    CoUninitialize();

    //
    // The service has been stopped (or the console has been shut down).
    //
    return( m_Status.dwWin32ExitCode );
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandInstall
// Process the command-line command 'install'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv)
{
    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    if(dwArgc > 0)
    {
        if(dwArgc != 2)
        {
            InstallInfo("Invalid number of parameters for Install");
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }

        m_pszInstallAccountName     = pArgv[0];
        m_pszInstallAccountPassword = pArgv[1];
    }

    DWORD status = Install();

    if(m_pszInstallAccountPassword)
    {
        memset(m_pszInstallAccountPassword, 0, wcslen(m_pszInstallAccountPassword));
    }

    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    return status;
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandUninstall
// Process the command-line command 'uinstall'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv)
{
    if(dwArgc != 0)
    {
        InstallInfo("Invalid number of parameters for Uninstall");
        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }

    return Uninstall();
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandList
// Process the command-line command 'list'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandList(DWORD dwArgc, LPWSTR* pArgv)
{
    DWORD                 dwRes = ERROR_SUCCESS;
    DWORD                 cAdapters = 0;
    RAWNIC_ADAPTER_INFO   aAdapters[16];  // arbitrarily large

    memset(aAdapters, 0, sizeof(aAdapters));

    // Hopefully 16 is big enough.
    dwRes = RawnicReadAdapters(ARRAYSIZE(aAdapters), aAdapters, &cAdapters);
            
    if (NT_ERROR(dwRes) || cAdapters == 0)
    {
        InstallInfo("Error retrieving list of adapters, Win32 error %u", dwRes);
        return dwRes;
    }
    
    if (dwRes == ERROR_MORE_DATA)
    {
        InstallInfo("Too many adapters found (more than %u), showing partial list", ARRAYSIZE(aAdapters));
    }

    Assert(cAdapters <= ARRAYSIZE(aAdapters));
    for (DWORD i = 0; i < cAdapters; i++)
    {
        InstallInfo("\nRawnic Adapter #%u:", i);
        InstallInfo(" %-21s : " ETHERFMT, "Ethernet MAC Address", ETHERPRM(aAdapters[i].MacAddress));
        InstallInfo(" %-21s : 0x%08X", "State", aAdapters[i].State);
        InstallInfo(" %-21s : 0x%08X", "Options", aAdapters[i].MacOptions);
    }

    return ERROR_SUCCESS;
}

void CLspService::PrintUsage()
{
    CSmallStr moduleFullName;
    CTinyStr  serviceName;  

    CSystem::GetModuleName(NULL, &moduleFullName);
    CSystem::ParseFileName(moduleFullName.cstr(), CSystem::PARSE_NAME_WITHOUT_EXTENSION,
                           &serviceName);

    //           0123456789012345678901234567890123456789012345678901234567890123456789
    InstallInfo("Usage:");
    InstallInfo("");
    InstallInfo("  %s install [<account-name> <account-password]", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Installs service. If account-name and account-password is not");
    InstallInfo("     specified, the service will use the system account.");
    InstallInfo("");
    InstallInfo("  %s uninstall", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Uninstalls service.");
    InstallInfo("");
    InstallInfo("  %s list", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     List network adapters Rawnic is bound to.");
    InstallInfo("");
    InstallInfo("  %s", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Run in console mode.");
    InstallInfo("");
}

//////////////////////////////////////////////////////////////////////////////
BOOL CLspService::IsServiceInstalled(LPCWSTR pszServiceName)
{
    BOOL fResult = FALSE;

    SC_HANDLE hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

    if( NULL != hSCM )
    {
        SC_HANDLE hService = ::OpenServiceW( hSCM, pszServiceName, SERVICE_QUERY_CONFIG );

        if( NULL != hService )
        {
            fResult = TRUE;
            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSCM );
    }

    return( fResult );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Install()
{
    DWORD dwRes = ERROR_SUCCESS;
    
    InstallInfo( "Configurator performing Install");

    do
    {
        //
        // the original SG-LSP's service name was LSPSG and the original MSI did 
        // not uinstall the service correctly. To prevent problems, delete the 
        // LSPSG service if it exists.
        //
        
        UninstallService(L"LSPSG");

        //
        // Optionally uninstall the service - is this necessary?
        //
        if( IsServiceInstalled(m_pszServiceName) )
        {
            InstallInfo( "Removing pre-existing service");

            dwRes = UninstallService(m_pszServiceName);

            if( ERROR_SUCCESS != dwRes )
            {
                break;
            }
        }

        //
        // Optionally install into the SCM
        //
        dwRes = InstallService();

        if( ERROR_SUCCESS != dwRes )
        {
            break;
        }
    }
    while( FALSE );

    return( dwRes );
}



//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Uninstall()
{
    DWORD dwRes = ERROR_SUCCESS;

    InstallInfo( "Configurator performing Uninstall");

    //
    // Remove the perfmon counters
    //
    UninstallCounters(m_pszServiceName);
    UninstallCounters(L"sgsvc");

    //
    // Remove the service from the SCM
    //
    if( IsServiceInstalled(m_pszServiceName) )
    {
        UninstallService(m_pszServiceName);
    }
    else
    {
        InstallInfo( "Service was not present and did not have to be removed");
    }

    return( dwRes );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::InstallCounters()
{
    DWORD dwRes = ERROR_SUCCESS;

    do
    {
        // Skip this step if the service doesn't have a counter dll
        if(NULL == m_pszPerfBaseName)
            break;
        
        if(0 == wcslen(m_pszPerfBaseName))
            break;
        
        InstallInfo( "Installing performance counters specified in %S", m_pszPerfBaseName);

        //
        // Construct name of perf DLL from this EXE's base name
        //
        WCHAR szPerfDLL[ MAX_PATH ];
        wcscpy(szPerfDLL, m_pszPerfBaseName);
        wcscat(szPerfDLL, L".dll");

        //
        // Get the perf DLL to register its entry points
        //
        HMODULE hmodPerf = LoadLibraryW( szPerfDLL );

        if( NULL == hmodPerf )
        {
            dwRes = GetLastError();
            break;
        }

        FARPROC DllRegServ = (FARPROC) GetProcAddress( hmodPerf, "DllRegisterServer" );

        if( NULL != DllRegServ )
        {
            DllRegServ();
        }

        FreeLibrary( hmodPerf );

    }
    while( FALSE );

    return( dwRes );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::UninstallCounters(LPCWSTR pszCounterServiceName)
{
    DWORD dwRes = ERROR_SUCCESS;


    do
    {
        // Skip this step if the service doesn't have a counter dll
        if(NULL == m_pszPerfBaseName)
            break;
        
        InstallInfo( "Removing performance counters from service '%S'", pszCounterServiceName);

        //
        // Use the same routine as unlodctr.exe to do the proper registry
        // grovelling necessary to remove our counters
        //
        WCHAR szCmdLine[ MAX_PATH ];
        wcscpy(szCmdLine, L"unlodctr.exe ");
        wcscat(szCmdLine, pszCounterServiceName);

        dwRes = UnloadPerfCounterTextStringsW( szCmdLine, TRUE );

        if( ERROR_BADKEY == dwRes || ERROR_FILE_NOT_FOUND == dwRes )
        {
            InstallInfo("No counters were found");
        }
        else if( ERROR_SUCCESS != dwRes )
        {
            InstallError( "Failed to unload performance counters strings (0x%08x)\n", dwRes );
            break;
        }
    }
    while( FALSE );

    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::InstallService()
{
    DWORD       dwRes = ERROR_SUCCESS;
    SC_HANDLE   hSCM      = NULL;
    SC_HANDLE   hService  = NULL;
    HANDLE      hToken    = NULL;
    LPCWSTR     pszSvcDependencies = L"RPCSS\0RAWNIC\0";

    do
    {
        InstallInfo( "Installing NT service");

        //
        // Anything to do?
        //
        if( IsServiceInstalled(m_pszServiceName) )
        {
            InstallInfo( "WARNING: Service is already installed!  Pre-existance check didn't work?");
            break;
        }

        //
        // Figure out where this .EXE lives
        //
        WCHAR szFileName[MAX_PATH + 1];
        GetModuleFileNameW(NULL, szFileName, MAX_PATH);
        szFileName[MAX_PATH] = L'\0';
 
        // If there was a service account specified, make sure that account is granted
        // rights to logon as a service
        if (m_pszInstallAccountName != NULL)
        {
            dwRes = GrantLogonRights(m_pszInstallAccountName);
            if ( ERROR_SUCCESS != dwRes )
            {
                if (dwRes == 0x80070534)
                    InstallError( "Failed granting SeLogonServiceRight to %S because account could not be resolved (0x%08x)\n", m_pszInstallAccountName, dwRes );
                else
                    InstallError( "Failed granting SeLogonServiceRight to %S (0x%08x)\n", m_pszInstallAccountName, dwRes );
                break;
            }
        }

        //
        // Contact the SCM and attempt to add a new service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        DWORD dwFlags = SERVICE_WIN32_OWN_PROCESS;

#if DBG
        // $REVIEW (michion):  Can't specify a service account and interactive process
        //                     at the same time
        if (m_pszInstallAccountName == NULL)
        {
            dwFlags |= SERVICE_INTERACTIVE_PROCESS;
        }

#endif

        hService = CreateServiceW(
            hSCM,
            m_pszServiceName,
            m_pszServiceDisplayName,
            SERVICE_ALL_ACCESS,
            dwFlags,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_NORMAL,
            szFileName,
            NULL,
            NULL,
            pszSvcDependencies,
            m_pszInstallAccountName,
            m_pszInstallAccountPassword ? m_pszInstallAccountPassword : NULL);

        if( NULL == hService )
        {
            // common errors:  1057 = ERROR_INVALID_SERVICE_ACCOUNT
            dwRes = GetLastError();
            InstallError( "Failed to create service %S (0x%08x)\n", m_pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service '%S' (%S) successfully created", m_pszServiceDisplayName, m_pszServiceName);

        //
        // Associate our descriptive string with the newly installed service
        //
        SERVICE_DESCRIPTIONW scDescription;
        scDescription.lpDescription = (LPWSTR) m_pszServiceDescription;

        if( !ChangeServiceConfig2(
                        hService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (void *) &scDescription ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed to change service description (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // Now, reconfigure the service retry configuration.  This turns out to
        // be a bit of a PITA because it requires the process token to have
        // the SE_SHUTDOWN_NAME privilege enabled which isn't (apparently)
        // present by default, even for machine/domain admins.
        //
        InstallInfo( "Setting service retry configuration");

        TOKEN_PRIVILEGES         tkPrivileges;
        SERVICE_FAILURE_ACTIONSW scFailureActions;
        SC_ACTION                rgActions[4];
    
        if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling OpenProcessToken (0x%08x)\n", dwRes );
            break;
        }
     
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkPrivileges.Privileges[0].Luid); 

        tkPrivileges.PrivilegeCount           = 1;
        tkPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
     
        if( !AdjustTokenPrivileges(hToken, FALSE, &tkPrivileges, 0, (PTOKEN_PRIVILEGES)NULL, 0) ||
            ERROR_SUCCESS != GetLastError() ) // Not all privileges were adjusted
        {
            dwRes = GetLastError();
            InstallError( "Failed calling AdjustTokenPrivileges (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // With that out of the way, we can set the restart configuration
        // (the privilege switch above is needed in order to set an
        // SC_ACTION_REBOOT Type entry)
        //
        rgActions[0].Type  = SC_ACTION_NONE;     // $REVIEW (michion): parameterize these into member vars
        rgActions[0].Delay = 5000;
        rgActions[1].Type  = SC_ACTION_NONE;
        rgActions[1].Delay = 5000;
        rgActions[2].Type  = SC_ACTION_NONE;
        rgActions[2].Delay = 5000;
        rgActions[3].Type  = SC_ACTION_NONE;
        rgActions[3].Delay = 5000;

        scFailureActions.dwResetPeriod = 1800;
        scFailureActions.lpRebootMsg   = L"";
        scFailureActions.lpCommand     = L"";
        scFailureActions.cActions      = sizeof(rgActions)/sizeof(rgActions[0]);
        scFailureActions.lpsaActions   = rgActions;

        if( !ChangeServiceConfig2(
                        hService,
                        SERVICE_CONFIG_FAILURE_ACTIONS,
                        (void *) &scFailureActions ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling ChangeServiceConfig2 (0x%08x)\n", dwRes );
            break;
        }

        dwRes = InstallCounters();

        if( ERROR_SUCCESS != dwRes )
        {
            InstallError( "Failed calling InstallCounters (0x%08x)\n", dwRes );
            break;
        }
    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hToken )
    {
        CloseHandle( hToken );
    }

    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }
    
    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::UninstallService(LPCWSTR pszServiceName)
{
    DWORD dwRes = ERROR_SUCCESS;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    BOOL      fOK = FALSE;

    do
    {
        InstallInfo( "Uninstalling NT service %S", pszServiceName);

        //
        // Anything to do?
        //
        if( !IsServiceInstalled(pszServiceName) )
        {
            InstallInfo( "Service is not installed. Nothing to do here.");
            break;
        }

        //
        // Contact the SCM and attempt to open the existing service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        hService = OpenServiceW( hSCM, pszServiceName, SERVICE_STOP | DELETE | SERVICE_QUERY_STATUS );

        if( NULL == hService )
        {
            dwRes = GetLastError();
            InstallError( "Failed retrieving service handle for %S (0x%08x)\n", pszServiceName, dwRes );
            break;
        }

        //
        // Stop and delete the service
        //
        SERVICE_STATUS status;

        fOK = ControlService( hService, SERVICE_CONTROL_STOP, &status );
        if (!fOK)
        {
            dwRes = GetLastError();

            if (dwRes != 0x00000426)   // if the service isn't running, we should get back 0x0426 (ERROR_SERVICE_NOT_ACTIVE)
            {
                InstallError( "Failed to stop service %S.  Service delete will probably fail as well (0x%08x)\n", pszServiceName, dwRes );
            }
            else
            {
                dwRes = 0;  // reset the exit code so that XMGMT doesn't think this was an actual error
            }
        }

        //
        // wait until the service has stopped
        //

        InstallInfo("Waiting for service to stop");
        
        for(;;)
        {
            SERVICE_STATUS_PROCESS serviceStatus;
            DWORD dwNeeded;
            BOOL ok;

            ok = QueryServiceStatusEx(hService, 
                                      SC_STATUS_PROCESS_INFO, 
                                      (BYTE*)&serviceStatus, 
                                      sizeof(serviceStatus), 
                                      &dwNeeded);

            if(!ok)
            {
                InstallError("QueryServiceStatusEx failed. Error = %u", GetLastError());
                break;
            }

            if(SERVICE_STOPPED == serviceStatus.dwCurrentState)
            {
                break;
            }

            InstallInfo("Service hasn't stopped yet. Current state=%u", serviceStatus.dwCurrentState);
            Sleep(1000);
        }

        if( !DeleteService( hService ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed deleting service %S (0x%08x)\n", pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service %S successfully stopped and deleted", pszServiceName);

    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }

    return( dwRes );
}

////////////////////////////////////////////////////////////////////////////
void CLspService::InstallError( char* pszFmt, ... )
{
    char szFmt[ 1024 ];
    va_list marker;

    va_start( marker, pszFmt );
    _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
    printf("InstallError: %s\n", szFmt);
    va_end( marker );

    return;
}


////////////////////////////////////////////////////////////////////////////
void CLspService::InstallInfo( char* pszFmt, ... )
{
    if (pszFmt == NULL)
    {
        printf("CLspService configurator intializing\n");
    }
    else
    {
        char szFmt[ 1024 ];
        va_list marker;

        va_start( marker, pszFmt );
        _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
        printf("   %s\n", szFmt);
        va_end( marker );
    }

    return;
}

////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ChangeState( DWORD dwState )
{
    m_Status.dwCheckPoint = (DWORD) -1; // will be inc. in Checkpoint()
    m_Status.dwCurrentState = dwState;

    return( Checkpoint() );
}


///////////////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Checkpoint( DWORD dwWaitHint /* = 0 */ )
{
    if( m_fRunningAsService )
    {
        m_Status.dwWaitHint = dwWaitHint;
        m_Status.dwCheckPoint++;
        
        if( !SetServiceStatus( m_hServiceStatus, &m_Status ) )
        {
            return( GetLastError() );
        }
    }

    return( ERROR_SUCCESS );
}


////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ReportError( DWORD dwErr )
{
    m_Status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    m_Status.dwServiceSpecificExitCode = dwErr;

    return( Checkpoint() );
}


//////////////////////////////////////////////////////////////////////////////
void CLspService::ServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    // CONSIDER: Move mgmt initialization here

    if( m_fRunningAsService )
    {
        m_hServiceStatus = RegisterServiceCtrlHandlerW(
                                            m_pszServiceName,
                                            StaticServiceControlHandler );

        if( NULL == m_hServiceStatus )
        {
            m_Status.dwWin32ExitCode = GetLastError();
            return;
        }
    }

    ChangeState( SERVICE_START_PENDING );

    m_Status.dwWin32ExitCode = S_OK;
    m_Status.dwCheckPoint = 0;
    m_Status.dwWaitHint = 0;

    HRESULT hr = S_OK;
    BOOL fServiceRan = FALSE;

    do
    {
        Checkpoint();

        hr = InitService( dwArgc, pszArgv );

        if( FAILED( hr ) )
        {
            break;
        }

        Checkpoint();

        ChangeState( SERVICE_RUNNING );

        hr = RunService( &fServiceRan );

        if( FAILED( hr ) )
        {
            break;
        }
    }
    while( FALSE );

    if ( FAILED( hr ) && !fServiceRan )
    {
        ChangeState( SERVICE_STOP_PENDING );
        ReportError( hr );
    }

    ChangeState( SERVICE_STOPPED );
}

//////////////////////////////////////////////////////////////////////////////
void CLspService::TermService()
{
    // wake up the RunService thread
    SetEvent( m_hevtShutdown );
}

//////////////////////////////////////////////////////////////////////////////
void CLspService::ServiceControlHandler( DWORD dwOpcode )
{
    if( SERVICE_CONTROL_STOP == dwOpcode )
    {
        // tell scm we're stopping
        ChangeState( SERVICE_STOP_PENDING );

        // wake up any sockets that are waiting to connect
//        g_SocketConnectWatchdog.Shutdown();

        TermService();
    }
    else
    {
        //
        // Unknown service control opcode?
        //
        OutputDebugStringA(CSmallStr().Format(
                           "ServiceControlHandler: unknown opcode %d", 
                           dwOpcode).cstr());
    }
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CLspService::StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    Assert( NULL != g_pService );
    g_pService->ServiceMain( dwArgc, pszArgv );
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CLspService::StaticServiceControlHandler( DWORD dwOpcode )
{
    Assert( NULL != g_pService );
    g_pService->ServiceControlHandler( dwOpcode );
}

//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CLspService::StaticConsoleCtrlHandler( DWORD dwCtrlType )
{
    Assert( NULL != g_pService );
    g_pService->ServiceControlHandler( SERVICE_CONTROL_STOP );
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::GrantLogonRights(LPCWSTR szAccount)
{
    DWORD       dwRes       = ERROR_SUCCESS;
    NTSTATUS    ntStatus    = 0;

    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    LSA_UNICODE_STRING      PrivilegeString;
    LSA_HANDLE              PolicyHandle = NULL;

    CSIDLookup              sidLookup;

    dwRes = sidLookup.Lookup(szAccount);
    if (FAILED(dwRes))
    {
        goto lCleanup;
    }
    //
    // It is very unfortunate that at this point dwRes holds a HRESULT
    // while this function returns a Win32 error by contract. The best
    // compromise is to have the function return a value that honors the
    // win32 success/failure semantics (0 -> success, failure otherwise),
    // but could potentially return hresults/ntstatus's as failure. This
    // ensures that returns such as S_FALSE are sanitized, but that doesn't
    // fix callers that use FAILED(dwRes). Those need to be fixed case by
    // case
    //
    dwRes = ERROR_SUCCESS;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    ntStatus = ::LsaOpenPolicy(
                    NULL,
                    &ObjectAttributes,
                    POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                    &PolicyHandle
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = ::LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }

    

    PrivilegeString.Buffer        = L"SeServiceLogonRight";
    PrivilegeString.Length        = (USHORT) wcslen(PrivilegeString.Buffer) * sizeof(WCHAR);
    PrivilegeString.MaximumLength = (USHORT)(wcslen(PrivilegeString.Buffer)+1) * sizeof(WCHAR);


    ntStatus = ::LsaAddAccountRights(
                    PolicyHandle,
                    sidLookup.GetPSID(),
                    &PrivilegeString,
                    1
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }


lCleanup:
    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
        PolicyHandle = NULL;
    }

    return( dwRes );
}

CSIDLookup::CSIDLookup()
{
    m_cbSID            = 0;
    m_cchRefDomainName = 0;
    m_pSID             = NULL;
    m_szRefDomainName  = NULL;
}


CSIDLookup::~CSIDLookup()
{
    if (m_pSID)
    {
        ::LocalFree(m_pSID);
        m_pSID = NULL;
    }

    if (m_szRefDomainName)
    {
        ::LocalFree(m_szRefDomainName);
        m_szRefDomainName = NULL;
    }
}


HRESULT CSIDLookup::Lookup(LPCWSTR szAccount)
{
    BOOL    fRet    = false;
    HRESULT hr      = S_OK;
    DWORD   dwRes   = ERROR_SUCCESS;
    SID     sidDummy;
    WCHAR   wstrDummy[2];

    // Get the required buffer sizes

    // N.B.: This is royally F*(&@#D up!  The MSDN docs claim that passing
    //       NULL for the PSID and ReferenceDomainName parameters will,
    //       in conjunction with passing pointers to zero'd out DWORDs for
    //       cbSid and cchReferenceDomainName, return the amount of
    //       space needed for these two buffers.  Total BS!  Unless the
    //       pointers are non-NULL, the function won't return anything in
    //       the cb/cch DWORDS except zero


    fRet = LookupAccountNameW(
            NULL,
            szAccount,
            &sidDummy,
            &m_cbSID,
            wstrDummy,
            &m_cchRefDomainName,
            &m_SIDNameUse
            );

    if (!fRet)
    {
        dwRes = ::GetLastError();
        if (dwRes == ERROR_INSUFFICIENT_BUFFER)
        {
            //-----------------------------------------------------------------
            // this is ok, we expected the function to complain about buffer
            // sizes being too small.  Just keep going now that we have the
            // actual buffer sizes we need in m_cbSID and m_cchRefDomainName
            //
            dwRes = ERROR_SUCCESS;
        }
        else
        {
            //-----------------------------------------------------------------
            // Gotta convert errors into HRESULTS (caller is checking FAILED()
            // which doesn't pick up on regular win32 errors
            //
            hr = HRESULT_FROM_WIN32(dwRes);
            goto lCleanup;
        }
    }
    
    
    m_szRefDomainName = (LPWSTR)::LocalAlloc(LPTR, m_cchRefDomainName * sizeof(TCHAR));
    if (m_szRefDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    m_pSID = (PSID)::LocalAlloc(LPTR, m_cbSID);
    if (m_pSID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    // Do the lookup for real now
    fRet = LookupAccountNameW(
             NULL,
             szAccount,
             m_pSID,
             &m_cbSID,
             m_szRefDomainName,
             &m_cchRefDomainName,
             &m_SIDNameUse
             );
    
    if (!fRet)
    {
        dwRes = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwRes);
        goto lCleanup;
    }
    

lCleanup:
    if (FAILED(hr))
    {
        if (m_pSID)
        {
            ::LocalFree(m_pSID);
            m_pSID = NULL;
        }
        
        if (m_szRefDomainName)
        {
            ::LocalFree(m_szRefDomainName);
            m_szRefDomainName = NULL;
        }
    }

    return hr;
}

PSID    CSIDLookup::GetPSID(void)
{
    return m_pSID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\guids.h ===
/******************************************************************************
 *
 *  Copyright 2000
 *  Broadcom Corporation
 *  16215 Alton Parkway
 *  PO Box 57013
 *  Irvine CA 92619-7013
 *
 *****************************************************************************/
/* 
 * Broadcom Corporation uBSec SDK 
 */
/*
 * guids.h:  uBSec WDM GUID definitions
 */
/*
 * Revision History:
 *
 * 02/29/00 DPA Created.
*/

#ifndef GUIDS_H
#define GUIDS_H

// {930D7841-E9F1-11d3-95C3-0010DC4050A5}
DEFINE_GUID(GUID_INTERFACE_WDM_UBSEC,0x930d7841, 0xe9f1, 0x11d3, 0x95, 0xc3, 0x0, 0x10, 0xdc, 0x40, 0x50, 0xa5);
// {9F685AE1-9065-11d4-95C5-0010DC4050A5}
DEFINE_GUID(GUID_INTERFACE_5820,0x9f685ae1, 0x9065, 0x11d4, 0x95, 0xc5, 0x0, 0x10, 0xdc, 0x40, 0x50, 0xa5);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\driver.h ===
/******************************************************************************
 *
 *  Copyright 2000
 *  Broadcom Corporation
 *  16215 Alton Parkway
 *  PO Box 57013
 *  Irvine CA 92619-7013
 *
 *****************************************************************************/
/* 
 * Broadcom Corporation uBSec SDK 
 */
/*
 * driver.h:  uBSec WDM driver definitions
 */
/*
 * Revision History:
 *
 * 02/29/00 DPA Created.
*/

#ifndef _WDMDRIVER_H_
#define _WDMDRIVER_H_
#ifdef __cplusplus
extern "C" {
#endif

#if BROADCOM_DID_NOT_SUCK_I_COULD_BE_HAPPY

#ifdef NT4
#include <ntddk.h>
#else
#include <wdm.h>
#include <wmistr.h>
#include <wmilib.h>
#endif
#include <stdio.h>

#endif


#define MAX_CRYPTO_MCRS 520
#define MAX_KEY_MCRS 64

enum  DEVICE_STATE {
	STOPPED,
	WORKING,
	QUERYREMOVE,
	SURPRISEREMOVED,
	REMOVED,
	FAILED
};

typedef struct _DEVICE_EXTENSION {
	PDEVICE_OBJECT DeviceObject;			// this device object
	PDEVICE_OBJECT LowerDeviceObject;		// next lower device object
	PDEVICE_OBJECT Pdo;						// physical device object
	UNICODE_STRING ifname;					// interface name
	UNICODE_STRING devlink;					// device name
	PKINTERRUPT InterruptObject;			// address of interrupt object
	ULONG ubsecDevice;						// this is the pointer to the device context from SRL
	KIRQL irql;								// for setting up interrupt
	ULONG vector;
	KAFFINITY affinity;
	PKSERVICE_ROUTINE onInterrupt;	
	KINTERRUPT_MODE mode;
	BOOLEAN irqshare;
	ULONG deviceType;						// type of ubsec device
	ULONG devInstance;						// instance of device
	ULONG devSlot;							// slot of device
	ULONG devBus;							// PCI bus of device
	ULONG devDevice;						// device number (on PCI bus)
	LONG  devString[8];						// device slot or bus/dev
	LONG  devFullString[14];				// like above, but includes 'BCM580x in '
	ULONG devSelfTestFailures;				// number of times self test has failed for device
	KEVENT event;							// device event (filled in in dummy device only)
	ULONG eventType;						// device event type (filled in in dummy device only)
#ifndef NT4
    WMILIB_CONTEXT WmiLib;
#endif
	ULONG revID;							// revID of ubsec device
	KIRQL	SRLirql;						// saved irql when raising irql in SRL
	KSPIN_LOCK SRLspinLock;					// spin lock to take when entering SRL
	ULONG	io_nbytes;						// size of io mapped region
	PDEVICE_OBJECT activeDevice;			// for multiple devices, indicates next one to receive request
	PDEVICE_OBJECT dummyDevice;				// points to dummy device use for load balancing
	LONG ADDeviceStatus;					// status for alternate device
	enum DEVICE_STATE devState;				// device state
	enum DEVICE_STATE devStatePrev;			// device state
	BOOLEAN bInterfaceCreated;				// indicates a device interface has been created
	} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

VOID DriverUnload(PDRIVER_OBJECT pDrvObj);
NTSTATUS AddDevice(PDRIVER_OBJECT DriverObject,PDEVICE_OBJECT pDevObj);
NTSTATUS StartDevice(PDEVICE_OBJECT pDevObj, PCM_PARTIAL_RESOURCE_LIST raw, PCM_PARTIAL_RESOURCE_LIST translated);
NTSTATUS FindPCIDeviceInfo(PDRIVER_OBJECT pDrvObj, PUNICODE_STRING pRegistryPath);
VOID StopDevice(PDEVICE_OBJECT pDevObj);
NTSTATUS RemoveDevice(PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt);
VOID DpcForIsr(PKDPC Dpc, PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt, PDEVICE_EXTENSION pDevExt);
NTSTATUS DispatchCreate(PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt);
NTSTATUS DispatchClose(PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt);
NTSTATUS DispatchControl(PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt);
NTSTATUS DispatchInternalControl(PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt);
NTSTATUS DispatchPower(PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt);
NTSTATUS DispatchPnp(PDEVICE_OBJECT pDevObj, PIRP pIOReqPkt);
#ifndef NT4
NTSTATUS MofSystemControl(PDEVICE_OBJECT DeviceObject,PIRP Irp);
NTSTATUS MofInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);
#endif
NTSTATUS FireWMICryptoNETEvent(PDEVICE_OBJECT pDevObj,ULONG event);

void LogEvent(NTSTATUS errorCode, PDEVICE_OBJECT pDevObj, PWSTR pString, char *pData, UCHAR szData );
void CryptonetEvent(PDEVICE_EXTENSION pDevExt,ULONG event);
#ifdef __cplusplus
	}
#endif

#endif /*_WDMDRIVER_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ioctls_int.h ===
/******************************************************************************
 *
 *  Copyright 2000
 *  Broadcom Corporation
 *  16215 Alton Parkway
 *  PO Box 57013
 *  Irvine CA 92619-7013
 *
 *****************************************************************************/
/* 
 * Broadcom Corporation uBSec SDK 
 */
/*
 * ioctls_int.h:  uBSec WDM internal ioctl definitions
 */
/*
 * Revision History:
 *
 * 03/28/00 DPA Created.
*/

#ifndef IOCTLS_INT_H
#define IOCTLS_INT_H

#define UBSEC_OFFLOAD CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define UBSEC_OFFLOAD_GETFUNC CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)

// output structure for crypto function and ubsec device context
typedef struct _cryptofunc
{
	ubsec_Status_t (*CipherFunc)(ubsec_DeviceContext_t Context,ubsec_CipherCommandInfo_pt command,int *NumCommands);
	ubsec_DeviceContext_t ubsecContext;
} CRYPTOFUNC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\tcrypto.cpp ===
// ---------------------------------------------------------------------------------------
// tcrypto.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------


// ---------------------------------------------------------------------------------------
// To Do List
//
// @@@ Test SHA
// @@@ Test concurrent SHA+3DES
// @@@ Test DH
// @@@ Performance tests
// ---------------------------------------------------------------------------------------

#include "tcryptop.h"

#include <initguid.h>
#include <guids.h>

//#define USE_IOCTL

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void            DriverUnload(PDRIVER_OBJECT pDriverObject);

extern "C"
{
    NTSTATUS        DeviceControl(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceNoop(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceUnsupported(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        PnPDriverNotification(PVOID pNotificationStructure,PVOID pContext);
    NTSTATUS        IRPCompletionGetFunc(PDEVICE_OBJECT pDevObj, PIRP pIrp, PVOID pContext);
    NTSTATUS        RestartTest3DESIoctl(PDEVICE_OBJECT pDevObj, PIRP pIrp, PVOID pContext);
}

void RunTests();

// ---------------------------------------------------------------------------------------
// Macros
// ---------------------------------------------------------------------------------------

#define dimensionof(a)      (sizeof(a)/sizeof(*(a)))

// ---------------------------------------------------------------------------------------
// CMemoryDescriptor
// ---------------------------------------------------------------------------------------

struct CMemoryDescriptor
{
    ubsec_FragmentInfo_t    _fragInfo[2];
    ULONG                   _cFrag;

    BYTE *                  _pVA;
    BOOLEAN                 _bFlipped;

    void                    Init(BYTE * pb, ULONG cb);
    void                    Print();
};


// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------


PVOID                       g_pPnPNotificationEntry;
PDEVICE_OBJECT              g_pBroadcomDeviceObject;

CRYPTOFUNC                  g_CryptoFunctionInfo;

// ---------------------------------------------------------------------------------------
// Crypto Constants
// ---------------------------------------------------------------------------------------

#define CBDHG1 96

extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
    0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
    0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
    0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
    0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
    0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
    0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
    0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
    0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
    0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

// ---------------------------------------------------------------------------------------
// DriverEntry
// ---------------------------------------------------------------------------------------

EXTERN_C
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    DbgPrint("tcrypto!DriverEntry\n");

    //
    // Initialize the driver object with this driver's entrypoints.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = &DeviceNoop;
    DriverObject->DriverUnload = &DriverUnload;

    //
    // Ask for notification of the crypto card's driver coming up.
    //

    NTSTATUS Status;

    Status = IoRegisterPlugPlayNotification(
                    EventCategoryDeviceInterfaceChange,
                    PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                    (PVOID)&GUID_INTERFACE_5820,
                    DriverObject,
                    PnPDriverNotification,
                    NULL,
                    &g_pPnPNotificationEntry
                    );

    if (!NT_SUCCESS(Status))
    {
        DbgPrint("Couldn't find offload card. Error %x\n", Status);
    }

    return STATUS_SUCCESS;
}

void
DriverUnload(
    PDRIVER_OBJECT pDriverObject
    )
{
    DbgPrint("tcrypto!DriverUnload\n");

    IoUnregisterPlugPlayNotification(g_pPnPNotificationEntry);

    if (g_pBroadcomDeviceObject)
    {
        ObDereferenceObject(g_pBroadcomDeviceObject);
        g_pBroadcomDeviceObject = NULL;
    }
}

NTSTATUS
DeviceNoop(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
{ return STATUS_SUCCESS; }


NTSTATUS        
PnPDriverNotification(
    PVOID pNotificationStructure,
    PVOID pContext
    )
{
    // this is the callback for notifying us when the broadcom driver is registered
    NTSTATUS status;
    DEVICE_INTERFACE_CHANGE_NOTIFICATION *pDevNotify = (DEVICE_INTERFACE_CHANGE_NOTIFICATION *)pNotificationStructure;
    PFILE_OBJECT pFileObject;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    // get device object pointer for ubsec WDM driver
    status = IoGetDeviceObjectPointer(
                    pDevNotify->SymbolicLinkName,
                    FILE_ALL_ACCESS,
                    &pFileObject,
                    &g_pBroadcomDeviceObject
                    );

    
    if (NT_SUCCESS(status))
    {
        DbgPrint("tcrypto!PnPDriverNotification got broadcom device object: %p\n", g_pBroadcomDeviceObject);
        
        ObReferenceObject(g_pBroadcomDeviceObject);
        ObDereferenceObject(pFileObject);

        //
        // Get the broadcom drivers entry point.
        //
        
        // allocate and initialize Irp
        pIrp = IoAllocateIrp(g_pBroadcomDeviceObject->StackSize, FALSE);

        if (pIrp)
        {
            pIrpSp = IoGetNextIrpStackLocation(pIrp);
            pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            pIrpSp->Parameters.DeviceIoControl.IoControlCode = UBSEC_OFFLOAD_GETFUNC;
            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = &g_CryptoFunctionInfo;
            pIrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(g_CryptoFunctionInfo);
            IoSetCompletionRoutine(pIrp, IRPCompletionGetFunc, NULL, TRUE, TRUE, TRUE);
            IoCallDriver(g_pBroadcomDeviceObject, pIrp);
        }
        else
        {
            DbgPrint("tcrypto!PnPDriverNotification IoAllocateIrp(%d) failed.\n",
                     g_pBroadcomDeviceObject->StackSize);
        }
    }
    else
    {
        DbgPrint("tcrypto!PnPDriverNotification IoGetDeviceObjectPointer(%ws) failed: %x\n",
                 pDevNotify->SymbolicLinkName->Buffer, status);
    }

    return STATUS_SUCCESS;
}


NTSTATUS 
IRPCompletionGetFunc(PDEVICE_OBJECT pDevObj, PIRP pIrp, PVOID pContext)
{
    DbgPrint("tcrypto!IRPCompletionGetFunc, crypto routine = %p, ctx = %p\n",
             g_CryptoFunctionInfo.CipherFunc, g_CryptoFunctionInfo.ubsecContext);


    RunTests();
    
    IoFreeIrp(pIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

// ---------------------------------------------------------------------------------------
// 3DES
// ---------------------------------------------------------------------------------------

void XcKeyTable(IN ULONG dwCipher, OUT PUCHAR pbKeyTable, IN PUCHAR pbKey)
{
    if (dwCipher == XC_SERVICE_DES_CIPHER)
    {
        deskey((DESTable*)pbKeyTable, pbKey);
    }
    else
    {
        // Assume XC_SERVICE_DES3_CIPHER:
        tripledes3key((PDES3TABLE)pbKeyTable, pbKey);
    }
}

void XcBlockCryptCBC(IN ULONG dwCipher, IN ULONG dwInputLength, IN PUCHAR pbOutput, IN PUCHAR pbInput,
                     IN PUCHAR pbKeyTable, IN ULONG dwOp, IN PUCHAR pbFeedback)
{
    BYTE *pbInputEnd = pbInput + dwInputLength;
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = (dwCipher == XC_SERVICE_DES_CIPHER) ? des : tripledes;
    while (pbInput < pbInputEnd)
    {
        CBC(pCipher, XC_SERVICE_DES_BLOCKLEN, pbOutput, pbInput, pbKeyTable, dwOp, pbFeedback);
        pbInput += XC_SERVICE_DES_BLOCKLEN;
        pbOutput += XC_SERVICE_DES_BLOCKLEN;
    }
}

void XcCryptDes(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2)
{
    ASSERT(cbKey == XC_SERVICE_DES_KEYSIZE || cbKey == XC_SERVICE_DES3_KEYSIZE);
    BYTE abDesTable[XC_SERVICE_DES3_TABLESIZE];
    BYTE abFeedback[XC_SERVICE_DES_BLOCKLEN];
    UINT uiCipher = (cbKey == XC_SERVICE_DES_KEYSIZE) ? XC_SERVICE_DES_CIPHER : XC_SERVICE_DES3_CIPHER;

    XcKeyTable(uiCipher, abDesTable, pbKey);
    memcpy(abFeedback, pbIv, XC_SERVICE_DES_BLOCKLEN);

    if (cb1 > 0)
    {
        ASSERT(pb1 != NULL && (cb1 % XC_SERVICE_DES_BLOCKLEN) == 0);
        XcBlockCryptCBC(uiCipher, cb1, pb1, pb1, abDesTable, dwOp, abFeedback);
    }

    if (cb2 > 0)
    {
        ASSERT(pb2 != NULL && (cb2 % XC_SERVICE_DES_BLOCKLEN) == 0);
        XcBlockCryptCBC(uiCipher, cb2, pb2, pb2, abDesTable, dwOp, abFeedback);
    }
}

// ---------------------------------------------------------------------------------------
// HMAC
// ---------------------------------------------------------------------------------------

void XcHMAC3(BYTE * pbKeyMaterial, UINT cbKeyMaterial, BYTE * pbData, UINT cbData,
             BYTE * pbData2, UINT cbData2, BYTE * pbData3, UINT cbData3, BYTE * HmacData)
{
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }
    if (cbData3 != 0)
    {
        A_SHAUpdate(&shaHash, pbData3, cbData3);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

// ---------------------------------------------------------------------------------------
// ModExp
// compute A = B ^ C mod D, N = len of params in DWORDs
// ---------------------------------------------------------------------------------------

ULONG XcModExp(IN LPDWORD pA, IN LPDWORD pB, IN LPDWORD pC, IN LPDWORD pD, IN ULONG dwN)
{
    return BenalohModExp(pA, pB, pC, pD, dwN);
}

// ---------------------------------------------------------------------------------------
// RSA library support
// ---------------------------------------------------------------------------------------

#define PTAG_RSA                'SRcT'

EXTERN_C 
void*
__stdcall
RSA32Alloc( unsigned long cb )
{
    PVOID pv;
    
    pv = ExAllocatePoolWithTag(
                NonPagedPool,
                cb,
                PTAG_RSA
                );

    return pv;
}


EXTERN_C 
void
__stdcall
RSA32Free( void *pv )
{
    if (pv) ExFreePool(pv);
}


BYTE                        g_abCipherText[8192];
ubsec_CryptKey_t            g_keys[3];
BYTE                        g_abIV[8];
BYTE                        g_abIV2[8];

KEVENT                      g_evtCompletion;
ubsec_Status_t              g_ubStatus;
ubsec_CipherCommandInfo_t   g_HardwareCommand;
INT                         g_cHardwareCommand = 1;

ubsec_FragmentInfo_t        g_aFragments[4];

ubsec_HMAC_State_t          g_HmacState;
BYTE                        g_abAuthInfo[4096];

void RestartHardwareCrypt(unsigned long Context, ubsec_Status_t Result)
{
    /*
    if (Result)
        DbgPrint("RestartHardwareCryptDes(ctx = %d, status = %d)\n", Context, Result);
    else
        DbgPrint("ctx %d ", Context);
        */

    g_ubStatus = Result;
    KeSetEvent(&g_evtCompletion, IO_NETWORK_INCREMENT, FALSE);
}

ubsec_Status_t SynchronousCipherCommand(ubsec_CipherCommandInfo_pt pCmd)
{
    pCmd->CommandContext = 0;
    pCmd->CompletionCallback = RestartHardwareCrypt;

//    DbgPrint("(%p %d) (%p %d)   ", pb1, cb1, pb2, cb2);
/*
    for (ULONG i = 0; i < pCmd->NumSource; i++)
    {
        DbgPrint("(%p %d) ", pCmd->SourceFragments[i].FragmentAddress, pCmd->SourceFragments[i].FragmentLength);
    }
    DbgPrint("\n");

    for (ULONG i = 0; i < pCmd->NumDestination; i++)
    {
        DbgPrint("(%p %d) ", pCmd->DestinationFragments[i].FragmentAddress, pCmd->DestinationFragments[i].FragmentLength);
    }
    DbgPrint("\n");
*/
    ubsec_Status_t Status;

    Status = g_CryptoFunctionInfo.CipherFunc(g_CryptoFunctionInfo.ubsecContext, pCmd, &g_cHardwareCommand);

    KeWaitForSingleObject(
        &g_evtCompletion,
        Executive,
        KernelMode,
        TRUE,
        NULL);

    KeResetEvent(&g_evtCompletion);

    return (g_ubStatus);
}

ubsec_Status_t SynchronousMathCommand(ubsec_MathCommandInfo_pt pCmd)
{
    pCmd->CommandContext = 0;
    pCmd->CompletionCallback = RestartHardwareCrypt;

    ubsec_Status_t Status;

    Status = ubsec_MathCommand(g_CryptoFunctionInfo.ubsecContext, pCmd, &g_cHardwareCommand);

    KeWaitForSingleObject(
        &g_evtCompletion,
        Executive,
        KernelMode,
        TRUE,
        NULL);

    KeResetEvent(&g_evtCompletion);

    return (g_ubStatus);
}

#if I_FIND_THE_SSL_ENTRY_POINT_SOME_DAY

ubsec_Status_t SynchronousSSLCommand(ubsec_SSLCommandInfo_pt pCmd)
{
    pCmd->CommandContext = 0;
    pCmd->CompletionCallback = RestartHardwareCrypt;

    ubsec_Status_t Status;

    Status = ubsec_SSLCommand(g_CryptoFunctionInfo.ubsecContext, pCmd, &g_cHardwareCommand);

    KeWaitForSingleObject(
        &g_evtCompletion,
        Executive,
        KernelMode,
        TRUE,
        NULL);

    KeResetEvent(&g_evtCompletion);

    return (g_ubStatus);
}

#endif

LONG g_cAsyncIterationIndex;


void RestartAsyncHardwareCrypt(unsigned long Context, ubsec_Status_t Result)
{
    LONG cIterationIndex = InterlockedDecrement(&g_cAsyncIterationIndex);
    g_ubStatus = Result;

    if (!cIterationIndex)
    {
        KeSetEvent(&g_evtCompletion, IO_NETWORK_INCREMENT, FALSE);
    }
    else
    {
        ubsec_CipherCommandInfo_pt pCmd = (ubsec_CipherCommandInfo_pt) Context;
        g_CryptoFunctionInfo.CipherFunc(g_CryptoFunctionInfo.ubsecContext, pCmd, &g_cHardwareCommand);
    }
}

ubsec_Status_t AsynchronousCipherCommand(ubsec_CipherCommandInfo_pt pCmd, ULONG i, ULONG cParallel)
{
    pCmd->CommandContext = (ULONG)pCmd;
    pCmd->CompletionCallback = RestartAsyncHardwareCrypt;

    ubsec_Status_t Status;

    g_cAsyncIterationIndex = i;

    ULONG j;
    for (j = 0; j < cParallel; j++)
    {
        Status = g_CryptoFunctionInfo.CipherFunc(g_CryptoFunctionInfo.ubsecContext, pCmd, &g_cHardwareCommand);
    }

    KeWaitForSingleObject(
        &g_evtCompletion,
        Executive,
        KernelMode,
        TRUE,
        NULL);

    KeResetEvent(&g_evtCompletion);

    return g_ubStatus;
}



BOOLEAN HardwareCryptSha(BYTE * pbKey, UINT cbKey, BYTE * pb, UINT cb, BYTE * pbHmacData)
{
    ubsec_CipherCommandInfo_pt pCmd;
    ULONG BytesToEncrypt;

    ASSERT(cb && pb);
    ASSERT(cbKey == 20);

    //
    // Set up auth info buffer.
    //

    CMemoryDescriptor md3;
    md3.Init(pbHmacData, 20);

    //
    // Set up key buffer
    //

    char achKey[UBSEC_MAC_KEY_LENGTH];
    memset(achKey, 0, sizeof(achKey));
    memcpy(achKey, pbKey, min(cbKey, sizeof(achKey)));
    ubsec_InitHMACState(&g_HmacState, UBSEC_MAC_SHA1, (ubsec_HMAC_Key_pt)achKey);

    //
    // Figure out how many fragments we have
    //

    ULONG cFrag = COMPUTE_PAGES_SPANNED(pb, cb);

    ASSERT(cFrag < 3);

    //
    // Set up command going to the card.
    //

    RtlZeroMemory(&g_HardwareCommand, sizeof(g_HardwareCommand));
    pCmd = &g_HardwareCommand;

    pCmd->Command = UBSEC_MAC_SHA1 | UBSEC_DECODE;

    pCmd->CryptHeaderSkip = 0;
    
    pCmd->NumSource = cFrag;
    pCmd->SourceFragments = (ubsec_FragmentInfo_pt) &g_aFragments;

    ubsec_FragmentInfo_pt pFrag = pCmd->SourceFragments;

    pFrag->FragmentAddress = (ULONG) pb;

    if (cFrag == 1)
    {
        pFrag->FragmentLength = cb;
    }
    else
    {
        pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb) + PAGE_SIZE - pb;

        pFrag++;

        pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb + cb - 1);
        pFrag->FragmentLength = pb + cb - (BYTE *) PAGE_ALIGN(pb + cb - 1);
    }

    pFrag++;

    pCmd->CryptKey = (ubsec_CryptKey_pt)g_keys;

    pCmd->NumDestination = pCmd->NumSource;
    pCmd->DestinationFragments = pCmd->SourceFragments;

    pCmd->HMACState = &g_HmacState;
    
    pCmd->AuthenticationInfo.FragmentLength = md3._fragInfo[0].FragmentLength;
    pCmd->AuthenticationInfo.FragmentAddress = md3._fragInfo[0].FragmentAddress;

//    DbgBreakPoint();
    return (SynchronousCipherCommand(pCmd) == UBSEC_STATUS_SUCCESS);
}


BOOLEAN HardwareCryptDes(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2)
{
    ubsec_CipherCommandInfo_pt pCmd;
    ULONG BytesToEncrypt;

    ASSERT(cb1 && pb1);
    ASSERT(cbKey == 24);

    //
    // Set up auth info buffer.
    //

    CMemoryDescriptor md3;
    md3.Init((BYTE *)&g_abAuthInfo, sizeof(g_abAuthInfo));

    //
    // Figure out how many fragments we have
    //

    ULONG cFrag1 = COMPUTE_PAGES_SPANNED(pb1, cb1);
    ULONG cFrag2 = COMPUTE_PAGES_SPANNED(pb2, cb2);

    ASSERT(cFrag1 < 3);
    ASSERT(cFrag2 < 3);

    //
    // Set up command going to the card.
    //

    RtlZeroMemory(&g_HardwareCommand, sizeof(g_HardwareCommand));
    pCmd = &g_HardwareCommand;

    pCmd->Command = dwOp == XC_SERVICE_ENCRYPT ? UBSEC_ENCODE_3DES : UBSEC_DECODE_3DES;
    pCmd->InitialVector = (ubsec_IV_pt)pbIv;

    pCmd->CryptHeaderSkip = 0;
    
    pCmd->NumSource = cFrag1 + cFrag2;
    pCmd->SourceFragments = (ubsec_FragmentInfo_pt) &g_aFragments;

    ubsec_FragmentInfo_pt pFrag = pCmd->SourceFragments;

    pFrag->FragmentAddress = (ULONG) pb1;

    if (cFrag1 == 1)
    {
        pFrag->FragmentLength = cb1;
    }
    else
    {
        pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb1) + PAGE_SIZE - pb1;

        pFrag++;

        pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb1 + cb1 - 1);
        pFrag->FragmentLength = pb1 + cb1 - (BYTE *) PAGE_ALIGN(pb1 + cb1 - 1);
    }

    pFrag++;

    if (cb2)
    {
        pFrag->FragmentAddress = (ULONG) pb2;

        if (cFrag2 == 1)
        {
            pFrag->FragmentLength = cb2;
        }
        else
        {
            pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb2) + PAGE_SIZE - pb2;

            pFrag++;
            
            pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb2 + cb2 - 1);
            pFrag->FragmentLength = pb2 + cb2 - (BYTE *) PAGE_ALIGN(pb1 + cb1 - 1);
        }
    }

    pCmd->CryptKey = (ubsec_CryptKey_pt)g_keys;

    pCmd->NumDestination = pCmd->NumSource;
    pCmd->DestinationFragments = pCmd->SourceFragments;
    
    pCmd->AuthenticationInfo.FragmentLength = md3._fragInfo[0].FragmentLength;
    pCmd->AuthenticationInfo.FragmentAddress = md3._fragInfo[0].FragmentAddress;

    return (SynchronousCipherCommand(pCmd) == UBSEC_STATUS_SUCCESS);
}

BOOLEAN HardwareCryptDesSha(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2,
                            BYTE * pbShaKey, UINT cbShaKey, BYTE * pbHmacData, UINT cbOffset, UINT cbShift)
{
    ubsec_CipherCommandInfo_pt pCmd;
    ULONG BytesToEncrypt;

    ASSERT(cb1 && pb1);
    ASSERT(cbKey == 24);

    //
    // Set up auth info buffer.
    //

    CMemoryDescriptor md3;
    md3.Init(pbHmacData, 20);

    //
    // Set up SHA key buffer
    //

    char achKey[UBSEC_MAC_KEY_LENGTH];
    memset(achKey, 0, sizeof(achKey));
    memcpy(achKey, pbShaKey, min(cbShaKey, sizeof(achKey)));
    ubsec_InitHMACState(&g_HmacState, UBSEC_MAC_SHA1, (ubsec_HMAC_Key_pt)achKey);
    
    //
    // Figure out how many fragments we have
    //

    ULONG cFrag1 = COMPUTE_PAGES_SPANNED(pb1, cb1);
    ULONG cFrag2 = COMPUTE_PAGES_SPANNED(pb2, cb2);

    ASSERT(cFrag1 < 3);
    ASSERT(cFrag2 < 3);

    ULONG cFragDst1 = COMPUTE_PAGES_SPANNED(pb1 + cbShift, cb1);
    ULONG cFragDst2 = COMPUTE_PAGES_SPANNED(pb2, cb2);

    ASSERT(cFragDst1 < 3);
    ASSERT(cFragDst2 < 3);

    //
    // Set up command going to the card.
    //

    RtlZeroMemory(&g_HardwareCommand, sizeof(g_HardwareCommand));
    pCmd = &g_HardwareCommand;

    pCmd->Command = (dwOp == XC_SERVICE_ENCRYPT ? UBSEC_ENCODE_3DES : UBSEC_DECODE_3DES) | UBSEC_MAC_SHA1;
    pCmd->InitialVector = (ubsec_IV_pt)pbIv;

    pCmd->CryptHeaderSkip = cbOffset;

    // source fragments 
    
    pCmd->NumSource = cFrag1 + cFrag2;
    pCmd->SourceFragments = (ubsec_FragmentInfo_pt) &g_aFragments;

    ubsec_FragmentInfo_pt pFrag = pCmd->SourceFragments;

    pFrag->FragmentAddress = (ULONG) pb1;

    if (cFrag1 == 1)
    {
        pFrag->FragmentLength = cb1;
    }
    else
    {
        pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb1) + PAGE_SIZE - pb1;

        pFrag++;

        pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb1 + cb1 - 1);
        pFrag->FragmentLength = pb1 + cb1 - (BYTE *) PAGE_ALIGN(pb1 + cb1 - 1);
    }

    pFrag++;

    if (cb2)
    {
        pFrag->FragmentAddress = (ULONG) pb2;

        if (cFrag2 == 1)
        {
            pFrag->FragmentLength = cb2;
        }
        else
        {
            pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb2) + PAGE_SIZE - pb2;

            pFrag++;
            
            pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb2 + cb2 - 1);
            pFrag->FragmentLength = pb2 + cb2 - (BYTE *) PAGE_ALIGN(pb1 + cb1 - 1);
        }
    }

    // destination fragments

    pCmd->NumDestination = cFragDst1 + cFragDst2;
    pCmd->DestinationFragments = pFrag;

    pb1 += cbShift;

    pFrag->FragmentAddress = (ULONG) pb1;

    if (cFrag1 == 1)
    {
        pFrag->FragmentLength = cb1;
    }
    else
    {
        pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb1) + PAGE_SIZE - pb1;

        pFrag++;

        pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb1 + cb1 - 1);
        pFrag->FragmentLength = pb1 + cb1 - (BYTE *) PAGE_ALIGN(pb1 + cb1 - 1);
    }

    pFrag++;

    if (cb2)
    {
        pFrag->FragmentAddress = (ULONG) pb2;

        if (cFrag2 == 1)
        {
            pFrag->FragmentLength = cb2;
        }
        else
        {
            pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb2) + PAGE_SIZE - pb2;

            pFrag++;
            
            pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb2 + cb2 - 1);
            pFrag->FragmentLength = pb2 + cb2 - (BYTE *) PAGE_ALIGN(pb1 + cb1 - 1);
        }
    }

    pCmd->CryptKey = (ubsec_CryptKey_pt)g_keys;
    
    pCmd->HMACState = &g_HmacState;
    
    pCmd->AuthenticationInfo.FragmentLength = md3._fragInfo[0].FragmentLength;
    pCmd->AuthenticationInfo.FragmentAddress = md3._fragInfo[0].FragmentAddress;

    return (SynchronousCipherCommand(pCmd) == UBSEC_STATUS_SUCCESS);
}

BOOLEAN HardwareModExp(BYTE * pbResult, BYTE * pbBase, BYTE * pbExp, BYTE * pbMod, DWORD cb)
{
    ubsec_MathCommandInfo_t Cmd;

    memset(&Cmd, 0, sizeof(Cmd));
    Cmd.Command = UBSEC_MATH_MODEXP;

    Cmd.Parameters.Result.KeyLength = cb * 8;
    Cmd.Parameters.Result.KeyValue = pbResult;

    Cmd.Parameters.ParamA.KeyLength = cb * 8;
    Cmd.Parameters.ParamA.KeyValue = pbBase;

    Cmd.Parameters.ParamB.KeyLength = cb * 8;
    Cmd.Parameters.ParamB.KeyValue = pbExp;

    Cmd.Parameters.ModN.KeyLength = cb * 8;
    Cmd.Parameters.ModN.KeyValue = pbMod;
    
    return (SynchronousMathCommand(&Cmd) == UBSEC_STATUS_SUCCESS);
}


BOOLEAN TestHardwareCrypt(BYTE * pbPhysical, BYTE * pbVirtual, ULONG cb)
{
//    DbgPrint("%p %p %d ", pbPhysical, pbVirtual, cb);
    
    memset(pbVirtual, 'M', cb);

    if (!HardwareCryptDes(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                          pbPhysical, cb, NULL, 0))
    {
        DbgPrint("[FAIL] HardwareCryptDes(ENCRYPT) returned an error.\n");
        return FALSE;
    }

    ULONG cbEqual = RtlCompareMemory(pbVirtual, g_abCipherText, cb);

    if (cbEqual != cb)
    {
        DbgPrint("[FAIL] Ciphertext did not match software ciphertext (location %d)\n", cbEqual);

        DbgPrint("Software: ");
        for (ULONG i = cbEqual; i < cb && i < (cbEqual + 8); i++)
            DbgPrint("%x ", g_abCipherText[i]);

        DbgPrint("\n");

        DbgPrint("Hardware: ");
        for (ULONG i = cbEqual; i < cb && i < (cbEqual + 8); i++)
            DbgPrint("%x ", pbVirtual[i]);

        DbgPrint("\n");
        
        return FALSE;
    }

    if (!HardwareCryptDes(XC_SERVICE_DECRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                          pbPhysical, cb, NULL, 0))
    {
        DbgPrint("[FAIL] HardwareCryptDes(ENCRYPT) returned an error.\n");
        return FALSE;
    }

    for (ULONG i = 0; i < cb; i++)
    {
        if (pbVirtual[i] != 'M')
        {
            DbgPrint("[FAIL] Cleartext did not match original buffer\n");
            return FALSE;
        }
    }

//    DbgPrint("[OK]\n");

    return TRUE;
}

BOOLEAN TestHardwareCrypt2(BYTE * pbP1, BYTE * pbV1, ULONG cb1, BYTE * pbP2, BYTE * pbV2, ULONG cb2)
{
//    DbgPrint("%p %p %d ", pbPhysical, pbVirtual, cb);
    
    memset(pbV1, 'M', cb1);
    memset(pbV2, 'M', cb2);

    if (!HardwareCryptDes(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                          pbP1, cb1, pbP2, cb2))
    {
        DbgPrint("[FAIL] HardwareCryptDes(ENCRYPT) returned an error.\n");
        return FALSE;
    }

    ULONG cbEqual = RtlCompareMemory(pbV1, g_abCipherText, cb1);

    if (cbEqual != cb1)
    {
        DbgPrint("[FAIL] Ciphertext1 did not match software ciphertext (location %d)\n", cbEqual);

        DbgPrint("Software: ");
        for (ULONG i = cbEqual; i < cb1 && i < (cbEqual + 8); i++)
            DbgPrint("%x ", g_abCipherText[i]);

        DbgPrint("\n");

        DbgPrint("Hardware: ");
        for (ULONG i = cbEqual; i < cb1 && i < (cbEqual + 8); i++)
            DbgPrint("%x ", pbV1[i]);

        DbgPrint("\n");
        
        return FALSE;
    }

    cbEqual = RtlCompareMemory(pbV2, g_abCipherText + cb1, cb2);

    if (cbEqual != cb2)
    {
        DbgPrint("[FAIL] Ciphertext2 did not match software ciphertext (location %d)\n", cbEqual);

        DbgPrint("Software: ");
        for (ULONG i = cbEqual; i < cb2 && i < (cbEqual + 8); i++)
            DbgPrint("%x ", g_abCipherText[i]);

        DbgPrint("\n");

        DbgPrint("Hardware: ");
        for (ULONG i = cbEqual; i < cb2 && i < (cbEqual + 8); i++)
            DbgPrint("%x ", pbV1[i]);

        DbgPrint("\n");
        
        return FALSE;
    }

    if (!HardwareCryptDes(XC_SERVICE_DECRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                          pbP1, cb1, pbP2, cb2))
    {
        DbgPrint("[FAIL] HardwareCryptDes(ENCRYPT) returned an error.\n");
        return FALSE;
    }

    for (ULONG i = 0; i < cb1; i++)
    {
        if (pbV1[i] != 'M')
        {
            DbgPrint("[FAIL] Cleartext1 did not match original buffer\n");
            return FALSE;
        }
    }

    for (ULONG i = 0; i < cb2; i++)
    {
        if (pbV2[i] != 'M')
        {
            DbgPrint("[FAIL] Cleartext2 did not match original buffer\n");
            return FALSE;
        }
    }

//    DbgPrint("[OK]\n");

    return TRUE;
}

BOOLEAN TestHardwareCryptSha(BYTE * pbKey, UINT cbKey, BYTE * pbV, BYTE * pbP, UINT cb)
{
    BYTE digestHw[20];
    BYTE digestSw[20];
    BOOLEAN fRet;

    memset(digestHw, 0, sizeof(digestHw));
    memset(digestSw, 0, sizeof(digestSw));
    
    if (!HardwareCryptSha(pbKey, cbKey, pbP, cb, digestHw))
        return FALSE;

    XcHMAC3(pbKey, cbKey, pbV, cb, NULL, 0, NULL, 0, digestSw);

    fRet = (RtlCompareMemory(digestHw, digestSw, sizeof(digestHw)) == sizeof(digestHw));

    if (!fRet)
    {
        DbgPrint("\n");
        DbgPrint("hw - ");
        for (int i = 0; i < 20; i++)
            DbgPrint("%02x ", digestHw[i]);
        DbgPrint("\n");

        DbgPrint("sw - ");
        for (int i = 0; i < 20; i++)
            DbgPrint("%02x ", digestSw[i]);
        DbgPrint("\n");
    }

    return fRet;
}

BOOLEAN TestHardwareModExp(BYTE * pbExp)
{
    BYTE abResultSw[CBDHG1];
    BYTE abResultHw[CBDHG1];

    XcModExp((DWORD *)abResultSw,
             (DWORD *)g_abOakleyGroup1Base, 
             (DWORD *)pbExp,
             (DWORD *)g_abOakleyGroup1Mod, 
             CBDHG1 / sizeof(DWORD));
    
    if (!HardwareModExp(abResultHw, 
                         (BYTE *)g_abOakleyGroup1Base, 
                         pbExp, 
                         (BYTE *)g_abOakleyGroup1Mod, 
                         CBDHG1))
    {
        return FALSE;
    }

    return (RtlCompareMemory(abResultSw, abResultHw, sizeof(abResultHw)) == sizeof(abResultHw));
}

typedef void (*PFNSPEEDTEST)(PVOID pv);

void
TestSpeed(PSTR szTestName, PFNSPEEDTEST pfnTestFunc, PVOID pv)
{
    DbgPrint("Calibrating %s test: ", szTestName);

    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    ULONG i;
    ULONG CalibratedIterations;

    #define SYSTIME_IN_SECONDS(time)    ((time) / 10000000)

    i = 0;
    KeQuerySystemTime(&StartTime);

    do
    {
        pfnTestFunc(pv);
        KeQuerySystemTime(&EndTime);
        i++;
        
    } while(SYSTIME_IN_SECONDS(EndTime.QuadPart - StartTime.QuadPart) < 1);

    DbgPrint("[OK]\n");

    CalibratedIterations = i * 10;

    DbgPrint("Running %s %d times: ", szTestName, CalibratedIterations);

    KeQuerySystemTime(&StartTime);

    for (i = 0; i < CalibratedIterations; i++)
    {
        pfnTestFunc(pv);
    }

    KeQuerySystemTime(&EndTime);

    ULONGLONG DiffTime;
    ULONGLONG IterationsPerSecond;

    DiffTime = EndTime.QuadPart - StartTime.QuadPart;
    IterationsPerSecond = ((ULONGLONG)i * 10000000) / DiffTime;

    DbgPrint("[OK] %I64d seconds, %d iterations/second\n\n",
             SYSTIME_IN_SECONDS(DiffTime),
             IterationsPerSecond);

}


void EmptyTestFunc(PVOID pv)
{
}

void SHASwTestFunc(PVOID pv)
{
    BYTE abHmacKey[20];
    BYTE digestSw[20];

    XcHMAC3(abHmacKey, sizeof(abHmacKey), g_abCipherText, 1000, NULL, 0, NULL, 0, digestSw);
}

void SHAHwTestFunc(PVOID pv)
{
    BYTE abHmacKey[20];
    BYTE digestHw[20];
    BYTE * pbPhysical;
    PHYSICAL_ADDRESS PhysicalAddress = MmGetPhysicalAddress(g_abCipherText);
    pbPhysical = (BYTE *) PhysicalAddress.LowPart;

    HardwareCryptSha(abHmacKey, sizeof(abHmacKey), pbPhysical, 1000, digestHw);
}

void SHAFastHwTestFunc(PVOID pv)
{
    BYTE abHmacKey[20];
    BYTE digestHw[20];

    HardwareCryptSha(abHmacKey, sizeof(abHmacKey), (BYTE *)pv, 1000, digestHw);
}

void SHAFasterHwTestFunc(PVOID pv)
{
    SynchronousCipherCommand((ubsec_CipherCommandInfo_pt)pv);
}


void
TestLowOverheadSHASpeed()
{
    ubsec_CipherCommandInfo_pt pCmd;
    ULONG BytesToEncrypt;
    BYTE digestHw[20];
    BYTE * pb = g_abCipherText;
    ULONG cb = 1000;
    ULONG cbKey = 20;
    BYTE * pbHmacData = digestHw;

    ASSERT(cb && pb);
    ASSERT(cbKey == 20);

    //
    // Set up auth info buffer.
    //

    CMemoryDescriptor md3;
    md3.Init(pbHmacData, 20);

    //
    // Set up key buffer
    //

    char achKey[UBSEC_MAC_KEY_LENGTH];
    ubsec_InitHMACState(&g_HmacState, UBSEC_MAC_SHA1, (ubsec_HMAC_Key_pt)achKey);

    //
    // Figure out how many fragments we have
    //

    ULONG cFrag = COMPUTE_PAGES_SPANNED(pb, cb);

    ASSERT(cFrag < 3);

    //
    // Set up command going to the card.
    //

    RtlZeroMemory(&g_HardwareCommand, sizeof(g_HardwareCommand));
    pCmd = &g_HardwareCommand;

    pCmd->Command = UBSEC_MAC_SHA1 | UBSEC_DECODE;

    pCmd->CryptHeaderSkip = 0;
    
    pCmd->NumSource = cFrag;
    pCmd->SourceFragments = (ubsec_FragmentInfo_pt) &g_aFragments;

    ubsec_FragmentInfo_pt pFrag = pCmd->SourceFragments;

    pFrag->FragmentAddress = (ULONG) pb;

    if (cFrag == 1)
    {
        pFrag->FragmentLength = cb;
    }
    else
    {
        pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb) + PAGE_SIZE - pb;

        pFrag++;

        pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb + cb - 1);
        pFrag->FragmentLength = pb + cb - (BYTE *) PAGE_ALIGN(pb + cb - 1);
    }

    pFrag++;

    pCmd->CryptKey = (ubsec_CryptKey_pt)g_keys;

    pCmd->NumDestination = pCmd->NumSource;
    pCmd->DestinationFragments = pCmd->SourceFragments;

    pCmd->HMACState = &g_HmacState;
    
    pCmd->AuthenticationInfo.FragmentLength = md3._fragInfo[0].FragmentLength;
    pCmd->AuthenticationInfo.FragmentAddress = md3._fragInfo[0].FragmentAddress;

    TestSpeed("Hardware SHA FASTER", SHAFasterHwTestFunc, pCmd);

}

BYTE g_digestHw[20];

void
TestNoOverheadSHASpeed()
{
    ubsec_CipherCommandInfo_pt pCmd;
    ULONG BytesToEncrypt;
    BYTE * pb = g_abCipherText;
    ULONG cb = 1000;
    ULONG cbKey = 20;
    BYTE * pbHmacData = g_digestHw;

    ASSERT(cb && pb);
    ASSERT(cbKey == 20);

    //
    // Set up auth info buffer.
    //

    CMemoryDescriptor md3;
    md3.Init(pbHmacData, 20);

    //
    // Set up key buffer
    //

    char achKey[UBSEC_MAC_KEY_LENGTH];
    ubsec_InitHMACState(&g_HmacState, UBSEC_MAC_SHA1, (ubsec_HMAC_Key_pt)achKey);

    //
    // Figure out how many fragments we have
    //

    ULONG cFrag = COMPUTE_PAGES_SPANNED(pb, cb);

    ASSERT(cFrag < 3);

    //
    // Set up command going to the card.
    //

    RtlZeroMemory(&g_HardwareCommand, sizeof(g_HardwareCommand));
    pCmd = &g_HardwareCommand;

    pCmd->Command = UBSEC_MAC_SHA1 | UBSEC_DECODE;

    pCmd->CryptHeaderSkip = 0;
    
    pCmd->NumSource = cFrag;
    pCmd->SourceFragments = (ubsec_FragmentInfo_pt) &g_aFragments;

    ubsec_FragmentInfo_pt pFrag = pCmd->SourceFragments;

    pFrag->FragmentAddress = (ULONG) pb;

    if (cFrag == 1)
    {
        pFrag->FragmentLength = cb;
    }
    else
    {
        pFrag->FragmentLength = (BYTE *) PAGE_ALIGN(pb) + PAGE_SIZE - pb;

        pFrag++;

        pFrag->FragmentAddress = (ULONG) PAGE_ALIGN(pb + cb - 1);
        pFrag->FragmentLength = pb + cb - (BYTE *) PAGE_ALIGN(pb + cb - 1);
    }

    pFrag++;

    pCmd->CryptKey = (ubsec_CryptKey_pt)g_keys;

    pCmd->NumDestination = pCmd->NumSource;
    pCmd->DestinationFragments = pCmd->SourceFragments;

    pCmd->HMACState = &g_HmacState;
    
    pCmd->AuthenticationInfo.FragmentLength = md3._fragInfo[0].FragmentLength;
    pCmd->AuthenticationInfo.FragmentAddress = md3._fragInfo[0].FragmentAddress;


    //
    // Run the test
    //
    CHAR szTestName[] = "Hardware SHA FASTEST";

    DbgPrint("Calibrating %s test: ", szTestName);

    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    ULONG i;
    ULONG CalibratedIterations;

    #define SYSTIME_IN_SECONDS(time)    ((time) / 10000000)

    i = 0;
    KeQuerySystemTime(&StartTime);

    do
    {
        SynchronousCipherCommand(pCmd);
        KeQuerySystemTime(&EndTime);
        i++;
        
    } while(SYSTIME_IN_SECONDS(EndTime.QuadPart - StartTime.QuadPart) < 1);

    DbgPrint("[OK]\n");

    CalibratedIterations = i * 10;

    DbgPrint("Running %s %d times: ", szTestName, CalibratedIterations);

    KeQuerySystemTime(&StartTime);

    AsynchronousCipherCommand(pCmd, CalibratedIterations, 100);

    KeQuerySystemTime(&EndTime);

    ULONGLONG DiffTime;
    ULONGLONG IterationsPerSecond;

    DiffTime = EndTime.QuadPart - StartTime.QuadPart;
    IterationsPerSecond = ((ULONGLONG)CalibratedIterations * 10000000) / DiffTime;

    DbgPrint("[OK] %I64d seconds, %d iterations/second\n\n",
             SYSTIME_IN_SECONDS(DiffTime),
             IterationsPerSecond);
    

}

void
TestSHASpeed()
{
    TestSpeed("Software SHA", SHASwTestFunc, NULL);
    TestSpeed("Hardware SHA", SHAHwTestFunc, NULL);

    BYTE * pbPhysical;
    PHYSICAL_ADDRESS PhysicalAddress = MmGetPhysicalAddress(g_abCipherText);
    pbPhysical = (BYTE *) PhysicalAddress.LowPart;

    TestSpeed("Hardware SHA FAST", SHAFastHwTestFunc, pbPhysical);
    TestLowOverheadSHASpeed();
    TestNoOverheadSHASpeed();
}

void ModExpSwTestFunc(PVOID)
{
    BYTE abExp[CBDHG1];
    BYTE abResult[CBDHG1];

    XcModExp((DWORD *)abResult,
             (DWORD *)g_abOakleyGroup1Base, 
             (DWORD *)abExp,
             (DWORD *)g_abOakleyGroup1Mod, 
             CBDHG1 / sizeof(DWORD));
}

void ModExpHwTestFunc(PVOID)
{
    BYTE abExp[CBDHG1];
    BYTE abResult[CBDHG1];

    HardwareModExp(abResult,
                   (BYTE *)g_abOakleyGroup1Base, 
                   abExp,
                   (BYTE *)g_abOakleyGroup1Mod, 
                   CBDHG1);
}

void TestModExpSpeed()
{
    TestSpeed("SW ModExp", ModExpSwTestFunc, NULL);
    TestSpeed("HW ModExp", ModExpHwTestFunc, NULL);
}

void ThreeDESSwTestFunc(PVOID pv)
{
    XcCryptDes(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
               (BYTE *)pv, 1000, NULL, 0);

}

void ThreeDESHwTestFunc(PVOID pv)
{
    HardwareCryptDes(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                     (BYTE *)pv, 1000, NULL, 0);

}

void Test3DESSpeed()
{
    BYTE * pbVirtual;
    BYTE * pbPhysical;
    PHYSICAL_ADDRESS MaxAddress;
    PHYSICAL_ADDRESS PhysicalAddress;
    
    MaxAddress.QuadPart = -1;
    pbVirtual = (BYTE *) MmAllocateContiguousMemory(sizeof(g_abCipherText), MaxAddress);

    if (!pbVirtual)
    {
        DbgPrint("Test3DESSpeed: Couldn't allocate continguous memory\n");
        return;
    }

    PhysicalAddress = MmGetPhysicalAddress(pbVirtual);
    pbPhysical = (BYTE *) PhysicalAddress.LowPart;
    
    TestSpeed("SW 3DES", ThreeDESSwTestFunc, pbVirtual);
    TestSpeed("HW 3DES", ThreeDESHwTestFunc, pbPhysical);
}


void
Test3DES()
{
    BYTE * pbVirtual;
    BYTE * pbPhysical;
    PHYSICAL_ADDRESS MaxAddress;
    PHYSICAL_ADDRESS PhysicalAddress;
    
    DbgPrint("Test3DES\n");
    
    memset(g_abCipherText, 'M', sizeof(g_abCipherText));
    memset(g_keys, 1, sizeof(g_keys));
    memset(g_abIV, 1, sizeof(g_abIV));
    memset(g_abIV2, 2, sizeof(g_abIV));

    XcCryptDes(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
               g_abCipherText, sizeof(g_abCipherText), NULL, 0);

    MaxAddress.QuadPart = -1;
    pbVirtual = (BYTE *) MmAllocateContiguousMemory(sizeof(g_abCipherText), MaxAddress);

    if (!pbVirtual)
    {
        DbgPrint("Couldn't allocate continguous memory\n");
        return;
    }

    PhysicalAddress = MmGetPhysicalAddress(pbVirtual);
    pbPhysical = (BYTE *) PhysicalAddress.LowPart;

    DbgPrint("Allocated contiguous buffer at VA %p PA %p\n", pbVirtual, pbPhysical);

    memset(g_keys, 1, sizeof(g_keys));
    memset(g_abIV, 1, sizeof(g_abIV));


    DbgPrint("Encrypt 8 bytes ");

    memset(pbVirtual, 0, sizeof(g_abCipherText));
    memset(pbVirtual, 'M', 8);

    HardwareCryptDes(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                     pbPhysical, 8, NULL, 0);

    if (RtlCompareMemory(pbVirtual, g_abCipherText, 8) == 8)
    {
        DbgPrint("[OK]\n");
    }
    else
    {
        DbgPrint("[FAIL]\n");

        for (int i = 0; i < 8; i++) DbgPrint("%2x ", g_abCipherText[i]);
        DbgPrint("\n");
        for (int i = 0; i < 8; i++) DbgPrint("%2x ", pbVirtual[i]);
        DbgPrint("\n");

        goto exit;
    }

    memset(pbVirtual, 0, sizeof(g_abCipherText));
    DbgPrint("Encrypt/Decrypt two 8 byte buffers ");

    if (!TestHardwareCrypt2(pbPhysical, pbVirtual, 8, pbPhysical + 8, pbVirtual + 8, 8))
    {
        goto exit;
    }

    DbgPrint("[OK]\n");

    DbgPrint("Encrypt/Decrypt two pages ");

    memset(pbVirtual, 0, sizeof(g_abCipherText));
    
    if (!TestHardwareCrypt(pbPhysical, pbVirtual, 8192))
    {
        goto exit;
    }


    DbgPrint("[OK]\n");

    DbgPrint("Encrypt/Decrypt in one page ");

    BYTE * pb;
    BYTE * pbV;

    for (pb = pbPhysical, pbV = pbVirtual;
         PAGE_ALIGN(pbPhysical) == PAGE_ALIGN(pb);
         pb += 4, pbV += 4)
    {
        for (int cb = XC_SERVICE_DES_BLOCKLEN;
             PAGE_ALIGN(pb) == PAGE_ALIGN(pb + cb - 1);
             cb += XC_SERVICE_DES_BLOCKLEN)
        {
            memset(pbVirtual, 0, sizeof(g_abCipherText));
            if (!TestHardwareCrypt(pb, pbV, cb))
            {
                goto exit;
            }
        }

        DbgPrint(".");
    }

    DbgPrint("[OK]\n");
         

exit:         
    MmFreeContiguousMemory(pbVirtual);
}

void
Test3DESSHA()
{
    BYTE * pbVirtual;
    BYTE * pbPhysical;
    PHYSICAL_ADDRESS MaxAddress;
    PHYSICAL_ADDRESS PhysicalAddress;
    BYTE abHmacKey[20];
    BYTE abHmacData[20];
    BYTE abSoftwareHmacData[20];
    
    DbgPrint("Test3DESSHA\n");
    
    memset(g_abCipherText, 'M', sizeof(g_abCipherText));
    memset(g_keys, 1, sizeof(g_keys));
    memset(g_abIV, 1, sizeof(g_abIV));
    memset(g_abIV2, 2, sizeof(g_abIV));

    XcCryptDes(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
               g_abCipherText, sizeof(g_abCipherText), NULL, 0);

    MaxAddress.QuadPart = -1;
    pbVirtual = (BYTE *) MmAllocateContiguousMemory(sizeof(g_abCipherText), MaxAddress);

    if (!pbVirtual)
    {
        DbgPrint("Couldn't allocate continguous memory\n");
        return;
    }

    PhysicalAddress = MmGetPhysicalAddress(pbVirtual);
    pbPhysical = (BYTE *) PhysicalAddress.LowPart;

    DbgPrint("Allocated contiguous buffer at VA %p PA %p\n", pbVirtual, pbPhysical);

    memset(g_keys, 1, sizeof(g_keys));
    memset(g_abIV, 1, sizeof(g_abIV));

    memset(abHmacKey, 0, sizeof(abHmacKey));
    memset(abHmacData, 0, sizeof(abHmacData));

    DbgPrint("Encrypt 8 bytes ");

    memset(pbVirtual, 0, sizeof(g_abCipherText));
    memset(pbVirtual, 'M', 8);

    HardwareCryptDesSha(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                        pbPhysical, 8, NULL, 0,
                        abHmacKey, sizeof(abHmacKey), abHmacData, 0, 0);

    if (RtlCompareMemory(pbVirtual, g_abCipherText, 8) != 8)
    {
        DbgPrint("[FAIL]\n");

        for (int i = 0; i < 8; i++) DbgPrint("%2x ", g_abCipherText[i]);
        DbgPrint("\n");
        for (int i = 0; i < 8; i++) DbgPrint("%2x ", pbVirtual[i]);
        DbgPrint("\n");

        goto exit;
    }

    XcHMAC3(abHmacKey, sizeof(abHmacKey), pbVirtual, 8, NULL, 0, NULL, 0, abSoftwareHmacData);

    if (RtlCompareMemory(abHmacData, abSoftwareHmacData, sizeof(abHmacData)) != sizeof(abHmacData))
    {
        DbgPrint("[FAIL]\n");
        DbgPrint("hw - ");
        for (int i = 0; i < 20; i++)
            DbgPrint("%02x ", abHmacData[i]);
        DbgPrint("\n");

        DbgPrint("sw - ");
        for (int i = 0; i < 20; i++)
            DbgPrint("%02x ", abSoftwareHmacData[i]);
        DbgPrint("\n");
    }

    DbgPrint("[OK]\n");

    ULONG cbShift = 4;
    ULONG cbSkew;

    for (cbSkew = 1; cbSkew < cbShift; cbSkew++)
    {
        DbgPrint("Encrypt 8 bytes (shift right %d, skew %d) ", cbShift, cbSkew);

        memset(pbVirtual, 0, sizeof(g_abCipherText));
        memset(pbVirtual + cbSkew, 'M', 8);

        DbgPrint(".");

        HardwareCryptDesSha(XC_SERVICE_ENCRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                            pbPhysical + cbSkew, 8, NULL, 0,
                            abHmacKey, sizeof(abHmacKey), abHmacData, 0, cbShift);

        DbgPrint(".");

        if (RtlCompareMemory(pbVirtual + cbShift, g_abCipherText, 8) != 8)
        {
            DbgPrint("[FAIL]\n");

            for (int i = 0; i < 8; i++) DbgPrint("%2x ", g_abCipherText[i]);
            DbgPrint("\n");
            for (int i = 0; i < 8; i++) DbgPrint("%2x ", pbVirtual[i + cbShift]);
            DbgPrint("\n");

            goto exit;
        }

        DbgPrint(".");

        XcHMAC3(abHmacKey, sizeof(abHmacKey), pbVirtual + cbShift, 8, NULL, 0, NULL, 0, abSoftwareHmacData);

        DbgPrint(".");

        if (RtlCompareMemory(abHmacData, abSoftwareHmacData, sizeof(abHmacData)) != sizeof(abHmacData))
        {
            DbgPrint("[FAIL]\n");
            DbgPrint("hw - ");
            for (int i = 0; i < 20; i++)
                DbgPrint("%02x ", abHmacData[i]);
            DbgPrint("\n");

            DbgPrint("sw - ");
            for (int i = 0; i < 20; i++)
                DbgPrint("%02x ", abSoftwareHmacData[i]);
            DbgPrint("\n");
        }

        DbgPrint(".");

        memset(pbVirtual, 0, sizeof(g_abCipherText));
        memset(abHmacData, 0, sizeof(abHmacData));

        DbgPrint("[OK]\n");
    }
    
    DbgPrint("Decrypt 8 bytes ");

    memset(pbVirtual, 'M', 8);
    memset(g_abCipherText, 'M', sizeof(g_abCipherText));

    XcHMAC3(abHmacKey, sizeof(abHmacKey), pbVirtual, 8, NULL, 0, NULL, 0, abSoftwareHmacData);

    XcCryptDes(XC_SERVICE_DECRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
               g_abCipherText, sizeof(g_abCipherText), NULL, 0);

    HardwareCryptDesSha(XC_SERVICE_DECRYPT, (BYTE *) g_keys, sizeof(g_keys), g_abIV,
                        pbPhysical, 8, NULL, 0,
                        abHmacKey, sizeof(abHmacKey), abHmacData, 0, 0);

    if (RtlCompareMemory(pbVirtual, g_abCipherText, 8) != 8)
    {
        DbgPrint("[FAIL]\n");

        for (int i = 0; i < 8; i++) DbgPrint("%2x ", g_abCipherText[i]);
        DbgPrint("\n");
        for (int i = 0; i < 8; i++) DbgPrint("%2x ", pbVirtual[i]);
        DbgPrint("\n");

        goto exit;
    }

    if (RtlCompareMemory(abHmacData, abSoftwareHmacData, sizeof(abHmacData)) != sizeof(abHmacData))
    {
        DbgPrint("[FAIL]\n");
        DbgPrint("hw - ");
        for (int i = 0; i < 20; i++)
            DbgPrint("%02x ", abHmacData[i]);
        DbgPrint("\n");

        DbgPrint("sw - ");
        for (int i = 0; i < 20; i++)
            DbgPrint("%02x ", abSoftwareHmacData[i]);
        DbgPrint("\n");
    }

    DbgPrint("[OK]\n");

exit:         
    MmFreeContiguousMemory(pbVirtual);
}

void
TestSHA()
{
    BYTE abHmacKey[20];
    BYTE abHmacData[20];
    PHYSICAL_ADDRESS PhysicalAddress;
    BYTE * pbPhysical;

    PhysicalAddress = MmGetPhysicalAddress(g_abCipherText);
    pbPhysical = (BYTE *) PhysicalAddress.LowPart;

    DbgPrint("TestSHA\n");

    memset(g_abCipherText, 'M', sizeof(g_abCipherText));
    memset(abHmacKey, 0, sizeof(abHmacKey));
    memset(abHmacData, 0, sizeof(abHmacData));

    DbgPrint("Calling HardwareCryptSha ");

    if (HardwareCryptSha(abHmacKey, sizeof(abHmacKey), pbPhysical, 100, abHmacData))
    {
        DbgPrint("[OK]\n");
    }
    else
    {
        DbgPrint("[FAIL]\n");
    }

    DbgPrint("Comparing SHA hw vs. sw ");

    if (TestHardwareCryptSha(abHmacKey, sizeof(abHmacKey), g_abCipherText, pbPhysical, 100))
    {
        DbgPrint("[OK]\n");
    }
    else
    {
        DbgPrint("[FAIL]\n");
    }
        
    
}

void
TestEXP()
{
    DbgPrint("TestEXP\n");

    ubsec_MathCommandInfo_t cmd;
    cmd.Command = UBSEC_MATH_MODEXP;


    BYTE TestExp[CBDHG1];
    memset(TestExp, 0, sizeof(TestExp));
    memcpy(TestExp, DriverEntry, sizeof(TestExp));

    for (int exp = 1; exp < 4; exp++)
    {
        TestExp[45] = exp;

        for (int i = 0; i < sizeof(TestExp); i++)
            DbgPrint("%02x ", TestExp[i]);
        DbgPrint("\n\n");

        DbgPrint("TestExp[45] = %d ", TestExp[45]);

        if (TestHardwareModExp(TestExp))
        {
            DbgPrint("[OK]\n");
        }
        else
        {
            DbgPrint("[FAIL]\n");
        }
    }

}


void
TestRC4()
{
    DbgPrint("TestRC4\n");
}


void                    
CMemoryDescriptor::Init(
    BYTE * pb, 
    ULONG cb
    )
{
    ASSERT(cb < (PAGE_SIZE * 2));

    PHYSICAL_ADDRESS StartAddr = MmGetPhysicalAddress(pb);
    PHYSICAL_ADDRESS EndAddr = MmGetPhysicalAddress(&pb[cb - 1]);

    ASSERT(StartAddr.HighPart == 0);
    ASSERT(EndAddr.HighPart == 0);

    BYTE * StartPA = (BYTE *) StartAddr.LowPart;
    BYTE * EndPA = (BYTE *) EndAddr.LowPart;
    
    BYTE * StartPage = (BYTE *) PAGE_ALIGN(StartPA);    
    BYTE * EndPage = (BYTE *) PAGE_ALIGN(EndPA);

    _pVA = pb;
    _bFlipped = FALSE;

    if (StartPage == EndPage)
    {
        _cFrag = 1;
        _fragInfo[0].FragmentAddress = StartAddr.LowPart;
        _fragInfo[0].FragmentLength = cb;
    }
    else
    {
        _cFrag = 2;

        _fragInfo[0].FragmentAddress = (ULONG) StartPA;
        _fragInfo[0].FragmentLength = (StartPage + PAGE_SIZE - StartPA);

        _fragInfo[1].FragmentAddress = (ULONG) EndPage;
        _fragInfo[1].FragmentLength = BYTE_OFFSET(EndPA) + 1;

        ASSERT(_fragInfo[0].FragmentLength + _fragInfo[1].FragmentLength == cb);
    }

    ASSERT(COMPUTE_PAGES_SPANNED(pb, cb) == _cFrag);
    
}


void
CMemoryDescriptor::Print()
{
    ASSERT(_cFrag == 1 || _cFrag == 2);

    DbgPrint("CMemoryDescriptor %p\n"
             "    _cFrag = %d\n"
             "    _fragInfo[0].FragmentAddress = %x (%x)\n"
             "    _fragInfo[0].FragmentLength  = %d\n",
             this,
             _cFrag,
             _fragInfo[0].FragmentAddress,
             _fragInfo[0].FragmentAddress + _fragInfo[0].FragmentLength - 1,
             _fragInfo[0].FragmentLength);

    if (_cFrag == 2)
    {
        DbgPrint("    _fragInfo[1].FragmentAddress = %x (%x)\n"
                 "    _fragInfo[1].FragmentLength  = %d\n",
                 _fragInfo[1].FragmentAddress,
                 _fragInfo[1].FragmentAddress + _fragInfo[1].FragmentLength - 1,
                 _fragInfo[1].FragmentLength);
    }

}

/*
 * WDMCriticalSection:
 *
 * returns value (always FALSE) for macro to use, since Windows spinlock routine doesn't 
 *
 */
EXTERN_C
unsigned long
WDMCriticalSection(unsigned long pDevice, unsigned long *SaveConfig)
{
//    DbgPrint("!!!!!! WDMCriticalSection !!!!!!\n");

    KeAcquireSpinLock(&(((DeviceInfo_pt)pDevice)->OsDeviceInfo->SRLspinLock),&(((DeviceInfo_pt)pDevice)->OsDeviceInfo->SRLirql));
    return FALSE;
}

/*
 * WDMGetPhysicalAddress:
 *
 * uses WDM API to get physical address corresponding to virtual address 
 * (avoids simpler NT-only kernel API)
 *
 */
EXTERN_C
long
WDMGetPhysicalAddress(long logical_address)
{
//    DbgPrint("!!!! WDMGetPhysicalAddress !!!!\n");
    
    LARGE_INTEGER addr;
    long physical_address;

    addr = MmGetPhysicalAddress((PVOID)logical_address);
    physical_address = addr.LowPart;

    return physical_address;
}

void RunPerfTests()
{
    TestModExpSpeed();
    TestSHASpeed();
    Test3DESSpeed();
    TestSpeed("Empty", EmptyTestFunc, NULL);
}

void
RunTests()
{
    KeInitializeEvent(&g_evtCompletion, NotificationEvent, FALSE);

    TestRC4();
    TestSHA();
    TestEXP();
//    Test3DES();
    Test3DESSHA();

//    RunPerfTests();

    DbgPrint("Done!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\tcryptop.h ===
extern "C"
{
    #include <ntddk.h>
    #include <wmistr.h>
    #include <wmilib.h>

    #include <ntddksec.h>

    #define VOLATILE
    #define WIN32_DEVICE
    
    #include "ubsincl.h"
    #include "ioctls_int.h"

    #include <windef.h>
    #define _INC_WINDOWS
//    typedef BPC_FILETIME FILETIME;
}

#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <xcrypt.h>
//#include <rsa.h>
//#include <wsockntp.h>
//#include <xonlinep.h>

#include <crypto\rc4.h>
#include <crypto\sha.h>
#include <crypto\md5.h>
#include <crypto\modes.h>
#include <crypto\des.h>
#include <crypto\tripldes.h>
#include <crypto\benaloh.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\CConfigInfoDbgParser\Program.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Diagnostics;

namespace CConfigInfoDbgParser
{
    class Program
    {
        static void Main (string[] args)
        {
            if (args.Length != 3)
            {
                Console.WriteLine("Usage: {0} <startup trace> <reload trace> <output file>", Process.GetCurrentProcess().ProcessName);
                Environment.Exit(1);
            }

            // try to load files
            StreamReader startup_trace = new StreamReader(args[0]);
            StreamReader reload_trace = new StreamReader(args[1]);

            // create output
            XmlWriterSettings xws = new XmlWriterSettings();
            xws.Indent = true;
            XmlWriter output_file = XmlWriter.Create(args[2], xws);

            // output
            output_file.WriteStartElement("root");

            ParseFile(output_file, startup_trace, "Startup");
            startup_trace.Close();

            ParseFile(output_file, reload_trace, "Reload");
            reload_trace.Close();

            output_file.WriteEndElement();
            output_file.Close();
        }

        private const string LineTag = "CConfigInfoDbg: ";
        private const string ListAction = "FindList";
        private const string NonListAction = "FindNonList";
        private const string CountAction = "Count";

        class Item
        {
            public string Action;
            public string Parent;
            public string Name;
            public bool AllowMultiple = false;
            public Dictionary<string, string> Attributes = new Dictionary<string,string>();

            internal bool Merge (Item other)
            {
                // if the previous value was a count, we can overwrite it
                if (Action == CountAction && (other.Action == ListAction || other.Action == NonListAction))
                {
                    return false;
                }

                // we counted again, lets just ignore
                if ((Action == ListAction || Action == NonListAction) && other.Action == CountAction)
                {
                    return true;
                }

                // we looked for the value before trying to retrieve it
                if (Action == NonListAction)
                {
                    // often times it is then "required", well not now
                    if (other.Attributes.ContainsKey("Required")) { other.Attributes["Required"] = "0"; }
                    return false;
                }

                // we will just allow multiples
                AllowMultiple = true;
                MergeListItem(other);

                return true;
            }

            internal virtual void MergeListItem (Item other)
            {
                // for a simple item, all of these things should stay true
                if (Action != other.Action) { Debugger.Break(); }
                if (Parent != other.Parent) { Debugger.Break(); }
                if (Name != other.Name) { Debugger.Break(); }
                if (Attributes.Count != other.Attributes.Count) { Debugger.Break(); }
                foreach (string key in Attributes.Keys)
                {
                    if (!other.Attributes.ContainsKey(key)) { Debugger.Break(); }
                    // allowed to be different
                    if (key == "Required") { continue; }
                    if (Attributes[key] != other.Attributes[key]) { Debugger.Break(); }
                }
            }

            internal virtual void WriteXml (XmlWriter writer)
            {
                WriteXmlStart(writer);
                writer.WriteEndElement();
            }

            protected void WriteXmlStart (XmlWriter writer)
            {
                writer.WriteStartElement("item");
                writer.WriteAttributeString("action", Action);
                writer.WriteAttributeString("parent", Parent);
                writer.WriteAttributeString("name", Name);
                writer.WriteAttributeString("multiple", (AllowMultiple ? "1" : "0"));

                foreach (string key in Attributes.Keys)
                {
                    writer.WriteStartElement("parameter");
                    writer.WriteAttributeString("name", key);
                    writer.WriteAttributeString("value", Attributes[key]);
                    writer.WriteEndElement();
                }
            }
        }

        class List : Item
        {
            public Dictionary<string, Item> Items = new Dictionary<string, Item>();

            internal void Add (Item item)
            {
                Item search;
                if (Items.TryGetValue(item.Name, out search))
                {
                    if (!search.Merge(item))
                    {
                        Items[item.Name] = item;
                    }
                }
                else
                {
                    Items.Add(item.Name, item);
                }
            }

            internal override void MergeListItem (Item other)
            {
                base.MergeListItem(other);

                List other_list = (List)other;

                foreach (string key in other_list.Items.Keys)
                {
                    Item other_item = other_list.Items[key];

                    Item search;
                    if (Items.TryGetValue(other_item.Name, out search))
                    {
                        search.MergeListItem(other_item);
                    }
                    else
                    {
                        Items.Add(other_item.Name, other_item);
                    }
                }
            }

            internal override void WriteXml (XmlWriter writer)
            {
                WriteXmlStart(writer);

                foreach (Item item in Items.Values)
                {
                    item.WriteXml(writer);
                }

                writer.WriteEndElement();
            }
        }

        private static void ParseFile (XmlWriter writer, StreamReader trace, string name)
        {
            Dictionary<string, Item> items = new Dictionary<string, Item>();
            List<List> list_stack = new List<List>();

            while (!trace.EndOfStream)
            {
                string line = trace.ReadLine();

                int pos = line.IndexOf(LineTag);

                // not for us
                if (pos == -1) { continue; }

                string data = line.Substring(pos + LineTag.Length);
                string[] split_data = data.Split(new char[] { '|' }, StringSplitOptions.None);

                // ignore tracetags
                if (split_data[1] == "TraceTags") { continue; }

                Item current = null;
                
                // check for list searching
                if (split_data[0] == ListAction)
                {
                    current = new List();
                }
                else
                {
                    current = new Item();
                }

                // save globals
                current.Action = split_data[0];
                current.Parent = split_data[1];
                current.Name = split_data[2];

                // optional parts
                for (int i = 3; i < split_data.Length; ++i)
                {
                    string val = split_data[i];

                    if (val == string.Empty) { continue; }

                    pos = val.IndexOf('=');

                    if (pos == -1)
                    {
                        current.Attributes.Add("Required", val);
                    }
                    else
                    {
                        current.Attributes.Add(val.Substring(0, pos), val.Substring(pos + 1));
                    }
                }

                // what do we need to do with this item?
                if (current.Parent == string.Empty)
                {
                    // if we had a list stack before now, we will need to merge/add it
                    if (list_stack.Count != 0)
                    {
                        while (list_stack.Count > 1)
                        {
                            list_stack[list_stack.Count - 2].Add(list_stack[list_stack.Count - 1]);
                            list_stack.RemoveAt(list_stack.Count - 1);
                        }

                        List stack_top = list_stack[0];

                        Item search;
                        if (items.TryGetValue(stack_top.Name, out search))
                        {
                            if (!search.Merge(stack_top))
                            {
                                items[stack_top.Name] = stack_top;
                            }
                        }
                        else
                        {
                            items.Add(stack_top.Name, stack_top);
                        }

                        list_stack.Clear();
                    }

                    if (current is List)
                    {
                        list_stack.Add((List)current);
                    }
                    else
                    {
                        Item search;
                        if (items.TryGetValue(current.Name, out search))
                        {
                            if (!search.Merge(current))
                            {
                                items[current.Name] = current;
                            }
                        }
                        else
                        {
                            items.Add(current.Name, current);
                        }
                    }
                }
                else
                {
                    if (list_stack.Count == 0)
                    {
                        Console.WriteLine("Error: Got a list member, but the stack was empty...");
                        Environment.Exit(2);
                    }

                    // drain stack until the top is our parent
                    for (int i = list_stack.Count - 1; i >= 0; --i)
                    {
                        if (list_stack[i].Name != current.Parent)
                        {
                            list_stack[i - 1].Add(list_stack[i]);
                        }
                        else
                        {
                            break;
                        }
                    }

                    if (current is List)
                    {
                        list_stack.Add((List)current);
                    }
                    else
                    {
                        list_stack[list_stack.Count - 1].Add(current);
                    }
                }

                // check for next line is part of us indicator
                if (split_data[split_data.Length - 1] == string.Empty)
                {
                    line = trace.ReadLine();
                    pos = line.IndexOf(LineTag);

                    if (pos == -1)
                    {
                        Console.WriteLine("Warning: The next line should have been a Find associated with the previous lookup.");
                    }

                    data = line.Substring(pos + LineTag.Length);
                    string[] sub_check = data.Split(new char[] { '|' }, StringSplitOptions.None);

                    if (split_data[1] != sub_check[1])
                    {
                        Console.WriteLine("Warning: Parent of sub-find did not match that of main call.");
                    }

                    if (split_data[2] != sub_check[2])
                    {
                        Console.WriteLine("Warning: Search string of sub-find did not match that of main call.");
                    }
                }
            }

            // handle any remaining list on the stack
            if (list_stack.Count != 0)
            {
                while (list_stack.Count > 1)
                {
                    list_stack[list_stack.Count - 2].Add(list_stack[list_stack.Count - 1]);
                    list_stack.RemoveAt(list_stack.Count - 1);
                }

                List stack_top = list_stack[0];

                Item search;
                if (items.TryGetValue(stack_top.Name, out search))
                {
                    if (!search.Merge(stack_top))
                    {
                        items[stack_top.Name] = stack_top;
                    }
                }
                else
                {
                    items.Add(stack_top.Name, stack_top);
                }

                list_stack.Clear();
            }

            // start xml output
            writer.WriteStartElement("CConfigInfoDbgParse");
            writer.WriteAttributeString("type", name);

            foreach (Item item in items.Values)
            {
                item.WriteXml(writer);
            }

            writer.WriteEndElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubscrypt.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubscrypt.h:  This file contains all the structure definitions for the crypto 
 * functions of the BCM58xx chip family.
 * 
 * This file was previously named ubs5501.h:
 */ 

/*
 * Revision History:
 *
 * 09/xx/1999 SOR Created - ubs5501.h.
 * 12/01/1999 DWP Modified to handle Big Endian devices.  Activating SRL for
 *                Big Endian requires defining BIG_ENDIAN, rather than 
 *                LITTLE_ENDIAN
 * 12/03/1999 SOR Modifications to do all static address computations 
 *                at init time
 * 09/14/2000 SOR Added 5820 Support
 * 09/14/2000 SOR Created register control file and this file.
 * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
 * 07/16/2001 RJT Added support for BCM5821
 */

#ifndef _UBSCRYPT_H_
#define _UBSCRYPT_H_

/*
 * Device specfic Data Structures.
 *
 * These structures are determined by the hardware.
 * additional fields are added for simplicity.
 *
 * BCM - ubs5801 was previously the BSN-ubs5501.
 * so both definitions may be used in this file.
 */


/*
 * Packet Context Buffer structure
 *
 * 	Keeps the keys and instructions for a packet.
 *
 *	CryptoKeys		holds the keys for 3DES
 *	HMACInnerState		pre-computed HMAC inner state
 *	HMACOuterState		pre-computed HMAC outer state
 *				(2x16bit for MD5, 2x20bit for SHA1)
 *	ComputedIV		Crypto Initial Vector(from payload, if explicit)
 *				Processing Control Flags:
 *	reserved		reserved
 *	uAuthentication		MD5/SHA1/None
 *	Inbound		Inbound Packet
 *	Crypto			3DES-CBC/None
 *	CryptoOffset		Offset to skip authenticated but not encrypted
 *				header words.  Goes to start of IV data, in
 *				units of 32-bit words.
 */
typedef struct CipherContext_s {
#ifdef UBSEC_582x_CLASS_DEVICE 
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short       CryptoFlag;
  VOLATILE unsigned short       CryptoOffset;
#else
  VOLATILE unsigned short       CryptoOffset;
  VOLATILE unsigned short       CryptoFlag;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long	CryptoKey1[2];
  VOLATILE unsigned long	CryptoKey2[2];
  VOLATILE unsigned long	CryptoKey3[2];
  VOLATILE unsigned long	ComputedIV[2];
  VOLATILE unsigned long	HMACInnerState[5];
  VOLATILE unsigned long	HMACOuterState[5];
#else /* UBSEC_580x */
  VOLATILE unsigned long	CryptoKey1[2];
  VOLATILE unsigned long	CryptoKey2[2];
  VOLATILE unsigned long	CryptoKey3[2];
  VOLATILE unsigned long	HMACInnerState[5];
  VOLATILE unsigned long	HMACOuterState[5];
  VOLATILE unsigned long	ComputedIV[2];
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short       CryptoFlag;
  VOLATILE unsigned short	CryptoOffset;
#else
  VOLATILE unsigned short	CryptoOffset;
  VOLATILE unsigned short       CryptoFlag;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
#endif /* 5820/21 conditional */
}   CipherContext_t, *CipherContext_pt;

/*
 * CryptoFlag Settings
 */
/* #ifdef UBS_LITTLE_ENDIAN */
#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
#define CF_ENCODE   0x0000
#define CF_DECODE   0x4000
#define CF_3DES     0x8000
#define CF_MD5      0x1000
#define CF_SHA1     0x2000
#else
#define CF_ENCODE   0x0000
#define CF_DECODE   0x0040
#define CF_3DES     0x0080
#define CF_MD5      0x0010
#define CF_SHA1     0x0020
#endif

#ifdef UBSEC_582x_CLASS_DEVICE  /* SSL/TLS/ARC4 are for BCM5820/21 only */

/*
 * SSL MD5/SHA1 context.
 */
#define SSL_HMAC_PAD_VALUE_LONG 0x3636363636363636
#define SSL_HMAC_PAD_LENGTH_LONG 12

#define SSL_MAC_PAD_VALUE_LONG 0x3636363636363636
#define SSL_MAC_PAD_LENGTH_LONG 12

typedef struct SSL_HMACContext_s {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short       CryptoFlag;
  VOLATILE unsigned short	Reserved;
#else
  VOLATILE unsigned short	Reserved;
  VOLATILE unsigned short       CryptoFlag;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned char	HMACKey[20];
  VOLATILE unsigned char	HMACPad[48];
  VOLATILE unsigned long	SequenceHigh;
  VOLATILE unsigned long	SequenceLow;
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned long	ReservedB : 8;
  VOLATILE unsigned long	DataLength : 16;
  VOLATILE unsigned long	ContentType : 8;
#else
  VOLATILE unsigned long	ContentType : 8;
  VOLATILE unsigned long	DataLength : 16;
  VOLATILE unsigned long	ReservedB : 8;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
}   SSL_HMACContext_t, *SSL_HMACContext_pt, SSL_MACContext_t, *SSL_MACContext_pt;

/* TLS HMAC Context */
typedef struct TLS_HMACContext_s {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short       CryptoFlag;
  VOLATILE unsigned short	Reserved;
#else
  VOLATILE unsigned short	Reserved;
  VOLATILE unsigned short       CryptoFlag;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long	HMACInnerState[5];
  VOLATILE unsigned long	HMACOuterState[5];
  VOLATILE unsigned long	SequenceHigh;
  VOLATILE unsigned long	SequenceLow;
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned long	DataLengthHi:8;
  VOLATILE unsigned long	Version:16;
  VOLATILE unsigned long	ContentType:8;
  VOLATILE unsigned long	ReservedG2:24;
  VOLATILE unsigned long	DataLengthLo:8;
#else
  VOLATILE unsigned long	ContentType:8;
  VOLATILE unsigned long	Version:16;
  VOLATILE unsigned long	DataLengthHi:8;
  VOLATILE unsigned long	DataLengthLo:8;
  VOLATILE unsigned long	ReservedG2:24;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
}   TLS_HMACContext_t, *TLS_HMACContext_pt;

/* SSL/TLS DES Context */
typedef struct SSL_CryptoContext_s {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short       CryptoFlag;
  VOLATILE unsigned short	Reserved;
#else
  VOLATILE unsigned short	Reserved;
  VOLATILE unsigned short       CryptoFlag;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long	CryptoKey1[2];
  VOLATILE unsigned long	CryptoKey2[2];
  VOLATILE unsigned long	CryptoKey3[2];
  VOLATILE unsigned long	ComputedIV[2];
}   SSL_CryptoContext_t, *SSL_CryptoContext_pt;

/* ARC4  DES Context */

typedef struct ARC4_CryptoContext_s {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short StateInfo;
  VOLATILE unsigned short Reserved;
  VOLATILE unsigned char Index_j;
  VOLATILE unsigned char Reserved_j;
  VOLATILE unsigned char Index_i;
  VOLATILE unsigned char Reserved_i;
#else
  VOLATILE unsigned short Reserved;
  VOLATILE unsigned short StateInfo;
  VOLATILE unsigned char Reserved_i;
  VOLATILE unsigned char Index_i;
  VOLATILE unsigned char Reserved_j;
  VOLATILE unsigned char Index_j;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned char KeyState[UBSEC_ARC4_KEYSTATE_BYTES];
}   ARC4_CryptoContext_t, *ARC4_CryptoContext_pt;

/* Bit field definitions for state Information  */
#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
#define ARC4_STATE_NULL_DATA   0x1000
#define ARC4_STATE_WRITEBACK   0x0800
#define ARC4_STATE_STATEKEY    0x0400
#else
#define ARC4_STATE_NULL_DATA   0x0010
#define ARC4_STATE_WRITEBACK   0x0008
#define ARC4_STATE_STATEKEY    0x0004
#endif


/* Pure Hash Context */
typedef struct Hash_Context_s {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short CryptoFlag;
  VOLATILE unsigned short Reserved; 
#else
  VOLATILE unsigned short Reserved; 
  VOLATILE unsigned short CryptoFlag;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
}   Hash_Context_t, *Hash_Context_pt;

#endif /* UBSEC_582x_CLASS_DEVICE */

/*
 * Generic union to encompass all cipher context types
 */

typedef union CryptoContext_u {
  CipherContext_t Cipher;
#ifdef UBSEC_582x_CLASS_DEVICE
  SSL_HMACContext_t SSL_Mac;
  TLS_HMACContext_t TLS_HMac;
  SSL_CryptoContext_t SSL_Crypto;
  ARC4_CryptoContext_t ARC4_Crypto;
  Hash_Context_t Hash;
#endif
}   CryptoContext_t, *CryptoContext_pt;

typedef struct PacketContextUnaligned_s {
#ifdef UBSEC_582x_CLASS_DEVICE
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short cmd_structure_length;
  VOLATILE unsigned short operation_type; 
#else
  VOLATILE unsigned short operation_type; 
  VOLATILE unsigned short cmd_structure_length;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
#endif /* UBSEC_582x_CLASS_DEVICE */
  VOLATILE CryptoContext_t Context;
  VOLATILE unsigned long  PhysicalAddress;
} PacketContextUnaligned_t;


#define PKTCONTEXT_ALIGNMENT 64 /* Boundary to which PacketContexts will be aligned. Must be power of 2 */

#if (SYS_CACHELINE_SIZE >= PKTCONTEXT_ALIGNMENT) 
  #define PKTCONTEXT_ALIGNMENT_PAD (PKTCONTEXT_ALIGNMENT - (sizeof(PacketContextUnaligned_t) & (PKTCONTEXT_ALIGNMENT-1)))
#else
  #undef PKTCONTEXT_ALIGNMENT_PAD
#endif

/***********************************************************************/
/* Hardware (DMA) version of above structure that is cacheline sized   */
/* (an integer multiple of SYS_CACHELINE_SIZE bytes in length).        */
/* Any changes made to either structure must be mirrored in the other  */
/***********************************************************************/

typedef struct PacketContext_s {
#ifdef UBSEC_582x_CLASS_DEVICE
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short cmd_structure_length;
  VOLATILE unsigned short operation_type; 
#else
  VOLATILE unsigned short operation_type; 
  VOLATILE unsigned short cmd_structure_length;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
#endif /* 582x conditional */
  VOLATILE CryptoContext_t Context;
  VOLATILE unsigned long  PhysicalAddress;
#if (SYS_CACHELINE_SIZE >= PKTCONTEXT_ALIGNMENT) 
  /***********************************************************************/
  /**** If PacketContextUnaligned_t is cacheline sized, the following ****/
  /**** pad array will have a subscript of zero. Under this condition ****/
  /**** the following line should be commented out.                   ****/ 
  unsigned char pad[PKTCONTEXT_ALIGNMENT_PAD];                        /***/
  /***********************************************************************/
#endif
} PacketContext_t,*PacketContext_pt;

/* Size of command fields. */
#define CIPHER_CONTEXT_SIZE (sizeof(CipherContext_t)+4) 
#define SSLMAC_CONTEXT_SIZE (sizeof(SSL_MACContext_t)+4)
#define SSLCRYPTO_CONTEXT_SIZE (sizeof(SSL_CryptoContext_t)+4) 
#define TLSHMAC_CONTEXT_SIZE (sizeof(TLS_HMACContext_t)+4) 
#define ARC4_CONTEXT_SIZE (sizeof(ARC4_CryptoContext_t)+4)
#define HASH_CONTEXT_SIZE (sizeof(Hash_Context_t)+4)

/*
 * Crypto operation types.
 */
/* #ifdef UBS_LITTLE_ENDIAN */
#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
#define OPERATION_IPSEC      0x0000
#define OPERATION_SSL_HMAC   0x0001
#define OPERATION_SSL_MAC    0x0001
#define OPERATION_TLS_HMAC   0x0002
#define OPERATION_SSL_CRYPTO 0x0003
#define OPERATION_ARC4       0x0004
#define OPERATION_HASH       0x0005
#else
#define OPERATION_IPSEC      0x0000
#define OPERATION_SSL_HMAC   0x0100
#define OPERATION_SSL_MAC    0x0100
#define OPERATION_TLS_HMAC   0x0200
#define OPERATION_SSL_CRYPTO 0x0300
#define OPERATION_ARC4       0x0400
#define OPERATION_HASH       0x0500
#endif

#define NULL_PACKET_CONTEXT (PacketContext_pt) 0



/*--------------------------------------------------------------------------
 * Data Buffer Chain element
 *
 *	An element in the linked list of data buffers that makes up a 
 *	Packet
 *
 *	DataAddress				pointer to this buffer's data
 *	pNext					pointer to the next element
 *	DataLength				size in bytes of this element
 *	Reserved				reserved
 */

typedef struct DataBufChain_s	{
  VOLATILE unsigned long 	DataAddress;           /* Physical address. */
  VOLATILE unsigned long	pNext;  /* Physical address. */
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short  DataLength;
  VOLATILE unsigned short  Reserved;
#else
  VOLATILE unsigned short  Reserved;
  VOLATILE unsigned short  DataLength;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
} DataBufChain_t, *DataBufChain_pt;

/* This is the same structure as above but with
   a physical address location for efficiency */
typedef struct DataBufChainList_s	{
  VOLATILE unsigned long 	DataAddress;           /* Physical address. */
  VOLATILE unsigned long	pNext;  /* Physical address. */
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short  DataLength;
  VOLATILE unsigned short  Reserved;
#else
  VOLATILE unsigned short  Reserved;
  VOLATILE unsigned short  DataLength;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long PhysicalAddress;
} DataBufChainList_t, *DataBufChainList_pt;

#define NULL_DATA_CHAIN ((DataBufChainList_pt) 0)

/*
 * Packet
 */
typedef struct Packet_s {
	 VOLATILE unsigned long      PacketContextBuffer;
	 VOLATILE DataBufChain_t     InputHead;
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
	 VOLATILE unsigned short     Reserved;
	 VOLATILE unsigned short     PacketLength;
#else
	 VOLATILE unsigned short     PacketLength;
	 VOLATILE unsigned short     Reserved;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
	 VOLATILE DataBufChain_t     OutputHead;
	} Packet_t, *Packet_pt;

/*
 * Master Command Record structure
 *
 * 	The master command record is the structure that gets passed
 *	to the chip.  
 *
 *	NumberOfPackets	number of packets in this MCR
 *	Flags			completion status from chip
 *	PacketArray		array of packet structures
 */

typedef struct CallBackInfo_s {
  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);
  unsigned long	   		 CommandContext;
  }   CallBackInfo_t, *CallBackInfo_pt;

#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
#define MCR_FLAG_COMPLETION    0x0001		/* bit [0] indicates done */
#define MCR_INTERRUPT_SUPPRESS 0x8000		/* bit [15] suppresses interrupt for 5821 MCR */
#else
#define MCR_FLAG_COMPLETION 0xff00		/* bit [8] indicates done */
#define MCR_INTERRUPT_SUPPRESS 0x0080		/* bit [7] suppresses interrupt for 5821 MCR */
#endif

/* MCR_DMA_MEM_OFFSET forces the PacketArray list to start on a 32-byte boundary.  */
/* This assumes that each MCR is aligned to at least a 32-byte boundary. That      */
/* means that OS_AllocateDMAMemory() must return physical memory aligned to        */
/* at least 32-byte boundaries (32, 64, 96 etc.) as defined by SYS_CACHELINE_SIZE. */
#if (SYS_CACHELINE_SIZE && !(SYS_CACHELINE_SIZE & 0x1F)) 
  #define MCR_DMA_MEM_OFFSET (sizeof(Packet_t) - 2*sizeof(unsigned short)) 
#else
  #define MCR_DMA_MEM_OFFSET 0
#endif

typedef struct MasterCommandUnaligned_s {
#if (SYS_CACHELINE_SIZE && !(SYS_CACHELINE_SIZE & 0x1F)) 
  unsigned char dma_pad[MCR_DMA_MEM_OFFSET];
#endif
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short	NumberOfPackets;
  VOLATILE unsigned short	Flags;
#else
  VOLATILE unsigned short	Flags;
  VOLATILE unsigned short	NumberOfPackets;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE Packet_t	PacketArray[MCR_MAXIMUM_PACKETS];
	  /*
	   * The following fields are not part of the MCR but are present here
	   * for easy access. 
	   */
  OS_MemHandle_t MCRMemHandle; /* Memory handle to use for current MCR */
  unsigned long MCRMemHandleOffset; /* Used with handle for OS_SyncTo calls */
  VOLATILE CallBackInfo_t CompletionArray[MCR_MAXIMUM_PACKETS];
  VOLATILE PacketContext_t  *ContextList;
  VOLATILE KeyContext_t  *KeyContextList[MCR_MAXIMUM_PACKETS];
  OS_MemHandle_t  ContextListHandle[MCR_MAXIMUM_PACKETS];
#ifdef STATIC_F_LIST
  VOLATILE DataBufChainList_t  InputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
  VOLATILE DataBufChainList_t  OutputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
#else
  VOLATILE DataBufChainList_t  *InputFragmentList;
  VOLATILE DataBufChainList_t  *OutputFragmentList;
  OS_MemHandle_t InputFragmentListHandle;
  OS_MemHandle_t OutputFragmentListHandle;
#endif
  VOLATILE unsigned long MCRPhysicalAddress;
  VOLATILE unsigned long MCRState;
  VOLATILE struct MasterCommand_s *pNextMCR; /* Pointer to next in list. */
  unsigned long Index;
} MasterCommandUnaligned_t;

#define MCR_ALIGNMENT 32 /* Boundary to which MCRs will be aligned. Must be power of 2 */

#if (SYS_CACHELINE_SIZE >= MCR_ALIGNMENT) 
  #define MCR_ALIGNMENT_PAD (MCR_ALIGNMENT - (sizeof(MasterCommandUnaligned_t) & (MCR_ALIGNMENT-1)))
#else
  #undef MCR_ALIGNMENT_PAD 
#endif

/***********************************************************************/
/* Hardware (DMA) version of above structure that is 'alignably' sized */
/* (an integer multiple of 32 bytes in length).                        */
/* Any changes made to either structure must be mirrored in the other  */
/***********************************************************************/

typedef struct MasterCommand_s {
#if (SYS_CACHELINE_SIZE && !(SYS_CACHELINE_SIZE & 0x3)) 
  unsigned char dma_pad[MCR_DMA_MEM_OFFSET];
#endif
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short	NumberOfPackets;
  VOLATILE unsigned short	Flags;
#else
  VOLATILE unsigned short	Flags;
  VOLATILE unsigned short	NumberOfPackets;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE Packet_t	PacketArray[MCR_MAXIMUM_PACKETS];
	  /*
	   * The following fields are not part of the MCR but are present here
	   * for easy access. 
	   */
  OS_MemHandle_t MCRMemHandle; /* Memory handle to use for current MCR */
  unsigned long MCRMemHandleOffset; /* Used with handle for OS_SyncTo calls */
  VOLATILE CallBackInfo_t CompletionArray[MCR_MAXIMUM_PACKETS];
  VOLATILE PacketContext_t  *ContextList;
  VOLATILE KeyContext_t  *KeyContextList[MCR_MAXIMUM_PACKETS];
  OS_MemHandle_t  ContextListHandle[MCR_MAXIMUM_PACKETS];
#ifdef STATIC_F_LIST
  VOLATILE DataBufChainList_t  InputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
  VOLATILE DataBufChainList_t  OutputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
#else
  VOLATILE DataBufChainList_t  *InputFragmentList;
  VOLATILE DataBufChainList_t  *OutputFragmentList;
  OS_MemHandle_t InputFragmentListHandle;
  OS_MemHandle_t OutputFragmentListHandle;
#endif
  VOLATILE unsigned long MCRPhysicalAddress;
  VOLATILE unsigned long MCRState;
  VOLATILE struct MasterCommand_s *pNextMCR; /* Pointer to next in list. */
  unsigned long Index;
#if (SYS_CACHELINE_SIZE >= MCR_ALIGNMENT) 
  /***********************************************************************/
  /**** If sizeof(MasterCommandUnaligned_t)%32 is zero, the following ****/
  /**** pad array will have a subscript of zero. Under this condition ****/
  /**** the following line should be commented out.                   ****/ 
  unsigned char pad[MCR_ALIGNMENT_PAD];                                /**/
  /***********************************************************************/
#endif
} MasterCommand_t, *MasterCommand_pt;

#define NULL_MASTER_COMMAND (MasterCommand_pt) 0

#define MCR_STATE_FREE   0x00 /* Not in use. */
#define MCR_STATE_ACTIVE   0x01 /* Packets in the MCR. */
#define MCR_STATE_PUSHED 0x02 /* Pushed onto device. */

#define UBSEC_IS_SSL_DEVICE(pDevice) ((pDevice->DeviceID==BROADCOM_DEVICE_ID_5820) || (pDevice->DeviceID==BROADCOM_DEVICE_ID_5821))

#endif /*  _UBSCRYPT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubsctl.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsctl.c: Ubsec device control macro definitions.
 */

/*
 * Revision History:
 *
 * 09/15/2000 SOR Created.
 * 07/16/2001 RJT Added support for BCM5821
 */

#ifndef _UBSCTL_H_
#define _UBSCTL_H_

enum ubsDmaRegistersNumber_e {
       	dmaMCR1=0,
	dmaControl,
	dmaStatus,
	dmaError,
	dmaMCR2
};


/*
 *
 * UBSEC PCI configuration space values
 *
 */

/*
 * DMA Control and Status Registers (32 bits each index)
 */
#define  MCR_ADDRESS  		0x0
/*  Writing the address of a valid Master Command Record to this
	//	register causes processing of the packtes within that record
	//	to begin.  This register must only be written when the
	//	'MCR1_FULL' bit of the DMA Status register is '0'.
*/
#define DMA_CONTROL			0x1
#if (UBS_CPU_ATTRIBUTE == UBS_LITTLE_ENDIAN)
#define UBSEC_RESET		0x80000000
#define MCR2INT_ENABLE		0x40000000
#define MCR1INT_ENABLE		0x20000000
#define OUTPUT_FRAG_MODE	0x10000000
#define UBS_LITTLE_ENDIAN_MODE	0x0C000000  /* (do both bits at once) */
#define UBS_BIG_ENDIAN_MODE	0x04000000  /* (do both bits at once) */
#define DMAERR_ENABLE		0x02000000
#define RNG_MODE_16		0x01800000
#define RNG_MODE_08		0x01000000
#define RNG_MODE_04		0x00800000
#define RNG_MODE_01		0x00000000
#define SW_NORM_EN              0x00400000
#else
#define UBSEC_RESET		0x00000080
#define MCR2INT_ENABLE		0x00000040
#define MCR1INT_ENABLE		0x00000020
#define OUTPUT_FRAG_MODE	0x00000010
#define UBS_LITTLE_ENDIAN_MODE	0x0000000C  /* (do both bits at once) */
#define UBS_BIG_ENDIAN_MODE	0x00000004  /* (do both bits at once) */
#define DMAERR_ENABLE		0x00000002
#define RNG_MODE_16		0x00008001
#define RNG_MODE_08		0x00000001
#define RNG_MODE_04		0x00008000
#define RNG_MODE_01		0x00000000
#define SW_NORM_EN              0x00004000 

#endif
/*  bits	    purpose
//  MCRnINT_ENABLE --           Enable MCR completion interrupt (def=0)
//  Output Fragment Mode --    '0' means get output fragment
//				size from data buffer length entry
//				'1' means get output fragment size from
//				low order bits of this register (def=0)
//  UBS_X_ENDIAN_MODE fields are comprised of the following two bits:
//  LE_CRYPTONET --             Little endian mode, 32-bit words.  '0' means
//				big endian data in DMA memory.  '1' means little
//				endian data in DMA memory. Must be set to '1' for
//                              BCM580x and BCM5820 devices (def=1).
//  NORMAL_PCI --               '0' means all PCI bus master data will be
//                              internally swapped by the CryptoNet chip.
//				'1' means industry standard PCI bus endianess.
//				Must be set to '1' for BCM580x and BCM5820 
//                              devices. Normally set to '1' (def=1).
//  DMAERR_ENABLE --            Enable DMA Error interrupt (def=0)
//  Output Fragment Size --     The size, in bytes of output
//				fragments.  Only used if Output Frag
//				Mode is enabled.
*/
#define DMA_STATUS			0x2
#if (UBS_CPU_ATTRIBUTE == UBS_LITTLE_ENDIAN)
#define MCR_BUSY			0x80000000
#define MCR1_FULL			0x40000000
#define MCR1_DONE			0x20000000
#define DMA_ERROR			0x10000000
#define MCR2_FULL			0x08000000
#define MCR2_DONE			0x04000000
#define MCR1_ALL_EMPTY			0x02000000
#define MCR2_ALL_EMPTY			0x01000000
#else
#define MCR_BUSY			0x00000080
#define MCR1_FULL			0x00000040
#define MCR1_DONE			0x00000020
#define DMA_ERROR			0x00000010
#define MCR2_FULL			0x00000008
#define MCR2_DONE			0x00000004
#define MCR1_ALL_EMPTY			0x00000002
#define MCR2_ALL_EMPTY			0x00000001
#endif
/*  bits	purpose
//  MCR_BUSY --	        If set, master access is in progress.
//  MCRn_FULL --        MCRn Address register is full.  When
//			'1', do not write to MCRn Address reg.
//  MCRn_DONE -- 	Completion status of MCRn.  This bit is
//			set regardless of the MCRnINT_EN completion
//			interrupt enable bit.  This bit is 
//			sticky, and is reset to zero by writing
//			a '1'.
//  DMA_ERROR --	DMA Error status.  This bit is set
//			regardless of the DMAERR_EN interrupt
//			enable bit.  This bit is sticky, and is
//			reset to zero by writing a '1'.
//  MCRn_ALL_EMPTY -- 	If set, indicates that chip completed all
//                      MCRs that were written to MCRn, i.e. there
//                      are no pending operations. This bit is
//			set regardless of the MCRnINT_EN completion
//			interrupt enable bit.  This bit is 
//			sticky, and is reset to zero by writing
//			a '1' to either the MCRn_ALL_EMPTY bit
//                      or to the associated MCRn_DONE bit.
*/
#define  DMA_ERROR_ADDRESS      0x3
/*  bits	purpose
//  2-31	Address of master access that resulted in a PCI fault.
//		The address points to a 32bit word.
//  1		1 = fault on a read.  0 = fault on a write.
*/


/*
 * Number of device registers
 */
#define UBSEC_CRYPTO_DEVICE_REGISTERS 4
#define UBSEC_KEY_DEVICE_REGISTERS 5

#ifdef  UBSEC_PKEY_SUPPORT
#define UBSEC_MAXREGISTERS 5
#else
#define UBSEC_MAXREGISTERS 4
#endif

/*
 * Interrupt ack/enable masks. Different for each class of device.
 */
#define UBSEC_CRYPTO_DEVICE_IENABLE_MASK (MCR1INT_ENABLE | DMAERR_ENABLE)
#define UBSEC_CRYPTO_DEVICE_IACK_MASK    (MCR1_DONE | DMA_ERROR)
#define UBSEC_KEY_DEVICE_IENABLE_MASK (MCR1INT_ENABLE | MCR2INT_ENABLE | DMAERR_ENABLE)
#define UBSEC_KEY_DEVICE_IACK_MASK    (MCR1_DONE | MCR2_DONE | DMA_ERROR) 

/*
 * Read configuration control register
 */
#define UBSEC_READ_CONFIG(pDevice)  \
  OS_IOMemRead32(pDevice->ControlReg[dmaControl])

/*
 * Write configuration control register. Because we share interrupts with another device and
 * there is no way to stop the int mask we need to set the interrupt enable status
 * accordingly
 */
#define UBSEC_WRITE_CONFIG(pDevice,value)  			   \
  { pDevice->IRQEnabled=((value) & (pDevice->IntEnableMask)); \
    OS_IOMemWrite32(pDevice->ControlReg[dmaControl],value); }


#define UBSEC_IRQ_ENABLED(pDevice) \
           ((UBSEC_READ_CONFIG(pDevice) & pDevice->IntEnableMask) != 0)

/*
 * Reset the security accelerator hardware (chip). 
 */
#define UBSEC_RESET_DEVICE(pDevice) \
  { UBSEC_WRITE_CONFIG(pDevice,(UBSEC_READ_CONFIG(pDevice) | UBSEC_RESET));     \
    OS_Waitus(100000);                                                          \
    UBSEC_WRITE_CONFIG(pDevice,pDevice->ResetConfig); }

/*
 * Enable device interrupts. 
 */
#define UBSEC_ENABLE_INT(pDevice) \
  UBSEC_WRITE_CONFIG(pDevice,(UBSEC_READ_CONFIG(pDevice) | (pDevice->IntEnableMask)))

/*
 * Disable device interrupts. Because we share interrupts with another device and
 * there is no way to stop the int mask we need to set the interrupt enable status
 * accordingly
 */
#define UBSEC_DISABLE_INT(pDevice)\
  UBSEC_WRITE_CONFIG(pDevice,(UBSEC_READ_CONFIG(pDevice)&~(pDevice->IntEnableMask))) 


/*
 * Acknowledge device status
 */
#define UBSEC_ACK_INT(pDevice)\
OS_IOMemWrite32(pDevice->ControlReg[dmaStatus],OS_IOMemRead32(pDevice->ControlReg[dmaStatus]) & (pDevice->IntAckMask)) 


/*
 * Hardware marker (for logic analyzer), used for code profiling
 */
#ifdef UBSEC_HW_PROFILE_MARKER_ENABLE
#define UBSEC_HW_PROFILE_MARKER(pDevice,marker) OS_IOMemWrite32(pDevice->ControlReg[dmaError],marker) 
#else
#define UBSEC_HW_PROFILE_MARKER(pDevice,marker) 
#endif


/*
 * Acknowledge device status
 */
#define UBSEC_ACK_CONDITION(pDevice,Condition)\
OS_IOMemWrite32(pDevice->ControlReg[dmaStatus],OS_IOMemRead32(pDevice->ControlReg[dmaStatus]) & (Condition))

/*
 * Read device status
 */
#define UBSEC_READ_STATUS(pDevice) \
  OS_IOMemRead32(pDevice->ControlReg[dmaStatus])

/*
 * Write MCR address to device.
 */
#define UBSEC_WRITE_MCR(pDevice,pMCR,ListIndex) \
  OS_IOMemWrite32(pDevice->ControlReg[(ListIndex) ? dmaMCR2 : dmaMCR1 ],pMCR->MCRPhysicalAddress);


#endif /*  _UBSCTL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\Ubsdebug.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsdebug.h: Ubsec debug helper routines
 */

/*
 * Revision History:
 *
 * 09/xx/99 SOR Created.
 */

/*
 * Debug.h: Macros associated with debug.
 */

#ifndef _UBSDEBUG_H_
#define _UBSDEBUG_H_

#ifdef  UBSDBG

#ifndef Dbg_Test

#define Dbg_Test(class)           \
	((Dbg_PrintEnabled & (class))==class)
#endif /* Dbg_Test */

#ifndef Dbg_Print

#define  Dbg_Print(class, x)                    \
  do  {                                         \
    if ((Dbg_PrintEnabled & (class))==class) 			\
      DbgPrint (x);                               \
  } while (0)
#endif /* Dbg_Print */

#ifndef Dbg_Call
#define  Dbg_Call(class, function)        		 \
  {                                             \
    if ((Dbg_PrintEnabled & (class))==class) 			\
      function;                                 \
  }
#endif /* Dbg_call */

#ifndef ASSERT
#define  ASSERT(x)  \
      DbgPrint(DBG_FATAL,("Assert \"%s\" failed, file %s, line %d.\n",  \
               #x, __FILE__, __LINE__));  

#endif /* ASSERT */
#else /* UBSDBG */

#ifndef Dbg_Test
#define Dbg_Test(class) 0
#endif /* Dbg_Test */

#ifndef Dbg_Print
#define  Dbg_Print(class, x)
#endif /* Dbg_Print  */

#ifndef Dbg_Call
#define	 Dbg_Call(class, function)
#endif /*  Dbg_Call */

#ifndef ASSERT
#define  ASSERT(x)
#endif /* ASSERT */

#endif

/*
 * Classes for the Dbg_Print macro.
 */
#define DBG_ALL	   	0xffffffff
#define	DBG_INIT   	0x00000001 /* debug initialization stuff */
#define	DBG_CMD_FAIL   	0x00000002 /* Debug command failures */
#define	DBG_MD5   	0x00000004 /* Debug MD5 Code */
#define	DBG_SHA1   	0x00000008 /* Debug SHA1 Code */
#define	DBG_FATAL   	0x00000010 /* Debug FATAL conditions */
#define	DBG_VERSION   	0x00000020 /* Debug Version control */
#define DBG_CMD        (0x00000040+DBG_CMD_FAIL) /* Command failure */
#define	DBG_IRQ   	0x00000080 /* Debug IRQ */
#define	DBG_DHKEY   	0x00000200 /* Debug DH  KEY */
#define DBG_PACKET      0x00000400 /* Debug packet processing. */
#define DBG_NORM        0x00000800 /* Debug Normalization routines. */
#define	DBG_RSAKEY   	0x00001000 /* Debug RSA  KEY */
#define	DBG_DSAKEY   	0x00002000 /* Debug DSA  KEY */
#define	DBG_TEST   	0x00004000 /* Debug SelfTest  KEY */
#define DBG_MATH        0x00008000 /* MATH function debug. */
#define DBG_RNG         0x00010000 /* Random Number function debug. */
#define DBG_RESET       0x00020000 /* Indicate Device Reset event */
#define DBG_LOG         0x00040000 /* Log messages */
#define DBG_INITD       0x00080000 /* Init device */
#define	DBG_INITS_LIST 	0x00100000 /* debug initialization list structure  stuff */
#define DBG_MCR_SYNC    0x00200000 /* CPU <-> DMA MCR synchronization events */
#define DBG_CNTXT_SYNC  0x00400000 /* Context synchronization events */
#define DBG_FRAG_SYNC   0x00800000 /* Frag descr synchronization events */
#define DBG_SYNC        (DBG_MCR_SYNC | DBG_CNTXT_SYNC | DBG_FRAG_SYNC)
#define	DBG_INITS 	(DBG_INITD | DBG_INITS_LIST)
#define	DBG_KEY   	(DBG_DHKEY | DBG_RSAKEY | DBG_DSAKEY)
#define DBG_LEVEL  	(DBG_FATAL | DBG_CMD_FAIL)  

#ifndef Dbg_PrintEnabled 
#define Dbg_PrintEnabled DBG_LEVEL
#endif /* Dbg_PrintEnabled */


/* When defined, enables the UBSEC_HW_PROFILE_MARKER macro (in ubsctl.h) */
#undef UBSEC_HW_PROFILE_MARKER_ENABLE

#endif _UBSDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\Ubsdefs.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsdefs.h:  Compilation definitions
 */

/*
 * Revision History:
 *
 * 09/xx/99 SOR Created.
 * 07/06/2000 DPA Fixes for SMP operation
 * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
 * 07/16/2001 RJT Added support for BCM5821
 */

#ifndef _UBSDEFS_H_
#define _UBSDEFS_H_

/**** Constants Definitions ****/
#define UBS_LITTLE_ENDIAN 1
#define UBS_BIG_ENDIAN    2
/*******************************/

/* To allow Makefile to override endianess settings with compiler switches */
#if defined(UBS_CPU_LITTLE_ENDIAN)       
  #define UBS_CPU_ATTRIBUTE         UBS_LITTLE_ENDIAN
#elif defined(UBS_CPU_BIG_ENDIAN) 
  #define UBS_CPU_ATTRIBUTE         UBS_BIG_ENDIAN
#else
  #define UBS_CPU_ATTRIBUTE         UBS_LITTLE_ENDIAN  /* Default CPU endianess */
#endif

#if defined(UBS_CRYPTONET_LITTLE_ENDIAN) 
  #define UBS_CRYPTONET_ATTRIBUTE   UBS_LITTLE_ENDIAN
#elif defined(UBS_CRYPTONET_BIG_ENDIAN)
  #define UBS_CRYPTONET_ATTRIBUTE   UBS_BIG_ENDIAN
#else
  #define UBS_CRYPTONET_ATTRIBUTE   UBS_LITTLE_ENDIAN  /* Default CryptoNet endianess */
#endif

/* Use polling for completion instead of irq */
#undef POLL 

/* Block on completion of a single MCR request. */
#undef BLOCK

#ifdef BLOCK
  #ifndef POLL
    #define POLL
  #endif
#endif

/*
 * Operational definitions.
 * UBSEC_5xxx (Chip Type) is defined on the compiler command line (see Makefile)
 */
#if defined(UBSEC_5820)
  #define UBSEC_582x_CLASS_DEVICE
  #define MCR_MAXIMUM_PACKETS 4 /* For key performance */
#elif defined(UBSEC_5821)
  #define UBSEC_582x_CLASS_DEVICE
  #define MCR_MAXIMUM_PACKETS 4 /* For key performance */
#else
  #undef UBSEC_582x_CLASS_DEVICE
  #define MCR_MAXIMUM_PACKETS 8 /* For key performance */
#endif

#define UBSEC_MAX_FRAGMENTS 20 

#ifndef COMPLETE_ON_COMMAND_THREAD /* To allow Makefile to override. */
  #undef COMPLETE_ON_COMMAND_THREAD		/* allows SRL to attempt to complete requests in same thread as command */
#endif

#define UBSEC_STATS  /* Enable/Disable statistical information. */


/* 5820/5821 Feature set */
#ifdef UBSEC_582x_CLASS_DEVICE
  #define UBSEC_HW_NORMALIZE /* Hardware does the normalization. */
  #define UBSEC_SSL_SUPPORT 
#endif

/* 
 *  Hard enable/disable of key support. 
 *  This must be enabled for all key functions.
 */
#define UBSEC_PKEY_SUPPORT	

#ifdef UBSEC_PKEY_SUPPORT
  #define UBSEC_MATH_SUPPORT /* Can be conditional. */
  #define UBSEC_RNG_SUPPORT  /* Can be conditional. */
  #define UBSEC_DH_SUPPORT   /* Can be conditional. */
  #define UBSEC_DSA_SUPPORT  /* Can be conditional. */
  #define UBSEC_RSA_SUPPORT  /* Can be conditional. */
#endif



/*
 * STATIC_F_LIST when defined allocate memory
 * for the fragment lists as part of the MCR.
 * This is useful to minimize fragmentation of memory. However
 * since it increases the size of the MCR large MCR/packet/fragment
 * combinations (see below) can cause the allocation to fail if the
 * system does not support large DMA memory allocations. When undefined
 * separate memory blocks are used in the memory allocation and these
 * allow the memory allocation to succeed.
 */
#undef STATIC_F_LIST

/* Allocate MCRs contiguously */
#undef CONTIG_MCR

/* Cacheline size of target platform.                        */
/* A value of zero disables struct alignment optimizations.  */
/* If enabled (!=0), OS_AllocateDMAMemory() must allocate    */
/* memory blocks aligned to a cacheline boundary.            */
#define SYS_CACHELINE_SIZE 64     

#endif  /* _UBSDEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\CConfigInfoDbgParser\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CConfigInfoDbgParser")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("CConfigInfoDbgParser")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6410daae-15eb-4a3a-8d8f-22fecdf137a5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubsincl.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsincl.h:  ubsec main include file
 */

/*
 * Revision History:
 *
 * 09/xx/99 SOR Created.
 */

#ifndef _UBSINCL_H_
#define _UBSINCL_H_

#include "ubsdefs.h"
#include "ubssys.h"
#include "ubsdebug.h"
#include "ubsec.h"
#include "ubskey.h"
#include "ubscrypt.h"
#include "ubsctl.h"
#include "ubsstruc.h"
#include "ubssha1.h"
#include "ubsmd5.h"
#include "ubsextrn.h"

#endif _UBSINCL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubsextrn.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsextrn.h:  ubsec internal function prototype and variable declarations
 */

/*
 * Revision History:
 *
 * 09/xx/99 SOR Created.
 */

#ifndef _UBSEXTRN_H_
#define _UBSEXTRN_H_

/*
 * Function prototype defintions.
 */
extern void completion_handler( void* p_void );
extern DeviceInfo_pt AllocDeviceInfo(unsigned long DeviceID,int NumberOfCipherMCRs,int NumberOfKeyMCRs,OS_DeviceInfo_t OSContext);
extern void  FreeDeviceInfo(DeviceInfo_pt pDevice );
extern ubsec_Status_t SetupInputFragmentList(MasterCommand_pt  pMCR,
		       Packet_pt pPacket,
		       int NumSource,
		       ubsec_FragmentInfo_pt SourceFragments);
extern ubsec_Status_t SetupOutputFragmentList(MasterCommand_pt  pMCR,
			Packet_pt pPacket,
			int NumFrags,
			ubsec_FragmentInfo_pt DestinationFragments,
			ubsec_FragmentInfo_pt pExtraFragment);
extern void revBytes(void *st, int len);
extern unsigned long  rol(unsigned long x, int n);
extern void copywords(unsigned long *out, unsigned long *in,int num);
extern void InitSHA1State(ubsec_HMAC_State_pt HMAC_State,unsigned char *HashBlock);
extern void InitMD5State(ubsec_HMAC_State_pt HMAC_State,unsigned char *HashKey);
extern int WaitForCompletion(DeviceInfo_pt pDevice,unsigned long blockus,unsigned long MCRListIndex);
extern void Dump_Registers(DeviceInfo_pt pDevice,int dbg_flag);
extern void ubsec_DumpDeviceInfo(ubsec_DeviceContext_t Context);
extern void PushMCR(DeviceInfo_pt pDevice);
extern void FlushDevice(DeviceInfo_pt pDevice,ubsec_Status_t Status,unsigned int type);
extern int dump_MCR(DeviceInfo_pt pDevice,MasterCommand_pt pMCR,unsigned long MCRListIndex);
extern ubsec_Status_t DH_SetupPublicParams(MasterCommand_pt pMCR, ubsec_DH_Params_pt pDHParams);
extern ubsec_Status_t DH_SetupSharedParams(MasterCommand_pt pMCR, ubsec_DH_Params_pt pDHParams);
extern ubsec_Status_t RSA_SetupPublicParams(MasterCommand_pt pMCR, ubsec_RSA_Params_pt pRSAParams);
extern ubsec_Status_t RSA_SetupPrivateParams(MasterCommand_pt pMCR, ubsec_RSA_Params_pt pRSAParams);
extern ubsec_Status_t DSA_SetupSignParams(MasterCommand_pt pMCR, ubsec_DSA_Params_pt pDSAParams);
extern ubsec_Status_t DSA_SetupVerifyParams(MasterCommand_pt pMCR, ubsec_DSA_Params_pt pDSAParams);
extern MasterCommand_pt GetFreeMCR(  DeviceInfo_pt pDevice,int MCRList,ubsec_Status_t *Status);
extern void KeyUnShiftResult(unsigned long Context,ubsec_Status_t Result);



/*
 * External variable definitions.
 */

#endif  _UBSEXTRN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubskey.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubskey.h: ubsec key specific context definitions.
 *
 * The BCM5805 was previously called the uB5601
 * This file was previously ubs5805.h
 * This file contains all the structure definitions for the key functions
 * of the 58xx chip family
 */

/*
 * Revision History:
 *
 * 09/21/2000 SOR Created from PW-5805.h
 * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
 * 04/24/2001 DPA Allow for unnormalize of D-H random number (x) output for BCM5805
 * 07/16/2001 RJT Added support for BCM5821
 */


#ifndef _UBSKEY_H_
#define _UBSKEY_H_


/* Context Buffer Operation type */
#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
#define OPERATION_DH_PUBLIC    	0x0001
#define OPERATION_DH_SHARED    	0x0002
#define OPERATION_RSA_PUBLIC   	0x0003
#define OPERATION_RSA_PRIVATE  	0x0004
#define OPERATION_DSA_SIGN   	0x0005
#define OPERATION_DSA_VERIFY  	0x0006
#define OPERATION_RNG_DIRECT   	0x0041
#define OPERATION_RNG_SHA1     	0x0042
#define OPERATION_MOD_ADD   	0x0043
#define OPERATION_MOD_SUB     	0x0044
#define OPERATION_MOD_MULT   	0x0045
#define OPERATION_MOD_REDUCT   	0x0046
#define OPERATION_MOD_EXPON   	0x0047
#define OPERATION_MOD_INVERSE  	0x0048
#else
#define OPERATION_DH_PUBLIC    	0x0100
#define OPERATION_DH_SHARED    	0x0200
#define OPERATION_RSA_PUBLIC   	0x0300
#define OPERATION_RSA_PRIVATE  	0x0400
#define OPERATION_DSA_SIGN   	0x0500
#define OPERATION_DSA_VERIFY  	0x0600
#define OPERATION_RNG_DIRECT   	0x4100
#define OPERATION_RNG_SHA1     	0x4200
#define OPERATION_MOD_ADD   	0x4300
#define OPERATION_MOD_SUB     	0x4400
#define OPERATION_MOD_MULT   	0x4500
#define OPERATION_MOD_REDUCT   	0x4600
#define OPERATION_MOD_EXPON   	0x4700
#define OPERATION_MOD_INVERSE  	0x4800
#endif

#define NULL_KEY_CONTEXT (KeyContext_pt) 0

/* Context buffer */
/* Different algorithms have different context command buffers */

#ifdef UBSEC_582x_CLASS_DEVICE
#define MAX_KEY_LENGTH_BITS 2048
#else
#define MAX_KEY_LENGTH_BITS 1024
#endif

#define MAX_KEY_LENGTH_BYTES (MAX_KEY_LENGTH_BITS/8)
#define MAX_KEY_LENGTH_WORDS (MAX_KEY_LENGTH_BITS/32)

/* These lengths are defined as longs. */
#define MAX_MODULUS_LENGTH      MAX_KEY_LENGTH_WORDS 	
#define MAX_GENERATOR_LENGTH   	MAX_KEY_LENGTH_WORDS
#define MAX_EXPON_LENGTH        MAX_KEY_LENGTH_WORDS
#define MAX_DP_LENGTH           MAX_KEY_LENGTH_WORDS
#define MAX_DQ_LENGTH           MAX_KEY_LENGTH_WORDS
#define MAX_PRIME_LENGTH        MAX_KEY_LENGTH_WORDS
#define MAX_PRINV_LENGTH        MAX_KEY_LENGTH_WORDS
#define MAX_PRIME_LENGTH        MAX_KEY_LENGTH_WORDS
#define MAX_PRI_KEY_LENGTH      MAX_KEY_LENGTH_WORDS
#define MAX_PUB_KEY_LENGTH      MAX_KEY_LENGTH_WORDS

#define DH_STATIC_SEND_CONTEXT_SIZE (6*sizeof(unsigned short))
/*Diffie-Hellman Send*/
typedef struct DH_Send_CtxCmdBuf_struct {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short rng_enable;	       /* Private key x RNG or SW  */ 
  VOLATILE unsigned short private_key_length;  /* Priv key x len in bits   */
  VOLATILE unsigned short generator_length;    /* Generator g len in bits  */
  VOLATILE unsigned short modulus_length;      /* Modulus N Len in bits    */
#else
  VOLATILE unsigned short private_key_length;  /* Priv key x len in bits   */
  VOLATILE unsigned short rng_enable;	       /* Private key x RNG or SW  */ 
  VOLATILE unsigned short modulus_length;      /* Modulus N Len in bits    */
  VOLATILE unsigned short generator_length;    /* Generator g len in bits  */
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long Ng[MAX_MODULUS_LENGTH+MAX_GENERATOR_LENGTH];
			 /* Private key is stored in the data buffer */	
} DH_Send_CtxCmdBuf_t, *DH_Send_CtxCmdBuf_pt;

#define DH_STATIC_REC_CONTEXT_SIZE (4*sizeof(unsigned short))
/*Diffie-Hellman Receive*/
typedef struct DH_REC_CtxCmdBuf_struct {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short private_key_length;  /* Private key length in bits */
  VOLATILE unsigned short modulus_length;      /* Modulus N Length in bits   */
#else
  VOLATILE unsigned short modulus_length;      /* Modulus N Length in bits   */
  VOLATILE unsigned short private_key_length;  /* Private key length in bits */
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long N[MAX_MODULUS_LENGTH];  /* Modulus N  */
} DH_REC_CtxCmdBuf_t, *DH_REC_CtxCmdBuf_pt;

/*Public Key RSA*/
#define RSA_STATIC_PUBLIC_CONTEXT_SIZE (4*sizeof(unsigned short))
typedef struct Pub_RSA_CtxCmdBuf_struct {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short exponent_length;   /* Exponent E length in bits */
  VOLATILE unsigned short modulus_length;    /* Modulus N Length in bits  */
#else
  VOLATILE unsigned short modulus_length;    /* Modulus N Length in bits  */
  VOLATILE unsigned short exponent_length;   /* Exponent E length in bits */
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long Ng[2*MAX_MODULUS_LENGTH]; /* Modulus N and g fields */
} Pub_RSA_CtxCmdBuf_t, *Pub_RSA_CtxCmdBuf_pt;

/*Public Key RSA*/
#define RSA_STATIC_PRIVATE_CONTEXT_SIZE  (4*sizeof(unsigned short))
  typedef struct Pri_RSA_CtxCmdBuf_struct {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short q_length; 	         /* Prime q length in bits */
  VOLATILE unsigned short p_length; 		 /* Prime p Length in bits */
#else
  VOLATILE unsigned short p_length; 		 /* Prime p Length in bits */
  VOLATILE unsigned short q_length; 	         /* Prime q length in bits */
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long CtxParams[MAX_PRIME_LENGTH+MAX_PRIME_LENGTH+MAX_DP_LENGTH+MAX_DQ_LENGTH+MAX_PRINV_LENGTH];
} Pri_RSA_CtxCmdBuf_t, *Pri_RSA_CtxCmdBuf_pt;

/*DSA signing */
#define DSA_STATIC_SIGN_CONTEXT_SIZE  (6*sizeof(unsigned short))
typedef struct DSA_Sign_CtxCmdBuf_struct {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
  VOLATILE unsigned short Reserved;	 /*                                 */
  VOLATILE unsigned short rng_enable;	 /* Private key x by RNG or SW      */ 
  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
#else
  VOLATILE unsigned short Reserved;	 /*                                 */
  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
  VOLATILE unsigned short rng_enable;	 /* Private key x by RNG or SW      */ 
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long CtxParams[4*MAX_MODULUS_LENGTH]; /* q,p,g,x */
} DSA_Sign_CtxCmdBuf_t, *DSA_Sign_CtxCmdBuf_pt;

/*DSA Verification */
#define DSA_STATIC_VERIFY_CONTEXT_SIZE  (6*sizeof(unsigned short))
typedef struct DSA_Verify_CtxCmdBuf_struct {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
  VOLATILE unsigned short Reserved;	 /*                                 */
  VOLATILE unsigned short Reserved2;     /* not used                        */
  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
#else
  VOLATILE unsigned short Reserved;	 /*                                 */
  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
  VOLATILE unsigned short Reserved2;     /* not used                        */
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long CtxParams[4*MAX_MODULUS_LENGTH]; /* q,p,g,y */
} DSA_Verify_CtxCmdBuf_t, *DSA_Verify_CtxCmdBuf_pt;

/* RNG Bypass */
#define RNG_STATIC_CONTEXT_SIZE 64
typedef struct RNG_CtxCmdBuf_struct {
  unsigned long none;
} RNG_CtxCmdBuf_t, *RNG_CtxCmdBuf_pt;


/* Generic math context buffer, Exp is only used for ModInv */
#define MATH_STATIC_CONTEXT_SIZE  (4*sizeof(unsigned short))
typedef struct Math_CtxCmdBuf_struct {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short exponent_length; /* Exponent (N-2) length in bits */
                                           /* 0 when not present            */
  VOLATILE unsigned short modulus_length;  /* Modulus N Length in bits 	    */
#else
  VOLATILE unsigned short modulus_length;  /* Modulus N Length in bits 	    */
  VOLATILE unsigned short exponent_length; /* Exponent (N-2) length in bits */
                                           /* 0 when not present            */
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE unsigned long NE[2*MAX_MODULUS_LENGTH];  /* Modulus N            */
} Math_CtxCmdBuf_t, *Math_CtxCmdBuf_pt;

typedef union CtxCmdBuf_u {
	DH_Send_CtxCmdBuf_t		DH_Send_CtxCmdBuf;
	DH_REC_CtxCmdBuf_t		DH_REC_CtxCmdBuf;
	Pub_RSA_CtxCmdBuf_t		Pub_RSA_CtxCmdBuf;
	Pri_RSA_CtxCmdBuf_t		Pri_RSA_CtxCmdBuf;
	DSA_Sign_CtxCmdBuf_t		DSA_Sign_CtxCmdBuf;
	DSA_Verify_CtxCmdBuf_t		DSA_Verify_CtxCmdBuf;
        RNG_CtxCmdBuf_t		        RNG_CtxCmdBuf;
	Math_CtxCmdBuf_t		Math_CtxCmdBuf;
    } CtxCmdBuf_t, *CtxCmdBuf_pt ; 

typedef struct KeyContextUnaligned_s {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short 	  cmd_structure_length;
  VOLATILE unsigned short 	  operation_type; 
#else
  VOLATILE unsigned short 	  operation_type; 
  VOLATILE unsigned short 	  cmd_structure_length;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE CtxCmdBuf_t  CtxCmdBuf;
  VOLATILE unsigned long  	  PhysicalAddress;
  /* The following fields are used as redirection when
     renormailization is required after a key operation. */
  void(*UserCallback)(unsigned long Context,ubsec_Status_t Result);
  unsigned long	UserContext;
  long NormBits;
  ubsec_LongKey_t ResultKey;
  ubsec_LongKey_t ResultRNG;
} KeyContextUnaligned_t;

#define KEYCONTEXT_ALIGNMENT 64 /* Boundary to which KeyContexts will be aligned. Must be power of 2 */

#if (SYS_CACHELINE_SIZE >= KEYCONTEXT_ALIGNMENT) 
  #define KEYCONTEXT_ALIGNMENT_PAD (KEYCONTEXT_ALIGNMENT - (sizeof(KeyContextUnaligned_t) & (KEYCONTEXT_ALIGNMENT-1)))
#else
  #undef KEYCONTEXT_ALIGNMENT_PAD
#endif

/***********************************************************************/
/* Hardware (DMA) version of above structure that is 'alignably' sized */
/* (an integer multiple of KEYCONTEXT_ALIGNMENT bytes in length).      */
/* Any changes made to either structure must be mirrored in the other  */
/***********************************************************************/

typedef struct KeyContext_s {
#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
  VOLATILE unsigned short 	  cmd_structure_length;
  VOLATILE unsigned short 	  operation_type; 
#else
  VOLATILE unsigned short 	  operation_type; 
  VOLATILE unsigned short 	  cmd_structure_length;
#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
  VOLATILE CtxCmdBuf_t  CtxCmdBuf;
  VOLATILE unsigned long  	  PhysicalAddress;
  /* The following fields are used as redirection when
     renormailization is required after a key operation. */
  void(*UserCallback)(unsigned long Context,ubsec_Status_t Result);
  unsigned long	UserContext;
  long NormBits;
  ubsec_LongKey_t ResultKey;
  ubsec_LongKey_t ResultRNG;
#if (SYS_CACHELINE_SIZE >= KEYCONTEXT_ALIGNMENT) 
  /***********************************************************************/
  /**** If KeyContextUnaligned_t is cacheline sized, the following    ****/
  /**** pad array will have a subscript of zero. Under this condition ****/
  /**** the following line should be commented out.                   ****/ 
  unsigned char pad[KEYCONTEXT_ALIGNMENT_PAD];                        /***/
  /***********************************************************************/
#endif
} KeyContext_t, *KeyContext_pt;

#define NULL_KEY_CONTEXT (KeyContext_pt) 0

#define UBSEC_IS_KEY_DEVICE(pDevice) ((UBSEC_IS_CRYPTO_DEVICEID(pDevice->DeviceID))==0) 

#endif /* _UBSKEY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubssha1.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubssha1.h: 
 */

/*
 * Revision History:
 *
 */

#ifndef _UBSSHA_H_
#define _UBSSHA_H_

/* define the following line to get FIPS 180-1 enhancements */
#define SHA_UPDATE

#define SHA_BLOCK_LENGTH  64		/* in bytes */
#define SHA_HASH_LENGTH   20		/* in bytes */

typedef unsigned char BYTE;


typedef struct {
    unsigned long Numbytes;
    unsigned long Numblocks[2];  /* each block contains 64 bytes */
    unsigned long Mblock[16];
    unsigned long buffer[5];
} SHA_CTX;


#endif /*_SHA_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubsec.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsec.h: Interface functions and defintions for the ubsec Software Reference
 * library.
 *
 * This file should be included by any files using the UBSEC 5501 SRL
 */

/*
 * Revision History:
 *
 *  Oct 99 SOR Created.
 *  Sep 00 SOR 5820 Support Added.
 *  Jul 01 RJT 5821 Support Added (1.2a)
 */

#ifndef _UBSEC_H_
#define _UBSEC_H_

/*
 * List of Vendor/Device IDs supported by the library.
 */
#define BSN_VENDOR_ID       0x15AB  /* Bluesteel Networks Vendor ID */
#define BSN_DEVICE_ID_5501  0x0     /* 5501 Proto board */
#define BSN_DEVICE_ID_5601  0x5601  /* 5601 Proto board */
#define BROADCOM_VENDOR_ID  0x14e4  /* Broadcom vendor ID */
#define BROADCOM_DEVICE_ID_5801  0x5801 /* Release board. */
#define BROADCOM_DEVICE_ID_5802  0x5802 /* Release board. */
#define BROADCOM_DEVICE_ID_5805  0x5805 /* Release board  */
#define BROADCOM_DEVICE_ID_5820  0x5820 /* Release board  */
#define BROADCOM_DEVICE_ID_5821  0x5821 /* Release board  */

/* Macro to determine device type based on deviceID */
#define UBSEC_IS_CRYPTO_DEVICEID(DeviceID) ((DeviceID) == BROADCOM_DEVICE_ID_5801)

/* 
 * Version of the SRL.
 */
#define UBSEC_VERSION_MAJOR 0x1
#define UBSEC_VERSION_MINOR 0x2
#define UBSEC_VERSION_REV   'c'


/*
 * Cryptographic parameter definitions
 */
#define UBSEC_DES_KEY_LENGTH 2    /* long */
#define UBSEC_3DES_KEY_LENGTH 6   /* long */
#define UBSEC_MAX_CRYPT_KEY_LENGTH UBSEC_3DES_KEY_LENGTH
#define UBSEC_IV_LENGTH		2 /* long */
#define UBSEC_IV_LENGTH_BYTES	8

#define UBSEC_MAC_KEY_LENGTH	64 /* Bytes */
#define UBSEC_MD5_LENGTH	16 /* Bytes */
#define UBSEC_SHA1_LENGTH	20 /* Bytes */
#define UBSEC_HMAC_LENGTH   20 /* Max of MD5/SHA1 */


/*
 * HMAC State type defines the current (inner/outer)
 * Hash state values. 
 */
typedef struct ubsec_HMAC_State_s {
  unsigned char	InnerState[UBSEC_HMAC_LENGTH];
  unsigned char	OuterState[UBSEC_HMAC_LENGTH];
} ubsec_HMAC_State_t, *ubsec_HMAC_State_pt;


/* 
 * Generic Fragment information type. Length
 * and physical address of fragment defined
 * here.
 */
typedef struct ubsec_FragmentInfo_s {
  int FragmentLength;            /* Length of the fragment. */
  unsigned long FragmentAddress; /* Physical address */
} ubsec_FragmentInfo_t, *ubsec_FragmentInfo_pt;


/*
 * HMAC Block type. Used to generate a HMAC state which is
 * passed to the API.
 */
typedef unsigned char ubsec_HMAC_Block_t[UBSEC_MAC_KEY_LENGTH],*ubsec_HMAC_Block_pt;

/*
 * HMAC Block type. Used to generate a HMAC state which is
 * passed to the API.
 */
typedef unsigned char ubsec_HMAC_Key_t[UBSEC_MAC_KEY_LENGTH],*ubsec_HMAC_Key_pt;

/*
 * Initial Vector type for CBC operations.
 */
typedef long  ubsec_IV_t[UBSEC_IV_LENGTH], *ubsec_IV_pt;

/*
 * DES Key type definitions.
 */

/* Single DES Crypt key type. 3DES operation used 3 of these. */
typedef long ubsec_CryptKey_t[UBSEC_DES_KEY_LENGTH], *ubsec_CryptKey_pt;

/* Cipher command type defines Cipher/Authentication operation. */
typedef long ubsec_CipherCommand_t;

/* Status code is used by the SRL to indicate status */
typedef long ubsec_Status_t;

/*
 * Device_Context is handle for all ubsec device operations. It
 * is assigned at initialization time.
 */
typedef void *ubsec_DeviceContext_t, **ubsec_DeviceContext_pt;


/*
 * Cipher command struture defines the parameters of a cipher
 * command, its input and output data areas along with the 
 * context.
 */
typedef struct ubsec_CipherCommandInfo_s {
  ubsec_CipherCommand_t   	Command;  /* Operation(s) to perform */
  ubsec_IV_pt	   	        InitialVector;   /* IV for CBC operation. */
  ubsec_CryptKey_pt 	        CryptKey;         /* For CBC operation. */
  ubsec_HMAC_State_pt            HMACState;    /*  Initialized HMAC state for authentication. */
  unsigned NumSource;                    /* Number of source fragments. */
  ubsec_FragmentInfo_pt 	SourceFragments; /* Source fragment list */
  unsigned long 		NumDestination;  /* Number of Destination fragments. */
  ubsec_FragmentInfo_pt         DestinationFragments;    /* Destination fragment list */
  ubsec_FragmentInfo_t          AuthenticationInfo;       /* Authentication output location . */
  unsigned short   		 CryptHeaderSkip; /* Size of crypt header to skip. */
  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
  unsigned long	   		 CommandContext;    /* Context (ID) of this command). */
  } ubsec_CipherCommandInfo_t,*ubsec_CipherCommandInfo_pt;


/*
 * Cipher Command subtype flags.
 */
#define UBSEC_ENCODE		1
#define UBSEC_DECODE		2
#define UBSEC_3DES		4
#define UBSEC_DES		8
#define UBSEC_MAC_MD5		16
#define UBSEC_MAC_SHA1		32

/*
 *	Command field definitions.
 */
#define UBSEC_ENCODE_3DES (UBSEC_ENCODE+UBSEC_3DES)
#define UBSEC_DECODE_3DES (UBSEC_DECODE+UBSEC_3DES)
#define UBSEC_ENCODE_DES  (UBSEC_ENCODE+UBSEC_DES)
#define UBSEC_DECODE_DES  (UBSEC_DECODE+UBSEC_DES)

#define UBSEC_ENCODE_3DES_MD5   (UBSEC_ENCODE_3DES+UBSEC_MAC_MD5)
#define UBSEC_DECODE_3DES_MD5   (UBSEC_DECODE_3DES+UBSEC_MAC_MD5)
#define UBSEC_ENCODE_3DES_SHA1  (UBSEC_ENCODE_3DES+UBSEC_MAC_SHA1)
#define UBSEC_DECODE_3DES_SHA1  (UBSEC_DECODE_3DES+UBSEC_MAC_SHA1)
#define UBSEC_ENCODE_DES_MD5	(UBSEC_ENCODE_DES+UBSEC_MAC_MD5)
#define UBSEC_DECODE_DES_MD5	(UBSEC_DECODE_DES+UBSEC_MAC_MD5)
#define UBSEC_ENCODE_DES_SHA1	(UBSEC_ENCODE_DES+UBSEC_MAC_SHA1)
#define UBSEC_DECODE_DES_SHA1	(UBSEC_DECODE_DES+UBSEC_MAC_SHA1)

#define UBSEC_USING_CRYPT(f) ( (f) & (UBSEC_3DES | UBSEC_DES) )
#define UBSEC_USING_MAC(f)   ( (f) & (UBSEC_MAC_MD5 | UBSEC_MAC_SHA1) )

/*
 * Status codes
 */
#define UBSEC_STATUS_SUCCESS      0
#define UBSEC_STATUS_NO_DEVICE  -1
#define UBSEC_STATUS_TIMEOUT     -2
#define UBSEC_STATUS_INVALID_PARAMETER     -3
#define UBSEC_STATUS_DEVICE_FAILED   -4
#define UBSEC_STATUS_DEVICE_BUSY   -5
#define UBSEC_STATUS_NO_RESOURCE   -6
#define UBSEC_STATUS_CANCELLED   -7

  /* 
   * SRL  API function prototypes.
   */
#ifndef OS_DeviceInfo_t
#define OS_DeviceInfo_t void *
#endif

#ifndef OS_MemHandle_t
#define OS_MemHandle_t void *
#endif

#ifndef UBSECAPI
#define UBSECAPI
#endif

  /* Initialize the device */
UBSECAPI ubsec_Status_t
ubsec_InitDevice(unsigned short DeviceID,
		 unsigned long BaseAddress,
		 unsigned int irq,
		 unsigned int CipherPipeLineDepth,
		 unsigned int KeyPipeLineDepth,
		 ubsec_DeviceContext_pt Context,
		 OS_DeviceInfo_t OSContext);

/*
 * Perform self test of device.
 */
UBSECAPI ubsec_Status_t
ubsec_TestCryptoDevice(ubsec_DeviceContext_t Context,void(*CompletionCallback)(unsigned long PacketContext,ubsec_Status_t Result),unsigned long CompletionContext);

UBSECAPI ubsec_Status_t
ubsec_TestKeyDevice(ubsec_DeviceContext_t Context,void(*CompletionCallback)(unsigned long PacketContext,ubsec_Status_t Result),unsigned long CompletionContext);


  /* Reset the device */
UBSECAPI ubsec_Status_t
ubsec_ResetDevice( ubsec_DeviceContext_t Context);

  /* Shutdown the device. */
UBSECAPI ubsec_Status_t
ubsec_ShutdownDevice( ubsec_DeviceContext_t Context);

  /* Enable device interrupts */
ubsec_Status_t
ubsec_EnableInterrupt( ubsec_DeviceContext_t Context);

  /* Disable device interrupts */
unsigned long
ubsec_DisableInterrupt( ubsec_DeviceContext_t Context);

  /* Poll device for completion of commands */
ubsec_Status_t
ubsec_PollDevice( ubsec_DeviceContext_t Context);

  /* Cipher command execute function. */
UBSECAPI ubsec_Status_t
ubsec_CipherCommand(ubsec_DeviceContext_t Context,
		    ubsec_CipherCommandInfo_pt command,
		    int *NumCommands);

  /* Initialize HMAC state */
UBSECAPI ubsec_Status_t
ubsec_InitHMACState(ubsec_HMAC_State_pt HMAC_State,
	      ubsec_CipherCommand_t type,
	      ubsec_HMAC_Key_pt Key) ;

/* ISR functions are here to allow direct call
   by the wrapper. */
UBSECAPI long ubsec_ISR(ubsec_DeviceContext_t Context);
UBSECAPI void ubsec_ISRCallback(ubsec_DeviceContext_t Context);

/*
 *
 * Public key operational definitions.
 *
 */


/*
 * The long key type is used as a generic type to hold public
 * key information.
 */

typedef struct ubsec_LongKey_s {
  unsigned long	KeyLength;	/* length in bits */
  OS_MemHandle_t  KeyValue;	/* pointer to byte containing LSB */
} ubsec_LongKey_t,*ubsec_LongKey_pt;


/*
 * Diffie-Hellman parameter type definition.
 */
typedef struct ubsec_DH_Params_t {
  ubsec_LongKey_t Y;		/* Public value, in (UBSEC_DH_SHARED), out (UBSEC_DH_PUBLIC) */
  ubsec_LongKey_t X;		/* Secret value, in (UBSEC_DH_SHARED), out (UBSEC_DH_PUBLIC) */
  ubsec_LongKey_t K;		/* Shared secret value, out (UBSEC_DH_SHARED) */
  ubsec_LongKey_t N;   		/* Modulus, in (UBSEC_DH_SHARED), out (UBSEC_DH_PUBLIC) */
  ubsec_LongKey_t G;	  	/* Generator, in (UBSEC_DH_PUBLIC) */
  ubsec_LongKey_t UserX;  	/* Optional user supplied secret value, in (UBSEC_DH_PUBLIC) */
  unsigned short RandomKeyLen;	/* Random key length*/
  unsigned short RNGEnable;	/* Generate random secret value if set, ignore user supplied. */
} ubsec_DH_Params_t,*ubsec_DH_Params_pt;


/*
 * RSA parameter type definition.
 */
typedef struct ubsec_RSA_Params_t {
  ubsec_LongKey_t OutputKeyInfo; /* Output data. */
  ubsec_LongKey_t InputKeyInfo;  /* Input data. */
  ubsec_LongKey_t ModN;      /* Modulo N value to be applied */
  ubsec_LongKey_t ExpE;      /* BaseG value to be applied. */
  ubsec_LongKey_t PrimeP;    /* Prime P value */
  ubsec_LongKey_t PrimeQ;    /* Prime Q value */
  ubsec_LongKey_t PrimeEdp;  /* Private exponent edp. */
  ubsec_LongKey_t PrimeEdq;  /* Private exponent edq.  */
  ubsec_LongKey_t Pinv;      /* Pinv value. */
} ubsec_RSA_Params_t,*ubsec_RSA_Params_pt;



/*
 * DSA parameter type definition.
 */
typedef struct ubsec_DSA_Params_t {
  unsigned int NumInputFragments;  /* Number of source fragments. */
  ubsec_LongKey_pt pInputKeyInfo; /* Input data. */
  ubsec_LongKey_t SigR;		/* Signature R value (input on verify, output on sign) */
  ubsec_LongKey_t SigS;		/* Signature S value (input on verify, output on sign) */
  ubsec_LongKey_t ModQ;   	/* Modulo Q value to be applied */
  ubsec_LongKey_t ModP;   	/* Modulo P value to be applied */
  ubsec_LongKey_t BaseG;  	/* BaseG value to be applied. */
  ubsec_LongKey_t Key;    	/* User supplied public (verify) or private (sign) key. */
  ubsec_LongKey_t Random; 	/* Random value optionally provided by user (sign) */
  ubsec_LongKey_t V;		/* Verification value (verify) */
  unsigned short RandomLen; 	/* Random value length (sign) */
  unsigned short RNGEnable;    	/* Random value generated on-chip. (sign) */
  unsigned short HashEnable;    /* Enable Chip hash */
} ubsec_DSA_Params_t,*ubsec_DSA_Params_pt;

/* 
 * Generic key command parameters
 */
typedef union ubsec_KeyCommandParams_u {
  ubsec_DH_Params_t DHParams;    /* DH parameters  */
  ubsec_RSA_Params_t RSAParams;  /* RSA Parameters */
  ubsec_DSA_Params_t DSAParams;  /* RSA Parameters */
} ubsec_KeyCommandParams_t,*ubsec_KeyCommandParams_pt;



/* Key command type defines Public key operation. */
typedef long ubsec_KeyCommand_t;


/* Key command types. */
#define UBSEC_DH          0x0001
#define UBSEC_RSA         0x0002
#define UBSEC_DSA         0x0004
#define UBSEC_KEY_PRIVATE 0x0010
#define UBSEC_KEY_PUBLIC  0x0020
#define UBSEC_SIGN        0x0040
#define UBSEC_VERIFY      0x0080

#define UBSEC_DH_PUBLIC    	(UBSEC_DH+UBSEC_KEY_PUBLIC)
#define UBSEC_DH_SHARED    	(UBSEC_DH+UBSEC_KEY_PRIVATE)
#define UBSEC_RSA_PUBLIC   	(UBSEC_RSA+UBSEC_KEY_PUBLIC)
#define UBSEC_RSA_PRIVATE  	(UBSEC_RSA+UBSEC_KEY_PRIVATE)
#define UBSEC_DSA_SIGN     	(UBSEC_DSA+UBSEC_SIGN)
#define UBSEC_DSA_VERIFY   	(UBSEC_DSA+UBSEC_VERIFY)

/*
 * Key command struture defines the parameters of a cipher
 * command, its input and output data areas along with the 
 * context.
 */
typedef struct ubsec_KeyCommandInfo_s {
  ubsec_KeyCommand_t   	Command;  /* Operation(s) to perform */
  ubsec_KeyCommandParams_t Parameters;  /* Associated parameters. */
  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
  unsigned long	 CommandContext;    /* Context (ID) of this command). */
  } ubsec_KeyCommandInfo_t,*ubsec_KeyCommandInfo_pt;

  /* Key command execute function. */
UBSECAPI ubsec_Status_t
ubsec_KeyCommand(ubsec_DeviceContext_t Context,
		    ubsec_KeyCommandInfo_pt command,
		    int *NumCommands);

/* 
 * Key normalization maniputaltion functions.
 */
long ubsec_NormalizeDataTo(ubsec_LongKey_pt pData,int NormalizeLen);
void ubsec_ShiftData(ubsec_LongKey_pt pData,long ShiftBits );

/* 
 * Generic Math command parameters. Parameters vary with the
 * command type.
 */
typedef struct  ubsec_MathCommandParams_s {
  ubsec_LongKey_t ModN;   	/* Modulo N value to be applied */
  ubsec_LongKey_t ExpE;   	/* Exponent E value to be applied (ModInv only) */
  ubsec_LongKey_t ParamA;   	/* Input Parameter 1 */
  ubsec_LongKey_t ParamB;   	/* Input Parameter 2  (Not used in ModRem and ModInv) */
  ubsec_LongKey_t Result;   	/* Of math operation. */
} ubsec_MathCommandParams_t,*ubsec_MathCommandParams_pt;

/* Math command type defines Math acceleration operation. */
typedef long ubsec_MathCommand_t;

/* Math command types. */
#define UBSEC_MATH_MODADD    0x0001
#define UBSEC_MATH_MODSUB    0x0002
#define UBSEC_MATH_MODMUL    0x0004
#define UBSEC_MATH_MODEXP    0x0008
#define UBSEC_MATH_MODREM    0x0010
#define UBSEC_MATH_MODINV    0x0020
#define UBSEC_MATH_DBLMODEXP 0x0040

/*
 * Math command struture defines the parameters of a Math
 * command, its input and output data areas along with the 
 * context.
 */
typedef struct ubsec_MathCommandInfo_s {
  ubsec_MathCommand_t   	Command;  /* Operation(s) to perform */
  ubsec_MathCommandParams_t Parameters;  /* Associated parameters. */
  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
  unsigned long	 CommandContext;    /* Context (ID) of this command). */
  } ubsec_MathCommandInfo_t,*ubsec_MathCommandInfo_pt;

/*
 * Math acceleration command function.
 */
UBSECAPI ubsec_Status_t 
ubsec_MathCommand(ubsec_DeviceContext_t Context,
	      ubsec_MathCommandInfo_pt pCommand,
	      int *NumCommands);


/* 
 * Random number gerneration parameters
 */
typedef struct  ubsec_RNGCommandParams_s {
  ubsec_LongKey_t Result;   	/* Of RNG operation. */
} ubsec_RNGCommandParams_t,*ubsec_RNGCommandParams_pt;

/* RNG command type defines RNG acceleration operation. */
typedef long ubsec_RNGCommand_t;

/* RNG command types. */
#define UBSEC_RNG_DIRECT 0x0001
#define UBSEC_RNG_SHA1   0x0002

/*
 * RNG command struture defines the parameters of a RNG
 * command, its input and output data areas along with the 
 * context.
 */
typedef struct ubsec_RNGCommandInfo_s {
  ubsec_RNGCommand_t   	Command;  /* Operation(s) to perform */
  ubsec_RNGCommandParams_t Parameters;  /* Associated parameters. */
  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
  unsigned long	 CommandContext;    /* Context (ID) of this command). */
  } ubsec_RNGCommandInfo_t,*ubsec_RNGCommandInfo_pt;

/*
 * RNG acceleration command function.
 */
UBSECAPI ubsec_Status_t 
ubsec_RNGCommand(ubsec_DeviceContext_t Context,
	      ubsec_RNGCommandInfo_pt pCommand,
	      int *NumCommands);


/*
 * Ubsec Statistics information contains all statistics 
 * maintained by the driver.
 */
typedef struct ubsec_Statistics_s {
  unsigned long BlocksEncryptedCount;
  unsigned long BlocksDecryptedCount;
  unsigned long BytesEncryptedCount;
  unsigned long BytesDecryptedCount;
  unsigned long CryptoFailedCount;
  unsigned long IKECount;
  unsigned long IKEFailedCount;
  unsigned long DHPublicCount;
  unsigned long DHSharedCount;
  unsigned long RSAPublicCount;
  unsigned long RSAPrivateCount;
  unsigned long DSASignCount;
  unsigned long DSAVerifyCount;
  unsigned long DMAErrorCount;
  } ubsec_Statistics_t, *ubsec_Statistics_pt;


/*
 * Ubsec get statistical information function.
 */
UBSECAPI ubsec_Status_t 
ubsec_GetStatistics(ubsec_DeviceContext_t Context,
	      ubsec_Statistics_pt Dest);


/* 
 * SSL/TLS/ARC4 Command prototype definitions
 */

/*
 *  SSL Command definitions. These commands will be ored in with
 * crypto commands.
 */

#define UBSEC_SSL_HMAC         (0x01000)
#define UBSEC_SSL_MAC         (0x01000)
#define UBSEC_SSL_CRYPTO      (0x02000)
#define UBSEC_TLS             (0x04000)
#define UBSEC_ARC4            (0x08000)
#define UBSEC_HASH            (0x10000)

#define UBSEC_SSL_DES_ENCODE (UBSEC_SSL_CRYPTO+UBSEC_ENCODE+UBSEC_3DES)
#define UBSEC_SSL_DES_DECODE (UBSEC_SSL_CRYPTO+UBSEC_ENCODE+UBSEC_DES)
#define UBSEC_SSL_HMAC_MD5   (UBSEC_SSL_HMAC+UBSEC_MAC_MD5)
#define UBSEC_SSL_HMAC_SHA1  (UBSEC_SSL_HMAC+UBSEC_MAC_SHA1)
#define UBSEC_SSL_MAC_MD5    (UBSEC_SSL_MAC+UBSEC_MAC_MD5)
#define UBSEC_SSL_MAC_SHA1   (UBSEC_SSL_MAC+UBSEC_MAC_SHA1)
#define UBSEC_TLS_HMAC_MD5   (UBSEC_TLS+UBSEC_MAC_MD5)
#define UBSEC_TLS_HMAC_SHA1  (UBSEC_TLS+UBSEC_MAC_SHA1)
#define UBSEC_HASH_SHA1      (UBSEC_HASH | UBSEC_MAC_SHA1)
#define UBSEC_HASH_MD5       (UBSEC_HASH | UBSEC_MAC_MD5)

#define UBSEC_ARC4_STATE_WRITEBACK  0x0001
#define UBSEC_ARC4_STATE_STATEKEY   0x0002
#define UBSEC_ARC4_STATE_NULL_DATA  0x0004

#define UBSEC_SSL_COMMAND_MASK (UBSEC_SSL_MAC+UBSEC_SSL_CRYPTO+UBSEC_TLS+UBSEC_ARC4+UBSEC_HASH)
#define UBSEC_SSL_COMMAND(command) (command & (UBSEC_SSL_COMMAND_MASK))

/*
 * Type Definitions:
 */
typedef unsigned char ubsec_SSLMAC_key_t[UBSEC_HMAC_LENGTH], *ubsec_SSLMAC_key_pt;

/* Sequence number type. Double DWORD. */
typedef struct ubsec_DoubleSequenceNumber_s {
  unsigned long HighWord;
  unsigned long LowWord;
} ubsec_DoubleSequenceNumber_t, *ubsec_DoubleSequenceNumber_pt;

typedef struct ubsec_SSLMACParams_s {
  ubsec_FragmentInfo_t         OutputHMAC;      /* output MAC */
  ubsec_SSLMAC_key_t           key;             /* MAC key */
  ubsec_DoubleSequenceNumber_t SequenceNumber;  /* sequence number */
  unsigned char                ContentType;     /* content type */
  unsigned short               DataLength;
} ubsec_SSLMACParams_t, *ubsec_SSLMACParams_pt;

typedef struct ubsec_TLSHMACParams_s {
  ubsec_FragmentInfo_t          OutputHMAC; /* output MAC */
  ubsec_HMAC_State_pt           HMACState; /* HMAC State */
  ubsec_DoubleSequenceNumber_t   SequenceNumber;     /* sequence number */
  unsigned char ContentType;        /* content type */
  unsigned short Version;        /* Version */
  unsigned short DataLength;
} ubsec_TLSHMACParams_t, *ubsec_TLSHMACParams_pt;

typedef struct ubsec_SSLCipherParams_t {
  ubsec_IV_t         InitialVector;              /* initial vector */
  unsigned long CryptKey[UBSEC_3DES_KEY_LENGTH];
} ubsec_SSLCipherParams_t, *ubsec_SSLCipherParams_pt;

#define UBSEC_ARC4_KEYSTATE_BYTES (256)
typedef unsigned char ubsec_ARC4_State_t[UBSEC_ARC4_KEYSTATE_BYTES], *ubsec_ARC4_State_pt;

typedef struct ubsec_SSLARC4Params_t {
  ubsec_ARC4_State_pt  KeyState;       /* key or state data */
  unsigned char index_i;            /* index i */
  unsigned char index_j;            /* index j */
  unsigned long          KeyStateFlag;  /* start with key or start from flag */
  ubsec_FragmentInfo_t  state_out;       /* state upon completing this arc4 operation */
} ubsec_ARC4Params_t, *ubsec_ARC4Params_pt;

typedef struct ubsec_HashParams_t {
  ubsec_FragmentInfo_t          OutputHMAC; /* output MAC */
} ubsec_HashParams_t, *ubsec_HashParams_pt;

typedef union ubsec_SSLParams_u {
  ubsec_SSLMACParams_t    SSLMACParams;
  ubsec_SSLCipherParams_t SSLCipherParams;
  ubsec_TLSHMACParams_t    TLSHMACParams;
  ubsec_ARC4Params_t      ARC4Params;
  ubsec_HashParams_t      HashParams;
} ubsec_SSLCommandParams_t, *ubsec_SSLCommandParams_pt;

typedef unsigned long ubsec_SSLCommand_t;

typedef struct ubsec_SSLCommandInfo_s {
  ubsec_SSLCommand_t        Command;
  ubsec_SSLCommandParams_t  Parameters;
  unsigned long             CommandContext;
  unsigned int NumSource;                    /* Number of source fragments. */
  ubsec_FragmentInfo_pt 	SourceFragments; /* Source fragment list */
  unsigned long 		NumDestination;  /* Number of Destination fragments. */
  ubsec_FragmentInfo_pt           DestinationFragments;    /* Destination fragment list */
  void(*CompletionCallback)(unsigned long Context, ubsec_Status_t Result);
} ubsec_SSLCommandInfo_t, *ubsec_SSLCommandInfo_pt;


  /* SSL command execute function. */
UBSECAPI ubsec_Status_t
ubsec_SSLCommand(ubsec_DeviceContext_t Context,
		    ubsec_SSLCommandInfo_pt command,
		    int *NumCommands);

#endif /* _UBSEC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubsmd5.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsmd5.h:
 */

/*
 * Revision History:
 *
 */

#ifndef _MD5_H_
#define _MD5_H_

#define MD5_BLOCK_LENGTH  64		/* in bytes */
#define MD5_HASH_LENGTH   16 		/* in bytes */


#if 0
typedef unsigned int u32;
typedef unsigned char u8;
typedef unsigned short u16;
#endif


typedef int uint32;
struct MD5Context {
	uint32 buf[4];
	uint32 bits[2];
	unsigned char in[64];
};


#endif _MD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\Ubsstruc.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubsstruc.h:  ubsec internal structure definition header file
 */

/*
 * Revision History:
 *
 * 09/xx/1999 SOR Created.
 * 02/05/2001 PW Added code for key self test 
 * 07/16/2001 RJT Added support for BCM5821
 */

#ifndef _UBSSTRUC_H_
#define _UBSSTRUC_H_


#define UBSEC_CIPHER_LIST 0
#define UBSEC_KEY_LIST 1
#define UBSEC_NUM_MCR_LISTS 2
#define UBSEC_MAX_MCR_LISTS 2

/*
 * Device Information structure. This contains all the state information
 * for the device. The device context points to this structure.
 */
typedef struct DeviceInfo_s {
  /* housekeeping information */
  unsigned long DeviceID;      /* Type of device */
  unsigned long BaseAddress;   /* Physical base address 	   	    */
  unsigned int IRQ;            /* IRQ associated with device. 	   	    */
  ubsec_Status_t Status;
  VOLATILE unsigned long *ControlReg[UBSEC_MAXREGISTERS];/* device register */
  unsigned int NumberOfMCRs[UBSEC_MAX_MCR_LISTS];   /* Number of MCRs allocated to this device.  */
  MasterCommand_pt  MCRList[UBSEC_MAX_MCR_LISTS];        /* MCR List, 0 for MCR1, 1 for MCR2  */
  MasterCommand_pt  NextFreeMCR[UBSEC_MAX_MCR_LISTS];    /* Next MCR to fill 	  	    */
  MasterCommand_pt  NextDeviceMCR[UBSEC_MAX_MCR_LISTS];  /* Next MCR to push to device. 	    */
  MasterCommand_pt  NextDoneMCR[UBSEC_MAX_MCR_LISTS];    /* Next MCR to be checked for        */
  VOLATILE int IRQEnabled;              /* Interrupt enabled indicator 	    */
  unsigned long InCriticalSection;      /* Primitive (single thread) mutex   */
  unsigned long NumberOfMCRLists;       /* Number of MCR Lists in this device */
  unsigned long IntEnableMask;          /* Interrupt mask values */
  unsigned long IntAckMask;             /* Interrupt mask values */
  unsigned long ResetConfig;            /* DMA Control reg state after reset */
  unsigned short InterruptSuppress;     /* Interrupt Suppress setting for MCR Flags field */
  unsigned short Reserved;              /* To maintain alignment */
  unsigned char *SelfTestMemArea;       /* Test memory area */
  OS_MemHandle_t SelfTestMemAreaHandle; /* Memory area handle */

  void (*SelfTestCallBack)(unsigned long Context,ubsec_Status_t Result);  /* Test user callback */
  unsigned long SelfTestContext; /* Self test user context */

  void (*KeySelfTestCallBack)(unsigned long Context,ubsec_Status_t Result);  /* Test user callback */
  unsigned long KeySelfTestContext; /* Self test user context */

  OS_DeviceInfo_t OsDeviceInfo;	/* pointer to structure containing info specific to an OS */
#ifdef UBSEC_STATS
  ubsec_Statistics_t Statistics;
#endif	
} DeviceInfo_t,*DeviceInfo_pt;

#define NULL_DEVICE_INFO (DeviceInfo_pt) 0

/*
 * Sizes for ubs Bud
 */
#define TEST_CIPHER_BLOCK_SIZE 64
#define TEST_AUTH_DATA_SIZE 32
#define TEST_DATA_SIZE (3*(TEST_CIPHER_BLOCK_SIZE+TEST_AUTH_DATA_SIZE))

/* need a array of 64 char (512 bits) for each parameter N G UserX Y and X, so the totoal length
   is 64 * 5 = 320 
*/
#define TEST_KEY_BLOCK_SIZE 64
#define TEST_KEY_OFFSET_SIZE 128
#define KEY_TEST_DATA_SIZE 2048 

#define FLUSH_ONLY_PUSHED 0
#define FLUSH_ALL         1

#endif  _UBSSTRUC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\Ubsnt.h ===
/*******************************************************************************
 *  BlueSteel Networks
 *  Mountain View, CA 94041
 *  650-625-0500
 *
 *
 *****************************************************************************/
/*
 * ubsnt.h:  ubsec NT operating system dependencies
 */
/*
 * Revision History:
 *
 * 10/xx/99 DWP Created.
 * 07/06/2000 DPA Fixes for SMP operation
 */


#ifndef _UBSNT_H_
#define _UBSNT_H_


#ifdef WIN32_DEVICE

#include "driver.h"

#ifdef UBSDBG
#define DbgPrint(x) KdPrint(x)
#endif

// WDM function prototypes
#ifdef __cplusplus
	#define UBSECAPI extern "C" 
#else
	#define UBSECAPI
#endif
UBSECAPI long WDMGetPhysicalAddress(long logical_address);
UBSECAPI PVOID WDMMapIOSpace(unsigned long pDevice,unsigned long PhysicalAddress,int numBytes);
UBSECAPI void WDMFlush(void *logical_address);
UBSECAPI unsigned long WDMCriticalSection(unsigned long pDevice,unsigned long *SaveConfig);

#define VOLATILE
#define COMPLETE_PENDING_REQUESTS

#define OS_FlushCache(addr)
#define OS_AllocateMemory(size)		ExAllocatePool(NonPagedPool ,size)
#define OS_AllocateDMAMemory(pDevice,size)  ExAllocatePool(NonPagedPool ,size)

#define OS_FreeMemory(mem,size)			ExFreePool(mem);
#define OS_FreeDMAMemory(mem,size)		ExFreePool(mem);

#define OS_AllocateISR(irq,context,callback)		do {																																										\
																								NTSTATUS irqStatus;																																			\
																								irqStatus = IoConnectInterrupt(&((DeviceInfo_pt)context)->OsDeviceInfo->InterruptObject,	\
																																(PKSERVICE_ROUTINE)(((DeviceInfo_pt)context)->OsDeviceInfo->onInterrupt),	\
																																(PVOID)(((DeviceInfo_pt)context)->OsDeviceInfo),												\
																																NULL,																																		\
																																((DeviceInfo_pt)context)->OsDeviceInfo->vector,													\
																																((DeviceInfo_pt)context)->OsDeviceInfo->irql,														\
																																((DeviceInfo_pt)context)->OsDeviceInfo->irql,														\
																																((DeviceInfo_pt)context)->OsDeviceInfo->mode,														\
																																((DeviceInfo_pt)context)->OsDeviceInfo->irqshare,												\
																																((DeviceInfo_pt)context)->OsDeviceInfo->affinity,												\
																																FALSE);	\
																								} while (0);

#define OS_FreeISR(irq,context)									IoDisconnectInterrupt(((DeviceInfo_pt)context)->OsDeviceInfo->InterruptObject)
#define OS_ScheduleCallBack(CallBack,Context)		IoRequestDpc(((DeviceInfo_pt)Context)->OsDeviceInfo->DeviceObject, NULL, ((DeviceInfo_pt)Context)->OsDeviceInfo)

#define OS_InitCriticalSection(pDevice)					KeInitializeSpinLock(&(((DeviceInfo_pt)pDevice)->OsDeviceInfo->SRLspinLock))
#define OS_EnterCriticalSection(pDevice,SaveConfig)				WDMCriticalSection((unsigned long)pDevice,&SaveConfig)
#define OS_TestCriticalSection OS_EnterCriticalSection
#define OS_LeaveCriticalSection(pDevice,SaveConfig) KeReleaseSpinLock(&(((DeviceInfo_pt)pDevice)->OsDeviceInfo->SRLspinLock),(((DeviceInfo_pt)pDevice)->OsDeviceInfo->SRLirql))

#define OS_MapPhysToIO(pDevice,Physical_Address,size)  WDMMapIOSpace((unsigned long)pDevice,Physical_Address,size)
#define OS_UnMapIO(pDevice,ioaddr) MmUnmapIoSpace(ioaddr, ((DeviceInfo_pt)pDevice)->OsDeviceInfo->io_nbytes)
#define OS_GetVirtualAddress(MemHandle) ((void *)(MemHandle))
#define OS_GetPhysicalAddress(MemHandle) WDMGetPhysicalAddress((long)MemHandle)
#define OS_IOMemWrite32(Address,val) WRITE_REGISTER_ULONG((unsigned long *)Address,val)
#define OS_IOMemRead32(Address) READ_REGISTER_ULONG((unsigned long *)Address)

#define OS_Waitus(wait_us) KeStallExecutionProcessor(wait_us)

/*
 * runtime library defintions
 */
#define  RTL_MemZero(mem,bytes)   RtlZeroMemory(mem,bytes)
#define  RTL_Memcpy(dest,source,bytes) RtlCopyMemory(dest,source,bytes)
#define	 RTL_Memcmp(dest,source,bytes) (bytes != RtlCompareMemory(dest,source,bytes))

/*
 * structures
 */
#define OS_DeviceInfo_t PDEVICE_EXTENSION
#define OS_DeviceInfo_pt *OS_DeviceInfo_t

#endif /* WIN32_DEVICE */


#endif  _UBSSYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\crypto\ubssys.h ===
/*
 * Broadcom Cryptonet Driver software is distributed as is, without any warranty
 * of any kind, either express or implied as further specified in the GNU Public
 * License. This software may be used and distributed according to the terms of
 * the GNU Public License.
 *
 * Cryptonet is a registered trademark of Broadcom Corporation.
 */

/******************************************************************************
 *
 * Copyright 2000
 * Broadcom Corporation
 * 16215 Alton Parkway
 * PO Box 57013
 * Irvine CA 92619-7013
 *
 *****************************************************************************/

/* 
 * Broadcom Corporation uBSec SDK 
 */

/*
 * ubssys.h:  ubsec operating system dependencies
 */

/*
 * Revision History:
 *
 * 09/xx/1999 SOR Created.
 * 12/02/1999 DWP Added macros to swap bytes for Little and Big endian hosts
 * 12/15/1999 SOR Added bsd include file
 * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
 * 04/13/2001 RJT Added support for CPU-DMA memory synchronization
 * 07/16/2001 RJT Added support for BCM5821
 */


#ifndef _UBSSYS_H_
#define _UBSSYS_H_


#if defined(UBSEC_5805)
  #if (defined(UBSEC_5820) || defined(UBSEC_5821))
    ERROR - Multiple driver types simultaneously defined 
  #endif
#elif defined(UBSEC_5820)
  #if (defined(UBSEC_5805) || defined(UBSEC_5821))
    ERROR - Multiple driver types simultaneously defined 
  #endif
#elif defined(UBSEC_5821)
  #if (defined(UBSEC_5805) || defined(UBSEC_5820))
    ERROR - Multiple driver types simultaneously defined 
  #endif
#endif


#ifdef UBS_PLATFORM_H_FILE
  #include UBS_PLATFORM_H_FILE
#else
  #ifdef LINUX_DEVICE
  #include "ubslinux.h"
  #endif
  #ifdef WIN32_DEVICE
  #include "ubsnt.h"
  #endif
  #ifdef BSD_DEVICE
  #include "ubsbsd.h"
  #endif
  #ifdef VXWORKS_DEVICE 
  #include "ubsvxworks.h"
  #endif
  #ifdef SOLARIS_DEVICE
  #include "ubssolaris.h"
  #endif
#endif

#ifndef OS_EnterCriticalSection
  #define OS_EnterCriticalSection(x,y) 0
#endif

#ifndef OS_TestCriticalSection
  #define OS_TestCriticalSection(x,y) 0
#endif

#ifndef OS_SyncToDevice
  #define OS_SyncToDevice(x,y,z)
#endif

#ifndef OS_SyncToCPU
  #define OS_SyncToCPU(x,y,z)
#endif

#define BYTESWAPSHORT(sval) ((((sval)&0xff00)>>8)+(((sval)&0xff)<<8))
#define BYTESWAPLONG(lval) (((BYTESWAPSHORT((lval)>>16)))+((BYTESWAPSHORT((lval)&0xffff)<<16)))


#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE) 

  #define CPU_TO_CTRL_LONG( lval )  (BYTESWAPLONG( (unsigned long)(lval) ))
  #define CTRL_TO_CPU_LONG( lval )  (BYTESWAPLONG( (unsigned long)(lval) ))
  #define CPU_TO_CTRL_SHORT( sval ) (BYTESWAPSHORT( (unsigned short)(sval) ))
  #define CTRL_TO_CPU_SHORT( sval ) (BYTESWAPSHORT( (unsigned short)(sval) ))

  #define SYS_TO_BE_LONG( lval )  ((unsigned long)(lval))

#else /* CPU and CryptoNet device have the same endianess */

  #define CPU_TO_CTRL_LONG( lval )  ((unsigned long)(lval))
  #define CTRL_TO_CPU_LONG( lval )  ((unsigned long)(lval))
  #define CPU_TO_CTRL_SHORT( sval ) ((unsigned short)(sval))
  #define CTRL_TO_CPU_SHORT( sval ) ((unsigned short)(sval))

  #define SYS_TO_BE_LONG( lval )  (BYTESWAPLONG((unsigned long)(lval)))

#endif /* CPU and CTRLMEM endianess considerations */

#if (UBS_CPU_ATTRIBUTE == UBS_BIG_ENDIAN) 

  /* byteswap for runtime (little endian) CryptoNet register accesses */
  #define CPU_TO_PCI_LONG( lval )  (BYTESWAPLONG( (unsigned long)(lval) ))
  #define PCI_TO_CPU_LONG( lval )  (BYTESWAPLONG( (unsigned long)(lval) ))

#else 

  /* CPU (and CryptoNet registers) are both little endian, no byteswap needed */
  #define CPU_TO_PCI_LONG( lval )  ((unsigned long)(lval))
  #define PCI_TO_CPU_LONG( lval )  ((unsigned long)(lval))

#endif /* CPU and CryptoNet endianess considerations */

#define LOW_BYTE(x) (x&0xff)
#define HIGH_BYTE(x) (((x)&0xff00)>>8)

#define ROUNDUP_BIT(n,m) ((((n)+(m)-1)/(m))*(m))
#define ROUNDUP_TO_32_BIT(n) ROUNDUP_BIT(n,32)

#endif  _UBSSYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\dnsd\dnsd.cpp ===
// ---------------------------------------------------------------------------------------
// chalmake.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>


char g_CurrentTime[sizeof("05/05/1975 00:05:00")];

char * GetTime()
{
    SYSTEMTIME st;

    GetSystemTime(&st);

    sprintf(g_CurrentTime, "%02d/%02d/%04d %02d:%02d:%02d",
            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

    return g_CurrentTime;
}

#define BIT(b)            (1<<(b))

struct CNameInfo
{
    char * _pchHostName;
    ULONG  _ulAddr;
};

struct CDnsHdr
{
    // Definitions ---------------------------------------------------

    #define DNSF_RESPONSE       BIT(15) // 1 if response; 0 if query
    #define DNSF_QOP_MASK       0x7800  // 4 bits of query opcode
    #define DNSF_QOP_SQRY       0x0000  // Standard query opcode
    #define DNSF_QOP_IQRY       0x0800  // Inverse query opcode
    #define DNSF_QOP_STAT       0x1000  // Server status request
    #define DNSF_AA             BIT(10) // Authoritative answer
    #define DNSF_TC             BIT(9)  // Truncation
    #define DNSF_RD             BIT(8)  // Recursion desired
    #define DNSF_RA             BIT(7)  // Recursion available
    #define DNSF_ROP_MASK       0x000F  // 4 bits of response opcode
    #define DNSF_ROP_OK         0x0000  // No error response code
    #define DNSF_ROP_FMTERR     0x0001  // Format error response code
    #define DNSF_ROP_SRVFAIL    0x0002  // Server failure response code
    #define DNSF_ROP_NAMEERR    0x0003  // Name error response code
    #define DNSF_ROP_NOTIMPL    0x0004  // Not implemented response code
    #define DNSF_ROP_REFUSED    0x0005  // Refused response code

    #define DNSRT_A             1       // a host address
    #define DNSRT_NS            2       // an authoritative name server
    #define DNSRT_MD            3       // a mail destination (Obsolete - use MX)
    #define DNSRT_MF            4       // a mail forwarder (Obsolete - use MX)
    #define DNSRT_CNAME         5       // the canonical name for an alias
    #define DNSRT_SOA           6       // marks the start of a zone of authority
    #define DNSRT_MB            7       // a mailbox domain name (EXPERIMENTAL)
    #define DNSRT_MG            8       // a mail group member (EXPERIMENTAL)
    #define DNSRT_MR            9       // a mail rename domain name (EXPERIMENTAL)
    #define DNSRT_NULL          10      // a null RR (EXPERIMENTAL)
    #define DNSRT_WKS           11      // a well known service description
    #define DNSRT_PTR           12      // a domain name pointer
    #define DNSRT_HINFO         13      // host information
    #define DNSRT_MINFO         14      // mailbox or mail list information
    #define DNSRT_MX            15      // mail exchange
    #define DNSRT_TXT           16      // text strings

    #define DNSQT_AXFR          252     // a transfer of an entire zone
    #define DNSQT_MAILB         253     // mailbox-related records (MB, MG or MR)
    #define DNSQT_MAILA         254     // mail agent RRs (Obsolete - see MX)
    #define DNSQT_ALL           255     // all records

    #define DNSRC_IN            1       // the Internet
    #define DNSRC_CS            2       // the CSNET class (Obsolete)
    #define DNSRC_CH            3       // the CHAOS class
    #define DNSRC_HS            4       // the Hesiod class
    #define DNSRC_ANY           255     // any class

    // Data ----------------------------------------------------------

    WORD _wId;               // DNS message unique identifier
    WORD _wFlags;            // See DNSF_* above
    WORD _cQd;               // Number of entries in questions section
    WORD _cAn;               // Number of entries in answers section
    WORD _cNs;               // Number of entries in authority section
    WORD _cAr;               // Number of entries in additional section
};

void DumpDns(CDnsHdr * pdnshdr, UINT cb)
{
    WORD wFlags = ntohs(pdnshdr->_wFlags);

    printf("%s [DNS %s %d/%s %d/%s%s%s%s%s %04X %d/Qd %d/An %d/Ns %d/Ar]\n",
           GetTime(),
           (wFlags & DNSF_RESPONSE) ? "RESP" : "QUERY",
           (wFlags & DNSF_QOP_MASK),
           (wFlags & DNSF_QOP_MASK) == DNSF_QOP_SQRY ? "SQRY" :
           (wFlags & DNSF_QOP_MASK) == DNSF_QOP_IQRY ? "IQRY" :
           (wFlags & DNSF_QOP_MASK) == DNSF_QOP_STAT ? "STAT" : "????",
           (wFlags & DNSF_ROP_MASK),
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_OK ? "OK" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_FMTERR ? "FMTERR" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_SRVFAIL ? "SRVFAIL" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NAMEERR ? "NAMEERR" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NOTIMPL ? "NOTIMPL" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_REFUSED ? "REFUSED" : "????",
           (wFlags & DNSF_AA) ? " AA" : "",
           (wFlags & DNSF_TC) ? " TC" : "",
           (wFlags & DNSF_RD) ? " RD" : "",
           (wFlags & DNSF_RA) ? " RA" : "",
           ntohs(pdnshdr->_wId),
           ntohs(pdnshdr->_cQd),
           ntohs(pdnshdr->_cAn),
           ntohs(pdnshdr->_cNs),
           ntohs(pdnshdr->_cAr));


}

CNameInfo g_anameinfo[3];

int __cdecl main(int argc, char * argv[])
{
    int err;
    WSADATA WSAData;

    if (argc != 4)
    {
        printf("usage: dnsd <macs-ip> <as-ip> <tgs-ip>\n");
        exit(1);
    }

    char achMacs[] = ".macs";
    char achAs[]   = ".as";
    char achTgs[]  = ".tgs";

    g_anameinfo[0]._pchHostName = achMacs;
    g_anameinfo[1]._pchHostName = achAs;
    g_anameinfo[2]._pchHostName = achTgs;

    for (UINT i = 0; i < 3; i++)
    {
        g_anameinfo[i]._pchHostName[0] = strlen(g_anameinfo[i]._pchHostName+1);
        g_anameinfo[i]._ulAddr = inet_addr(argv[i+1]);

        BYTE * pbAddr = (BYTE *)&g_anameinfo[i]._ulAddr;

        printf("%4s: %d.%d.%d.%d\n", g_anameinfo[i]._pchHostName + 1,
               pbAddr[0], pbAddr[1], pbAddr[2], pbAddr[3]);
    }


    err = WSAStartup(0x0101, &WSAData);

    if (err != 0)
    {
        printf("Couldn't init winsock, err %d\n", err);
        exit(1);
    }

    SOCKET s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (s == SOCKET_ERROR)
    {
        printf("Couldn't create socket %d\n", WSAGetLastError());
        exit(1);
    }

    sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(53);

    err = bind(s, (struct sockaddr *)&sin, sizeof(sin));
    if (err != 0)
    {
        printf("Couldn't bind socket %d\n", err);
        exit(1);
    }


    int slen = sizeof(sin);
    int cb;

    BYTE abRecv[1500];
    BYTE abAnswer[12] = {0xC0, 0xC, 0, 1, 0, 1, 0, 0, 0xA, 0, 0, 4 };

    while (1)
    {
        cb = recvfrom(s, (char *)abRecv, sizeof(abRecv) - 16, 0,
                      (struct sockaddr *)&sin, &slen);

        if (cb == SOCKET_ERROR)
            break;

        CDnsHdr * pdnshdr = (CDnsHdr *)abRecv;
        DumpDns(pdnshdr, cb);

        if (pdnshdr->_cQd != htons(1))
            continue;

        BYTE * pbName = (BYTE *)(pdnshdr + 1);

        ULONG ulAddr = 0;
        UINT  uiLen  = pbName[0];
        CNameInfo * pinfo = g_anameinfo;

        for (UINT i = 0; i < 3; i++, pinfo++)
        {
            char * pchName     = (char *)pbName + 1;
            char * pchHostName = pinfo->_pchHostName + 1;

            if (   uiLen == pinfo->_pchHostName[0]
                && _strnicmp(pchName, pchHostName, uiLen) == 0)
            {
                printf("%s [RESPONSE] for %s\n", GetTime(), pchHostName);
                ulAddr = pinfo->_ulAddr;
                break;
            }
        }

        if (ulAddr == 0)
            continue;

        pdnshdr->_wFlags |= htons(DNSF_RESPONSE);
        pdnshdr->_cAn = htons(1);

        BYTE * pbAnswer = abRecv + cb;
        memcpy(pbAnswer, abAnswer, sizeof(abAnswer));
        pbAnswer += sizeof(abAnswer);
        *(ULONG *)pbAnswer = ulAddr;

        cb = sendto(s, (char *)abRecv, cb + 16, 0,
                    (struct sockaddr *)&sin, slen);
        if (cb == SOCKET_ERROR)
            break;
    }

    printf("socket error %d\n", WSAGetLastError());

    closesocket(s);
    WSACleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\PacketPusher\PacketPusher.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Globalization;

namespace PacketPusher
{
    class Program
    {
        static void Main(string[] args)
        {
            int port        = 3074;
            int numThreads  = 1;
            IPEndPoint ip   = null;
            int packetSize  = 16;
            byte action     = 0x81;

            for (int i = 0; i < args.Length; i++)
            {
                if (args[i].ToLower() == "-port" && i + 1 < args.Length)
                {
                    port = int.Parse(args[++i]);
                }
                else if (args[i].ToLower() == "-threads" && i + 1 < args.Length)
                {
                    numThreads = int.Parse(args[++i]);
                }
                else if (args[i].ToLower() == "-ip" && i + 1 < args.Length)
                {
                    string ipString = args[++i];
                    //IPAddress ipAddress = Dns.GetHostEntry(ipString).AddressList[0];
                    IPAddress ipAddress = IPAddress.Parse(ipString);
                    ip = new IPEndPoint(ipAddress, port);
                }
                else if (args[i].ToLower() == "-size" && i + 1 < args.Length)
                {
                    packetSize = int.Parse(args[++i]);
                }
                else if (args[i].ToLower() == "-action" && i + 1 < args.Length)
                {
                    string actionstring = args[++i];
                    if (actionstring.StartsWith("0x"))
                        action = byte.Parse(actionstring.Substring(2), NumberStyles.HexNumber);
                    else
                        action = byte.Parse(actionstring);
                }
                else
                {
                    ShowHelp();
                }
            }
            if (ip == null)
                ShowHelp();
            ip.Port = port;

            PacketPusher pp = new PacketPusher(ip, packetSize, numThreads, action);

            // Timer
            TimerCallback timerDelegate = new TimerCallback(Status);
            Timer timer = new Timer(timerDelegate, pp, 1000, 1000);

            pp.Start();

        }

        static void ShowHelp()
        {
            Console.WriteLine("PacketPusher [-ip ipaddress] [-port port] [-threads numthreads] [-size packetsize] [-action action]");
            Console.WriteLine("  Default port is 3074, default threads is 1, default size is 16, default action is 0x86");
            Console.WriteLine("  Action 0x80: Drop");
            Console.WriteLine("  Action 0x81: Reflect");
            Console.WriteLine("  Action 0x86: ReflectTimestamp");
            Console.WriteLine("");
            Console.WriteLine("Example:");
            Console.WriteLine("  PacketPusher -ip 10.198.102.211 -port 3074 -threads 1 -size 16 -action 0x81");
            System.Environment.Exit(-1);
        }

        public static void Status(object state)
        {
            long incPackets = Interlocked.Exchange(ref PacketPusher.IncPackets, 0);
            long incBytes = Interlocked.Exchange(ref PacketPusher.IncBytes, 0);
            long totalPackets = PacketPusher.TotalPackets;
            long totalBytes = PacketPusher.TotalBytes;
            Console.WriteLine("[{0}] {1} packets/sec ({2} total), {3} bytes/sec ({4}MB total)",
                Thread.CurrentThread.ManagedThreadId,
                incPackets,
                totalPackets,
                incBytes,
                (ulong)(totalBytes / 1000000));
        }
    }

    public class PacketPusher
    {
        private int         PacketSize;
        private byte        Action;
        private IPEndPoint  RemoteIp;

        static private Thread[] Threads;

        static public long  TotalPackets = 0;
        static public long  IncPackets = 0;
        static public long  TotalBytes = 0;
        static public long  IncBytes = 0;

        public PacketPusher(IPEndPoint ip, int packetSize, int numThreads, byte action)
        {
            PacketSize = packetSize;
            RemoteIp = ip;
            Threads = new Thread[numThreads];
            Action = action;
        }

        public void Start()
        {
            int i;
            for (i = 0; i < Threads.Length; i++)
            {
                Threads[i] = new Thread(new ThreadStart(Start_ThreadProc));
                Threads[i].Start();
            }

            for (i = 0; i < Threads.Length; i++)
            {
                Threads[i].Join();
            }

            Console.WriteLine("All done.");
        }

        protected void Start_ThreadProc()
        {
            Socket UdpSock;
            UdpSock = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            UdpSock.Bind(new IPEndPoint(IPAddress.Any, 0));

            Console.WriteLine("[{0}] Sending {1} byte packets to {2} from {3}",
                Thread.CurrentThread.ManagedThreadId,
                PacketSize,
                RemoteIp.ToString(),
                UdpSock.LocalEndPoint.ToString());

            byte[] payload = new byte[PacketSize];
            int bytesSent = 0;
            ulong timestamp = 0;
            uint sequenceNumber = 0;
            DateTime startTime = DateTime.Now;

            // The SGFakeService / ThroughputReflector supports some special packets, so we'll set
            // our payload for this thing.  If we send the packets to it, we should get 
            // the packets reflected to us. Byte 0:
            //   0x81 is Reflect
            //   0x86 is ReflectTimestamp
            if (payload.Length >= 4)
                payload[0] = Action;
            while (true)
            {
                if (payload[0] == 0x86)
                {
                    timestamp = (ulong)(DateTime.Now.Ticks - startTime.Ticks);
                    SetTimestamp(payload, 4, ++sequenceNumber, timestamp);
                }

                bytesSent = UdpSock.SendTo(
                    payload,
                    0,
                    PacketSize,
                    SocketFlags.None,
                    RemoteIp);
                if (bytesSent <= 0)
                {
                    Console.WriteLine("Failed to send {0} bytes, only sent {1} bytes", PacketSize, bytesSent);
                }
                Interlocked.Increment(ref TotalPackets);
                Interlocked.Increment(ref IncPackets);
                Interlocked.Add(ref TotalBytes, (long)PacketSize);
                Interlocked.Add(ref IncBytes, (long)PacketSize);

                // Silly 1-byte sequence number
                if (payload.Length >= 2)
                    payload[1]++;
            }
        }

        public static void SetTimestamp(byte[] data, int dataOffset, uint sequenceNum, ulong timestamp)
        {
            if (data != null && data.Length >= dataOffset + 4)
            {
                // We must be super uber fast, no allocating of nothin'.
                data[dataOffset + 0] = (byte)((sequenceNum       ) & 0xFF);
                data[dataOffset + 1] = (byte)((sequenceNum  >>  8) & 0xFF);
                data[dataOffset + 2] = (byte)((sequenceNum  >> 16) & 0xFF);
                data[dataOffset + 3] = (byte)((sequenceNum  >> 24) & 0xFF);
            }
            if (data != null && data.Length >= dataOffset + 12)
            {
                long ticks = (long)timestamp;
                //long ticks = DateTime.Now.Ticks - ClientBirth.Ticks;
                data[dataOffset + 4] = (byte)((ticks      ) & 0xFF);
                data[dataOffset + 5] = (byte)((ticks >>  8) & 0xFF);
                data[dataOffset + 6] = (byte)((ticks >> 16) & 0xFF);
                data[dataOffset + 7] = (byte)((ticks >> 24) & 0xFF);
                data[dataOffset + 8] = (byte)((ticks >> 32) & 0xFF);
                data[dataOffset + 9] = (byte)((ticks >> 40) & 0xFF);
                data[dataOffset +10] = (byte)((ticks >> 48) & 0xFF);
                data[dataOffset +11] = (byte)((ticks >> 56) & 0xFF);
            }
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\sources.inc ===
USER_CS_FLAGS=$(USER_CS_FLAGS) /unsafe

REFERENCES = \

SOURCES=\
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\SGPlugin.cs ===
using System;
using System.Windows.Forms;

using STFGui.Plugins;

namespace SGNatTest
{
    /// <summary>
    /// The SG test plugin, replaces the SgStressForm UI.
    /// </summary>
    public class SGPlugin : IPluginGui
    {
        /// <summary>Backing for Control.</summary>
        private SGPluginControl _control = null;

        /// <summary>
        /// The control that makes up the body of the tab page.
        /// </summary>
        public SGPluginControl Control
        {
            get
            {
                if (_control == null)
                {
                    _control = new SGPluginControl();
                }

                return _control;
            }
        }

        /// <summary>
        /// Creates a tab page for the 
        /// </summary>
        /// <returns></returns>
        public TabPage GetNewTabPage ()
        {
            TabPage page = new TabPage();

            page.Text = "SG";

            Control.Dock = DockStyle.Fill;
            page.Controls.Add(Control);

            return page;
        }

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGAuthDataParser\SGAuthDataParser.cs ===
using System;
using System.IO;
using System.Text;
using ServerTestFramework;

namespace SGAuthDataParser
{

    class SGADDR : WireData
    {
        [WireInfo(ArraySize=4)]
        public byte[]   inaSg={0,0,0,0};              // IP address of the SG for the client
        public uint     dwSpiSg=0;            // Pseudo-random identifier assigned by the SG
        public ulong    qwXboxID=0;           // Unique identifier of client machine account
        [WireInfo(ArraySize=4)]
        public byte[]   abReserved={0,0,0,0};         // Reserved (must be zero)

        public override String ToString()
        {
            StringBuilder sb = new StringBuilder(1000);
            sb.AppendFormat("IP {0}.{1}.{2}.{3}, SPI=0x{4:X}, XboxID=0x{5:X}", inaSg[0], inaSg[1], inaSg[2], inaSg[3], dwSpiSg, qwXboxID);
            return sb.ToString();
        }
    }

    class XBOX_LIBRARY_VERSION : WireData
    {
        public ushort wMajorVersion=0;
        public ushort wMinorVersion=0;
        public ushort wBuildNumber=0;
        public ushort wQFENumber=0;

        public override String ToString()
        {
            return "[XBOX_LIBRARY_VERSION]";
        }
    }

    class XUID : WireData
    {
        public ulong qwUserID=0;
        public uint dwUserFlags=0;

        public override String ToString()
        {
            return String.Format("qwUserID=0x{0,16:X} ({2}), dwUserFlags=0x{1,8:X}", qwUserID, dwUserFlags, qwUserID);
        }
    }

    class CAuthData2 : WireData
    {
        public ushort   _wType=0;                    // See SGMSG_TYPE_* above
        public ushort   _cbEnt=0;                    // Size of this entry (including header)
        public ushort                   wAuthDataVersion=0;
        public ushort                   wAuthDataSize=0;
        public XBOX_LIBRARY_VERSION     clientVersion=null;
        public uint                     dwTitleID=0;
        public uint                     dwTitleVersion=0;
        public uint                     dwTitleRegion=0;
        public ulong                    qwXboxID=0;
        [WireInfo(ArraySize=4)]
        public XUID[]                   users=null;
        public uint                     dwNumServices=0;
        [WireInfo(ArraySize=12)]
        public uint[]                   dwServiceID={0,0,0,0,0,0,0,0,0,0,0,0};
        [WireInfo(ArraySize=4)]
        public float[]                  afltTrustFactor={0,0,0,0};
        [WireInfo(ArraySize=4)]
        public uint[]                   dwAltTitleID={0,0,0,0};
        [WireInfo(ArraySize=16)]
        public byte[]                   abKey={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

        public override String ToString()
        {
            StringBuilder sb = new StringBuilder(1000);
            sb.Append("[CAuthData2]\n");
            sb.AppendFormat("_wType \t\t0x{0:X}\n", _wType);
            sb.AppendFormat("_cbEnt \t\t{0}\n", _cbEnt);
            sb.AppendFormat("wAuthDataVersion \t{0}\n", wAuthDataVersion);
            sb.AppendFormat("wAuthDataSize \t{0}\n", wAuthDataSize);
            sb.AppendFormat("dwTitleID \t0x{0,8:X} ({1})\n", dwTitleID, dwTitleID);
            sb.AppendFormat("dwTitleVersion \t0x{0,8:X} ({1})\n", dwTitleVersion, dwTitleVersion);
            sb.AppendFormat("dwTitleRegion \t0x{0,8:X} ({1})\n", dwTitleRegion, dwTitleRegion);
            sb.AppendFormat("dwNumServices \t{0}\n", dwNumServices);
            sb.AppendFormat("users:\n\tUser1: {0}\n\tUser2: {1}\n\tUser3: {2}\n\tUser4: {3}\n", users[0], users[1], users[2], users[3]);
            sb.AppendFormat("afltTrustFactor:\n\tUser1: {0}\n\tUser2: {1}\n\tUser3: {2}\n\tUser4: {3}\n", afltTrustFactor[0],afltTrustFactor[1],afltTrustFactor[2],afltTrustFactor[3]);
            return sb.ToString();
        }

    }

    class CSgMsgSpiData2 : WireData
    {
        public ushort   _wType=0;                     // See SGMSG_TYPE_* above
        public ushort   _cbEnt=0;                     // Size of this entry (including header)
        public ushort   _ipportI=0;                   // IP port of the client on the Internet
        [WireInfo(ArraySize=4)]
        public byte[]   _ipaI={0,0,0,0};                      // IP address of the client on the Internet
        public SGADDR   _sgaddr=null;                    // SGADDR of the client
        public ushort   _wVersionKeyEx=0;             // KeyEx version of the client
        public ushort   _wFlagsKeyEx=0;               // Flags sent in KeyEx initiator
        public long     _liNonce=0;                   // A random nonce associated with this session
        public long     _liTimeInit=0;                // FILETIME marking session initiation
        public uint     _fCs=0;                       // TRUE if SG is providing connection services  BOOL=int, curses

        public override String ToString()
        {
            StringBuilder sb = new StringBuilder(1000);
            sb.Append("[CSgMsgSpiData2]\n");
            sb.AppendFormat("_wType \t\t0x{0:X}\n", _wType);
            sb.AppendFormat("_cbEnt \t\t{0}\n", _cbEnt);
            sb.AppendFormat("_ipportI \t{0}\n", _ipportI);
            sb.AppendFormat("_ipaI \t\t{0}.{1}.{2}.{3}\n", _ipaI[0],_ipaI[1],_ipaI[2],_ipaI[3]);
            sb.AppendFormat("_sgaddr \t{0}\n", _sgaddr.ToString());
            sb.AppendFormat("_fCs \t\t{0}\n", _fCs);
            return sb.ToString();
        }
    }

    class CSgMsgSpiReq2 : WireData
    {
        public ushort   _wType=0;                     // See SGMSG_TYPE_* above
        public ushort   _cbEnt=0;                     // Size of this entry (including header)
        public uint     _dwReqNum=0;                  // Request number from requester
        [WireInfo(ArraySize=4)]
        public byte[]   _ipaZ={0,0,0,0};                      // IP address of the client on the DMZ
        public ushort   _ipportZ=0;                   // IP port of the client on the DMZ

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(1000);
            sb.Append("[CSgMsgSpiReq2]\n");
            sb.AppendFormat("_wType \t\t0x{0:X}\n", _wType);
            sb.AppendFormat("_cbEnt \t\t{0}\n", _cbEnt);
            sb.AppendFormat("_dwReqNum \t{0}\n", _dwReqNum);
            sb.AppendFormat("_ipaZ \t\t{0}.{1}.{2}.{3}\n", _ipaZ[0],_ipaZ[1],_ipaZ[2],_ipaZ[3]);
            sb.AppendFormat("_ipportZ \t{0}\n", _ipportZ);
            return sb.ToString();
        }
    }

    class CSgMsgSpiRep2 : WireData
    {
        // CSgMsgSpiRep
        public ushort   _wType=0;                     // See SGMSG_TYPE_* above
        public ushort   _cbEnt=0;                     // Size of this entry (including header)
        public uint     _dwReqNum=0;                  // Request number from requester
        [WireInfo(ArraySize=4)]
        public byte[]   _ipaZ={0,0,0,0};                      // IP address of the client on the DMZ
        public ushort   _ipportZ=0;                   // IP port of the client on the DMZ
        public byte     _fNotFound=0;                 // TRUE if client not found (no auth-data enclosed)

        // CSgMsgSpiData2
        public CSgMsgSpiData2 _spidata2=null;

        // CSgMsgHdr + CAuthData2
        public CAuthData2 _authdata=null;


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(1000);
            sb.Append("[CSgMsgSpiRep2]\n");
            sb.AppendFormat("_wType \t\t0x{0:X}\n", _wType);
            sb.AppendFormat("_cbEnt \t\t{0}\n", _cbEnt);
            sb.AppendFormat("_dwReqNum \t{0}\n", _dwReqNum);
            sb.AppendFormat("_ipaZ \t\t{0}.{1}.{2}.{3}\n", _ipaZ[0],_ipaZ[1],_ipaZ[2],_ipaZ[3]);
            sb.AppendFormat("_ipportZ \t{0}\n", _ipportZ);
            sb.AppendFormat("_fNotFound \t{0}\n", _fNotFound);
            sb.Append(_spidata2.ToString());
            sb.Append(_authdata.ToString());
            return sb.ToString();
        }
    }

    class MainClass
    {
        static public void ShowHelp()
        {
            Console.WriteLine("Usage: SGAuthDataParser.exe packetdatafile");
            Console.WriteLine("");
            Console.WriteLine("This utility will parse a hex representation of a data struct.");
            Console.WriteLine("It's rather specialized, input format is from Netmon and it only");
            Console.WriteLine("supports a handful of struct types.");
            Console.WriteLine("");
            Console.WriteLine("Supported data structs: CSgMsgSpiReq, CSgMsgSpiRep");
            Console.WriteLine("(also known as SGInfo requests or authdata requests)");
            Console.WriteLine("");
            Console.WriteLine("Sample format of packetdatafile:");
            Console.WriteLine("");
            Console.WriteLine("[CSgMsgSpiReq2]");
            Console.WriteLine("00000020                                10 47 0E 00 86 14           .G....");
            Console.WriteLine("00000030  37 00 0A FE 01 01 04 00                         7.......        ");
            Console.WriteLine("[CSgMsgSpiRep2]");
            Console.WriteLine("00000020                                11 47 0F 00 86 14           .G....");
            Console.WriteLine("00000030  37 00 0A FE 01 01 04 00 00 82 47 36 00 0C 02 41 7.........G6...A");
            Console.WriteLine("00000040  34 F1 C4 0A FE 01 01 00 38 80 74 03 BC BB BB BB 4.......8.t.....");
            Console.WriteLine("00000050  BB 09 00 00 00 00 00 00 00 01 00 9F 61 D8 C4 0B ............a...");
            Console.WriteLine("<more data here, chopped off>");
            Console.WriteLine("");
            Console.WriteLine("Notice the header type specifying what struct this is. The actual data");
            Console.WriteLine("comes from Netmon - view the packet, click the Data section, then click");
            Console.WriteLine("on the first highlighted hex digit in the 3rd pane. Copy and paste.");
            Console.WriteLine("");

        }

        static public void ProcessSection(string section, byte[] bigdata, int datalen)
        {
            Console.WriteLine("For section {0}, {1} data bytes", section, datalen);
            // Shorten array to exact size
            byte[] data = new byte[datalen];
            for (int i = 0; i < datalen; i++)
            {
                data[i] = bigdata[i];
            }
            if (section.ToLower() == "csgmsgspireq2")
            {
                CSgMsgSpiReq2 packet = new CSgMsgSpiReq2();
                packet.ReadBytes(data);
                Console.WriteLine(packet.ToString());
            }
            else if (section.ToLower() == "csgmsgspirep2")
            {
                CSgMsgSpiRep2 packet = new CSgMsgSpiRep2();
                packet.ReadBytes(data);
                Console.WriteLine(packet.ToString());
            }
        }

        [STAThread]
        static void Main(string[] args)
        {
            if (args.Length != 1)
            {
                ShowHelp();
                return;
            }

            StreamReader sr = new StreamReader(args[0]);
            
            string line = "";
            string section = "";
            int count = 0;
            byte[] bigarray = new byte[2048];
            while ((line = sr.ReadLine()) != null)
            {
                if (line.StartsWith("[") && line.EndsWith("]"))
                {
                    if (section != "" && count > 0)
                    {
                        ProcessSection(section, bigarray, count);
                    }
                    count = 0;
                    section = line.Substring(1, line.Length - 2);
                }
                else if (line == null || line == " " || line == "")
                {
                }
                else
                {
                    // Skip the leading line count (10 characters wide), and stop
                    // before the trailing character representation.
                    string hexvals = line.Substring(10, 3*16);
                    byte val;
                    for (int i = 0; i < 16; i++)
                    {
                        // Walk through 1 hex number at a time (2 chars + 1 space)
                        string hex = hexvals.Substring(i*3, 2);
                        // If blank, ignore. Intended so your data start/end doesn't have
                        // to be 16 byte aligned.
                        if (hex == "  ")
                            continue;
                        val = byte.Parse(hex, System.Globalization.NumberStyles.HexNumber);
                        bigarray[count++] = val;
                    }
                }
            }

            if (section != "" && count > 0)
            {
                ProcessSection(section, bigarray, count);
            }
            sr.Close();
        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\SGConnectionTest.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;

namespace SGNatTest
{
    [TestGroup]
    public class SGConnectionTest : TestNode
    {
        [TestCase]
        public class SimpleConnect : TestNode
        {
            SGConnection Connection = null;

            public override void PreRun (RUN_TYPE runType)
            {
                Connection = new SGConnection();
                AuthContext ctx = new AuthContext(AuthContext.ClientTypes.Xenon);

                // Set users
                int numUsers = 1;

                if (numUsers > 0)
                {
                    for (int i = 0; i < numUsers; i++)
                    {
                        ctx.SetUser("sgstressusr" + i, i);
                    }
                }

                Connection.Context = ctx;
                if (numUsers > 0)
                {
                    Connection.UseConnectionServices = true;
                }
                ctx.Site = SiteInfoManager.GetDefaultSgSite();

                Connection.UseRealXKDC = false;

                // Get the authdata version right
                if (ctx.Site.authdataVersion == 3)
                {
                    ctx.Authdata = new Authdata_Xenon();
                    SgClient.SetDefaultAuthdata(ctx, ctx.Authdata as Authdata_Xenon);
                }
                else
                {
                    ctx.Authdata = new Authdata_Xbox2();
                    SgClient.SetDefaultAuthdata(ctx, ctx.Authdata as Authdata_Xbox2);
                }

                Connection.Transport = new XspUdp();

                Connection.Connect();
            }

            public override TEST_RESULTS Run (RUN_TYPE runType)
            {
                return TEST_RESULTS.PASSED;
            }

            public override void PostRun (RUN_TYPE runType)
            {
                Connection.Disconnect();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\SGPluginControl.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;

namespace SGNatTest
{
    public partial class SGPluginControl : UserControl
    {
        public SGPluginControl ()
        {
            InitializeComponent();

            // set defaults to StressSettings
            StressSettings.Instance.Connections.SocketsToUse = (uint)nudSockets.Value;
            StressSettings.Instance.Connections.MaximumConnections = (uint)nudConnections.Value;
        }

        private void nudSockets_ValueChanged (object sender, EventArgs e)
        {
            StressSettings.Instance.Connections.SocketsToUse = (uint)nudSockets.Value;
        }

        private void nudConnections_ValueChanged (object sender, EventArgs e)
        {
            StressSettings.Instance.Connections.MaximumConnections = (uint)nudConnections.Value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\SGPluginControl.designer.cs ===
namespace SGNatTest
{
    partial class SGPluginControl
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose (bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            System.Windows.Forms.GroupBox groupBox1;
            System.Windows.Forms.Label label2;
            System.Windows.Forms.Label label1;
            this.nudSockets = new System.Windows.Forms.NumericUpDown();
            this.nudConnections = new System.Windows.Forms.NumericUpDown();
            groupBox1 = new System.Windows.Forms.GroupBox();
            label2 = new System.Windows.Forms.Label();
            label1 = new System.Windows.Forms.Label();
            groupBox1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.nudSockets)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudConnections)).BeginInit();
            this.SuspendLayout();
            // 
            // groupBox1
            // 
            groupBox1.Controls.Add(this.nudSockets);
            groupBox1.Controls.Add(label2);
            groupBox1.Controls.Add(this.nudConnections);
            groupBox1.Controls.Add(label1);
            groupBox1.Location = new System.Drawing.Point(3, 3);
            groupBox1.Name = "groupBox1";
            groupBox1.Size = new System.Drawing.Size(199, 247);
            groupBox1.TabIndex = 0;
            groupBox1.TabStop = false;
            groupBox1.Text = "Settings";
            // 
            // nudSockets
            // 
            this.nudSockets.Location = new System.Drawing.Point(81, 40);
            this.nudSockets.Maximum = new decimal(new int[] {
            50000,
            0,
            0,
            0});
            this.nudSockets.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.nudSockets.Name = "nudSockets";
            this.nudSockets.Size = new System.Drawing.Size(71, 20);
            this.nudSockets.TabIndex = 3;
            this.nudSockets.Value = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.nudSockets.ValueChanged += new System.EventHandler(this.nudSockets_ValueChanged);
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new System.Drawing.Point(26, 42);
            label2.Name = "label2";
            label2.Size = new System.Drawing.Size(49, 13);
            label2.TabIndex = 2;
            label2.Text = "Sockets:";
            // 
            // nudConnections
            // 
            this.nudConnections.Location = new System.Drawing.Point(81, 14);
            this.nudConnections.Maximum = new decimal(new int[] {
            200000,
            0,
            0,
            0});
            this.nudConnections.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.nudConnections.Name = "nudConnections";
            this.nudConnections.Size = new System.Drawing.Size(71, 20);
            this.nudConnections.TabIndex = 1;
            this.nudConnections.Value = new decimal(new int[] {
            10000,
            0,
            0,
            0});
            this.nudConnections.ValueChanged += new System.EventHandler(this.nudConnections_ValueChanged);
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new System.Drawing.Point(6, 16);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(69, 13);
            label1.TabIndex = 0;
            label1.Text = "Connections:";
            // 
            // SGPluginControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(groupBox1);
            this.Name = "SGPluginControl";
            this.Size = new System.Drawing.Size(361, 296);
            groupBox1.ResumeLayout(false);
            groupBox1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.nudSockets)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudConnections)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.NumericUpDown nudConnections;
        private System.Windows.Forms.NumericUpDown nudSockets;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\StressConnectionPool.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;

using ServerTestFramework.LiveService.Auth;

namespace SGNatTest
{
    /// <summary>
    /// Maintains a pool of connections for use in stress situations.
    /// </summary>
    /// <remarks>
    /// The designed usage of connections is to use PopConnection if exclusive access is required.  The connection
    /// should later be returned with PushConnection.  If exclusive access is not required, use GetConnection.
    /// </remarks>
    public class StressConnectionPool
    {
        #region Constructor

        /// <summary>
        /// Initialized the StressConnectionPool.
        /// </summary>
        public StressConnectionPool ()
        {
            _connections = new Queue<SGConnection>[(int)ConnectionState.Maximum];
        }

        #endregion

        #region Sockets

        /// <summary>Backing for SocketsToUse.</summary>
        private uint _socket_count = 0;

        /// <summary>
        /// Gets or sets the number of sockets to use.
        /// </summary>
        /// <remarks>
        /// Sockets are not closed instantly as this value is reduced, but rather as the connections that use a
        /// socket are closed.  When the last connection finishes, the socket will be placed into the garbage
        /// collection set.  This was chosen as it is not expected that the number of sockets will change frequently.
        /// </remarks>
        public uint SocketsToUse
        {
            get { return _socket_count; }
            set
            {
                lock (_sockets)
                {
                    _socket_count = value;
                    uint current = (uint)_sockets.Count;

                    if (_socket_count > current)
                    {
                        // add
                        _sockets.Capacity = (int)_socket_count;
                        for (uint i = current; i < _socket_count; ++i)
                        {
                            _sockets.Add(new XspUdp());
                        }
                    }
                    else if (_socket_count < current)
                    {
                        // remove
                        _sockets.RemoveRange((int)_socket_count, (int)(current - _socket_count));

                        // also, we need to make sure we weren't going to use one of those
                        if (_current_socket >= _socket_count)
                        {
                            _current_socket = 0;
                        }
                    }
                }
            }
        }

        /// <summary>The <c>XspUdp</c> sockets used by the connections.</summary>
        protected List<XspUdp> _sockets = new List<XspUdp>();

        /// <summary>
        /// Used by GetSocket to 'evenly' spread the sockets to connections.
        /// </summary>
        protected uint _current_socket = 0;

        /// <summary>
        /// Gets the next socket from the list.
        /// </summary>
        /// <returns>A socket.</returns>
        protected XspUdp GetSocket ()
        {
            if (_socket_count == 0)
            {
                throw new InvalidOperationException("There are no sockets (SocketsToUse == 0)");
            }

            lock (_sockets)
            {
                int val = (int)_current_socket;
                _current_socket = (_current_socket + 1) % _socket_count;
                return _sockets[val];
            }
        }

        #endregion

        #region Connections

        /// <summary>Backing for MaximumConnections.</summary>
        private uint _max_connections = 0;

        /// <summary>
        /// The maximum number of connections that we will have at once.
        /// </summary>
        /// <remarks>
        /// Connections are not necessarily closed instantly as this value is reduced, but rather as the 
        /// connections enter the default state.  This was chosen as it is not expected that the number of 
        /// connections will change frequently.
        /// </remarks>
        public uint MaximumConnections
        {
            get { return _max_connections; }
            set
            {
                _max_connections = value;
            }
        }

        /// <summary>
        /// The current number of connections being tracked by the pool.  Is not 100% perfect.
        /// </summary>
        public uint TotalConnections
        {
            get
            {
                uint ans = 0;

                for (int i = 0; i < (int)ConnectionState.Maximum; ++i)
                {
                    Queue<SGConnection> q = _connections[i];
                    if (q != null)
                    {
                        ans += (uint)q.Count;
                    }
                }

                return ans + (uint)_connections_checked_out;
            }
        }

        /// <summary>
        /// The connections divided into groups by state, in LRU queues.
        /// </summary>
        protected Queue<SGConnection>[] _connections = null;

        /// <summary>The number of connections that have been acquired by a user.</summary>
        protected int _connections_checked_out = 0;

        /// <summary>
        /// Gets the queue associated with the given state.
        /// </summary>
        /// <param name="state">The state queue to get.</param>
        /// <returns>The queue associated with the given state, or null if there isn't one.</returns>
        protected Queue<SGConnection> GetQueue (ConnectionState state)
        {
            return _connections[(int)state];
        }

        /// <summary>
        /// Gets the queue associated with the given state.  Creates it if it does not already exist.
        /// </summary>
        /// <param name="state">The state queue to get.</param>
        /// <returns>The queue associated with the given state.</returns>
        protected Queue<SGConnection> GetQueueWithCreate (ConnectionState state)
        {
            Queue<SGConnection> ans = GetQueue(state);

            // near 100% case
            if (ans != null)
            {
                return ans;
            }

            // we have to create one
            lock (_connections)
            {
                ans = _connections[(int)state];

                // did someone else beat us?
                if (ans != null)
                {
                    return ans;
                }
                else
                {
                    ans = new Queue<SGConnection>();
                    _connections[(int)state] = ans; ;
                    return ans;
                }
            }
        }

        /// <summary>
        /// Creates a new connection, if possible.
        /// </summary>
        /// <param name="state">The state to create the connection in.</param>
        /// <returns>A new connection, or null if one cannot be created.</returns>
        protected SGConnection CreateConnection (ConnectionState state)
        {
            // can only create in default state
            // cannot create any more if over max
            if (state != _default_state || TotalConnections >= MaximumConnections)
            {
                return null;
            }

            SGConnection ans = new SGConnection();
            ans.Transport = GetSocket();

            return ans;
        }

        /// <summary>
        /// Gets a connection in the current state.  The connection is removed from the pool.  It can be returned
        /// later, see PushConnection.
        /// </summary>
        /// <param name="state">The state of the connection to be returned.</param>
        /// <returns>A connection in the requested state, or null if one is not available.</returns>
        public SGConnection PopConnection (ConnectionState state)
        {
            Queue<SGConnection> q = GetQueue(state);
            SGConnection ans = null;

            // no queue
            if (q == null)
            {
                ans = CreateConnection(state);
            }
            else
            {
                lock (q)
                {
                    // empty
                    if (q.Count == 0)
                    {
                        ans = CreateConnection(state);
                    }
                    else
                    {
                        ans = q.Dequeue();
                    }
                }
            }

            if (ans != null)
            {
                Interlocked.Increment(ref _connections_checked_out);
            }

            return ans;
        }

        /// <summary>
        /// A way for us to notify the pool that we lost the connection.
        /// </summary>
        internal void RemovePoppedConnection ()
        {
            Interlocked.Decrement(ref _connections_checked_out);
        }

        /// <summary>
        /// Puts a connection back into the pool.  The connection may be dropped if it is in the
        /// default state and too many connections are already in the pool.
        /// </summary>
        /// <param name="conn">The connection to put back.</param>
        /// <param name="state">The state it is in.</param>
        public void PushConnection (SGConnection conn, ConnectionState state)
        {
            Debug.Assert(conn != null);

            Queue<SGConnection> q = GetQueueWithCreate(state);

            if (state != _default_state || TotalConnections <= MaximumConnections)
            {
                lock (q)
                {
                    q.Enqueue(conn);
                }
            }

            Interlocked.Decrement(ref _connections_checked_out);
        }

#if false
        /// <summary>
        /// Looks for a connection in the pool, if it is found it is transitioned to another state.
        /// </summary>
        /// <param name="conn">The connection transition or replace.</param>
        /// <param name="state">The state is is in or it should be moved to.</param>
        public void PushOrTransitionConnection (SGConnection conn, ConnectionState state)
        {
        }
#endif

        /// <summary>
        /// Gets a connection in the current state.  The connection is not removed from the pool, but is placed
        /// at the end of its state queue.
        /// </summary>
        /// <param name="state">The state of the connection to be returned.</param>
        /// <returns>A connection in the requested state, or null if one is not available.</returns>
        public SGConnection GetConnection (ConnectionState state)
        {
            Queue<SGConnection> q = GetQueueWithCreate(state);
            SGConnection ans = null;

            lock (q)
            {
                // empty
                if (q.Count == 0)
                {
                    ans = CreateConnection(state);
                }
                else
                {
                    ans = q.Dequeue();
                }
            }

            if (ans != null)
            {
                q.Enqueue(ans);
            }

            return ans;
        }

        #endregion

        #region State

        /// <summary>
        /// The state of a connection.
        /// </summary>
        public enum ConnectionState
        {
            /// <summary>The connection is not connected.</summary>
            Unconnected,
            /// <summary>The connection is connected.</summary>
            Connected,
            /// <summary>A state used for debugging bad connections.</summary>
            Error,
            /// <summary>The last value of the enumeration.</summary>
            Maximum
        }

        /// <summary>Backing for DefaultState.</summary>
        protected ConnectionState _default_state = ConnectionState.Unconnected;

        /// <summary>
        /// The default state of a connection; the state that a connection should be in when it is first created.
        /// </summary>
        public ConnectionState DefaultState
        {
            get { return _default_state; }
            set { _default_state = value; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\StressSettings.cs ===
using System;
using System.Threading;

namespace SGNatTest
{
    /// <summary>
    /// A class that is meant to be used as a singleton for communication of stress settings between tests and
    /// the plugin.  Also stores some objects that are shared across stress tests that rely on these communicated
    /// settings.
    /// </summary>
    public class StressSettings
    {
        #region Singleton

        /// <summary>Backing for Instance.</summary>
        private static StressSettings _singleton = null;

        /// <summary>
        /// The singleton settings object for generic use.
        /// </summary>
        public static StressSettings Instance { get { return _singleton; } }

        /// <summary>
        /// The lazy way to initialize our singleton.  I'm ok with that.
        /// </summary>
        static StressSettings ()
        {
            _singleton = new StressSettings();
        }

        /// <summary>
        /// Default constructor.
        /// </summary>
        public StressSettings ()
        {
            _connections = new StressConnectionPool();
            _services = new ushort[] { 334, 337 };
        }

        #endregion

        #region Settings

        #region Connections

        /// <summary>Backing for Connections.</summary>
        private StressConnectionPool _connections = null;

        /// <summary>
        /// The pool of connections to use during stress.
        /// </summary>
        public StressConnectionPool Connections { get { return _connections; } }

        #endregion

        #region Service IDs

        /// <summary>Backing for ServiceIDs.</summary>
        private ushort[] _services = null;

        /// <summary>
        /// The service IDs to use when sending traffic to the SG.
        /// </summary>
        public ushort[] ServiceIDs
        {
            get { return _services; }
            set { _services = value; }
        }

        /// <summary>Used by NextServiceID.</summary>
        private int _service_index = 0;

        /// <summary>
        /// The next service in the rotation.
        /// </summary>
        public ushort NextServiceID
        {
            get
            {
                int index = Interlocked.Increment(ref _service_index);
                return _services[(index & 0x7FFFFFFF) % _services.Length];
            }
        }

        #endregion

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\template\driver\driver.cpp ===
// ---------------------------------------------------------------------------------------
// driver.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "driverp.h"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void            DriverUnload(PDRIVER_OBJECT pDriverObject);

extern "C"
{
    NTSTATUS        DeviceControl(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceNoop(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceUnsupported(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
}


// ---------------------------------------------------------------------------------------
// DriverEntry
// ---------------------------------------------------------------------------------------

EXTERN_C
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    DbgPrint("DriverEntry\n");

    //
    // Initialize the driver object with this driver's entrypoints.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &DeviceNoop;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = &DeviceNoop;
    DriverObject->DriverUnload = &DriverUnload;

    return STATUS_SUCCESS;
}

void
DriverUnload(
    PDRIVER_OBJECT pDriverObject
    )
{
    DbgPrint("DriverUnload\n");
}

NTSTATUS
DeviceNoop(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
{ return STATUS_SUCCESS; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\template\driver\driverp.h ===
extern "C"
{
    #include <ntddk.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\StressSg.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Net;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace SGNatTest
{
    #region Sign in LSP style
    /*
    [StressTest(Priority=0)]
    public class SignIn_TSKeyExchange_Machine : TestBase_Stress
    {
        protected override TEST_RESULTS SgExecute()
        {
            return SignIn(AuthContext.ClientTypes.Xenon, 0, 0x0011, true);
        }
    }

    [StressTest(Priority=0)]
    public class SignIn_TSKeyExchange_1User : TestBase_Stress
    {
        protected override TEST_RESULTS SgExecute()
        {
            return SignIn(AuthContext.ClientTypes.Xenon, 1, 0x0011, true);
        }
    }
    */
    #endregion

    #region Sign in

    [StressTest]
    public class SignIn_KeyExchange_Machine : StressNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SignInAsync(AuthContext.ClientTypes.Xenon, 0, tracker);
        }
    }
    
    [TestCase]
    [StressTest]
    public class SignIn_KeyExchange_1User : StressNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SignInAsync(AuthContext.ClientTypes.Xenon, 1, tracker);
        }
    }

    [StressTest]
    public class SignIn_KeyExchange_4Users : StressNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SignInAsync(AuthContext.ClientTypes.Xenon, 4, tracker);
        }
    }
    /*
    [StressTest(Priority=0)]
    public class SignIn_KeyExchange_1User_AsyncChallenge : TestBase_Stress
    {
        protected override TEST_RESULTS SgExecute()
        {
            return SignIn(AuthContext.ClientTypes.Xenon, 1, 0x0010);
        }
    }
    */
    [StressTest]
    public class SignIn_KeyExchange_1User_PC : StressNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SignInAsync(AuthContext.ClientTypes.Panorama, 1, tracker);
        }
    }
    
    //[StressTest(Priority=0)]
    //public class Optional_Recv : TestBase_Stress
    //{
    //    protected override TEST_RESULTS SgExecute()
    //    {
    //        // We will grab an SgClient from the local store, which has already been
    //        // signed in to the SG.  Remove from store and add it back at end, if necessary.
    //        SgClient sg = SgForm.GetSignedInClient();
    //        if (sg == null)
    //            return TEST_RESULTS.NOT_EXECUTED;

    //        try
    //        {
    //            TEST_RESULTS result = Recv(sg);

    //            if (result == TEST_RESULTS.FAILED)
    //                DeleteClient(sg, "Recv failed");
    //            else
    //                SgForm.PutSignedInClient(sg, false);

    //            return result;
    //        }
    //        catch (Exception e)
    //        {
    //            // Don't want to lose the client, add to free list
    //            DeleteClient(sg, "Recv exception: " + e.Message);
    //            return TEST_RESULTS.FAILED;
    //        }
    //    }
    //}
    /*
    [StressTest(Priority=0)]
    public class Optional_SendChalResponse_Positive : TestBase_Stress
    {
        protected override TEST_RESULTS SgExecute()
        {
            // We will grab an SgClient from the local store, which has already been
            // signed in to the SG.  Remove from store and add it back at end, if necessary.
            SgClient sg = SgForm.GetSignedInClient();
            if (sg == null)
                return TEST_RESULTS.NOT_EXECUTED;

            try
            {
                if (sg.timeToSendChalResponse > 0 &&
                    TimerMs > sg.timeToSendChalResponse)
                {
                    sg.SendChallengeResponse(false);
                    sg.timeToSendChalResponse = 0;
                    SgForm.PutSignedInClient(sg, false);
                    return TEST_RESULTS.PASSED;
                }
                SgForm.PutSignedInClient(sg, false);
                return TEST_RESULTS.NOT_EXECUTED;
            }
            catch (Exception e)
            {
                // Don't want to lose the client, add to free list
                DeleteClient(sg, "Optional_SendChalResponse exception: " + e.Message);
                return TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest(Priority=0)]
    public class Optional_SendChalResponse_Negative : TestBase_Stress
    {
        protected override TEST_RESULTS SgExecute()
        {
            // We will grab an SgClient from the local store, which has already been
            // signed in to the SG.  Remove from store and add it back at end, if necessary.
            SgClient sg = SgForm.GetSignedInClient();
            if (sg == null)
                return TEST_RESULTS.NOT_EXECUTED;

            try
            {
                if (sg.timeToSendChalResponse > 0 &&
                    TimerMs > sg.timeToSendChalResponse)
                {
                    sg.SendChallengeResponse(true);
                    sg.timeToSendChalResponse = 0;
                    DeleteClient(sg, "Challenge kick");
                    return TEST_RESULTS.PASSED;
                }
                SgForm.PutSignedInClient(sg, false);
                return TEST_RESULTS.NOT_EXECUTED;
            }
            catch (Exception e)
            {
                // Don't want to lose the client, add to free list
                DeleteClient(sg, "Optional_SendChalResponse exception: " + e.Message);
                return TEST_RESULTS.FAILED;
            }
        }
    }
    */
    #endregion

    
    #region Throughput
    /*
    //[StressTest(Priority=0)]
    //public class Throughput_16payloadReflect: Throughput_Base
    //{
    //    protected override TEST_RESULTS SgExecute()
    //    {
    //        return GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
    //    }
    //}
    
    [StressTest(Priority=0)]
    public class Throughput_160payloadReflect: Throughput_Base
    {
        protected override TEST_RESULTS SgExecute()
        {
            return GoIfSignedIn(k_payload160, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_1400payloadReflect: Throughput_Base
    {
        protected override TEST_RESULTS SgExecute()
        {
            return GoIfSignedIn(k_payload1400, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadDrop : Throughput_Base
    {
        protected override TEST_RESULTS SgExecute ()
        {
            return GoIfSignedIn(k_payload16, SGFakeService.ActionType.Drop, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_160payloadDrop : Throughput_Base
    {
        protected override TEST_RESULTS SgExecute ()
        {
            return GoIfSignedIn(k_payload160, SGFakeService.ActionType.Drop, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_1400payloadDrop : Throughput_Base
    {
        protected override TEST_RESULTS SgExecute ()
        {
            return GoIfSignedIn(k_payload1400, SGFakeService.ActionType.Drop, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect64 : Throughput_Base
    {
        protected override TEST_RESULTS SgExecute ()
        {
            return GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 8, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect320 : Throughput_Base
    {
        protected override TEST_RESULTS SgExecute ()
        {
            return GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 40, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect1400 : Throughput_Base
    {
        protected override TEST_RESULTS SgExecute ()
        {
            return GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 175, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_64payloadAuthdataLookup: Throughput_Base
    {
        protected override TEST_RESULTS SgExecute()
        {
            // This reflect a regular UDP packet back to us AND does an authdata lookup
            return GoIfSignedIn(k_payload64, SGFakeService.ActionType.ReflectAuthdata, 0, this.ServiceCycle);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_64payloadAuthdataLookupReflect: Throughput_Base
    {
        protected override TEST_RESULTS SgExecute()
        {
            // This reflects the actual authdata back to us
            return GoIfSignedIn(k_payload64, SGFakeService.ActionType.AuthdataLookup, 0, this.ServiceCycle);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_64payloadAuthdataLookupDrop : Throughput_Base
    {
        protected override TEST_RESULTS SgExecute ()
        {
            // This reflects the actual authdata back to us
            return GoIfSignedIn(k_payload64, SGFakeService.ActionType.DropAuthdata, 0, this.ServiceCycle);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_160payloadReflect_Synchronous: Throughput_Base
    {
        protected override TEST_RESULTS SgExecute()
        {
            return GoIfSignedIn(k_payload160, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 500);
        }
    }
    */
    [TestCase]
    [StressTest]
    public class NAT_Single : ThroughputNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SGConnection conn = GetSignedInConnection();

            if (conn == null)
            {
                // no connected connections, skip
                End(TEST_RESULTS.NOT_EXECUTED, tracker);
                return;
            }

            ThroughputTestData testdata = CreateTestData(tracker, conn);
            SendNATThroughput(testdata, GetRandomSourcePort(), StressSettings.Instance.NextServiceID);
            AllowTestComplettion(testdata);
        }
    }

    [StressTest]
    public class NAT_TwoSameSource : ThroughputNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SGConnection conn = GetSignedInConnection();

            if (conn == null)
            {
                // no connected connections, skip
                End(TEST_RESULTS.NOT_EXECUTED, tracker);
                return;
            }

            uint source = GetRandomSourcePort();
            ushort service = StressSettings.Instance.NextServiceID;

            ThroughputTestData testdata = CreateTestData(tracker, conn);
            SendNATThroughput(testdata, source, service);
            SendNATThroughput(testdata, source, service);
            AllowTestComplettion(testdata);
        }
    }

    [StressTest]
    public class NAT_TwoDiffSource : ThroughputNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SGConnection conn = GetSignedInConnection();

            if (conn == null)
            {
                // no connected connections, skip
                End(TEST_RESULTS.NOT_EXECUTED, tracker);
                return;
            }

            uint source1 = GetRandomSourcePort();
            uint source2 = 0;
            do
            {
                source2 = GetRandomSourcePort();
            } while (source1 == source2);

            ushort service = StressSettings.Instance.NextServiceID;

            ThroughputTestData testdata = CreateTestData(tracker, conn);
            SendNATThroughput(testdata, source1, service);
            SendNATThroughput(testdata, source2, service);
            AllowTestComplettion(testdata);
        }
    }

    [StressTest]
    public class NAT_S1_S2_S1 : ThroughputNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SGConnection conn = GetSignedInConnection();

            if (conn == null)
            {
                // no connected connections, skip
                End(TEST_RESULTS.NOT_EXECUTED, tracker);
                return;
            }

            uint source1 = GetRandomSourcePort();
            uint source2 = 0;
            do
            {
                source2 = GetRandomSourcePort();
            } while (source1 == source2);

            ushort service = StressSettings.Instance.NextServiceID;

            ThroughputTestData testdata = CreateTestData(tracker, conn);
            SendNATThroughput(testdata, source1, service);
            SendNATThroughput(testdata, source2, service);
            SendNATThroughput(testdata, source1, service);
            AllowTestComplettion(testdata);
        }
    }

    [StressTest]
    public class NAT_S1_S2_S1_S2 : ThroughputNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SGConnection conn = GetSignedInConnection();

            if (conn == null)
            {
                // no connected connections, skip
                End(TEST_RESULTS.NOT_EXECUTED, tracker);
                return;
            }

            uint source1 = GetRandomSourcePort();
            uint source2 = 0;
            do
            {
                source2 = GetRandomSourcePort();
            } while (source1 == source2);

            ushort service = StressSettings.Instance.NextServiceID;

            ThroughputTestData testdata = CreateTestData(tracker, conn);
            SendNATThroughput(testdata, source1, service);
            SendNATThroughput(testdata, source2, service);
            SendNATThroughput(testdata, source1, service);
            SendNATThroughput(testdata, source2, service);
            AllowTestComplettion(testdata);
        }
    }

    /*
#if false

    [StressTest(Priority=0)]
    public class Throughput_Timestamp: Throughput_Base
    {
        [ThreadStatic]
        protected static byte[] localPayload;

        protected override TEST_RESULTS SgExecute()
        {
            if (localPayload == null)
                localPayload = new byte[16];
            return GoIfSignedIn(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, (ushort)SGFakeService.IServicePort.Service5, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous: Throughput_Base
    {
        [ThreadStatic]
        protected static byte[] localPayload = new byte[16];

        protected override TEST_RESULTS SgExecute()
        {
            bMeasureTimestamp = true;
            return GoIfSignedIn(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, (ushort)SGFakeService.IServicePort.Service5, 500);
        }
    }

#endif
                
    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Async_1User_1Server : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
        }

        protected override TEST_RESULTS RunTest()
        {
            return Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 0);
        }
    }
    
    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous_1User_1Server : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
        }

        protected override TEST_RESULTS RunTest()
        {
            return Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 500);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous_1User : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
        }

        protected override TEST_RESULTS RunTest()
        {
            servicePort = ServiceCycle;
            return Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 500);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous_1User_Big : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
            localPayload = new byte[1400];
        }

        protected override TEST_RESULTS RunTest()
        {
            servicePort = ServiceCycle;
            return Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 500);
        }
    }
    
    [StressTest(Priority=0)]
    public class Throughput_SimulateXboxTcp_1User : Throughput_Base_1Client
    {
        [ThreadStatic]
        protected static ulong packetCount;

        protected override void InitializeTest()
        {
            base.InitializeTest();
            localPayload = new byte[1400];
        }

        protected override TEST_RESULTS RunTest()
        {
            // Send 2 large packets, wait for 1 small packet, repeat.
            if ((++packetCount % 2) == 0)
            {
                // Trigger a small packet reply
                // 1 means we'll get an 8 byte reply (1 << 3)
                return Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 1, servicePort, client, 500);
            }
            else
            {
                // Send a big packet, no reply wanted
                return Go(localPayload, SGFakeService.ActionType.Drop, 0, servicePort, client, 0);
            }

        }
    }
    */  
    #endregion


    #region Secmsg
    /*
    [StressTest(Priority=0)]
    public class SecMsg_DataPulse: SecMsg_Base
    {
        protected override void SendPacket(SgClient sg)
        {
            sg.SendDataPulse();
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_DataPulseStateChange: SecMsg_Base
    {
        private static uint FakeState = 0;
        protected override void SendPacket(SgClient sg)
        {
            ulong userpuid = (sg.Context.Authdata as Authdata_Xenon).users[0].qwUserID;
            sg.SendDataPulseStateChange(FakeState++, userpuid);
            if (FakeState >= uint.MaxValue)
                FakeState = 0;
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_Pulse: SecMsg_Base
    {
        protected override void SendPacket(SgClient sg)
        {
            sg.SendPulse();
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_QOS: SecMsg_Base
    {
        protected override void SendPacket(SgClient sg)
        {
            sg.SendQos(0, false);
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_XbToXbForward: SecMsg_Base
    {
        // Arbitrary size for payload
        protected static byte[] message = new byte[256];

        protected override void SendPacket(SgClient sg)
        {
            // Send it to me
            SGAddress recipient = sg.KeyexResult.keyexResp.SGAddressInit;
            sg.SendXbToXbForward(recipient, message);
        }
    }
    */
    [TestCase]
    [StressTest]
    public class SecMsg_Logoff : StressNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            SGConnection conn = GetSignedInConnection();

            if (conn == null)
            {
                // no connected connections, skip
                End(TEST_RESULTS.NOT_EXECUTED, tracker);
                return;
            }

            SignOut(conn);
            End(TEST_RESULTS.PASSED, tracker);
        }
    }
    /*
    [StressTest(Priority=0)]
    public class ForceConfigReload_NPDBSetting_Stats : StressTestBase
    {
        public const string SQLCommandText = @"
Update t_settings set vc_value = {0} where vc_setting = 'sg_StatsConfidenceLimitInClients'
Update t_settings set vc_value = {1} where vc_setting = 'sg_StatsPenaltyTimeInSeconds'
";
        public readonly int[] ConfidenceValues = new int[] { 2001, 2000 };
        public static int ConfidenceIndex = 0;
        public readonly int[] PenaltyValues = new int[] { 121, 120 };
        public static int PenaltyIndex = 0;

        protected override void Execute ()
        {
            string commtemp = String.Format(SQLCommandText, ConfidenceValues[ConfidenceIndex], 
                PenaltyValues[PenaltyIndex]);
            ConfidenceIndex = (ConfidenceIndex + 1) % ConfidenceValues.Length;
            PenaltyIndex = (PenaltyIndex + 1) % PenaltyValues.Length;

            using (SqlConnection conn = new SqlConnection("Data Source=" + Global.DefaultNpdbSetting.ip +
                ";Initial Catalog=npdb;Integrated Security=SSPI"))
            {
                conn.Open();
                SqlCommand comm = new SqlCommand(commtemp, conn);
                comm.ExecuteNonQuery();
                conn.Close();
            }

            ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressTest(Priority = 0)]
    public class ForceConfigReload_NPDBSetting_StatsReallocate : StressTestBase
    {
        public const string SQLCommandText = @"
Update t_settings set vc_value = {0} where vc_setting = 'sg_StatsConfidenceLimitInClients'
Update t_settings set vc_value = {1} where vc_setting = 'sg_StatsHistoryInMs'
";
        public readonly int[] ConfidenceValues = new int[] { 2001, 2000 };
        public static int ConfidenceIndex = 0;
        public readonly int[] HistoryValues = new int[] { 0, 60000 };
        public static int HistoryIndex = 0;

        protected override void Execute ()
        {
            string commtemp = String.Format(SQLCommandText, ConfidenceValues[ConfidenceIndex],
                HistoryValues[HistoryIndex]);
            ConfidenceIndex = (ConfidenceIndex + 1) % ConfidenceValues.Length;
            HistoryIndex = (HistoryIndex + 1) % HistoryValues.Length;

            using (SqlConnection conn = new SqlConnection("Data Source=" + Global.DefaultNpdbSetting.ip +
                ";Initial Catalog=npdb;Integrated Security=SSPI"))
            {
                conn.Open();
                SqlCommand comm = new SqlCommand(commtemp, conn);
                comm.ExecuteNonQuery();
                conn.Close();
            }

            ResultCode = TEST_RESULTS.PASSED;
        }
    }
    */
    #endregion

    #region Negative Cases
    /*
    [StressTest(Priority=0)]
    public class BadFlags_PacketLeak : StressTestBase
    {
        protected static byte[] Payload;
        protected static SimpleUdpSG SUSG;
        protected static IPEndPoint SGIP;

        static BadFlags_PacketLeak ()
        {
            Payload = Packet_Validity.BadPacketType_Leak.ConstructPayload("Packet leak stress");
            SUSG = new SimpleUdpSG();
            SGIP = Global.XEnv.GetVirtualInterface("sgsvc");
        }

        protected override void Execute ()
        {
            SUSG.SendFast(Payload, Payload.Length, SGIP);
        }
    }
    */
    #endregion
    
    /*
    [TestCase]
    public class RegTest : TestNode
    {
        public override TEST_RESULTS Run ()
        {
            ManualResetEvent mre = new ManualResetEvent(false);

            RegisteredWaitHandle[] regs = new RegisteredWaitHandle[1000];

            for (int i = 0; i < 1000; ++i)
            {
                regs[i] = ThreadPool.RegisterWaitForSingleObject(mre, WOTC, i, (i + 1) * 100, true);
            }

            for (int i = 0; i < 1000; i += 2)
            {
                regs[i].Unregister(null);
            }

            return TEST_RESULTS.PASSED;
        }

        public void WOTC (object state, bool timedout)
        {
            Global.RO.Info("WOTC" + state.ToString());
        }
    }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\ThroughputReflector\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\ThroughputReflector\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\TestBase_Stress.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Net;
using System.Runtime.InteropServices;
using System.Collections;   
using System.Collections.Generic;   
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

[assembly: RootNode(typeof(SGNatTest.Suite))]

namespace SGNatTest
{
    [Owner("johnmcp"), TestFrequency("Daily"), EnvRequirement("SGReflector,Manual")]
    class Suite : TestNode { }

    class SgStressException : Exception
    {
        public SgStressException(string format, params object[] args) : base(String.Format(format, args)) {}
    }

    /// <summary>
    /// The base node for SG stress tests.  It does everything that any generic test might.  To add non-generic
    /// members, please override.  Remember that Async nodes should only have one actual object created, and any
    /// access to member must be thread safe.
    /// </summary>
    public abstract class StressNode : AsyncStressTestNode
    {
        /// <summary>
        /// The report to be used by stress tests.
        /// </summary>
        public static Report ro = new Report("SgStress");

        public static SGConnection GetSignedInConnection ()
        {
            SGConnection conn = null;

            try
            {
                while (true)
                {
                    conn = StressSettings.Instance.Connections.PopConnection(StressConnectionPool.ConnectionState.Connected);

                    if (conn == null)
                    {
                        return null;
                    }

                    if (!conn.IsConnected)
                    {
                        // so we aren't connected any more, throw us back into the other q
                        conn.Disconnect();
                        StressSettings.Instance.Connections.PushConnection(conn, StressConnectionPool.ConnectionState.Unconnected);
                    }
                    else
                    {
                        return conn;
                    }
                }
            }
            catch
            {
                if (conn != null)
                {
                    // if something bad happens, we will assume its not connected
                    StressSettings.Instance.Connections.PushConnection(conn, StressConnectionPool.ConnectionState.Unconnected);
                }
                throw;
            }
        }

        #region SignIn

        #region Shared SignIn

        protected void PreSignIn (AuthContext.ClientTypes clientType, int numUsers, ushort buildNum,
            out SGConnection conn)
        {
            conn =
                StressSettings.Instance.Connections.PopConnection(StressConnectionPool.ConnectionState.Unconnected);

            // No connection was available or could be created :(
            if (conn == null)
            {
                return;
            }

            // Force a new machine, new nonces, etc
            if (conn.Context != null)
            {
                SgClient.FakeSignInXkdc(conn.Context);
            }
            // Create if necessary
            else
            {
                AuthContext ctx = new AuthContext(clientType);

                // Set users
                if (numUsers > 0)
                {
                    for (int i = 0; i < numUsers; i++)
                    {
                        ctx.SetUser("sgstressusr" + i, i);
                    }
                }

#if !LSPTEST
                conn.Context = ctx;
                if (numUsers > 0)
                {
                    conn.UseConnectionServices = true;
                }
                ctx.Site = SiteInfoManager.GetDefaultSgSite();
#else
                LspClient lsp = new LspClient(ctx);
                sg = (SgClient)lsp;
                sg.Context.Site = SiteInfoManager.GetDefaultLspSite();
#endif
                //////////////////////////////////////////////
                //sg.TimeoutInMs = 2000;
                //////////////////////////////////////////////
                conn.UseRealXKDC = false;

                // Get the authdata version right
                if (ctx.Site.authdataVersion == 3)
                {
                    ctx.Authdata = new Authdata_Xenon();
                    SgClient.SetDefaultAuthdata(ctx, ctx.Authdata as Authdata_Xenon);
                }
                else
                {
                    ctx.Authdata = new Authdata_Xbox2();
                    SgClient.SetDefaultAuthdata(ctx, ctx.Authdata as Authdata_Xbox2);
                }
            }

            // Buildnum 0x0010 should cause us to get asynchronously challenged
            conn.Context.TitleInfo.BuildNumber = buildNum;
        }

        #endregion

        public TEST_RESULTS SignIn (AuthContext.ClientTypes clientType, int numUsers)
        {
            return SignIn(clientType, numUsers, 0);
        }

        public TEST_RESULTS SignIn (AuthContext.ClientTypes clientType, int numUsers, ushort buildNum)
        {
            return SignIn(clientType, numUsers, buildNum, false);
        }

        public TEST_RESULTS SignIn (AuthContext.ClientTypes clientType, int numUsers, ushort buildNum, bool bTSKeyex)
        {
            //string serverName = "sg";

            SGConnection conn;
            PreSignIn(clientType, numUsers, buildNum, out conn);

            // No connection was available or could be created :(
            if (conn == null)
            {
                return TEST_RESULTS.NOT_EXECUTED;
            }

            //string errMessage = "";
            try
            {
#if !LSPTEST
                //serverName = "sg";
                conn.Connect();
#else
                try
                {
                serverName = "ts";
                if (!bTSKeyex)
                {
                    // SG-style key exchange
                    sg.SignInSG();
                }
                else
                {
                    // LSP TS-style key exchange
                    (sg as LspClient).SignInLSPWithTSKey();
                }
                }
                catch
                {
                    ro.Debug(sg.Context.Authdata.ToString());
                    throw;
                }
#endif

                StressSettings.Instance.Connections.PushConnection(conn, 
                    StressConnectionPool.ConnectionState.Connected);
                return TEST_RESULTS.PASSED;
            }
            catch (Exception e)
            {
                ro.Error("Got exception signing in, adding client back to unconnected queue:\n" + e.ToString());
                StressSettings.Instance.Connections.PushConnection(conn, 
                    StressConnectionPool.ConnectionState.Unconnected);
                //errMessage = e.Message;
            }

            return TEST_RESULTS.FAILED;
        }

        public void SignInAsync (AuthContext.ClientTypes clientType, int numUsers, AsyncStressTracking tracker)
        {
            SignInAsync(clientType, numUsers, 0, false, tracker);
        }

        public void SignInAsync (AuthContext.ClientTypes clientType, int numUsers, ushort buildNum, bool bTSKeyex, 
            AsyncStressTracking tracker)
        {
            //string serverName = "sg";

            SignInAsyncState state = new SignInAsyncState();
            state.Tracker = tracker;

            PreSignIn(clientType, numUsers, buildNum, out state.Conn);

            // No connection was available or could be created :(
            if (state.Conn == null)
            {
                SignInAsyncEnd(TEST_RESULTS.NOT_EXECUTED, tracker, null);
                return;
            }

            //string errMessage = "";
            try
            {
#if !LSPTEST
                //serverName = "sg";
                state.Conn.ConnectAsync(SignInAsyncCallback, state);
#else
                try
                {
                serverName = "ts";
                if (!bTSKeyex)
                {
                    // SG-style key exchange
                    sg.SignInSG();
                }
                else
                {
                    // LSP TS-style key exchange
                    (sg as LspClient).SignInLSPWithTSKey();
                }
                }
                catch
                {
                    ro.Debug(sg.Context.Authdata.ToString());
                    throw;
                }
#endif
            }
            catch (Exception e)
            {
                ro.Error("Got exception signing in, adding client back to unconnected queue:\n" + e.ToString());
                StressSettings.Instance.Connections.PushConnection(state.Conn,
                    StressConnectionPool.ConnectionState.Unconnected);
                //errMessage = e.Message;
                SignInAsyncEnd(TEST_RESULTS.FAILED, tracker, e);
            }
        }

        protected class SignInAsyncState
        {
            public AsyncStressTracking Tracker;
            public SGConnection Conn;
        }

        protected void SignInAsyncCallback (object userData, Exception exc)
        {
            SignInAsyncState state = null;

            try
            {
                state = (SignInAsyncState)userData;

                if (exc != null)
                {
                    ro.Error("Got exception signing in, adding client back to unconnected queue:\n" + exc.ToString());
                    StressSettings.Instance.Connections.PushConnection(state.Conn,
                        StressConnectionPool.ConnectionState.Unconnected);
                    //errMessage = e.Message;
                    SignInAsyncEnd(TEST_RESULTS.FAILED, state.Tracker, exc);
                }
                else
                {
                    StressSettings.Instance.Connections.PushConnection(state.Conn,
                        StressConnectionPool.ConnectionState.Connected);
                    SignInAsyncEnd(TEST_RESULTS.PASSED, state.Tracker, null);
                }
            }
            catch (Exception e)
            {
                if (state == null)
                {
                    ro.Error("Got exception signing in, state is null, client has been lost and test cannot " + 
                        "complete:\n" + e.ToString());
                    StressSettings.Instance.Connections.RemovePoppedConnection();
                }
                else
                {
                    ro.Error("Got exception after signing in, adding client back to unconnected queue:\n" + e.ToString());
                    StressSettings.Instance.Connections.PushConnection(state.Conn,
                        StressConnectionPool.ConnectionState.Unconnected);
                    //errMessage = e.Message;
                    SignInAsyncEnd(TEST_RESULTS.FAILED, state.Tracker, e);
                }
            }
        }

        protected virtual void SignInAsyncEnd (TEST_RESULTS result, AsyncStressTracking tracker, Exception exc)
        {
            if (exc == null)
            {
                End(result, tracker);
            }
            else
            {
                End(exc, tracker);
            }
        }

        #endregion

        #region SignOut

        /// <summary>
        /// Signs the connection out.
        /// </summary>
        public void SignOut (SGConnection conn)
        {
            try
            {
                conn.Disconnect();
                StressSettings.Instance.Connections.PushConnection(conn, StressConnectionPool.ConnectionState.Unconnected);
            }
            catch
            {
                // if we failed this simple task, then this connection might be broken, lets toss it
                StressSettings.Instance.Connections.RemovePoppedConnection();
                throw;
            }
        }

        #endregion
    }

    /// <summary>
    /// Throughput tests.
    /// </summary>
    public abstract class ThroughputNode : StressNode
    {
        #region Public Statics

        /// <summary>
        /// The maximum number of ports that can be mapped per connection.
        /// Corresponds to the t_setting, sg_ClientPortLimit.
        /// </summary>
        public static int MaxPortMappingsPerConnection = 64;

        #endregion

        #region Sequence

        private static int Sequence = 0;

        protected static uint NextSequence { get { return (uint)(Interlocked.Increment(ref Sequence)); } }

        #endregion

        #region TestData

        protected static ThroughputTestData CreateTestData (AsyncStressTracking tracker, SGConnection conn)
        {
            ThroughputTestData ans = new ThroughputTestData();
            ans.Tracker = tracker;
            ans.Connection = conn;
            ans.Mapping = GetNATMapping(conn);

            return ans;
        }

        protected void AllowTestComplettion (ThroughputTestData testdata)
        {
            testdata.CanComplete = true;
            CheckForCompletion(testdata);
        }

        private void CheckForCompletion (ThroughputTestData testdata)
        {
            if (testdata.CanComplete && testdata.Packets.Count == 0)
            {
                InternalEnd(TEST_RESULTS.PASSED, testdata, null);
            }
        }

        #endregion

        #region NatMapping

        private static NATMapping GetNATMapping (SGConnection conn)
        {
            NATMapping ans = (NATMapping)conn.GetUserData("NATMapping");

            if (ans != null && ans.Spi == conn.Session.ReceiveSPI)
            {
                return ans;
            }

            ans = new NATMapping();
            ans.Spi = conn.Session.ReceiveSPI;
            conn.SetUserData("NATMapping", ans);
            return ans;
        }

        #endregion

        #region Data Classes

        public class NATThroughput
        {
            public uint Sequence;
            public uint SourcePort;
            public uint DestPort;
        }

        public class ThroughputTestData
        {
            public AsyncStressTracking Tracker;
            public SGConnection Connection;
            public NATMapping Mapping;
            public LinkedList<NATThroughput> Packets = new LinkedList<NATThroughput>();
            public bool CanComplete = false;
            public int Completed = 0;

            public void AddPacket (NATThroughput natt)
            {
                lock (Packets)
                {
                    Packets.AddLast(natt);
                }
            }

            public uint GetPacket (uint seq, out NATThroughput natt)
            {
                uint ans = 0;
                natt = null;

                lock (Packets)
                {
                    LinkedListNode<NATThroughput> node = Packets.First;

                    if (node == null)
                    {
                        return 0;
                    }

                    ans = node.Value.Sequence;

                    while (node != null)
                    {
                        if (node.Value.Sequence == seq)
                        {
                            natt = node.Value;
                            Packets.Remove(node);
                            return ans;
                        }
                        node = node.Next;
                    }
                }

                return 0;
            }
        }

        public class NATMapping
        {
            public uint Spi;
            public IPAddress Address;

            public struct PortMapping
            {
                public uint LocalSource, RemoteSource;
            }
            public PortMapping[] SourcePortMapping;
            public uint[] LRUList;
            public uint Count = 0;

            public bool IsUnmapped { get { return (Address == null && SourcePortMapping == null); } }

            public void Init ()
            {
                SourcePortMapping = new PortMapping[MaxPortMappingsPerConnection];
                LRUList = new uint[MaxPortMappingsPerConnection];
            }

            public uint this[uint l]
            {
                get
                {
                    uint i = 0;

                    for (; i < Count; ++i)
                    {
                        if (SourcePortMapping[LRUList[i]].LocalSource == l)
                        {
                            break;
                        }
                    }

                    if (i < Count)
                    {
                        uint ans = SourcePortMapping[LRUList[i]].RemoteSource;

                        // move it to the back
                        uint temp = LRUList[i];
                        Buffer.BlockCopy(LRUList, (int)(4 * (i + 1)), LRUList, (int)(4 * i), (int)(4 * (Count - i - 1)));
                        LRUList[Count - 1] = temp;

                        return ans;
                    }
                    else
                    {
                        return 0;
                    }
                }
            }

            public void Map (uint local, uint remote)
            {
                if (Count < MaxPortMappingsPerConnection)
                {
                    // add it at the end
                    SourcePortMapping[Count].LocalSource = local;
                    SourcePortMapping[Count].RemoteSource = remote;
                    LRUList[Count] = Count;
                    ++Count;
                }
                else
                {
                    // remap the one with the same remote source
                    uint i = 0;

                    for (; i < Count; ++i)
                    {
                        if (SourcePortMapping[LRUList[i]].RemoteSource == remote)
                        {
                            break;
                        }
                    }

                    //if (i != 0)
                    //{
                    //    // packet reordering detected
                    //}

                    if (i >= Count)
                    {
                        uint min = uint.MaxValue;
                        uint max = uint.MinValue;

                        for (uint j = 0; j < Count; ++j)
                        {
                            min = Math.Min(min, SourcePortMapping[j].RemoteSource);
                            max = Math.Max(max, SourcePortMapping[j].RemoteSource);
                        }

                        throw new SgStressException("Got a remote source port that we shouldn't be able to get for [{0}, {1}]: {2}",
                            min, max, remote);
                    }

                    uint ind = LRUList[i];
                    Buffer.BlockCopy(LRUList, (int)(4 * (i + 1)), LRUList, (int)(4 * i), (int)(4 * (Count - i - 1)));
                    SourcePortMapping[ind].LocalSource = local;
                    // remote should already be this, since that is how we found this one
                    //SourcePortMapping[ind].RemoteSource = remote;
                    LRUList[Count - 1] = ind;
                }
            }
        }

        #endregion

        public void SendNATThroughput (ThroughputTestData testdata, uint sourcePort, uint destPort)
        {
            NATThroughput natt = new NATThroughput();
            natt.Sequence = NextSequence;
            natt.SourcePort = sourcePort;
            natt.DestPort = destPort;

            // put body data in
            XspBuffer buffer = XspBufferManager.Allocate();
            buffer.RawBuffer[4] = (byte)SGFakeService.ActionType.ReflectNATData;
            buffer.SetUInt32(5, natt.Sequence);
            
            // encode/encrypt
            testdata.Connection.Session.EncodeUdpWithDataInPlace(buffer, sourcePort, destPort, 5);

            // register
            testdata.AddPacket(natt);

            // send
            testdata.Connection.SendAsyncWithFree(buffer);

            // receive
            testdata.Connection.ReceiveDecryptedAsync(SendNATThroughputCallback, testdata);
        }

        private void SendNATThroughputCallback (object userData, XspBuffer buffer, Exception exc)
        {
            ThroughputTestData testdata = null;

            try
            {
                testdata = (ThroughputTestData)userData;

                if (exc != null)
                {
                    InternalEnd(TEST_RESULTS.FAILED, testdata, exc);
                }
                else if (buffer == null)
                {
                    InternalEnd(TEST_RESULTS.FAILED, testdata, new Exception("Did not receive the throughput packet in response."));
                }
                else
                {
                    // verify stuffs
                    string error = null;

                    // look up the appropriate packet
                    uint reflect_seq = buffer.GetUInt32(4);
                    NATThroughput natt;
                    uint firstseq = testdata.GetPacket(reflect_seq, out natt);

                    if (natt == null)
                    {
                        error = "Received an unknown sequence number, could be extra packets in the buffer.";
                        goto verify_exception;
                    }

                    if (firstseq != reflect_seq)
                    {
                        ro.Debug("Got seq {0}, first expected was {1}", reflect_seq, firstseq);
                    }

                    // source in/dest out port
                    if (natt.SourcePort != buffer.DestPort)
                    {
                        error = String.Format("Local source port :{0} does not match remote destination port :{1}.", 
                            natt.SourcePort, buffer.DestPort);
                        ro.Error(error);
                    }

                    // dest in/source out port
                    if (natt.DestPort != buffer.SourcePort)
                    {
                        error = String.Format("Local destination port :{0} does not match remote source port :{1}.",
                            natt.DestPort, buffer.SourcePort);
                        ro.Error(error);
                    }

                    // ip mapping
                    byte[] tempip = new byte[4];
                    Buffer.BlockCopy(buffer.RawBuffer, 8, tempip, 0, 4);
                    IPAddress reflected_ip = new IPAddress(tempip);
                    uint reflected_port = buffer.GetUInt32(12);

                    NATMapping map = testdata.Mapping;

                    lock (map)
                    {
                        if (map.IsUnmapped)
                        {
                            // nothing to check, just insert some mappings
                            map.Address = reflected_ip;
                            map.Init();
                            map.Map(natt.SourcePort, reflected_port);
                        }
                        else
                        {
                            // make sure addresses match
                            if (!map.Address.Equals(reflected_ip))
                            {
                                error = String.Format("Connection was previously bound to {0}, but {1} was reflected.",
                                    map.Address, reflected_ip);
                                ro.Error(error);
                            }

                            // update port mappings
                            uint mapped = map[natt.SourcePort];
                            if (mapped != 0)
                            {
                                // we already know about this source port, make sure it maps to the same place
                                if (mapped != reflected_port)
                                {
                                    error = String.Format("Source port was previously bound to {0}, but {1} was reflected.",
                                        mapped, reflected_port);
                                    ro.Error(error);
                                }
                            }
                            else
                            {
                                // we don't know about it, update
                                map.Map(natt.SourcePort, reflected_port);
                            }
                        }
                    }

                    //ro.Info("--------------------------------");
                    //ro.Info("Tracker    : " + testdata.Tracker.ID.ToString());
                    //ro.Info("In Seq     : " + natt.Sequence.ToString());
                    //ro.Info("In Src Prt : " + natt.SourcePort.ToString());
                    //ro.Info("In Dst Prt : " + natt.DestPort.ToString());
                    //ro.Info("Out Src Prt: " + buffer.SourcePort.ToString());
                    //ro.Info("Out Dst Prt: " + buffer.DestPort.ToString());
                    //ro.Info("Out Seq    : " + reflect_seq.ToString());
                    //ro.Info("Out IP     : " + reflected_ip.ToString());
                    //ro.Info("Out Prt    : " + reflected_port.ToString());
                    //ro.Info("--------------------------------");

                    if (error != null) { goto verify_exception; }

                    CheckForCompletion(testdata);
                    return;

                verify_exception:
                    InternalEnd(TEST_RESULTS.FAILED, testdata, new Exception(error));
                }
            }
            catch (Exception e)
            {
                if (testdata != null)
                {
                    InternalEnd(TEST_RESULTS.FAILED, testdata, e);
                }
                else
                {
                    ro.Error("An exception occured in SendNATThroughputCallback:\n" + e.ToString());
                    StressSettings.Instance.Connections.RemovePoppedConnection();
                }
            }
        }

        private void InternalEnd (TEST_RESULTS result, ThroughputTestData testData, Exception exc)
        {
            if (Interlocked.Exchange(ref testData.Completed, 1) == 0)
            {
                StressSettings.Instance.Connections.PushConnection(testData.Connection,
                    StressConnectionPool.ConnectionState.Connected);
                SendNATThroughputEnd(result, testData.Tracker, exc);
            }
            else if (exc != null)
            {
                ro.Error("An additional error occured after the test data object was completed:\n" + exc.ToString());
            }
        }

        protected virtual void SendNATThroughputEnd (TEST_RESULTS result, AsyncStressTracking tracker, Exception exc)
        {
            if (exc == null)
            {
                End(result, tracker);
            }
            else
            {
                End(exc, tracker);
            }
        }

        public static uint GetRandomSourcePort ()
        {
            return (uint)RandomEx.GlobalRandGen.Next(1000, 65534);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\SGNatTest\XspUdpTest.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;

namespace SGNatTest
{
    // Implement a plugin for changing some things
    //public class XspUdpPlugin : ServerTestFramework.

    [TestGroup]
    public class XspUdpTest : TestNode
    {
        private static readonly IPEndPoint Target = new IPEndPoint(IPAddress.Loopback, 65421);
        private static XspUdp Udp = new XspUdp();
        private static XspUdp Udp2 = new XspUdp();

        public struct ConnectionInfo
        {
            public uint Spi;
            public object Lock;
            public int Counter;
            public int LastSeen;
            public Queue<XspBuffer> Q;

            public void Enqueue (XspBuffer buffer)
            {
                lock (Q)
                {
                    Q.Enqueue(buffer);
                }
            }

            public XspBuffer Dequeue ()
            {
                lock (Q)
                {
                    if (Q.Count == 0)
                    {
                        return null;
                    }
                    else
                    {
                        return Q.Dequeue();
                    }
                }
            }
        }

        public static ConnectionInfo[] Connections = new ConnectionInfo[100];
        public static Dictionary<uint, int> ConnMap = new Dictionary<uint, int>();

        public override void PreRun()
        {
            Global.RO.Info("Sending to address: " + Target.ToString());

            ConnMap.Clear();

            for (int i = 0; i < Connections.Length; ++i)
            {
                Connections[i].Spi = AuthUtils.GetNewSpi();
                Connections[i].Lock = new object();
                Connections[i].Counter = 0;
                Connections[i].LastSeen = 0;
                Connections[i].Q = new Queue<XspBuffer>();
                ConnMap.Add(Connections[i].Spi, i);

                if ((i % 2) == 0)
                {
                    Udp.AttachForSpi(Connections[i].Spi, ReceiveCallback);
                }
                else
                {
                    Udp2.AttachForSpi(Connections[i].Spi, ReceiveCallback);
                }
            }
        }

        private static void ReceiveCallback (XspBuffer buffer, int resets)
        {
            Connections[ConnMap[buffer.DecodeSpi()]].Enqueue(buffer);
        }

        public override void PostRun()
        {
            // resets it
            Udp.Close();
            Udp2.Close();
        }

        public static void Send(uint spi, uint keyex_spi, uint length)
        {
            XspBuffer buff = XspBufferManager.Allocate();

            try
            {
                byte[] raw_buff = buff.RawBuffer;

                raw_buff[0] = (byte)SGFakeService.ActionType.ReflectOffset;
                raw_buff[2] = 1;

                Buffer.BlockCopy(BitConverter.GetBytes(spi), 0, raw_buff, 4, 4);
                Buffer.BlockCopy(BitConverter.GetBytes(keyex_spi), 0, raw_buff, 16, 4);

                buff.RawBufferLength = length;

                if ((ConnMap[spi] % 2) == 0)
                {
                    Udp.Send(raw_buff, (int)length, Target);
                }
                else
                {
                    Udp2.Send(raw_buff, (int)length, Target);
                }
            }
            finally
            {
                XspBufferManager.Free(buff);
            }
        }

        /// <summary>
        /// Test base for XspUdp tests.
        /// </summary>
        public class XspUdpTestBase : TestNode
        {
            public uint Spi = 0;
            public XspBuffer Buffer = null;

            public override void PreRun (RUN_TYPE runType)
            {
                Spi = AuthUtils.GetNewSpi();

                XspUdpTest.Udp.AttachForSpi(Spi, ReceiveCallback);
            }

            public void ReceiveCallback (XspBuffer buffer, int resets)
            {
                Buffer = buffer;
            }

            public void WaitLoop (double milliseconds)
            {
                DateTime start = DateTime.UtcNow;

                while (Buffer == null)
                {
                    if (DateTime.UtcNow.Subtract(start).TotalMilliseconds >= milliseconds)
                    {
                        throw new TimeoutException();
                    }
                    Thread.Sleep(10);
                }
            }

            public override void PostRun (RUN_TYPE runType)
            {
                XspUdpTest.Udp.Close(Spi);
                FreeBuffer();
            }

            public void FreeBuffer ()
            {
                if (Buffer != null)
                {
                    XspBufferManager.Free(Buffer);
                    Buffer = null;
                }
            }
        }

        /// <summary>
        /// Everything that was awesome about the first times 2.
        /// </summary>
        public class XspUdpTestBase_2Spis : XspUdpTestBase
        {
            public uint Spi2 = 0;
            public XspBuffer Buffer2 = null;

            public override void PreRun (RUN_TYPE runType)
            {
                Spi = AuthUtils.GetNewSpi();
                Spi2 = AuthUtils.GetNewSpi();

                XspUdpTest.Udp.AttachForSpi(Spi, ReceiveCallback);
                XspUdpTest.Udp.AttachForSpi(Spi2, ReceiveCallback2);
            }

            public void ReceiveCallback2 (XspBuffer buffer, int resets)
            {
                Buffer2 = buffer;
            }

            public void WaitLoop2 (double milliseconds)
            {
                DateTime start = DateTime.UtcNow;

                while (Buffer2 == null)
                {
                    if (DateTime.UtcNow.Subtract(start).TotalMilliseconds >= milliseconds)
                    {
                        throw new TimeoutException();
                    }
                    Thread.Sleep(10);
                }
            }

            public override void PostRun (RUN_TYPE runType)
            {
                XspUdpTest.Udp.Close(Spi);
                XspUdpTest.Udp.Close(Spi2);

                FreeBuffer();
                FreeBuffer2();
            }

            public void FreeBuffer2 ()
            {
                if (Buffer2 != null)
                {
                    XspBufferManager.Free(Buffer2);
                    Buffer2 = null;
                }
            }
        }

        [TestCase]
        public class KeyEx : XspUdpTestBase
        {
            public override void Run()
            {
                XspUdpTest.Send(0, Spi, 1000);

                WaitLoop(1000);

                if (Buffer == null) { throw new Exception("Got no result"); }
                if (Buffer.RawBufferLength != 996) { throw new Exception("Result not right size"); }

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class KeyExWithAnother : XspUdpTestBase
        {
            public override void Run()
            {
                XspUdpTest.Send(0, Spi, 1000);
                WaitLoop(1000);
                if (Buffer == null) { throw new Exception("Got no result"); }
                if (Buffer.RawBufferLength != 996) { throw new Exception("Result not right size"); }
                FreeBuffer();

                XspUdpTest.Send(Spi, 0, 20);
                WaitLoop(1000);
                if (Buffer == null) { throw new Exception("Got no result"); }
                if (Buffer.RawBufferLength != 16) { throw new Exception("Result not right size"); }

                return TEST_RESULTS.PASSED;
            }
        }

        //[TestCase]
        //public class KeyExWithAnotherAllSendFirst : XspUdpTestBase
        //{
        //    public override void Run()
        //    {
        //        uint spi = AuthUtils.GetNewSpi();

        //        XspUdpTest.Send(0, spi, 1000);
        //        XspUdpTest.Send(spi, 0, 20);

        //        XspBuffer buff = XspUdpTest.Receive(spi).XspBuffer;
        //        if (buff == null) { throw new Exception("Got no result"); }
        //        if (buff.RawBufferLength != 996) { throw new Exception("Result not right size"); }
        //        XspBufferManager.Free(buff);

        //        buff = XspUdpTest.Receive(spi).XspBuffer;
        //        if (buff == null) { throw new Exception("Got no result"); }
        //        if (buff.RawBufferLength != 16) { throw new Exception("Result not right size"); }
        //        XspBufferManager.Free(buff);

        //        return TEST_RESULTS.PASSED;
        //    }
        //}

        [TestCase]
        public class TwoSpisSerial : XspUdpTestBase_2Spis
        {
            public override void Run()
            {
                XspUdpTest.Send(Spi, 0, 20);

                WaitLoop(1000);
                if (Buffer == null) { throw new Exception("Got no result"); }
                if (Buffer.RawBufferLength != 16) { throw new Exception("Result not right size"); }

                XspUdpTest.Send(Spi2, 0, 24);
                WaitLoop2(1000);
                if (Buffer2 == null) { throw new Exception("Got no result"); }
                if (Buffer2.RawBufferLength != 20) { throw new Exception("Result not right size"); }

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TwoSpisParallel : XspUdpTestBase_2Spis
        {
            public override void Run()
            {
                XspUdpTest.Send(Spi, 0, 20);
                XspUdpTest.Send(Spi2, 0, 24);

                WaitLoop(1000);
                if (Buffer == null) { throw new Exception("Got no result"); }
                if (Buffer.RawBufferLength != 16)
                {
                    throw new Exception(string.Format("Result not right size: Expect {0}, got {1}", 16, Buffer.RawBufferLength));
                }

                WaitLoop2(1000);
                if (Buffer2 == null) { throw new Exception("Got no result"); }
                if (Buffer2.RawBufferLength != 20)
                {
                    throw new Exception(string.Format("Result not right size: Expect {0}, got {1}", 20, Buffer2.RawBufferLength));
                }

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TwoSpisParallel_OutOfOrder : XspUdpTestBase_2Spis
        {
            public override void Run()
            {
                XspUdpTest.Send(Spi, 0, 20);
                XspUdpTest.Send(Spi2, 0, 24);

                WaitLoop2(1000);
                if (Buffer2 == null) { throw new Exception("Got no result"); }
                if (Buffer2.RawBufferLength != 20) { throw new Exception("Result not right size"); }

                WaitLoop(1000);
                if (Buffer == null) { throw new Exception("Got no result"); }
                if (Buffer.RawBufferLength != 16) { throw new Exception("Result not right size"); }

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class PrintConnectionQLengths : TestNode
        {
            public override TEST_RESULTS Run ()
            {
                Global.RO.Debug("Connections Q Lengths:");
                int total = 0;
                for (int i = 0; i < Connections.Length; ++i)
                {
                    int val = Connections[i].Q.Count;
                    Global.RO.Debug("  [{0:D2}] : {1}", i, val);
                    total += val;
                }
                Global.RO.Debug("Total: {0}", total);

                return TEST_RESULTS.PASSED;
            }
        }

        [ThreadStatic]
        private static Random _rand;

        public static Random Random
        {
            get
            {
                if (_rand == null) { _rand = new Random(); }
                return _rand;
            }
        }
        
        [StressTest]
        public class StressSend : TestNode
        {
            public override void Run()
            {
                int val = Random.Next(90);

                Send(Connections[val].Spi, 0, (uint)(20 + val));

                return TEST_RESULTS.PASSED;
            }
        }

        [StressTest]
        public class StressReceive : TestNode
        {
            public override void Run()
            {
                int val = Random.Next(90);

                XspBuffer buffer = Connections[val].Dequeue();

                if (buffer == null)
                {
                    return TEST_RESULTS.NOT_EXECUTED;
                }

                if (buffer.RawBufferLength != val + 16)
                {
                    Global.RO.Error("Spi Index : {0} -- Recv Buffer : {1} -- Expect Buffer : {2} -- Spi : {4} -- Packet Spi : {3}",
                        val, buffer.RawBufferLength, val + 16, buffer.DecodeSpi(), Connections[val].Spi);
                    return TEST_RESULTS.FAILED;
                }

                XspBufferManager.Free(buffer);

                return TEST_RESULTS.PASSED;
            }
        }

        [StressTest]
        public class StressSendReceiveAsync : AsyncStressTestNode
        {
            public struct TestCases
            {
                public int Num;
                public AsyncStressTestNode.AsyncStressTracking Tracker;
            }

            public Queue<TestCases>[] TestCaseQueues = new Queue<TestCases>[10];

            public override void PreRun (RUN_TYPE runType)
            {
                for (int i = 90; i < 100; ++i)
                {
                    Udp.AttachForSpi(Connections[i].Spi, TestCallback);
                    TestCaseQueues[i - 90] = new Queue<TestCases>();
                }
            }

            public override void Begin (AsyncStressTestNode.AsyncStressTracking tracker)
            {
                int val = 90 + Random.Next(10);

                // ensure that we should get things in order
                lock (Connections[val].Lock)
                {
                    TestCases testcase;
                    testcase.Num = (Connections[val].Counter)++;
                    testcase.Tracker = tracker;

                    // send
                    XspBuffer buff = XspBufferManager.Allocate();

                    try
                    {
                        byte[] raw_buff = buff.RawBuffer;

                        raw_buff[0] = (byte)SGFakeService.ActionType.ReflectOffset;
                        raw_buff[2] = 1;

                        Buffer.BlockCopy(BitConverter.GetBytes(Connections[val].Spi), 0, raw_buff, 4, 4);
                        Buffer.BlockCopy(BitConverter.GetBytes(testcase.Num), 0, raw_buff, 8, 4);

                        Udp.Send(raw_buff, val + 20, Target);
                    }
                    finally
                    {
                        XspBufferManager.Free(buff);
                    }

                    TestCaseQueues[val - 90].Enqueue(testcase);
                }
            }

            public void TestCallback (XspBuffer buffer, int resets)
            {
                TestCases testcase;
                testcase.Tracker = null;

                try
                {
                    uint spi = buffer.DecodeSpi();
                    int val = ConnMap[spi];

                    if (val < 90)
                    {
                        Global.RO.Error("Spi Index : !{0}! -- Packet Spi : {3}", val, spi);
                        return;
                    }

                    // get test case info (we presume)
                    lock (Connections[val].Lock)
                    {
                        testcase = TestCaseQueues[val - 90].Dequeue();
                    }

                    if (buffer.RawBufferLength != val + 16)
                    {
                        Global.RO.Error("Spi Index : {0} -- Recv Buffer : {1} -- Expect Buffer : {2} -- Packet Spi : {3}",
                            val, buffer.RawBufferLength, val + 16, spi);
                        End(TEST_RESULTS.FAILED, testcase.Tracker);
                        return;
                    }

                    int counter_val = BitConverter.ToInt32(buffer.RawBuffer, 4);
                    if (counter_val != testcase.Num)
                    {
                        Global.RO.Error("Counter data did not match (0x{2:X8}): Expect {0}, got {1}.",
                            testcase.Num, counter_val, spi);
                        End(TEST_RESULTS.FAILED, testcase.Tracker);
                        return;
                    }

                    End(TEST_RESULTS.PASSED, testcase.Tracker);
                }
                catch (Exception e)
                {
                    if (testcase.Tracker != null)
                    {
                        End(e, testcase.Tracker);
                    }
                    else
                    {
                        Global.RO.Error("An exception occured in TestCallback:\n" + e.ToString());
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\ThroughputReflector\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_throughputreflector_none_12.4.56.0_none_c13719b2781133ff
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=throughputreflector
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.manifest
XP_MANIFEST_PATH=manifests\msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.cat
XP_CATALOG_PATH=manifests\msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.cat
XP_PAYLOAD_PATH=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=throughputreflector,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\ThroughputReflector\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_throughputreflector_none_12.4.56.0_none_c13719b2781133ff
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=throughputreflector
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.manifest
XP_MANIFEST_PATH=manifests\msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.cat
XP_CATALOG_PATH=manifests\msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79.cat
XP_PAYLOAD_PATH=msil_throughputreflector_no-public-key_12.4.56.0_x-ww_776daf79
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=throughputreflector,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\vlan\vlantest.cpp ===
// ---------------------------------------------------------------------------------------
// vlantest.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stddef.h>
#include <vlan.h>

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

int     g_argc;
char ** g_argv;

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

INLINE
void DbgBreak()
{
    _asm int 3;
}

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

// ---------------------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    char * Str() const;
};

struct CEnetFrame
{
    CEnetAddr   _eaDst;
    CEnetAddr   _eaSrc;
    BYTE        _ab[1500 - sizeof(CEnetAddr) * 2];
};

#include <poppack.h>

// ---------------------------------------------------------------------------------------
// CNic
// ---------------------------------------------------------------------------------------

class CNic
{
public:

                    CNic(char * pszLan);
                   ~CNic();
    virtual void    Recv(BYTE * pb, UINT cb);

    // Data ------------------------------------------------------------------------------

    CEnetAddr       _ea;
    ULONG           _cRecv;

};

CNic::CNic(char * pszLan)
{
    _cRecv = 0;

    Verify(VLanAttach(pszLan, _ea._ab, this));
}

CNic::~CNic()
{
    Verify(VLanDetach(_ea._ab));
}

void CNic::Recv(BYTE * pb, UINT cb)
{
    _cRecv += 1;
}

// ---------------------------------------------------------------------------------------
// VLanRecv
// ---------------------------------------------------------------------------------------

void WINAPI VLanRecv(BYTE * pb, UINT cb, void * pvArg)
{
    ((CNic *)pvArg)->Recv(pb, cb);
}

// ---------------------------------------------------------------------------------------
// CNicTest1
// ---------------------------------------------------------------------------------------

class CNicTest1 : public CNic
{
public:

                 CNicTest1(char * pszLan) : CNic(pszLan) { _fIsSender = FALSE; }
    void         Run(CEnetAddr * peaDst);
    virtual void Recv(BYTE * pb, UINT cb);

    // Data ------------------------------------------------------------------------------

    BOOL         _fIsSender;

};

void CNicTest1::Run(CEnetAddr * peaDst)
{
    CEnetFrame ef;

    _fIsSender = TRUE;

    ef._eaDst = *peaDst;
    ef._eaSrc = _ea;

	UINT k;
    for (k = 0; k < 100; ++k)
    {
        for (UINT i = 0; i < sizeof(ef._ab); ++i)
        {
            for (UINT j = 0; j < i; ++j)
            {
                ef._ab[j] = (BYTE)(i+j);
            }

            VLanXmit((BYTE *)&ef, offsetof(CEnetFrame, _ab) + i);
        }

        // Don't get too far ahead, lest we lose frames

        while (_cRecv < sizeof(ef._ab) * k)
            Sleep(0);

        if ((k % 3) == 0)
        {
            printf(".");
        }
    }

    while (_cRecv < sizeof(ef._ab) * k)
        Sleep(0);
}

void CNicTest1::Recv(BYTE * pb, UINT cb)
{
    CEnetFrame * pef    = (CEnetFrame *)pb;
    UINT         cbData = _cRecv % sizeof(pef->_ab);

    Verify(cb == offsetof(CEnetFrame, _ab) + cbData);

    for (UINT j = 0; j < cbData; ++j)
    {
        Verify(pef->_ab[j] == (BYTE)(cbData+j));
    }

    _cRecv += 1;

    if (!_fIsSender)
    {
        if (!pef->_eaDst.IsBroadcast())
        {
            pef->_eaDst = pef->_eaSrc;
        }
        
        pef->_eaSrc = _ea;

        VLanXmit(pb, cb);
    }
}


// ---------------------------------------------------------------------------------------
// CNicTest2
// ---------------------------------------------------------------------------------------

class CNicTest2 : public CNic
{
public:

                 CNicTest2(char * pszLan) : CNic(pszLan) {}
    void         Run();
    virtual void Recv(BYTE * pb, UINT cb);


};

void CNicTest2::Run()
{
    while (_cRecv < 100)
        Sleep(0);
}

void CNicTest2::Recv(BYTE * pb, UINT cb)
{
    _cRecv += 1;

    if ((_cRecv % 3) == 0)
    {
        printf(".");
    }
}

// ---------------------------------------------------------------------------------------
// main
// ---------------------------------------------------------------------------------------

int __cdecl main(int argc, char * argv[])
{
    printf("VLan Unit Test\n\n");

    if (!VLanInit())
    {
        printf("VLanInit failed\n");
        return(1);
    }

    printf("Testing VLAN.SYS  ");

    if (VLanDriver())
    {
        CNicTest1 * pNic1 = new CNicTest1("Nic1@Lan1");
        CNicTest2 * pNic3;
        pNic3 = new CNicTest2("Nic2@Nic/0");

        pNic3->Run();

        Verify(pNic1->_cRecv == 0);
        
        delete pNic3;
        delete pNic1;

        printf(" [OK]\n");
    }
    else
    {
        printf("[SKIP]\n");
    }

    printf("Testing Unicast   ");

    CNicTest1 * pNic1 = new CNicTest1("Nic1@Lan1");
    CNicTest1 * pNic2 = new CNicTest1("Nic2@Lan1");
    pNic1->Run(&pNic2->_ea);
    Verify(pNic1->_cRecv == pNic2->_cRecv);
    delete pNic1;
    delete pNic2;

    printf(" [OK]\n");

    printf("Testing Broadcast ");

    pNic1 = new CNicTest1("Nic1@Lan1");
    pNic2 = new CNicTest1("Nic2@Lan1");
    CEnetAddr ea;
    ea.SetBroadcast();
    pNic1->Run(&ea);
    Verify(pNic1->_cRecv == pNic2->_cRecv);
    delete pNic1;
    delete pNic2;

    printf(" [OK]\n");


    VLanTerm();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\ThroughputReflector\ThroughputReflector.cs ===
using System;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Diagnostics;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;


public class ThroughputReflector
{
    static DateTime                 LastEvent = DateTime.Now;
    static TimeSpan                 NextEventInterval = new TimeSpan(0, 0, 0, 1, 0);  // days,hours,mins,secs,ms

    static SGFakeService            service = null;
    static ushort                   port = 65421;
    static int                      packetCount = 0;
    static int                      packetSize = 0;
    
    static NotificationListener     notilistener = null;
    static ushort                   httpport = 0;
    static long                     notiCount = 0;

    static StreamWriter             outputFile = null;

    public static void Main(string[] args)
    {
        // Args
        for (int i = 0; i < args.Length; i++)
        {
            if (args[i].ToLower() == "-port" && i+1 < args.Length)
            {
                port = ushort.Parse(args[++i]);
            }
            else if (args[i].ToLower() == "-httpport" && i+1 < args.Length)
            {
                httpport = ushort.Parse(args[++i]);
            }
            else if (args[i].ToLower() == "-logfile" && i+1 < args.Length)
            {
                // Output log file, for statistics and such, not status
                outputFile = new StreamWriter(args[++i], false);
            }
            else
            {
                ShowHelp();
            }
        }

        // Create throughput service
        service = new SGFakeService(port);
        Console.WriteLine("[THRP] Stored local endpoint is {0}", service.localEP.ToString());
        Console.WriteLine("[THRP] Listening on {0}", ((IPEndPoint)(service.udpSocket.LocalEndPoint)).ToString());

        // Create optional notification listener
        if (httpport > 0)
        {
            // This runs asynchronously
            notilistener = new NotificationListener((int)httpport);
            notilistener.Go();
            Console.WriteLine("[NOTI] HTTP listener on port {0}", httpport);
        }

        // Set options        
        service.TimeoutInMs = 60000;

        // Status timer
        TimerCallback timerDelegate = new TimerCallback(Status);
        Timer timer = new Timer(timerDelegate, null, 1000, 1000);  // wait 1 sec, invoke every 1 sec

        while (true)
        {
            // Attempt recv
            service.RecvFast();
            packetSize = service.packetSize;

            if (service.packetSize == 0)
            {
                // Recv timed out
                Console.WriteLine("[THRP] Nothing received, still alive, trying again...");
            }
            else if (service.packetSize < 2)
            {
                // Too small 
                Console.WriteLine("[THRP] Warning: Packet size is less than 2 bytes, aborting processing");
            }
            else 
            {
                // Just right.  
                packetCount++;
             
                // Process this packet
                if (!service.Process())
                {
                    Console.WriteLine("[THRP] Received {0} bytes from {1} with action=0x{2:X}, seq={3} -- Process() failed",
                        service.packetSize,
                        ((IPEndPoint)service.remoteEP).ToString(),
                        service.PacketAction,
                        service.PacketSequence);
                }

                if (service.PacketAction == (int)SGFakeService.ActionType.ReflectTimestamp)
                {
                    // Log it
                    if (outputFile != null)
                    {
                        outputFile.WriteLine(String.Format("{0}|{1}|{2}|{3:X}",
                                                           ((IPEndPoint)service.remoteEP).ToString(),
                                                           service.PacketBigSequence,
                                                           service.PacketTimestamp,
                                                           service.ConnectionId));
                        if (service.PacketParam == 1)
                        {
                            // Flush the file. Probably don't want to do this very often in 
                            // stress, but great for functional.
                            outputFile.Flush();
                        }
                    }
                }


            }
        }

    }

    public static void Status(object state)
    {
        // Throughput service
        if (service != null && packetSize > 2 && packetCount > 0)
        {
            Console.WriteLine("[THRP] {0} bytes from {1} action=0x{2:X}, seq={3} [+{4} packets]",
                              packetSize,
                              ((IPEndPoint)service.remoteEP).ToString(),
                              service.PacketAction,
                              service.PacketSequence,
                              packetCount);
            packetCount = 0;
        }

        // Notification listener
        if (notilistener != null && notilistener.BatchesTotal > notiCount)
        {
            Console.WriteLine("[NOTI] +{0} upd, +{1} titlchg, +{2} deadxb [{3}/{4}/{5} +{6} batches +{7} bytes] {8} handlers",
                              notilistener.CountUpdate,
                              notilistener.CountTitleChange,
                              notilistener.CountDelete,
                              notilistener.BatchesUpdate,
                              notilistener.BatchesTitleChange,
                              notilistener.BatchesDelete,
                              notilistener.BatchesTotal - notiCount,
                              notilistener.BytesTotal,
                              notilistener.Handlers);
            notiCount = notilistener.BatchesTotal;
            notilistener.ResetCounts();
        }
    }

    public static void ShowHelp()
    {
        Console.WriteLine("Usage: ThroughputReflector.exe [-port port] [-httpport port] [-logfile filename]");
        Console.WriteLine("     -port: port to listen to throughput traffic on.");
        Console.WriteLine("            Service 5 is 65421, Service 6 is 65417");
        Console.WriteLine(" -httpport: TCP port to listen on for notification messages.");
        Console.WriteLine("            SG default is 65000.");
        Console.WriteLine("  -logfile: Timestamp logfile name. If not specified, no file is created.");
        System.Environment.Exit(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncConnectionServices.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
 
namespace XSGTest
{
    // TODO: What is this supposed to be doing?  It doesn't seem to do anything right now
    //[TestGroup]
    public class ConnectionServices : TestNode
    {

        [TestCase, Description("Verify QVal")]
        class Simple_QVal : TestBase_SgFake
        {
            override protected void RunTest()
            {
            }
        }
        


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\ChallengeTestNodes.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using xonline.common.config;

namespace XSGTest
{
    /// <summary>
    /// A base class for tests that wish to use the SgConnection class to connect to the SG.
    /// </summary>
    public class SgConnectionTestNode : TestNode
    {
        /// <summary>Test-specific reporting object.</summary>
        private static Report Ro = new Report("SgConnTest");

        /// <summary>Client type to use in creating the authdata.</summary>
        public AuthContext.ClientTypes ClientType = AuthContext.ClientTypes.Xenon;

        /// <summary>Number of users to add to the SgConnection when it is created.</summary>
        public int DefaultUserCount = 1;

        /// <summary>This instance's SgConnection.</summary>
        public SGConnection Sg;

        /// <summary>The port to send to for the TestRefl service.</summary>
        protected SGFakeService.IServicePort ServicePort
        {
            get { return SGFakeService.IServicePort.TestRefl; }
        }

        /// <summary>Backing for DefaultTransport.</summary>
        private static XspUdp _DefaultTransport = null;

        /// <summary>The shared transport for new SgConnections.</summary>
        protected static XspUdp DefaultTransport
        {
            get
            {
                if (_DefaultTransport == null)
                {
                    _DefaultTransport = new XspUdp();
                }

                return _DefaultTransport;
            }
        }

        /// <summary>Creates a new SgConnection.</summary>
        public static SGConnection CreateNewConnection (AuthContext.ClientTypes clientType, int numUsers)
        {
            SGConnection ans = new SGConnection();
            ans.Context = new AuthContext(clientType);

#if !LSPTEST
            ans.Context.Site = SiteInfoManager.GetDefaultSgSite().CloneDeep();
#else
            ans.Context.Site = SiteInfoManager.GetDefaultLspSite().CloneDeep();
#endif
            ans.Context.Authdata = Authdata_Base.NewDefaultFromSite(ans.Context.Site);
            ans.Transport = DefaultTransport;

            // Set some user names.  DefaultAuthData() will detect this and
            // make up unique puids for us.
            ans.Context.ClearUsers();
            for (int i = 0; i < numUsers; i++)
            {
                ans.Context.SetUser("sgtestuser" + i, i);
            }

            SgClient.SetDefaultAuthdata(ans.Context, ans.Context.Authdata);

            return ans;
        }

        /// <summary>
        /// It will generally be a good idea to call base.PreRun in all derived classes
        /// that override PreRun.
        /// </summary>
        public override void PreRun ()
        {
            Sg = CreateNewConnection(ClientType, DefaultUserCount);
        }

        /// <summary>
        /// It will generally be a good idea to call base.PostRun in all derived classes
        /// that override PostRun.
        /// </summary>
        public override void PostRun ()
        {
            // disconnect from the SG to avoid using up all of the connections
            Sg.Disconnect();
        }

        /// <summary>
        /// Ensure that the connection is still active.
        /// </summary>
        public bool IsStillSignedIn ()
        {
            return IsStillSignedIn(2000);
        }

        /// <summary>
        /// Ensure that the connection is still active.
        /// </summary>
        public bool IsStillSignedIn (int timeoutInMS)
        {
            // first check the state
            if (Sg.State != SGConnection.ConnectionState.Connected)
                return false;

            // Do QOS exchange to make sure
            DateTime now = DateTime.UtcNow;
            Sg.SendQoS();

            while ((DateTime.UtcNow - now).TotalMilliseconds < timeoutInMS)
            {
                System.Threading.Thread.Sleep(0);
                Sg.ProcessReceiveQueue();

                if (!Sg.QoSPending)
                {
                    return true;
                }
            }

            return false;
        }
    }

    /// <summary>
    /// A base class for tests that target the asynchronous challenge system.
    /// </summary>
    public class AsyncChallengeTestNode : SgConnectionTestNode, IGroupManagedLuaScript
    {
        #region Statics

        /// <summary>The resolution of the SGs timer routine.</summary>
        public const int SgTimerResolutionInMs = 200;

        /// <summary>Test-specific reporting object.</summary>
        private static Report Ro = new Report("AsyncChal");

        #endregion

        #region Fields set by AsyncChallengeTestNode

        // Challenge Timers
        /// <summary>The time it takes for the SG to process every connection for timed events.</summary>
        protected int ScanTime;
        /// <summary>The time between challenges.</summary>
        protected int Period;
        /// <summary>The time that the client is given to acknowledge a challenge.</summary>
        protected int AckTimeout;
        /// <summary>The time that the client is given to respond to a challenge.</summary>
        protected int ResponseTimeout;
        /// <summary>The heartbeat timer period.</summary>
        protected int Heartbeat;
        /// <summary>Client only timer that would normally be used to resend a challenge response.</summary>
        protected int ResponseAckTimeout = 2;
        /// <summary>The maximum amount of time that we allow a challenge to come before the next scheduled one.</summary>
        protected TimeSpan MaximumEarlyChallengeTime;

        // Challenge State for Descendents
        /// <summary>The current challenge that we are "executing".</summary>
        protected SecMsgSgToXbChal CurrentChallenge;
        /// <summary>The number of times we have received a challenge before responding successfully.</summary>
        protected int CurrentChallengeReceiveCount;
        /// <summary>The total number of challenges that we have completed.</summary>
        protected int ChallengesCompleted;

        /// <summary>The number of heartbeats that have occured.</summary>
        protected int TotalHeartbeatCount;

        #endregion

        #region Fields for Descendent Control

        /// <summary>By setting this to true, the main test loop will end.</summary>
        protected bool TestComplete;

        /// <summary>By setting this to true, receiving a new challenge mid-execution will not generate an exception.</summary>
        protected bool AcceptNewChallenges;

        /// <summary>The param id we expect to see in log lines.</summary>
        protected uint ChallengeParamId;

        /// <summary>When true, we will send heartbeats to the SG; when false we won't.</summary>
        protected bool SendHeartbeats;

        #endregion

        #region Private Fields

        /// <summary>Enum for the current state of the test.</summary>
        private enum ChallengeState
        {
            Idle,
            WaitingForAck,
            WaitingForResponse,
            WaitingForResponseAck,
        }

        // State information
        private ChallengeState State;
        private DateTime NextEvent;
        private DateTime NextHeartbeat;

        // Log information
        private int ExpectLogAfterChallengeReceived_AssignCount;
        private int ExpectLogAfterChallengeReceived_AckTimeouts;
        private int ExpectLogAfterChallengeReceived_RespTimeouts;

        /// <summary>The set of scripts required for the current test.</summary>
        private IEnumerable<LuaScript> LuaScripts;

        /// <summary>The logs that we expect to see come to us.</summary>
        private List<LuaAreaLogline> ExpectedLuaAreaLogs;

        #endregion

        #region Constructor

        /// <summary>
        /// Constructor for AsyncChallengeTestNode.
        /// </summary>
        public AsyncChallengeTestNode ()
        {
            List<LuaScript> scripts = new List<LuaScript>();

            foreach (object obj in 
                GetType().GetCustomAttributes(typeof(PreconfiguredChallengeAttribute), true))
            {
                PreconfiguredChallengeAttribute pca = obj as PreconfiguredChallengeAttribute;

                if (pca != null)
                {
                    LuaScript lua = ChallengeManager.PreconfiguredLuaScripts[pca.ScriptName];

                    if (lua != null)
                    {
                        scripts.Add(lua);
                    }
                }
            }

            SetScripts(scripts);
        }

        #endregion

        #region Test Execution

        public override void PreRun ()
        {
            base.PreRun();

            // hook up our sec msg handler to grab challenge packets directly
            Sg.UserSecMsgHandler = ProcessSecMsg;

            // use the first LuaScript to set the authdata so that we are targeted properly
            LuaScript firstScript = PrimaryScript;

            if (firstScript != null)
            {
                ChallengeManager scriptManager = GetGroupScriptManager();
                scriptManager.SetAuthdataForScript(firstScript, Sg.Context.Authdata);
            }

            // get async challenge timing settings
            ScanTime = Global.XEnv.GetIntSetting(Setting.sg_SgToXbScanFrequencyInSeconds);
            Period = Global.XEnv.GetIntSetting(Setting.sg_SgToXbChallengePeriodInSeconds);
            AckTimeout = Global.XEnv.GetIntSetting(Setting.sg_XbToSgChallengeAckInSeconds);
            ResponseTimeout = Global.XEnv.GetIntSetting(Setting.sg_XbToSgChallengeTimeoutInSeconds);
            Heartbeat = Global.XEnv.GetIntSetting(Setting.sg_ChalHeartbeatTimeoutInSeconds);
            MaximumEarlyChallengeTime = new TimeSpan(0, 0, ScanTime + 1);

            // reset test state
            CurrentChallenge = null;
            CurrentChallengeReceiveCount = 0;
            ChallengesCompleted = 0;
            TotalHeartbeatCount = 0;

            TestComplete = false;
            AcceptNewChallenges = false;
            ChallengeParamId = 0;
            SendHeartbeats = true;

            NextHeartbeat = DateTime.UtcNow;
            ExpectLogAfterChallengeReceived_AssignCount = 0;
            ExpectLogAfterChallengeReceived_AckTimeouts = 0;
            ExpectLogAfterChallengeReceived_RespTimeouts = 0;
            ExpectedLuaAreaLogs = new List<LuaAreaLogline>();
        }

        public override void Run ()
        {
            // connect
            try
            {
                Sg.Connect();
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                // on a connection timeout, give one more try
                Sg.Connect();
            }

            // set state to default
            ResetState();

            while (!TestComplete)
            {
                // pump our incoming queue which will call into our sec msg handler
                Sg.ProcessReceiveQueue();

                // avoid false errors by breaking early if the test is done
                if (TestComplete) break;

                if (Sg.State != SGConnection.ConnectionState.Connected)
                {
                    LostConnection();
                    continue;
                }

                if (SendHeartbeats)
                {
                    Sg.SendHeartbeat(true);
                }

                // handle any timers that may have expired
                if (DateTime.UtcNow > NextEvent)
                {
                    switch (State)
                    {
                        // if we are in idle, we expected another challenge by now
                        case ChallengeState.Idle:
                            ChallengeAssignmentTimeout();
                            break;

                        // if we are in waiting for ack, we expected the same challenge to be resent
                        case ChallengeState.WaitingForAck:
                            ChallengeAckTimeout();
                            break;

                        case ChallengeState.WaitingForResponse:
                            ChallengeResponseTimeout();
                            break;

                        case ChallengeState.WaitingForResponseAck:
                            ChallengeResponseAckTimeout();
                            break;
                    }
                }

                // avoid false errors by breaking early if the test is done
                if (TestComplete) break;

                if (DateTime.UtcNow >= NextHeartbeat)
                {
                    ++TotalHeartbeatCount;
                    ChallengeHeartbeat();
                    NextHeartbeat = NextHeartbeat.AddSeconds(Heartbeat);
                }

                // we don't need to be any more active than the SG is
                System.Threading.Thread.Sleep(SgTimerResolutionInMs);
            }

            // verify logs
            VerifyLogs();
        }

        #endregion

        #region Virtual Events

        /// <summary>
        /// Called when the connection to the SG is lost. This function should not return normally without
        /// reconnecting or other exceptions will likely be thrown in Run.
        /// 
        /// Setting TestComplete to true will be handled correctly.
        /// </summary>
        protected virtual void LostConnection ()
        {
            throw new UnexpectedTestResultException("Unexpectedly disconnected from the SG.");
        }

        /// <summary>
        /// Called when we have not received a challenge after the idle period has expired.
        /// </summary>
        protected virtual void ChallengeAssignmentTimeout ()
        {
            throw new UnexpectedTestResultException("Expected to receive a challenge after the idle period.");
        }

        /// <summary>
        /// Called when we have not received a resend of the previous challenge after the ack timeout.
        /// </summary>
        protected virtual void ChallengeAckTimeout ()
        {
            throw new UnexpectedTestResultException("Expected to receive a challenge resend after the ack timeout.");
        }

        /// <summary>
        /// Called when we have not received a resend of the previous challenge after the response timeout.
        /// </summary>
        protected virtual void ChallengeResponseTimeout ()
        {
            throw new UnexpectedTestResultException("Expected to receive a challenge resend after the response timeout.");
        }

        /// <summary>
        /// Called when we have not received an ack to our challenge response.
        /// </summary>
        protected virtual void ChallengeResponseAckTimeout ()
        {
            throw new UnexpectedTestResultException("Expected to receive an ack to our challenge response.");
        }

        /// <summary>
        /// Called when the heartbeat timer comes up.
        /// </summary>
        protected virtual void ChallengeHeartbeat ()
        {
        }

        /// <summary>
        /// Called when any SECMSG_TYPE_SGTOXB_CHAL packet is received.
        /// 
        /// Default implementation sends an ack and a blank response.
        /// </summary>
        protected virtual void ChallengeReceived (SecMsgSgToXbChal challenge)
        {
            SendAck(challenge.ChallengeNonce);
            SendResponse(challenge.ChallengeNonce);
        }

        /// <summary>
        /// Called when any SECMSG_TYPE_SGTOXB_CHALRESP_ACK packet is received.
        /// 
        /// Default implementation sets the test to complete.
        /// </summary>
        protected virtual void ChallengeResponseAckReceived (SecMsgSgToXbChalRespAck chalRespAck)
        {
            TestComplete = true;
        }

        #endregion

        #region Protected Helpers

        #region IGroupManagedLuaScript Related

        /// <summary>
        /// Set the single LuaScript that is used by this test.
        /// </summary>
        protected void SetScript (LuaScript luaScript)
        {
            LuaScripts = new LuaScript[] { luaScript };
        }

        /// <summary>
        /// Set the LuaScripts that are used by this test.
        /// </summary>
        protected void SetScripts (IEnumerable<LuaScript> luaScripts)
        {
            LuaScripts = luaScripts;
        }

        /// <summary>
        /// The first script in the list of lua scripts.
        /// </summary>
        protected virtual LuaScript PrimaryScript
        {
            get
            {
                if (LuaScripts != null)
                {
                    foreach (LuaScript ls in LuaScripts)
                    {
                        return ls;
                    }
                }

                return null;
            }
        }

        /// <summary>
        /// Gets the ChallengeManager for this IGroupManagedLuaScript.
        /// </summary>
        protected ChallengeManager GetGroupScriptManager ()
        {
            return (ChallengeManager)GetContextData(GroupManagedLuaScriptTestNode.ScriptManagerContext);
        }

        #endregion

        #region State and Verification

        /// <summary>
        /// Use this to reset the state due to a title change, etc.
        /// </summary>
        protected void ResetState ()
        {
            ResetState(true);
        }

        /// <summary>
        /// Use this to reset the state due to a title change, etc.
        /// </summary>
        protected void ResetState (bool dropCurrentChallenge)
        {
            State = ChallengeState.Idle;
            NextEvent = GetNextEventTime(0);
            if (dropCurrentChallenge)
            {
                CurrentChallenge = null;
                CurrentChallengeReceiveCount = 0;
            }
        }

        /// <summary>
        /// Resets the challenge log counters.
        /// </summary>
        protected void ResetChallengeLogCounters ()
        {
            ExpectLogAfterChallengeReceived_AssignCount = 0;
            ExpectLogAfterChallengeReceived_AckTimeouts = 0;
            ExpectLogAfterChallengeReceived_RespTimeouts = 0;
        }

        /// <summary>
        /// Throws if the current challenge is not that same as the one presented.
        /// </summary>
        protected void EnsureChallengeConsistency (SecMsgSgToXbChal challenge)
        {
            if (!AcceptNewChallenges && CurrentChallenge != null && !CurrentChallenge.Equals(challenge))
            {
                throw new UnexpectedTestResultException("Got a new challenge when we already had one");
            }

            DateTime now = DateTime.UtcNow;
            if (now < NextEvent && NextEvent - now > MaximumEarlyChallengeTime)
            {
                throw new UnexpectedTestResultException("Challenge came too early: " + (NextEvent - now));
            }
        }

        /// <summary>
        /// Throws if the current challenge is not consistent with the response ack.
        /// </summary>
        protected void EnsureChallengeResponseAckConsistency (SecMsgSgToXbChalRespAck chalRespAck)
        {
            if (CurrentChallenge == null)
            {
                throw new UnexpectedTestResultException("Got a challenge response ack when we didn't have a challenge.");
            }

            if (CurrentChallenge.ChallengeNonce != chalRespAck.ChallengeNonce)
            {
                throw new UnexpectedTestResultException("Got a challenge response ack with a different nonce than our challenge.");
            }
        }

        #endregion

        #region Send Packets

        /// <summary>
        /// Sends an ack for the given nonce, which is assumed to be the nonce of the current challenge.
        /// </summary>
        protected void SendAck (uint nonce)
        {
            SendAck(nonce, true);
        }

        /// <summary>
        /// Sends an ack for the given nonce, and only advances the state if it is the correct nonce.
        /// </summary>
        protected void SendAck (uint nonce, bool isCorrectNonce)
        {
            // create the packet
            SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
            ack.ChallengeNonce = nonce;

            // send it
            Sg.Send(ack);

            if (isCorrectNonce)
            {
                // update state
                UpdateStateForSentAck();
            }
        }

        /// <summary>
        /// Advances the state when a correct ack has been sent.
        /// </summary>
        protected void UpdateStateForSentAck ()
        {
            State = ChallengeState.WaitingForResponse;
            NextEvent = GetNextEventTime(ResponseTimeout);
        }

        /// <summary>
        /// Sends a response for the given nonce, which is assumed to be the nonce of the current challenge.
        /// </summary>
        protected void SendResponse (uint nonce)
        {
            SendResponse(nonce, new byte[1024], true);
        }

        /// <summary>
        /// Sends a response for the given nonce, which is assumed to be the nonce of the current challenge.
        /// </summary>
        protected void SendResponse (uint nonce, byte[] data)
        {
            SendResponse(nonce, data, true);
        }

        /// <summary>
        /// Sends a response for the given nonce, and only advances the state if it is the correct nonce.
        /// </summary>
        protected void SendResponse (uint nonce, byte[] data, bool isCorrectNonce)
        {
            // create the packet
            SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
            resp.ChallengeNonce = nonce;
            resp.Execute = data;

            // send it
            Sg.Send(resp);

            if (isCorrectNonce)
            {
                // update state
                UpdateStateForSentResp();
            }
        }

        /// <summary>
        /// Advances the state when a correct resp has been sent.
        /// </summary>
        protected void UpdateStateForSentResp ()
        {
            State = ChallengeState.WaitingForResponseAck;
            NextEvent = GetNextEventTime(ResponseAckTimeout);
        }

        #endregion

        #region Log Verification

        /// <summary>Adds an expected log to our list.</summary>
        protected void ExpectLog (string action)
        {
            ExpectLog(Sg, action, PrimaryScript, ChallengeParamId, -1, -1, -1);
        }

        /// <summary>Adds an expected log to our list.</summary>
        protected void ExpectLogWithManagedCounters (string action)
        {
            ExpectLog(Sg, action, PrimaryScript, ChallengeParamId, ExpectLogAfterChallengeReceived_AssignCount, 
                ExpectLogAfterChallengeReceived_AckTimeouts, ExpectLogAfterChallengeReceived_RespTimeouts);
        }

        /// <summary>Adds an expected log to our list.</summary>
        protected void ExpectLog (string action, int assignCount, int ackTimeouts, int respTimeouts)
        {
            ExpectLog(Sg, action, PrimaryScript, ChallengeParamId, assignCount, ackTimeouts, respTimeouts);
        }

        /// <summary>Adds an expected log to our list.</summary>
        protected void ExpectLog (SGConnection conn, string action, LuaScript luaScript, uint paramId, 
            int assignCount, int ackTimeouts, int respTimeouts)
        {
            LuaAreaLogline lal = new LuaAreaLogline()
            {
                MachinePuid = conn.Context.Authdata.XboxID,
                Nonce = BitConverter.ToUInt64(conn.Context.SecKeys.NonceResp, 0),
                Flowtoken = conn.Context.Authdata.Flowtoken,
                Action = action,
                ChallengeId = (luaScript == null ? 0 : GetGroupScriptManager().GetChallengeIdForScript(luaScript)),
                ParamId = paramId,
                AssignCount = assignCount,
                AckTimeouts = ackTimeouts,
                RespTimeouts = respTimeouts
            };

            ExpectedLuaAreaLogs.Add(lal);
        }

        /// <summary>Verifies the logs with our expectations.</summary>
        /// <remarks>At this time, the UDP tracing coming from xmgmt is too flaky to rely on to fail tests.</remarks>
        protected void VerifyLogs ()
        {
            VerifyLogs(Sg.Context.Authdata.XboxID, ExpectedLuaAreaLogs, false);
        }

        /// <summary>Verifies the logs with our expectations.</summary>
        protected void VerifyLogs (ulong machinePuid, List<LuaAreaLogline> expected, bool throwOnError)
        {
            List<LuaAreaLogline> logs = LuaAreaLogListener.GetLogs(machinePuid);
            MultiEnumerator<LuaAreaLogline> multiEnum = new MultiEnumerator<LuaAreaLogline>(expected, logs);

            if (logs == null)
            {
                if (expected != null && expected.Count != 0)
                {
                    if (throwOnError)
                    {
                        throw new UnexpectedTestResultException("We expected logs but there were none for the given machine.");
                    }
                    else
                    {
                        Ro.Error("We expected logs but there were none for the given machine.");
                    }
                }

                // no logs, and none were expected
                return;
            }

            lock (logs)
            {
                if (logs.Count != expected.Count)
                {
                    goto failed;
                }
                else
                {
                    foreach (var entries in multiEnum)
                    {
                        if (!entries[0].Value.Equals(entries[1].Value))
                        {
                            goto failed;
                        }
                    }
                }

                return;

            failed:
                StringBuilder sb = new StringBuilder();
                int count = 0;

                sb.AppendLine("The expected logs (top) did not match those received from the server (bottom):");

                foreach (var entries in multiEnum)
                {
                    sb.Append("Entry ");
                    sb.Append(count++);
                    sb.AppendLine(":");

                    foreach (var entry in entries)
                    {
                        sb.Append(' ', 4);
                        sb.AppendLine(entry.Valid ? entry.Value.ToString() : "<No Entry>");
                    }
                }

                if (throwOnError)
                {
                    throw new UnexpectedTestResultException(sb.ToString());
                }
                else
                {
                    Ro.Error(sb.ToString());
                }
            }
        }

        #endregion

        #endregion

        #region Private Helpers

        /// <summary>Extra time we allow for network latency.</summary>
        private readonly double NetworkLatencyTimeWobble = 0.1;

        /// <summary>Extra time we allow for an xblob.</summary>
        private readonly double XblobTimeWobble = 0.5;

        /// <summary>Gets the absolute latest time we expect the next event to occur.</summary>
        private DateTime GetNextEventTime (int offsetSeconds)
        {
            return DateTime.UtcNow.AddSeconds(offsetSeconds + ScanTime + NetworkLatencyTimeWobble +
                (SgEnvironmentInfo.IsXblob ? XblobTimeWobble : 0));
        }

        /// <summary>Handles inbound SecMsgs for the Run method.</summary>
        private bool ProcessSecMsg (int msgType, XspBuffer packet)
        {
            switch (msgType)
            {
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL:
                    {
                        // create the challenge object
                        SecMsgSgToXbChal challenge = new SecMsgSgToXbChal();
                        challenge.ReadStream(
                            new System.IO.MemoryStream(packet.RawBuffer, XspBuffer.DATA_START_OFFSET, (int)packet.DataBufferLength)
                            );

                        // check the challenge
                        EnsureChallengeConsistency(challenge);

                        // update the state 
                        if (CurrentChallenge != null && !CurrentChallenge.Equals(challenge))
                        {
                            CurrentChallengeReceiveCount = 1;
                        }
                        else
                        {
                            ++CurrentChallengeReceiveCount;
                        }
                        CurrentChallenge = challenge;

                        ExpectLogAfterChallengeReceived();
                        State = ChallengeState.WaitingForAck;
                        NextEvent = GetNextEventTime(AckTimeout);

                        // call into event handler for challenge
                        ChallengeReceived(challenge);
                    }
                    return true;

                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK:
                    {
                        // create the challenge response ack object
                        SecMsgSgToXbChalRespAck chalRespAck = new SecMsgSgToXbChalRespAck();
                        chalRespAck.ReadStream(
                            new System.IO.MemoryStream(packet.RawBuffer, XspBuffer.DATA_START_OFFSET, (int)packet.DataBufferLength)
                            );

                        // handle it
                        EnsureChallengeResponseAckConsistency(chalRespAck);
                        ExpectLogWithManagedCounters("ANALYZE");

                        ChallengeResponseAckReceived(chalRespAck);

                        // we assume that the challenge response ack was accepted
                        CurrentChallenge = null;
                        CurrentChallengeReceiveCount = 0;
                        ++ChallengesCompleted;
                        ResetChallengeLogCounters();

                        State = ChallengeState.Idle;
                        NextEvent = GetNextEventTime(Period);
                    }
                    return true;
            }

            return false;
        }

        /// <summary>Expects the appropriate log line after a challenge packet is received.</summary>
        private void ExpectLogAfterChallengeReceived ()
        {
            string logHeader = null;

            switch (State)
            {
                case ChallengeState.Idle:
                    ++ExpectLogAfterChallengeReceived_AssignCount;
                    logHeader = "SELECT";
                    break;

                case ChallengeState.WaitingForAck:
                    ++ExpectLogAfterChallengeReceived_AckTimeouts;
                    logHeader = "TIMEOUTACK";
                    break;

                case ChallengeState.WaitingForResponse:
                    ++ExpectLogAfterChallengeReceived_RespTimeouts;
                    logHeader = "TIMEOUTRESP";
                    break;
            }

            ExpectLogWithManagedCounters(logHeader);
        }

        #endregion

        #region IGroupManagedLuaScript Members

        /// <summary>
        /// This method can be overriden if one needs to make runtime decisions on which scripts are used.
        /// </summary>
        protected virtual IEnumerable<LuaScript> GetScripts ()
        {
            return LuaScripts;
        }

        IEnumerable<LuaScript> IGroupManagedLuaScript.GetScripts ()
        {
            return GetScripts();
        }

        #endregion
    }

    /// <summary>
    /// Used by tests that want to load a lua script.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public class PreconfiguredChallengeAttribute : Attribute
    {
        public string ScriptName;

        public PreconfiguredChallengeAttribute (string scriptName)
        {
            ScriptName = scriptName;
        }
    }

    /// <summary>A log from the lua area.</summary>
    public class LuaAreaLogline : IEquatable<LuaAreaLogline>
    {
        public ulong MachinePuid;
        public ulong Nonce;
        public ulong Flowtoken;
        public string Action;
        public uint ChallengeId;
        public uint ParamId;
        public int AssignCount;
        public int AckTimeouts;
        public int RespTimeouts;

        public override bool Equals (object obj)
        {
            return Equals(obj as LuaAreaLogline);
        }

        public bool Equals (LuaAreaLogline log)
        {
            return (
                MachinePuid == log.MachinePuid &&
                Nonce == log.Nonce &&
                Flowtoken == log.Flowtoken &&
                Action == log.Action &&
                ChallengeId == log.ChallengeId &&
                ParamId == log.ParamId &&
                (AssignCount == -1 || log.AssignCount == -1 || AssignCount == log.AssignCount) &&
                (AckTimeouts == -1 || log.AckTimeouts == -1 || AckTimeouts == log.AckTimeouts) &&
                (RespTimeouts == -1 || log.RespTimeouts == -1 || RespTimeouts == log.RespTimeouts)
                );
        }

        public override int GetHashCode ()
        {
            return
                MachinePuid.GetHashCode() ^
                Nonce.GetHashCode() ^
                Flowtoken.GetHashCode() ^
                Action.GetHashCode() ^
                ChallengeId.GetHashCode() ^
                ParamId.GetHashCode() ^
                AssignCount.GetHashCode() ^
                AckTimeouts.GetHashCode() ^
                RespTimeouts.GetHashCode();
        }

        public override string ToString ()
        {
            return string.Format("{0:X16}|{1:X16}|FT{2}|{3}|{4:X8}|{5}|{6}|{7}|{8}",
                MachinePuid, Nonce, (Flowtoken == 0 ? "0" : Flowtoken.ToString("X16")), Action, 
                ChallengeId, ParamId, AssignCount, AckTimeouts, RespTimeouts);
        }
    }

    /// <summary>
    /// Listens to the lua area for log lines generated by challenges.
    /// </summary>
    public static class LuaAreaLogListener
    {

        private static Report Ro = new Report("LuaAreaLogListener");

        public static void Start ()
        {
            // clear the old stuff
            lock (Loglines)
            {
                Loglines.Clear();
            }

            foreach (SgServerInfo ssi in SgServerInfo.Servers)
            {
                ManagementListener.Listen(ssi.XmgmtIp, "SG", "lua", LuaAreaListener);
            }
        }

        public static void Stop ()
        {
            foreach (SgServerInfo ssi in SgServerInfo.Servers)
            {
                ManagementListener.Stop(ssi.XmgmtIp, "SG", "lua", LuaAreaListener);
            }
        }

        /// <summary>Log lines that we have received.</summary>
        private static Dictionary<ulong, List<LuaAreaLogline>> Loglines = new Dictionary<ulong, List<LuaAreaLogline>>();

        /// <summary>Receives logs from the lua area.</summary>
        private static void LuaAreaListener (ManagementListener.Datagram datagram)
        {
            try
            {
                string[] parts = datagram.Text.Split('|');

                LuaAreaLogline lal = new LuaAreaLogline()
                {
                    MachinePuid = ulong.Parse(parts[0], System.Globalization.NumberStyles.AllowHexSpecifier),
                    Nonce = ulong.Parse(parts[1], System.Globalization.NumberStyles.AllowHexSpecifier),
                    Flowtoken = ulong.Parse(parts[2].Substring(2), System.Globalization.NumberStyles.AllowHexSpecifier),
                    Action = parts[3],
                    ChallengeId = string.IsNullOrEmpty(parts[4]) ? 0 : uint.Parse(parts[4], System.Globalization.NumberStyles.AllowHexSpecifier),
                    ParamId = uint.Parse(parts[5]),
                    AssignCount = string.IsNullOrEmpty(parts[6]) ? 0 : int.Parse(parts[6]),
                    AckTimeouts = string.IsNullOrEmpty(parts[7]) ? 0 : int.Parse(parts[7]),
                    RespTimeouts = string.IsNullOrEmpty(parts[8]) ? 0 : int.Parse(parts[8])
                };

                List<LuaAreaLogline> list = null;

                lock (Loglines)
                {
                    if (!Loglines.TryGetValue(lal.MachinePuid, out list))
                    {
                        list = null;
                    }
                }

                if (list == null)
                {
                    list = new List<LuaAreaLogline>();
                    list.Add(lal);

                    lock (Loglines)
                    {
                        Loglines.Add(lal.MachinePuid, list);
                    }
                }
                else
                {
                    lock (list)
                    {
                        list.Add(lal);
                    }
                }
            }
            catch (Exception e)
            {
                Ro.Error("Could not save this log line:\n" + datagram + "\n  because of:\n" + e.ToString());
            }
        }

        /// <summary>
        /// Gets the log lines associated with the machine puid. The list should be locked on for access.
        /// </summary>
        public static List<LuaAreaLogline> GetLogs (ulong machinePuid)
        {
            lock (Loglines)
            {
                List<LuaAreaLogline> ans;

                if (Loglines.TryGetValue(machinePuid, out ans))
                {
                    return ans;
                }

                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncConnectionServerStomping.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Auth;

namespace XSGTest
{
    [TestGroup, TestCasePriority(1), EnvRequirement("TestFD"), Owner("johnmcp")]
    public class PortStomping : TestNode
    {
        [TestCase]
        public class CheckPortPartitioning : TestBase_Data
        {
            protected override void RunTest()
            {
                // Read in the port partition values
                int maxPortCount = 0;
                int reserverdPortCount = 0;
                GetPortPartitionSizes(out maxPortCount, out reserverdPortCount);
                int expectedUsedPorts = maxPortCount - reserverdPortCount;

                // Send a bunch of requests to the unreserved ports.
                List<ushort> unreservedPorts = new List<ushort>();
                int iterations;
                for (int repeat = 0; repeat < 3; repeat++)
                {
                    iterations = maxPortCount * 2;
                    ro.Debug("Sending {0} packets, repetition #{1}", iterations, repeat);
                    for (int i = 0; i < iterations; i++)
                    {
                        ushort clientPort = (ushort)(i + 1000 + (repeat * 10));
                        if (ReflectUdpWithNATDataVerify(defPayload, clientPort))
                        {
                            // Packet was reflected fine, so track the port.
                            ushort mappedPort = GetMappedPort();
                            if (!unreservedPorts.Contains(mappedPort))
                                unreservedPorts.Add(mappedPort);
                        }
                        else
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }

                // Check that we only used the correct amount of ports
                if (unreservedPorts.Count != expectedUsedPorts)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    ro.Error("Utilised port count on SG did not equal expect count. Expected {0} ports to be used, but identified {1}.", expectedUsedPorts, unreservedPorts.Count);
                }

                // We know that we didn't use th reserved ports, but make sure that we can send data to them
                List<ushort> connServerPorts = new List<ushort>();
                for (int repeat = 0; repeat < 3; repeat++)
                {
                    iterations = reserverdPortCount * 2;
                    ro.Debug("Sending {0} packets to connection server, repitition #{1}", iterations, repeat);
                    for (int i = 0; i < iterations; i++)
                    {
                        ushort clientPort = (ushort)(i + 1000 + (repeat * 10));
                        if (ReflectUdpWithNATDataVerify(defPayload, clientPort, SGFakeService.IServicePort.TestRefl2))
                        {
                            // Packet was reflected fine, so track the port.
                            ushort mappedPort = GetMappedPort();
                            if (!connServerPorts.Contains(mappedPort))
                                connServerPorts.Add(mappedPort);
                        }
                        else
                        {
                            ro.Debug("Failed on iteration #{0}", i);
                            return;
                        }
                    }
                }

                // Make sure that we only used the expected number of reserved ports
                if (connServerPorts.Count != reserverdPortCount)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    ro.Error("Utilised port count on SG for connection server did not equal expect count. Expected {0} ports to be used, but identified {1}.", reserverdPortCount, connServerPorts.Count);
                }

                // Finally verify that there is no overlap between the port list (i.e. connection server ports are dinstinct)
                foreach (ushort port in connServerPorts)
                {
                    if (unreservedPorts.Contains(port))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        ro.Error("Detected that port {0} was used to service both Xrl Requests and Connection Server requests.", port);
                    }
                }
            }

            /// <summary>
            /// Reads in the port partition valuse from NPDB
            /// </summary>
            /// <param name="maxPorts"></param>
            /// <param name="reservedPorts"></param>
            private void GetPortPartitionSizes(out int maxPorts, out int connectionServerPorts)
            {
                maxPorts = Global.XEnv.GetIntSetting("sg_ClientPortLimit");
                connectionServerPorts = Global.XEnv.GetIntSetting("sg_ConnectionServerPortLimit");
            }

            /// <summary>
            /// Extracts the mapped port from the reflected payload
            /// </summary>
            /// <returns></returns>
            private ushort GetMappedPort()
            {
                // Port is reflected in the buffer at offset 8
                return Convert.ToUInt16(BitConverter.ToInt32(lastXsp.Payload, 8));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\ArpAutomated.cs ===
using System;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XSGTest
{
    /// <HighLevel>
    /// These tests generate ARP traffic to create artificial situations in the SG.  They are intended to do things that
    /// are impossible using known, well-behaved systems.
    /// 
    /// As most of the positive tests are currently manual cases, these too require some manual work (NetMon, Event Viewer).  In addition, they 
    /// must be run from a machine on the same local network as the target, and RawNic must be installed.
    /// </HighLevel>
    /// <Goals>
    /// <ul>
    /// <li>Generate ARP traffic that is otherwise difficult to create</li>
    /// </ul>
    /// </Goals>
    /// <NonGoals>
    /// <ul>
    /// <li>Positive tests</li>
    /// <li>Full coverage</li>
    /// </ul>
    /// </NonGoals>
    [TestGroup, Ignore, EnvRequirement("Manual")]
    public class ArpAutomated : TestNode
    {
        #region Internals and Setup

        public const string TargetIPProperty = "Automated ARP Test Target IP";
        public const string TargetMACProperty = "Automated ARP Test Target MAC";

        /// <summary>
        /// Static constructor adds our property.
        /// </summary>
        static ArpAutomated ()
        {
            SgPlugin.AddOrSetProperty(TargetIPProperty, "");
            SgPlugin.AddOrSetProperty(TargetMACProperty, "");
        }

        private RawNic rawnic = null;
        private IPAddress IP = null;
        private IpAddr IPAddr = null;
        private EnetAddr MAC = null;

        private IpAddr FakeRequestTargetIP = new IpAddr("172.172.172.172");
        private EnetAddr FakeRequestSenderMAC = new EnetAddr("FF-01-02-03-04-05");
        private EnetAddr FakeResponseTargetMAC = new EnetAddr("FF-06-07-08-09-0A");

        public override void PreRun ()
        {
            CommonCleanup();

            // get ip address from property
            IPAddress ip = GetTargetIP();

            if (ip == null)
            {
                throw new InvalidOperationException("Invalid value specified for " + TargetIPProperty);
            }

            IP = ip;
            IPAddr = new IpAddr(IP.GetAddressBytes());

            // get mac from property
            byte[] mac = GetTargetMAC();

            if (mac == null)
            {
                throw new InvalidOperationException("Invalid value specified for " + TargetMACProperty);
            }

            MAC = new EnetAddr(mac);

            // rawnic
            rawnic = new RawNic();
            rawnic.Open(IPAddr, false);
        }

        public override void PostRun ()
        {
            CommonCleanup();
        }

        /// <summary>
        /// Cleanup done at both teardown and setup times, for bulletproofing.
        /// </summary>
        private void CommonCleanup ()
        {
            if (rawnic != null)
            {
                try
                {
                    rawnic.Close();
                }
                catch (RawNic.RawNicException rne)
                {
                    Global.RO.Warn("RawNic close threw an exception, continuing:\n" + rne.Message);
                }

                rawnic = null;
            }

            IP = null;
            MAC = null;
        }

        /// <summary>
        /// Gets the target IP from the SG properties.
        /// </summary>
        /// <returns>The IPAddress specified by the property, or null if it is not one.</returns>
        private IPAddress GetTargetIP ()
        {
            string prop_val = SgPlugin.GetProperty(TargetIPProperty);

            if (prop_val == null) { return null; }

            IPAddress ans;
            if (IPAddress.TryParse(prop_val, out ans))
            {
                return ans;
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the target MAC from the SG properties.
        /// </summary>
        /// <returns>The byte[] specified by the property, or null if it is not one.</returns>
        private byte[] GetTargetMAC ()
        {
            string prop_val = SgPlugin.GetProperty(TargetMACProperty);

            // guaranteed to NOT catch any errors in the hex string
            return Hexer.unhex(prop_val);
        }

        #endregion

        /// <summary>
        /// Sends a probe packet originating from the target.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends a probe packet originating from the target.  The SG should ignore this packet, in the event that it was sent
        /// by itself and somehow reflected back.
        /// </description>
        /// </remarks>
        [TestCase, Description("Sends a probe packet originating from the target.")]
        public void SendProbeFromTarget ()
        {
            ArpPacket ap = new ArpPacket();
            ap.SetProbe(MAC, IPAddr);
            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
        }

        /// <summary>
        /// Sends a request packet originating from the target.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends a request packet originating from the target.  The SG should ignore this packet, in the event that it was sent
        /// by itself and somehow reflected back.
        /// </description>
        /// </remarks>
        [TestCase, Description("Sends a request packet originating from the target.")]
        public void SendRequestFromTarget ()
        {
            ArpPacket ap = new ArpPacket();
            // hopefully noone actually has this IP...
            ap.Set(MAC, IPAddr, FakeRequestTargetIP);
            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
        }

        /// <summary>
        /// Sends an announcement packet originating from the target.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends an announcement packet originating from the target.  The SG should ignore this packet, in the event that it was sent
        /// by itself and somehow reflected back.
        /// </description>
        /// </remarks>
        [TestCase, Description("Sends an announcement packet originating from the target.")]
        public void SendAnnouncementFromTarget ()
        {
            ArpPacket ap = new ArpPacket();
            ap.Set(MAC, IPAddr, IPAddr);
            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
        }

        /// <summary>
        /// Sends a request packet using the target's IP as our own.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends a request packet using the target's IP as our own.
        /// This will be a sender conflict, and the SG should go into a defend state.
        /// </description>
        /// </remarks>
        [TestCase, Description("Sends a request packet using the target's IP as our own.")]
        public void SenderConflictWithTarget ()
        {
            ArpPacket ap = new ArpPacket();
            // hopefully noone actually has this IP...
            ap.Set(FakeRequestSenderMAC, IPAddr, FakeRequestTargetIP);
            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
        }

        /// <summary>
        /// Sends multiple request packets using the target's IP as our own.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends multiple request packets using the target's IP as our own.
        /// This will be a sender conflict, and the SG should go into a defend state.
        /// The second packet should not cause another defense announcement.
        /// </description>
        /// </remarks>
        [TestCase, Description("Sends multiple request packets using the target's IP as our own.")]
        public void SenderConflictWithTarget_x2WithDelay ()
        {
            ArpPacket ap = new ArpPacket();
            // hopefully noone actually has this IP...
            ap.Set(FakeRequestSenderMAC, IPAddr, FakeRequestTargetIP);
            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
            System.Threading.Thread.Sleep(2000);
            rawnic.Send(buff);
        }

        /// <summary>
        /// Sends multiple request packets using the target's IP as our own.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends multiple request packets using the target's IP as our own.
        /// This will be a sender conflict, and the SG should go into a defend state.
        /// Defense announcement's should not be sent more often than every 10 seconds (configurable on the SG).
        /// </description>
        /// </remarks>
        [TestCase, Description("Sends multiple request packets using the target's IP as our own.")]
        public void SenderConflictWithTarget_x10WithDelay ()
        {
            ArpPacket ap = new ArpPacket();
            // hopefully noone actually has this IP...
            ap.Set(FakeRequestSenderMAC, IPAddr, FakeRequestTargetIP);
            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
            for (int i = 0; i < 9; ++i)
            {
                System.Threading.Thread.Sleep(2000);
                rawnic.Send(buff);
            }
        }

        /// <summary>
        /// Sends multiple request packets using the target's IP as our own.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends multiple request packets using the target's IP as our own.
        /// This will be a sender conflict, and the SG should go into a defend state.
        /// Nothing after the first packet should not cause another defense announcement.
        /// </description>
        /// </remarks>
        [TestCase, Description("Sends multiple request packets using the target's IP as our own.")]
        public void SenderConflictWithTarget_x10NoDelay ()
        {
            ArpPacket ap = new ArpPacket();
            // hopefully noone actually has this IP...
            ap.Set(FakeRequestSenderMAC, IPAddr, FakeRequestTargetIP);
            byte[] buff = (byte[])ap;
            for (int i = 0; i < 10; ++i)
            {
                rawnic.Send(buff);
            }
        }

        /// <summary>
        /// Puts the SG into a defense state, then sends a probe.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Puts the SG into a defense state, then sends a probe.
        /// The SG should still respond to the probe with a normal ARP response.
        /// </description>
        /// </remarks>
        [TestCase, Description("Puts the SG into a defense state, then sends a probe.")]
        public void ProbeDuringDefendState ()
        {
            ArpPacket ap = new ArpPacket();
            // hopefully noone actually has this IP...
            ap.Set(FakeRequestSenderMAC, IPAddr, FakeRequestTargetIP);
            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
            System.Threading.Thread.Sleep(2000);

            // create and send a probe now
            ap = new ArpPacket();
            ap.SetProbe(FakeRequestSenderMAC, IPAddr);
            buff = (byte[])ap;
            rawnic.Send(buff);
        }

        /// <summary>
        /// Sends a random (one of several predefined choices) ARP packet.
        /// </summary>
        /// <remarks>
        /// <description>
        /// Sends a random (one of several predefined choices) ARP packet.
        /// The current choices are:
        /// <ul>
        /// <li>Probe for the target IP.</li>
        /// <li>Request using target IP for sender.</li>
        /// </ul>
        /// </description>
        /// </remarks>
        public void RandomARPFuzz ()
        {
            ArpPacket ap = new ArpPacket();

            // pick a random one
            int val = RandomEx.GlobalRandGen.Next(0, 2);

            switch (val)
            {
                case 0:
                    ap.SetProbe(FakeRequestSenderMAC, IPAddr);
                    break;

                case 1:
                    ap.Set(FakeRequestSenderMAC, IPAddr, FakeRequestTargetIP);
                    break;
            }

            byte[] buff = (byte[])ap;
            rawnic.Send(buff);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncKeyexSg.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

 
namespace XSGTest
{
    [TestGroup, TestCasePriority(1)]
#if LSPTEST
    [CompoundCase("AuthData 3", 3)]
    [CompoundCase("AuthData 4", 4)]
#endif
    public class Keyex_Sg : MultiAuthDataBase
    {
        public Keyex_Sg()
        {
            Name = GetType().Name;

            // Add tests here
            //                U1    U2  TID     CS   ICMP  VERIFY
            AddChild(new KeyexTest(null, null, 0, false, false, false));                 // machine
            AddChild(new KeyexTest(null, null, 0, false, true, false));                  // machine icmp
            AddChild(new KeyexTest(null, null, 0, true, false, false));                  // machine cs (-)
            AddChild(new KeyexTest("xktduusert2a", null, 0, false, false, false));       // user
            AddChild(new KeyexTest("xktduusert2a", "user2", 0, false, false, false));    // 2 users
            AddChild(new KeyexTest("xktduusert2a", null, 0, false, true, false));        // user icmp
            AddChild(new KeyexTest("xktduusert2a", null, 0, true, false, false));        // user cs
            AddChild(new KeyexTest("xktduusert2a", null, 0, true, true, false));         // user cs icmp
            AddChild(new KeyexTest("xktduusert2a", null, 0, true, false, true));         // user cs verify
            AddChild(new KeyexTest("xktduusert2a", "xktusert2a", 0, true, false, true)); // 2user cs verify
        }

        [TestCase]
            class Keyex_CheckReplyIp : TestBase_Keyex
        {
            override protected bool VerifyTest()
            {
                if (!base.VerifyTest())
                    return false;

                IPEndPoint ep = (IPEndPoint)sg.Context.Udp.epRemote;
                ro.Debug("Sent key exchange to {0}, got reply from {1} (should be the same)", sg.IpServer.ToString(), ep.ToString());
                if (!sg.IpServer.Equals(ep))
                {
                    return false;
                }
                return true;
            }
        }

        [TestCase, Ignore]
            class Keyex_RealTicket_Machine_Simple : TestBase_Keyex
        {
            override protected void SetDefaults()
            {
                base.numSimulatedUsers = 0;
                base.SetDefaults();
            }
            override protected void RunTest()
            {
                XkdcClient xkdc = new XkdcClient(sg.Context);
                xkdc.SignInXkdc();
                sg.SignInSG();
            }

        }

        [TestCase]
            class Keyex_FakeTicket_Machine_Simple : TestBase_Keyex
        {
            override protected void SetDefaults()
            {
                base.numSimulatedUsers = 0;
                base.SetDefaults();
            }
            override protected void RunTest()
            {
                base.RunTest();
                ro.Debug("Keyex: {0}", sg.Context.Site.ToString());
            }
        }

        [TestCase, Ignore]
            class Keyex_RealTicket_User_Simple_CS : TestBase_Keyex
        {
            override protected void RunTest()
            {
                sg.bUseConnectionServices = true;
                XkdcClient xkdc = new XkdcClient(sg.Context);
                xkdc.SignInXkdc();
                sg.SignInSG();
            }
        }

        [TestCase]
            class Keyex_FakeTicket_User_Simple_CS : TestBase_Keyex
        {
            override protected void RunTest()
            {
                base.RunTest();
                ro.Debug("Keyex: {0}", sg.Context.Site.ToString());
            }
        }

        [TestCase]
            class Keyex_User_Dual : TestBase_Keyex
        {
            override protected void RunTest()
            {
#if !LSPTEST
                sg.bUseConnectionServices = true;
#endif
                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());

                // Sign out, sign in again 
                Thread.Sleep(2000);  // 1 second between key exchanges
                sg.SendDelete();

                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());
            }
        }

        [TestCase]
            class Keyex_User_Reinit : TestBase_Keyex
        {
            override protected void RunTest()
            {
#if !LSPTEST
                sg.bUseConnectionServices = true;
#endif
                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());

                // Sign in again without signing out
                Thread.Sleep(2000);  // 1 second between key exchanges
                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());
            }
        }

        [TestCase]
            class Keyex_User_Dual_OtherUser : TestBase_Keyex
        {
            override protected void RunTest()
            {
#if !LSPTEST
                sg.bUseConnectionServices = true;
#endif
                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());

                // Sign out, sign in again 
                Thread.Sleep(2000);  // 1 second between key exchanges
                sg.SendDelete();

                // Someone else signs in
#if !LSPTEST
                SgClient sg2 = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                sg2.Context.SetUser("bubba", 0);
                sg2.bUseConnectionServices = true;
                sg2.SignInSG();
                ro.Debug("Other user: {0}", sg2.KeyexResult.keyexResp.SGAddressInit.ToString());
#else
                LspClient sg2 = new LspClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                sg2.Context.SetUser("bubba", 0);
                sg2.SignInLSP();
#endif

                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());
            }
        }

        [TestCase]
            class Keyex_User_Reinit_OtherUser : TestBase_Keyex
        {
            override protected void RunTest()
            {
#if !LSPTEST
                sg.bUseConnectionServices = true;
#endif
                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());

                // Someone else signs in
#if !LSPTEST
                SgClient sg2 = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                sg2.Context.SetUser("bubba", 0);
                sg2.bUseConnectionServices = true;
                sg2.SignInSG();
                ro.Debug("Other user: {0}", sg2.KeyexResult.keyexResp.SGAddressInit.ToString());
#else
                LspClient sg2 = new LspClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                sg2.Context.SetUser("bubba", 0);
                sg2.SignInLSP();
#endif

                // Sign in again without signing out
                Thread.Sleep(2000);  // 1 second between key exchanges
                DoKeyExchange();
                EnsureStillSignedIn();
                ro.Debug(sg.KeyexResult.keyexResp.SGAddressInit.ToString());
            }
        }

        [TestCase]
            class Keyex_User_Reinit_KeyexTooSoon : TestBase_Keyex
        {
            override protected void RunTest()
            {
                DoKeyExchange();

                // Sign in again without signing out and immediately after the last key exchange
                bExpectedNoReply = true;
                DoKeyExchange();
            }
        }

        [TestCase, Description("Sign in, sign out, sign in immediately")]
        public class Keyex_User_KeyexTooSoon_WithDelete : TestBase_Keyex
        {
            override protected void RunTest()
            {
                DoKeyExchange();
                sg.SendDelete();
                bExpectedNoReply = true;
                DoKeyExchange();
            }
        }

        [TestCase, Description("Sign in, sign out, sign in immediately")]
            class Keyex_User_KeyexTooSoon_WithDeleteAndPause : TestBase_Keyex
        {
            override protected void RunTest()
            {
                DoKeyExchange();
                sg.SendDelete();
                Thread.Sleep(2000);
                DoKeyExchange();
                EnsureStillSignedIn();
            }
        }

        [TestCase, Description("Sign in, then send the key ex packet again.")]
        public class Keyex_Resend : TestBase_Keyex
        {
            override protected void RunTest ()
            {
                DoKeyExchange();
                sg.KeyexRequest.Send(sg.IpServer, sg.Context.Udp);
            }
        }

        [TestCase, Description("Sign in, sign out, then send the key ex packet again.")]
        public class Keyex_Resend_WithDelete : TestBase_Keyex
        {
            override protected void RunTest ()
            {
                DoKeyExchange();
                sg.SendDelete();
                sg.KeyexRequest.Send(sg.IpServer, sg.Context.Udp);
            }
        }

        [TestCase]
            class Kerb_TicketRealm_Invalid : TestBase_Keyex
        {
            override protected void RunTest()
            {
                bExpectedNoReply = true;
                sg.BuildFakeTicket(
                    sg.Context.Authdata, 
                    sg.Context.Site.serverName, 
                    sg.Context.Site.siteName, 
                    "ticketrealm.invalid",
                    sg.Context.k_PassportKerberosRealm,
                    sg.Context.k_TicketClientName1,
                    sg.Context.k_TicketClientName2,
                    sg.Context.Site.siteKey);
                sg.SignInSG();
            }
        }

        [TestCase]
            class Kerb_TicketRealm_None : TestBase_Keyex
        {
            override protected void RunTest()
            {
                bExpectedNoReply = true;
                sg.BuildFakeTicket(
                    sg.Context.Authdata, 
                    sg.Context.Site.serverName, 
                    sg.Context.Site.siteName, 
                    "",
                    sg.Context.k_PassportKerberosRealm,
                    sg.Context.k_TicketClientName1,
                    sg.Context.k_TicketClientName2,
                    sg.Context.Site.siteKey);
                sg.SignInSG();
            }
        }

        [TestCase]
        public class Kerb_Ticket_Expired : TestBase_Keyex
        {
            override protected void RunTest ()
            {
                bExpectedNoReply = true;
                long skew = 0;
                AuthClientBase.DLL_GetTimeSkew(out skew);

                try
                {
                    // skew time by one year and one day in the past (this is how long BuildFakeTicket will give us)
                    AuthClientBase.DLL_SetTimeSkew(-(60 * 60 * 24 * 366));
                    sg.BuildFakeTicket(sg.Context.Authdata);
                    sg.SignInSG();
                }
                finally
                {
                    // reset it
                    AuthClientBase.DLL_SetTimeSkew(skew);
                }
            }
        }

        [TestCase]
        public class Kerb_Authenticator_Expired : TestBase_Keyex
        {
            override protected void RunTest ()
            {
                bExpectedNoReply = true;
                long skew = 0;
                AuthClientBase.DLL_GetTimeSkew(out skew);

                try
                {
                    // skew time by one day, authenticator defaults to a 5 minute window either way
                    AuthClientBase.DLL_SetTimeSkew(-(60 * 60 * 24));
                    sg.SignInSG();
                }
                finally
                {
                    // reset it
                    AuthClientBase.DLL_SetTimeSkew(skew);
                }
            }
        }

        [TestCase]
            class Kerb_ClientRealm_Invalid_OK : TestBase_Keyex
        {
            override protected void RunTest()
            {
                sg.BuildFakeTicket(
                    sg.Context.Authdata, 
                    sg.Context.Site.serverName, 
                    sg.Context.Site.siteName, 
                    sg.Context.k_XboxKerberosRealm,
                    "clientrealm.invalid",
                    sg.Context.k_TicketClientName1,
                    sg.Context.k_TicketClientName2,
                    sg.Context.Site.siteKey);
                sg.SignInSG();
            }
        }

        [TestCase]
            class Kerb_ClientName2_Invalid_OK : TestBase_Keyex
        {
            override protected void RunTest()
            {
                sg.BuildFakeTicket(
                    sg.Context.Authdata, 
                    sg.Context.Site.serverName, 
                    sg.Context.Site.siteName, 
                    sg.Context.k_XboxKerberosRealm,
                    sg.Context.k_PassportKerberosRealm,
                    sg.Context.k_TicketClientName1,
                    "clientname2.invalid",
                    sg.Context.Site.siteKey);
                sg.SignInSG();
            }
        }

        [TestCase, Description("Perform an xmgmt 'e :sg reload_config' command then immediately attempt to sign in")]
            class Xmgmt_ReloadConfig_ThenKeyex: TestBase_Keyex
        {
            override protected void RunTest()
            {
                SgServerInfo.ReloadConfiguration(10000, false);

                base.RunTest();
            }
        }

#if !LSPTEST
        [TestGroup, TestCasePriority(3)]
        public class NullMachineId_MultiSetting : TestNode
        {
            private static List<ulong> NullMachines = null;

            static NullMachineId_MultiSetting ()
            {
                NullMachines = new List<ulong>();
            }

            private static void ExecuteAgainstNPDB (string command)
            {
                using (System.Data.SqlClient.SqlConnection conn =
                    new System.Data.SqlClient.SqlConnection(xonline.common.config.Config.NpdbConnectionString))
                {
                    conn.Open();

                    System.Data.SqlClient.SqlCommand comm = new System.Data.SqlClient.SqlCommand(command, conn);
                    comm.CommandType = System.Data.CommandType.Text;

                    comm.ExecuteNonQuery();
                }
            }

            public static void AddNullMachine (ulong machine)
            {
                AddNullMachine(machine, true);
            }

            public static void AddNullMachine (ulong machine, bool reload)
            {
                AddNullMachine(machine, reload, false);
            }

            public static void AddNullMachine (ulong machine, bool reload, bool useDecimal)
            {
                string command_text = "Insert into t_multisettings (vc_multisetting, vc_value) values ('" +
                    xonline.common.config.MultiSetting.sg_NullMachineId + "', '" + 
                    (useDecimal ? unchecked((long)machine).ToString("D") : "0x" + machine.ToString("X")) + "')";
                ExecuteAgainstNPDB(command_text);
                NullMachines.Add(machine);

                if (reload)
                {
                    // force config refresh and then reload the SG
                    XSGTest.SgEnvironmentInfo.ConfigCacheRefresh();
                    SgServerInfo.ReloadConfiguration();
                }
            }

            public override void PreRun (RUN_TYPE runType)
            {
                if (SgEnvironmentInfo.IsXblob)
                {
                    // check for the "everything is null" filter
                    foreach (var response in 
                        ManagementConsole.ExecuteOnAll(xonline.common.config.Interface.sgsvc, "e :sg list_challenges"))
                    {
                        if (!response.Result)
                        {
                            throw new UnexpectedTestResultException("We could not get the list of challenges.");
                        }

                        if (response.Response.Contains("NULL cipher for XBlob machines"))
                        {
                            throw new DidNotExecuteException("The 'NULL cipher for XBlob machines' filter invalidates these tests.");
                        }
                    }
                }

                // empty out machines
                NullMachines.Clear();
            }

            public override void PostRun (RUN_TYPE runType)
            {
                if (NullMachines.Count == 0)
                {
                    return;
                }

                // delete machines from npdb
                string command_text = "Delete from t_multisettings where vc_multisetting = '" +
                    xonline.common.config.MultiSetting.sg_NullMachineId + "' and vc_value in (";

                foreach (ulong machine in NullMachines)
                {
                    command_text += "'0x" + machine.ToString("X") + "', " + "'" + unchecked((long)machine).ToString("D") + "', ";
                }

                command_text = command_text.Substring(0, command_text.Length - 2) + ")";

                ExecuteAgainstNPDB(command_text);

                // now that they are gone, reload them away
                XSGTest.SgEnvironmentInfo.ConfigCacheRefresh();
                SgServerInfo.ReloadConfiguration();
            }

            public class TestBase_ClientVersion : TestBase_SgFake
            {
                protected override void InitGroup ()
                {
                    sg.SetupForFakeSignInXkdc();
                }

                public void SetClientVersion (bool useAES)
                {
                    Authdata_Base ad = sg.Context.Authdata;
                    ad.MajorVersion = XSGTest.SgEnvironmentInfo.AesMinClientVersionXbox360_Major;
                    ad.MinorVersion = XSGTest.SgEnvironmentInfo.AesMinClientVersionXbox360_Minor;
                    ad.BuildNumber = (ushort)(XSGTest.SgEnvironmentInfo.AesMinClientVersionXbox360_Build - (useAES ? 0 : 1));
                    ad.QFENumber = XSGTest.SgEnvironmentInfo.AesMinClientVersionXbox360_QFE;
                }

                public SecReg.CipherType Cipher
                {
                    get
                    {
                        return sg.Context.SecKeys.Cipher;
                    }
                }
            }

            [TestCase, Description("Sign in with a client that doesn't support AES.")]
            public class SimpleSignIn_LessThanAES : TestBase_ClientVersion
            {
                protected override void RunTest ()
                {
                    SetClientVersion(false);
                    sg.SignInSG();

                    // we should get DES3 unless something crazy is going down
                    if (Cipher != SecReg.CipherType.DES3)
                    {
                        if (Cipher == SecReg.CipherType.DES)
                        {
                            Global.RO.Warn("We got DES, that is a bit strange...");
                        }

                        throw new SGException("Got cipher " + Cipher.ToString() + " from SG, expected DES3.");
                    }
                }
            }

            [TestCase, Description("Sign in with a client that does support AES.")]
            public class SimpleSignIn_GreaterThanAES : TestBase_ClientVersion
            {
                protected override void RunTest ()
                {
                    SetClientVersion(true);
                    sg.SignInSG();

                    // we should get AES unless something crazy is going down
                    if (Cipher != SecReg.CipherType.AES)
                    {
                        throw new SGException("Got cipher " + Cipher.ToString() + " from SG, expected AES.");
                    }
                }
            }

            [TestCase, Description("Sign in with a client that doesn't support AES, but is set to NULL.")]
            public class NullMachine_LessThanAES : TestBase_ClientVersion
            {
                protected override void RunTest ()
                {
                    SetClientVersion(false);
                    NullMachineId_MultiSetting.AddNullMachine(sg.Context.Authdata.XboxID);
                    sg.SignInSG();

                    // we should get DES3 unless something crazy is going down
                    if (Cipher != SecReg.CipherType.DES3)
                    {
                        if (Cipher == SecReg.CipherType.DES)
                        {
                            Global.RO.Warn("We got DES, that is a bit strange...");
                        }

                        throw new SGException("Got cipher " + Cipher.ToString() + " from SG, expected DES3.");
                    }
                }
            }

            [TestCase, Description("Sign in with a client that does support AES, and is set to NULL.")]
            public class NullMachine_GreaterThanAES : TestBase_ClientVersion
            {
                protected override void RunTest ()
                {
                    SetClientVersion(true);
                    NullMachineId_MultiSetting.AddNullMachine(sg.Context.Authdata.XboxID);
                    sg.SignInSG();

                    // we should get NULL unless something crazy is going down
                    if (Cipher != SecReg.CipherType.NULL)
                    {
                        throw new SGException("Got cipher " + Cipher.ToString() + " from SG, expected NULL.");
                    }
                }
            }

            [TestCase, Description("Sign in with a second client that does support AES, and is set to NULL.")]
            [RunDependency("NullMachine_GreaterThanAES")]
            public class NullMachine_GreaterThanAES_2 : NullMachine_GreaterThanAES { }

            [TestCase, Description("Sign in with another client that does support AES, but isn't set to NULL.")]
            [RunDependency("NullMachine_GreaterThanAES")]
            public class SimpleSignIn_GreaterThanAES_2 : TestBase_ClientVersion { }

            [TestCase, Description("Sign in with a client that does support AES, and is set to NULL.  The SG multisetting value will be decimal.")]
            [RunDependency("NullMachine_GreaterThanAES")]
            public class NullMachine_GreaterThanAES_SignedDecimal : TestBase_ClientVersion
            {
                protected override void RunTest ()
                {
                    SetClientVersion(true);
                    NullMachineId_MultiSetting.AddNullMachine(sg.Context.Authdata.XboxID, true, true);
                    sg.SignInSG();

                    // we should get NULL unless something crazy is going down
                    if (Cipher != SecReg.CipherType.NULL)
                    {
                        throw new SGException("Got cipher " + Cipher.ToString() + " from SG, expected NULL.");
                    }
                }
            }

            [TestCase, Description("Sign in with a client that does support AES.  Also go crazy with machines.")]
            [CompoundCase("10", 10)]
            [CompoundCase("100", 100)]
            [CompoundCase("1000", 1000)]
            public class GreaterThanAES_WithNExtra : TestBase_ClientVersion
            {
                protected override void RunTest ()
                {
                    SetClientVersion(true);

                    // insert a whole lot of random machines
                    for (int i = 0, j = (int)MyValues[0]; i < j; ++i)
                    {
                        NullMachineId_MultiSetting.AddNullMachine(
                            (RandomEx.GlobalRandGen.NextUlong() & SgClient.k_CounterPuidMask) | SgClient.k_XenonMachinePuidMask, 
                            (i == (j - 1)));
                    }

                    DateTime before = DateTime.UtcNow;

                    for (int i = 0; i < 100; ++i)
                    {
                        sg.SignInSG();
                        sg.SignOutSG();
                        sg.Context.ClearXmacs();
                        sg.GetNewMachine();
                    }

                    DateTime after = DateTime.UtcNow;
                    Global.RO.Info("Time to sign in 100: " + (after - before).ToString());
                }
            }
        }
#endif
    }


    class KeyexTest : TestBase_Keyex
    {
        // Parameters
        string User1;
        string User2;
        uint TitleId;
        bool bUseCS;
        bool bVerifyICMP;
        bool bVerifyResult;

        public KeyexTest(string u1, string u2, uint titleid, bool useCS, bool verifyICMP, bool verifyResult)
        {
            // Save params
            this.User1 = u1;
            this.User2 = u2;
            this.TitleId = titleid;
            this.bUseCS = useCS;
            this.bVerifyICMP = verifyICMP;
            this.bVerifyResult = verifyResult;

            // Change name of test
            SetName();
        }

        public void SetName()
        {
            // Name of test will be:
            // Keyex_[NumUsers]U_[usernames]_[CS/NoCS]_[CheckICMP]_[VerifyResult]_[TitleID]

            // Numusers
            int numusers = 0;
            if (User1 != null)
                numusers++;
            if (User2 != null)
                numusers++;
            string prefix = "Keyex_" + numusers + "U";

            // user names
            if (User1 != null)
                prefix += "_" + User1;
            if (User2 != null)
                prefix += "_" + User2;

            // connection services
#if !LSPTEST
            prefix += bUseCS ? "_CS" : "_NoCS";
#else
            prefix += bUseCS ? "_CS_Fail" : "_NoCS";
#endif

            // verify icmp
            if (bVerifyICMP)
                prefix += "_CheckICMP";

            if (bVerifyResult)
                prefix += "_V";

            // title id (optional)
            if (TitleId != 0)
                prefix += "_" + TitleId.ToString("X");
                        
            this.Name = prefix;
        }

        protected override void InitGroup()
        {
            sg.Context.SetUser(User1, 0);
            sg.Context.SetUser(User2, 0);
            sg.bUseConnectionServices = bUseCS;
            if (TitleId != 0)
            {
                sg.Context.SetTitle(TitleId, 0, 0);
            }
#if LSPTEST
            if (bUseCS)
            {
                bExpectedNoReply = true;
            }
#endif
            base.InitGroup();
        }

        override protected bool VerifyTest()
        {
#if !LSPTEST           
            if (bVerifyICMP && sg.Context.Udp.connResetCounter != 1)
            {
                if (SgEnvironmentInfo.IsXblob)
                {
                    throw new DidNotExecuteException("Can not reliably test ICMP against an xblob.");
                }

                Fail("Did not receive the ICMP Port Unreachable message from the SG");
                return false;
            }
#else
            if (bVerifyICMP && sg.Context.Udp.connResetCounter != 0)
            {
                Fail("Received the ICMP Port Unreachable message from the SGLSP");
                return false;
            }
#endif

            if (bVerifyResult)
            {
                if (!bUseCS)
                {
                    ro.Debug("To verify the key exchange result, you must use Connection Services (CS)");
                    return false;
                }
                else
                {
                    Authdata_Base ad = sg.Context.Authdata;

                    KeyExchangeInitResponse resp = sg.KeyexResult.keyexResp;
                    IPEndPoint myIp = (IPEndPoint)sg.Context.Udp.udpSocket.LocalEndPoint;

                    if (resp.SGAddressInit.XboxID != ad.XboxID)
                        Fail("SGAddr said our XboxID is 0x{0:X}, but we think it is 0x{1:X}", resp.SGAddressInit.XboxID, ad.XboxID);

                    // TODO: get rid of this
                    ro.Debug("IPInit is {0}, PortInit is 0x{1:X}, SGAddr is {2}", resp.IPInit.ToString(), resp.PortInit, resp.SGAddressInit.ToString());

                    // Warnings
                    if (resp.XbToSgPulseTimeoutInSecs != 20)
                        ro.Warn("Xbox to SG pulse timeout: expected 20 seconds, got {0}", resp.XbToSgPulseTimeoutInSecs);
                    if (resp.XbToSgTimeoutInSecs!= 120)
                        ro.Warn("Xbox to SG timeout: expected 20 seconds, got {0}", resp.XbToSgTimeoutInSecs);
                }
            }
            return true;

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncFlowmapLog.cs ===
using System;
using System.Collections.Generic;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XSGTest
{
    [TestGroup, TestCasePriority(1)]
    public class FlowmapLog : TestNode
    {
        public override void PreRun ()
        {
            base.PreRun();

            SgServerInfo[] servers = SgServerInfo.Servers;

            foreach (SgServerInfo server in servers)
            {
                ManagementListener.Listen(server.XmgmtIp, "sg", "Reporting", Listener);
                Global.RO.Debug("Listening to SG Reporting on {0}", server.XmgmtIp);
            }
        }

        public override void PostRun ()
        {
            SgServerInfo[] servers = SgServerInfo.Servers;

            foreach (SgServerInfo server in servers)
            {
                ManagementListener.Stop(server.XmgmtIp, "sg", "Reporting", Listener);
            }

            base.PostRun();
        }

        protected override void PostProcessBranchConstruction ()
        {
            // the base FlowmapLog will not have values, the individual compound cases will
            if (MyValues == null)
            {
                return;
            }

            int authdataVersion = (int)MyValues[0];

            if (authdataVersion < Authdata_Base.XONLINE_XENON2_AUTHDATA_VERSION)
            {
                foreach (TestNode tn in Children)
                {
                    if (tn.Name == "ChangeFloken")
                    {
                        RemoveChild(tn);
                        break;
                    }
                }
            }
        }

        protected static List<FlowmapLogBase> _tests = new List<FlowmapLogBase>();

        public static void RegisterTest (FlowmapLogBase test)
        {
            lock (_tests)
            {
                if (!_tests.Contains(test))
                {
                    _tests.Add(test);
                }
            }
        }

        public static void UnregisterTest (FlowmapLogBase test)
        {
            lock (_tests)
            {
                _tests.Remove(test);
            }
        }

        public static void Listener (ManagementListener.Datagram dgram)
        {
            try
            {
                Global.RO.Debug(dgram.ToString());

                if (dgram.Text == null || dgram.Text == string.Empty)
                {
                    Global.RO.Debug("Got empty text log: {0}", dgram);
                }
                else
                {
                    string[] logsplit = dgram.Text.Split('|');

                    // guaranteed to have at least one string in the array, check for packet event starter
                    if (logsplit[0] != "SGFLOWMAP")
                    {
                        return;
                    }

                    if (logsplit.Length == 1)
                    {
                        Global.RO.Debug("Got short text log: {0}", dgram);
                    }
                    else
                    {
                        // pass split log line to test
                        dgram.UserData = logsplit;

                        lock (_tests)
                        {
                            foreach (FlowmapLogBase test in _tests)
                            {
                                test.HandleLog(dgram);
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Warn("Got exception from processing log:\r\n{0}", e);
            }
        }

        [TestCase]
        public class Mainline : FlowmapLogBase
        {
        }

        [TestCase]
        public class KeyexDual : FlowmapChangeLogBase
        {
            public override void ChangeAuthdata ()
            {
                Thread.Sleep(2000);
                sg.SendDelete();

                DoKeyExchange();
            }
        }

        [TestCase]
        public class KeyexReinit : FlowmapChangeLogBase
        {
            public override void ChangeAuthdata ()
            {
                Thread.Sleep(2000);

                DoKeyExchange();
            }
        }

        [TestCase]
        public class KeyexReinitTooSoon : FlowmapLogBase
        {
            public override void RunFlowmapTest ()
            {
                RetryKeyExOnTimeout = false;

                DoKeyExchange();
                bExpectedNoReply = true;
                DoKeyExchange();
            }
        }

        [TestCase]
        public class KeyexReinitTooSoonWithDelete : FlowmapLogBase
        {
            public override void RunFlowmapTest ()
            {
                RetryKeyExOnTimeout = false;

                DoKeyExchange();
                sg.SendDelete();
                bExpectedNoReply = true;
                DoKeyExchange();
            }
        }

        [TestCase]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 2)]
        [CompoundCase("{0}", 3)]
        [CompoundCase("{0}", 4)]
        public class UserCount : FlowmapLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = (int)MyValues[0];
                base.SetDefaults();
            }
        }

        [TestCase]
        [CompoundCase("{0}", 0)]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 2)]
        [CompoundCase("{0}", 3)]
        public class UserSlot : FlowmapLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = 0;
                base.SetDefaults();

                int userSlot = (int)MyValues[0];
                sg.Context.Authdata.GetUser((uint)userSlot).SetDefaults();
            }
        }

        [TestCase]
        [CompoundCase("{0}", 103)]
        [CompoundCase("{0}", 62)]
        [CompoundCase("{0}", 14)]
        [CompoundCase("{0}", 279)]
        public class UserCountry : FlowmapLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = 0;
                base.SetDefaults();

                int country = (int)MyValues[0];
                XUserID user = sg.Context.Authdata.GetUser((uint)(country % 4));
                user.SetDefaults();
                user.CountryId = (uint)country;
            }
        }

        [TestCase]
        [CompoundCase("{0}", 34)]
        [CompoundCase("{0}", 975)]
        [CompoundCase("{0}", 672)]
        [CompoundCase("{0}", 1033)]
        public class UserCountryWithGuest : FlowmapLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = 0;
                base.SetDefaults();

                int country = (int)MyValues[0];
                XUserID user = sg.Context.Authdata.GetUser((uint)(country % 4));
                user.SetDefaults();
                user.CountryId = (uint)country;

                XUserID guest = sg.Context.Authdata.GetUser((uint)(country % 4 == 0 ? 1 : 0));
                guest.SetDefaults();
                guest.CountryId = (uint)(country + 1);
                guest.IsGuest = true;
            }
        }

        [TestCase]
        [CompoundCase("{0}-{1}-{2}-{3}", 234, 34, 243, 986)]
        [CompoundCase("{0}-{1}-{2}-{3}", 856, 23, 354, 12)]
        [CompoundCase("{0}-{1}-{2}-{3}", 654, 23, 536, 67)]
        [CompoundCase("{0}-{1}-{2}-{3}", 1, 45, 657, 78)]
        public class MultipleCountries : FlowmapLogBase
        {
            protected override void SetDefaults ()
            {
                base.SetDefaults();

                for (uint i = 0; i < 4; ++i)
                {
                    int country = (int)MyValues[i];
                    XUserID user = sg.Context.Authdata.GetUser(i);
                    user.SetDefaults();
                    user.CountryId = (uint)country;
                }
            }
        }

        [TestCase]
        public class ChangeFloken : FlowmapChangeLogBase
        {
            public override void ChangeAuthdata ()
            {
                Authdata_Xenon2 authdata = sg.Context.Authdata as Authdata_Xenon2;

                if (authdata != null)
                {
                    authdata.flowToken = xonline.common.service.Floken.NewFloken().FlowToken;
                    sg.BuildFakeTicket(authdata);
                }

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        [TestCase]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 2)]
        [CompoundCase("{0}", 3)]
        public class ChangeUserCount : FlowmapChangeLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = (int)MyValues[0];
                base.SetDefaults();
            }

            public override void ChangeAuthdata ()
            {
                Authdata_Base authdata = sg.Context.Authdata;

                int userSlot = (int)MyValues[0];
                authdata.GetUser((uint)userSlot).SetDefaults();
                authdata.GetUser((uint)userSlot).CountryId += (uint)userSlot;
                sg.BuildFakeTicket(authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        [TestCase]
        [CompoundCase("{0}", 0)]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 2)]
        [CompoundCase("{0}", 3)]
        public class ChangeUserInSlot : FlowmapChangeLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = 0;
                base.SetDefaults();

                int userSlot = (int)MyValues[0];
                sg.Context.Authdata.GetUser((uint)userSlot).SetDefaults();
            }

            public override void ChangeAuthdata ()
            {
                Authdata_Base authdata = sg.Context.Authdata;

                int userSlot = (int)MyValues[0];
                authdata.GetUser((uint)userSlot).qwUserID++;
                authdata.GetUser((uint)userSlot).CountryId++;
                sg.BuildFakeTicket(authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        [TestCase]
        [CompoundCase("{0}", 0)]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 2)]
        [CompoundCase("{0}", 3)]
        public class ChangeUserSlot : FlowmapChangeLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = 0;
                base.SetDefaults();

                int userSlot = (int)MyValues[0];
                sg.Context.Authdata.GetUser((uint)userSlot).SetDefaults();
            }

            public override void ChangeAuthdata ()
            {
                Authdata_Base authdata = sg.Context.Authdata;

                int userSlot = (int)MyValues[0];

                XUserID original = authdata.GetUser((uint)userSlot);
                XUserID next = authdata.GetUser((uint)((userSlot + 1) % 4));
                next.qwUserID = original.qwUserID;
                next.dwUserFlags = original.dwUserFlags;
                original.qwUserID = 0;
                original.dwUserFlags = 0;
                sg.BuildFakeTicket(authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        [TestCase(BugDatabase = "Xbox 360 Console Software", BugID = 151786), TestCasePriority(3)]
        [CompoundCase("{0}", 103)]
        [CompoundCase("{0}", 62)]
        [CompoundCase("{0}", 14)]
        [CompoundCase("{0}", 279)]
        public class ChangeUserCountry : FlowmapChangeLogBase
        {
            protected override void SetDefaults ()
            {
                numSimulatedUsers = 0;
                base.SetDefaults();

                int country = (int)MyValues[0];
                XUserID user = sg.Context.Authdata.GetUser((uint)(country % 4));
                user.SetDefaults();
                user.CountryId = (uint)country;
            }

            public override void ChangeAuthdata ()
            {
                Authdata_Base authdata = sg.Context.Authdata;

                int country = (int)MyValues[0];

                XUserID original = authdata.GetUser((uint)(country % 4));
                original.CountryId = (uint)(country + 1);
                sg.BuildFakeTicket(authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        [TestCase]
        public class ChangeTitleId : FlowmapChangeLogBase
        {
            public override void ChangeAuthdata ()
            {
                Authdata_Base authdata = sg.Context.Authdata;

                authdata.TitleId = (uint)(RandomEx.GlobalRandGen.NextUlong() & 0xFFFFFFFF);
                sg.BuildFakeTicket(authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        [TestCase]
        public class ChangeTitleVersion : FlowmapChangeLogBase
        {
            public override void ChangeAuthdata ()
            {
                Authdata_Base authdata = sg.Context.Authdata;

                authdata.TitleVersion = (uint)(RandomEx.GlobalRandGen.NextUlong() & 0xFFFFFFFF);
                sg.BuildFakeTicket(authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        public class ChangeClientVersion : FlowmapChangeLogBase
        {
            public override void ChangeAuthdata ()
            {
                Authdata_Base authdata = sg.Context.Authdata;

                authdata.BuildNumber = (ushort)(RandomEx.GlobalRandGen.Next() & 0xFFFF);
                sg.BuildFakeTicket(authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
            }
        }

        // Leaving this here as it is a handy way to watch the log if you really want
        [TestCase, Ignore]
        public class Wait100 : TestBase
        {
            protected override void Execute ()
            {
                System.Threading.Thread.Sleep(100 * 1000);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Base class for flowmap log tests that don't change data.
        /// </summary>
        public class FlowmapLogBase : TestBase_SgFake
        {
            protected ManualResetEvent SyncObj = new ManualResetEvent(false);
            public int Timeout = 10000;

            // reinitialize these every time
            public int LogRepeatCount;
            public Exception ValidationException;
            public bool ProcessLoglines;
            public List<ManagementListener.Datagram> Loglines;

            protected override void SetDefaults ()
            {
                base.SetDefaults();
                
                // randomize the 
                Authdata_Base authdata = sg.Context.Authdata;
                authdata.MajorVersion = (ushort)(RandomEx.GlobalRandGen.Next() & 0xFFFF);
                authdata.MinorVersion = (ushort)(RandomEx.GlobalRandGen.Next() & 0xFFFF);
                authdata.BuildNumber = (ushort)(RandomEx.GlobalRandGen.Next() & 0xFFFF);
                authdata.QFENumber = (ushort)(RandomEx.GlobalRandGen.Next() & 0xFFFF);
                authdata.TitleId = (uint)(RandomEx.GlobalRandGen.NextUlong() & 0xFFFFFFFF);
                authdata.TitleVersion = (uint)(RandomEx.GlobalRandGen.NextUlong() & 0xFFFFFFFF);
            }

            protected override void RunTest ()
            {
                try
                {
                    LogRepeatCount = 0;
                    ValidationException = null;
                    ProcessLoglines = false;
                    Loglines = new List<ManagementListener.Datagram>();

                    FlowmapLog.RegisterTest(this);
                    SyncObj.Reset();

                    RunFlowmapTest();

                    ProcessLoglines = true;
                    lock (Loglines)
                    {
                        foreach (ManagementListener.Datagram dgram in Loglines)
                        {
                            HandleLog(dgram);
                        }
                    }

                    // waiting for HandleLog to signal us, it will fail the test if necessary
                    if (!SyncObj.WaitOne(Timeout, false))
                    {
                        throw new UnexpectedTestResultException("Failed to receive log line within timeout.");
                    }

                    if (ValidationException != null)
                    {
                        throw new UnexpectedTestResultException("Validation exception occured", ValidationException);
                    }

                    // verify that the SG is still running
                    TestBase_QOS qos = new TestBase_QOS();
                    qos.Run();

                    // check on logline count
                    ValueCheck.Test("LogRepeatCount", 1, LogRepeatCount);
                }
                finally
                {
                    FlowmapLog.UnregisterTest(this);
                }
            }

            public virtual void RunFlowmapTest ()
            {
                sg.bUseConnectionServices = false;
                DoKeyExchange();
            }

            public virtual void HandleLog (ManagementListener.Datagram dgram)
            {
                try
                {
                    if (ProcessLoglines)
                    {
                        if (ValidateLog(dgram, sg))
                        {
                            Interlocked.Increment(ref LogRepeatCount);
                        }
                    }
                    else
                    {
                        lock (Loglines)
                        {
                            Loglines.Add(dgram);
                        }
                    }
                }
                catch (Exception e)
                {
                    ValidationException = e;
                }

                if (ValidationException != null || LogRepeatCount >= 1)
                {
                    SyncObj.Set();
                }
            }

            public static bool ValidateLog (ManagementListener.Datagram dgram, SgClient sgClient)
            {
                string[] splitParts = (string[])dgram.UserData;

                ValueCheck.Test("Flowmap field count", 12, splitParts.Length);

                // first determine if it is ours by checking the nonce
                ulong nonce = Parse16CharHexUlong("Nonce", splitParts[1], dgram);
                ulong nonce_client = BitConverter.ToUInt64(sgClient.KeyexResult.keyexResp.NonceResp, 0);

                if (nonce != nonce_client)
                {
                    return false;
                }

                // grab authdata
                Authdata_Base authdata = sgClient.Context.Authdata;
                Authdata_Xenon2 authdata_xenon2 = authdata as Authdata_Xenon2;

                // debug print the two things to be compared
                Global.RO.Debug("Comparing authdata to logline:\n" + authdata + "\n" + dgram.Text);

                // flow token
                string floken_string = splitParts[2];
                ValueCheck.TestAny("Floken length", new int[] { 3, 18 }, floken_string.Length);
                ulong floken;
                if (floken_string.Length == 3)
                {
                    ValueCheck.Test("Floken (0)", "FT0", floken_string);
                    floken = 0;
                }
                else
                {
                    ValueCheck.Test("Floken start", "FT", floken_string.Substring(0, 2));

                    if (!ulong.TryParse(floken_string.Substring(2), System.Globalization.NumberStyles.AllowHexSpecifier, null, out floken))
                    {
                        throw new FlowmapLogException("Floken was not a hex ulong: " + floken_string, dgram);
                    }
                }
                ulong floken_client = 0;

                if (authdata_xenon2 != null)
                {
                    floken_client = authdata_xenon2.flowToken;
                }

                ValueCheck.Test("Floken", floken_client, floken);

                // Xbox id
                ulong xboxid = ParseHexUlong("Xbox ID", splitParts[3], dgram);
                ValueCheck.Test("Xbox ID", authdata.XboxID, xboxid);

                // Users
                for (int i = 0; i < 4; ++i)
                {
                    string userid_string = "User ID [" + i + "]";
                    ulong userid = ParseHexUlong(userid_string, splitParts[4 + i], dgram);
                    ValueCheck.Test(userid_string, authdata.GetUser((uint)i).qwUserID, userid);
                }

                // Country
                uint countryid = ParseHexUint("Country ID", splitParts[8], dgram);
                uint countryid_client = 0;

                for (uint i = 0; i < 4; ++i)
                {
                    XUserID user = authdata.GetUser(i);

                    if (user.Exists && !user.IsGuest)
                    {
                        countryid_client = user.CountryId;
                        break;
                    }
                }

                ValueCheck.Test("Country ID", countryid_client, countryid);

                // Title
                uint titleid = ParseHexUint("Title ID", splitParts[9], dgram);
                ValueCheck.Test("Title ID", authdata.TitleId, titleid);

                // Title Version
                uint titleversion = ParseHexUint("Title Version", splitParts[10], dgram);
                ValueCheck.Test("Title Version", authdata.TitleVersion, titleversion);

                // Client Version
                uint clientversion = ParseHexUint("Client Version", splitParts[11], dgram);
                uint clientversion_client = SgEnvironmentInfo.ConvertVersionToUint(authdata);
                ValueCheck.Test("Client Version", clientversion_client, clientversion);

                return true;
            }

            private static ulong Parse16CharHexUlong (string name, string value, ManagementListener.Datagram dgram)
            {
                ValueCheck.Test(name + " length", 16, value.Length);
                return ParseHexUlong(name, value, dgram);
            }

            private static ulong ParseHexUlong (string name, string value, ManagementListener.Datagram dgram)
            {
                ulong ans;
                if (!ulong.TryParse(value, System.Globalization.NumberStyles.AllowHexSpecifier, null, out ans))
                {
                    throw new FlowmapLogException(name + " was not a hex ulong: " + value, dgram);
                }

                return ans;
            }

            private static uint ParseHexUint (string name, string value, ManagementListener.Datagram dgram)
            {
                uint ans;
                if (!uint.TryParse(value, System.Globalization.NumberStyles.AllowHexSpecifier, null, out ans))
                {
                    throw new FlowmapLogException(name + " was not a hex uint: " + value, dgram);
                }

                return ans;
            }
        }

        /// <summary>
        /// Base class for flowmap log tests that change the data.
        /// </summary>
        public class FlowmapChangeLogBase : FlowmapLogBase
        {
            public override void RunFlowmapTest ()
            {
                InitialSetup();

                ProcessLoglines = true;
                lock (Loglines)
                {
                    foreach (ManagementListener.Datagram dgram in Loglines)
                    {
                        HandleLog(dgram);
                    }
                    Loglines.Clear();
                }

                // waiting for HandleLog to signal us, it will fail the test if necessary
                if (!SyncObj.WaitOne(Timeout, false))
                {
                    throw new UnexpectedTestResultException("Failed to receive log line within timeout.");
                }

                if (ValidationException != null)
                {
                    throw new UnexpectedTestResultException("Validation exception occured", ValidationException);
                }

                // check on logline count
                ValueCheck.Test("LogRepeatCount", 1, LogRepeatCount);

                LogRepeatCount = 0;
                ProcessLoglines = false;
                SyncObj.Reset();

                ChangeAuthdata();
            }

            public virtual void InitialSetup ()
            {
                sg.bUseConnectionServices = false;
                DoKeyExchange();
            }

            public virtual void ChangeAuthdata ()
            {
            }
        }
    }

    public class FlowmapLogException : UnexpectedTestResultException
    {
        public FlowmapLogException (string message, ManagementListener.Datagram dgram) : base(message + "\n  " + dgram.ToString()) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncData.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Auth;
 
namespace XSGTest
{
    [TestGroup, TestCasePriority(1), EnvRequirement("TestFD")]
    public class Data : TestNode
    {
        public static int Iterations = 80;

        [TestCase]
            class PortTranslation_MixedPorts : TestBase_Data
        {
            protected override void RunTest()
            {
                ushort[] ports = new ushort[] {
                    5, 1, 7, 2, 3, 9, 8, 6,
                    5, 1, 7, 2, 3, 9, 8, 6,
                    8, 2, 4, 3, 1, 9, 6, 7,
                    5, 1, 7, 2, 3, 9, 8, 6,
                    8, 2, 4, 3, 1, 9, 6, 7,
                    5, 1, 7, 2, 3, 9, 8, 6,
                    5, 1, 7, 2, 3, 9, 8, 6,
                    5, 1, 7, 2, 3, 9, 8, 6,
                    1
                };
                for (int repeat = 0; repeat < 2; repeat++)
                {
                    ro.Debug("Sending {0} packets, repetition #{1}", 65, repeat);
                    for (int i = 0; i < 65; i++)
                    {
                        if (!ReflectUdpVerify(defPayload, ports[i]))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }
            }
        }

        [TestCase]
            class PortTranslation_DeleteBeginning : TestBase_Data
        {
            protected override void RunTest()
            {
                // Send low port, wait a timer tick, send a bunch of high ports
                if (!ReflectUdpVerify(defPayload, 500))
                    return;
                Thread.Sleep(500);  // 200 msec is actual limit

                for (int repeat = 0; repeat < 2; repeat++)
                {
                    ro.Debug("Sending {0} packets, repetition #{1}", Data.Iterations, repeat);
                    for (int i = 0; i < Data.Iterations; i++)
                    {
                        if (!ReflectUdpVerify(defPayload, (ushort)(i + 1000)))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }
            }
        }

        [TestCase]
            class PortTranslation_DeleteEnd : TestBase_Data
        {
            protected override void RunTest()
            {
                // Send high port, wait a timer tick, send a bunch of low ports
                if (!ReflectUdpVerify(defPayload, 1500))
                    return;
                Thread.Sleep(500);  // 200 msec is actual limit

                for (int repeat = 0; repeat < 2; repeat++)
                {
                    ro.Debug("Sending {0} packets, repetition #{1}", Data.Iterations, repeat);
                    for (int i = 0; i < Data.Iterations; i++)
                    {
                        if (!ReflectUdpVerify(defPayload, (ushort)(i + 1000)))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }
            }
        }

        [TestCase]
            class PortTranslation_DeleteMiddle : TestBase_Data
        {
            protected override void RunTest()
            {
                // Send middle port, wait a timer tick, send a bunch of low and high ports
                if (!ReflectUdpVerify(defPayload, 1000))
                    return;
                Thread.Sleep(500);  // 200 msec is actual limit

                int toggle = -1;
                for (int repeat = 0; repeat < 2; repeat++)
                {
                    ro.Debug("Sending {0} packets, repetition #{1}", Data.Iterations, repeat);
                    for (int i = 0; i < Data.Iterations; i++)
                    {
                        toggle *= -1;
                        ushort port = (ushort)((i + 1000) + (toggle * 500));
                        if (!ReflectUdpVerify(defPayload, port))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }
            }
        }

        [TestCase]
            class PortTranslation_InsertBeginning : TestBase_Data
        {
            protected override void RunTest()
            {
                // Send in ascending order
                for (int repeat = 0; repeat < 2; repeat++)
                {
                    ro.Debug("Sending {0} packets, repetition #{1}", Data.Iterations, repeat);
                    for (int i = 0; i < Data.Iterations; i++)
                    {
                        if (!ReflectUdpVerify(defPayload, (ushort)(i + 1000)))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }
            }
        }

        [TestCase]
            class PortTranslation_InsertEnd : TestBase_Data
        {
            protected override void RunTest()
            {
                // Send in descending order
                for (int repeat = 0; repeat < 2; repeat++)
                {
                    ro.Debug("Sending {0} packets, repetition #{1}", Data.Iterations, repeat);
                    for (int i = Data.Iterations; i >= 0; i--)
                    {
                        if (!ReflectUdpVerify(defPayload, (ushort)(i + 1000)))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }
            }
        }

        [TestCase]
            class PortTranslation_dcaiafa : TestBase_Data
        {
            protected override void RunTest()
            {
                for (int repeat = 0; repeat < 5; repeat++)
                {
                    ro.Debug("Sending {0} packets, repetition #{1}", Data.Iterations, repeat);
                    for (int i = 0; i < Data.Iterations; i++)
                    {
                        if (!ReflectUdpVerify(defPayload, (ushort)(i + 1000 + (repeat * 10))))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }
                    }
                }
            }
        }


        [TestCase]
            class PortTranslation_ConnSrv: TestBase_Data
        {
            protected override void RunTest()
            {
                for (int repeat = 0; repeat < 2; repeat++)
                {
                    ro.Debug("Sending 10 packets, repetition #{0}", repeat);
                    for (int i = 0; i < 10; i++)
                    {
                        ushort srcPort = (ushort)(i + 1000 + (repeat * 5)); 
                        if (!ReflectUdpVerify(defPayload, srcPort))
                        {
                            ro.Debug("Failed on repetition #{0} iteration #{1}", repeat, i);
                            return;
                        }

                        // Now send to connection server. We won't get a response, but 
                        // watching the NatInfo trace in the SG would be useful.
                        sg.XspSendData(
                            defPayload,
                            (byte)sequenceNumber,
                            defAction,
                            defParam,
                            SGFakeService.IServicePort.ConnectionService,
                            (ushort)(srcPort + 1000));

                        ro.Debug("Sent packets from {0} and {1}", srcPort, srcPort + 1000);
                    }
                }
            }
        }





        [TestCase, TestCasePriority(3)]
            class Packet_Latency_LowLoad : TestBase_Data
        {
            protected override void RunTest()
            {
                int i;
                defAction = SGFakeService.ActionType.ReflectTimestamp;
                ro.Debug("Running 100 times synchronously...");
                long[] timeSent = new long[100];
                long[] timeRecv = new long[100];
                for (i = 0; i < 100; i++)
                {
                    // Send it
                    timeSent[i] = DateTime.Now.Ticks;
                    sg.XspSendData(
                        defPayload,
                        (byte)sequenceNumber,
                        defAction,
                        defParam,
                        ServicePort,
                        1000);
                    sequenceNumber = (sequenceNumber + 1) % 256;

                    // Recv it
                    int timeout = 2000;
                    if (!RecvLoop(ref timeout, false, true))
                    {
                        Fail("No UDP reflection received in {0} ms for sourcePort 1000 [packet {1}]", 2000, i);
                        return;
                    }
                    timeRecv[i] = DateTime.Now.Ticks;
                }

                long avgRtt = 0;
                long maxRtt = Int64.MinValue;
                long minRtt = Int64.MaxValue;
                for (i = 0; i < 100; i++)
                {
                    long rtt = timeRecv[i] - timeSent[i]; 
                    avgRtt += rtt;
                    if (rtt > maxRtt)
                        maxRtt = rtt;
                    if (rtt < minRtt)
                        minRtt = rtt;
                }
                avgRtt /= 100;

                long elapsed = (timeSent[99] - timeSent[0]) / 10000;
                ro.Debug("TEST RESULTS: Elapsed {0} ms, packet/sec: {1}", 
                        elapsed,
                        99  * 1000 / elapsed);
                ro.Debug("Latency results: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avgRtt / 10000),
                        (long)(maxRtt / 10000),
                        (long)(minRtt / 10000));

                // Flush buffer on ThroughputReflector
                sg.XspSendData(
                    defPayload,
                    (byte)sequenceNumber,
                    defAction,
                    1,
                    ServicePort,
                    1000);
            }
        }

        [TestCase, TestCasePriority(3)]
            class Packet_Latency_HighLoad : TestBase_Data
        {
            public void LoadSg(uint count, object userData)
            {
                int iterations = (int)userData;
                byte[] payload = new byte[32];
                int seqnum = 0;
                SgClient sg = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));

                sg.SignInSG();
                ro.Debug("[LoadSg] Signed in to SG, now sending {0} packets", iterations);

                for (int i = 0; i < iterations; i++)
                {
                    sg.XspSendData(
                        payload,
                        (byte)(seqnum++ % 256),
                        SGFakeService.ActionType.Reflect,
                        0,
                        ServicePort,
                        1001);
                }
            }

            protected override void RunTest()
            {
                if (SgEnvironmentInfo.IsXblob)
                {
                    throw new DidNotExecuteException("This load test does not reliably execute on an xblob.");
                }

                int i;
                defAction = SGFakeService.ActionType.ReflectTimestamp;

                // Fire off separate threads to hammer the SG
                int iterations = 100000;
                ParallelRunner.Status asyncStatus;
                asyncStatus = ParallelRunner.RunAsync(
                    LoadSg,
                    1,      // count
                    1,      // maxatonce
                    iterations);
                System.Threading.Thread.Sleep(2000);

                ro.Debug("Running 100 times synchronously...");
                long[] timeSent = new long[100];
                long[] timeRecv = new long[100];
                for (i = 0; i < 100; i++)
                {
                    // Send it
                    timeSent[i] = DateTime.Now.Ticks;
                    sg.XspSendData(
                        defPayload,
                        (byte)sequenceNumber,
                        defAction,
                        defParam,
                        ServicePort,
                        1000);
                    sequenceNumber = (sequenceNumber + 1) % 256;

                    // Recv it
                    int timeout = 2000;
                    if (!RecvLoop(ref timeout, false, true))
                    {
                        Fail("No UDP reflection received in {0} ms for sourcePort 1000 [packet {1}]", 2000, i);
                        return;
                    }
                    timeRecv[i] = DateTime.Now.Ticks;
                }

                long avgRtt = 0;
                long maxRtt = Int64.MinValue;
                long minRtt = Int64.MaxValue;
                for (i = 0; i < 100; i++)
                {
                    long rtt = timeRecv[i] - timeSent[i]; 
                    avgRtt += rtt;
                    if (rtt > maxRtt)
                        maxRtt = rtt;
                    if (rtt < minRtt)
                        minRtt = rtt;
                }
                avgRtt /= 100;

                long elapsed = (timeSent[99] - timeSent[0]) / 10000;
                ro.Debug("TEST RESULTS: Elapsed {0} ms, packet/sec: {1}", 
                        elapsed,
                        99 * 1000 / elapsed);
                ro.Debug("Latency results: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avgRtt / 10000),
                        (long)(maxRtt / 10000),
                        (long)(minRtt / 10000));

                // Flush buffer on ThroughputReflector
                sg.XspSendData(
                    defPayload,
                    (byte)sequenceNumber,
                    defAction,
                    1,
                    ServicePort,
                    1000);
            }
        }

        [TestCase, TestCasePriority(3)]
            class Packet_Ordering_LowLoad : TestBase_Data
        {
            protected override void RunTest()
            {
                int i;
                defAction = SGFakeService.ActionType.ReflectTimestamp;
                ro.Debug("Running 100 times asynchronously (batched, actually)...");
                // Send them all
                for (i = 0; i < 100; i++)
                {
                    sg.XspSendData(
                        defPayload,
                        (byte)sequenceNumber,
                        defAction,
                        defParam,
                        ServicePort,
                        1000);
                    sequenceNumber = (sequenceNumber + 1) % 256;
                }

                // Recv them all (?)
                byte prevSeq = 0;
                uint prevBigseq = 0;
                for (i = 0; i < 100; i++)
                {
                    // Recv it
                    int timeout = 2000;
                    if (!RecvLoop(ref timeout, false, true))
                    {
                        Fail("No UDP reflection received in {0} ms for sourcePort 1000, expecting packet {1}", 2000, i);
                        return;
                    }
                    if (lastDataLength != defPayload.Length)
                    {
                        Fail("Wrong size payload for packet {0}", i);
                        return;
                    }
                    byte seq = lastData[1];
                    uint bigseq;
                    ulong timestamp;
                    AuthClientBase.GetTimestamp(lastData, 4, out bigseq, out timestamp);

                    if (i != 0)
                    {
                        if (((prevSeq + 1) % 256) != seq)
                        {
                            Fail("Sequence numbers don't match for packet {0}: last seq {1}, this seq {2}",
                                 i, prevSeq, seq);
                            //return;
                        }
                        if (prevBigseq + 1 != bigseq)
                        {
                            Fail("Big sequence numbers don't match for packet {0}: last seq {1}, this seq {2}",
                                 i, prevBigseq, bigseq);
                            //return;
                        }
                    }

                    prevSeq = seq;
                    prevBigseq = bigseq;
                }

                // Flush buffer on ThroughputReflector
                sg.XspSendData(
                    defPayload,
                    (byte)sequenceNumber,
                    defAction,
                    1,
                    ServicePort,
                    1000);
            }
        }





    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncKeyexFilters.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
 
namespace XSGTest
{
    /// <summary>
    /// Base class for any LUA-specific tests. If a function is only relevant to LUA, it
    /// goes here. If it is relevant to the SG tests in general, it goes in
    /// TestBase_SgFake. If it is relevant to the SG itself, it goes in SgClient.
    /// 
    /// TODO: Rearchitect this so that it makes more sense, because as it is now with the optimization
    /// of loading the filters once per subgroup, it is a mess.  This will probably require some changes to
    /// TestBase_SgFake to fix the right way.
    /// </summary>
    class TestBase_KeyexFilters : TestBase_SgFake
    {
        #region Filter Strings

        protected static readonly string baseFilter = 
@"FilterDeclare(""{0}"")

function ApplyFilter()
{1}
end
";
        protected static readonly string versionCheck = 
@"if Spi.GetClientMajor() == {0} and Spi.GetClientMinor() == {1} and Spi.GetClientBuild() == {2} and Spi.GetClientQfe() == {3} then
{4}
end
";

        #endregion

        protected Authdata_Base        authData = null;
        protected bool needsReload = true;
        protected bool expectReloadFailure = false;
        protected bool manageFilters = true;

        protected override void InitGroup()
        {
            // Don't call the base one, we'll build a fake ticket just prior to signin so 
            // we can give the test a chance to twiddle the authdata.

            // Save a pointer to authdata to make life easier
            authData = sg.Context.Authdata;

            // Set our own custom client version that the LUA challenges or filters should 
            // target. The nnnn.nnnn.nnnn.nnnn client version is broken out like so:
            //   public ushort                   wMajorVersion;
            //   public ushort                   wMinorVersion;
            //   public ushort                   wBuildNumber;
            //   public ushort                   wQFENumber;
            authData.MajorVersion  = 0x5347;  // 'SG' in hex
            authData.MinorVersion  = 0x0002;  // 1 for LUA C/R, 2 for LUA filters
            authData.BuildNumber   = 0x4A4D;  // 'JM' in hex, used by these
            authData.QFENumber     = 0x0001;  // any tests that may stomp on each other should change this!
        }

        /// <summary>
        /// Creates and props the filter with the given arguments.
        /// </summary>
        /// <param name="name">The name of the filter, must be unique within the database.</param>
        /// <param name="body">The body of the filter.</param>
        protected void PropFilter (string name, string body)
        {
            LuaScript temp = new LuaScript() { Name = name, Script = String.Format(baseFilter, name, body) };
            ChalManager.AddScript(temp, false);
        }

        /// <summary>
        /// Creates and props the filter with the given arguments.
        /// </summary>
        /// <param name="name">The name of the filter, must be unique within the database.</param>
        /// <param name="declareName">The name to declare the filter with on the SG.</param>
        /// <param name="body">The body of the filter.</param>
        protected void PropFilter (string name, string declareName, string body)
        {
            LuaScript temp = new LuaScript() { Name = name, Script = String.Format(baseFilter, declareName, body) };
            ChalManager.AddScript(temp, false);
        }

        /// <summary>
        /// Props the given filter without reloading the SG.
        /// </summary>
        /// <param name="filter">The filter to prop.</param>
        protected void PropFilter (LuaScript filter)
        {
            ChalManager.AddScript(filter, false);
        }

        /// <summary>
        /// Surrounds the given code with a version check condition.
        /// If the version does not match the auth data, the code will not be run.
        /// </summary>
        /// <param name="code">The code to surround.</param>
        /// <returns>Lua code built in the manner requested.</returns>
        protected string SurroundWithVersionCheck (string code)
        {
            return String.Format(versionCheck, authData.MajorVersion, authData.MinorVersion, authData.BuildNumber,
                authData.QFENumber, code);
        }

        protected void Reload ()
        {
            bool gotReloadFailure = false;

            try
            {
                SgServerInfo.ReloadChallenges();
            }
            catch
            {
                if (expectReloadFailure)
                {
                    gotReloadFailure = true;
                }
                else
                {
                    throw;
                }
            }

            if (expectReloadFailure && !gotReloadFailure)
            {
                throw new UnexpectedTestResultException("We were expecting the SG to fail its reload.");
            }
        }

        /// <summary>
        /// Runs the Lua filter test.
        /// </summary>
        protected override void RunTest ()
        {
            if (needsReload)
            {
                Reload();
            }

            DoKeyExchange();
        }

        /// <summary>
        /// Removes all filters.
        /// </summary>
        /// <param name="runType"></param>
        public override void PostRun (RUN_TYPE runType)
        {
            if (manageFilters)
            {
                ChalManager.RemoveAllScripts();
            }
        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;

            // Put group-specific test verification here
            // If you do a check and need to report an error, do it like so:
            //   Fail("Test failed for title id 0x{0:X}", authData.dwTitleID);

            return true;
        }
    }


    [TestCasePriority(1), TestFrequency("Regression")]
    public class Filters : TestNode
    {
        #region Semi-Programatic Test Generation

        private class Filter_Setup
        {
            public string filter = null;
            public bool[] reply = null;

            public Filter_Setup (string f, int[] r)
            {
                filter = f;
                reply = new bool[10];
                for (int i = 0; i < reply.Length; ++i)
                {
                    reply[i] = false;
                }
                for (int i = 0; i < r.Length; ++i)
                {
                    reply[r[i]] = true;
                }
            }
        }

        /// <summary>
        /// Constructor adds tests to the group.
        /// </summary>
        public Filters ()
        {
            // Blocking on Console type
            List<Filter_Setup> tests = new List<Filter_Setup>();
            tests.Add(new Filter_Setup("Block Xboxs", new int[] { 0, 4 }));
            tests.Add(new Filter_Setup("Block Xbox360s", new int[] { 1, 5, 6, 7, 8 }));
            tests.Add(new Filter_Setup("Block Xenons", new int[] { 1, 2, 3, 5, 6, 7, 8, 9 }));
            tests.Add(new Filter_Setup("Block PCs", new int[] { 2, 9 }));
            tests.Add(new Filter_Setup("Block Fusion", new int[] { 3 }));
            tests.Add(new Filter_Setup("Block DevKits", new int[] { 4, 5, 7 }));
            tests.Add(new Filter_Setup("Block TestKits", new int[] { 6, 7 }));
            tests.Add(new Filter_Setup("Block Beta", new int[] { 8 }));
            tests.Add(new Filter_Setup("Block Limited", new int[] { 9 }));

            List<TestNode> testnodes = new List<TestNode>(10);

            foreach (Filter_Setup fs in tests)
            {
                testnodes.Clear();

                // [0] : Xbox
                testnodes.Add(new Filters_Mainline("Xbox", null,
                    AuthFlags.None, PlatformType.Xbox, fs.reply[0]));
                // [1] : Xenon
                testnodes.Add(new Filters_Mainline("Xenon", null,
                    AuthFlags.Xenon, PlatformType.Xenon, fs.reply[1]));
                // [2] : Panorama
                testnodes.Add(new Filters_Mainline("Panorama", null,
                    AuthFlags.Xenon, PlatformType.Panorama, fs.reply[2]));
                // [3] : Fusion
                testnodes.Add(new Filters_Mainline("Fusion", null,
                    AuthFlags.Fusion, PlatformType.Xenon, fs.reply[3]));
                // [4] : Xbox DevKit
                testnodes.Add(new Filters_Mainline("DevXbox", null,
                    AuthFlags.DevKit, PlatformType.Xbox, fs.reply[4]));
                // [5] : Xenon DevKit
                testnodes.Add(new Filters_Mainline("DevXenon", null,
                    AuthFlags.DevKit | AuthFlags.Xenon, PlatformType.Xenon, fs.reply[5]));
                // [6] : Retail Xenon TestKit
                testnodes.Add(new Filters_Mainline("TestRetail", null,
                    AuthFlags.TestKit | AuthFlags.Xenon, PlatformType.Xenon, fs.reply[6]));
                // [7] : DevKit Xenon TestKit
                testnodes.Add(new Filters_Mainline("TestDev", null,
                    AuthFlags.TestKit | AuthFlags.DevKit | AuthFlags.Xenon, PlatformType.Xenon, fs.reply[7]));
                // [8] : Retail Xenon Beta
                testnodes.Add(new Filters_Mainline("Beta", null,
                    AuthFlags.Beta | AuthFlags.Xenon, PlatformType.Xenon, fs.reply[8]));
                // [9] : Panorama Limited
                testnodes.Add(new Filters_Mainline("Limited", null,
                    AuthFlags.Limited | AuthFlags.Xenon, PlatformType.Panorama, fs.reply[9]));

                AddChild(new Filters_Mainline(fs.filter, fs.filter, testnodes));
            }

            // Blocking on version
            testnodes.Clear();
            testnodes.Add(new Filters_Mainline("Pass", null, new ushort[] { 0x5347, 0x0002, 0x4A4D, 0x0001 }, false));
            testnodes.Add(new Filters_Mainline("Block", null, new ushort[] { 0x5347, 0x0002, 0x4A4C, 0x0001 }, true));
            AddChild(new Filters_Mainline("Version Less Than", "Version Less Than", testnodes));

            // Blocking on title
            testnodes.Clear();
            testnodes.Add(new Filters_Mainline("Pass", null, 0xFAFAFADA, 6, false));
            testnodes.Add(new Filters_Mainline("Block", null, 0xDEADBABE, 1, true));
            AddChild(new Filters_Mainline("Block Title", "Block Title", testnodes));

            // Blocking on title version
            testnodes.Clear();
            testnodes.Add(new Filters_Mainline("Pass", null, 0xDEADBEEF, 2, false));
            testnodes.Add(new Filters_Mainline("Block", null, 0xDEADBEEF, 1, true));
            AddChild(new Filters_Mainline("Block Title Version", "Block Title Version", testnodes));

            // Blocking on title region
            testnodes.Clear();
            testnodes.Add(new Filters_Mainline("Pass", null, 0xDEADBEEF, 2, 2, false));
            testnodes.Add(new Filters_Mainline("Block", null, 0xDEADBEEF, 2, 1, true));
            AddChild(new Filters_Mainline("Block Title Region", "Block Title Region", testnodes));

            // Block a specific console ID
            testnodes.Clear();
            testnodes.Add(new Filters_Mainline("Pass", null, AuthFlags.None, PlatformType.Xbox, false));
            testnodes.Add(new Filters_Mainline("Block", null, AuthFlags.Xenon, 0xFA00123456789ABC, true));
            AddChild(new Filters_Mainline("Block Xbox ID", "Block Xbox ID", testnodes));

            // Block a specific IP
            // If this stops working, the best way is to connect to the SG and use the local ip of that connection
            // for these tests
            byte[] to_use = null;
            IPAddress sgIp = IpHelper.GetBestInterface(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.sgsvc).Address);

            if (sgIp != null)
            {
                to_use = sgIp.GetAddressBytes();
            }

            if (to_use == null)
            {
                Global.RO.Warn("Unable to determine local IP for SG connection, Filters_Block_IPs_* dropped.  Please fix.");
            }
            else
            {
                Filters_Mainline filter_test_pass =
                    new Filters_Mainline("Filters_Block_IPs_Pass", "Block IP", false,
                    to_use[0], to_use[1], to_use[2], (to_use[3] > 200 ? to_use[3] - 1 : to_use[3] + 1));
                AddChild(filter_test_pass);
                filter_test_pass.FunctionalData.BugID = 108304;

                Filters_Mainline filter_test_block =
                    new Filters_Mainline("Filters_Block_IPs_Block", "Block IP", true,
                    to_use[0], to_use[1], to_use[2], to_use[3]);
                AddChild(filter_test_block);
                filter_test_block.FunctionalData.BugID = 108304;
            }
        }

        #endregion

        #region Simple Tests

        /// <summary>
        /// With no filter we should be able to connect.
        /// </summary>
        [TestCase]
        class Filters_No_Filter : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                bExpectedNoReply = false;
            }
        }

        /// <summary>
        /// This test simply connects to the SG and expects to get through.
        /// The filter is as close to an empty function as we get.
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class Filters_Simple_Positive : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                PropFilter("Version Check Filter", "trace(\"Empty Filter outside version check\")\n" + 
                    SurroundWithVersionCheck("trace(\"Empty Filter inside version check\")"));

                bExpectedNoReply = false;
            }
        }

        /// <summary>
        /// This test simply connects to the SG and expects to get blocked.
        /// The filter will always block (assuming the client matches the version numbers).
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class Filters_Simple_Negative : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                PropFilter("Always Block Test Client Version", SurroundWithVersionCheck("Filter.Block()"));

                bExpectedNoReply = true;
            }
        }

        #endregion

        #region Bad Filters

        /// <summary>
        /// The Lua for this filter is an empty string.
        /// </summary>
        [TestCase(BugID = 70535, BugDatabase = "Xenon"), TestCasePriority(3)]
        class Filters_No_Lua : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                LuaScript filter = new LuaScript() { Name = "No Lua Filter", Script = "" };
                PropFilter(filter);

                bExpectedNoReply = false;
                expectReloadFailure = false;
            }
        }

        /// <summary>
        /// This filter does not declare itself, and should behave as if there is no filter present.
        /// IF the filter is indeed run, we will be blocked.
        /// </summary>
        [TestCase, TestCasePriority(3)]
        class Filters_No_FilterDeclare : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                LuaScript filter = new LuaScript()
                {
                    Name = "No Filter Declare",
                    Script = "function ApplyFilter()\n" +
                        SurroundWithVersionCheck("Filter.Block()") + "\nend\n"
                };
                PropFilter(filter);

                bExpectedNoReply = false;
            }
        }

        /// <summary>
        /// This filter has no Apply Filter function, we expect it to log the error but let us connect.
        /// </summary>
        [TestCase, TestCasePriority(3)]
        class Filters_No_ApplyFilter : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                LuaScript filter = new LuaScript() { Name = "No Apply Filter", Script = "FilterDeclare(\"No Apply Filter\")\n" };
                PropFilter(filter);

                bExpectedNoReply = false;
            }
        }

        /// <summary>
        /// This filter has multiple Declares, we will be blocked if we end up running the ApplyFilter twice due to
        /// a global variable.
        /// </summary>
        [TestCase(BugID = 99994, BugDatabase = "Xenon"), TestCasePriority(3)]
        class Filters_Multiple_FilterDeclare : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                PropFilter(new LuaScript(ChallengeManager.PreconfiguredLuaScripts["Multiple FilterDeclare"]));

                expectReloadFailure = false;
                bExpectedNoReply = false;
            }
        }

        /// <summary>
        /// This filter declares two ApplyFilter functions.  Apparently in Lua this assigns the second one over the
        /// first, so these two sections of code are equivalent:
        /// function foo () { "This is foo 1" }
        /// function foo () { "This is foo 2" }
        ///               AND
        /// function foo () { "This is foo 1" }
        /// foo = function () { "This is foo 2" }
        /// </summary>
        [TestCase, TestCasePriority(3)]
        class Filters_Multiple_ApplyFilter : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                PropFilter(new LuaScript(ChallengeManager.PreconfiguredLuaScripts["Multiple ApplyFilter"]));

                bExpectedNoReply = true;
            }
        }
        
        /// <summary>
        /// This test props two filters, one which should fail to load and one which will always block us.  If the 
        /// one that fails to load causes the blocking one to not load, we will fail the test.
        /// </summary>
        [TestCase(BugID = 70570, BugDatabase = "Xenon")]
        class Filters_Multiple_Filters_OneBad : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                PropFilter("Lua Error", "This will be very much a lua error!\nSomething.Something.Somethingelse()\n");
                PropFilter("Always Block Test Client Version", SurroundWithVersionCheck("Filter.Block()"));

                expectReloadFailure = false;
                bExpectedNoReply = true;
            }
        }

        [TestCase, TestCasePriority(3)]
        class Filters_Multiple_Filters_SameName : TestBase_KeyexFilters
        {
            protected override void InitTest ()
            {
                PropFilter("Always Block Test Client Version", "FilterNameMatchZQR", SurroundWithVersionCheck("trace('Inside first filter')\nFilter.Block()"));
                PropFilter("Trace Test Client Version", "FilterNameMatchZQR", SurroundWithVersionCheck("trace('Inside second filter')"));

                bExpectedNoReply = true;
            }
        }
        
        #endregion

        #region Special Cases
        /* Implement with bug for applying filters after user change (LSG 2763)
        [Description("")]
        public class ChangeUsers : Filters_Mainline
        {
            public ChangeUsers () : base("Change Users", "Block")
            {
            }
        }
        */
        #endregion

        #region China Authblock Tests

        [TestCase, Description("These tests require the filter_china.lua filter to be manually propped and changed."), Ignore]
        public class China : TestNode
        {
            public class TestBase_ChinaFilter : TestBase_Keyex
            {
                public void SetUserCountry (int slot, uint country)
                {
                    AuthContext context = sg.Context;

                    uint newFlags = UserFlagsUtil.SetUserCountryId(context.Users[slot].xuid.dwUserFlags, country);
                    context.Users[slot].xuid.dwUserFlags = context.Authdata.GetUser((uint)slot).dwUserFlags = newFlags;
                }
            }

            #region Machine

            [TestCase]
            public class MachineOnly_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    // no users
                    numSimulatedUsers = 0;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;
                }
            }

            [TestCase]
            public class MachineOnly_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    // no users
                    numSimulatedUsers = 0;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;
                }
            }

            #endregion

            #region 1 User

            [TestCase]
            public class OneUser_US_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set user
                    SetUserCountry(0, 103);
                }
            }

            [TestCase]
            public class OneUser_China_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set use
                    SetUserCountry(0, 20);
                }
            }

            [TestCase]
            public class OneUser_US_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 103);
                }
            }

            [TestCase]
            public class OneUser_China_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 20);
                }
            }

            #endregion

            #region 2 Users

            [TestCase]
            public class TwoUser_US_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 2;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set user
                    SetUserCountry(0, 103);
                    SetUserCountry(1, 103);
                }
            }

            [TestCase]
            public class TwoUser_Mixed_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 2;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set user
                    SetUserCountry(0, 103);
                    SetUserCountry(1, 20);
                }
            }

            [TestCase]
            public class TwoUser_China_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 2;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set use
                    SetUserCountry(0, 20);
                    SetUserCountry(1, 20);
                }
            }

            [TestCase]
            public class TwoUser_US_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 2;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 103);
                    SetUserCountry(1, 103);
                }
            }

            [TestCase]
            public class TwoUser_Mixed_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 2;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 20);
                    SetUserCountry(1, 103);
                }
            }

            [TestCase]
            public class TwoUser_China_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 2;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 20);
                    SetUserCountry(1, 20);
                }
            }

            #endregion

            #region 4 Users

            [TestCase]
            public class FourUser_US_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 4;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set user
                    SetUserCountry(0, 103);
                    SetUserCountry(1, 103);
                    SetUserCountry(2, 103);
                    SetUserCountry(3, 103);
                }
            }

            [TestCase]
            public class FourUser_Mixed_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 4;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set user
                    SetUserCountry(0, 103);
                    SetUserCountry(1, 20);
                    SetUserCountry(2, 103);
                    SetUserCountry(3, 103);
                }
            }

            [TestCase]
            public class FourUser_China_ZeroConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 4;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 0;

                    // set use
                    SetUserCountry(0, 20);
                    SetUserCountry(1, 20);
                    SetUserCountry(2, 20);
                    SetUserCountry(3, 20);
                }
            }

            [TestCase]
            public class FourUser_US_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 4;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 103);
                    SetUserCountry(1, 103);
                    SetUserCountry(2, 103);
                    SetUserCountry(3, 103);
                }
            }

            [TestCase]
            public class FourUser_Mixed_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 4;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 20);
                    SetUserCountry(1, 103);
                    SetUserCountry(2, 20);
                    SetUserCountry(3, 103);
                }
            }

            [TestCase]
            public class FourUser_China_ChinaConsoleRegion : TestBase_ChinaFilter
            {
                protected override void SetDefaults ()
                {
                    numSimulatedUsers = 4;
                    base.SetDefaults();

                    // set console region
                    sg.Context.Authdata.ConsoleRegion = 260;

                    // set user
                    SetUserCountry(0, 20);
                    SetUserCountry(1, 20);
                    SetUserCountry(2, 20);
                    SetUserCountry(3, 20);
                }
            }

            #endregion
        }

        #endregion

        #region Authblock TestBase

        /// <summary>
        /// The platform from which we are connecting.
        /// </summary>
        public enum PlatformType
        {
            Xbox,
            Xenon,
            Panorama
        }

        /// <summary>
        /// The type of machine to simulate connecting with.
        /// </summary>
        [Flags]
        public enum AuthFlags : uint
        {
            None=0x00,
            Xenon=0x01,
            Fusion=0x02,
            DevKit=0x04,
            TestKit=0x08,
            Beta=0x10,
            Limited=0x20,
        }

        /// <summary>
        /// A generic class for running all of the mainline tests.
        /// </summary>
        class Filters_Mainline : TestBase_KeyexFilters
        {
            protected string filterName = null;
            protected uint dwAuthDataFlags = 0;
            protected ulong qwXboxID = 0;
            protected bool _bExpectedNoReply = false;
            protected ushort[] _version = null;
            protected uint dwTitleID = 0;
            protected uint dwTitleVersion = 0;
            protected uint dwTitleRegion = 0;
            protected object[] format_args = null;

            public Filters_Mainline (string name, string filter)
            {
                Name = name;
                filterName = filter;
            }

            public Filters_Mainline (string name, string filter, List<TestNode> children)
            {
                Name = name;
                filterName = filter;
                foreach (TestNode node in children)
                {
                    AddChild(node, true, false);
                }
            }

            public Filters_Mainline (string name, string filter, AuthFlags auth, PlatformType platform, bool noReply)
            {
                Name = name;
                filterName = filter;
                dwAuthDataFlags = (uint) auth;
                SetPlatformType(platform);
                _bExpectedNoReply = noReply;
            }

            public Filters_Mainline (string name, string filter, AuthFlags auth, ulong xboxID, bool noReply)
            {
                Name = name;
                filterName = filter;
                dwAuthDataFlags = (uint) auth;
                qwXboxID = xboxID;
                _bExpectedNoReply = noReply;
            }

            public Filters_Mainline (string name, string filter, ushort[] version, bool noReply)
            {
                Name = name;
                filterName = filter;
                _version = version;
                _bExpectedNoReply = noReply;
            }

            public Filters_Mainline (string name, string filter, uint titleID, uint titleVersion, bool noReply)
            {
                Name = name;
                filterName = filter;
                dwTitleID = titleID;
                dwTitleVersion = titleVersion;
                _bExpectedNoReply = noReply;
            }

            public Filters_Mainline (string name, string filter, uint titleID, uint titleVersion, uint titleRegion, 
                bool noReply)
            {
                Name = name;
                filterName = filter;
                dwTitleID = titleID;
                dwTitleVersion = titleVersion;
                dwTitleRegion = titleRegion;
                _bExpectedNoReply = noReply;
            }

            public Filters_Mainline (string name, string filter, bool noReply, params object[] format)
            {
                Name = name;
                filterName = filter;
                _bExpectedNoReply = noReply;
                format_args = format;
            }

            /// <summary>
            /// Props the filter to prepare the test for running.
            /// </summary>
            protected override void InitTest ()
            {
                if (dwAuthDataFlags != 0)
                {
                    authData.AuthDataFlags = dwAuthDataFlags;
                }

                if (qwXboxID != 0)
                {
                    authData.XboxID = qwXboxID;
                }

                if (_version != null)
                {
                    authData.MajorVersion = _version[0];
                    authData.MinorVersion = _version[1];
                    authData.BuildNumber = _version[2];
                    authData.QFENumber = _version[3];
                }

                if (dwTitleID != 0)
                {
                    authData.TitleId = dwTitleID;
                }

                if (dwTitleVersion != 0)
                {
                    authData.TitleVersion = dwTitleVersion;
                }

                if (dwTitleRegion != 0)
                {
                    authData.TitleRegion = dwTitleRegion;
                }

                bExpectedNoReply = _bExpectedNoReply;
            }

            /// <summary>
            /// Props the filter.
            /// </summary>
            public override void PreRun (RUN_TYPE runType)
            {
                needsReload = false;
                manageFilters = (filterName != null);

                if (manageFilters)
                {
                    if (format_args == null)
                    {
                        PropFilter(new LuaScript(ChallengeManager.PreconfiguredLuaScripts[filterName]));
                    }
                    else
                    {
                        LuaScript temp = new LuaScript(ChallengeManager.PreconfiguredLuaScripts[filterName]);
                        temp.Script = String.Format(temp.Script, format_args);
                        PropFilter(temp);
                    }

                    Reload();
                }
            }

            /// <summary>
            /// Sets the platform type in the auth data.
            /// </summary>
            /// <param name="platform">The machine type to emulate.</param>
            protected void SetPlatformType (PlatformType platform)
            {
                RandomEx rand = new RandomEx();

                switch (platform)
                {
                    case PlatformType.Xbox:
                        qwXboxID = rand.GenerateRandomMachineId(CSGInfo.ClientType.Xbox);
                        break;

                    case PlatformType.Xenon:
                        qwXboxID = rand.GenerateRandomMachineId(CSGInfo.ClientType.Xenon);
                        break;

                    case PlatformType.Panorama:
                        qwXboxID = rand.GenerateRandomMachineId(CSGInfo.ClientType.PC);
                        break;
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncKeyexTs.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using System.Xml;

 
namespace XSGTest
{
    [TestGroup]
    public class KeyexTs : TestNode
    {

        [TestCase, Description("Sign in to LSP server using SG-style key exchange")]
            class Lsp_Keyex_Simple : TestBase_Lsp
        {
            override protected void RunTest()
            {
                ro.Debug("Keyex: {0}", lsp.Context.Site.ToString()); //SiteInfoManager.GetDefaultLspSite().ToString());
                lsp.SignInLSP();
            }
        }

        [TestCase, Description("Sign in to LSP server using SG-style key exchange")]
            class Lsp_Keyex_Simple_VerifyConnection : TestBase_Lsp
        {
            override protected void RunTest()
            {
                ro.Debug(lsp.Context.Site.ToString());
                lsp.SignInLSP();
                ro.Debug(lsp.Context.SecKeys.ToString());
                ro.Debug(lsp.Context.Authdata.ToString());
                EnsureStillSignedIn();
            }
        }

        [TestCase, Description("Sign in to LSP server using TS-style key exchange")]
            class Lsp_TsKeyex_Simple : TestBase_Lsp
        {
            override protected void RunTest()
            {
                ro.Debug("TsKeyex: {0}", lsp.Context.Site.ToString());  //SiteInfoManager.GetDefaultLspSite().ToString());
                lsp.SignInLSPWithTSKey();
            }
        }

        [TestCase, Description("Sign in to LSP server using TS-style key exchange")]
            class Lsp_TsKeyex_Simple_VerifyConnection : TestBase_Lsp
        {
            override protected void RunTest()
            {
                ro.Debug(lsp.Context.Site.ToString());
                lsp.SignInLSPWithTSKey();
                ro.Debug(lsp.Context.SecKeys.ToString());
                ro.Debug(lsp.Context.Authdata.ToString());
                EnsureStillSignedIn();
            }
        }


        [TestCase, Description("Sign in to LSP server using TS-style key exchange")]
            class Lsp_WaitForHeartbeat : TestBase_Lsp
        {
            override protected void RunTest()
            {
                System.DateTime startTime = System.DateTime.Now;

                lsp.SignInLSPWithTSKey();
                ro.Debug("Waiting 40 seconds for a heartbeat");
                SecMsgHeader hdr = sg.SecMsgRecv(40000, SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2);
                if (hdr == null)
                {
                    Fail("No pulse received in {0} ms", (System.DateTime.Now-startTime).TotalMilliseconds);
                }
                EnsureStillSignedIn();
            }
        }

        [TestCase, Description("Sign in with invalid XNKID in keyex request")]
            class Lsp_InvalidXnkid : TestBase_Lsp
        {
            override protected void RunTest()
            {
                site.tsXnKid[0]++;
                bExpectedNoReply = true;
                lsp.SignInLSPWithTSKey();
                if (IsStillSignedIn())
                {
                    Fail("We seem to still be signed in to the SG");
                }
            }
        }


    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncLuaSGHooks.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;

namespace XSGTest
{
    /// <summary>
    /// Base class for any LUA-specific tests. If a function is only relevant to LUA, it
    /// goes here. If it is relevant to the SG tests in general, it goes in
    /// TestBase_SgFake. If it is relevant to the SG itself, it goes in SgClient.
    /// </summary>
    public class TestBase_LuaSGHooks : TestBase_SgFake
    {
        #region Filter Strings

        protected static readonly string baseFilter = 
@"FilterDeclare(""{0}"")

function ApplyFilter()
{1}
end
";
        protected static readonly string versionCheck = 
@"if Spi.GetClientMajor() == {0} and Spi.GetClientMinor() == {1} and Spi.GetClientBuild() == {2} and Spi.GetClientQfe() == {3} then
{4}
end
";

        #endregion

        protected Authdata_Base        authData = null;

        protected override void InitGroup()
        {
            // Don't call the base one, we'll build a fake ticket just prior to signin so 
            // we can give the test a chance to twiddle the authdata.

            // Save a pointer to authdata to make life easier
            authData = sg.Context.Authdata;

            // Set our own custom client version that the LUA challenges or filters should 
            // target. The nnnn.nnnn.nnnn.nnnn client version is broken out like so:
            //   public ushort                   wMajorVersion;
            //   public ushort                   wMinorVersion;
            //   public ushort                   wBuildNumber;
            //   public ushort                   wQFENumber;
            authData.MajorVersion  = 0x5347;  // 'SG' in hex
            authData.MinorVersion  = 0x0003;  // 1 for LUA C/R, 2 for LUA filters, 3 for LUA hooks
            authData.BuildNumber   = 0x4A4D;  // 'JM' in hex, used by these
            authData.QFENumber     = 0x0001;  // any tests that may stomp on each other should change this!
        }

        /// <summary>
        /// Creates and props the filter with the given arguments.
        /// </summary>
        /// <param name="name">The name of the filter, must be unique within the database.</param>
        /// <param name="body">The body of the filter.</param>
        protected void PropFilter (string name, string body)
        {
            LuaScript temp = new LuaScript() { Name = name, Script = String.Format(baseFilter, name, body) };
            ChalManager.AddScript(temp, false);
        }

        /// <summary>
        /// Creates and props the filter with the given arguments.
        /// </summary>
        /// <param name="name">The name of the filter, must be unique within the database.</param>
        /// <param name="declareName">The name to declare the filter with on the SG.</param>
        /// <param name="body">The body of the filter.</param>
        protected void PropFilter (string name, string declareName, string body)
        {
            LuaScript temp = new LuaScript() { Name = name, Script = String.Format(baseFilter, declareName, body) };
            ChalManager.AddScript(temp, false);
        }

        /// <summary>
        /// Props the given filter without reloading the SG.
        /// </summary>
        /// <param name="filter">The filter to prop.</param>
        protected void PropFilter (LuaScript filter)
        {
            ChalManager.AddScript(filter, false);
        }

        /// <summary>
        /// Surrounds the given code with a version check condition.
        /// If the version does not match the auth data, the code will not be run.
        /// </summary>
        /// <param name="code">The code to surround.</param>
        /// <returns>Lua code built in the manner requested.</returns>
        protected string SurroundWithVersionCheck (string code)
        {
            return String.Format(versionCheck, authData.MajorVersion, authData.MinorVersion, authData.BuildNumber,
                authData.QFENumber, code);
        }

        /// <summary>
        /// Runs the Lua filter test.
        /// </summary>
        protected override void RunTest ()
        {
            try
            {
                SgServerInfo.ReloadChallenges();
                DoKeyExchange();
                // TODO: Add Events.TestServerForEvents for event #53902
            }
            catch
            {
                SearchLogFiles(Name);
                throw;
            }
            finally
            {
                // Don't reload post-test, the next test will reload before key exchange or teardown will reload
                // at the end of testing
                ChalManager.RemoveAllScripts(false);
            }
        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;

            // Put group-specific test verification here
            // If you do a check and need to report an error, do it like so:
            //   Fail("Test failed for title id 0x{0:X}", authData.dwTitleID);

            return true;
        }

        /// <summary>
        /// Searches the currently targeted SG log file for the given string.
        /// </summary>
        /// <param name="target">the string to search for.</param>
        public static void SearchLogFiles (string target)
        {
            try
            {
                foreach (string svr in SgServerInfo.ServerNames)
                {
                    string logPath = "\\\\" + svr +
                            "\\d$\\WEBROOT\\sgcfg\\sgtrace.log";

                    if (!File.Exists(logPath))
                    {
                        logPath = "\\\\" + svr + "\\d$\\sgtrace.log";

                        if (!File.Exists(logPath))
                        {
                            continue;
                        }
                    }

                    Global.RO.Debug("Checking for trace lines: " + logPath);

                    StreamReader reader = new StreamReader(File.Open(logPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite));
                    reader.BaseStream.Seek(0, SeekOrigin.Begin);
                    bool found = false, nextLine = false;

                    while (!reader.EndOfStream)
                    {
                        bool outputLine = false;
                        string temp = reader.ReadLine();

                        if (temp[0] != '[')
                        {
                            outputLine = true;
                        }
                        else if (temp.Contains(target.ToLower()) || temp.Contains(target))
                        {
                            outputLine = !temp.Contains("Applying filter " + target);
                            nextLine = true;
                        }
                        else if (nextLine)
                        {
                            outputLine = !temp.Contains("Applying filter");
                            nextLine = false;
                        }

                        if (outputLine)
                        {
                            if (!found)
                            {
                                Global.RO.Info("SG trace log hits for '" + target + "':");
                                found = true;
                            }
                            Global.RO.Info(temp);
                        }
                    }

                    reader.Close();
                }
            }
            catch (Exception e)
            {
                Global.RO.Warn("Attempted to search SG trace file, but encountered error: " + e.Message);
            }
        }
    }

    public class SGHooksXMLLoader : TestNode
    {
        public void BuildGroup (XmlNode groupNode)
        {
            XmlNodeList groups = groupNode.SelectNodes("sgluahookgroup");

            foreach (XmlNode node in groups)
            {
                SGHooksXMLLoader temp = new SGHooksXMLLoader();

                XmlAttribute tempAttr;

                tempAttr = node.Attributes["name"];
                if (tempAttr == null)
                {
                    Global.RO.Error("XML test group did not contain @name: " + node.ToString());
                    continue;
                }
                else
                    temp.Name = tempAttr.Value;

                AddChild(temp, true, false);
                temp.BuildGroup(node);
            }

            XmlNodeList tests = groupNode.SelectNodes("sgluahooktest");

            foreach (XmlNode node in tests)
            {
                string smallName = null, pre = null, returnList = null, func = null, paramList = null,
                    failure = null, verification = null, message = null, post = null;

                XmlAttribute tempAttr;

                tempAttr = node.Attributes["id"];
                if (tempAttr == null)
                {
                    Global.RO.Error("XML test did not contain @id: " + node.ToString());
                    continue;
                }
                else
                    smallName = tempAttr.Value;

                tempAttr = node.Attributes["pre"];
                if (tempAttr != null)
                    pre = tempAttr.Value;

                tempAttr = node.Attributes["post"];
                if (tempAttr != null)
                    post = tempAttr.Value;

                tempAttr = node.Attributes["returnList"];
                if (tempAttr != null)
                    returnList = tempAttr.Value;

                tempAttr = node.Attributes["func"];
                if (tempAttr == null)
                {
                    Global.RO.Error("XML test [" + smallName + "] did not contain @func: " + node.ToString());
                    continue;
                }
                else
                    func = tempAttr.Value;

                tempAttr = node.Attributes["paramList"];
                if (tempAttr != null)
                    paramList = tempAttr.Value;

                tempAttr = node.Attributes["failure"];
                if (tempAttr != null)
                    failure = tempAttr.Value;

                tempAttr = node.Attributes["verification"];
                if (tempAttr != null)
                    verification = tempAttr.Value;

                tempAttr = node.Attributes["message"];
                if (tempAttr != null)
                    message = tempAttr.Value;

                // Create new test from gathered values
                SgExtensions.Filter_Loader newTest = SgExtensions.Filter_Loader.Create(smallName, pre, returnList, func, paramList, failure,
                    verification, message, post);

                // Add the test to the list
                // Moved to here due to TestNode not creating func data until it is added, which would cause the
                // BugId property to throw.
                AddChild(newTest, true, false);

                tempAttr = node.Attributes["bug"];
                if (tempAttr != null)
                {
                    int temp;
                    if (int.TryParse(tempAttr.Value, out temp))
                    {
                        newTest.FunctionalData.BugID = temp;

                        tempAttr = node.Attributes["bugdb"];
                        if (tempAttr != null)
                        {
                            newTest.FunctionalData.BugDatabase = tempAttr.Value;
                        }
                    }
                    else
                    {
                        Global.RO.Warn("Could not set value '{0}' to the BugId for the test '{1}'",
                            tempAttr.Value, newTest.Name);
                    }
                }

                // Update timeout if given
                tempAttr = node.Attributes["timeout"];
                if (tempAttr != null)
                    newTest.TimeoutInMs = int.Parse(tempAttr.Value);

                // Authdata
                tempAttr = node.Attributes["versionMajor"];
                if (tempAttr != null)
                    newTest._version[0] = ushort.Parse(tempAttr.Value, NumberStyles.AllowHexSpecifier);

                tempAttr = node.Attributes["versionMinor"];
                if (tempAttr != null)
                    newTest._version[1] = ushort.Parse(tempAttr.Value, NumberStyles.AllowHexSpecifier);

                tempAttr = node.Attributes["versionBuild"];
                if (tempAttr != null)
                    newTest._version[2] = ushort.Parse(tempAttr.Value, NumberStyles.AllowHexSpecifier);

                tempAttr = node.Attributes["versionQfe"];
                if (tempAttr != null)
                    newTest._version[3] = ushort.Parse(tempAttr.Value, NumberStyles.AllowHexSpecifier);

                tempAttr = node.Attributes["titleID"];
                if (tempAttr != null)
                    newTest.dwTitleID = uint.Parse(tempAttr.Value, NumberStyles.AllowHexSpecifier);

                tempAttr = node.Attributes["titleVersion"];
                if (tempAttr != null)
                    newTest.dwTitleVersion = uint.Parse(tempAttr.Value, NumberStyles.AllowHexSpecifier);

                tempAttr = node.Attributes["platform"];
                if (tempAttr != null)
                {
                    RandomEx rand = new RandomEx();

                    if (tempAttr.Value == "Xbox")
                        newTest.qwXboxID = rand.GenerateRandomMachineId(CSGInfo.ClientType.Xbox);
                    else if (tempAttr.Value == "Xenon")
                        newTest.qwXboxID = rand.GenerateRandomMachineId(CSGInfo.ClientType.Xenon);
                    else if (tempAttr.Value == "Panorama")
                        newTest.qwXboxID = rand.GenerateRandomMachineId(CSGInfo.ClientType.PC);
                    else
                    {
                        Global.RO.Error("XML test [" + smallName + "] did had a bad value for @platform: " + node.ToString());
                        continue;
                    }
                }

                tempAttr = node.Attributes["flags"];
                if (tempAttr != null)
                    newTest.dwAuthDataFlags = uint.Parse(tempAttr.Value, NumberStyles.AllowHexSpecifier);

                tempAttr = node.Attributes["key"];
                if (tempAttr != null)
                {
                    newTest.abKey = new byte[16];
                    string temp = tempAttr.Value;

                    for (int i = 0; i < 16 && 2 * i < temp.Length; ++i)
                    {
                        newTest.abKey[i] = byte.Parse(temp.Substring(2 * i, 2), NumberStyles.AllowHexSpecifier);
                    }
                }
            }
        }
    }

    [TestCasePriority(3), TestFrequency("Regression")]
    public class SgExtensions : SGHooksXMLLoader
    {
        protected const string SGLuaHookTestXMLConfig = "Suites\\XSGTest_LuaSGHooks.xml";

        public override void PostRun (RUN_TYPE runType)
        {
            SgServerInfo.ReloadChallenges();
        }

        public SgExtensions ()
        {
            XmlDocument config = new XmlDocument();

            try
            {
                config.Load(SGLuaHookTestXMLConfig);
            }
            catch (System.IO.FileNotFoundException)
            {
                Global.RO.Warn("Unable to load LuaSGHooks tests from '" + SGLuaHookTestXMLConfig + "', most tests will be absent.");
                return;
            }

            BuildGroup(config.SelectSingleNode("//sgluahooktests"));
        }

        /// <summary>
        /// A simple class that will load a predefined filter.
        /// </summary>
        public class Filter_Loader : TestBase_LuaSGHooks
        {
            public int TimeoutInMs = 5000;

            public uint dwAuthDataFlags = 0;
            public ushort[] _version = null;
            public uint dwTitleID = 0;
            public uint dwTitleVersion = 0;
            public uint dwTitleRegion = 0;
            public ulong qwXboxID = 0;
            public byte[] abKey = null;

            protected LuaScript filter = null;

            protected Filter_Loader () { }

            /// <summary>
            /// Builds Lua code to test a specific function call.
            /// </summary>
            protected void init (string smallName, string pre, string returnList, string func, string paramList, 
                string failure, string verification, string message, string post)
            {
                // Construct Name
                Name = func + "__" + smallName;

                // Map
                // 0  : Name
                // 1  : pre
                // 2  : returnList
                // 3  : func
                // 4  : paramList
                // 5  : failure == null ? "true" : "false"
                // 6  : verification
                // 7  : verification message
                // 8  : failure == null ? "" : failure
                // 9  : paramList comma
                // 10 : post
                const string code = @"
FilterDeclare('{0}')

function ApplyFilter ()
    if Spi.GetClientMajor() == 0x5347 and Spi.GetClientMinor() == 0x0003 and Spi.GetClientBuild() == 0x4A4D and Spi.GetClientQfe() == 0x0001 then
        {1}

        local _pcallSuccessValue, _pcallFirstValueReturned, _placeholder
        local _theCallStringValue = [==[The call '{3}({4})']==]

        _pcallSuccessValue, _pcallFirstValueReturned, {2} = pcall({3}{9}{4})

        if {5} then
            if _pcallSuccessValue then
                {2} = _pcallFirstValueReturned, {2}

                {10}

                _pcallSuccessValue = ({6})

                if not _pcallSuccessValue then
                    trace(_theCallStringValue..' did not pass verification.  Message: '..tostring({7}))
                end
            else
                trace(_theCallStringValue..' failed to execute.  Error: '..tostring(_pcallFirstValueReturned))
            end
        else
            _pcallSuccessValue = not _pcallSuccessValue

            if _pcallSuccessValue then
                local _expectedErrorString = [==[{8}]==]

                if _pcallFirstValueReturned ~= _expectedErrorString then
                    _pcallSuccessValue = false
                    trace(_theCallStringValue..' did not return the expected error.\nExpected Error: '.._expectedErrorString..'\nReceived Error: '..tostring(_pcallFirstValueReturned))
                end
            else
                trace(_theCallStringValue..' was successful when an error was expected.')
            end
        end

        if not _pcallSuccessValue then
            Filter.Block()
        end
    end
end
                ";

                filter = new LuaScript()
                {
                    Name = Name,
                    Script = String.Format(code, Name, (pre == null ? "" : pre),
                        (returnList == null || returnList == "" ? "_placeholder" : returnList), func,
                        (paramList == null ? "" : paramList), (failure == null ? "true" : "false"),
                        (verification == null || verification == "" ? "true" : verification),
                        (message == null || message == "" ? "'[No Message]'" : message),
                        (failure == null ? "" : failure),
                        (paramList == null || paramList == "" ? "" : ", "),
                        (post == null ? "" : post))
                };
            }

            protected override void InitTest ()
            {
                if (dwAuthDataFlags != 0)
                {
                    authData.AuthDataFlags = dwAuthDataFlags;
                }

                if (qwXboxID != 0)
                {
                    authData.XboxID = qwXboxID;
                }

                if (_version != null)
                {
                    authData.MajorVersion = _version[0];
                    authData.MinorVersion = _version[1];
                    authData.BuildNumber = _version[2];
                    authData.QFENumber = _version[3];
                }

                if (dwTitleID != 0)
                {
                    authData.TitleId = dwTitleID;
                }

                if (dwTitleVersion != 0)
                {
                    authData.TitleVersion = dwTitleVersion;
                }

                if (abKey != null)
                {
                    authData.Key = abKey;
                }

                sg.TimeoutInMs = TimeoutInMs;

                try
                {
                    PropFilter(filter);
                }
                catch
                {
                    Global.RO.Debug("Lua propped for : " + Name + "\n" + filter.Script);
                    throw;
                }
            }

            protected override void RunTest ()
            {
                try
                {
                    base.RunTest();
                }
                catch
                {
                    Global.RO.Debug("Lua propped for : " + Name + "\n" + filter.Script);
                    throw;
                }
            }

            public static Filter_Loader Create (string smallName, string pre, string returnList, string func, 
                string paramList, string failure, string verification, string message, string post)
            {
                Filter_Loader filter = new Filter_Loader();
                filter.init(smallName, pre, returnList, func, paramList, failure, verification, message, post);
                return filter;
            }
        }

        /// <summary>
        /// Tests the Chal. functions.
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class SyncChalTests : TestBase_Lua
        {
            protected override void  InitTest()
            {
                authData.MajorVersion  = 0x5347;  // 'SG' in hex
                authData.MinorVersion  = 0x0003;  // 1 for LUA C/R, 2 for LUA filters, 3 for LUA hooks
                authData.BuildNumber   = 0x4A4D;  // 'JM' in hex, used by these
                authData.QFENumber     = 0x0001;  // any tests that may stomp on each other should change this!

                luaChal = ChallengeManager.PreconfiguredLuaScripts["SG Hooks Sync Challenge"];
            }

            protected override void RunLuaTest ()
            {
                SignIn(true);
                if ((sgChal.Params[0] & 0x01) != 0)
                {
                    Fail("Chal.AsyncMode returned true during a sync challenge");
                }

                if ((sgChal.Params[0] & 0x02) != 0)
                {
                    Fail("Chal.SyncMode returned false during a sync challenge");
                }

                if ((sgChal.Params[0] & 0x04) != 0)
                {
                    TestBase_LuaSGHooks.SearchLogFiles("Chal.GetId");
                    Fail("Chal.GetId returned a different number than the one just set");
                }

                if ((sgChal.Params[0] & 0x08) != 0)
                {
                    TestBase_LuaSGHooks.SearchLogFiles("Chal.GetParamId");
                    Fail("Chal.GetParamId returned a different number than the one just set");
                }
                
                SendChallengeResponse("00", true);
            }
        }

        /// <summary>
        /// Tests the Chal. functions.
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class AsyncChalTests : TestBase_AsyncLua
        {
            int chalNumber = 0;

            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.MajorVersion  = 0x5347;  // 'SG' in hex
                authData.MinorVersion  = 0x0003;  // 1 for LUA C/R, 2 for LUA filters, 3 for LUA hooks
                authData.BuildNumber   = 0x4A4D;  // 'JM' in hex, used by these
                authData.QFENumber     = 0x0100;  // any tests that may stomp on each other should change this!

                chalNumber = 0;

                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["SG Hooks Async Challenge"]);
            }

            protected override void HandleChallenge (SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal == null)
                {
                    Fail("Expecting to receive another challenge.");
                    return;
                }

                if (chalNumber == 0)
                {
                    if ((chal.Params[0] & 0x01) != 0)
                    {
                        Fail("Chal.AsyncMode returned false during an async challenge");
                    }

                    if ((chal.Params[0] & 0x02) != 0)
                    {
                        Fail("Chal.SyncMode returned true during an async challenge");
                    }

                    if ((chal.Params[0] & 0x04) != 0)
                    {
                        Fail("This should never happen");
                    }

                    waitForAnotherChallenge = true;
                    SendChallengeResponse(new byte[1024]);
                }
                else if (chalNumber == 1)
                {
                    if ((chal.Params[0] & 0x01) != 0)
                    {
                        Fail("Chal.AsyncMode returned false during an async challenge");
                    }

                    if ((chal.Params[0] & 0x02) != 0)
                    {
                        Fail("Chal.SyncMode returned true during an async challenge");
                    }

                    if ((chal.Params[0] & 0x04) == 0)
                    {
                        Fail("Spi storage lost between async calls");
                    }
                    
                    waitForAnotherChallenge = true;
                    SendChallengeResponse(new byte[1024]);
                    System.Threading.Thread.Sleep(5000);
                    SgServerInfo.ReloadChallenges();
                }
                else if (chalNumber == 2)
                {
                    if ((chal.Params[0] & 0x01) != 0)
                    {
                        Fail("Chal.AsyncMode returned false during an async challenge");
                    }

                    if ((chal.Params[0] & 0x02) != 0)
                    {
                        Fail("Chal.SyncMode returned true during an async challenge");
                    }

                    if ((chal.Params[0] & 0x04) == 0)
                    {
                        Global.RO.Warn("A reload seems to have hosed the Spi storage, this was somewhat expected");
                    }

                    waitForAnotherChallenge = false;
                    SendChallengeResponse(new byte[1024]);
                }

                ++chalNumber;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncLuaChal.cs ===
using System;
using System.Threading;

using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XSGTest
{
    [TestCasePriority(1), TestFrequency("Regression")]
    class LuaChal : TestNode_LuaScriptGroup
    {
        public LuaChal ()
        {
            AddScript("LuaChallengeEnhancements");
        }

        // Challenge Timers
        /// <summary>The time it takes for the SG to process every connection for timed events.</summary>
        public static int ScanTimeInSeconds;
        /// <summary>The time between challenges.</summary>
        public static int PeriodInSeconds;
        /// <summary>The time that the client is given to acknowledge a challenge.</summary>
        public static int AckTimeoutInSeconds;
        /// <summary>The time that the client is given to respond to a challenge.</summary>
        public static int ResponseTimeoutInSeconds;
        /// <summary>The heartbeat timer period.</summary>
        public static int HeartbeatInSeconds;

        public override void PreRun (RUN_TYPE runType)
        {
            base.PreRun(runType);

            ScanTimeInSeconds = Global.XEnv.GetIntSetting(Setting.sg_SgToXbScanFrequencyInSeconds);
            PeriodInSeconds = Global.XEnv.GetIntSetting(Setting.sg_SgToXbChallengePeriodInSeconds);
            AckTimeoutInSeconds = Global.XEnv.GetIntSetting(Setting.sg_XbToSgChallengeAckInSeconds);
            ResponseTimeoutInSeconds = Global.XEnv.GetIntSetting(Setting.sg_XbToSgChallengeTimeoutInSeconds);
            HeartbeatInSeconds = Global.XEnv.GetIntSetting(Setting.sg_ChalHeartbeatTimeoutInSeconds);
        }

        /// <summary>
        /// Simple base class to set up the client version to enable tests.
        /// </summary>
        public class TestBase_LuaChal : TestBase_SgFake
        {
            protected Authdata_Base authdata;

            protected override void InitGroup ()
            {
                authdata = sg.Context.Authdata;

                authdata.MajorVersion = 0x5347;  // 'SG' in hex
                authdata.MinorVersion = 0x0010;  // Group specific number
                authdata.BuildNumber = 0x4A4D;   // 'JM' in hex
                authdata.QFENumber = 0;
            }

            protected KeyExchangeSgToXbChallenge Chal
            {
                get
                {
                    if (sg.KeyexResult == null)
                    {
                        throw new InvalidOperationException("We don't seem to have signed in.");
                    }

                    return sg.KeyexResult.keyexChal;
                }
            }

            protected KeyExchangeSgToXbChallenge ChalRequire
            {
                get
                {
                    KeyExchangeSgToXbChallenge ans = Chal;
                    if (ans == null)
                    {
                        throw new SGException("We did not get a sync challenge and it is required.");
                    }
                    return ans;
                }
            }

            public override void PostRun (RUN_TYPE runType)
            {
                sg.SignOutSG();
            }

            /// <summary>
            /// Pulls the string response out of a challenge buffer.
            /// </summary>
            public static string DecodeChalResponse (byte[] buffer)
            {
                // find the null byte
                int end = buffer.Length;
                for (int i = 0; i < buffer.Length; ++i)
                {
                    if (buffer[i] == 0)
                    {
                        end = i;
                        break;
                    }
                }

                return ByteEncoding.Instance.GetString(buffer, 0, end);
            }
        }

        [TestCase, Description("Signs in without any knowledge of the challenges, should work unless things are very bad.")]
        public class Mainline : TestBase_LuaChal
        {
            protected override void RunTest ()
            {
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = Chal;

                if (chal != null)
                {
                    throw new UnexpectedTestResultException("We should not have been challenged.");
                }
            }
        }

        [TestCase, Description("Checks the pulse of the SG chal code by signing in twice over its interval.")]
        public class Heartbeat : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0001;
            }

            protected override void RunTest ()
            {
                // first time to get a baseline
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;
                sg.SignOutSG();
                
                // get values
                int controller_count = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("Before Sleep :: Controller : {0} :: Challenge : {1}", 
                    controller_count, challenge_count);

                // sleeeeeep
                Thread.Sleep((HeartbeatInSeconds * 3000) / 2);

                // and again
                DoKeyExchange();
                chal = ChalRequire;
                sg.SignOutSG();

                int controller_count_after = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count_after = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("After Sleep  :: Controller : {0} :: Challenge : {1}", 
                    controller_count_after, challenge_count_after);

                controller_count_after -= controller_count;
                challenge_count_after -= challenge_count;

                // it should be 1 or 2, depending on our luck
                if (controller_count_after > 2 || controller_count_after < 1)
                {
                    throw new SGException("Controller heartbeat is out of range (difference): " + 
                        controller_count_after.ToString());
                }

                if (challenge_count_after > 2 || challenge_count_after < 1)
                {
                    throw new SGException("Challenge heartbeat is out of range (difference): " +
                        challenge_count_after.ToString());
                }
            }
        }

        [TestCase, Description("Checks that the no Spi is attached during the heartbeat.")]
        public class SpiInHeartbeat : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0002;
            }

            protected override void RunTest ()
            {
                KeyExchangeSgToXbChallenge chal = null;

                for (int i = 0; i < 7; ++i)
                {
                    DoKeyExchange();
                    chal = ChalRequire;
                    sg.SignOutSG();

                    // 2 means that the heartbeat hasn't run yet
                    if (chal.Params[0] != 2)
                    {
                        break;
                    }

                    Thread.Sleep(HeartbeatInSeconds * 1000);
                }

                if (chal.Params[0] == 1)
                {
                    // woots, Spi not available
                    return;
                }
                else if (chal.Params[0] == 0)
                {
                    throw new SGException("Spi was available in the heartbeat, or error was not the expected one: " + 
                        DecodeChalResponse(chal.PkSig));
                }
                else if (chal.Params[0] == 2)
                {
                    throw new SGException("Heartbeat doesn't seem to be running");
                }
                else
                {
                    throw new UnexpectedTestResultException("Got an unexpected return value: " +
                        chal.Params[0].ToString());
                }
            }
        }

        [TestCase, Description("Check for the event generated by a heartbeat error.")]
        public class HeartbeatErrorEvent : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0003;
            }

            protected override void RunTest ()
            {
                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                // connect
                DoKeyExchange();
                // don't need it, just make sure we have it
                KeyExchangeSgToXbChallenge chal = ChalRequire;
                sg.SignOutSG();

                // check for event
                for (int i = 0; i < 7; ++i)
                {
                    // event contains this string
                    if (events.TestForChange("Requested heartbeat error"))
                    {
                        return;
                    }

                    Thread.Sleep(HeartbeatInSeconds * 1000);
                }

                throw new SGException("Heartbeat doesn't seem to be running");
            }
        }

        [TestCase, Description("Check that the ChallengeDropped function is not called when a response is sent back.")]
        public class ChalDroppedWithResponse : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0004;
            }

            protected override void RunTest ()
            {
                // first time to get a baseline, send a response this time
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;
                SendKeyexChalResponse((byte[])null);

                // get values
                int controller_count = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("Before Sleep :: Controller : {0} :: Challenge : {1}",
                    controller_count, challenge_count);

                // sleeeeeep
                Thread.Sleep(36000);

                sg.SignOutSG();

                // and again
                DoKeyExchange();
                chal = ChalRequire;
                sg.SignOutSG();

                int controller_count_after = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count_after = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("After Sleep  :: Controller : {0} :: Challenge : {1}",
                    controller_count_after, challenge_count_after);

                // these should match because we sent a response
                if (controller_count_after != controller_count)
                {
                    throw new SGException("Controller ChallengeDropped was called: {0} -> {1}", 
                        controller_count, controller_count_after);
                }

                if (challenge_count_after != challenge_count)
                {
                    throw new SGException("Challenge ChallengeDropped was called: {0} -> {1}",
                        challenge_count, challenge_count_after);
                }
            }
        }

        [TestCase, Description("Check that the ChallengeDropped function is called when the client logs immediately.")]
        public class ChalDroppedWithDelete : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0004;
            }

            protected override void RunTest ()
            {
                // first time to get a baseline
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;
                sg.SignOutSG();

                // get values
                int controller_count = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("Before Sleep :: Controller : {0} :: Challenge : {1}",
                    controller_count, challenge_count);

                // sleeeeeep
                Thread.Sleep(36000);

                // and again
                DoKeyExchange();
                chal = ChalRequire;
                sg.SignOutSG();

                int controller_count_after = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count_after = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("After Sleep  :: Controller : {0} :: Challenge : {1}",
                    controller_count_after, challenge_count_after);

                controller_count_after -= controller_count;
                challenge_count_after -= challenge_count;

                // the drop should be called once because we tried to be sneaky
                if (controller_count_after != 1)
                {
                    throw new SGException("Controller ChallengeDropped was not called exactly once: {0} -> {1}",
                        controller_count, controller_count_after);
                }

                if (challenge_count_after != 0)
                {
                    throw new SGException("Challenge ChallengeDropped was called: {0} -> {1}",
                        challenge_count, challenge_count_after);
                }
            }
        }

        [TestCase, Description("Send multiple delete SecMsgs to see if ChallengeDropped is called multiple times.")]
        public class ChalDroppedWithDoubleDelete : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0004;
            }

            protected override void RunTest ()
            {
                // first time to get a baseline
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;

                // double delete messages
                sg.SendDelete();
                sg.SendDelete();
                // this just clears the state, shouldn't actually send a delete (although if it does thats fine)
                sg.SignOutSG();

                // get values
                int controller_count = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("Before Sleep :: Controller : {0} :: Challenge : {1}",
                    controller_count, challenge_count);

                // sleeeeeep
                Thread.Sleep(36000);

                // and again
                DoKeyExchange();
                chal = ChalRequire;
                sg.SignOutSG();

                int controller_count_after = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count_after = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("After Sleep  :: Controller : {0} :: Challenge : {1}",
                    controller_count_after, challenge_count_after);

                controller_count_after -= controller_count;
                challenge_count_after -= challenge_count;

                // the drop should be called once because we tried to be sneaky
                if (controller_count_after != 1)
                {
                    throw new KnownBugException(38627, "TFS: ISS All (IEB)",
                        new SGException("Controller ChallengeDropped was not called exactly once: {0} -> {1}",
                            controller_count, controller_count_after));
                    //throw new SGException("Controller ChallengeDropped was not called exactly once: {0} -> {1}",
                    //    controller_count, controller_count_after);
                }

                if (challenge_count_after != 0)
                {
                    throw new SGException("Challenge ChallengeDropped was called: {0} -> {1}",
                        challenge_count, challenge_count_after);
                }
            }
        }

        [TestCase, Description("Check that the ChallengeDropped function is called when the client does not respond to the challenge.")]
        public class ChalDroppedNoResponse : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0004;
            }

            protected override void RunTest ()
            {
                // first time to get a baseline
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;

                // get values
                int controller_count = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("Before Sleep :: Controller : {0} :: Challenge : {1}",
                    controller_count, challenge_count);

                // sleeeeeep
                Thread.Sleep(36000);

                // and again
                DoKeyExchange();
                chal = ChalRequire;
                sg.SignOutSG();

                int controller_count_after = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count_after = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("After Sleep  :: Controller : {0} :: Challenge : {1}",
                    controller_count_after, challenge_count_after);

                if (controller_count_after != controller_count + 1)
                {
                    throw new SGException("Controller ChallengeDropped was NOT called: {0} -> {1}",
                        controller_count, controller_count_after);
                }

                if (challenge_count_after != challenge_count)
                {
                    throw new SGException("Challenge ChallengeDropped was called: {0} -> {1}",
                        challenge_count, challenge_count_after);
                }
            }
        }

        [TestCase, Description("Check that the ChallengeDropped function is not called when the client does not respond but was not challenged.")]
        public class ChalDroppedNoResponseNoChallenge : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0004;
            }

            protected override void RunTest ()
            {
                // first time to get a baseline
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;
                SendKeyexChalResponse((byte[])null);
                sg.SignOutSG();

                // get values
                int controller_count = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("Before Sleep :: Controller : {0} :: Challenge : {1}",
                    controller_count, challenge_count);

                // sleeeeeep
                Thread.Sleep(2000);

                // now again to not get challenged but not respond
                authdata.QFENumber = 0;

                DoKeyExchange();
                chal = Chal;

                if (chal != null)
                {
                    throw new UnexpectedTestResultException("We should not have been challenged.");
                }

                Thread.Sleep(36000);
                sg.SignOutSG();

                // and again
                authdata.QFENumber = 0x0004;

                DoKeyExchange();
                chal = ChalRequire;
                sg.SignOutSG();

                int controller_count_after = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count_after = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("After Sleep  :: Controller : {0} :: Challenge : {1}",
                    controller_count_after, challenge_count_after);

                if (controller_count_after != controller_count)
                {
                    throw new SGException("Controller ChallengeDropped was called: {0} -> {1}",
                        controller_count, controller_count_after);
                }

                if (challenge_count_after != challenge_count)
                {
                    throw new SGException("Challenge ChallengeDropped was called: {0} -> {1}",
                        challenge_count, challenge_count_after);
                }
            }
        }

        [TestCase, Description("Check that the ChallengeDropped function is not called when the client does not respond (at all!) but was not challenged.")]
        public class ChalDroppedNoResponseNoChallengeNoPulse : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0004;
            }

            protected override void RunTest ()
            {
                // first time to get a baseline
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;
                SendKeyexChalResponse((byte[])null);
                sg.SignOutSG();

                // get values
                int controller_count = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("Before Sleep :: Controller : {0} :: Challenge : {1}",
                    controller_count, challenge_count);

                // sleeeeeep
                Thread.Sleep(2000);

                // now again to not get challenged but not respond
                authdata.QFENumber = 0;
                sg.SendPulseAfterSignIn = false;

                DoKeyExchange();
                chal = Chal;

                if (chal != null)
                {
                    throw new UnexpectedTestResultException("We should not have been challenged.");
                }

                Thread.Sleep(36000);
                sg.SignOutSG();

                // and again
                authdata.QFENumber = 0x0004;
                sg.SendPulseAfterSignIn = true;

                DoKeyExchange();
                chal = ChalRequire;
                sg.SignOutSG();

                int controller_count_after = BitConverter.ToInt32(chal.Params, 0);
                int challenge_count_after = BitConverter.ToInt32(chal.Params, 4);

                ro.Debug("After Sleep  :: Controller : {0} :: Challenge : {1}",
                    controller_count_after, challenge_count_after);

                if (controller_count_after != controller_count)
                {
                    throw new SGException("Controller ChallengeDropped was called: {0} -> {1}",
                        controller_count, controller_count_after);
                }

                if (challenge_count_after != challenge_count)
                {
                    throw new SGException("Challenge ChallengeDropped was called: {0} -> {1}",
                        challenge_count, challenge_count_after);
                }
            }
        }

        [TestCase, Description("Check for the ChallengeDropped event on an error.")]
        public class ChalDroppedErrorEvent : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0005;
            }

            protected override void RunTest ()
            {
                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                // first time to get a baseline
                DoKeyExchange();
                KeyExchangeSgToXbChallenge chal = ChalRequire;

                // sleeeeeep
                Thread.Sleep(36000);

                // check for the event
                if (!events.TestForChange("Requested challenge drop error"))
                {
                    throw new SGException("Expected an event due to a ChallengeDropped error.");
                }
            }
        }

        [TestCase, Description("Test Kicking from the Target function.")]
        public class KickFromTarget : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0006;
            }

            protected override void RunTest ()
            {
                try
                {
                    DoKeyExchange();
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    ro.Debug("Keyex timed out as expected.");
                }
            }
        }

        [TestCase, Description("Checks that clients are always being mapped to the same lua state.")]
        public class LuaStateMapping : TestBase_LuaChal
        {
            protected override void InitTest ()
            {
                authdata.QFENumber = 0x0007;
            }

            protected override void RunTest ()
            {
                // number of machines to try
                int machine_count = 27;

                ulong[] machines = new ulong[machine_count];

                for (int i = 0; i < machine_count; ++i)
                {
                restart_loop:
                    authdata.XboxID = (SgClient.rand.NextUlong() & SgClient.k_CounterPuidMask) | SgClient.k_XenonMachinePuidMask;
                    machines[i] = authdata.XboxID;

                    DoKeyExchange();
                    KeyExchangeSgToXbChallenge chal = ChalRequire;
                    sg.SignOutSG();

                    if (chal.Params[0] == 0)
                    {
                        // good state
                    }
                    else if (chal.Params[0] == 1)
                    {
                        // somehow we hit a machine that was already there, try this round again
                        goto restart_loop;
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("Got an unexpected value back from the challenge: " + 
                            chal.Params[0].ToString());
                    }
                }

                // wait a few seconds to make sure we can sign in again
                Thread.Sleep(2000);

                for (int i = 0; i < machine_count; ++i)
                {
                    authdata.XboxID = machines[i];

                    DoKeyExchange();
                    KeyExchangeSgToXbChallenge chal = ChalRequire;
                    sg.SignOutSG();

                    if (chal.Params[0] == 0)
                    {
                        throw new SGException("We were not mapped to the same lua state: " + 
                            machines[i].ToString("X16"));
                    }
                    else if (chal.Params[0] == 1)
                    {
                        // good state
                        ro.Debug("Lua state remembers us: " + machines[i].ToString("X16"));
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("Got an unexpected value back from the challenge: " +
                            chal.Params[0].ToString());
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncLuaSpiSeq.cs ===
//tests of the spi storage, and using that storage to do challenge sequencing
//note: sync tests use TestBase_Lua as a base (FuncLua.cs), async tests use TestBase_AsyncLua (FuncSecmsgChalResp_Lua.cs)

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XSGTest
{

    [Description("Lua SPI.GetStorage() tests"), TestFrequency("Regression")]
    public class SpiStorage : TestNode
    {

        [TestCase, Description("dead simple test to make sure Spi.GetStorage() even works")]
        class DeadSimpleSPIStorage : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=67;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SpiDeadSimple"];
                SignIn(true);
                if (sgChal.Params[0]!=0x11)
                {
                    Fail("Dead simple spi storage isn't working");
                }
            }
        }

        [TestCase, Description("set data in __Target and make sure it's still there in __Analyze")]
        class SimpleSPIStorage : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=67;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SpiSimple"];
                SignIn(true);
                SendChallengeResponse("0xc00c00",true); //disconnects us on check failure in __Analyze
            }
        }

        [TestCase, TestCasePriority(3), Description("store a lot of data in __Target then check it in __Analyze")]
        class SPIStorageLots : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=67;
                sg.TimeoutInMs=30000; //give it 30s.. this will take a moment to run.. or will once this field works right

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_StoreALot"];
                SignIn(true);
                SendChallengeResponse("0xc00c00",true); //disconnects us on check failure in __Analyze
            }
        }

        [TestCase,Description("run one script and set spi data in __Target, then login as another user and make sure we can't access that")]
        //main test that logs in first user
        class SpiStorageSeperateUsersNoAccess: TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=67;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaA_StoreCheckAccess0"]);
                System.Threading.Thread.Sleep(1000);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaA_StoreCheckAccess1"]);
            }
            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Did not get challenged");
                }

                //make the other client to check the value
                CheckSpiStore client2=new CheckSpiStore();
                client2.Execute();
            }

            //helper 2nd test and user that checks that the data can't be accessed
            private class CheckSpiStore: SpiStorageSeperateUsersNoAccess
            {
                protected override void PreloginSetup (Authdata_Base authData)
                {
                    authData.QFENumber=677;
                }
                protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
                {
                    //challenges us if it could "not" access the other's data
                    if (chal==null)
                    {
                        throw new SgTestException("Either we COULD access the other's data (BAD), or some kinda script error..");
                    }
                }
            }
        }

        [TestCase,Description("sequence several challenges in a row, remembering something between each one")]
        class SimpleSequence : TestBase_AsyncLua
        {
            private uint seqNum=1; //which step in sequence we're waiting on... corresponds with Spi.GetStorage().SeqNum in lua script

            protected override void PreloginSetup (Authdata_Base authData)
            {
                seqNum=1;
                authData.QFENumber=67;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaA_SimpleSequence"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (seqNum==4)//should be the last step, no challenge
                {
                    if (chal!=null) Fail("got challenge on sequence number "+seqNum);
                    return;
                }

                //first 3 steps we should be challenged.. make sure the param has the seq number that was passed to us
                if (chal==null)
                {
                    throw new SgTestException("Did not get challenged");
                }
                else if (chal.Params[15] != seqNum)
                {
                    throw new SgTestException("Bad challenge param returned from script, on seq number "+seqNum);
                }
                
                //respond.. which increments Spi.GetStorage().SeqNum in script.. then wait for another challenge
                SendChallengeResponse(new byte[1024]);
                if (!WaitAndCheckConnected(0)) throw new SgTestException("got disconnected by sg.. how dare it!");

                ++seqNum;
                waitForAnotherChallenge=true;
                ro.Debug("finished sequence number "+(seqNum-1));
            }
        }

        [TestCase,Description("run this ONLY AFTER you run SimpleSequence.  it checks that the state was not 'saved' between session.")]
        class SimpleSequence_VERIFY : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=67;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaA_SimpleSequence_Verify"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null) //it will challenge us if the spi value is nil as it should be
                {
                    throw new SgTestException("no challenge, means that the SPI storage info was saved between logins, but it SHOULD NOT have been.");
                }
            }
        }

        [TestCase,Description("sequence several challenges in a row, using different lua scripts")]
        class SequenceMultiple : TestBase_AsyncLua
        {
            private uint seqNum=0; //which step in sequence we're on... corresponds to which script # that should reply (byte 1 of param)

            protected override void PreloginSetup (Authdata_Base authData)
            {
                seqNum=0;
                authData.QFENumber=67;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaA_SequenceMult1"]);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaA_SequenceMult2"]);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaA_SequenceMult0"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Did not get challenged");
                }

                //check response to first 3 in sequence
                if (chal.Params[0]!=seqNum)
                {
                    throw new SgTestException("challenged by wrong one in sequence");
                }

                //for final sequence and report total number of targets for referance (last 4 bytes)
                if (seqNum==2)
                {
                    byte []grrEndian=new byte[4]{chal.Params[15],chal.Params[14],chal.Params[13],chal.Params[12]};

                    uint tars=System.BitConverter.ToUInt32(grrEndian,0);
                    ro.Debug("note: total number of __Target calls: "+tars);
                }
                
                //respond and make sure we're still connected, then wait on another challenge
                byte []b=new byte[1024];
                b[0]=0xff;
                SendChallengeResponse(b);
                if (!WaitAndCheckConnected(0)) throw new SgTestException("got disconnected by sg.. how dare it!");
                ro.Debug("finished sequence number "+seqNum);
                if (seqNum<2)
                {
                    waitForAnotherChallenge=true;
                }
                ++seqNum;
            }
        }
    }

} //namespace XSGTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncLuaRuntime.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XSGTest
{
    [TestCasePriority(3), TestFrequency("Regression")]
    public class LuaRuntime : TestNode
    {
        [TestGroup, Ignore]
        public class LargeStructures : TestNode
        {
            [TestCase]
            [CompoundCase("100", 100)]
            [CompoundCase("1000", 1000)]
            [CompoundCase("5000", 5000)]
            [CompoundCase("10000", 10000)]
            [CompoundCase("20000", 20000)]
            [CompoundCase("50000", 50000)]
            [CompoundCase("100000", 100000)]
            public class SimpleTable : LargeLuaTableTestBase
            {
                public SimpleTable () { Type = TableType.Simple; }
            }

            [TestCase]
            [CompoundCase("100", 100)]
            [CompoundCase("1000", 1000)]
            [CompoundCase("5000", 5000)]
            [CompoundCase("10000", 10000)]
            [CompoundCase("20000", 20000)]
            [CompoundCase("50000", 50000)]
            [CompoundCase("100000", 100000)]
            public class NestedTable : LargeLuaTableTestBase
            {
                public NestedTable () { Type = TableType.Nested; }
            }

            [TestCase]
            [CompoundCase("100", 100)]
            [CompoundCase("1000", 1000)]
            [CompoundCase("5000", 5000)]
            [CompoundCase("10000", 10000)]
            [CompoundCase("20000", 20000)]
            [CompoundCase("50000", 50000)]
            [CompoundCase("100000", 100000)]
            public class NestedTableWithAnswers : LargeLuaTableTestBase
            {
                public NestedTableWithAnswers () { Type = TableType.NestedWithAnswers; }
            }

            public override void PostRun (RUN_TYPE runType)
            {
                SgServerInfo.ReloadChallenges();
            }
        }
    }

    /// <summary>
    /// A test base for creating large lua tables in challenges.
    /// </summary>
    public class LargeLuaTableTestBase : TestNode_LuaScriptGroup
    {
        /// <summary>The table type to create.</summary>
        public enum TableType { Simple, Nested, NestedWithAnswers }

        public TableType Type;

        /// <summary>Our lua challenge object, constructed the first time we run.</summary>
        public LuaScript Chal = null;

        public LargeLuaTableTestBase ()
        {
            DoPostRunReload = false;
        }

        /// <summary>
        /// Main challenge body.
        /// </summary>
        /// <remarks>
        /// 0 - Table of questions/answers.
        /// 1 - The part after 'QuestionsAndAnswers[param]' to get a question
        /// 2 - The part after 'QuestionsAndAnswers[param]' to get an answer
        /// </remarks>
        private const string MainChallengeBody = @"
ChallengeDeclare(0x4567, 'Challenge 0x4567', true, false, false)

__Binary = Buffer.new(
'BDFBB9D4E177EF4D7229F7F332C88E99289B67C1A9DF2B0352C97B629B630749'..
'7C3217747070E451DD105AD83EF8962982F469064ED0F6B6176FB7E5BCAA6D18'..
'0BCDDDBD044A13BB759810EC0C78F6851CE78FE4D4E6057119C695A8B9AFCA41'..
'6737D013B2BC21AFC0B133081F9F390D7E5FCD3EF560910DBF29185C36DC70C1'..
'A84A6AAFB0A52B30C1F597277B1738D72D3BB49DB1CE2CC078CD5541297995E9'..
'FA7329466F463B88513B1F7A3D84697166692A5A3EA9D4BFF8FE9F837682B36B'..
'372D93AEFFB25D4E9C93048573C4A9CEDAC876EBDB1DA5236D004BB709C328D7'..
'06D65F259198224AA989E7D233D046917CEE82A6FDA981019400661F4317CBE5'..
'0001011000020001'
)

-- List of Questions and Answers 
QuestionsAndAnswers = {0}

-- Targetting Function Entry Point
function __Target()

    -- build 2858 or later only
    if Spi.GetClientMajor() ~= 0x5347 or Spi.GetClientMinor() ~= 0x0011 or Spi.GetClientBuild() ~= 0x4A4D or Spi.GetClientQfe() ~= 0 then
        return false
    end
    
    -- Randomly select one of the parameters in the question array
    local param
    
    param = math.random(1, #QuestionsAndAnswers)
    
    -- Copy into the Global Params Buffer the 16 relevant bytes
    local parambuffer = QuestionsAndAnswers[param]{1};
    
    Chal.SetParam(parambuffer)
    
    -- return found
    return true
end

-- Analyze Function Entry Point
function __Analyze(buffer)
    -- Randomly select one of the parameters in the question array
    local param
    
    param = math.random(1, #QuestionsAndAnswers)
    
    -- Copy into the Global Params Buffer the 16 relevant bytes
    local parambuffer = QuestionsAndAnswers[param]{2};
    
    trace(tostring(parambuffer))
end
";

        public override void PreRun (RUN_TYPE runType)
        {
            // create the challenge
            if (Chal == null)
            {
                // get this
                int count = (int)MyValues[0];

                // random bytes generator
                Random rand = new Random();
                byte[] question = new byte[16];
                byte[] answer = new byte[20];

                // format replacers
                string question_format = null;
                string answer_format = null;

                // construct the table
                System.Text.StringBuilder buff = new System.Text.StringBuilder(count * 36);

                buff.Append('{');

                switch (Type)
                {
                    case TableType.Simple:
                        question_format = "";
                        answer_format = "";

                        for (int i = 0; i < count; ++i)
                        {
                            rand.NextBytes(question);

                            if (i != 0) { buff.AppendLine(","); }
                            buff.Append("Buffer.new('");
                            buff.Append(Hexer.tohex(question));
                            buff.Append("')");
                        }
                        break;

                    case TableType.Nested:
                        question_format = ".q";
                        answer_format = ".q";

                        for (int i = 0; i < count; ++i)
                        {
                            rand.NextBytes(question);

                            if (i != 0) { buff.AppendLine(","); }
                            buff.Append("{ q = Buffer.new('");
                            buff.Append(Hexer.tohex(question));
                            buff.Append("') }");
                        }
                        break;

                    case TableType.NestedWithAnswers:
                        question_format = ".q";
                        answer_format = ".a";

                        for (int i = 0; i < count; ++i)
                        {
                            rand.NextBytes(question);
                            rand.NextBytes(answer);

                            if (i != 0) { buff.AppendLine(","); }
                            buff.Append("{ q = Buffer.new('");
                            buff.Append(Hexer.tohex(question));
                            buff.Append("'), a = Buffer.new('");
                            buff.Append(Hexer.tohex(answer));
                            buff.Append("') }");
                        }
                        break;
                }

                buff.Append('}');

                Chal = new LuaScript()
                {
                    Name = "Challenge: " + FullName,
                    Script = string.Format(MainChallengeBody, buff.ToString(), question_format, answer_format)
                };
            }

            AddScript(Chal);

            DateTime before_reload = DateTime.UtcNow;
            base.PreRun(runType);
            DateTime after_reload = DateTime.UtcNow;
            Global.RO.Info("Took this long to reload: " + (after_reload - before_reload).ToString());
        }

        public override void PostRun (RUN_TYPE runType)
        {
            base.PostRun(runType);

            // unfortunately we have to do this because we are using compound case which only makes one object per
            // should make a lua script test case base
            LuaScripts.Remove(Chal);
        }

        protected override void InitGroup ()
        {
            Authdata_Base authdata = sg.Context.Authdata;

            authdata.MajorVersion = 0x5347;  // 'SG' in hex
            authdata.MinorVersion = 0x0011;  // Group specific number
            authdata.BuildNumber = 0x4A4D;   // 'JM' in hex
        }

        /// <summary>
        /// Here we need to check a few things.
        /// </summary>
        protected override void RunTest ()
        {
            Authdata_Base authdata = sg.Context.Authdata;

            // No challenge
            authdata.QFENumber = 1;

            DateTime before_keyex = DateTime.UtcNow;
            DoKeyExchange();
            DateTime after_keyex = DateTime.UtcNow;
            Global.RO.Info("Took this long to keyex without being challenged: " + (after_keyex - before_keyex).ToString());
            sg.SendDelete();

            // Challenge with a new machine puid to skip that pesky 1 second wait
            authdata.QFENumber = 0;
            SgClient.GetNewMachine(sg.Context, authdata);

            before_keyex = DateTime.UtcNow;
            DoKeyExchange();
            after_keyex = DateTime.UtcNow;
            Global.RO.Info("Took this long to keyex being challenged: " + (after_keyex - before_keyex).ToString());
            sg.SendDelete();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncLua.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XSGTest
{
    /// <summary>
    /// At one time, there were 10 different top level groups for tests that target functionality
    /// in the SG involving Lua.  Combining all of the different Lua targeted testing into one group
    /// made the SG test cases much more structured, and easier to find anything Lua related.
    /// 
    /// If I didn't actually get around to moving the groups around in files, they are here:
    /// Filters => FuncKeyexFilters.cs
    /// SyncChallenges => This file (FuncLua.cs)
    /// LuaPanorama => FuncPanoramaLua.cs
    /// AsyncFundamentals => FuncSecmsgChalResp_Lua.cs
    /// Controller => FuncLuaMultistage.cs
    /// Secmsg_ChalResp => FuncSecmsgChalResp.cs
    /// Secmsg_ChalResp_Auto => FuncSecmsgChalResp.cs
    /// LuaChal => FuncLuaChal.cs
    /// LuaSGHooks => FuncLuaSGHooks.cs
    /// SpiStorage => FuncLuaSpiSeq.cs
    /// LuaRuntime => FuncLuaRuntime.cs
    /// </summary>
    [TestGroup]
    public class Lua : TestNode
    {
        public override void PreRun ()
        {
            SgEnvironmentInfo.ReduceChallengeTiming();
            SgServerInfo.ReloadConfiguration();
        }

        public override void PostRun ()
        {
            SgEnvironmentInfo.RestoreChallengeTiming();
            //SgServerInfo.ReloadConfiguration();
        }

        public Lua ()
        {
            AddChild(new Filters());
            AddChild(new SyncChallenges());
            AddChild(new LuaPanorama());   // Roll into sync challenges
            AddChild(new LuaChal());   // Roll into sync challenges
            AddChild(new Controller());
            AddChild(new XSGTest.AsyncChallenges());
            AddChild(new PersistentKick());
        }

        [TestGroup]
        public class SgLuaImplementation : TestNode
        {
            public SgLuaImplementation ()
            {
                AddChild(new SgExtensions());
                AddChild(new SpiStorage());
                AddChild(new LuaRuntime());
            }
        }
    }

    /// <summary>
    /// Base class for any LUA-specific tests. If a function is only relevant to LUA, it
    /// goes here. If it is relevant to the SG tests in general, it goes in
    /// TestBase_SgFake. If it is relevant to the SG itself, it goes in SgClient.
    /// </summary>
    class TestBase_Lua : TestBase_SgFake
    {
        protected virtual void RunLuaTest() {} //implement this in derived class for your test

        // Authdata sent to the SG
        protected Authdata_Base                 authData = null;

        // LUA challenge configured on the SG
        protected LuaScript                     luaChal = null;

        // Key exchange challenge structure received from the SG. This is not the 
        // asynchronous challenge.
        protected KeyExchangeSgToXbChallenge    sgChal = null;

        // Is this LUA script expected to have an error in the syntax?
        protected bool                          bBadLuaScript = false;

        // delay after propping a challenge to give the sg time to reload (in ms)
        protected uint sgReloadDelay=0;

        // time sg has to respond to qos packets
        protected uint sgResponseTime=2000;

#region Internal Workings

        protected override void InitGroup()
        {
            // Don't call the base one, we'll build a fake ticket just prior to signin so 
            // we can give the test a chance to twiddle the authdata.

            // Save a pointer to authdata to make life easier
            authData = sg.Context.Authdata;

            // Set our own custom client version that the LUA challenges or filters should 
            // target. The nnnn.nnnn.nnnn.nnnn client version is broken out like so:
            //   public ushort                   wMajorVersion;
            //   public ushort                   wMinorVersion;
            //   public ushort                   wBuildNumber;
            //   public ushort                   wQFENumber;
            authData.MajorVersion  = 0x5347;  // 'SG' in hex
            authData.MinorVersion  = 0x0001;  // 1 for LUA C/R, 2 for LUA filters
            authData.BuildNumber   = 0;
            authData.QFENumber     = 0x0001;  // any tests that may stomp on each other should change this!
            authData.TitleVersion = 0x00000001;
        }

        private uint numChalsPushed=0;

        //...?
        protected override bool VerifyTest()
        {
            if (bBadLuaScript)
            {
                return true;
            }

            if (!base.VerifyTest())
            {
                return false;
            }

            return true;
        }

        //called when test needs run.. this will call RunLuaTest of derived classes
        protected sealed override void RunTest ()
        {
            Exception exc = null;

            try
            {
                //run test (may do several challenges)
                RunLuaTest();
            }
            catch (Exception e)
            {
                exc = e;
            }
            finally
            {
                try
                {
                    ChalManager.RemoveAllScripts();
                }
                catch (Exception e)
                {
                    throw exc ?? e;
                }
                finally
                {
                    numChalsPushed = 0;
                }
            }
        }

#endregion

        //Registers another challenge (gets unregistered automatically when we destruct)
        protected bool AddChallenge(string chalScript)
        {
            return AddChallenge(new LuaScript() { Name=Name, Script = chalScript });
        }
        protected bool AddChallenge(LuaScript chal)
        {
            bool gotLuaLoadFailure = false;

            // Prop the challenge, but put some test logic around it.
            try
            {
                ChalManager.AddScript(chal, false);
                SgServerInfo.ReloadChallenges();
                ++numChalsPushed;
            }
            catch (SgReloadConfigException)
            {
                Fail("Unexpected error reloading the config for the SG. Check the eventlogs on the server for more information.");
                ChalManager.RemoveScript(chal);
                return false;
            }
            if (bBadLuaScript && !gotLuaLoadFailure)
            {
                Fail("This was supposed to be a bad LUA script but it seems to have been propped successfully. We'll continue with the sign-in.");
            }

            if (sgReloadDelay>0) System.Threading.Thread.Sleep((int)sgReloadDelay);
            return true;
        }

        //logs in and throws if whether we expected a challenge didn't line up
        protected void SignIn(bool shouldBeChallenged)
        {
            SignIn();
            if (sgChal==null && shouldBeChallenged)
            {
                Fail("did NOT get challenged when we expected to.");
                throw new System.Exception();
            }
            else if (sgChal!=null && !shouldBeChallenged)
            {
                Fail("GOT challenged when we did not expect to");
                throw new System.Exception();
            }
        }

        //logs in and gets a challenge if we got one
        protected void SignIn()
        {
            //if easy-use-member is set, add that challenge
            if (luaChal != null)
            {
                if (!AddChallenge(luaChal))
                {
                    return;
                }
            }

            //debug spew
            Global.RO.Debug("Using auth data:\n"+authData.ToString());

            //
            try
            {
                // Sign in
                DoKeyExchange();
                
                // Save off the keyex challenge, if one ws received.
                if (sg.KeyexResult != null)
                {
                    if (sg.KeyexResult.keyexChal==null)
                    {
                        ro.Debug("We did NOT get challenged by the SG after key exchange");
                    }
                    else
                    {
                        ro.Debug("We got challenged by the SG after key exchange");
                    }
                    sgChal = sg.KeyexResult.keyexChal;
                }
            }
            finally { } //challenges removed after test finishes now
        }

        //sends a response back for a challenge, and fails if whether we expected to be disconnected didn't happen (returns false if we got wrong result also)
        protected bool SendChallengeResponse(String response, bool shouldStayConnected)
        {
            SendKeyexChalResponse(response);
            System.Threading.Thread.Sleep(200);
            return TestSignedIn(shouldStayConnected);
        }

        //sends a response back for a challenge, and fails if whether we expected to be disconnected didn't happen (returns false if we got wrong result also)
        protected bool SendChallengeResponse3 (byte[] response, bool shouldStayConnected)
        {
            SendKeyexChalResponse3(response);
            System.Threading.Thread.Sleep(200);
            return TestSignedIn(shouldStayConnected);
        }

        /// <summary>
        /// Tests to see if we are still signed in, with the return result being dependent on the value passed in.
        /// </summary>
        protected bool TestSignedIn (bool shouldBeConnected)
        {
            if (IsStillSignedIn((int)sgResponseTime) != shouldBeConnected)
            {
                if (shouldBeConnected)
                {
                    Fail("SG disconnected us :(");
                }
                else
                {
                    Fail("SG did NOT disconnect us");
                }
                return false;
            }
            else
            {
                return true;
            }
        }

        //generates a lua script for testing a single auth data entry as a target filter, and simple a kick on bad response
        protected static String GenLua_TargetFilterWithSimpleKick(String spiFuncName, 
                                                                  ushort authValue,
                                                                  bool shouldTarget,
                                                                  out byte[] outExpectedParam,
                                                                  bool doMakeValidAnswer,
                                                                  out String answerToSend,
                                                                  bool targetPanorama)
        {
            //make 4 char hex string
            String authValString = String.Format("{0:x4}",authValue);

            //calc param to expect back (last 2 bytes are where the authValue as passed.. rest is just padding)
            outExpectedParam = new byte[] { 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,(byte)((authValue >> 8) & 0xff),(byte)(authValue & 0xff) };

            //calc answer to send back to the sg (last 2 bytes is where answer is again)
            if (doMakeValidAnswer) //this response should pass the __Analyze
            {
                answerToSend = String.Format("0x7777777777777777777777777777{0}",authValString);
            }
            else //this response should fail the __Analize
            {
                answerToSend = "0x77777777777777777777777777777777";
                if (authValString == "7777") answerToSend = "0x7777777777777777777777777778888";
            }

            //lua script template (values within are replaced)
            String lscript_template = "ChallengeDeclare(0x999, \"Challenge 0x999\",true,"+(targetPanorama?"true":"false")+")\n" +
            "__Binary = Buffer.new('079B8E731B85137E369DA119F3C196F6109B4C547A611BD257BAA9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927DB227E1585A2D4DF506C0911DEAFCAC705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877FF2A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E745288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5816D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC19CCEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100010000200000000000')\n" +
            "function __Target()\n" +
            (shouldTarget ? "    if Spi.{2}() ~= {0} then return false end\n" : "    if Spi.{2}() == {0} then return false end\n") +
            "    chalParamQ=Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFF{1}')\n" +
            "    Chal.SetParam(chalParamQ)\n" +
            "    return true\n" +
            "end\n" +
            "function __Analyze(buffer)\n" +
            //"    trace('got buffer:'..buffer:__tostring())\n"+
            "    if buffer:getbyte(0)~=119 or buffer:getbyte(14)~=" + (authValue >> 8) + " or buffer:getbyte(15)~=" + (authValue & 0xff) + " then Chal.Kick(true) end\n" +
            "end\n";

            String lscript = String.Format(lscript_template,authValue,authValString,spiFuncName);

            ro.Debug("generated lua script:\n" + lscript);
            //Global.RO.Debug("answer to be sent to sg lua script: "+answerToSend);

            return lscript;
        }

        //runs a test for the above generated Lua script
        protected void RunGeneratedLuaScript_TargetFilterWithSimpleKick(String spiFuncName,
                                                                        ushort authValue,
                                                                        bool targetPanorama,
                                                                        bool shouldTarget,
                                                                        bool shouldKickIfTargetted)
        {
            //generate lua script and expected param and answer to send
            byte[] expectedParam;
            String answerToSend;
            String lscript = GenLua_TargetFilterWithSimpleKick(spiFuncName,authValue,shouldTarget,out expectedParam,!shouldKickIfTargetted,out answerToSend,targetPanorama);
            luaChal = new LuaScript() { Name = spiFuncName, Script = lscript };

            //send script, login, check the challenge param, send response, and make sure our connection state is as it should be after that
            SignIn();
            if (shouldTarget && sgChal==null)
            {
                Fail("expected a challenge back from sg but didn't get (lua script error can cause this too)");
                return;
            }
            else if (!shouldTarget && sgChal!=null)
            {
                Fail("got a challenge from sg but didn't expect that");
                return;
            }
            else if (!shouldTarget) //shouldn't have been targetted and we weren't.. we're good
            {
                return;
            }

            ValueCheck.Test("bad challenge param received",expectedParam,sgChal.Params);
            SendChallengeResponse(answerToSend,!shouldKickIfTargetted);
        }
    }

    // -- tests

    [TestCasePriority(1), Description("Lua Sync challenges - happens at login"), TestFrequency("Regression")]
    public class SyncChallenges : TestNode
    {
        //
        [TestCase, TestCasePriority(3), Description("")]
        class Lua_Simple_LoginOnly_NoProp : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set fields in authData as necessary
                authData.TitleId          = 0xDEADBEEF;
                SignIn();
                if (sgChal != null)
                {
                    ro.Debug("Param: {0}", Hexer.tohex(sgChal.Params));
                    ro.Debug("Binary: {0}", Hexer.tohex(sgChal.PkSig));
                    ro.Debug("Extra code: {0}", sgChal.ChalCode != null ? Hexer.tohex(sgChal.ChalCode) : "");
                }
                else
                {
                    ro.Debug("No challenge received.");
                }
            }
        }

	//
        [TestCase,Description("simple test to see if the sg will not target me")]
        class Lua_Simple_NoTarget : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set fields in authData as necessary
                authData.TitleId = 0xDEADBEEF;
                authData.TitleVersion = 9;

                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Simple"];

                SignIn(false);
            }
        }

        //
        [TestCase, Description("simple test to see if the sg will target me and not kick for a simple response")]
        class Lua_Simple_TargetNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set fields in authData as necessary
                authData.TitleId          = 0xDEADBEEF;

                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Simple"];
                SignIn(true);
                SendChallengeResponse("Rar",true);
            }
        }

        //
        [TestCase, Description("simple test to see if the sg will kick me for a bad response")]
        class Lua_Simple_Kickme : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set fields in authData as necessary
                authData.TitleId = 0xDEADBEEF;
                authData.TitleVersion=2;
                
                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Simple"];

                SignIn(true);
                SendChallengeResponse("Rar",false);
            }
        }

        //
        [TestCase, Description("target but don't set param.. the sg should whine and complain")]
        class Lua_Target_NoParam : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=60;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_NoSetParam"];
                try
                {
                    SignIn();
                }
                catch
                {
                    Fail("This is an unexpected failure.");
                    throw;
                }

                if (sgChal != null) //it should not have succeeded with the challenge
                {
                    Fail("Got challenged, but SG should not have accepted the lack of a Param");
                }
                else
                {
                    // We were able to sign in but got no challenge, this is what we expect
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        //
        [TestCase, TestCasePriority(3), Description("malformed lua script")]
        class Lua_BadScript : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_BadScript"];

                bBadLuaScript = false;
                SignIn(false);
            }
        }

        //
        [TestCase, TestCasePriority(3), Description("lua script with no binary data?")]
        class Lua_NoBinary : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_NoBinary"];
                SignIn();
            }
        }

        /*[TestCase] //TODO: grr evil C#... ...maybe later
        class LuaPos_TargetUsingLanguageID : TestBase_Lua
        {
            protected override void RunTest()
            {
                uint langIDOffset=(byte*)&authData.wLanguageID-(byte*)&authData;
                authData.wLanguageID=7;
                String lscript=LuaChalBinHeader+
                "function __Target()\n"+
                "   if Spi.GetAuthData3():getword("+langIDOffset+") ~= 7 then return false end\n"+
                "    return true\n"+
                "end\n"+
                "function __Analyze(buffer)\n"+
                "end\n";

                luaChal = new Challenge_Lua(lscript);
                bExpectedNoReply = true;
                SignIn();
            }
        }*/

        //
        [TestCase, TestCasePriority(3), Description("prop a blank script and see what happens... ...")]
        class Lua_Blank : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Blank"];
                SignIn();

                //TODO:  What is the expected behavior if we prop a blank script?
            }
        }

        //
        [TestCase, TestCasePriority(3), Description("test of stf xml thing to extract the lua script with a bad name")]
        class Lua_TestSTFXMLBadName : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set challenge member. It will get propped automatically.
                try
                {
                    luaChal = ChallengeManager.PreconfiguredLuaScripts["I do not exist"];
                    SignIn();
                }
                catch
                {
                    //should throw about a bad entry.. though this is really just testing the stf stuff..
                    return;
                }

                Fail("Managed to find an entry that doesn't exist...");
            }
        }

        //
        [TestCase,Description("a more complex target test script - should not be challenged")]
        class Lua_TargetComplex_0: TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexTarget"];
                authData.TitleVersion = 2;
                SignIn(false);
            }
        }

        //
        [TestCase,Description("a more complex target test script - should be challenged")]
        class Lua_TargetComplex_1 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexTarget"];
                authData.TitleVersion = 1;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISXENON;
                authData.TitleId = 0x9999;
                SignIn(true);
            }
        }

        //
        [TestCase,Description("a more complex target test script - should not be challenged")]
        class Lua_TargetComplex_2 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexTarget"];
                authData.TitleVersion = 1;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISXENON;
                authData.TitleId = 0xffff;
                SignIn(false);
            }
        }

        //
        [TestCase,Description("a more complex target test script - should not be challenged")]
        class Lua_TargetComplex_3 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexTarget"];
                authData.TitleVersion = 1;
                authData.AuthDataFlags &= ~Authdata_Xenon.FLAGS_ISXENON;
                authData.XboxID = 0xffffffffffffffef;
                System.Threading.Thread.Sleep(1000); //sg doesn't like us sequentially logging in with same ID too fast
                SignIn(false);
            }
        }

        //
        [TestCase,Description("a more complex target test script - should not be challenged")]
        class Lua_TargetComplex_4 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexTarget"];
                authData.TitleVersion = 1;
                authData.AuthDataFlags &= ~Authdata_Xenon.FLAGS_ISXENON;
                authData.XboxID = 0xfffffffeffffffff;
                System.Threading.Thread.Sleep(1000); //sg doesn't like us sequentially logging in with same ID too fast
                SignIn(true);
            }
        }

        //
        [TestCase,Description("a more complex analyze test script - should be kicked")]
        class Lua_AnalyzeComplex_0 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexAnalyze"];
                authData.QFENumber=0x9999;
                authData.TitleVersion=2;
                SignIn(true);
                SendChallengeResponse("0xa0ec",false);
            }
        }

        //
        [TestCase,Description("a more complex analyze test script - should not be kicked")]
        class Lua_AnalyzeComplex_1 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexAnalyze"];
                authData.QFENumber = 0x9999;
                authData.TitleVersion = 1;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISXENON;
                authData.TitleId=0x9999;
                SignIn(true);
                SendChallengeResponse("0x80",true);
            }
        }

        //
        [TestCase,Description("a more complex analyze test script - should be kicked")]
        class Lua_AnalyzeComplex_2 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexAnalyze"];
                authData.QFENumber = 0x9999;
                authData.TitleVersion = 1;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISXENON;
                authData.TitleId = 0xaaab;
                SignIn(true);
                SendChallengeResponse("0x111111",false);
            }
        }

        //
        [TestCase,Description("a more complex analyze test script - should be kicked")]
        class Lua_AnalyzeComplex_3 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexAnalyze"];
                authData.QFENumber = 0x9999;
                authData.TitleVersion = 1;
                authData.XboxID = 0xffffffffffffffef;
                System.Threading.Thread.Sleep(1000); //sg doesn't like us sequentially logging in with same ID too fast
                SignIn(true);
                SendChallengeResponse("0x111111",false);
            }
        }

        //
        [TestCase,Description("a more complex analyze test script - should not be kicked")]
        class Lua_AnalyzeComplex_4 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexAnalyze"];
                authData.QFENumber = 0x9999;
                authData.TitleVersion = 1;
                authData.XboxID = 0xffffffeeffffffff;
                System.Threading.Thread.Sleep(1000); //sg doesn't like us sequentially logging in with same ID too fast
                SignIn(true);
                SendChallengeResponse("0x111111",true);
            }
        }

        //
        [TestCase,Description("a more complex analyze test script - should be kicked")]
        class Lua_AnalyzeComplex_5 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_ComplexAnalyze"];
                authData.QFENumber = 0x9999;
                authData.TitleVersion = 1;
                authData.XboxID = 0xffffffeeffffffff;
                System.Threading.Thread.Sleep(1000); //sg doesn't like us sequentially logging in with same ID too fast
                SignIn(true);
                SendChallengeResponse("0x8008",false);
            }
        }

        //
        [TestCase, Description("test that min length binary data gets passed to client correctly")]
        class Lua_TestMinBinary : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                //some random data (256 bytes)
                string binDataStr="109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030000200000800070";
                byte []binData=Hexer.unhex(binDataStr);

                // Use this for targeting
                authData.QFENumber = 0x9977;

                //set the script
                string luaCode="ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('" + binDataStr + "')\n" +
                    "function __Target()\n" +
                    "  if Spi.GetClientQfe() == 0x9977 then\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "  end\n" +
                    "  return false\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "end\n";

                ro.Debug("Lua script used:\n"+luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                //sign in... we should be challenged
                SignIn();
                if (sgChal == null)
                {
                    Fail("expected a challenge back from sg but didn't get");
                    return;
                }

                //check that the binary blob is right
                ValueCheck.Test("Binary chunk of stuff: ",binData,sgChal.PkSig);
            }
        }

        //
        [TestCase, Description("Test that a one byte binary gets dropped for a DES client")]
        class Lua_TestOneByteBinary_DES : TestBase_Lua
        {
            protected override void RunLuaTest ()
            {
                //some random data (256 bytes)
                string binDataStr = "a5";
                byte[] binData = Hexer.unhex(binDataStr);

                // Use this for targeting
                SgEnvironmentInfo.SetXbox360ClientVersion(authData, false);
                authData.QFENumber = 0x9977;

                //set the script
                string luaCode = "ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('" + binDataStr + "')\n" +
                    "function __Target()\n" +
                    "  if Spi.GetClientQfe() == 0x9977 then\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "  end\n" +
                    "  return false\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "end\n";

                ro.Debug("Lua script used:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                //sign in... we should not be challenged
                SignIn();
                if (sgChal != null)
                {
                    Fail("Did not expect a challenge back from sg but got one");
                    return;
                }

                if (!events.TestForChange(53914))
                {
                    Fail("Did not find the event about the challenge not being 0 mod 8 (53914)");
                }
            }
        }

        //
        [TestCase, Description("Test that a one byte binary gets padded for an AES client")]
        class Lua_TestOneByteBinary_AES : TestBase_Lua
        {
            protected override void RunLuaTest ()
            {
                //some random data (256 bytes)
                string binDataStr = "a5";
                byte[] binData = Hexer.unhex(binDataStr);

                // Use this for targeting
                SgEnvironmentInfo.SetXbox360ClientVersion(authData, true);
                authData.QFENumber = 0x9977;

                //set the script
                string luaCode = "ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('" + binDataStr + "')\n" +
                    "function __Target()\n" +
                    "  if Spi.GetClientQfe() == 0x9977 then\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "  end\n" +
                    "  return false\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "end\n";

                ro.Debug("Lua script used:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                //sign in... we should be challenged
                SignIn();
                if (sgChal == null)
                {
                    Fail("expected a challenge back from sg but didn't get");
                    return;
                }

                // check that the binary blob is right
                // The KeyExchangeSgToXbChallenge header is encrypted without the KeyExchangeHeader part (its size is enc_chal_hdr)
                // For AES we pad this plus the challenge bytes up to 0 mod 16
                int enc_chal_hdr = KeyExchangeSgToXbChallenge.SIZE_WITHOUT_PKSIG - KeyExchangeHeader.SIZE;
                int chal_data_size = (int)((enc_chal_hdr + binData.Length + 15) & ~15);
                if (sgChal.cbEnt != KeyExchangeHeader.SIZE + chal_data_size)
                {
                    Fail("Challenge should have been padded to 0 mod 16 :: cbEnt = {0} : " + 
                        "sizeof(SgToXbChal Hdr portion) = {1} : Expected encrypted chal size = {2}",
                        sgChal.cbEnt, enc_chal_hdr, chal_data_size);
                }

                if (sgChal.PkSig[0] != binData[0])
                {
                    Fail("The 'challenge' code was not correct.");
                }
            }
        }

        //
        [TestCase,Description("test that max length binary data gets passed to client correctly")]
        class Lua_TestMaxBinary : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                //some random data (256+760 bytes)
                string binDataStr0 = "109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030000200000800070";
                string binDataStr1 = "cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003000020000080bb33cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003000020000080bb33cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003";
                byte[] binData0 = Hexer.unhex(binDataStr0);
                byte[] binData1 = Hexer.unhex(binDataStr1);

                // Use this for targeting
                authData.QFENumber = 0x9977;

                //set the script
                string luaCode = "ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('" + binDataStr0 + binDataStr1 +"')\n" +
                    "function __Target()\n" +
                    "  if Spi.GetClientQfe() == 0x9977 then\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "  end\n" +
                    "  return false\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "end\n";

                ro.Debug("Lua script used:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                //sign in... we should be challenged
                SignIn();
                if (sgChal == null)
                {
                    Fail("expected a challenge back from sg but didn't get");
                    return;
                }

                //check that the binary blob is right (first 256 in PkSig, rest in ChalCode)
                ValueCheck.Test("Binary chunk 0: ",binData0,sgChal.PkSig);
                ValueCheck.Test("Binary chunk 1: ",binData1,sgChal.ChalCode);
            }
        }

        //
        [TestCase, TestCasePriority(3), Description("Test that max length + 1 binary data gets dropped and we don't get challenged")]
        class Lua_TestTooLargeBinary : TestBase_Lua
        {
            protected override void RunLuaTest ()
            {
                //some random data (256+761 bytes)
                string binDataStr0 = "109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030000200000800070";
                string binDataStr1 = "cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003000020000080bb33cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003000020000080bb33cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE96000101100001000377";
                byte[] binData0 = Hexer.unhex(binDataStr0);
                byte[] binData1 = Hexer.unhex(binDataStr1);

                // Use this for targeting
                authData.QFENumber = 0x9977;

                //set the script
                string luaCode = "ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('" + binDataStr0 + binDataStr1 + "')\n" +
                    "function __Target()\n" +
                    "  if Spi.GetClientQfe() == 0x9977 then\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "  end\n" +
                    "  return false\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "end\n";

                ro.Debug("Lua script used:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                //sign in... we should not be challenged
                SignIn();
                if (sgChal != null)
                {
                    Fail("Did not expect a challenge back from sg but got one");
                    return;
                }

                if (!events.TestForChange(53915))
                {
                    Fail("Did not find the event about the challenge being too large (53915)");
                }
            }
        }

        //
        [TestCase,Description("test that lua script __Analyze gets the exact data we had sent")]
        class Lua_TestResponseBuffer : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                //some random data (256 bytes)
                string binDataStr = "109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030120200000808844";

                //set the script
                string luaCode = "ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000')\n" +
                    "function __Target()\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "    if buffer:getbyte(0)==0x10";
                for (int i=1;i<256;++i)
                    luaCode+=" and buffer:getbyte("+i+")==0x"+binDataStr[i*2]+binDataStr[i*2+1];
                luaCode+=" then return end\n"+
                    "    Chal.Kick(true)\n"+
                    "end\n";

                ro.Debug("Lua script generated:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                //sign in... we should be challenged
                SignIn(true);

                //send response.. we should not be kicked
                SendChallengeResponse(binDataStr,true);
            }
        }

        //
        [TestCase, TestCasePriority(3), Description("test that lua script __Analyze doesn't do bad things if we send too big a response, and that it doesn't kick us if we error")]
        class Lua_TestResponseBufferTooBigNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                //some random data (257 bytes)
                string binDataStr = "99109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030120200000808844";

                //set the script
                string luaCode = "ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000')\n" +
                    "function __Target()\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "    if buffer:getbyte(0)==0x99";
                for (int i = 1;i < 257;++i)
                    luaCode += " and buffer:getbyte(" + i + ")==0x" + binDataStr[i * 2] + binDataStr[i * 2 + 1];
                luaCode += " then return end\n" +
                    "    Chal.Kick(true)\n" +
                    "end\n";

                ro.Debug("Lua script generated:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                //sign in... we should be challenged
                ro.Debug("string is " + binDataStr.Length + " bytes, so " + binDataStr.Length/2+ " bytes of data.");
                SignIn(true);

                //send response.. the last byte shouldn't get through, and lua script should error trying to read it and die there, never getting to Kick
                SendChallengeResponse(binDataStr,true);
            }
        }

        //
        [TestCase, Description("test that lua script __Analyze gets the exact data we had sent")]
        class Lua_TestResponseBuffer3 : TestBase_Lua
        {
            protected override void RunLuaTest ()
            {
                // construct response
                byte[] resp = new byte[1024];
                for (int i = 0; i < resp.Length; ++i)
                {
                    resp[i] = (byte)(i % 256);
                }

                // set the script
                luaChal = new LuaScript(ChallengeManager.PreconfiguredLuaScripts["LuaCM_VerifyBinaries"]);
                luaChal.IsSync = true;

                // add the script ourselves, it won't be duped later
                if (!AddChallenge(luaChal))
                {
                    throw new UnexpectedTestResultException("Unable to prop challenge.");
                }

                // set the authdata so that we get challenged
                ChalManager.SetAuthdataForScript(luaChal, sg.Context.Authdata);

                // sign in... we should be challenged
                SignIn(true);

                // send response.. we should be kicked
                SendChallengeResponse3(resp, false);
            }
        }

        //
        [TestCase, TestCasePriority(3), Description("test that lua script __Analyze WILL kick us, if we call Kick then error")]
        class Lua_TestResponseBufferTooBigKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                //some random data (257 bytes)
                string binDataStr = "99109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030120200000808844";

                //set the script
                string luaCode = "ChallengeDeclare(0x997, \"Challenge 0x997\",true,false)\n" +
                    "__Binary = Buffer.new('00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000')\n" +
                    "function __Target()\n" +
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "    Chal.Kick(true)\n" +
                    "    if buffer:getbyte(0)==0x99";
                for (int i = 256;i < 257;++i)
                    luaCode += " and buffer:getbyte(" + i + ")==0x" + binDataStr[i * 2] + binDataStr[i * 2 + 1];
                luaCode += " then return end\n" +
                    "    Chal.Kick(false)\n"+
                    "end\n";

                ro.Debug("Lua script generated:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                //sign in... we should be challenged
                ro.Debug("string is " + binDataStr.Length + " bytes, so " + binDataStr.Length / 2 + " bytes of data.");
                SignIn(true);

                //send response.. the last byte shouldn't get through, and lua script should error trying to read it and die there, but still kick us since we already called it
                SendChallengeResponse(binDataStr,false);
            }
        }

        //
        [TestCase, Description("target me, verify param sent, don't kick me, based off wMajorVersion value 0xffff")]
        class Lua_TarMajorVersionFFFFNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0xffff, false, true, false);
            }
        }

        //
        [TestCase,Description("target me, verify param sent, don't kick me, based off wMajorVersion value 0x0000")]
        class Lua_TarMajorVersion0000NoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0x0000, false, true, false);
            }
        }

        //
        [TestCase,Description("target me, verify param sent, kick me, based off wMajorVersion value 0xffff")]
        class Lua_TarMajorVersionFFFFKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0xffff, false, true, true);
            }
        }

        //
        [TestCase,Description("target me, verify param sent, kick me, based off wMajorVersion value 0x0000")]
        class Lua_TarMajorVersion0000Kick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0x0000, false, true, true);
            }
        }

        //
        [TestCase,Description("don't target me, based off wMajorVersion value 0xffff")]
        class Lua_NoTarMajorFFFFVersion : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0xffff, false, false, true);
            }
        }

        //
        [TestCase,Description("don't target me, based off wMajorVersion value 0x0000")]
        class Lua_NoTarMajor0000Version : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0x0000, false, false, true);
            }
        }

        //
        [TestCase,Description("target me, verify param sent, don't kick me, based off wMinorVersion value 0x8888")]
        class Lua_TarMinorVersionNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMinor", authData.MinorVersion = 0x8888, false, true, false);
            }
        }

        //
        [TestCase,Description("target me, verify param sent, don't kick me, based off wBuildNumber value 0x6666")]
        class Lua_TarBuildNumberNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientBuild", authData.BuildNumber = 0x6666, false, true, false);
            }
        }

        //
        [TestCase,Description("target me, verify param sent, don't kick me, based off wQFENumber value 0x9999")]
        class Lua_TarQFENumberNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientQfe", authData.QFENumber = 0x9999, false, true, false);
            }
        }

        //
        [TestCase,Description("target a machine labeled as part of beta")]
        class Lua_TargetBeta: TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_TargetBeta"];
                authData.QFENumber = 0x9999;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISBETAMACHINE;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISXENON;
                SignIn(true);
            }
        }

        //
        [TestCase,Description("target beta machines, but log in as a non-beta")]
        class Lua_NoTargetBeta: TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_TargetBeta"];
                authData.QFENumber = 0x9999;
                authData.AuthDataFlags &= ~Authdata_Xenon.FLAGS_ISBETAMACHINE;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISXENON;
                SignIn(false);
            }
        }

        //
        [TestCase,Description("target a machine labeled as not part of beta")]
        class Lua_TargetNonBeta: TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_TargetNonBeta"];
                authData.QFENumber = 0x9999;
                authData.AuthDataFlags &= ~Authdata_Xenon.FLAGS_ISBETAMACHINE;
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISXENON;
                SignIn(true);
            }
        }

        //
        [TestCase, Description("simple test to see if the sg will NOT kick me for a bad response when the per-challenge variable has kicking off")]
        class Lua_PCVNoKick_TryToKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set fields in authData as necessary
                authData.TitleId = 0xDEADBEEF;
                authData.TitleVersion=2;
                
                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Simple"];
                luaChal.KickEnabled = false;
                luaChal.TimeoutEnabled = true;

                SignIn(true);
                SendChallengeResponse("Rar",false);

                luaChal.KickEnabled = true;
            }
        }

        //
        [TestCase, Description("simple test to see if the sg doesn't do anything strange when the timeout var is set off for a key exchange challenge")]
        class Lua_PCVNoTimeout : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                // Set fields in authData as necessary
                authData.TitleId = 0xDEADBEEF;
                authData.TitleVersion=2;
                
                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Simple"];
                luaChal.KickEnabled = true;
                luaChal.TimeoutEnabled = false;

                SignIn(true);
                SendChallengeResponse("Rar",false);

                luaChal.TimeoutEnabled = true;
            }
        }

        //
        [TestCase,Description("target me and log it -- You must MANUALLY check the log to verify (title id: Ca7Ca700 response: 1779B1779D1779)")]
        class Lua_Log_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId = 0xCa7Ca700;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SimpleLog"];
                SignIn(true);
                SendChallengeResponse("0x1779B1779D1779",true);
            }
        }

        //
        [TestCase,Description("target me and DON'T log it -- You must MANUALLY check the log to verify (title id: BaceBa11 repsonse: BadBad)")]
        class Lua_NoLog_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId = 0xBaceBa11;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SimpleNoLog"];
                SignIn(true);
                SendChallengeResponse("0xBadBad",true);
            }
        }

        //
        [TestCase,Description("target me, turn on logging, and kick me -- You must MANUALLY check the log to verify (title id: 0x66677700 response: 0x1441211008164362516941)")]
        class Lua_LogAndKick_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId = 0x66677700;
                authData.QFENumber=66;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_LogAndKick"];
                SignIn(true);
                SendChallengeResponse("0x1441211008164362516941",false);
            }
        }

        //
        [TestCase,Description("target me and log it, but caues a lua error before return... it should still be logged -- You must MANUALLY check the log to verify (title id: 0x40C0FFEE response: B00B00)")]
        class Lua_LogWithLuaError_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId = 0x40C0FFEE;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SimpleLogWithError"];
                SignIn(true);
                SendChallengeResponse("0xB00B00",true);
            }
        }

        //
        [TestCase,Description("target me and log it (min size response) -- You must MANUALLY check the log to verify (title id: Ba779B00 response: 00)")]
        class Lua_LogMinResponse_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId = 0xBa779B00;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SimpleLog"];
                SignIn(true);
                SendChallengeResponse("0x00",true);
            }
        }

        //
        [TestCase,Description("target me and log it (max size response) -- You must MANUALLY check the log to verify (title id: 70070022 response: ff00..000000..00ff)")]
        class Lua_LogMaxResponse_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId= 0x70070022;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SimpleLog"];
                SignIn(true);
                byte []b=new byte[256];
                b[0]=0xff;
                b[255]=0xff;
                SendChallengeResponse("0x"+Hexer.tohex(b),true);
            }
        }

        //
        [TestCase,Description("target me and log it (over max size response) -- You must MANUALLY check the log to verify (title id: B0b15B0b response: ff00..000000..00feff (the ff is 1 past max))")]
        class Lua_LogOverMaxResponse_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId = 0xB0b15B0b;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_SimpleLog"];
                SignIn(true);
                byte[] b = new byte[257];
                b[0] = 0xff;
                b[255] = 0xfe;
                b[256] = 0xff;
                SendChallengeResponse("0x" + Hexer.tohex(b),true);
            }
        }

        //
        [TestCase, Ignore, TestCasePriority(3), Description("put lua script into an infinite loop in __Analyze -- WARNING: right now the SG will get have threads get stuck doing this, which pushes cpu to max until SG is reset.  Manually check the CPU load before and after running this test to verify it.")]
        class Lua_InfiniteLoop_BADNESS : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.TitleId = 0xBadddddd;
                authData.QFENumber=66;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_LockupAnalyze"];
                SignIn(true);
                SendChallengeResponse("0xbada",false);
            }
        }

        [TestCase, TestCasePriority(3), Description("Put a large number of lua scripts into the npdb and do a reload_config, to make sure it can chew on it")]
        class Lua_PropATonOfScripts : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                uint num_scripts=100;

                //push a bunch of scripts up
                ro.Info("Putting "+num_scripts+" challenges into the npdb...");
                for (uint i=0;i<num_scripts;++i)
                {
                    LuaScript const_cl=ChallengeManager.PreconfiguredLuaScripts["Lua_FillerTemplate"]; //gosh grr C#'s lack of a const

                    LuaScript cl=new LuaScript(const_cl);
                    cl.Name+=i.ToString()+".lua";
                    cl.Script=string.Format(cl.Script,"0x"+Hexer.tohex(0x770000+i));
                    ChalManager.AddScript(cl,false);

                    //if (i%1000==999) ro.Info("pushed #"+(i+1)+" of "+num_scripts+"...");
                }

                //reload
                try
                {
                    ro.Info("sleeping for 10s before reload...");
                    System.Threading.Thread.Sleep(10000);
                    ro.Info("issueing reload_config and giving it 5 minutes to get back to us...");
                    SgServerInfo.ReloadConfiguration(300000, true);
                    ro.Info("sleeping for 10s after reload...");
                    System.Threading.Thread.Sleep(10000);
                }
                finally
                {
                    //take those challenges back off
                    try
                    {
                        ro.Info("removing those challenges from the npdb...");
                        ChalManager.RemoveAllScripts(false);
                        ro.Info("doing reload_config to clear them off the sg");
                        SgServerInfo.ReloadConfiguration(300000, true);
                        ro.Info("successfully removed the challenges from the sg");
                    }
                    catch
                    {
                        ro.Warn("Challenges may be stuck on the SG.  Make sure npdb t_sg_scripts doesn't have the challenges, then do a reload_config to fix.");
                        throw;
                    }
                }
            }
        }

        [TestCase(BugDatabase = "Xbox 360 Console Software", BugID = 154908)]
        [Description("Send a kick request for a client that is still processing a challenge")]
        class KickBeforeChallengeResponse : TestBase_Lua
        {
            protected override void RunLuaTest ()
            {
                // Set challenge member. It will get propped automatically.
                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Simple"];

                // we don't want to be challenged
                authData.TitleVersion = 9;
                SignIn();

                // sign in a client to the SG, getting challenged
                SgClient otherClient = new SgClient(new AuthContext());
                otherClient.Context.SetUser("User", 0);
                otherClient.bUseConnectionServices = true;
                otherClient.SetDefaultAuthdata(Authdata_Base.NewDefaultFromSite(SiteInfoManager.GetDefaultSgSite()));
                otherClient.SignInSG();

                // send a kick msg
                SgMsgKickReq kick = new SgMsgKickReq();
                kick.SgAddr = otherClient.KeyexResult.keyexResp.SGAddressInit;

                byte[] buff = SendSgMsg((byte[])kick);

                if (buff == null)
                {
                    throw new UnexpectedTestResultException("Did not receive a kick response");
                }

                SgMsgKickRep kickRep = new SgMsgKickRep();
                kickRep.ReadBytes(buff);

                if (kickRep.NotFound != 0)
                {
                    Global.RO.Debug(kickRep.ToString());
                    throw new UnexpectedTestResultException("Client to kick is reported as not found");
                }

                // wait a tiny bit
                Thread.Sleep(100);

                // test that the SG is still there
                QOS q = new QOS();
                if (!q.SendRecv(sg))
                {
                    throw new ServerTestFramework.Utilities.TimeoutException("QOS exchange timed out, SG may have crashed");
                }
            }
        }

    } //LuaSync group
} //namespace XSGTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncLuaMultistage.cs ===
//tests of the new multi-stage asynchronous challenge-response.
//These are tests for using challenges with the new control object only; old-style sequenced challenges are still in FuncLeaSpiSeq.cs

//TODO: Change SG's testbase to be a compound test base... thin half of these tests can be combined into the same code.

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XSGTest
{
    [Description("Multipronged challenges using the Master Control Program."), TestFrequency("Regression")]
    public class Controller : TestNode
    {

        //
        [TestCase,Description("prop a controller and a challenge that kicks")]
        class SimpleKick : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4499;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_con"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Should have gotten challenged");
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been booted");
            }
        };

        //
        [TestCase,Description("prop a controller and a challenge that kicks, but sign in on a different platform")]
        class SimpleKick_WrongPlatform : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                LuaPanorama.MakeAuthPC(authData);
                authData.QFENumber=0x4499;
                
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_con"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal!=null)
                {
                    throw new SgTestException("Should not have gotten challenged");
                }
            }
        };

        //
        [TestCase,Description("prop a controller and a challenge(disabled) that kicks")]
        class PCV_SimpleKick_ChalDisabled : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4499;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false, false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_con"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Should have gotten challenged");
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been kicked");
            }
        };

        //
        [TestCase(106271),Description("prop a controller(disabled) and a challenge that kicks")]
        class PCV_SimpleKick_ContDisabled : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4499;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_con"], true, false);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Should have gotten challenged");
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been kicked");
            }
        };

        //
        [TestCase,Description("sequence 3 challenges in a row then no challenge after that")]
        class Sequence3 : TestBase_AsyncLua
        {
            private uint seqNum; //which step in sequence we're waiting on... corresponds with Spi.GetStorage().SeqNum in lua script

            protected override void PreloginSetup (Authdata_Base authData)
            {
                seqNum=1;
                authData.QFENumber=0x4444;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_Sequence3_p1"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_Sequence3_p2"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_Sequence3_p3"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_Sequence3_con"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (seqNum==4) //should be this after the last step
                {
                    if (chal!=null)
                    {
                        throw new SgTestException("Got unexpected challenge. Sequence number is "+seqNum);
                    }
                    return;
                }

                //first 3 steps we should be challenged
                if (chal==null)
                {
                    throw new SgTestException("Did not get challenged");
                }

                //verify that the correct challenge was sent via its param and buffer's first and last byte
                byte []expectedParam=new byte[16];
                for (int i=0; i<15; ++i)
                    expectedParam[i]=0xff;
                expectedParam[15]=(byte)seqNum;
                    
                if (!ArrayEx.Compare(expectedParam,chal.Params))
                {
                    throw new SgTestException("Challenge Param for this sequence number is incorrect. Expected 0x"+Hexer.tohex(expectedParam)+" but got 0x"+Hexer.tohex(chal.Params));
                }

                if (chal.PkSig==null || chal.PkSig.Length<3)
                {
                    throw new SgTestException("Challenge PkSig is missing or too small...?");
                }

                if (chal.PkSig[0]!=seqNum || chal.PkSig[chal.PkSig.Length-1]!=seqNum)
                {
                    throw new SgTestException("Challenge PkSig is for the wrong challenge.");
                }

                //respond
                byte []response=new byte[1024];
                response[1023]=(byte)seqNum;
                SendChallengeResponse(response);
                if (!WaitAndCheckConnected(0)) throw new SgTestException("Got disconnected by sg unexpectedly");

                waitForAnotherChallenge=true;
                ro.Debug("finished sequence number "+seqNum);
                ++seqNum;
            }
        };

        //
        [TestCase, TestCasePriority(3), Description("prop a controller that does nothing whatsoever, and no challenges")]
        class LaughAtNothing : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4455;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_DoNothing_con"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal!=null)
                {
                    throw new SgTestException("Should not have gotten challenged");
                }
            }
        };

        //
        [TestCase(106272),Description("prop a mean controller that kicks in its target")]
        class ControllerTargetKick : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4466;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_DoNothing_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_KickTarget_con"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been booted");
            }
        };

        //
        [TestCase,Description("prop a controller that kicks in its analyze")]
        class ControllerAnalyzeKick : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4477;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_DoNothing_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_KickAnalyze_con"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Did not get challenged");
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been booted");
            }
        };

        //
        [TestCase,Description("prop 4 controllers, one targets xen devkits, one xen retail, one pc devkits, one pc retail - test 1")]
        class FourControllers_Xen : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4511;

                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_dev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pcdev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pc_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con1"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con2"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con3"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con4"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Should have gotten challenged");
                }

                //verify that the correct challenge was sent via its param and buffer's first and last byte
                byte []expectedParam=new byte[16];
                for (int i=0; i<15; ++i)
                    expectedParam[i]=0xbb;
                expectedParam[15]=1;
                    
                if (!ArrayEx.Compare(expectedParam,chal.Params))
                {
                    throw new SgTestException("Challenge Param is incorrect. Expected 0x"+Hexer.tohex(expectedParam)+" but got 0x"+Hexer.tohex(chal.Params));
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been booted");
            }
        };

        //
        [TestCase,Description("prop 4 controllers, one targets xen devkits, one xen retail, one pc devkits, one pc retail - test 2")]
        class FourControllers_XenDev : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4511;
                authData.AuthDataFlags|=Authdata_Xenon.FLAGS_ISDEVKIT;

                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_dev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pcdev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pc_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con1"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con2"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con3"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con4"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Should have gotten challenged");
                }

                //verify that the correct challenge was sent via its param and buffer's first and last byte
                byte []expectedParam=new byte[16];
                for (int i=0; i<15; ++i)
                    expectedParam[i]=0xbb;
                expectedParam[15]=3;
                    
                if (!ArrayEx.Compare(expectedParam,chal.Params))
                {
                    throw new SgTestException("Challenge Param is incorrect. Expected 0x"+Hexer.tohex(expectedParam)+" but got 0x"+Hexer.tohex(chal.Params));
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been booted");
            }
        };

        //
        [TestCase,Description("prop 4 controllers, one targets xen devkits, one xen retail, one pc devkits, one pc retail - test 3")]
        class FourControllers_PCDev : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                LuaPanorama.MakeAuthPC(authData);
                authData.QFENumber=0x4511;
                authData.AuthDataFlags|=Authdata_Xenon.FLAGS_ISDEVKIT;

                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_dev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pcdev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pc_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con1"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con2"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con3"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con4"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Should have gotten challenged");
                }

                //verify that the correct challenge was sent via its param and buffer's first and last byte
                byte []expectedParam=new byte[16];
                for (int i=0; i<15; ++i)
                    expectedParam[i]=0xbb;
                expectedParam[15]=2;
                    
                if (!ArrayEx.Compare(expectedParam,chal.Params))
                {
                    throw new SgTestException("Challenge Param is incorrect. Expected 0x"+Hexer.tohex(expectedParam)+" but got 0x"+Hexer.tohex(chal.Params));
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been booted");
            }
        };

        //
        [TestCase,Description("prop 4 controllers, one targets xen devkits, one xen retail, one pc devkits, one pc retail - test 4")]
        class FourControllers_PC : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                authData.QFENumber=0x4511;
                LuaPanorama.MakeAuthPC(authData);

                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_dev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pcdev_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_AlwaysKick_pc_chal"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con1"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con2"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con3"], false);
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaMSC_ThreeCons_con4"], true);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null)
                {
                    throw new SgTestException("Should have gotten challenged");
                }

                //verify that the correct challenge was sent via its param and buffer's first and last byte
                byte []expectedParam=new byte[16];
                for (int i=0; i<15; ++i)
                    expectedParam[i]=0xbb;
                expectedParam[15]=4;
                    
                if (!ArrayEx.Compare(expectedParam,chal.Params))
                {
                    throw new SgTestException("Challenge Param is incorrect. Expected 0x"+Hexer.tohex(expectedParam)+" but got 0x"+Hexer.tohex(chal.Params));
                }

                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(45)) throw new SgTestException("Should have been booted");
            }
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncMgmt.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
 
namespace XSGTest
{

    public class TestBase_Mgmt : TestBase_SgFake
    {
        protected List<SgClient> _clients = null;

        public static bool IsStillSignedIn (SgClient sgclient)
        {
            if (!sgclient.IsSignedIn)
                return false;
            // Do QOS exchange as a verification step
            QOS q = new QOS();
            return q.SendRecv(sgclient);
        }

        protected bool SignInMachines(int count)
        {
            _clients = new List<SgClient>(count);
            for (int i = 0; i < count; i++)
            {
                AuthContext ctx = new AuthContext(clientType);
                SgClient sgclient = new SgClient(ctx);
                sgclient.SignInSG();
                _clients.Add(sgclient);
            }
            return true;
        }

        override protected bool VerifyTest()
        {
            // Sign in a new client to make sure the SG is still running
            SgClient sg = new SgClient(new AuthContext(clientType));
            try
            {
                sg.SignInSG();
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                Fail("Timed out trying to sign in to the SG - did it crash?");
            }

            // Check all the clients we previously signed in
            if (_clients != null)
            {
                foreach (SgClient sgclient in _clients)
                {
                    if (!IsStillSignedIn(sgclient))
                    {
                        Fail("Found a client in our list of {0} previously signed in clients that is currently not signed in", _clients.Count);
                        return false;
                    }
                }
            }
            return true;
        }
    }

    /// <summary>
    /// SG stats xmgmt command tests.  Will only work against a single SG.
    /// </summary>
    public class TestBase_MgmtStats : TestNode
    {
        public string Command = null;
        public string ExpectedBegin = null;
        public string ExpectedEnd = null;
        public string ExpectedWhole = null;
        public string ExpectedSubstring = null;

        const string DefaultEnd = "ms to generate.\r\n";

        public TestBase_MgmtStats ()
        {
        }

        public TestBase_MgmtStats (string command, string begin)
        {
            Name = command;
            Command = command;
            ExpectedBegin = begin;
            ExpectedEnd = DefaultEnd;
        }

        public TestBase_MgmtStats (string command, string begin, string sub)
        {
            Name = command;
            Command = command;
            ExpectedBegin = begin;
            ExpectedEnd = DefaultEnd;
            ExpectedSubstring = sub;
        }

        public TestBase_MgmtStats (string command, string begin, string end, string whole, string sub)
        {
            Name = command;
            Command = command;
            ExpectedBegin = begin;
            ExpectedEnd = end;
            ExpectedWhole = whole;
            ExpectedSubstring = sub;
        }

        public override void Run ()
        {
            // sign in a client before
            SgClient preclient = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));
            try
            {
                preclient.SignInSG();
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                throw new UnexpectedTestResultException("Could not sign client in before running the command.");
            }

            string machinepuid = "0x" + preclient.Context.Authdata.XboxID.ToString("X16");
            string spi = "0x" + preclient.KeyexResult.keyexResp.SpiResp.ToString("X8");

            SgServerInfo server = SgServerInfo.Servers[0];
            string output = "";

            bool result = ServerTestFramework.LiveService.ManagementConsole.Execute(server.XmgmtIp,
                "e :sg " + Command.Replace("%mpuid%", machinepuid).Replace("%spi%", spi), 
                out output);

            if (!result)
            {
                Global.RO.Error("Xmgmt command execution failed, details below:" +
                    "\n  Server  : " + server.Name +
                    "\n  Command : " + Command +
                    "\n  Response: " + (output == null ? "<null>" : output));
                throw new UnexpectedTestResultException("Xmgmt command execution failed: " + (output == null ? "<null>" : output));
            }
            else if (!TestBase_Mgmt.IsStillSignedIn(preclient))
            {
                Global.RO.Error("Client was not signed in after xmgmt execution:" +
                    "\n  Server  : " + server.Name +
                    "\n  Command : " + Command +
                    "\n  Response: " + (output == null ? "<null>" : output) +
                    "\n  Client  : Puid[" + machinepuid + "] Spi[" + spi + "]");
                throw new UnexpectedTestResultException("Client was not signed in after xmgmt execution");
            }

            // attempt to sign in again
            SgClient postclient = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));
            try
            {
                postclient.SignInSG();
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                throw new UnexpectedTestResultException("Could not sign client in after running the command.");
            }

            // check expected strings
            bool failure = false;

            if (ExpectedBegin != null)
            {
                string temp = ExpectedBegin.Replace("%mpuid%", machinepuid).Replace("%spi%", spi);
                if (!output.StartsWith(temp))
                {
                    Global.RO.Error("Response did not match expectations:" +
                        "\n  Server  : " + server.Name +
                        "\n  Command : " + Command +
                        "\n  Begins  : " + temp +
                        "\n  Response: " + output);
                    failure = true;
                }
            }

            if (ExpectedEnd != null)
            {
                string temp = ExpectedEnd.Replace("%mpuid%", machinepuid).Replace("%spi%", spi);
                if (!output.EndsWith(temp))
                {
                    Global.RO.Error("Response did not match expectations:" +
                        "\n  Server  : " + server.Name +
                        "\n  Command : " + Command +
                        "\n  Ends    : " + temp +
                        "\n  Response: " + output);
                    failure = true;
                }
            }

            if (ExpectedWhole != null)
            {
                string temp = ExpectedWhole.Replace("%mpuid%", machinepuid).Replace("%spi%", spi);
                if (output != temp)
                {
                    Global.RO.Error("Response did not match expectations:" +
                        "\n  Server  : " + server.Name +
                        "\n  Command : " + Command +
                        "\n  Matches : " + temp +
                        "\n  Response: " + output);
                    failure = true;
                }
            }

            if (ExpectedSubstring != null)
            {
                string temp = ExpectedSubstring.Replace("%mpuid%", machinepuid).Replace("%spi%", spi);
                if (!output.Contains(temp))
                {
                    Global.RO.Error("Response did not match expectations:" +
                        "\n  Server  : " + server.Name +
                        "\n  Command : " + Command +
                        "\n  Contains: " + temp +
                        "\n  Response: " + output);
                    failure = true;
                }
            }

            if (failure)
            {
                if (SgEnvironmentInfo.IsXblob && Command.StartsWith("stats"))
                {
                    throw new DidNotExecuteException("Client stats are disabled by default on xblobs.");
                }

                throw new UnexpectedTestResultException("Response did not match expectations");
            }
        }

        private bool CheckForSPI (string s)
        {
            return (s == null ? false : s.Contains("%spi%"));
        }

        /// <summary>
        /// A rather dubious function that uses xmgmt to get the SPI for a machine puid.
        /// </summary>
        private string GetSPIFromXMGMT (string machinepuid)
        {
            SgServerInfo server = SgServerInfo.Servers[0];
            string output = "";

            try
            {
                if (ServerTestFramework.LiveService.ManagementConsole.Execute(server.XmgmtIp,
                    "e :sg stats mpuid " + machinepuid, out output))
                {
                    return output.Substring(48, 10);
                }
            }
            catch (Exception e)
            {
                Global.RO.Debug(e.Message);
            }

            return String.Empty;
        }
    }

    [TestGroup, TestCasePriority(3)]
    public class Mgmt : TestNode
    {
        public Mgmt ()
        {
            // TestBase_MgmtStats (command, begin, end, whole, sub)
            AddChildAsyncGroup(new TestBase_MgmtStats("numconnections", null, null, null, "connections active out of"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats", "OverallStats: Total packets over", "StdDev"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats histogram", "Statistics summary for", "XONLINE_PRESENCE_SERVICE"), 1);

            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid", "Operation failed: invalid params", null, null, null), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid 0", "Machine puid 0x0000000000000000 not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid 0x0", "Machine puid 0x0000000000000000 not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid -1", "Machine puid 0xFFFFFFFFFFFFFFFF not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid 57", "Machine puid 0x0000000000000039 not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid 0xffffffffffffffff", "Machine puid 0xFFFFFFFFFFFFFFFF not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid 0xfffffffffffffffff", "Machine puid 0xFFFFFFFFFFFFFFFF not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid 0xfffffffffffffffffffffffffffff", "Machine puid 0xFFFFFFFFFFFFFFFF not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid notevenanumber", "Machine puid 0x0000000000000000 not found"), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats mpuid %mpuid%", "Machine stats for mpuid %mpuid%, spi %spi%", "SECMSG"), 1);

            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi", "Operation failed: invalid params", null, null, null), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi 0", "Spi 0x00000000 is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi 0x0", "Spi 0x00000000 is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi -1", "Spi 0xFFFFFFFF is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi 57", "Spi 0x00000039 is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi 0xffffffff", "Spi 0xFFFFFFFF is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi 0xfffffffff", "Spi 0xFFFFFFFF is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi 0xfffffffffffffffffff", "Spi 0xFFFFFFFF is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi thisisntanumber", "Spi 0x00000000 is not active."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats spi %spi%", "Machine stats for mpuid %mpuid%, spi %spi%", "Total Packets History"), 1);

            AddChildAsyncGroup(new TestBase_MgmtStats("stats warnings", "All clients that are currently in their warning period", "clients in the penalty box."), 1);
            AddChildAsyncGroup(new TestBase_MgmtStats("stats reset", "Global stats have been reset for all packet types."), 1);
        }

        private void AddChildAsyncGroup(TestNode node, int asyncGroup)
        {
            AddChild(node);
            node.FunctionalData.AsyncGroup=asyncGroup;
        }

        [TestCase, TestCasePriority(1)] 
        class Mgmt_ReloadConfig_Simple : TestBase_Mgmt
        {
            override protected void RunTest()
            {
                // Just issue a reload_config command, then sign in a user to make sure 
                // all is OK.

                DoXmgmtReloadConfig();
            }
        }

        [TestCase, TestCasePriority(1)] 
        class Mgmt_ReloadConfig_1Machines : TestBase_Mgmt
        {
            override protected void RunTest()
            {
                SignInMachines(1); 
                DoXmgmtReloadConfig();
            }
        }

        [TestCase, TestCasePriority(1)] 
        class Mgmt_ReloadConfig_2Machines : TestBase_Mgmt
        {
            override protected void RunTest()
            {
                SignInMachines(2); 
                DoXmgmtReloadConfig();
            }
        }

        [TestCase, TestCasePriority(1)] 
        class Mgmt_ReloadConfig_100Machines : TestBase_Mgmt
        {
            override protected void RunTest()
            {
                SignInMachines(100); 
                DoXmgmtReloadConfig();
            }
        }

        [TestCase, TestCasePriority(1)]
        class Mgmt_ReloadChallenges_Simple : TestBase_Mgmt
        {
            override protected void RunTest ()
            {
                ChalManager.AddScript(new LuaScript()
                {
                    Name = Name,
                    Script = "FilterDeclare(\"" + Name + "\")\nfunction ApplyFilter ()\nend"
                }, false);

                try
                {
                    SgServerInfo.ReloadChallenges();

                    SgServerInfo server = SgServerInfo.Servers[0];
                    string output = "";

                    bool result = ServerTestFramework.LiveService.ManagementConsole.Execute(server.XmgmtIp,
                        "e :sg list_challenges", out output);

                    if (!result)
                    {
                        Global.RO.Error("Xmgmt command execution failed, details below:" +
                            "\n  Server  : " + server.Name +
                            "\n  Command : list_challenges" + 
                            "\n  Response: " + (output == null ? "<null>" : output));
                        throw new UnexpectedTestResultException("Xmgmt command execution failed: " + (output == null ? "<null>" : output));
                    }

                    if (!output.Contains(Name))
                    {
                        Global.RO.Error("Our lua script was not reloaded by reload_challenges:" +
                            "\n  Server  : " + server.Name +
                            "\n  Command : list_challenges" +
                            "\n  Response: " + (output == null ? "<null>" : output) +
                            "\n  Expected: " + Name);
                        throw new UnexpectedTestResultException("Our lua script was not reloaded by reload_challenges");
                    }
                }
                finally
                {
                    ChalManager.RemoveAllScripts();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncNotifications.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
 
namespace XSGTest
{

    [TestGroup, TestCasePriority(1)]
    public class Notifications : TestNode
    {

        public const string InterfaceName = "SgNotificationsTest";
        protected ComponentEditor Component;
        protected InterfaceEditor Interface;
        protected VirtualInterfaceEditor VirtualInterface;

        protected const int Port = 8181;
        protected const string BaseUrl = "/" + InterfaceName + "/";
        protected const string HealthUrl = BaseUrl + "health.ashx";
        protected HttpListener Listener;

        public override void PreRun ()
        {
            // null out an old editors we might have had
            Listener = null;
            Component = null;
            Interface = null;
            VirtualInterface = null;
            NotificationsByMachine = new Dictionary<ulong, List<Notification>>();

            // check to see if we can use HttpListener
            if (!HttpListener.IsSupported)
            {
                throw new DidNotExecuteException("Unable to use HttpListener on this operating system.");
            }

            // poke a hole in the firewall
            ProcessWrapper netsh = new ProcessWrapper("netsh", "netsh");
            netsh.Run("advfirewall firewall add rule name=" + InterfaceName + " dir=in protocol=tcp localport=" + Port + " action=allow");
            string netshOut = netsh.Output;
            Global.RO.Debug("Netsh Output:\n" + netshOut);
            if (!netshOut.StartsWith("Ok."))
            {
                throw new DidNotExecuteException("Could not open a hole in the firewall.");
            }

            // create an http listener
            Listener = new HttpListener();
            Listener.Prefixes.Add("http://+:" + Port + BaseUrl);
            Listener.Start();
            Listener.BeginGetContext(ListenerCallback, null);

            // create an interface for us to receive notifications on
            Component = ComponentEditor.CreateOrOverwrite(InterfaceName, "NOINSTALLUNIT", null, null, null, null, null);
            Interface = InterfaceEditor.CreateOrOverwrite(InterfaceName, InterfaceName, "middle_tier", "http", Port, null,
                null, null, null, null, null, 30000, 28, "XONLINE_TEST_FD_SERVICE", false, null, null, null, null, null, null);
            VirtualInterface = VirtualInterfaceEditor.CreateOrOverwrite(InterfaceName, InterfaceName, Port, null, null, null,
                30000, null, null, null, null);

            // set the notification urls
            Interface.SetNotificationUrl(InterfaceEditor.NotificationType.DeadXbox, BaseUrl + "deadxbox");
            Interface.SetNotificationUrl(InterfaceEditor.NotificationType.TitleChange, BaseUrl + "titlechange");
            Interface.SetNotificationUrl(InterfaceEditor.NotificationType.UserChange, BaseUrl + "userchange");
            Interface.SetNotificationUrl(InterfaceEditor.NotificationType.XboxStateChange, BaseUrl + "xboxstatechange");
            Interface.SetNotificationUrl(InterfaceEditor.NotificationType.SpiUpdate, BaseUrl + "spiupdate");

            // set the IP to send to
            InterfaceEditor sgInterface = InterfaceEditor.FromName(xonline.common.config.Interface.sgsvc);
            List<string> servers = sgInterface.GetServerList();
            if (servers.Count == 0)
            {
                throw new DidNotExecuteException("No servers listed for sgsvc.");
            }
            ServerEditor server = ServerEditor.FromName(servers[0]);
            IPAddress sgIp = server.GetServiceNicIp("middle_tier");
            if (sgIp == null)
            {
                throw new DidNotExecuteException("No middle_tier nic for sgsvc server " + server.Name + ".");
            }

            string ip = IpHelper.GetBestInterface(sgIp).ToString();
            VirtualInterface.SetVirtualInterfaceIp(ip);

            // create the health check url
            VirtualInterface.AddOrUpdateXrl(HealthUrl, false, false, false, 0, 0, 0, false, false, false, false, false, "GET");

            // force a reload via config
            SgEnvironmentInfo.ConfigCacheRefresh();
            SgServerInfo.ReloadConfiguration();
        }

        public override void PostRun ()
        {
            if (VirtualInterface != null)
            {
                VirtualInterface.DeleteXrl(HealthUrl);
                VirtualInterface.Delete();
                VirtualInterface = null;
            }

            if (VirtualInterface != null)
            {
                VirtualInterface.Delete();
                VirtualInterface = null;
            }

            if (Interface != null)
            {
                Interface.Delete();
                Interface = null;
            }

            if (Component != null)
            {
                Component.Delete();
                Component = null;
            }

            // force a reload via config, then wait for the reload before shutting down the listener
            SgEnvironmentInfo.ConfigCacheRefresh();
            SgServerInfo.ReloadConfiguration();

            if (Listener != null)
            {
                Listener.Abort();
                Listener = null;
            }

            // close the hole in the firewall
            ProcessWrapper netsh = new ProcessWrapper("netsh", "netsh");
            netsh.Run("advfirewall firewall delete rule name=" + InterfaceName + " dir=in protocol=tcp localport=" + Port);
            string netshOut = netsh.Output;
            Global.RO.Debug("Netsh Output:\n" + netshOut);
            if (!netshOut.Contains("Ok."))
            {
                throw new DidNotExecuteException("Could not close the hole in the firewall.");
            }
        }

        /// <summary>
        /// Callback for the HTTP listener.
        /// </summary>
        private void ListenerCallback (IAsyncResult result)
        {
            // we are aborting
            if (Listener == null)
            {
                return;
            }

            HttpListenerContext context = null;

            try
            {
                // set the thread context to the test group
                ThreadTracker.SetTest(FullName);

                if (result == null)
                {
                    return;
                }

                // get the actual request
                context = Listener.EndGetContext(result);

                // process the request (copy it out)
                HttpListenerRequest request = context.Request;
                Notification.NotificationType type;
                switch (request.Url.AbsolutePath)
                {
                    case BaseUrl + "deadxbox": type = Notification.NotificationType.DeadXbox; break;
                    case BaseUrl + "titlechange": type = Notification.NotificationType.TitleChange; break;
                    case BaseUrl + "userchange": type = Notification.NotificationType.UserChange; break;
                    case BaseUrl + "xboxstatechange": type = Notification.NotificationType.XboxStateChange; break;
                    case BaseUrl + "spiupdate": type = Notification.NotificationType.SpiUpdate; break;
                    case HealthUrl: type = Notification.NotificationType.Health; break;
                    default: type = Notification.NotificationType.Unknown; break;
                }

                if (type != Notification.NotificationType.Unknown && type != Notification.NotificationType.Health)
                {

                    BinaryReader input = new BinaryReader(request.InputStream);
                    SgMsgNotifyHeader sgmsg = null;

                    try
                    {
                        while (true)
                        {
                            sgmsg = Notification.CreateNotificationObject(type);
                            sgmsg.ReadStream(input);

                            ulong machineId = sgmsg.SgAddr.XboxID;
                            Notification noti = new Notification() { Type = type, Machine = machineId, Message = sgmsg };

                            lock (NotificationsByMachine)
                            {
                                List<Notification> notis = null;
                                if (NotificationsByMachine.TryGetValue(machineId, out notis))
                                {
                                    notis.Add(noti);
                                }
                                else
                                {
                                    notis = new List<Notification>();
                                    notis.Add(noti);
                                    NotificationsByMachine.Add(machineId, notis);
                                }
                            }
                        }
                    }
                    catch (xonline.common.service.XRLException e)
                    {
                        if (e.InnerException.GetType() == typeof(EndOfStreamException))
                        {
                            int msgSize = sgmsg.Size();
                            long msgCount = request.ContentLength64 / msgSize;
                            if (msgCount * msgSize != request.ContentLength64)
                            {
                                Global.RO.Warn("Request body did not contain an integral number of messages: " +
                                    "MsgSize {0} FullMsgCount {1} TheseBytes {2} ActualBytes {3}",
                                    msgSize, msgCount, msgSize * msgCount, request.ContentLength64);
                            }
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
                else if (type == Notification.NotificationType.Unknown)
                {
                    Global.RO.Warn("Got unknown notification type: " + request.RawUrl);
                }
            }
            catch (Exception e)
            {
                // if Listener is null, we were shutting down, ignore
                if (Listener != null)
                {
                    Global.RO.Error("Got exception in ListenerCallback main body:\n" + e.ToString());
                }
            }

            try
            {
                if (context != null)
                {
                    // always respond with 200
                    HttpListenerResponse response = context.Response;
                    response.StatusCode = (int)HttpStatusCode.OK;
                    response.Close();
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Got exception in ListenerCallback responder:\n" + e.ToString());
            }

            try
            {
                Listener.BeginGetContext(ListenerCallback, null);
            }
            catch (Exception e)
            {
                // if Listener is null, we were shutting down, ignore
                if (Listener != null)
                {
                    Global.RO.Error("Got exception in ListenerCallback begin next recieve:\n" + e.ToString());
                }
            }
        }

        public class Notification
        {
            public enum NotificationType
            {
                Unknown,
                DeadXbox,
                TitleChange,
                UserChange,
                XboxStateChange,
                SpiUpdate,
                Health
            }

            public NotificationType Type;
            public ulong Machine;
            public SgMsgNotifyHeader Message;
            public bool Found;

            public static SgMsgNotifyHeader CreateNotificationObject (NotificationType type)
            {
                switch (type)
                {
                    case NotificationType.DeadXbox: return new SgMsgNotifyCliDelete();
                    case NotificationType.TitleChange: return new SgMsgNotifyCliTitleChange();
                    case NotificationType.UserChange: return new SgMsgNotifyCliUserChange();
                    case NotificationType.XboxStateChange: return new SgMsgNotifyCliUpdate();
                    case NotificationType.SpiUpdate: return new SgMsgNotifySpiUpdate();
                }

                return null;
            }

            public override string ToString ()
            {
                return string.Format("{0} for 0x{1:X16} [{2}Found]\n{3}", Type, Machine, (Found ? "" : "Not "), Message);
            }
        }

        protected Dictionary<ulong, List<Notification>> NotificationsByMachine;

        public Notification[] GetNotificationsForMachine (ulong machineId)
        {
            lock (NotificationsByMachine)
            {
                List<Notification> notis = null;
                if (NotificationsByMachine.TryGetValue(machineId, out notis))
                {
                    return notis.ToArray();
                }
                else
                {
                    return new Notification[0];
                }
            }
        }

        public class NotificationTestNode : SgConnectionTestNode
        {
            protected List<SgMsgNotifyHeader> Expected;
            protected long? LifetimeInMS = null;

            #region TestNode Runners

            public override void PreRun ()
            {
                base.PreRun();

                Expected = new List<SgMsgNotifyHeader>();

                if (LifetimeInMS != null)
                    Sg.Context.TicketLifetimeInMS = (long)LifetimeInMS; 
                
                Sg.UseConnectionServices = true;
                Sg.Connect();
                AddUserChange(true);
            }

            public override void Run ()
            {
                WaitForNotifications();
                Notification[] notis = GetNotifications();
                Verify(notis);
            }

            public override void PostRun ()
            {
                if (Sg.State == SGConnection.ConnectionState.Connected)
                {
                    Sg.Disconnect();
                }
            }

            #endregion

            #region Authdata Utilities

            protected void SendChangeUsers ()
            {
                Sg.SendChangeUsers();
                do
                {
                    Thread.Sleep(100);
                    Sg.ProcessReceiveQueue();
                    Sg.ProdChangeUsers();
                } while (Sg.ChangeUsersPending);
            }

            protected XUserID CreateNewUser ()
            {
                XUserID ans = new XUserID();
                ans.SetDefaults();
                return ans;
            }

            protected Authdata_Base Authdata
            {
                get { return Sg.Context.Authdata; }
            }

            #endregion

            #region Expected Notification Utilities

            protected void AddUserChange (bool added)
            {
                SgMsgNotifyCliUserChange change = new SgMsgNotifyCliUserChange();
                change.Users = new ulong[4];
                for (uint i = 0; i < 4; ++i)
                {
                    change.Users[i] = Sg.Context.Authdata.GetUser(i).qwUserID;
                }
                change.InternetIp = new IpAddr(SgServerInfo.BestInterfaceForVip.GetAddressBytes());
                change.Flags = (added ? SgMsgNotifyCliUserChange.SECMSG_CLIUSERCHANGE_TYPE_ADD :
                    SgMsgNotifyCliUserChange.SECMSG_CLIUSERCHANGE_TYPE_DEL);

                Expected.Add(change);
            }

            protected void AddUserChange (bool added, params ulong[] users)
            {
                SgMsgNotifyCliUserChange change = new SgMsgNotifyCliUserChange();
                change.Users = new ulong[4];
                Array.Copy(users, change.Users, Math.Min(users.Length, change.Users.Length));
                change.InternetIp = new IpAddr(SgServerInfo.BestInterfaceForVip.GetAddressBytes());
                change.Flags = (added ? SgMsgNotifyCliUserChange.SECMSG_CLIUSERCHANGE_TYPE_ADD :
                    SgMsgNotifyCliUserChange.SECMSG_CLIUSERCHANGE_TYPE_DEL);

                Expected.Add(change);
            }

            protected void AddDelete ()
            {
                SgMsgNotifyCliDelete delete = new SgMsgNotifyCliDelete();
                delete.TitleId = Sg.Context.Authdata.TitleId;

                Expected.Add(delete);
            }

            protected void AddTitleChange (uint oldTitle)
            {
                SgMsgNotifyCliTitleChange change = new SgMsgNotifyCliTitleChange();
                change.OldTitleId = oldTitle;
                change.NewTitleId = Sg.Context.Authdata.TitleId;

                Expected.Add(change);
            }

            protected void AddSpiUpdate(uint oldSpi)
            {
                SgMsgNotifySpiUpdate update = new SgMsgNotifySpiUpdate();
                update.OldSpi = oldSpi;

                Expected.Add(update);
            }

            #endregion

            #region Receive and Verify

            protected void WaitForNotifications ()
            {
                Thread.Sleep(6000);
            }

            protected Notification[] GetNotifications ()
            {
                TestNode parent = Parent;
                Notifications notis = parent as Notifications;
                while (parent != null && notis == null)
                {
                    parent = parent.Parent;
                    notis = parent as Notifications;
                }

                if (notis == null)
                {
                    throw new UnexpectedTestResultException("Could not find a Notifications ancestor.");
                }

                return notis.GetNotificationsForMachine(Sg.Context.Authdata.XboxID);
            }

            protected void Verify (IEnumerable<Notification> notis)
            {
                try
                {
                    // we can only guarantee that notifications of the same type are in order, so process each seperately
                    Verify(notis, Notification.NotificationType.DeadXbox);
                    Verify(notis, Notification.NotificationType.TitleChange);
                    Verify(notis, Notification.NotificationType.UserChange);
                    Verify(notis, Notification.NotificationType.XboxStateChange);
                    Verify(notis, Notification.NotificationType.SpiUpdate);

                    foreach (Notification noti in notis)
                    {
                        if (!noti.Found)
                        {
                            throw new UnexpectedTestResultException("Unexpected notification:\n" + noti.ToString());
                        }
                    }
                }
                catch
                {
                    SpewExpected(Expected);
                    SpewNotifications(notis);
                    throw;
                }
            }

            protected void Verify (IEnumerable<Notification> notis, Notification.NotificationType type)
            {
                short sgmsgType = 0;

                switch (type)
                {
                    case Notification.NotificationType.DeadXbox: sgmsgType = SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_DEL; break;
                    case Notification.NotificationType.TitleChange: sgmsgType = SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_TCHG; break;
                    case Notification.NotificationType.UserChange: sgmsgType = SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_UCHG; break;
                    case Notification.NotificationType.XboxStateChange: sgmsgType = SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_UPD; break;
                    case Notification.NotificationType.SpiUpdate: sgmsgType = SgMsgHeader.SGMSG_TYPE_NOTIFY_SPI_UPD; break;
                }

                foreach (SgMsgNotifyHeader expected in Expected)
                {
                    // only look at expected ones for this type
                    if (expected.Type == sgmsgType)
                    {
                        bool found = false;

                        foreach (Notification noti in notis)
                        {
                            // only check ones that have not been found yet
                            if (noti.Type == type && !noti.Found)
                            {
                                // we found a notification
                                found = true;

                                Verify(expected, noti.Message);
                                noti.Found = true;
                                break;
                            }
                        }

                        if (!found)
                        {
                            throw new UnexpectedTestResultException("Could not find expected notification:\n" +
                                expected.ToString());
                        }
                    }
                }
            }

            protected void Verify (SgMsgNotifyHeader expected, SgMsgNotifyHeader actual)
            {
                ValueCheck.Test("Notification Type", expected.Type, actual.Type);
                ValueCheck.Test("Notification Size", expected.cbEnt, actual.cbEnt);
                ValueCheck.Test("Notification Xbox Id", Sg.Context.Authdata.XboxID, actual.SgAddr.XboxID);

                switch (expected.Type)
                {
                    case SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_DEL:
                        {
                            SgMsgNotifyCliDelete expectedSpecific = (SgMsgNotifyCliDelete)expected;
                            SgMsgNotifyCliDelete actualSpecific = (SgMsgNotifyCliDelete)actual;

                            ValueCheck.Test("Delete Title Id", expectedSpecific.TitleId, actualSpecific.TitleId);
                        }
                        break;

                    case SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_TCHG:
                        {
                            SgMsgNotifyCliTitleChange expectedSpecific = (SgMsgNotifyCliTitleChange)expected;
                            SgMsgNotifyCliTitleChange actualSpecific = (SgMsgNotifyCliTitleChange)actual;

                            ValueCheck.Test("TitleChange Old Title Id", expectedSpecific.OldTitleId, actualSpecific.OldTitleId);
                            ValueCheck.Test("TitleChange New Title Id", expectedSpecific.NewTitleId, actualSpecific.NewTitleId);
                        }
                        break;

                    case SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_UCHG:
                        {
                            SgMsgNotifyCliUserChange expectedSpecific = (SgMsgNotifyCliUserChange)expected;
                            SgMsgNotifyCliUserChange actualSpecific = (SgMsgNotifyCliUserChange)actual;

                            ValueCheck.TestAllUnordered("UserChange Users", expectedSpecific.Users, actualSpecific.Users);
                            ValueCheck.Test("UserChange Ip", expectedSpecific.InternetIp, actualSpecific.InternetIp);
                            ValueCheck.Test("UserChange Flags", expectedSpecific.Flags, actualSpecific.Flags);
                        }
                        break;

                    case SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_UPD:
                        {
                            SgMsgNotifyCliUpdate expectedSpecific = (SgMsgNotifyCliUpdate)expected;
                            SgMsgNotifyCliUpdate actualSpecific = (SgMsgNotifyCliUpdate)actual;

                            ValueCheck.Test("Update User", expectedSpecific.UserId, actualSpecific.UserId);
                            ValueCheck.Test("Update Xnkid", expectedSpecific.Xnkid, actualSpecific.Xnkid);
                            ValueCheck.Test("Update AuthFlags", expectedSpecific.AuthFlags, actualSpecific.AuthFlags);
                            ValueCheck.Test("Update State", expectedSpecific.State, actualSpecific.State);
                            ValueCheck.Test("Update TitleId", expectedSpecific.TitleId, actualSpecific.TitleId);
                            ValueCheck.Test("Update TitleDataSize", expectedSpecific.TitleDataSize, actualSpecific.TitleDataSize);
                            ValueCheck.Test("Update TitleData", expectedSpecific.TitleData, actualSpecific.TitleData);
                        }
                        break;

                    case SgMsgHeader.SGMSG_TYPE_NOTIFY_SPI_UPD:
                        {
                            SgMsgNotifySpiUpdate expectedSpecific = (SgMsgNotifySpiUpdate)expected;
                            SgMsgNotifySpiUpdate actualSpecific = (SgMsgNotifySpiUpdate)actual;

                            ValueCheck.Test("Update Spi", expectedSpecific.OldSpi, actualSpecific.OldSpi);
                        }
                        break;
                }
            }

            protected void SpewNotifications (IEnumerable<Notification> notis)
            {
                Global.RO.Debug("====== Received Notifications for {0} ======", FullName);
                foreach (Notification noti in notis)
                {
                    Global.RO.Debug(noti.ToString());
                }
                Global.RO.Debug("============================================");
            }

            protected void SpewExpected (IEnumerable<SgMsgNotifyHeader> msgs)
            {
                Global.RO.Debug("====== Expected Notifications for {0} ======", FullName);
                foreach (SgMsgNotifyHeader msg in msgs)
                {
                    Global.RO.Debug(msg.ToString());
                }
                Global.RO.Debug("============================================");
            }

            #endregion
        }
       
        [TestCase, Description("Verify delete notification")]
        class Simple_DeleteNotification : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                sg.SendDelete();
            }
        }
        
        [TestCase, Description("Verify update notification")]
            class Simple_UpdateNotification : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                sg.SendDataPulseStateChange(1);
            }
        }

        [TestCase, Description("Verify title change notification")]
            class Simple_TitleChangeNotification : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // Log Xbox ID so we can look it up in the SG logs
                Authdata_Base ad = sg.Context.Authdata;
                ro.Debug("Before TitleChange: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{1:X16}",
                    ad.TitleId,
                    ad.XboxID,
                    ad.GetUser(0).qwUserID);

                // Set new info and build the TGS ticket
                ad.TitleId++;
                sg.BuildFakeTicket(ad);

                if (!sg.SendChangeUsers())
                {
                    Fail("SendChangeUsers failed, qwXboxID=0x{0:X}", ad.XboxID);
                    return;
                }

                ro.Debug(" After TitleChange: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{1:X16}",
                    ad.TitleId,
                    ad.XboxID,
                    ad.GetUser(0).qwUserID);

                //sg.SendDataPulseTitleChange(0xC0FE0801);                
            }
        }

        [TestCase, TestCasePriority(3), Description("Verify delete notification batching")]
        class Batch_Delete_200: TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // This is not multi-threaded - thus we won't test any race conditions
                // Sign in 200 clients
                SgClient[] sgs = new SgClient[200];
                ro.Debug("Creating and signing in 200 clients...");
                for (int i = 0; i < sgs.Length; i++)
                {
                    sgs[i] = new SgClient(new AuthContext(clientType));
                    sgs[i].Context.Site = SiteInfoManager.GetDefaultSgSite();
                    sgs[i].Context.Authdata = Authdata_Base.NewDefaultFromSite(sgs[i].Context.Site);
                    sgs[i].Context.SetUser("sgtestuser0", 0);
                    sgs[i].bUseConnectionServices = true;
                    sgs[i].SetDefaultAuthdata(sgs[i].Context.Authdata);
                    sgs[i].FakeSignInXkdc();
                    try
                    {
                        sgs[i].SignInSG();
                    }
                    catch
                    {
                        ro.Debug("Error with sgclient #{0} of 200", i);
                        throw;
                    }
                }

                // Sign them all out very quickly
                ro.Debug("Now signing them out very quickly...");
                for (int i = 0; i < sgs.Length; i++)
                {
                    sgs[i].SendDelete();
                }
            }
        }


        [TestCase, TestCasePriority(3), Description("Verify update notification batching")]
        class Batch_Update_AndDelete_200: TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // This is not multi-threaded - thus we won't test any race conditions
                // Sign in 200 clients
                SgClient[] sgs = new SgClient[200];
                ro.Debug("Creating and signing in 200 clients...");
                for (int i = 0; i < sgs.Length; i++)
                {
                    sgs[i] = new SgClient(new AuthContext(clientType));
                    sgs[i].Context.Site = SiteInfoManager.GetDefaultSgSite();
                    sgs[i].Context.Authdata = Authdata_Base.NewDefaultFromSite(sgs[i].Context.Site);
                    sgs[i].Context.SetUser("sgtestuser0", 0);
                    sgs[i].bUseConnectionServices = true;
                    sgs[i].SetDefaultAuthdata(sgs[i].Context.Authdata);
                    sgs[i].FakeSignInXkdc();
                    try
                    {
                        sgs[i].SignInSG();
                    }
                    catch
                    {
                        ro.Debug("Error with sgclient #{0} of 200", i);
                        throw;
                    }
                }

                // 
                ro.Debug("Now update them very quickly...");
                for (int i = 0; i < sgs.Length; i++)
                {
                    sgs[i].SendDataPulseStateChange((uint)i);
                    sgs[i].SendDelete();
                }
            }
        }

        [TestGroup, Description("Tests for the User Change notification.")]
        [AsyncGroup(1, 1)]
        public class UserChange : TestNode
        {

            [TestCase, Description("Signs in and out.")]
            public class Basic : NotificationTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Disconnect();
                    AddDelete();
                    AddUserChange(false);
                }
            }

            [TestCase, Description("Reinit.")]
            public class Reinit : NotificationTestNode
            {
                public override void PreRun()
                {
                    base.PreRun();

                    uint oldSpi = 0;
                    oldSpi = Sg.Session.TransmitSPI;

                    Sg.SetDisconnected();
                    Thread.Sleep(1000);
                    Sg.Connect();

                    uint newSpi = 0;
                    newSpi = Sg.Session.TransmitSPI;

                    // make sure the new spi is different from the old spi
                    ValueCheck.TestDifferent("oldSpi", oldSpi, newSpi);

                    // this should cause a user change DEL, ADD, DeadXbox and SpiUpdate
                    AddUserChange(false);
                    AddUserChange(true);
                    AddDelete();
                    AddSpiUpdate(oldSpi);
                }
            }

            [TestCase, Description("A title change should not cause a user change message.")]
            public class TitleChange : NotificationTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    // this should not cause a user change notification
                    Authdata.TitleId++;
                    SendChangeUsers();
                    AddTitleChange(Sg.Context.Authdata.TitleId - 1);
                }
            }

            [TestCase, Description("A non-user change should not cause a user change message.")]
            public class OtherChange : NotificationTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    // this should not cause a user change notification
                    Authdata.BuildNumber += 1;
                    SendChangeUsers();
                }
            }

            [TestCase, Description("Add a user.")]
            public class AddUser : NotificationTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    XUserID newUser = CreateNewUser();
                    Authdata.SetUser(1, newUser);
                    SendChangeUsers();
                    AddUserChange(true, newUser.qwUserID);
                }
            }

            [TestCase, Description("Remove a user.")]
            public class RemoveUser : NotificationTestNode
            {
                public override void PreRun ()
                {
                    DefaultUserCount = 2;

                    base.PreRun();

                    XUserID oldUser = Authdata.GetUser(0);
                    Authdata.SetUser(0, new XUserID());
                    SendChangeUsers();
                    AddUserChange(false, oldUser.qwUserID);
                }
            }

            [TestCase, Description("Switch the user.")]
            public class SwitchUser : NotificationTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    XUserID oldUser = Authdata.GetUser(0);
                    XUserID newUser = CreateNewUser();
                    Authdata.SetUser(0, newUser);
                    SendChangeUsers();
                    AddUserChange(false, oldUser.qwUserID);
                    AddUserChange(true, newUser.qwUserID);
                }
            }

            [TestCase, Description("Change the user slot, but not the user.")]
            public class SwitchUserSlot : NotificationTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    XUserID oldUser = Authdata.GetUser(0);
                    Authdata.SetUser(0, new XUserID());
                    Authdata.SetUser(1, oldUser);
                    SendChangeUsers();
                }
            }

            [TestCase, Description("Add, remove, and switch the users.")]
            public class AddRemoveAndSwitch : NotificationTestNode
            {
                public override void PreRun ()
                {
                    DefaultUserCount = 3;

                    base.PreRun();

                    XUserID removedUser = Authdata.GetUser(0);
                    XUserID newSwitchedUser = CreateNewUser();
                    XUserID oldSwitchedUser = Authdata.GetUser(1);
                    XUserID newUser = CreateNewUser();

                    Authdata.SetUser(0, new XUserID());
                    Authdata.SetUser(1, newSwitchedUser);
                    Authdata.SetUser(3, newUser);

                    SendChangeUsers();

                    AddUserChange(false, removedUser.qwUserID, oldSwitchedUser.qwUserID);
                    AddUserChange(true, newSwitchedUser.qwUserID, newUser.qwUserID);
                }
            }

            [TestCase, Description("Change all users.")]
            public class SwitchAllUsers : NotificationTestNode
            {
                public override void PreRun ()
                {
                    DefaultUserCount = 4;

                    base.PreRun();

                    XUserID[] oldUsers = new XUserID[4];
                    XUserID[] newUsers = new XUserID[4];

                    for (uint i = 0; i < 4; ++i)
                    {
                        oldUsers[i] = Authdata.GetUser(i);
                        newUsers[i] = CreateNewUser();
                        Authdata.SetUser(i, newUsers[i]);
                    }

                    SendChangeUsers();

                    AddUserChange(false, oldUsers[0].qwUserID, oldUsers[1].qwUserID, oldUsers[2].qwUserID, oldUsers[3].qwUserID);
                    AddUserChange(true, newUsers[0].qwUserID, newUsers[1].qwUserID, newUsers[2].qwUserID, newUsers[3].qwUserID);
                }
            }

            [TestCase, Description("Add a guest user.")]
            public class AddGuestUser : NotificationTestNode
            {
                public override void PreRun()
                {
                    base.PreRun();

                    XUserID guestUser = CreateNewUser();
                    guestUser.IsGuest = true;

                    // expect no notifications for the guest user
                    Authdata.SetUser(1, guestUser);
                    SendChangeUsers();
                }
            }

            [TestCase, Description("Remove a guest user.")]
            public class RemoveGuestUser : NotificationTestNode
            {
                public override void PreRun()
                {
                    // create authdata with a user and a guest
                    Sg = CreateNewConnection(ClientType, 2);

                    XUserID firstUser = Authdata.GetUser(0);
                    XUserID secondUser = Authdata.GetUser(1);
                    secondUser.IsGuest = true;

                    // connect
                    Sg.UseConnectionServices = true;
                    Sg.Connect();

                    // remove guest
                    Authdata.SetUser(1, new XUserID());
                    SendChangeUsers();

                    // should only see the notification for the first user (not guest)
                    Expected = new List<SgMsgNotifyHeader>();
                    AddUserChange(true);
                }
            }
            
            [TestCase, Description("Machine only, although you shouldnt be requesting CS with machine only.")]
            public class MachineOnly : NotificationTestNode
            {
                public override void PreRun ()
                {
                    // create authdata with 1 user, then remove them
                    Sg = CreateNewConnection(ClientType, 1);
                    Authdata.SetUser(0, new XUserID());
                    Sg.UseConnectionServices = true;

                    // connect and disconnect
                    Sg.Connect();
                    Sg.Disconnect();

                    // we shouldn't get any user change notifications
                    Expected = new List<SgMsgNotifyHeader>();
                    AddDelete();
                }
            }

            [TestCase, Description("Verify delete user and dead xbox message on ticket expiration.")]
            [CompoundCase("TicketLifeTime expiration",    15, 45, false)]
            [CompoundCase("TicketLifeTime no expiration", 3600, 10,  true)]
            public class LifetimeDroppedConnection : NotificationTestNode
            {
                public override void PreRun()
                {
                    int testLifetime = (int)MyValues[0] * 1000; // to milliseconds
                    int sleepTime = (int)MyValues[1] * 1000;

                    LifetimeInMS = (int?)testLifetime;

                    base.PreRun();
                    Thread.Sleep(sleepTime);

                    // verification of dropped connection
                    if (sleepTime > testLifetime)
                    {
                        // there should be events for deleting the xbox and the user
                        AddDelete();
                        AddUserChange(false);
                    }
                }

                public override void Run()
                {
                    // verify connection state
                    ValueCheck.Test("IsConnected", (bool)MyValues[2], IsStillSignedIn());

                    base.Run();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncPacketValidity.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.config;
 
namespace XSGTest
{
    public abstract class TestBase_Validity : TestBase_SgFake
    {
        public static RawNicSimpleUdp rawnic = new RawNicSimpleUdp();
        
        protected byte[] NoPayload = new byte[0];

        // payloadSize is allowed to be negative
        protected void SendUdp(int payloadSize)
        {
            int adjustedPayloadSize = payloadSize;
            if (payloadSize < 0)
            {
                adjustedPayloadSize = 0;
            }

            byte[] payload = new byte[adjustedPayloadSize];
            UdpPacket udp = ConstructPacket(payload);
            byte[] udpBytes = (byte[])udp;
            MemoryStream stream = new MemoryStream();

            if (payloadSize < 0)
            {
                stream.Write(udpBytes, 0, udpBytes.Length + payloadSize);
            }
            else
            {
                stream.Write(udpBytes, 0, udpBytes.Length);
            }
            rawnic.Send(stream.ToArray());
        }

        /// <summary>
        /// Sends the packet, recalculating the IP checksum.  Sets the UDP checksum to 0, meaning we are not using it.
        /// </summary>
        /// <param name="udp">The packet to send.</param>
        protected void SendWithChecksum(UdpPacket udp)
        {
            udp.Ip.DoChecksum();
            udp.Udp.Checksum = 0;
            rawnic.Send((byte[])udp);
        }

        protected void Send (UdpPacket udp)
        {
            rawnic.Send((byte[]) udp);
        }

        protected virtual UdpPacket ConstructPacket(byte[] payload)
        {
            return rawnic.ConstructPacket(payload);
        }

//        protected override void SetDefaults()
//        {
//            // do nothing
//        }
//
//        protected override void InitGroup()
//        {
//            // do nothing
//        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;

            // if we are signed in, sign out and get a new machine so we don't have to wait 1 second
            if (sg.IsSignedIn)
            {
                sg.SignOutSG();
                sg.GetNewMachine();
            }

            // Make sure the SG is still running and not in a crashed state
            try
            {
                DoKeyExchange();
            }
            catch (System.Net.Sockets.SocketException e)
            {
                if (e.ErrorCode == 10054)
                {
                    Global.RO.Warn("Got ICMP port unreachable twice, might want to check that the SG is still up, " +
                        "but this is probably just quick login/logout/login traffic pileup.");
                }
                else
                {
                    throw;
                }
            }

            return true;
        }

    }

    // These tests throw invalid packets at the SG.  We're not trying to key exchange or anything,
    // just send invalid UDP packets at it.  Verify by making sure the SG doesn't crash or get 
    // into an invalid state.
    [TestGroup, TestCasePriority(1)]
#if LSPTEST
    [CompoundCase("AuthData 3", 3)]
    [CompoundCase("AuthData 4", 4)]
#endif
    public class Packet_Validity : MultiAuthDataBase
    {
        protected static IPEndPoint SgIp;

        public override void PreRun ()
        {
            base.PreRun();

            Setup();
        }

        public static void Setup ()
        {
            SgIp = Global.XEnv.GetVirtualInterface(VirtualInterface.sgsvc);
            IpAddr ip_addr = new IpAddr(SgIp.Address.GetAddressBytes());
            Global.RO.Debug("Opening RAWNIC...");
            TestBase_Validity.rawnic.Open(ip_addr);
            Global.RO.Debug("Connecting to SG ip {0} port {1} using client port {2}", SgIp.ToString(), 3074, 2112);
            TestBase_Validity.rawnic.ConnectTo(ip_addr, 3074, 2112);
        }

        public override void PostRun ()
        {
            TearDown();

            base.PostRun();
        }

        public static void TearDown ()
        {
            try
            {
                Global.RO.Debug("Closing RAWNIC...");
                TestBase_Validity.rawnic.Close();
            }
            catch
            {
                // We don't care if this fails.. but we need to swallow the exception, otherwise
                // STFRunner will say this test suite failed.
            }
        }

        [TestCase, Description("Boundary conditions for buffer sizes")]
            class BufferSizes : TestBase_Validity
        {
            override protected void RunTest()
            {
                SendUdp(1473);
                SendUdp(1472);
                SendUdp(0);
                SendUdp(-1);
                SendUdp(1);

                SendUdp(-NetConstants.UDP_HDR_SIZE);
            }
        }


        [TestCase, Description("Change IP header length to boundary conditions")]
            class IpHeaderLengths : TestBase_Validity
        {
            override protected void RunTest()
            {
                UdpPacket udp = rawnic.ConstructPacket(NoPayload);
                ushort orig = udp.Ip.Len;
                
                udp.Ip.Len = (ushort)(orig + 1);
                SendWithChecksum(udp);

                udp.Ip.Len = (ushort)(orig + NetConstants.ENET_HDR_SIZE + 1);
                SendWithChecksum(udp);                
            }
        }
       
        [TestCase, Description("Change IP header version field (size byte) to boundary conditions")]
            class IpHeaderSize : TestBase_Validity
        {
            override protected void RunTest()
            {
                UdpPacket udp = rawnic.ConstructPacket(NoPayload);
                                
                udp.Ip.VerHdr = 0x46;  // translates into version 4, header length 24 (6*4)
                SendWithChecksum(udp);
                
                udp.Ip.VerHdr = 0x44;  // translates into version 4, header length 16 (4*4)
                SendWithChecksum(udp);
            }
        }
        
        [TestCase, Description("Change IP header version to all values")]
            class IpVersion : TestBase_Validity
        {
            override protected void RunTest()
            {
                UdpPacket udp = rawnic.ConstructPacket(NoPayload);
                for (int Ver = 0; Ver < 7; Ver++)
                {   
                    udp.Ip.VerHdr = (byte)((Ver * 16) + 5);
                    SendWithChecksum(udp);                    
                }
            }

        }

        [TestCase, Description("Send all frame types as broadcast")]
            class BadFrameBroadcast : TestBase_Validity
        {
            override protected void RunTest()
            {
                UdpPacket udp = rawnic.ConstructPacket(NoPayload);
                udp.Enet.eaDst = EnetAddr.Broadcast();
                for (int FrameType = 0; FrameType < 0xFF00; FrameType++)
                {
                    udp.Enet.Type = NetConstants.HTONS((ushort)FrameType);
                    SendWithChecksum(udp);
                }
            }
        }
    
        [TestCase, Description("Sends all frame types as unicast (SG's MAC address)")]
            class BadFrameUnicast : TestBase_Validity
        {
            override protected void RunTest()
            {
                UdpPacket udp = rawnic.ConstructPacket(NoPayload);
                for (int FrameType = 0; FrameType < 0xFF00; FrameType++)
                {
                    udp.Enet.Type = NetConstants.HTONS((ushort)FrameType);
                    SendWithChecksum(udp);
                }
            }
        }

        [TestCase, Description("Sends an XR owns packet to the SG.  With the AES changes this just generates an Unknown SPI log line.")]
        public class BadPacketType_Leak : TestBase_Validity
        {
            protected IPEndPoint SGIP = null;

            protected override void RunTest ()
            {
                SGIP = Global.XEnv.GetVirtualInterface("sgsvc");

                byte[] payload = ConstructPayload("You packet is leaked!!!");
                SimpleUdpSG udpsender = new SimpleUdpSG();

                udpsender.Send(payload, SGIP);
            }

            public static byte[] ConstructPayload (string message)
            {
                if (message == null) { message = string.Empty; }

                byte[] ans = new byte[104];

                for (int i = 0; i < 4; ++i) { ans[i] = 0xff; }
                for (int i = 0; i < message.Length; ++i) { ans[i + 4] = (byte) message[i]; }
                ans[4 + message.Length] = 0x00;
                for (int i = 5 + message.Length; i < ans.Length; ++i) { ans[i] = 0x01; }

                return ans;
            }
        }

        [TestCase, Description("Sends 1000 bad packets to the SG to see if they get freed properly."), Ignore]
        public class BadPacketType_Leak_1000 : BadPacketType_Leak
        {
            protected int Count = 1000;
            protected string SG = null;

            protected override void RunTest ()
            {
                SGIP = Global.XEnv.GetVirtualInterface("sgsvc");
                SG = Global.XEnv.GetInterface("sgsvc_int")[0].Address.ToString();
                
                byte[] payload = ConstructPayload("You packet is leaked!!!");
                SimpleUdpSG udpsender = new SimpleUdpSG();

                int premin = GetMinimumAllocated();

                for (int i = 0; i < Count; ++i)
                {
                    udpsender.Send(payload, SGIP);
                }

                // wait for a bit to make sure the SG has time to process them all
                System.Threading.Thread.Sleep(1000);

                int postmin = GetMinimumAllocated();

                if (postmin - premin >= Count)
                {
                    Global.RO.Error("Packet leak detected [{0} : {1}], check Gc Packets allocated to be sure.",
                        premin, postmin);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else if (premin == -1 || postmin == -1)
                {
                    Global.RO.Error("You will have to manually check the Gc Packets allocated counter.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            protected int GetMinimumAllocated ()
            {
                PerformanceCounter perf = null;

                try
                {
                    perf = new PerformanceCounter("XBox Security Gateway (Global)",
                        "Gc Packets allocated", "", SG);
                }
                catch
                {
                    Global.RO.Warn("Could not open the perf counters on the SG [{0}], please check the sgsvc_int IP " +
                        "to ensure that it can connect.  Also make sure that Remote Registry is running on the " +
                        "server.", SG);

                    return -1;
                }

                int ans = 1000000;

                for (int i = 0; i < 5; ++i)
                {
                    int temp = (int) perf.NextValue();
                    ans = Math.Min(temp, ans);
                    System.Threading.Thread.Sleep(1000);
                }

                return ans;
            }
        }
        
        [TestCase, Description("Sends a packet with padding larger than the encryption block size, requires DES(3).")]
        [CompoundCase("7", 7u)]
        [CompoundCase("8", 8u)]
        [CompoundCase("15", 15u)]
        public class BadPadding : TestBase_Validity
        {
            protected override void RunTest ()
            {
                uint padding = (uint)MyValues[0];
#if !LSPTEST
                bool expect_event = (padding >= 8);

                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();
#endif

                sg.Context.Authdata.MajorVersion = 2;
                sg.Context.Authdata.MinorVersion = 0;
                sg.Context.Authdata.BuildNumber = 0;
                sg.Context.Authdata.QFENumber = 0;

                // get us a new ticket for our new version
                sg.FakeSignInXkdc();
                sg.SignInSG();
                XspPacket xsp = new XspPacket(new SecMsgPulse(), sg.Context.SecKeys, sg.SequenceXmit++);
                xsp.SpiHeader.SetPadding(padding);
                sg.XspSend(xsp);
                
#if !LSPTEST
                if (expect_event != events.TestForChange(53913))
                {
                    throw new UnexpectedTestResultException("We should " + (expect_event ? "" : "not ") + 
                        "have seen an event about the padding size!");
                }
#endif
            }
        }

        [TestCase, Description("Sends a packet with a bad SHA hash.")]
        public class BadSHA : TestBase_Validity
        {
            protected override void RunTest ()
            {
                sg.SignInSG();
                XspPacket xsp = new XspPacket(new SecMsgPulse(), sg.Context.SecKeys, sg.SequenceXmit++);
                xsp.HashedTail[xsp.HashedTail.Length - 1] += 1;
                sg.XspSend(xsp);
            }
        }

        [TestCase, Description("Sends a packet with the IP fragmentation bit on.")]
        public class IPFragmentPacket : TestBase_Validity
        {
            override protected void RunTest ()
            {
                UdpPacket udp = rawnic.ConstructPacket(NoPayload);
                udp.Ip.FragOff = 0x0020;
                SendWithChecksum(udp);
            }
        }

        [TestCase, Description("Sends a packet whose UDP data portion is empty.  The error it should encounter " +
            "is that the body is not large enough to store the XspHdr.")]
        public class EmptyUDPPacket : TestBase_Validity
        {
            override protected void RunTest ()
            {
                UdpPacket udp = rawnic.ConstructPacket(NoPayload);
                Send(udp);
            }
        }

        [TestCase, Description("Sends a packet whose UDP length does not match the IP length.")]
        public class BadUDPSize : TestBase_Validity
        {
            override protected void RunTest ()
            {
                UdpPacket udp = rawnic.ConstructPacket(new byte[20]);
                udp.Udp.Len += 1;
                SendWithChecksum(udp);
            }
        }

        [TestCase, Description("Sends an XSP packet with an unknown SPI.")]
        public class UnknownSPI : TestBase_Validity
        {
            protected override void RunTest ()
            {
                IPEndPoint SGIP = Global.XEnv.GetVirtualInterface("sgsvc");

                byte[] payload = new byte[16];
                for (byte i = 0; i < 4; ++i) { payload[i] = i; }

                SimpleUdpSG udpsender = new SimpleUdpSG();
                udpsender.Send(payload, SGIP);
            }
        }

        [TestCase, Description("Sends a packet with a source IP that does not match the keyex source IP.")]
        public class ChangeSourceIP : TestBase_Validity
        {
            protected override void RunTest ()
            {
                sg.SignInSG();

                // create a new xsp pulse packet
                XspPacket xsp = new XspPacket(new SecMsgPulse(), sg.Context.SecKeys, sg.SequenceXmit++);
                UdpPacket udp = ConstructPacket((byte[])xsp);

                // change the ip
                byte[] local_ip = sg.Context.Udp.LocalIP.Address.GetAddressBytes();
                if (local_ip.Length != 4)
                {
                    throw new UnexpectedTestResultException("When did we switch to handling that protocol?");
                }
                udp.Ip.ipaSrc.S_addr = (uint) (((local_ip[3] + 1) << 24) | (local_ip[2] << 16) | (local_ip[1] << 8) | 
                    local_ip[0]);
                SendWithChecksum(udp);
            }
        }

        [TestCase, Description("Sends a packet with a source port that does not match the keyex source port.")]
        public class ChangeSourcePort : TestBase_Validity
        {
            protected override void RunTest ()
            {
                sg.SignInSG();

                // create a new xsp pulse packet
                XspPacket xsp = new XspPacket(new SecMsgPulse(), sg.Context.SecKeys, sg.SequenceXmit++);
                UdpPacket udp = ConstructPacket((byte[]) xsp);

                // change the port
                udp.Udp.portSrc = NetConstants.HTONS((ushort)(sg.Context.Udp.LocalIP.Port + 1));
                SendWithChecksum(udp);
            }
        }

        [TestCase, Description("Sends a packet that is outside of the sequence window.")]
        public class OutsideSequenceWindow : TestBase_Validity
        {
            protected override void RunTest ()
            {
                sg.SignInSG();
                // lets send one first just to set a precedent
                XspPacket xsp = new XspPacket(new SecMsgPulse(), sg.Context.SecKeys, sg.SequenceXmit++);
                sg.XspSend(xsp);
                xsp = new XspPacket(new SecMsgPulse(), sg.Context.SecKeys, sg.SequenceXmit + 1024);
                sg.XspSend(xsp);
            }
        }

        [TestCase, Description("Sends a packet twice in a row.")]
        public class PacketReplay : TestBase_Validity
        {
            protected override void RunTest ()
            {
                sg.SignInSG();
                XspPacket xsp = new XspPacket(new SecMsgPulse(), sg.Context.SecKeys, sg.SequenceXmit++);
                sg.XspSend(xsp);
                sg.XspSend(xsp);
            }
        }

        [TestCase, Description("Sends a packet with the source port of 0.")]
        public class SourcePortInvalid_0 : TestBase_Validity
        {
            protected override void RunTest ()
            {
                sg.SignInSG();
                XspPacket xsp = new XspPacket(new byte[4], XspHeader.XSP_TYPE_UDP_2, 0, 1, 
                    sg.Context.SecKeys, sg.SequenceXmit++);
                sg.XspSend(xsp);
            }
        }

        [TestCase, Description("Sends a packet with the source port of 0xFFFF.")]
        public class SourcePortInvalid_Max : TestBase_Validity
        {
            protected override void RunTest ()
            {
                sg.SignInSG();
                XspPacket xsp = new XspPacket(new byte[4], XspHeader.XSP_TYPE_UDP_2, 0xFFFF, 1,
                    sg.Context.SecKeys, sg.SequenceXmit++);
                sg.XspSend(xsp);
            }
        }

        [TestCase, Description("Sends a key exchange that is smaller than the defined min (1332 default).")]
        public class KeyExPacketTooSmall : TestBase_Validity
        {
            protected override void RunTest ()
            {
                byte[] payload = new byte[16];
                for (byte i = 0; i < 4; ++i) { payload[i] = 0; }

                UdpPacket udp = ConstructPacket(payload);
                Send(udp);
            }
        }

        [TestCase, Description("Sends a key exchange with a corrupt kerb AP req.")]
        public class BadKerbApReq : TestBase_Validity
        {
            protected override void RunTest ()
            {
                SgClient.SetDefaults(sg.Context);
                sg.FakeSignInXkdc();

                // Construct the request packet
                KeyExchangeRequestPacket KeyexRequest = new KeyExchangeRequestPacket();

                KeyexRequest.keyexInit.wFlags = KeyExchangeInit.XSIF_CONNECTION_SERVICE;

                byte[] apData = KeyexRequest.BuildAP(sg.Context);

                // corrupt that data
                apData[apData.Length / 2] += 1;

                KeyexRequest.keyexAPReq.Data = apData;

                // send it on over
                UdpPacket udp = ConstructPacket((byte[]) KeyexRequest);
                Send(udp);
            }
        }

        [TestCase, Description("Sends an ECHO_REPLY ICMP packet to the SG.")]
        public class IcmpEchoReply : TestBase_Validity
        {
            protected override void RunTest ()
            {
                IcmpPacket icmp = null;

                if (Global.XEnv.GetOverriddenVInterfaces().Contains("sgsvc/"))
                {
                    icmp = rawnic.ConstructIcmpPacket();
                }
                else
                {
                    // send directly to the first SG in the list, thus bypassing the VIP
                    IpAddr ip_addr = new IpAddr(SgServerInfo.Servers[0].InternetIp.Address.GetAddressBytes());
                    icmp = new IcmpPacket();
                    icmp.Set(rawnic.LocalIpMac, rawnic.LookupMac(ip_addr));
                }

                icmp.Icmp.Type = IcmpHdr.ECHO_REPLY;
                icmp.DoIcmpChecksum();
                rawnic.Send((byte[]) icmp);
            }
        }

#if !LSPTEST
        [TestCase, Description("Uses the reflector to send a TCP packet to unused ports on a valid datacenter IP.")]
        [EnvRequirement("TestFD")]
        public class SendTCPtoUnusedHighPorts : TestBase_Validity
        {
            protected override void RunTest ()
            {
                // get the configuration info for one of the SGs
                IInterfaceInfo iii = Config.GetInterface(SgServerInfo.Servers[0].Name, Interface.sgsvc_int);
                string client_limit_string = Config.GetSetting(Setting.sg_ClientLimit);
                string client_port_limit_string = Config.GetSetting(Setting.sg_ClientPortLimit);

                // make sure we are using port translation
                // (loosely, there is some gray area due to not using any .0 or .255 ips)
                uint client_limit = uint.Parse(client_limit_string);
                uint total_ips = (iii.SgIpAddressEndDword - iii.SgIpAddressBeginDword) + 1;

                if (client_limit <= total_ips)
                {
                    Global.RO.Debug("This test does not apply without port translation.");
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }

                // make sure there are actually unused ports on each IP
                int client_port_limit = int.Parse(client_port_limit_string);
                int sg_port_end = iii.SgPortEnd;
                int total_ports = (sg_port_end - iii.SgPortBegin) + 1;

                if ((total_ports % client_port_limit) == 0)
                {
                    Global.RO.Debug("This test does not apply without unused ports.");
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }

                // create byte array request
                byte rand_val = (byte)RandomEx.GlobalRandGen.Next();

                byte[] request = new byte[10];
                request[0] = (byte)SGFakeService.ActionType.TCPConnectTest;
                request[1] = rand_val;
                Buffer.BlockCopy(iii.SgIpAddressBegin.GetAddressBytes(), 0, request, 4, 4);
                Buffer.BlockCopy(BitConverter.GetBytes((UInt16)sg_port_end), 0, request, 8, 2);

                sg.SignInSG();
                XspPacket xsp = new XspPacket(request, XspHeader.XSP_TYPE_UDP_2, 0x1234, (int)SGFakeService.IServicePort.Service5,
                    sg.Context.SecKeys, sg.SequenceXmit++);
                sg.XspSend(xsp);

                // receive response and verify
                XspPacket response = sg.XspRecv(12000);

                if (response == null)
                {
                    throw new UnexpectedTestResultException("No response from reflector.");
                }

                if (response.MessageLength != 3)
                {
                    throw new UnexpectedTestResultException("Response was not 3 bytes, was " + response.MessageLength.ToString());
                }

                if (response.Message[0] != (byte)SGFakeService.ActionType.TCPConnectTest)
                {
                    throw new UnexpectedTestResultException("Response action was not TCPConnectTest (0x89) bytes, was 0x" + 
                        response.Message[0].ToString("X2"));
                }

                if (response.Message[1] != rand_val)
                {
                    throw new UnexpectedTestResultException("Response sequence was not " + rand_val.ToString() + " bytes, was " +
                        response.Message[1].ToString());
                }

                // 0 means the SG TCP RST, others are anything else
                if (response.Message[2] != 0)
                {
                    if (response.Message[2] == 1)
                    {
                        throw new UnexpectedTestResultException("Somehow we connected to something...");
                    }
                    else if (response.Message[2] == 2)
                    {
                        throw new UnexpectedTestResultException("Some unexpected error occured (not a TCP RST)...");
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("Unknown response value: " + response.Message[2].ToString());
                    }
                }
            }
        }
#endif

        [TestCase]
        class FinalVerify : TestBase_Keyex
        {
            // this will sign in to the SG automatically. if we can do that, the SG must still be running.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncPacketKeyexOrder.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;


namespace XSGTest
{
    
    // Extend base class to set defaults for entire test group
    abstract class TestBase_KeyOrder : TestBase_SgFake
    {
        protected override void SetDefaults()
        {
            base.SetDefaults ();
            sg.TimeoutInMs = 500;
        }

        protected override void InitTest()
        {
            base.InitTest();

            // Do a valid normal key exchange to make sure the server is running, not much
            // point to flinging bad packets at it if it isn't even working properly.
            DoKeyExchange();
        }

        protected override bool VerifyTest()
        {
            // Do a valid normal key exchange to make sure the server is still responding
            DoKeyExchange();

            return base.VerifyTest ();
        }


        protected void DoInvalidKeyExchange(KeyExchangeRequestPacket requestPacket)
        {
            this.bExpectedNoReply = true;
            sg.BuildFakeTicket(sg.Context.Authdata);
            sg.SetRequest(requestPacket);
            sg.SignInSG();
        }

        protected void SendInvalid(KeyExchangeRequestPacket req)
        {
            bExpectedNoReply = true;
            DoInvalidKeyExchange(req);
        }

        // KEYEX_TYPE_XBTOSG_INIT modifications
        protected void SendInvalidType1(short type)
        {
            KeyExchangeRequestPacket req = new KeyExchangeRequestPacket();
            req.keyexInit.Type = type;
            SendInvalid(req);
        }

        // KEYEX_TYPE_XBTOSG_INIT modifications
        protected void SendInvalidType1(short type, short size)
        {
            KeyExchangeRequestPacket req = new KeyExchangeRequestPacket();
            req.keyexInit.cbEnt = size;
            req.keyexInit.Type = type;
            SendInvalid(req);
        }

        // KEYEX_TYPE_DH_GX modifications
        protected void SendInvalidType2(short type)
        {
            KeyExchangeRequestPacket req = new KeyExchangeRequestPacket();
            req.keyexDhgx.Type = type;
            SendInvalid(req);
        }

        // KEYEX_TYPE_DH_GX modifications
        protected void SendInvalidType2(short type, short size)
        {
            KeyExchangeRequestPacket req = new KeyExchangeRequestPacket();
            req.keyexDhgx.cbEnt = size;
            req.keyexDhgx.Type = type;
            SendInvalid(req);
        }

        // KEYEX_TYPE_KERB_APREQ modifications
        protected void SendInvalidType3(short type)
        {
            KeyExchangeRequestPacket req = new KeyExchangeRequestPacket();
            req.keyexAPReq.Type = type;
            SendInvalid(req);
        }

        // KEYEX_TYPE_KERB_APREQ modifications
        protected void SendInvalidType3(short type, short size)
        {
            KeyExchangeRequestPacket req = new KeyExchangeRequestPacket();
            req.keyexAPReq.cbEnt = size;
            req.keyexAPReq.Type = type;
            SendInvalid(req);
        }

    }

    [TestGroup, TestCasePriority(1)]
#if LSPTEST
    [CompoundCase("AuthData 3", 3)]
    [CompoundCase("AuthData 4", 4)]
#endif
    public class Packet_KeyexOrder : MultiAuthDataBase
    {

        [TestCase, Description("Invalid packet types for KeyExchangeInit (1STKEY)")]
        class InvalidPacketTypes1_Init : TestBase_KeyOrder
        {
            protected override void RunTest()
            {
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_XBTOXB_INIT);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_XBTOXB_RESP);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_DH_GX);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_HMAC_SHA);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_KERB_APREP);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_NULL_APREQ2);
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_NULL_APREP);
                SendInvalidType1(10);  // not in range

            }
        }

        [TestCase, Description("Invalid packet sizes for KeyExchangeInit (1STKEY)")]
        class InvalidPacketSizes1_Init : TestBase_KeyOrder
        {
            protected override void RunTest()
            {
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT, 25);     // +1 too big
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT, 4096);   // way too big
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT, 23);     // -1 too small
                SendInvalidType1(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT, 0);

            }
        }

        [TestCase, Description("Invalid packet types for KeyExchangeDHGx (2NDKEY)")]
        class InvalidPacketTypes2_DHGx : TestBase_KeyOrder
        {
            protected override void RunTest()
            {

                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_XBTOXB_INIT);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_XBTOXB_RESP);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_HMAC_SHA);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_KERB_APREP);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_NULL_APREQ2);
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_NULL_APREP);
                SendInvalidType2(10);  // not in range
               
            }
        }

        [TestCase, Description("Invalid packet sizes for KeyExchangeDHGx (2NDKEY)")]
        class InvalidPacketSizes2_DHGx : TestBase_KeyOrder
        {
            protected override void RunTest()
            {
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_DH_GX, 1+4+(short)KC.k_dwDHKeySize);     // +1 too big
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_DH_GX, 4096);   // way too big
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_DH_GX, -1+4+(short)KC.k_dwDHKeySize);     // -1 too small
                SendInvalidType2(KeyExchangeHeader.KEYEX_TYPE_DH_GX, 0);

            }
        }

        [TestCase, Description("Invalid packet types for KeyExchangeAPReq (3RDKEY)")]
            class InvalidPacketTypes3_APReq : TestBase_KeyOrder
        {
            protected override void RunTest()
            {
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_XBTOXB_INIT);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_XBTOXB_RESP);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_DH_GX);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_HMAC_SHA);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_KERB_APREP);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_NULL_APREQ2);
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_NULL_APREP);
                SendInvalidType3(10);  // not in range
             
            }
        }

        [TestCase, Description("Invalid packet sizes for KeyExchangeAPReq (3RDKEY)")]
            class InvalidPacketSizes3_APReq : TestBase_KeyOrder
        {
            protected override void RunTest()
            {
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ, 1+4+(short)KC.k_dwDHKeySize);     // +1 too big
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ, 4096);   // way too big
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ, -1+4+(short)KC.k_dwDHKeySize);     // -1 too small
                SendInvalidType3(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ, 0);

            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncPanoramaLua.cs ===
//sync and async panaroma tests
//note: sync tests use TestBase_Lua as a base (FuncLua.cs), async tests use TestBase_AsyncLua (FuncSecmsgChalResp_Lua.cs)

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;

namespace XSGTest
{

    [Description("port of some of the other lua tests to run using panorama instead of xbox"), TestFrequency("Regression")]
    public class LuaPanorama : TestNode
    {

        //turns a client into a specific type
        static public void MakeAuthPC(Authdata_Base authData)
        {
            authData.AuthDataFlags=0;
            authData.XboxID=(authData.XboxID&0x0000ffffffffffff)|0xfb00000000000000;
        }
        static public void MakeAuthXenon(Authdata_Base authData)
        {
            authData.AuthDataFlags=Authdata_Xenon.FLAGS_ISXENON;
            authData.XboxID=(authData.XboxID&0x0000ffffffffffff)|0xfa00000000000000;
        }
        static public void MakeAuthXbox1(Authdata_Base authData)
        {
            authData.AuthDataFlags=0;
            authData.XboxID=(authData.XboxID&0x0000ffffffffffff)|0x0009000000000000;
        }

        // -- login challenge tests (most are taken from FuncLua.cs test cases)

        [TestCase, Description("login: test that targetting a panorama client works")]
        class TargetPan : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                authData.TitleVersion=4;
                MakeAuthPC(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_Simple"];
                SignIn(true);
            }
        }
        
        [TestCase, Description("login: test that not targetting a panorama client works")]
        class NoTargetPan : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                authData.TitleVersion=9;
                MakeAuthPC(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_Simple"];
                SignIn(false);
            }
        }

        [TestCase, Description("login: test that panorama script with xenon client doesn't target")]
        class TargetXenon : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                authData.TitleVersion=4;
                MakeAuthXenon(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_Simple"];
                SignIn(false);
            }
        }

        [TestCase, Description("login: test that panorama script with xbox1 client doesn't target")]
        class TargetXbox1 : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                authData.TitleVersion=4;
                MakeAuthXbox1(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_Simple"];
                SignIn(false);
            }
        }

        [TestCase, Description("login: test that xbox script with panorama client doesn't target")]
        class TargetPanWithXBox : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                authData.TitleVersion=4;
                MakeAuthPC(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["Lua_Simple"];
                SignIn(false);
            }
        }

        [TestCase, Description("login: target and don't kick after response")]
        class TargetNokick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                authData.TitleVersion=4;
                MakeAuthPC(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_Simple"];
                SignIn(true);
                SendChallengeResponse("0x11",true);
            }
        }

        [TestCase, Description("login: target and kick after response")]
        class TargetKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                authData.TitleVersion=2;
                MakeAuthPC(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_Simple"];
                SignIn(true);
                SendChallengeResponse("0x11",false);
            }
        }

        [TestCase, Description("login: target me, verify param sent, don't kick me, based off wMajorVersion value 0xffff")]
        class Lua_TarMajorVersionFFFFNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0xffff, true, true, false);
            }
        }

        [TestCase,Description("login: target me, verify param sent, don't kick me, based off wMajorVersion value 0x0000")]
        class Lua_TarMajorVersion0000NoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0x0000, true, true, false);
            }
        }

        [TestCase,Description("login: target me, verify param sent, kick me, based off wMajorVersion value 0xffff")]
        class Lua_TarMajorVersionFFFFKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0xffff, true, true, true);
            }
        }

        [TestCase,Description("login: target me, verify param sent, kick me, based off wMajorVersion value 0x0000")]
        class Lua_TarMajorVersion0000Kick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0x0000, true, true, true);
            }
        }

        [TestCase,Description("login: don't target me, based off wMajorVersion value 0xffff")]
        class Lua_NoTarMajorFFFFVersion : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0xffff, true, false, true);
            }
        }

        [TestCase,Description("login: don't target me, based off wMajorVersion value 0x0000")]
        class Lua_NoTarMajor0000Version : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMajor", authData.MajorVersion = 0x0000, true, false, true);
            }
        }

        [TestCase,Description("login: target me, verify param sent, don't kick me, based off wMinorVersion value 0x8888")]
        class Lua_TarMinorVersionNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientMinor", authData.MinorVersion = 0x8888, true, true, false);
            }
        }

        [TestCase,Description("login: target me, verify param sent, don't kick me, based off wBuildNumber value 0x6666")]
        class Lua_TarBuildNumberNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientBuild", authData.BuildNumber = 0x6666, true, true, false);
            }
        }

        [TestCase,Description("login: target me, verify param sent, don't kick me, based off wQFENumber value 0x9999")]
        class Lua_TarQFENumberNoKick : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                RunGeneratedLuaScript_TargetFilterWithSimpleKick("GetClientQfe", authData.QFENumber = 0x9999, true, true, false);
            }
        }

        [TestCase, Description("login: test targetting beta bit with bit set")]
        class TargetBeta : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=0x9999;
                MakeAuthPC(authData);
                authData.AuthDataFlags |= Authdata_Xenon.FLAGS_ISBETAMACHINE;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_TargetBeta"];
                SignIn(true);
            }
        }

        [TestCase, Description("login: test targetting beta bit, bit not set")]
        class TargetBetaNot : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=0x9999;
                MakeAuthPC(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_TargetBeta"];
                SignIn(false);
            }
        }

        [TestCase, TestCasePriority(3), Description("login: malformed lua script")]
        class BadScript : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_BadScript"];
                bBadLuaScript=false;
                SignIn(false);
            }
        }

        [TestCase, Description("login: set spi storage data in __Target and make sure it's still there in __Analyze")]
        class SimpleSPIStorage : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                authData.QFENumber=63;
                MakeAuthPC(authData);

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_SpiSimple"];
                SignIn(true);
                SendChallengeResponse("0xc00c00",true); //disconnects us on check failure in __Analyze
            }
        }

        [TestCase,Description("login: test that max length binary data gets passed to client correctly")]
        class TestMaxBinary : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                authData.QFENumber=63;

                //some random data (256+760 bytes)
                string binDataStr0 = "109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030000200000800070";
                string binDataStr1 = "cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003000020000080bb33cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003000020000080bb33cc9B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE960001011000010003";
                byte[] binData0 = Hexer.unhex(binDataStr0);
                byte[] binData1 = Hexer.unhex(binDataStr1);

                //set the script
                string luaCode = "ChallengeDeclare(0x994, \"Challenge 0x994\",true,true)\n" +
                    "__Binary = Buffer.new('" + binDataStr0 + binDataStr1 +"')\n" +
                    "function __Target()\n" +
                    "    if Spi.GetClientQfe() ~= 63 then return false end"+
                    "    Chal.SetParam(Buffer.new('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'))\n" +
                    "    return true\n" +
                    "end\n" +
                    "function __Analyze(buffer)\n" +
                    "end\n";

                ro.Debug("Lua script used:\n" + luaCode);
                luaChal = new LuaScript() { Name = Name, Script = luaCode };

                //sign in... we should be challenged
                SignIn();
                if (sgChal == null)
                {
                    Fail("expected a challenge back from sg but didn't get");
                    return;
                }

                //check that the binary blob is right (first 256 in PkSig, rest in ChalCode)
                ValueCheck.Test("Binary chunk 0: ",binData0,sgChal.PkSig);
                ValueCheck.Test("Binary chunk 1: ",binData1,sgChal.ChalCode);
            }
        }

        // -- async challenge tests (most are taken from FuncSecmsgChalResp_Lua.cs test cases)

        [TestCase,Description("async: simple test that should target us")]
        class AsyncPanTarget : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=62;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleTarget"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null) throw new SgTestException("Did not get challenged");
            }
        }

        [TestCase,Description("async: simple test that should NOT target us")]
        class AsyncPanNotarget : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=61;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleTarget"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal!=null) throw new SgTestException("Got challenged but shouldn't have");
            }
        }

        [TestCase,Description("async: try targetting xenon with panorama challenge")]
        class AsyncTargetXenon : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthXenon(authData);
                authData.QFENumber=62;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleTarget"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal!=null) throw new SgTestException("Got challenged but shouldn't have");
            }
        }

        [TestCase,Description("async: try targetting xbox1 with panorama challenge")]
        class AsyncTargetXbox1 : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthXbox1(authData);
                authData.QFENumber=62;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleTarget"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal!=null) throw new SgTestException("Got challenged but shouldn't have");
            }
        }

        [TestCase,Description("async: try targetting panorama with xbox challenge")]
        class AsyncTargetPanWithXbox : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=66;
                AddChallenge(GetXmlChallenge("LuaA_SimpleTarget","",0x9989,66));
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal!=null) throw new SgTestException("Got challenged but shouldn't have");
            }
        }

        [TestCase,Description("async: challenge us, send reply, and kick us")]
        class AsyncSimpleKick : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=62;
                authData.MinorVersion=6;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleKick"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null) throw new SgTestException("Did not get challenged");
                SendChallengeResponse(new byte[1024]);
                if (WaitAndCheckConnected(15)) throw new SgTestException("Still connected but shouldn't be");
            }
        }

        [TestCase,Description("async: challenge us, send reply, and don't kick us")]
        class AsyncSimpleNoKick : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=62;
                authData.MinorVersion=11;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleKick"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null) throw new SgTestException("Did not get challenged");
                SendChallengeResponse(new byte[1024]);
                if (!WaitAndCheckConnected()) throw new SgTestException("We got kicked :(");
            }
        }

        [TestCase,Description("async: pass 32 bit value as auth value, back as, param, then back in chal response (verifying all)")]
        class AsyncVerifyParamAndResponse : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=62;
                authData.TitleVersion=0xffeeddcc;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_PassBackAndForth"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null) throw new SgTestException("Did not get challenged");

                //verify param coming in
                ValueCheck.Test("challenge param",Hexer.unhex("0x887766555566778888776655ffeeddcc"),chal.Params);

                //construct response
                byte []rar=new byte[1024];
                rar[0]=0xff;
                rar[1023]=0xff; rar[1022]=0xee; rar[1021]=0xdd; rar[1020]=0xcc;
                SendChallengeResponse(rar);

                if (!WaitAndCheckConnected())
                {
                    Fail("Should not have been kicked");
                }
            }
        }

        // -- tests where manual verification is needed

        [TestCase,Description("login: target me and log it -- You must MANUALLY check the log to verify (title id: aaabbbcd response: ddcbaaaabc)")]
        class Log_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                authData.TitleId=0xaaabbbcd;
                authData.QFENumber=63;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_SimpleLog"];
                SignIn(true);
                SendChallengeResponse("0xddcbaaaabc",true);
            }
        }

        [TestCase,Description("login: target me and DON'T log it -- You must MANUALLY check the log to verify (title id: BaceB0dd repsonse: BadBadBadd)")]
        class NoLog_MANUAL_CHECK_NEEDED : TestBase_Lua
        {
            protected override void RunLuaTest()
            {
                MakeAuthPC(authData);
                authData.TitleId=0xBaceB0dd;
                authData.QFENumber=63;

                luaChal = ChallengeManager.PreconfiguredLuaScripts["LuaP_SimpleLog"];
                SignIn(true);
                SendChallengeResponse("0xffBadBadBadd",true);
            }
        }

        [TestCase,Description("async: log the thing - titleID=BeeBee00")]
        class AsyncLog_MANUAL_CHECK_NEEDED : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=63;
                authData.TitleId=0xBeeBee00;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleLog"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null) throw new SgTestException("Did not get challenged");
                SendChallengeResponse(new byte[1024]);
            }
        }

        [TestCase,Description("async: do NOT log this thing - titleID=C1C2C3C4")]
        class AsyncNoLog_MANUAL_CHECK_NEEDED : TestBase_AsyncLua
        {
            protected override void PreloginSetup (Authdata_Base authData)
            {
                MakeAuthPC(authData);
                authData.QFENumber=63;
                authData.TitleId=0xC1C2C3C4;
                AddChallenge(ChallengeManager.PreconfiguredLuaScripts["LuaPA_SimpleLog"]);
            }

            protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
            {
                if (chal==null) throw new SgTestException("Did not get challenged");
                byte []b=new byte[1024];
                b[0]=0xff;
                SendChallengeResponse(b);
            }
        }

    }

} //namespace XSGTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncPacketXsp.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

 
namespace XSGTest
{
    abstract class TestBase_Xsp : TestBase_SgFake
    {
        public const uint DATA_STRIDE = 1;
        public const uint VOICE_STRIDE = 3;

        protected void SignInAndQos()
        {
            DoKeyExchange();

            ro.Debug("Using cipher {0} with key length {1}", sg.Context.SecKeys.Cipher, sg.Context.SecKeys.KeyLength);

            QOS q = new QOS();
            if (!q.SendRecv(sg))
            {
                throw new ServerTestFramework.Utilities.TimeoutException("QOS exchange timed out");
            }
        }

        protected void SetXspV1()
        { 
            sg.Context.Authdata.MajorVersion = 0x0;
            sg.Context.Authdata.MinorVersion = 0x0;
            sg.Context.Authdata.BuildNumber  = 0x0000;
            sg.Context.Authdata.QFENumber    = 0x00;
        }

        protected void SetXspV2()
        { 
            // This depends on the settings AesBaseClientVersionXbox360 and 
            // AesBaseClientVersionPc, but since they can't be higher than 0xFFFFFFFF, 
            // this is a guaranteed safe value to "trigger" us as a newer client.
            sg.Context.Authdata.MajorVersion = 0xF;
            sg.Context.Authdata.MinorVersion = 0xF;
            sg.Context.Authdata.BuildNumber  = 0xFFFF;
            sg.Context.Authdata.QFENumber    = 0xFF;
        }

        protected void PopulateTestArray(
            byte[] array, 
            uint startIndex, 
            uint count,
            uint stride)
        {
            for (uint i = 0; i < count; i++)
            {
                array[i + startIndex] = (byte)((i * stride) % 256);
            }
        }

        protected bool CompareArrays(
            string errorPrefix,
            byte[] array1, 
            byte[] array2)
        {
            if (array1.Length != array2.Length)
            {
                Fail(errorPrefix + "array1 length {0} doesn't equal array2 length {1}",
                     array1.Length, array2.Length);
            }

            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i])
                {
                    Fail(errorPrefix + "byte mismatch at index {0}. Sent:\n{0}\nGot:\n{0}", 
                         PrintTestArray(array1, 0, (uint)array1.Length),
                         PrintTestArray(array2, 0, (uint)array2.Length));
                    return false;
                }
            }
            return true;
        }

        protected bool VerifyTestArray(
            byte[] array1, 
            uint startIndex1,
            uint count1,
            uint stride)
        {
            for (uint i = 0; i < count1; i++)
            {
                if (array1[i + startIndex1] != (byte)((i * stride) % 256))
                {
                    Fail("Reply is incorrect. Got:\n{0}", PrintTestArray(array1, startIndex1, count1));
                    return false;
                }
            }
            return true;
        }

        protected string PrintTestArray(
            byte[] array,
            uint startIndex,
            uint count)
        {
            StringBuilder sb = new StringBuilder();
            for (uint i = 0; i < count; i++)
            {
                sb.Append(array[i + startIndex].ToString("X2"));
                if (i > 0 && (i % 16) == 0)
                {
                    sb.Append("\n");
                }
                else if ((i % 8) == 0)
                {
                    sb.Append(" - ");
                }
                else 
                {
                    sb.Append(" ");
                }
            }
            return sb.ToString();
        }

        protected bool Reflect2(
            string prefix,
            uint xspType, 
            uint dataSize, 
            uint voiceSize)
        {
            byte[] data = new byte[dataSize];
            byte[] voice = new byte[voiceSize];
            PopulateTestArray(data, 0, dataSize, DATA_STRIDE);
            PopulateTestArray(voice, 0, voiceSize, VOICE_STRIDE);

            bool fOk = Reflect(xspType, data, voice);

            if (fOk)
                ro.Debug("[Pass] {0}, {1}:d {2}:v bytes, {3} type", prefix, dataSize, voiceSize, xspType);
            else
                ro.Warn("[Fail] {0}, {1}:d {2}:v bytes, {3} type", prefix, dataSize, voiceSize, xspType);

            return fOk;
        }

        protected bool Reflect(
            uint xspType, 
            byte[] data, 
            byte[] voice)
        {
            uint    bytesPerPort    = (xspType - XspHeader.XSP_TYPE_TCP_0) % 3;
            uint    baseXspType     = xspType - bytesPerPort;
            uint    sourcePort      = 0;
            uint    destPort        = 0;
            uint    cbPadding       = 0;

            XspTcpInfo tcpInfo      = null;
            byte[]     vdpCombo     = null;

            // want all ports to be different
            // Note:
            // These must be configured on the SG as well:
            //   998  - vdp (2 byte ports)
            //   999  - udp/tcp (2 byte ports)
            //   1000 - udp/tcp (0 byte ports)
            //   1001 - udp/tcp (1 byte ports)
            //   1002 - vdp (2 byte ports)
            //
            // We unfortunately can't configure 0 byte VDP ports, since port 1000 is the 
            // only one available and VDP can't share with UDP. That means manual SG 
            // reconfiguration.
            //
            if (bytesPerPort == 0)
            {
                destPort = 1000;
                sourcePort = 1000;
            }
            else if (bytesPerPort == 1)
            {
                if (baseXspType >= XspHeader.XSP_TYPE_VDP_0)
                {
                    destPort = 1002;
                    sourcePort = 1003;
                }
                else
                {
                    destPort = 1001;
                    sourcePort = 1002;
                }
            }
            else 
            {
                if (baseXspType >= XspHeader.XSP_TYPE_VDP_0)
                {
                    destPort = 998;
                    sourcePort = 997;
                }
                else
                {
                    destPort = 999;
                    sourcePort = 998;
                }
            }

            // Construct XspSession and send buffer
            XspBuffer xsp;
            XspSession xspSession = new XspSession(sg.Context.SecKeys);
            
            // hack hack #1/2
            xspSession.SyncSequenceNumbers(sg);
            
            if (baseXspType == XspHeader.XSP_TYPE_UDP_0)
            {
                xsp = xspSession.EncodeUdp(
                    sourcePort,
                    destPort,
                    data,
                    (uint)data.Length);
                cbPadding = xsp.XspPadding;
            }
            else if (baseXspType == XspHeader.XSP_TYPE_TCP_0)
            {
                // Sorta unique numbers. Totally fake.
                tcpInfo = new XspTcpInfo();
                tcpInfo._SeqNum = 1;
                tcpInfo._AckNum = 2;
                tcpInfo._HdrLen = (byte)((20 << 2) & 0xF0);  // size of TcpHdr in dwords
                tcpInfo._Flags = 0;
                tcpInfo._Window = 3;

                xsp = xspSession.EncodeTcp(
                    sourcePort,
                    destPort,
                    tcpInfo,
                    data,
                    (uint)data.Length);
                cbPadding = xsp.XspPadding;
            }
            else if (baseXspType >= XspHeader.XSP_TYPE_VDP_0)
            {
                if (voice == null)
                    voice = new byte[0];
                if (data == null)
                    data = new byte[0];

                vdpCombo = new byte[data.Length + voice.Length + 2];
                BinaryWriter bw = new BinaryWriter(new MemoryStream(vdpCombo));
                bw.Write((ushort)data.Length);
                bw.Write(data);
                bw.Write(voice);

                xsp = xspSession.EncodeVdp(
                    sourcePort,
                    destPort,
                    vdpCombo,
                    (uint)vdpCombo.Length);
                cbPadding = xsp.XspPadding;
            }
            else
            {
                throw new ArgumentException("Unknown baseXspType " + baseXspType);
            }

            string errorPrefix = String.Format("[p{0} d{1} v{2}] ", 
                                               destPort, 
                                               (data != null) ? data.Length : 0,
                                               (voice != null) ? voice.Length : 0);
            //
            // Transport layer magic
            //
            // This should eventually move elsewhere, like maybe SgClient
            //

            // Send it
            sg.IpServer.Port = 3076;  // special XSPECHO port
            sg.Context.Udp.SendFast(
               xsp.RawBuffer, 
               (int)xsp.RawBufferLength, 
               sg.IpServer);
            
            // hack hack #2/2
            xspSession.SyncSequenceNumbers(sg);

            // To make sure we're getting a squeaky clean buffer and not actually 
            // verifying the one we sent, we're going to create a new buffer. 
            xsp = new XspBuffer();

            for (int numAttempts = 0; numAttempts < 2; numAttempts++)
            {
                
                // Recv it quickly
                int recvBytes;
                sg.Context.Udp.RecvFast(
                    200,
                    xsp.RawBuffer,
                    out recvBytes);
                xsp.RawBufferLength = (uint)recvBytes;

                if (xsp.RawBufferLength == 0)
                {
                    Fail(errorPrefix + "Did not receive a response, 0 bytes received.");
                    return false;
                }

                // Decode it
                if (!xspSession.Decode(xsp, true))
                {
                    Fail(errorPrefix + "Failed to decode XspBuffer. Spi in buffer 0x{0:X} doesn't match expected spi 0x{1:X}",
                         xsp.Spi, sg.Context.SecKeys.SpiXmit);
                    return false;
                }

                // If we got a secmsg back, it may have been a heartbeat. If so, let's try 
                // again.
                if (xsp.XspType == XspHeader.XSP_TYPE_SEC)
                {
                    ro.Warn("Got a SECMSG for a response, trying again.");
                    continue;
                }

                // We succeeded, it seems.
                break;
            }
            
            // destPort
            if (xsp.SourcePort != destPort)
            {
                Fail(errorPrefix + "Sent to port {0} but got reply from port {1}", 
                     destPort, xsp.SourcePort);
                return false;
            }

            // sourcePort
            if (xsp.DestPort != sourcePort)
            {
                Fail(errorPrefix + "Sent from port {0} but reply was sent to port {1}", 
                     sourcePort, xsp.DestPort);
                return false;
            }

            // xspType
            if (xsp.XspType != xspType)
            {
                Fail(errorPrefix + "XspType in request {0} doesn't match response {1}",
                     xspType, xsp.XspType);
                return false;
            }

            // padding
            if (xsp.XspPadding != cbPadding)
            {
                Fail(errorPrefix + "XspPadding in request {0} doesn't match response {1}",
                     cbPadding, xsp.XspPadding);
                return false;
            }

            // packet-type-specific data validation
            if (baseXspType == XspHeader.XSP_TYPE_UDP_0)
            {
                if (!CompareArrays(errorPrefix, data, xsp.DataBuffer))
                    return false;
            }
            else if (baseXspType == XspHeader.XSP_TYPE_TCP_0)
            {
                XspTcpInfo t = xsp.TcpInfo;
                if (tcpInfo._SeqNum != t._SeqNum ||
                    tcpInfo._AckNum != t._AckNum ||
                    tcpInfo._HdrLen != t._HdrLen ||
                    tcpInfo._Flags != t._Flags ||
                    tcpInfo._Window != t._Window)
                {
                    Fail(errorPrefix + "TcpInfo mismatches. Sent {0}, got {1}",
                         tcpInfo, t);
                    return false;
                }
                if (!CompareArrays(errorPrefix, data, xsp.DataBuffer))
                    return false;
            }
            else if (baseXspType > XspHeader.XSP_TYPE_VDP_0)
            {
                if (!CompareArrays(errorPrefix + "[data] ", data, xsp.DataBuffer))
                    return false;
                if (!CompareArrays(errorPrefix + "[voice] ", voice, xsp.VoiceBuffer))
                    return false;
            }

            //ro.Debug(errorPrefix + "passed.");
            return true;
        }

        protected bool TestPaddingData(string prefix, uint xspType)
        {
            SignInAndQos();
            return TestPaddingDataNoSignin(prefix, xspType, 0);
        }

        protected bool TestPaddingDataNoSignin(string prefix, uint xspType, uint voiceSize)
        {
            uint numPasses = 0;
            uint numIters = 0;
            uint i;

            uint maxDataSize = 1264;
            if (voiceSize > 0)
            {
                maxDataSize -= 2;  // room for at *least* 1 voice byte + the size marker
            }

            for (i = 1; i < (1+32); i++)
            {
                uint vs = Math.Min(voiceSize, 1264 - i);
                numIters++;
                if (Reflect2(prefix, xspType, i, vs))
                    numPasses++;
                
            }

            // early bail
            if (numPasses > 0)
            {
                for (i = maxDataSize; i >= (maxDataSize-32); i--)
                {
                    uint vs = Math.Min(voiceSize, 1264 - i);
                    numIters++;
                    if (Reflect2(prefix, xspType, i, vs))
                        numPasses++;
                }
            }

            ro.Info("{0}: {1} out of {2} tests passed for voicesize {3}", prefix, numPasses, numIters, voiceSize);
            return numPasses == numIters;
        }

        protected bool TestPaddingCombo(string prefix, uint xspType)
        {
            uint i;
            bool fOk = true;
                
            SignInAndQos();

            uint    bytesPerPort    = (xspType - XspHeader.XSP_TYPE_TCP_0) % 3;
            uint    baseXspType     = xspType - bytesPerPort;

            if (baseXspType == XspHeader.XSP_TYPE_VDP_VO_0)
            {
                for (i = 1; i < (1+32); i++)
                {
                    fOk = fOk & Reflect2(prefix, xspType, 0, i);
                }
                for (i = 1264; i >= (1264-32); i--)
                {
                    fOk = fOk & Reflect2(prefix, xspType, 0, i);
                }
                return fOk;
            }
            else if (baseXspType == XspHeader.XSP_TYPE_VDP_DO_0)
            {
                return TestPaddingDataNoSignin(prefix, xspType, 0);
            }
            
            // VDP

            for (i = 1; i < (1+32); i++)
            {
                fOk = fOk & TestPaddingDataNoSignin(prefix, xspType, i);
                if (!fOk)
                    return fOk;
            }
            for (i = 1264; i >= (1264-32); i--)
            {
                fOk = fOk & TestPaddingDataNoSignin(prefix, xspType, i);
                if (!fOk)
                    return fOk;
            }

            return fOk;
        }


    }

    [TestGroup, TestCasePriority(3), DVT, EnvRequirement("Manual")]
        public class Packet_Xsp : TestNode
    {

        // ------------------------------------------------------------------------------
        // Basic tests
        // ------------------------------------------------------------------------------

        [TestCase, DVT]
            class VerifyEncryption_KeyexOnly_XspV1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV1();
                SignInAndQos();
            }
        }

        [TestCase, DVT]
            class VerifyEncryption_KeyexOnly_XspV2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
            }
        }

        [TestCase, DVT]
            class VerifyEncryption_VdpTest_XspV1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV1();
                SignInAndQos();
                Reflect2("vdp", XspHeader.XSP_TYPE_VDP_2, 16, 16);
                Reflect2("vdp", XspHeader.XSP_TYPE_VDP_2, 14, 18);
                Reflect2("vdp", XspHeader.XSP_TYPE_VDP_2, 12, 20);
            }
        }

        [TestCase, DVT]
            class VerifyEncryption_VdpTest_XspV2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
                Reflect2("vdp", XspHeader.XSP_TYPE_VDP_2, 16, 16);
                Reflect2("vdp", XspHeader.XSP_TYPE_VDP_2, 14, 18);
                Reflect2("vdp", XspHeader.XSP_TYPE_VDP_2, 12, 20);
            }
        }

        [TestCase, DVT, Description("16 byte payload, 2 bytes per port")]
            class Reflect_UDP_Basic : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
                Reflect2("udp", XspHeader.XSP_TYPE_UDP_2, 16, 0);
            }
        }

        [TestCase, DVT, Description("16 byte payload, 2 bytes per port")]
            class Reflect_TCP_Basic : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
                Reflect2("tcp", XspHeader.XSP_TYPE_TCP_2, 16, 0);
            }
        }

        [TestCase, DVT, Description("16 byte payload, 16 byte voice, 2 bytes per port")]
            class Reflect_VDP_Basic : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
                Reflect2("vdp", XspHeader.XSP_TYPE_VDP_2, 16, 16);
            }
        }

        [TestCase, DVT, Description("16 byte payload, 16 byte voice, 2 bytes per port")]
            class Reflect_VDP_DataOnly_Basic : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
                Reflect2("vdp_do", XspHeader.XSP_TYPE_VDP_DO_2, 16, 0);
            }
        }

        [TestCase, DVT, Description("16 byte payload, 16 byte voice, 2 bytes per port")]
            class Reflect_VDP_VoiceOnly_Basic : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
                Reflect2("vdp_vo", XspHeader.XSP_TYPE_VDP_VO_2, 0, 16);
            }
        }


        [TestCase, DVT, Description("Variety of types and sizes protected by ValueChecks")]
            class Reflect_VDP_Boundaries: TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                SignInAndQos();
                for (int iter = 0; iter < 2; iter++)
                {
                    if (iter == 0)
                    {
                        ro.Info("Running with XSPv1 (DES3)");
                        SetXspV1();
                    }
                    else if (iter == 1)
                    {
                        ro.Info("Running with XSPv2 (AES)");
                        SetXspV2();
                    }

                    // 1264 is max safe size. 
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_1, XspBuffer.PAYLOAD_MAXSAFESIZE - 2, 1), "safe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_2, XspBuffer.PAYLOAD_MAXSAFESIZE - 2, 1), "safe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_1, XspBuffer.PAYLOAD_MAXSAFESIZE - 8, 7), "safe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_2, XspBuffer.PAYLOAD_MAXSAFESIZE - 8, 7), "safe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_1, 1, XspBuffer.PAYLOAD_MAXSAFESIZE - 2), "safe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_2, 1, XspBuffer.PAYLOAD_MAXSAFESIZE - 2), "safe");
                    
                    // 1440 is max unsafe size.
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_1, XspBuffer.PAYLOAD_MAXUNSAFESIZE - 2, 1), "unsafe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_2, XspBuffer.PAYLOAD_MAXUNSAFESIZE - 2, 1), "unsafe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_1, XspBuffer.PAYLOAD_MAXUNSAFESIZE - 8, 7), "unsafe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_2, XspBuffer.PAYLOAD_MAXUNSAFESIZE - 8, 7), "unsafe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_1, 1, XspBuffer.PAYLOAD_MAXUNSAFESIZE - 2), "unsafe");
                    ValueCheck.IsTrue(Reflect2("na", XspHeader.XSP_TYPE_VDP_2, 1, XspBuffer.PAYLOAD_MAXUNSAFESIZE - 2), "unsafe");


                }
            }
        }

        [TestCase, DVT, Description("Multiple key exchanges per single source port")]
            class MultiConversation : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                
                SignInAndQos();
                ro.Info("Client spi (init) #1: 0x{0:X8}", sg.SPI);
                TestPaddingDataNoSignin("UDP_2", XspHeader.XSP_TYPE_UDP_2, 0);
                sg.SignOutSG();
                
                Thread.Sleep(1000);
                
                sg.IpServer.Port = 3074; 
                SignInAndQos();
                ro.Info("Client spi (init) #2: 0x{0:X8}", sg.SPI);
                TestPaddingDataNoSignin("TCP_2", XspHeader.XSP_TYPE_TCP_2, 0);
                sg.SignOutSG();
                Thread.Sleep(1000);
                
                sg.IpServer.Port = 3074; 
                SignInAndQos();
                ro.Info("Client spi (init) #2: 0x{0:X8}", sg.SPI);
                TestPaddingDataNoSignin("VDP_2", XspHeader.XSP_TYPE_VDP_2, 13);
                sg.SignOutSG();
                Thread.Sleep(1000);
                
                sg.IpServer.Port = 3074; 
                SignInAndQos();
                ro.Info("Client spi (init) #2: 0x{0:X8}", sg.SPI);
                TestPaddingDataNoSignin("UDP_2", XspHeader.XSP_TYPE_UDP_2, 0);
                TestPaddingDataNoSignin("TCP_2", XspHeader.XSP_TYPE_TCP_2, 0);
                TestPaddingDataNoSignin("VDP_2", XspHeader.XSP_TYPE_VDP_2, 12);
                TestPaddingDataNoSignin("TCP_0", XspHeader.XSP_TYPE_TCP_0, 0);
                sg.SignOutSG();
            }
        }


        // ------------------------------------------------------------------------------
        // UDP 
        // ------------------------------------------------------------------------------

        [TestCase, DVT]
            class Paddings_UDP_0_Config1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingData("UDP_0", XspHeader.XSP_TYPE_UDP_0);
            }
        }

        [TestCase, DVT]
            class Paddings_UDP_1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingData("UDP_1", XspHeader.XSP_TYPE_UDP_1);
            }
        }

        [TestCase, DVT]
            class Paddings_UDP_2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingData("UDP_2", XspHeader.XSP_TYPE_UDP_2);
            }
        }

        [TestCase, DVT]
            class Paddings_UDP_2_Old : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV1();
                TestPaddingData("UDP_2_Old", XspHeader.XSP_TYPE_UDP_2);
            }
        }


        // ------------------------------------------------------------------------------
        // TCP  
        // ------------------------------------------------------------------------------

        [TestCase, DVT]
            class Paddings_TCP_0 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingData("TCP_0", XspHeader.XSP_TYPE_TCP_0);
            }
        }

        [TestCase, DVT]
            class Paddings_TCP_1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingData("TCP_1", XspHeader.XSP_TYPE_TCP_1);
            }
        }

        [TestCase, DVT]
            class Paddings_TCP_2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingData("TCP_2", XspHeader.XSP_TYPE_TCP_2);
            }
        }

        [TestCase, DVT]
            class Paddings_TCP_2_Old : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV1();
                TestPaddingData("TCP_2_Old", XspHeader.XSP_TYPE_TCP_2);
            }
        }



        // ------------------------------------------------------------------------------
        // VDP
        // ------------------------------------------------------------------------------

        [TestCase, Ignore, DVT]
            class Paddings_VDP_0_Config2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_0", XspHeader.XSP_TYPE_VDP_0);
            }
        }

        [TestCase, DVT]
            class Paddings_VDP_1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_1", XspHeader.XSP_TYPE_VDP_1);
            }
        }

        [TestCase, DVT]
            class Paddings_VDP_2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_2", XspHeader.XSP_TYPE_VDP_2);
            }
        }

        [TestCase, DVT]
            class Paddings_VDP_2_Old : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV1();
                TestPaddingCombo("VDP_2_Old", XspHeader.XSP_TYPE_VDP_2);
            }
        }


        // ------------------------------------------------------------------------------
        // VDP_VO
        // ------------------------------------------------------------------------------

        [TestCase, Ignore, DVT]
            class Paddings_VDP_VO_0_Config2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_VO_0", XspHeader.XSP_TYPE_VDP_VO_0);
            }
        }

        [TestCase, DVT]
            class Paddings_VDP_VO_1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_VO_1", XspHeader.XSP_TYPE_VDP_VO_1);
            }
        }

        [TestCase, DVT]
            class Paddings_VDP_VO_2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_VO_2", XspHeader.XSP_TYPE_VDP_VO_2);
            }
        }



        // ------------------------------------------------------------------------------
        // VDP_DO
        // ------------------------------------------------------------------------------

        [TestCase, Ignore, DVT]
            class Paddings_VDP_DO_0_Config2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_DO_0", XspHeader.XSP_TYPE_VDP_DO_0);
            }
        }

        [TestCase, DVT]
            class Paddings_VDP_DO_1 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_DO_1", XspHeader.XSP_TYPE_VDP_DO_1);
            }
        }

        [TestCase, DVT]
            class Paddings_VDP_DO_2 : TestBase_Xsp
        {
            override protected void RunTest()
            {
                SetXspV2();
                TestPaddingCombo("VDP_DO_2", XspHeader.XSP_TYPE_VDP_DO_2);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSecmsgChalResp.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using xonline.common.config;
 
namespace XSGTest
{
    // The async challenge sequence goes something like this:
    //   SG sends challenge to client
    //   client sends ack to SG
    //   client retrieves and executes challenge
    //   client sends response to SG
    //   SG sends ack to client

    class TestBase_ChalRespAsync : TestBase_Keyex
    {
        // Shortcuts
        protected static NoChallengeException   ExNoChallenge   = new NoChallengeException("Expected no challenge");
        protected static NoAckException         ExNoAck         = new NoAckException("Expected no ack");
        //protected static NoConnectionException  ExNoConnection  = new NoConnectionException("");

        protected static int                ChalIntervalInSec   = 0;
        protected static int                AckIntervalInSec    = 0;
        protected static int                RespIntervalInSec   = 0;
        protected static bool               bVerbose            = true;

        protected Exception                 ExpectedException   = null;
        protected SecMsgSgToXbChal          sgChallenge         = null;
        protected SecMsgSgToXbChalRespAck   sgAck               = null;
        protected SecMsgDelete              sgDelete            = null;
        protected bool                      bExpectChallenge    = true;
        protected bool                      bExpectDisconnect   = false;
        protected byte[]                    chalResponse        = null;

        public ushort                       BuildNum            = 0x0010;  // Build 16 is our test challenge target build

        // Only used for auto-generated tests
        public bool         bAutoTest           = false;
        public int          ackNonce            = -1;
        public int          ackSize             = SecMsgXbToSgChalAck.SIZE;
        public int          ackPacketSize       = SecMsgXbToSgChalAck.SIZE;
        public int          respNonce           = -1;  
        public int          respSize            = SecMsgXbToSgChalResp2.SIZE;
        public int          respPacketSize      = SecMsgXbToSgChalResp2.SIZE;
        public bool         bPleaseKickMe       = false;
        public Exception    expectedExceptionBase = null;

        protected bool GotChallenge
        {
            get { return sgChallenge != null; }
        }

        protected bool GotAck
        {
            get { return sgAck != null; }
        }

        // Shortcut name
        protected Exception EE
        {
            get { return ExpectedException; }
            set { ExpectedException = value; }
        }

        #region Constructors and helpers

        /// <summary>
        /// Constructor for the normal manually-constructed tests
        /// </summary>
        public TestBase_ChalRespAsync() : base()
        {
            clientType = AuthContext.ClientTypes.Xenon;
        }

        /// <summary>
        /// Constructor for the auto-generated tests
        /// </summary>
        /// <param name="ackSize"></param>
        /// <param name="ackPacketSize"></param>
        /// <param name="respSize"></param>
        /// <param name="respPacketSize"></param>
        public TestBase_ChalRespAsync(
            int ackNonce,
            int ackSize, 
            int ackPacketSize,
            int respNonce,
            int respSize, 
            int respPacketSize,
            bool bSendInvalidAnswer)
        {
            string n = "CRA";

            // -1 means don't set this value
            this.bAutoTest = true;

            n += "_Ack";
            if (ackNonce != -1)
            {
                n += "_N" + ackNonce.ToString();
                this.ackNonce = ackNonce;
            }
            if (ackSize != -1)
            {
                n += "_S" + ackSize.ToString();
                this.ackSize = ackSize;
            }
            if (ackPacketSize != -1)
            {
                n += "_PS" + ackPacketSize.ToString();
                this.ackPacketSize = ackPacketSize;
            }

            n += "_Resp";
            if (respNonce != -1)
            {
                n += "_N" + respNonce.ToString();
                this.respNonce = respNonce;
            }
            if (respSize != -1)
            {
                n += "_S" + respSize.ToString();
                this.respSize = respSize;
            }
            if (respPacketSize != -1)
            {
                n += "_PS" + respPacketSize.ToString();
                this.respPacketSize = respPacketSize;
            }

            this.bPleaseKickMe = bSendInvalidAnswer;
            if (this.bPleaseKickMe)
            {
                n += "_Kick";
            }

            // Set the name
            this.Name = n;
        }

        protected void ChangeLogonUsers(bool bChangeTitle, bool bChangeUser1, bool bAddUser)
        {
            ro.Debug("[CR] ChangeLogonUsers...");
            Authdata_Base ad = sg.Context.Authdata;
            if (bChangeTitle)
            {
                ad.TitleId++;
            }
            if (bChangeUser1)
            {
                ad.GetUser(0).qwUserID++;
            }
            if (bAddUser)
            {
                ad.GetUser(1).qwUserID = ad.GetUser(0).qwUserID + 0x100;
            }
            sg.BuildFakeTicket(ad);
            ValueCheck.IsTrue(sg.SendChangeUsers(), "SendChangeUsers");
            ValueCheck.IsTrue(CheckConnection(), "Still signed in");
        }

        #endregion


        // SetDefaults
        // InitGroup
        // VerifyTest
        #region Base class overrides

        /// <summary>
        /// Reset all members to defaults since test instances are cached by STFRunner
        /// </summary>
        protected void Reset()
        {
            ExpectedException   = null;
            sgChallenge         = null;
            sgAck               = null;
            sgDelete            = null;
            bExpectDisconnect   = false;
            chalResponse        = null;
        }

        private string GetStringAttr(XmlNode n, string attr, string defaultVal)
        {
            XmlAttribute a = n.Attributes[attr];
            if (a == null || a.Value == null)
                return defaultVal;
            else
                return a.Value;
        }

        private int GetIntAttr(XmlNode n, string attr, int defaultVal)
        {
            string a = GetStringAttr(n, attr, null);
            if (a == null)
                return defaultVal;
            else
                return int.Parse(a);

        }

        protected override void SetDefaults()
        {
            base.SetDefaults ();

            Reset();

            // Determine the challenge interval one time
            if (ChalIntervalInSec == 0)
            {
                // We should probably look at the configdb for this setting? 
                // Maybe change it for this test group?
                // Hard code for now.

                try
                {
                    XConfig.CheckNpdbAccessibility();
                    ro.Info("[CR] Using NPDB for settings");
                    ChalIntervalInSec = Global.XEnv.GetIntSetting(Setting.sg_SgToXbChallengePeriodInSeconds);
                    AckIntervalInSec =  Global.XEnv.GetIntSetting(Setting.sg_XbToSgChallengeAckInSeconds);
                    RespIntervalInSec =  Global.XEnv.GetIntSetting(Setting.sg_XbToSgChallengeTimeoutInSeconds);
                }
                catch (Exception)
                {
                    // Hard code defaults but then look for overrides in the XML file
                    ChalIntervalInSec = 30;
                    AckIntervalInSec = 6;
                    RespIntervalInSec = 29;

                    XmlElement el = Global.GetEnvironmentSettingsGroup();
                    if (el != null)
                    {
                        XmlNodeList settings = el.SelectNodes("setting");
                        if (settings != null && settings.Count > 0)
                        {
                            foreach (XmlNode node in settings)
                            {
                                if (node.Attributes["name"].Value == "sg_SgToXbChallengePeriodInSeconds")
                                    ChalIntervalInSec = GetIntAttr(node, "value", ChalIntervalInSec);
                                if (node.Attributes["name"].Value == "sg_XbToSgChallengeAckInSeconds")
                                    AckIntervalInSec = GetIntAttr(node, "value", AckIntervalInSec);
                                if (node.Attributes["name"].Value == "sg_XbToSgChallengeTimeoutInSeconds")
                                    RespIntervalInSec = GetIntAttr(node, "value", RespIntervalInSec);
                            }
                        }
                    }
                    ro.Info("[CR] Using local source (XML or hard-coded) for settings");
                }

                // Add a fudge factor to the timeout values
                ChalIntervalInSec += 10;
                RespIntervalInSec += 5;
                ro.Info("[CR] Settings: ChalIntervalInSec={0}, AckIntervalInSec={1}, RespIntervalInSec={2}", 
                    ChalIntervalInSec,
                    AckIntervalInSec,
                    RespIntervalInSec);
            }
        }

        protected void InitGroup(AuthContext.ClientTypes clienttype, int numusers, ushort buildnum, uint titleid, uint titleversion)
        {
            sg.Context.ClientType = base.clientType;
            this.numSimulatedUsers = numusers;
            sg.Context.TitleInfo.TitleId = titleid;
            sg.Context.TitleInfo.TitleVersion = titleversion;
            sg.Context.TitleInfo.BuildNumber = buildnum;
            sg.bUseConnectionServices = true;

            // Set fields in authdata. Title id, build number, etc.
            sg.SetDefaultAuthdata(sg.Context.Authdata); 

            base.InitGroup();
        }

        protected override void InitGroup()
        {
            // Defaults
            InitGroup(AuthContext.ClientTypes.Xenon, 1, BuildNum, 0xC0FE0800, 0);

            // I believe we're assuming we won't get challenged at sign-in
            DoKeyExchange();
        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;


            bool bStillConnected = CheckConnection();
            if (this.bExpectDisconnect && bStillConnected)
            {
                Fail("[CR] Expected to be disconnected but we seem to still be able to communicate with the SG");
                return false;
            }
            else if (!this.bExpectDisconnect && !bStillConnected)
            {
                Fail("[CR] Expected to still be connected but the SG seems to have disconnected us");
                return false;
            }

            if (sgAck != null && sgChallenge != null && (sgAck.ChallengeNonce != sgChallenge.ChallengeNonce))
            {
                Fail("[CR] Challenge nonce does not match ACK nonce");
                return false;
            }

            if (sgAck != null)
            {
                if (sgAck.cbEnt != SecMsgSgToXbChalRespAck.SIZE)
                {
                    Fail("[CR] Ack from the SG has the wrong size, cbEnt={0} should be {1}", sgAck.cbEnt, SecMsgSgToXbChalRespAck.SIZE);
                }
            }

            return true;

        }

        #endregion


        // RecvLoop
        // CheckConnection
        // WaitPeriodForDisconnect
        #region Transport layer

        /// <summary>
        /// Specialized receive loop for chal/resp tests. Responds to heartbeats.
        /// </summary>
        /// <param name="timeoutInSeconds"></param>
        /// <param name="exitOnChal">Return from function if challenge is received</param>
        /// <param name="exitOnAck">Return from function if ACK is received</param>
        /// <returns>TRUE only if we exited early or we got something but no early exit requested</returns>
        protected bool RecvLoop(int timeoutInSeconds, bool exitOnChal, bool exitOnAck)
        {
            SecMsgHeader hdr = null;
            double startTime = base.TimerMs;
            double stopTime = TimerSeconds + timeoutInSeconds;
            while (TimerSeconds < stopTime)
            {
                int remainTime = (int)(stopTime - TimerSeconds);
                hdr = sg.SecMsgRecv(remainTime * 1000);
                if (hdr == null)
                {
                    return false;
                }

                if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL)
                {
                    sgChallenge = hdr as SecMsgSgToXbChal;
                    if (bVerbose)
                        ro.Debug("[CR] [{2:X8}] Got SECMSG_TYPE_SGTOXB_CHAL type=0x{0:X}, size={1} in {3} ms", hdr.Type, hdr.cbEnt, sgChallenge.ChallengeNonce, (int)(TimerMs - startTime));
                    if (exitOnChal)
                        return true;
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK)
                {
                    sgAck = hdr as SecMsgSgToXbChalRespAck;
                    if (bVerbose)
                        ro.Debug("[CR] [{2:X8}] Got SECMSG_TYPE_SGTOXB_CHALRESP_ACK type=0x{0:X}, size={1} in {3} ms", hdr.Type, hdr.cbEnt, sgAck.ChallengeNonce, (int)(TimerMs - startTime));
                    if (exitOnAck)
                        return true;
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2)
                {
                    if (bVerbose)
                        ro.Debug("[CR] Got SECMSG_TYPE_SGTOXB_PULSE_2 type=0x{0:X}, size={1} in {2} ms, replying...", hdr.Type, hdr.cbEnt, (int)(TimerMs - startTime));
                    // Respond with a heartbeat
                    sg.SendDataPulse();
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_DELETE)
                {
                    // We just got booted :(
                    sgDelete = hdr as SecMsgDelete;
                    if (bVerbose)
                        ro.Debug("[CR] Got SECMSG_TYPE_DELETE type=0x{0:X}, size={1} in {2} ms, replying...", hdr.Type, hdr.cbEnt, (int)(TimerMs - startTime));
                }
                else
                {
                    ro.Debug("[CR] Got unknown SECMSG type=0x{0:X} size={1} in {2} ms, ignoring...", hdr.Type, hdr.cbEnt, (int)(TimerMs - startTime));
                }
            }
            // Return true only if we got something AND the caller didn't request an early exit
            //return (hdr != null && !exitOnChal && !exitOnAck);
            return false;
        }

        /// <summary>
        /// Verify whether we are still connected to the SG or not. This can be done in 2 ways:
        ///   Did the SG send us a SECMSG_DELETE message?
        ///   Can we still communicate with the SG?  QoS is a good request/response test for this.
        /// </summary>
        /// <returns>True if still connected</returns>
        protected bool CheckConnection()
        {
            if (sgDelete != null)
            {
                // We got a delete message, so we're probably not connected..
                return false;
            }

            // Do something.  How about a QOS exchange?
            QOS q = new QOS();
            bool bSuccess = q.SendRecv(sg);

            if (bSuccess)
                ro.Debug("[CR] Still connected to the SG (passed QOS test)");
            else
                ro.Debug("[CR] Not connected to the SG (failed QOS test)");

            return bSuccess;
        }

        /// <summary>
        /// If we send no response, then it is expected the SG will disconnect us after X seconds,
        /// where generally X is the challenge interval minus one.  Call this function if you 
        /// expect that to happen, it will verify nothing gets received while waiting to be
        /// disconnected.
        /// </summary>
        protected void WaitPeriodForDisconnect()
        {
            if (bVerbose)
                ro.Debug("[CR] Waiting {0} seconds for the SG to disconnect us...", RespIntervalInSec);
            this.bExpectDisconnect = true;
            if (RecvLoop(RespIntervalInSec, true, true))
            {
                throw new NoDisconnectException("[CR] Received something, this is not expected");
            }
        }

        #endregion


        // WaitForChallenge(...)
        // WaitForAck(...)
        // SendAck(...)
        // ProcessChallenge(..)
        // SendResponse(...)
        #region Meaty functions for communicating with the SG
     
        /// <summary>
        /// Wait for an async challenge from the server
        /// </summary>
        /// <param name="timeoutInSeconds"></param>
        /// <returns></returns>
        protected bool WaitForChallenge(int timeoutInSeconds)
        {
            // Clear stored variables
            sgChallenge = null;
            sgAck = null;
            if (bVerbose)
                ro.Debug("[CR] Waiting {0} seconds for a challenge...", timeoutInSeconds);
            return RecvLoop(timeoutInSeconds, true, false);
        }

        /// <summary>
        /// Send ACK to server
        /// </summary>
        /// <param name="chalNonce"></param>
        protected void SendAck(uint chalNonce)
        {
            SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
            ack.ChallengeNonce = chalNonce;
            sg.XspSend(ack);
            if (bVerbose)
                ro.Debug("[CR] [{2:X8}] Sent SECMSG_TYPE_XBTOSG_CHAL_ACK type=0x{0:X}, size={1}", ack.Type, ack.cbEnt, chalNonce);
        }

        /// <summary>
        /// Send a degenerate ACK to server
        /// </summary>
        /// <param name="chalNonce"></param>
        protected void SendAck(uint chalNonce, int cbEnt, int packetSizeDelta)
        {
            SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
            ack.ChallengeNonce = (uint)chalNonce;
            ack.cbEnt = (short)cbEnt;
            sg.XspSendAdjustSize((byte[])ack, packetSizeDelta);
            if (bVerbose)
                ro.Debug("[CR] [{2:X8}] Sent SECMSG_TYPE_XBTOSG_CHAL_ACK type=0x{0:X}, size={1}, sizeDelta={3}", ack.Type, ack.cbEnt, chalNonce, packetSizeDelta);
        }

        /// <summary>
        /// Process the incoming challenge. What does this mean to an STFTest?
        /// </summary>
        protected void ProcessChallenge(bool bKickMe)
        {
            if (!GotChallenge)
            {
                throw new NoChallengeException("No challenge received, thus can't process it");
            }

            // Probably should do something meaningful here

            // For the test challenge that is hopefully configured,
            // chalResponse[0] == 0 means don't kick me
            // chalResponse[0] >= 1 means kick me
            chalResponse = new byte[1024];
            chalResponse[7] = 255;  // this will force 8 bytes (16 characters) to be logged, just to make life a bit easier
            if (bKickMe)
            {
                chalResponse[0] = 1;
                // Set expectations automagically
                EE = ExNoAck;
                bExpectDisconnect = true;
            }

            if (sgChallenge.IsLargeSupervisorChallenge())
            {
                LargeSupervisorChallenge lsc = sgChallenge.GetLargeSupervisorChallenge();
                if (bVerbose)
                    ro.Debug("[CR] [{0:X8}] Processing {1}{2}", 
                        sgChallenge.ChallengeNonce, 
                        bKickMe ? "(Kick) " : "",
                        lsc.ToString());
            }
            else
            {
                if (bVerbose)
                    ro.Debug("[CR] [{0:X8}] Processing {1}{2}", 
                        sgChallenge.ChallengeNonce, 
                        bKickMe ? "(Kick) " : "",
                        sgChallenge.ToString());
            }
        }

        /// <summary>
        /// Send a response (from a challenge) to server
        /// </summary>
        /// <param name="chalNonce"></param>
        protected void SendResponse(uint chalNonce)
        {
            SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
            resp.ChallengeNonce = chalNonce;
            resp.Execute = chalResponse;
            sg.XspSend(resp);
            if (bVerbose)
                ro.Debug("[CR] [{2:X8}] Sent SECMSG_TYPE_XBTOSG_CHALRESP_2 type=0x{0:X}, size={1}", resp.Type, resp.cbEnt, chalNonce);
        }

        /// <summary>
        /// Send a degenerate response (from a challenge) to server
        /// </summary>
        /// <param name="chalNonce"></param>
        /// <param name="cbEnt"></param>
        /// <param name="packetSizeDelta"></param>
        protected void SendResponse(uint chalNonce, int cbEnt, int packetSizeDelta)
        {
            SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
            resp.ChallengeNonce = (uint)chalNonce;
            resp.cbEnt = (short)cbEnt;
            resp.Execute = chalResponse;
            sg.XspSendAdjustSize((byte[])resp, packetSizeDelta);
            if (bVerbose)
                ro.Debug("[CR] [{2:X8}] Sent SECMSG_TYPE_XBTOSG_CHALRESP_2 type=0x{0:X}, size={1}, sizeDelta={3}", resp.Type, resp.cbEnt, chalNonce, packetSizeDelta);
        }

        /// <summary>
        /// Wait for an ACK from the server
        /// </summary>
        /// <param name="timeoutInSeconds"></param>
        /// <returns></returns>
        protected bool WaitForAck(int timeoutInSeconds)
        {
            sgAck = null;
            if (bVerbose)
                ro.Debug("[CR] Waiting {0} seconds for an ACK...", timeoutInSeconds);
            return RecvLoop(timeoutInSeconds, false, true);
        }


        #endregion


        // WaitForChallenge()
        // SendAck()
        // ProcessChallenge()
        // SendResponse()
        // WaitForAck()
        #region Virtual positive case wrappers, throw exceptions on fail. OVERRIDE THESE IN TESTS.

        /// <summary>
        /// Wait for a SECMSG challenge from the server. Must be signed in.
        /// </summary>
        protected virtual void WaitForChallenge()
        {
            if (!WaitForChallenge(ChalIntervalInSec))
            {
                throw new NoChallengeException("[CR] No challenge received in {0} seconds", ChalIntervalInSec);
            }
        }

        /// <summary>
        /// Send ACK to server using last seen ChallengeNonce
        /// </summary>
        protected virtual void SendAck()
        {
            if (!GotChallenge)
            {
                throw new NoChallengeException("[CR] No challenge received, thus no nonce available");
            }
            SendAck(this.sgChallenge.ChallengeNonce);
        }


        /// <summary>
        /// "Execute" the challenge and construct a response
        /// </summary>
        protected virtual void ProcessChallenge()
        {
            if (!GotChallenge)
            {
                throw new NoChallengeException("[CR] No challenge received, thus can't process it");
            }
            // Don't kick me by default
            ProcessChallenge(false);
        }   

        /// <summary>
        /// Send a response (from a challenge) to server using last seen ChallengeNonce
        /// </summary>
        protected virtual void SendResponse()
        {
            if (!GotChallenge)
            {
                throw new NoChallengeException("[CR] No challenge received, thus no nonce available, can't send response");
            }
            SendResponse(this.sgChallenge.ChallengeNonce);
        }
        
        /// <summary>
        /// Wait for ACK from server in response to the response we sent
        /// </summary>
        protected virtual void WaitForAck()
        {
            if (!WaitForAck(AckIntervalInSec))
            {
                throw new NoAckException("[CR] No server ack received in {0} seconds", AckIntervalInSec);
            }
        }

        ///<summary>
        /// Called after test is done, to clean up any stray resources the test might need to
        ///</summary>
        protected virtual void CleanUp() { }

        #endregion


        // RunTest
        // RunTestAuto
        #region Test runners

        protected override void RunTest()
        {
            if (bAutoTest)
            {
                RunTestAuto();
                return;
            }

            // Override any of the following as necessary
            try
            {
                WaitForChallenge();
                if (ResultCode == TEST_RESULTS.FAILED)
                    return;
                SendAck();
                if (ResultCode == TEST_RESULTS.FAILED)
                    return;
                ProcessChallenge();
                if (ResultCode == TEST_RESULTS.FAILED)
                    return;
                SendResponse();
                if (ResultCode == TEST_RESULTS.FAILED)
                    return;
                WaitForAck();
                if (ResultCode == TEST_RESULTS.FAILED)
                    return;

                // Did we expect an exception but got none?
                if (ExpectedException != null)
                {
                    Fail("[CR RunTest] Expected exception of type {0}", ExpectedException.GetType().ToString());
                }
            }
            catch (SgTestException e)
            {
                if (ExpectedException == null)
                {
                    // Error, No exception expected
                    throw;
                }
                else
                {
                    if (e.GetType() != ExpectedException.GetType())
                    {
                        // Error, Expected a different type
                        throw;
                    }
                    // Message included?

                }
            }
            finally
            {
                CleanUp();
            }
        }

        protected void RunTestAuto()
        {
            uint actualAckNonce;
            uint actualRespNonce;

            try
            {
                WaitForChallenge();
                if (ackNonce == -1)
                    actualAckNonce = sgChallenge.ChallengeNonce;
                else
                    actualAckNonce = (uint)ackNonce;

                SendAck(actualAckNonce, ackSize, ackPacketSize - SecMsgXbToSgChalAck.SIZE);

                // If we just sent an invalid ack, then we need to pretend we never received a challenge
                if (actualAckNonce != sgChallenge.ChallengeNonce ||
                    (int)ackSize < SecMsgXbToSgChalAck.SIZE ||
                    (int)ackPacketSize < SecMsgXbToSgChalAck.SIZE)
                {
                    uint oldNonce = sgChallenge.ChallengeNonce;
                    sgChallenge = null;
                    WaitForChallenge();

                    // Verify the nonce of the new challenges matches the old one, to ensure
                    // we got the same challenge instead of a new one
                    if (oldNonce != sgChallenge.ChallengeNonce)
                    {
                        Fail("Nonce of 2nd challenge doesn't match 1st challenge");
                        return;
                    }

                    // Send a proper ACK
                    SendAck();
                }

                ProcessChallenge(bPleaseKickMe);

                if (respNonce == -1)
                    actualRespNonce = sgChallenge.ChallengeNonce;
                else
                    actualRespNonce = (uint)respNonce;

                SendResponse(actualRespNonce, respSize, respPacketSize - SecMsgXbToSgChalResp2.SIZE);
                
                // If we just sent an invalid response, then we need to pretend like we never sent a response
                if (actualRespNonce != sgChallenge.ChallengeNonce ||
                    (int)respSize < SecMsgXbToSgChalResp2.SIZE ||
                    (int)respPacketSize < SecMsgXbToSgChalResp2.SIZE)
                {
                    EE = ExNoAck;

                    // If we were expecting to get disconnected because we sent a bad answer, then
                    // we need to change that expectation because the SG is going to toss our answer..
                    // thus we won't actually be kicked.
                    this.bExpectDisconnect = false;
                }
                WaitForAck();

                // Did we expect an exception but got none?
                if (ExpectedException != null)
                {
                    Fail("Expected exception of type {0}", ExpectedException.GetType().ToString());
                }
            }
            catch (SgTestException e)
            {
                if (ExpectedException == null)
                {
                    // Error, No exception expected
                    throw;
                }
                else
                {
                    if (e.GetType() != ExpectedException.GetType())
                    {
                        // Error, Expected a different type
                        throw;
                    }
                    // Message included?

                }
            }
            finally
            {
                CleanUp();
            }
        }

        #endregion




    }

    [AsyncThreadCount(25), AsyncGroup(1, 0, true)]
    [Description("Tests targeting the async challenge infrastructure.")]
    public class AsyncChallenges : GroupManagedLuaScriptTestNode
    {

        public override void PreRun ()
        {
            base.PreRun();

            LuaAreaLogListener.Start();
        }

        public override void PostRun ()
        {
            base.PostRun();

            LuaAreaLogListener.Stop();
        }

        [TestGroup]
        public class Fundamentals : TestNode
        {

            [TestCase]
            [PreconfiguredChallenge("LuaCM_BasicChallenge")]
            public class Mainline : AsyncChallengeTestNode
            {
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_BasicChallenge")]
            public class NotTargeted : AsyncChallengeTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.MajorVersion = 2;
                }

                protected override void ChallengeAssignmentTimeout ()
                {
                    TestComplete = true;
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_BasicChallenge")]
            public class MachineLogon_NoChallenge : AsyncChallengeTestNode
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.ClearUsers();
                    Sg.UseConnectionServices = false;
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    throw new UnexpectedTestResultException("We should not have gotten a challenge.");
                }

                protected override void ChallengeAssignmentTimeout ()
                {
                    TestComplete = true;
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_OverrideTimers")]
            public class OverrideTimers : AsyncChallengeTestNode
            {
                protected bool SecondTime;

                public override void PreRun ()
                {
                    base.PreRun();

                    SecondTime = false;
                }

                protected override void ChallengeResponseAckReceived (SecMsgSgToXbChalRespAck chalRespAck)
                {
                    if (SecondTime)
                    {
                        base.ChallengeResponseAckReceived(chalRespAck);
                    }
                    else
                    {
                        Period = 10;
                        AckTimeout = 10;
                        ResponseTimeout = 10;

                        SecondTime = true;
                    }
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_BasicChallenge")]
            [CompoundCase("{0}", 1)]
            [CompoundCase("{0}", 8)]
            [CompoundCase("{0}", 16)]
            [CompoundCase("{0}", 256)]
            [CompoundCase("{0}", 500)]
            [CompoundCase("{0}", 1023)]
            [CompoundCase("{0}", 1024)]
            public class VerifyDefaultBinary : AsyncChallengeTestNode
            {
                protected int ChalSize
                {
                    get
                    {
                        return (int)MyValues[0];
                    }
                }

                protected override void PostProcessBranchConstruction ()
                {
                    if (MyValues == null)
                    {
                        return;
                    }

                    LuaScript newScript = new LuaScript(PrimaryScript);
                    newScript.Blob = new byte[ChalSize];

                    for (int i = 0; i < ChalSize; ++i)
                    {
                        newScript.Blob[i] = (byte)(i % 256);
                    }

                    SetScript(newScript);
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    // combine arrays to make life a bit easier
                    byte[] fullChal = null;

                    if (challenge.ChalCode == null)
                    {
                        fullChal = challenge.PkSig;
                    }
                    else
                    {
                        fullChal = new byte[challenge.PkSig.Length + challenge.ChalCode.Length];
                        Buffer.BlockCopy(challenge.PkSig, 0, fullChal, 0, challenge.PkSig.Length);
                        Buffer.BlockCopy(challenge.ChalCode, 0, fullChal, challenge.PkSig.Length, challenge.ChalCode.Length);
                    }

                    // verify that the array we sent in is the one we got out
                    ValueCheck.Test("Challenge binary data", PrimaryScript.Blob, fullChal);

                    base.ChallengeReceived(challenge);
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_SendPerSpiBinary")]
            [CompoundCase("{0}", 1)]
            [CompoundCase("{0}", 8)]
            [CompoundCase("{0}", 16)]
            [CompoundCase("{0}", 256)]
            [CompoundCase("{0}", 500)]
            [CompoundCase("{0}", 1023)]
            [CompoundCase("{0}", 1024)]
            public class VerifyPerSpiBinary : AsyncChallengeTestNode
            {
                protected int ChalSize
                {
                    get
                    {
                        return (int)MyValues[0];
                    }
                }

                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)ChalSize;
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    // combine arrays to make life a bit easier
                    byte[] fullChal = null;

                    if (challenge.ChalCode == null)
                    {
                        fullChal = challenge.PkSig;
                    }
                    else
                    {
                        fullChal = new byte[challenge.PkSig.Length + challenge.ChalCode.Length];
                        Buffer.BlockCopy(challenge.PkSig, 0, fullChal, 0, challenge.PkSig.Length);
                        Buffer.BlockCopy(challenge.ChalCode, 0, fullChal, challenge.PkSig.Length, challenge.ChalCode.Length);
                    }

                    ValueCheck.Test("Challenge length", ChalSize, fullChal.Length);

                    for (int i = 0; i < ChalSize; ++i)
                    {
                        ValueCheck.Test("Challenge binary data", (byte)(i % 256), fullChal[i]);
                    }

                    base.ChallengeReceived(challenge);
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_VerifyBinaries")]
            public class VerifyParam : AsyncChallengeTestNode
            {
                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    if (challenge.Params.Length != 16)
                    {
                        throw new UnexpectedTestResultException("Challenge parameters should have been 16 bytes.");
                    }

                    for (int i = 0; i < 16; ++i)
                    {
                        if (challenge.Params[i] != (byte)i)
                        {
                            throw new UnexpectedTestResultException("Challenge parameters were not as expected: " + Hexer.tohex(challenge.Params));
                        }
                    }

                    base.ChallengeReceived(challenge);
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_VerifyBinaries")]
            public class VerifyResponse : AsyncChallengeTestNode
            {
                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    SendAck(challenge.ChallengeNonce);

                    byte[] resp = new byte[1024];
                    for (int i = 0; i < resp.Length; ++i)
                    {
                        resp[i] = (byte)(i % 256);
                    }

                    SendResponse(challenge.ChallengeNonce, resp);

                    ExpectLogWithManagedCounters("KICK");
                    ExpectLogWithManagedCounters("ANALYZE");
                }

                protected override void ChallengeResponseAckTimeout ()
                {
                    TestComplete = true;
                }

                protected override void ChallengeResponseAckReceived (SecMsgSgToXbChalRespAck chalRespAck)
                {
                    throw new UnexpectedTestResultException("We should have been kicked by the challenge.");
                }
            }

            // TODO : Chal.Log

        }

        [TestGroup]
        public class CorruptPackets : TestNode
        {

            public class CorruptPacketBase : AsyncChallengeTestNode
            {
                protected bool FirstTime;

                public override void PreRun ()
                {
                    base.PreRun();

                    FirstTime = true;
                }

                protected virtual void SendBadPacket (SecMsgSgToXbChal challenge)
                {
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    if (FirstTime)
                    {
                        SendBadPacket(challenge);
                        FirstTime = false;
                    }
                    else
                    {
                        base.ChallengeReceived(challenge);
                    }
                }
            }

            [TestGroup]
            public class Ack : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class SmallListSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
                        ack.ChallengeNonce = challenge.ChallengeNonce;

                        ack.cbEnt = SecMsgHeader.SIZE;

                        Sg.Send(ack);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class LargeListSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
                        ack.ChallengeNonce = challenge.ChallengeNonce;

                        ack.cbEnt = SecMsgXbToSgChalAck.SIZE + 4;

                        Sg.Send(ack);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class SmallPacketSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
                        ack.ChallengeNonce = challenge.ChallengeNonce;

                        XspBuffer buffer = Sg.Session.EncodeSecMsg((byte[])ack, SecMsgHeader.SIZE);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class LargePacketSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
                        ack.ChallengeNonce = challenge.ChallengeNonce;

                        byte[] ackBuffer = (byte[])ack;
                        byte[] ackMore = new byte[ackBuffer.Length + 4];
                        Buffer.BlockCopy(ackBuffer, 0, ackMore, 0, ackBuffer.Length);

                        XspBuffer buffer = Sg.Session.EncodeSecMsg(ackMore, (uint)ackMore.Length);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                        UpdateStateForSentAck();
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class SmallTotalSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
                        ack.ChallengeNonce = challenge.ChallengeNonce;

                        ack.cbEnt = SecMsgHeader.SIZE;

                        XspBuffer buffer = Sg.Session.EncodeSecMsg((byte[])ack, SecMsgHeader.SIZE);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class LargeTotalSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
                        ack.ChallengeNonce = challenge.ChallengeNonce;

                        ack.cbEnt = SecMsgXbToSgChalAck.SIZE + 4;

                        byte[] ackBuffer = (byte[])ack;
                        byte[] ackMore = new byte[ackBuffer.Length + 4];
                        Buffer.BlockCopy(ackBuffer, 0, ackMore, 0, ackBuffer.Length);

                        XspBuffer buffer = Sg.Session.EncodeSecMsg(ackMore, (uint)ackMore.Length);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                        UpdateStateForSentAck();
                    }
                }

            }

            [TestGroup]
            public class Resp : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class SmallListSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);

                        SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
                        resp.ChallengeNonce = challenge.ChallengeNonce;
                        resp.Execute = new byte[1024];

                        resp.cbEnt = SecMsgHeader.SIZE;

                        Sg.Send(resp);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class LargeListSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);

                        SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
                        resp.ChallengeNonce = challenge.ChallengeNonce;
                        resp.Execute = new byte[1024];

                        resp.cbEnt = SecMsgXbToSgChalResp2.SIZE + 4;

                        Sg.Send(resp);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class SmallPacketSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
                        resp.ChallengeNonce = challenge.ChallengeNonce;
                        resp.Execute = new byte[1024];

                        XspBuffer buffer = Sg.Session.EncodeSecMsg((byte[])resp, SecMsgHeader.SIZE);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class LargePacketSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
                        resp.ChallengeNonce = challenge.ChallengeNonce;
                        resp.Execute = new byte[1024];

                        byte[] respBuffer = (byte[])resp;
                        byte[] respMore = new byte[respBuffer.Length + 4];
                        Buffer.BlockCopy(respBuffer, 0, respMore, 0, respBuffer.Length);

                        XspBuffer buffer = Sg.Session.EncodeSecMsg(respMore, (uint)respMore.Length);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                        UpdateStateForSentResp();
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class SmallTotalSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
                        resp.ChallengeNonce = challenge.ChallengeNonce;
                        resp.Execute = new byte[1024];

                        resp.cbEnt = SecMsgHeader.SIZE;

                        XspBuffer buffer = Sg.Session.EncodeSecMsg((byte[])resp, SecMsgHeader.SIZE);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class LargeTotalSize : CorruptPacketBase
                {
                    protected override void SendBadPacket (SecMsgSgToXbChal challenge)
                    {
                        SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
                        resp.ChallengeNonce = challenge.ChallengeNonce;
                        resp.Execute = new byte[1024];

                        resp.cbEnt = SecMsgXbToSgChalResp2.SIZE + 4;

                        byte[] respBuffer = (byte[])resp;
                        byte[] respMore = new byte[respBuffer.Length + 4];
                        Buffer.BlockCopy(respBuffer, 0, respMore, 0, respBuffer.Length);

                        XspBuffer buffer = Sg.Session.EncodeSecMsg(respMore, (uint)respMore.Length);
                        Sg.Send(buffer);
                        XspBufferManager.Free(buffer);
                        UpdateStateForSentResp();
                    }
                }

            }

        }

        [TestGroup]
        public class ErrantPackets : TestNode
        {

            [TestGroup]
            public class AfterSignin : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectAck : AsyncChallengeTestNode
                {
                    protected override void ChallengeHeartbeat ()
                    {
                        if (TotalHeartbeatCount == 1)
                        {
                            SendAck((uint)RandomEx.GlobalRandGen.Next(), false);
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectResponse : AsyncChallengeTestNode
                {
                    protected override void ChallengeHeartbeat ()
                    {
                        if (TotalHeartbeatCount == 1)
                        {
                            SendResponse((uint)RandomEx.GlobalRandGen.Next(), new byte[1024], false);
                        }
                    }
                }

            }

            [TestGroup]
            public class ChallengeReceived : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectAck : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (CurrentChallengeReceiveCount == 1)
                        {
                            SendAck(challenge.ChallengeNonce + 1, false);
                        }
                        else
                        {
                            base.ChallengeReceived(challenge);
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectResponse : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (CurrentChallengeReceiveCount == 1)
                        {
                            SendResponse(challenge.ChallengeNonce + 1, new byte[1024], false);
                        }
                        else
                        {
                            base.ChallengeReceived(challenge);
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class CorrectResponseNoAck : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (CurrentChallengeReceiveCount == 1)
                        {
                            SendResponse(challenge.ChallengeNonce);
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("The SG rejected our response because we didn't ack the challenge.");
                        }
                    }
                }

            }

            [TestGroup]
            public class WaitingForResponse : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectAck : AsyncChallengeTestNode
                {
                    protected int HeartbeatCountEvent;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        HeartbeatCountEvent = -1;
                    }

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);
                        HeartbeatCountEvent = TotalHeartbeatCount;
                    }

                    protected override void ChallengeHeartbeat ()
                    {
                        if (HeartbeatCountEvent != -1)
                        {
                            if (HeartbeatCountEvent + 1 == TotalHeartbeatCount)
                            {
                                SendAck(CurrentChallenge.ChallengeNonce + 1, false);
                            }
                            else
                            {
                                SendResponse(CurrentChallenge.ChallengeNonce);
                            }
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class CorrectAck : AsyncChallengeTestNode
                {
                    protected int HeartbeatCountEvent;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        HeartbeatCountEvent = -1;
                    }

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);
                        HeartbeatCountEvent = TotalHeartbeatCount;
                    }

                    protected override void ChallengeHeartbeat ()
                    {
                        if (HeartbeatCountEvent != -1)
                        {
                            if (HeartbeatCountEvent + 1 == TotalHeartbeatCount)
                            {
                                SendAck(CurrentChallenge.ChallengeNonce, false);
                            }
                            else
                            {
                                SendResponse(CurrentChallenge.ChallengeNonce);
                            }
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectResponse : AsyncChallengeTestNode
                {
                    protected int HeartbeatCountEvent;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        HeartbeatCountEvent = -1;
                    }

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);
                        SendResponse(challenge.ChallengeNonce + 1, new byte[1024], false);
                        HeartbeatCountEvent = TotalHeartbeatCount;
                    }

                    protected override void ChallengeHeartbeat ()
                    {
                        if (HeartbeatCountEvent != -1)
                        {
                            SendResponse(CurrentChallenge.ChallengeNonce);
                        }
                    }
                }

            }

            [TestGroup]
            public class Idle : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectAck : AsyncChallengeTestNode
                {
                    protected int HeartbeatCountEvent;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        HeartbeatCountEvent = -1;
                    }

                    protected override void ChallengeResponseAckReceived (SecMsgSgToXbChalRespAck chalRespAck)
                    {
                        if (ChallengesCompleted == 0)
                        {
                            HeartbeatCountEvent = TotalHeartbeatCount;
                        }
                        else
                        {
                            TestComplete = true;
                        }
                    }

                    protected override void ChallengeHeartbeat ()
                    {
                        if (HeartbeatCountEvent != -1)
                        {
                            SendAck((uint)RandomEx.GlobalRandGen.Next(), false);
                            HeartbeatCountEvent = 0;
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class IncorrectResponse : AsyncChallengeTestNode
                {
                    protected int HeartbeatCountEvent;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        HeartbeatCountEvent = -1;
                    }

                    protected override void ChallengeResponseAckReceived (SecMsgSgToXbChalRespAck chalRespAck)
                    {
                        if (ChallengesCompleted == 0)
                        {
                            HeartbeatCountEvent = TotalHeartbeatCount;
                        }
                        else
                        {
                            TestComplete = true;
                        }
                    }

                    protected override void ChallengeHeartbeat ()
                    {
                        if (HeartbeatCountEvent != -1)
                        {
                            SendResponse((uint)RandomEx.GlobalRandGen.Next(), new byte[1024], false);
                            HeartbeatCountEvent = 0;
                        }
                    }
                }

            }

        }

        [TestGroup]
        public class NonResponse : TestNode
        {

            [TestGroup]
            public class ChallengeReceived : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class Disconnect : AsyncChallengeTestNode
                {
                    protected bool AfterDrop;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        AfterDrop = false;
                    }

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (!AfterDrop)
                        {
                            ExpectLogWithManagedCounters("DROPPED");
                            Sg.Disconnect();

                            // wait 1 second to ensure we can sign in again
                            Thread.Sleep(1000);

                            Sg.Connect();
                            ResetState();
                            ResetChallengeLogCounters();
                            AfterDrop = true;
                        }
                        else
                        {
                            if (challenge.Params[3] != 1)
                            {
                                throw new UnexpectedTestResultException("Expected to see a single ChallengeDropped call, got: " + challenge.Params[3]);
                            }

                            // do the default thing (golden path)
                            base.ChallengeReceived(challenge);
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class InactivityDisconnect : AsyncChallengeTestNode
                {
                    protected bool AfterDrop;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        AfterDrop = false;
                    }

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendHeartbeats = false;

                        if (CurrentChallengeReceiveCount > 120)
                        {
                            throw new UnexpectedTestResultException("We should have been disconnected by now.");
                        }
                    }

                    protected override void ChallengeAckTimeout ()
                    {
                        if (IsStillSignedIn())
                        {
                            throw new UnexpectedTestResultException("We should have been disconnected due to inactivity.");
                        }

                        ExpectLogWithManagedCounters("DROPPED");
                        TestComplete = true;
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class NoAckDefaultKick : AsyncChallengeTestNode
                {
                    protected const int AckTimeoutLimit = 4;

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (CurrentChallengeReceiveCount > AckTimeoutLimit)
                        {
                            throw new UnexpectedTestResultException("Should have been kicked by the default ack timeout behavior.");
                        }
                    }

                    protected override void ChallengeAckTimeout ()
                    {
                        if (CurrentChallengeReceiveCount != AckTimeoutLimit || IsStillSignedIn())
                        {
                            throw new UnexpectedTestResultException("We should have been kicked after exactly " + AckTimeoutLimit + 
                                " resends, got: " + CurrentChallengeReceiveCount);
                        }

                        // add the logs for being kicked on the last timeout
                        ExpectLog("KICK", 1, AckTimeoutLimit, 0);
                        ExpectLog("TIMEOUTACK", 1, AckTimeoutLimit, 0);

                        // attempt to reconnect to ensure that we were only kicked
                        Sg.SetDisconnected();

                        // change authdata so that we aren't targeted by a challenge
                        Sg.Context.Authdata.MajorVersion = 2;
                        Sg.ClearTicketCache();

                        Sg.Connect();

                        TestComplete = true;
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class NoAckNoResponse : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (CurrentChallengeReceiveCount == 10)
                        {
                            TestComplete = true;
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class NoAckSlowResponse : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (CurrentChallengeReceiveCount > 10)
                        {
                            // allow 1 extra challenge receive, then throw
                            throw new UnexpectedTestResultException("The SG ignored our slow response.");
                        }

                        if (CurrentChallengeReceiveCount > 9)
                        {
                            SendResponse(CurrentChallenge.ChallengeNonce);
                        }
                    }
                }

            }

            [TestGroup]
            public class WaitingForResponse : TestNode
            {

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class Disconnect : AsyncChallengeTestNode
                {
                    protected bool AfterDrop;
                    protected int HeartbeatCountEvent;

                    public override void PreRun ()
                    {
                        base.PreRun();

                        AfterDrop = false;
                        HeartbeatCountEvent = -1;
                    }

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        if (!AfterDrop)
                        {
                            SendAck(challenge.ChallengeNonce);

                            if (HeartbeatCountEvent == -1)
                            {
                                HeartbeatCountEvent = TotalHeartbeatCount;
                            }
                        }
                        else
                        {
                            if (challenge.Params[3] != 1)
                            {
                                throw new UnexpectedTestResultException("Expected to see a single ChallengeDropped call, got: " + challenge.Params[3]);
                            }

                            // do the default thing (golden path)
                            base.ChallengeReceived(challenge);
                        }
                    }

                    protected override void ChallengeHeartbeat ()
                    {
                        if (HeartbeatCountEvent != -1 && HeartbeatCountEvent + 1 == TotalHeartbeatCount)
                        {
                            ExpectLogWithManagedCounters("DROPPED");
                            Sg.Disconnect();

                            // wait 1 second to ensure we can sign in again
                            Thread.Sleep(1000);

                            Sg.Connect();
                            ResetState();
                            ResetChallengeLogCounters();
                            AfterDrop = true;
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_BasicChallenge")]
                public class NoResponseDefaultKick : AsyncChallengeTestNode
                {
                    protected const int RespTimeoutLimit = 2;

                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);

                        if (CurrentChallengeReceiveCount > RespTimeoutLimit)
                        {
                            throw new UnexpectedTestResultException("Should have been kicked by the default response timeout behavior.");
                        }
                    }

                    protected override void ChallengeResponseTimeout ()
                    {
                        if (CurrentChallengeReceiveCount != RespTimeoutLimit || IsStillSignedIn())
                        {
                            throw new UnexpectedTestResultException("We should have been kicked after exactly " + RespTimeoutLimit + 
                                " resends, got: " + CurrentChallengeReceiveCount);
                        }

                        // add the logs for being kicked on the last timeout
                        ExpectLog("KICK", 1, 0, RespTimeoutLimit);
                        ExpectLog("TIMEOUTRESP", 1, 0, RespTimeoutLimit);

                        // attempt to reconnect to ensure that we were only kicked
                        Sg.SetDisconnected();

                        // change authdata so that we aren't targeted by a challenge
                        Sg.Context.Authdata.MajorVersion = 2;
                        Sg.ClearTicketCache();

                        Sg.Connect();

                        TestComplete = true;
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class NoResponse : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);

                        if (CurrentChallengeReceiveCount == 10)
                        {
                            TestComplete = true;
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class NoResponseKeepAcking : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);

                        if (CurrentChallengeReceiveCount == 10)
                        {
                            TestComplete = true;
                        }
                    }

                    protected override void ChallengeHeartbeat ()
                    {
                        if (CurrentChallenge != null)
                        {
                            SendAck(CurrentChallenge.ChallengeNonce, false);
                        }
                    }
                }

                [TestCase]
                [PreconfiguredChallenge("LuaCM_NonResponse")]
                public class SelectiveResponse : AsyncChallengeTestNode
                {
                    protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                    {
                        SendAck(challenge.ChallengeNonce);

                        if (CurrentChallengeReceiveCount == 10)
                        {
                            SendResponse(challenge.ChallengeNonce);
                        }
                    }
                }

            }

        }

        [TestGroup]
        public class AuthdataChanges : TestNode
        {

            public enum AuthdataChange
            {
                User,
                UserCountry,
                UserGuest,
                Title,
                TitleVersion,
                Flowtoken,
                Version,
                BaseServices,
                ExtendedServices,
                AuthdataFlags,
                // These below do not trigger a reset
                LanguageId,
                MachinePrivileges,
            }

            public class AuthdataChangeBase : AsyncChallengeTestNode
            {
                protected bool AuthdataChanged;
                protected bool ChallengesReset;

                public override void PreRun ()
                {
                    Sg = CreateNewConnection(ClientType, 2);

                    base.PreRun();

                    AuthdataChanged = false;
                    AcceptNewChallenges = true;
                    ChallengesReset = false;
                }

                protected void ChangeAuthdata ()
                {
                    AuthdataChange change = (AuthdataChange)MyValues[0];
                    Authdata_Base authdata = Sg.Context.Authdata;

                    #region Authdata Modification

                    switch (change)
                    {
                        case AuthdataChange.User:
                            {
                                XUserID user = authdata.GetUser((uint)(RandomEx.GlobalRandGen.Next() % 4));
                                if (user.Exists)
                                {
                                    if (RandomEx.GlobalRandGen.NextBool())
                                    {
                                        user.qwUserID = XUserID.NextUserID;
                                    }
                                    else
                                    {
                                        user.qwUserID = 0;
                                        user.dwUserFlags = 0;
                                    }
                                }
                                else
                                {
                                    user.SetDefaults();
                                }

                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.UserCountry:
                            {
                                XUserID user = authdata.GetUser((uint)(RandomEx.GlobalRandGen.Next() % 2));
                                user.CountryId++;
                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.UserGuest:
                            {
                                XUserID user = authdata.GetUser((uint)(RandomEx.GlobalRandGen.Next() % 2));
                                user.IsGuest = !user.IsGuest;
                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.Title:
                            {
                                authdata.TitleId++;
                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.Flowtoken:
                            {
                                authdata.Flowtoken++;
                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.Version:
                            {
                                ushort oldVersion = authdata.MajorVersion;
                                authdata.MajorVersion = 2;
                                // by sending it now, we will cause the next one to actually prod the same code path again
                                Sg.SendChangeUsers();
                                authdata.MajorVersion = oldVersion;
                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.BaseServices:
                            {
                                uint[] privs = authdata.GetCombinedPrivileges();
                                privs[0] = privs[0] ^ 0x52;
                                authdata.SetCombinedPrivileges(privs);
                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.ExtendedServices:
                            {
                                authdata.AddExtendedService(0xDEADBEEF);
                                ChallengesReset = true;
                            }
                            break;

                        case AuthdataChange.TitleVersion:
                            authdata.TitleVersion++;
                            ChallengesReset = true;
                            break;

                        case AuthdataChange.AuthdataFlags:
                            authdata.AuthDataFlags = authdata.AuthDataFlags ^ Authdata_Xenon2.FLAGS_ISBETAMACHINE;
                            ChallengesReset = true;
                            break;

                        case AuthdataChange.LanguageId:
                            authdata.LanguageID++;
                            break;

                        case AuthdataChange.MachinePrivileges:
                            {
                                uint[] privs = authdata.GetCombinedPrivileges();
                                privs[4] = privs[4] ^ 0x52;
                                authdata.SetCombinedPrivileges(privs);
                            }
                            break;
                    }

                    #endregion

                    // send the change users sec msg
                    Sg.SendChangeUsers();

                    while (Sg.ChangeUsersPending)
                    {
                        Thread.Sleep(10);

                        Sg.ProcessReceiveQueue();
                        Sg.ProdChangeUsers();
                    }

                    // any of these changes should have reset the state
                    if (ChallengesReset)
                    {
                        ResetState(false);
                    }
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_BasicChallenge")]
            [CompoundCase("{0}", AuthdataChange.User)]
            [CompoundCase("{0}", AuthdataChange.UserCountry)]
            [CompoundCase("{0}", AuthdataChange.UserGuest)]
            [CompoundCase("{0}", AuthdataChange.Title)]
            [CompoundCase("{0}", AuthdataChange.Flowtoken)]
            [CompoundCase("{0}", AuthdataChange.Version)]
            [CompoundCase("{0}", AuthdataChange.BaseServices)]
            [CompoundCase("{0}", AuthdataChange.ExtendedServices)]
            [CompoundCase("{0}", AuthdataChange.TitleVersion)]
            [CompoundCase("{0}", AuthdataChange.LanguageId)]
            [CompoundCase("{0}", AuthdataChange.MachinePrivileges)]
            [CompoundCase("{0}", AuthdataChange.AuthdataFlags)]
            public class WaitingForAck : AuthdataChangeBase
            {
                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    if (AuthdataChanged)
                    {
                        if (ChallengesReset)
                        {
                            // this means the challenge didn't change
                            if (CurrentChallengeReceiveCount != 1)
                            {
                                throw new UnexpectedTestResultException("The challenge did not change.");
                            }
                        }
                        else
                        {
                            // this means the challenge changed
                            if (CurrentChallengeReceiveCount != 2)
                            {
                                throw new UnexpectedTestResultException("The challenge changed.");
                            }
                        }

                        base.ChallengeReceived(challenge);
                    }
                    else
                    {
                        ChangeAuthdata();
                        AuthdataChanged = true;
                    }
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_BasicChallenge")]
            [CompoundCase("{0}", AuthdataChange.User)]
            [CompoundCase("{0}", AuthdataChange.UserCountry)]
            [CompoundCase("{0}", AuthdataChange.UserGuest)]
            [CompoundCase("{0}", AuthdataChange.Title)]
            [CompoundCase("{0}", AuthdataChange.Flowtoken)]
            [CompoundCase("{0}", AuthdataChange.Version)]
            [CompoundCase("{0}", AuthdataChange.BaseServices)]
            [CompoundCase("{0}", AuthdataChange.ExtendedServices)]
            [CompoundCase("{0}", AuthdataChange.TitleVersion)]
            [CompoundCase("{0}", AuthdataChange.LanguageId)]
            [CompoundCase("{0}", AuthdataChange.MachinePrivileges)]
            [CompoundCase("{0}", AuthdataChange.AuthdataFlags)]
            public class WaitingForResp : AuthdataChangeBase
            {
                protected int HeartbeatCountEvent;

                public override void PreRun ()
                {
                    base.PreRun();

                    HeartbeatCountEvent = -1;
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    if (AuthdataChanged)
                    {
                        if (ChallengesReset)
                        {
                            // this means the challenge didn't change
                            if (CurrentChallengeReceiveCount != 1)
                            {
                                throw new UnexpectedTestResultException("The challenge did not change.");
                            }
                        }
                        else
                        {
                            // this means the challenge changed
                            if (CurrentChallengeReceiveCount < 2)
                            {
                                throw new UnexpectedTestResultException("The challenge changed.");
                            }
                        }

                        base.ChallengeReceived(challenge);
                    }
                    else if (HeartbeatCountEvent == -1)
                    {
                        SendAck(challenge.ChallengeNonce);
                        HeartbeatCountEvent = TotalHeartbeatCount;
                    }
                }

                protected override void ChallengeHeartbeat ()
                {
                    if (HeartbeatCountEvent + 1 == TotalHeartbeatCount)
                    {
                        ChangeAuthdata();
                        AuthdataChanged = true;
                    }
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_BasicChallenge")]
            [CompoundCase("{0}", AuthdataChange.User)]
            [CompoundCase("{0}", AuthdataChange.UserCountry)]
            [CompoundCase("{0}", AuthdataChange.UserGuest)]
            [CompoundCase("{0}", AuthdataChange.Title)]
            [CompoundCase("{0}", AuthdataChange.Flowtoken)]
            [CompoundCase("{0}", AuthdataChange.Version)]
            [CompoundCase("{0}", AuthdataChange.BaseServices)]
            [CompoundCase("{0}", AuthdataChange.ExtendedServices)]
            [CompoundCase("{0}", AuthdataChange.TitleVersion)]
            [CompoundCase("{0}", AuthdataChange.LanguageId)]
            [CompoundCase("{0}", AuthdataChange.MachinePrivileges)]
            [CompoundCase("{0}", AuthdataChange.AuthdataFlags)]
            public class Idle : AuthdataChangeBase
            {
                protected int HeartbeatCountEvent;

                public override void PreRun ()
                {
                    base.PreRun();

                    HeartbeatCountEvent = -1;
                }

                protected override void ChallengeResponseAckReceived (SecMsgSgToXbChalRespAck chalRespAck)
                {
                    if (AuthdataChanged)
                    {
                        base.ChallengeResponseAckReceived(chalRespAck);
                    }
                    else if (HeartbeatCountEvent == -1)
                    {
                        HeartbeatCountEvent = TotalHeartbeatCount;
                    }
                }

                protected override void ChallengeHeartbeat ()
                {
                    if (HeartbeatCountEvent + 1 == TotalHeartbeatCount)
                    {
                        ChangeAuthdata();
                        AuthdataChanged = true;
                    }
                }
            }

        }

        [TestGroup]
        public class ChallengeChanges : TestNode
        {

            public enum LuaEntryPoints
            {
                Target = 0x1,
                Analyze = 0x2,
                Dropped = 0x3,
                AckTimeout = 0x4,
                RespTimeout = 0x5,
            }

            public enum ChallengeChangeOptions
            {
                Id = 0,
                Param = 1,
                Enable = 2,
            }

            public class KickAndBlockBase : AsyncChallengeTestNode
            {
                public KickAndBlockBase ()
                {
                    SetScripts(new LuaScript[] { 
                        ChallengeManager.PreconfiguredLuaScripts["LuaCM_ChangeChallenge"], 
                        SecondScript
                    });
                }

                protected LuaScript SecondScript
                {
                    get
                    {
                        return ChallengeManager.PreconfiguredLuaScripts["LuaCM_BasicChallenge"];
                    }
                }

                protected LuaScript CurrentScript;

                protected override LuaScript PrimaryScript
                {
                    get
                    {
                        return CurrentScript;
                    }
                }

                public override void PreRun ()
                {
                    CurrentScript = base.PrimaryScript;

                    base.PreRun();
                }

                protected ChallengeChangeOptions Change
                {
                    get
                    {
                        return (ChallengeChangeOptions)MyValues[0];
                    }
                }
            }

            [TestCase]
            [CompoundCase("{0}", ChallengeChangeOptions.Param)]
            [CompoundCase("{0}", ChallengeChangeOptions.Enable)]
            public class Target : KickAndBlockBase
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.Target;
                    Sg.Context.Authdata.TitleRegion = (uint)Change;

                    if (Change == ChallengeChangeOptions.Param)
                    {
                        ChallengeParamId = 1;
                    }
                }

                protected override void ChallengeAssignmentTimeout ()
                {
                    if (Change == ChallengeChangeOptions.Enable)
                    {
                        TestComplete = true;
                    }
                    else
                    {
                        base.ChallengeAssignmentTimeout();
                    }
                }
            }

            [TestCase]
            [CompoundCase("{0}", ChallengeChangeOptions.Enable)]
            public class Analyze : KickAndBlockBase
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.Analyze;
                    Sg.Context.Authdata.TitleRegion = (uint)Change;

                    if (Change == ChallengeChangeOptions.Id)
                    {
                        Sg.Context.Authdata.TitleRegion = GetGroupScriptManager().GetChallengeIdForScript(SecondScript);
                    }
                }

                protected override void ChallengeAssignmentTimeout ()
                {
                    if (Change == ChallengeChangeOptions.Enable && ChallengesCompleted > 0)
                    {
                        TestComplete = true;
                    }
                    else
                    {
                        base.ChallengeAssignmentTimeout();
                    }
                }
            }

            [TestCase]
            [CompoundCase("{0}", ChallengeChangeOptions.Id)]
            [CompoundCase("{0}", ChallengeChangeOptions.Param)]
            [CompoundCase("{0}", ChallengeChangeOptions.Enable)]
            public class AckTimeout : KickAndBlockBase
            {
                protected SecMsgSgToXbChal FirstChallenge;

                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.AckTimeout;
                    Sg.Context.Authdata.TitleRegion = (uint)Change;

                    if (Change == ChallengeChangeOptions.Id)
                    {
                        Sg.Context.Authdata.TitleRegion = GetGroupScriptManager().GetChallengeIdForScript(SecondScript);
                    }

                    FirstChallenge = null;
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    if (FirstChallenge == null)
                    {
                        FirstChallenge = challenge;

                        if (Change == ChallengeChangeOptions.Id)
                        {
                            CurrentScript = SecondScript;
                            AcceptNewChallenges = true;
                        }
                        else if (Change == ChallengeChangeOptions.Param)
                        {
                            ChallengeParamId = 1;
                            AcceptNewChallenges = true;
                        }
                    }
                    else
                    {
                        // make sure the challenges are different
                        if (CurrentChallengeReceiveCount != 1)
                        {
                            throw new UnexpectedTestResultException("Challenge did not change.");
                        }

                        TestComplete = true;
                    }
                }

                protected override void ChallengeAckTimeout ()
                {
                    if (Change == ChallengeChangeOptions.Enable)
                    {
                        ExpectLog("TIMEOUTACK");
                        TestComplete = true;
                    }
                    else
                    {
                        base.ChallengeAckTimeout();
                    }
                }
            }

            [TestCase]
            [CompoundCase("{0}", ChallengeChangeOptions.Id)]
            [CompoundCase("{0}", ChallengeChangeOptions.Param)]
            [CompoundCase("{0}", ChallengeChangeOptions.Enable)]
            public class RespTimeout : KickAndBlockBase
            {
                protected SecMsgSgToXbChal FirstChallenge;

                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.RespTimeout;
                    Sg.Context.Authdata.TitleRegion = (uint)Change;

                    if (Change == ChallengeChangeOptions.Id)
                    {
                        Sg.Context.Authdata.TitleRegion = GetGroupScriptManager().GetChallengeIdForScript(SecondScript);
                    }

                    FirstChallenge = null;
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    if (FirstChallenge == null)
                    {
                        SendAck(challenge.ChallengeNonce);

                        FirstChallenge = challenge;

                        if (Change == ChallengeChangeOptions.Id)
                        {
                            CurrentScript = SecondScript;
                            AcceptNewChallenges = true;
                        }
                        else if (Change == ChallengeChangeOptions.Param)
                        {
                            ChallengeParamId = 1;
                            AcceptNewChallenges = true;
                        }
                    }
                    else
                    {
                        // make sure the challenges are different
                        if (CurrentChallengeReceiveCount != 1)
                        {
                            throw new UnexpectedTestResultException("Challenge did not change.");
                        }

                        TestComplete = true;
                    }
                }

                protected override void ChallengeResponseTimeout ()
                {
                    if (Change == ChallengeChangeOptions.Enable)
                    {
                        ExpectLog("TIMEOUTRESP");
                        TestComplete = true;
                    }
                    else
                    {
                        base.ChallengeAckTimeout();
                    }
                }
            }

        }

        [TestGroup]
        public class KickAndBlock : TestNode
        {

            public enum LuaEntryPoints
            {
                Target = 0x1,
                Analyze = 0x2,
                Dropped = 0x3,
                AckTimeout = 0x4,
                RespTimeout = 0x5,
            }

            public enum LuaResponseOptions
            {
                Kick = 0,
                Block = 1,
            }

            public class KickAndBlockBase : AsyncChallengeTestNode
            {
                protected void ExpectLogAndKickOrBlock (string log)
                {
                    switch ((LuaResponseOptions)MyValues[0])
                    {
                        case LuaResponseOptions.Kick:
                            // add the log for being kicked
                            ExpectLog("KICK");
                            break;

                        case LuaResponseOptions.Block:
                            // add the log for being blocked
                            ExpectLog("BLOCK");
                            break;
                    }

                    ExpectLog(log);
                }

                protected void ExpectLogAndKickOrBlockEmpty (string log)
                {
                    switch ((LuaResponseOptions)MyValues[0])
                    {
                        case LuaResponseOptions.Kick:
                            // add the log for being kicked
                            ExpectLog(Sg, "KICK", null, 0, 0, 0, 0);
                            break;

                        case LuaResponseOptions.Block:
                            // add the log for being blocked
                            ExpectLog(Sg, "BLOCK", null, 0, 0, 0, 0);
                            break;
                    }

                    ExpectLog(log);
                }

                protected void CheckLuaResponse ()
                {
                    // wait 1 second to ensure we can sign in again
                    Thread.Sleep(1000);

                    switch ((LuaResponseOptions)MyValues[0])
                    {
                        case LuaResponseOptions.Kick:
                            if (IsStillSignedIn())
                            {
                                throw new UnexpectedTestResultException("We should have been kicked by the challenge.");
                            }

                            // attempt to reconnect to ensure that we were only kicked
                            Sg.SetDisconnected();

                            // change authdata so that we aren't targeted by a challenge
                            Sg.Context.Authdata.MajorVersion = 2;
                            Sg.ClearTicketCache();

                            Sg.Connect();
                            break;

                        case LuaResponseOptions.Block:
                            if (IsStillSignedIn())
                            {
                                throw new UnexpectedTestResultException("We should have been block-dropped by the challenge.");
                            }

                            // attempt to reconnect to ensure that we were blocked
                            Sg.SetDisconnected();

                            // change authdata so that we aren't targeted by a challenge
                            Sg.Context.Authdata.MajorVersion = 2;
                            Sg.ClearTicketCache();

                            try
                            {
                                Sg.Connect();
                                throw new UnexpectedTestResultException("We should have been blocked by the challenge.");
                            }
                            catch (ServerTestFramework.Utilities.TimeoutException)
                            {
                                // this is the correct thing
                            }
                            break;
                    }
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_KickBlock")]
            [CompoundCase("{0}", LuaResponseOptions.Kick, false)]
            [CompoundCase("{0}", LuaResponseOptions.Block, false)]
            public class Target : KickAndBlockBase
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.Target;
                    Sg.Context.Authdata.TitleRegion = (uint)(LuaResponseOptions)MyValues[0];
                    Sg.Context.Authdata.TitleId = (uint)((bool)MyValues[1] ? 1 : 0);
                }

                protected override void ChallengeAssignmentTimeout ()
                {
                    ExpectLogAndKickOrBlockEmpty("SELECT");
                    CheckLuaResponse();
                    TestComplete = true;
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_KickBlock")]
            [CompoundCase("{0}", LuaResponseOptions.Kick, false)]
            [CompoundCase("{0}", LuaResponseOptions.Block, false)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Kick, true)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Block, true)]
            public class Analyze : KickAndBlockBase
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.Analyze;
                    Sg.Context.Authdata.TitleRegion = (uint)(LuaResponseOptions)MyValues[0];
                    Sg.Context.Authdata.TitleId = (uint)((bool)MyValues[1] ? 1 : 0);
                }

                protected override void ChallengeResponseAckTimeout ()
                {
                    ExpectLogAndKickOrBlock("ANALYZE");
                    CheckLuaResponse();
                    TestComplete = true;
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_KickBlock")]
            [CompoundCase("{0}", LuaResponseOptions.Kick, false)]
            [CompoundCase("{0}", LuaResponseOptions.Block, false)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Kick, true)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Block, true)]
            public class Dropped : KickAndBlockBase
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.Dropped;
                    Sg.Context.Authdata.TitleRegion = (uint)(LuaResponseOptions)MyValues[0];
                    Sg.Context.Authdata.TitleId = (uint)((bool)MyValues[1] ? 1 : 0);
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    ExpectLogAndKickOrBlock("DROPPED");

                    // trigger dropped
                    Sg.Disconnect();

                    // for kick, this is somewhat meaningless, but do it anyway
                    CheckLuaResponse();
                    TestComplete = true;
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_KickBlock")]
            [CompoundCase("{0}", LuaResponseOptions.Kick, false)]
            [CompoundCase("{0}", LuaResponseOptions.Block, false)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Kick, true)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Block, true)]
            public class AckTimeout : KickAndBlockBase
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.AckTimeout;
                    Sg.Context.Authdata.TitleRegion = (uint)(LuaResponseOptions)MyValues[0];
                    Sg.Context.Authdata.TitleId = (uint)((bool)MyValues[1] ? 1 : 0);
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    // do nothing
                }

                protected override void ChallengeAckTimeout ()
                {
                    ExpectLogAndKickOrBlock("TIMEOUTACK");
                    CheckLuaResponse();
                    TestComplete = true;
                }
            }

            [TestCase]
            [PreconfiguredChallenge("LuaCM_KickBlock")]
            [CompoundCase("{0}", LuaResponseOptions.Kick, false)]
            [CompoundCase("{0}", LuaResponseOptions.Block, false)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Kick, true)]
            [CompoundCase("{0}WithError", LuaResponseOptions.Block, true)]
            public class RespTimeout : KickAndBlockBase
            {
                public override void PreRun ()
                {
                    base.PreRun();

                    Sg.Context.Authdata.TitleVersion = (uint)LuaEntryPoints.RespTimeout;
                    Sg.Context.Authdata.TitleRegion = (uint)(LuaResponseOptions)MyValues[0];
                    Sg.Context.Authdata.TitleId = (uint)((bool)MyValues[1] ? 1 : 0);
                }

                protected override void ChallengeReceived (SecMsgSgToXbChal challenge)
                {
                    SendAck(challenge.ChallengeNonce);
                }

                protected override void ChallengeResponseTimeout ()
                {
                    ExpectLogAndKickOrBlock("TIMEOUTRESP");
                    CheckLuaResponse();
                    TestComplete = true;
                }
            }

        }

    }

    [TestGroup]
    public class AsyncChallengeStress : TestNode
    {
        protected ChallengeManager ChalMan;
        protected LuaScript Script;

        public SGConnectionPool ConnectionPool;

        public AsyncChallengeStress ()
        {
            ChalMan = new ChallengeManager();
        }

        public override void PreRun ()
        {
            Script = ChallengeManager.PreconfiguredLuaScripts["LuaCM_AsyncChallengeStress"];
            ChalMan.AddScript(Script);

            ConnectionPool = new SGConnectionPool(4, 9000);
            ConnectionPool.Start();
            ConnectionPool.NewConnection = CreateNewConnection;
            ConnectionPool.ProcessChallenge = HandleChallenges;
        }

        public override void PostRun ()
        {
            ConnectionPool.Stop();
            ChalMan.RemoveAllScripts();
        }

        protected class ChalTestInfo
        {
            public static string UserDataName = "ChalTestInfo";

            public TimeSpan ChallengeReponseResendTimeout = new TimeSpan(0, 0, 5);

            public DateTime LastChallengeResponseSent = DateTime.MinValue;
            public TimeSpan SinceLastChallengeResponseSent { get { return DateTime.UtcNow - LastChallengeResponseSent; } }
        }

        protected SGConnection CreateNewConnection ()
        {
            SGConnection ans = ConnectionPool.CreateNewConnection();
            ChalMan.SetAuthdataForScript(Script, ans.Context.Authdata);
            return ans;
        }

        protected void VerifyChallengeParams (SGConnection conn)
        {
            SecMsgSgToXbChal chal = conn.CurrentChallengePacket;

            ValueCheck.TestNotNull("CurrentChallengePacket", chal);
            ValueCheck.TestNotNull("CurrentChallengePacket.Params", chal.Params);
            ValueCheck.Test("CurrentChallengePacket.Params.Length", 16, chal.Params.Length);

            // pull out params
            byte ackTimeouts = chal.Params[0];
            byte respTimeouts = chal.Params[1];
            byte assignCount = chal.Params[2];
            byte dropCount = chal.Params[3];
            byte badAnswerCount = chal.Params[4];
            ulong xboxId = BitConverter.ToUInt64(chal.Params, 8);

            // check params
            ValueCheck.Test("AckTimeouts", 0, ackTimeouts);
            ValueCheck.Test("RespTimeouts", 0, respTimeouts);
            ValueCheck.Test("AssignCount", 0, assignCount);
            ValueCheck.Test("DropCount", 0, dropCount);
            ValueCheck.Test("BadAnswerCount", 0, badAnswerCount);
            ValueCheck.Test("XboxId", conn.Context.Authdata.XboxID, xboxId);
        }

        protected void SendAck (SGConnection conn)
        {
            SecMsgSgToXbChal chal = conn.CurrentChallengePacket;

            ValueCheck.TestNotNull("CurrentChallengePacket", chal);

            SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck();
            ack.ChallengeNonce = chal.ChallengeNonce;

            conn.Send(ack);
        }

        protected void SendResponse (SGConnection conn)
        {
            SecMsgSgToXbChal chal = conn.CurrentChallengePacket;

            ValueCheck.TestNotNull("CurrentChallengePacket", chal);

            SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
            resp.ChallengeNonce = chal.ChallengeNonce;
            resp.Execute = new byte[1024];

            // fill with our machine puid
            Buffer.BlockCopy(BitConverter.GetBytes(conn.Context.Authdata.XboxID), 0, resp.Execute, 0, 8);

            conn.Send(resp);
        }

        protected void HandleChallenges (SGConnection conn)
        {
            ChalTestInfo testInfo = conn.GetUserData(ChalTestInfo.UserDataName) as ChalTestInfo;

            if (testInfo == null)
            {
                testInfo = new ChalTestInfo();
                conn.SetUserData(ChalTestInfo.UserDataName, testInfo);
            }

            try
            {
                // verify that the params encoded data is good
                VerifyChallengeParams(conn);
            }
            catch (Exception e)
            {
                Global.RO.Error(e.ToString());
            }

            try
            {
                // do stuff based on flags we have from the test cases
                // TODO: that

                if (testInfo.SinceLastChallengeResponseSent > testInfo.ChallengeReponseResendTimeout)
                {
                    SendAck(conn);

                    // send response with our machine puid in it for verification
                    SendResponse(conn);

                    testInfo.LastChallengeResponseSent = DateTime.UtcNow;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error(e.ToString());
            }
        }

        [StressTest]
        public class NoOp : TestNode
        {
            public override void Run ()
            {
            }
        }
    }
    
    // NoChallengeException
    // NoAckException
    #region Custom CR exceptions

    class NoChallengeException : SgTestException
    {
        public NoChallengeException(string format, params object[] args) : base(String.Format(format, args)) { }
    }

    class NoAckException : SgTestException
    {
        public NoAckException(string format, params object[] args) : base(String.Format(format, args)) { }
    }

    class NoDisconnectException : NoAckException
    {
        public NoDisconnectException(string format, params object[] args) : base(format, args) { }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncPolicy.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace XSGTest
{
    [TestGroup, TestCasePriority(1)]
#if LSPTEST
    [CompoundCase("AuthData 3", 3)]
    [CompoundCase("AuthData 4", 4)]
#endif
    public class Policy : MultiAuthDataBase
    {
#if !LSPTEST
        [TestCase, Description("Send a packet to every destination, none are authorized for the connection")]
        public class NoServicesAuthorized : TestBase_SgFake
        {
            protected override void SetDefaults ()
            {
                base.SetDefaults();

                sg.Context.Authdata.SetCombinedPrivileges(new uint[8]);
            }

            protected override void RunTest ()
            {
                IEnumerable<IVirtualInterfaceInfo> virtInts = SgEnvironmentInfo.GetSgVirtualInterfaceInfo();

                DoKeyExchange();

                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                byte[] portBytes = new byte[2];

                foreach (IVirtualInterfaceInfo vii in virtInts)
                {
                    int port = vii.InternetPort;

                    sg.XspSendData(new byte[] { 0, 1, 2, 3, 4 }, XspHeader.XSP_TYPE_UDP_2, 1000, (ushort)port);

                    portBytes[0] = (byte)((port >> 8) & 0xFF);
                    portBytes[1] = (byte)(port & 0xFF);

                    // check for event about not having access to server
                    if (!events.TestForChange(53836, portBytes))
                    {
                        throw new SgTestException("Did not find the event about not being authorized for server " + port + " (53836)");
                    }
                }
            }
        }

        [TestCase, Description("Send a packet to every destination, all are authorized for the connection")]
        public class AllServicesAuthorized : TestBase_SgFake
        {
            protected override void SetDefaults ()
            {
                base.SetDefaults();

                uint[] privs = new uint[8];
                for (int i = 0; i < privs.Length; ++i)
                {
                    privs[i] = unchecked((uint)~0);
                }

                sg.Context.Authdata.SetCombinedPrivileges(privs);
            }

            protected override void RunTest ()
            {
                IEnumerable<IVirtualInterfaceInfo> virtInts = SgEnvironmentInfo.GetSgVirtualInterfaceInfo();

                DoKeyExchange();

                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                byte[] portBytes = new byte[2];

                foreach (IVirtualInterfaceInfo vii in virtInts)
                {
                    int port = vii.InternetPort;

                    sg.XspSendData(new byte[] { 0, 1, 2, 3, 4 }, XspHeader.XSP_TYPE_UDP_2, 1000, (ushort)port);

                    portBytes[0] = (byte)((port >> 8) & 0xFF);
                    portBytes[1] = (byte)(port & 0xFF);

                    // check for event about not having access to server
                    if (events.TestForChange(53836, portBytes))
                    {
                        throw new SgTestException("Found the event about not being authorized for server " + port + " (53836)");
                    }
                }
            }
        }

        [TestCase, Description("Send a packet to every destination, all are authorized for the connection")]
        public class SingleServiceAuthorized : TestBase_SgFake
        {
            protected IVirtualInterfaceInfo mappedVirtInt;

            public SingleServiceAuthorized ()
            {
                IEnumerable<IVirtualInterfaceInfo> virtInts = null;

                try
                {
                    virtInts = SgEnvironmentInfo.GetSgVirtualInterfaceInfo();
                }
                catch (Exception e)
                {
                    ro.Error("Could not access NPDB for " + FullName + " child generation. Please fix:\n" + e.Message);
                    return;
                }

                foreach (IVirtualInterfaceInfo vii in virtInts)
                {
                    bool next = false;
                    foreach (TestNode child in Children)
                    {
                        if (((SingleServiceAuthorized)child).mappedVirtInt.ServiceId == vii.ServiceId)
                        {
                            next = true;
                            break;
                        }
                    }
                    if (next)
                    {
                        continue;
                    }

                    AddChild(new SingleServiceAuthorized(vii), true, false);
                }
            }

            public SingleServiceAuthorized (IVirtualInterfaceInfo mapped)
            {
                mappedVirtInt = mapped;
                Name = string.Format("{0} [{1} {2}]", mappedVirtInt.ServiceId, mappedVirtInt.ServiceName, mappedVirtInt.InternetPort);
            }

            protected override void SetDefaults ()
            {
                base.SetDefaults();

                uint[] privs = new uint[8];
                privs[mappedVirtInt.ServiceId / 32] = unchecked((uint)(1 << (mappedVirtInt.ServiceId % 32)));

                sg.Context.Authdata.SetCombinedPrivileges(privs);
            }

            protected override void RunTest ()
            {
                IEnumerable<IVirtualInterfaceInfo> virtInts = SgEnvironmentInfo.GetSgVirtualInterfaceInfo();

                DoKeyExchange();

                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                byte[] portBytes = new byte[2];

                foreach (IVirtualInterfaceInfo vii in virtInts)
                {
                    int port = vii.InternetPort;

                    sg.XspSendData(new byte[] { 0, 1, 2, 3, 4 }, XspHeader.XSP_TYPE_UDP_2, 1000, (ushort)port);

                    portBytes[0] = (byte)((port >> 8) & 0xFF);
                    portBytes[1] = (byte)(port & 0xFF);

                    // see if this is mapped or not
                    bool isMapped = (mappedVirtInt.ServiceId == vii.ServiceId);

                    // check for event about not having access to server
                    if (events.TestForChange(53836, portBytes) == isMapped)
                    {
                        // isMapped means that the packet should have gone through, but was blocked by the SG
                        // !isMapped means that the packet should _not_ have gone through, but it was _not_ blocked
                        throw new SgTestException("{0} the event about not being authorized for server " + port + " (53836)",
                            (isMapped ? "Found" : "Did not find"));
                    }
                }
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSecmsgNatDetection.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService;
 
namespace XSGTest
{

    abstract class TestBase_NatDetection : TestBase_Secmsg
    {
        protected bool bGotReply = true;

        protected override void RunTest()
        {
            bGotReply = sg.SendNatDetect();
        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;

            if (!bGotReply)
            {
                if (SgEnvironmentInfo.IsXblob)
                {
                    throw new DidNotExecuteException("IPSec/firewall typically blocks the different port that a NET detection reply comes back on.");
                }

                Fail("Sent NAT request to {0}, no reply received - VIP broken?", sg.IpServer.ToString());
                return false;
            }
            return true;
        }

    }


    [TestGroup, TestCasePriority(1), EnvRequirement("NatDetection")]
    public class Secmsg_NatDetection : TestNode
    {

        [TestCase]
            class SecMsg_NatDetect_Only : TestBase_NatDetection
        {
        }

        [TestCase(38049), Description("Verify the main SG does not disconnect us after 30 seconds")]
            class SecMsg_NatDetect_VerifyNoDisconnect_MainSG : TestBase_NatDetection
        {
            override protected void RunTest()
            {
                // The main SG will not disconnect us. The NAT detection SG will. I don't 
                // have a good way of finding the NAT SG's IP address right now.
                ro.Debug("Sending NAT request to {0} and waiting 40 seconds to not be kicked", sg.IpServer.ToString());
                base.RunTest();
                if (bGotReply)
                {
                    DateTime start = DateTime.Now;

                    SecMsgHeader hdr = sg.SecMsgRecv(40000, SecMsgHeader.SECMSG_TYPE_DELETE);
                    if (hdr != null)
                    {
                        Fail("Got Delete message (reason={0}) in approximately {1} seconds", (hdr as SecMsgDelete).Reason, (DateTime.Now - start).TotalSeconds);
                    }
                }
                EnsureStillSignedIn();
            }
        }

        [TestCase(38049), Ignore, Description("Verify the NAT SG disconnects us after 30 seconds")]
            class SecMsg_NatDetect_VerifyDisconnect_NatSG : TestBase_NatDetection
        {
            override protected void RunTest()
            {
                // The main SG will not disconnect us. The NAT detection SG will. I don't 
                // have a good way of finding the NAT SG's IP address right now.
                ro.Debug("Sending NAT request to {0} and waiting 40 seconds to be kicked", sg.IpServer.ToString());
                base.RunTest();
                if (bGotReply)
                {
                    DateTime start = DateTime.Now;

                    SecMsgHeader hdr = sg.SecMsgRecv(40000, SecMsgHeader.SECMSG_TYPE_DELETE);
                    if (hdr == null)
                    {
                        Fail("Didn't receive SECMSG_TYPE_DELETE message from NatDetection SG in 40 seconds");
                    }
                    else
                    {
                        ro.Debug("Got Delete message (reason={0}) in approximately {1} seconds", (hdr as SecMsgDelete).Reason, (DateTime.Now - start).TotalSeconds);
                    }
                }
            }
        }
        
        [TestCase]
            class SecMsg_NatDetect_DiffPort : TestBase_NatDetection
        {
            protected override bool VerifyTest()
            {
                if (!base.VerifyTest())
                    return false;
                IPEndPoint ep = (IPEndPoint)sg.Context.Udp.epRemote;
                ro.Debug("NatDetection reply came in from {0} (expected port 3330 or 3075)", ep.ToString());
                if (!(ep.Port == 3330 || ep.Port == 3075))
                {
                    Fail("Expected reply from port 3330 or 3075");
                }
                return true;
            }
        }

        [TestCase]
            class SecMsg_NatDetect_CheckReplyIP : TestBase_NatDetection
        {
            protected override bool VerifyTest()
            {
                if (!base.VerifyTest())
                    return false;

                // Because the NAT detection reply is being sent through the gateway and not the CSM,
                // because the SG now ARPS for the dest address, the reply won't be seen coming from
                // the VIP ip. It will instead come from the machine's real IP.. which is OK, and in
                // fact makes for a better NAT detection service.
                //
                // TODO: is this true?
                
                IPEndPoint ep = (IPEndPoint)sg.Context.Udp.epRemote;
                ro.Debug("NatDetection reply came in from {0}", ep.ToString());
                if (ep.Address.Equals(sg.IpServer.Address))
                {
                    Fail("IP address of reply matches the request, but it shouldn't (doesn't matter though)");
                }
                return true;
            }                
        }

        [TestCase]
            class SecMsg_NatDetect_FullScenario : TestBase_NatDetection
        {
            override protected void RunTest()
            {
                // sign out of SG
                sg.SendDelete();

                // Basic auto-discover of everything
                sg.Context.SetNewUser(0);
                XkdcClient xkdc = new XkdcClient(sg.Context);
                xkdc.SetRequest(null, true);

                // retry on logon failure
                int retries = 4;

            retry_logon:
                try
                {
                    xkdc.SignInXkdc();
                }
                catch (System.Runtime.InteropServices.COMException e)
                {
                    unchecked
                    {
                        if (e.ErrorCode == (int) 0xC000006D)
                        {
                            Global.RO.Debug("Logon failed, trying again.");
                            // get around anti-DOS
                            Thread.Sleep(2000);
                            if (retries > 0)
                            {
                                --retries;
                                goto retry_logon;
                            }
                            else
                            {
                                throw e;
                            }
                        }
                    }
                }

                XkdcResult result = sg.Context.GetXkdcResult();
                ro.Debug(result.ToString());
                
                // Failed?
                if (result.ServiceHR != HResult.S_OK || result.NumServices <= 1)
                {
                    Fail("First auto-discover request sign in failed, ServiceHR={0} and NumServices={1}",
                        result.ServiceHR,
                        result.NumServices);
                }

                // Save the original XKDC context
                ServiceContextXe serviceCtx1 = sg.Context.ServiceCtxXe;

                // Clear XKDC result and sign in only requesting NAT_TYPE_DETECTION_SERVICE 20
                sg.Context.ClearXkdc();
                xkdc.SetRequest(new uint[] { 20 }, false);
                xkdc.SignInXkdc();
                result = sg.Context.GetXkdcResult();
                ro.Debug(result.ToString());

                // Failed 2nd time?
                if (result.ServiceHR != HResult.S_OK || result.ServiceHRs[0] != 0)
                {
                    Fail("Second explicit request sign in failed, ServiceHR={0} and ServiceHRs[0]={1}",
                        result.ServiceHR,
                        result.ServiceHRs[0]);
                    return;
                }

                // SG ip should be different from the original request 
                // (that's sort of the point of NAT detection)
                ro.Debug("Original request got SG IP {0}, second request for NAT Detection Service got IP {1}",
                    serviceCtx1.siteIPAddress.ToString(),
                    sg.Context.ServiceCtxXe.siteIPAddress.ToString());
                if (serviceCtx1.siteIPAddress.S_addr == sg.Context.ServiceCtxXe.siteIPAddress.S_addr)
                {
                    Fail("SG IP address match, should be different.  Original request got SG IP {0}, second request for NAT Detection Service got IP {1}",
                        serviceCtx1.siteIPAddress.ToString(),
                        sg.Context.ServiceCtxXe.siteIPAddress.ToString());
                    return;
                }

                // Create an SG client to send nat request to and send request
                sg = new SgClient(sg.Context);
                sg.bUseRealXKDC = true;
                sg.bUseSgIpFromKDC = true;

                try
                {
                    sg.SignInSG();
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    Fail("NAT detection SG timed out at IP {0}", sg.Context.ServiceCtxXe.siteIPAddress.ToString());
                    return;
                }

                if (!sg.SendNatDetect())
                {
                    Fail("Failed sending and receiving NatDetect XSP message. VIP broken?");
                }

                // SG should have incremented the port
                IPEndPoint ep = (IPEndPoint)sg.Context.Udp.epRemote;
                if (ep != null)
                {
                    if (!(ep.Port == 3330 || ep.Port == 3075))
                    {
                        Fail("Expected reply from port 3330 or 3075, instead got port {0}", ep.Port);
                    }
                }

                // And now we should get disconnected - wait for the DELETE message
                ro.Debug("Waiting 40 seconds to be kicked from NatDetection SG {0}", sg.IpServer.ToString());
                DateTime start = DateTime.Now;
                SecMsgHeader hdr = sg.SecMsgRecv(40000, SecMsgHeader.SECMSG_TYPE_DELETE);
                if (hdr == null)
                {
                    Fail("Didn't receive SECMSG_TYPE_DELETE message from NatDetection SG in 40 seconds");
                }
                else
                {
                    ro.Debug("Got Delete message (reason={0}) in approximately {1} seconds", (hdr as SecMsgDelete).Reason, (DateTime.Now - start).TotalSeconds);
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSecmsgPulse.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

namespace XSGTest
{
    public class TestBase_SecmsgPulse : TestBase_Secmsg
    {
        public readonly static int PulseTimeout         = 20 + 15;
        public readonly static int DisconnectTimeout    = 120 + 15;
    }

    [TestGroup, TestCasePriority(1), AsyncGroup(1, 0)]
    public class Secmsg_Pulse : TestNode
    {

        [TestCase]
            class Pulse_NoSend_WaitForSg_1Iteration : TestBase_SecmsgPulse
        {
            override protected void RunTest()
            {
                SecMsgHeader hdr = sg.SecMsgRecv(PulseTimeout*1000, SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2);
                if (hdr == null)
                {
                    Fail("No pulse from the SG after {0} seconds", PulseTimeout);
                }
                if (!IsStillSignedIn())
                    Fail("We appear to be disconnected from the SG");
            }
        }

        [TestCase]
            class Pulse_NoSend_WaitForSg_2Iteration : TestBase_SecmsgPulse
        {
            override protected void RunTest()
            {
                for (int i = 0; i < 2; i++)
                {
                    SecMsgHeader hdr = sg.SecMsgRecv(PulseTimeout*1000, SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2);
                    if (hdr == null)
                    {
                        Fail("No pulse from the SG after {0} seconds", PulseTimeout);
                    }
                }
                if (!IsStillSignedIn())
                    Fail("We appear to be disconnected from the SG");
            }
        }

        [TestCase]
            class Pulse_Send_WaitForSg_2Iteration : TestBase_SecmsgPulse
        {
            override protected void RunTest()
            {
                for (int i = 0; i < 2; i++)
                {
                    ro.Debug("Sending pulse...");
                    sg.SendDataPulse();
                    SecMsgHeader hdr = sg.SecMsgRecv(PulseTimeout*1000, SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2);
                    if (hdr == null)
                    {
                        Fail("No pulse from the SG after {0} seconds", PulseTimeout);
                    }
                }
                if (!IsStillSignedIn())
                    Fail("We appear to be disconnected from the SG");
            }
        }

        [TestCase]
            class Pulse_NoSend_WaitForDisconnect_120seconds: TestBase_SecmsgPulse
        {
            override protected void RunTest()
            {
                System.DateTime startTime = System.DateTime.Now;

                int timeout = DisconnectTimeout * 1000;
                while (timeout > 0)
                {
                    ro.Debug("Waiting for {0} more seconds...", (int)(timeout / 1000));
                    if (RecvLoop(ref timeout, true, false))
                    {
                        ro.Debug("Got SECMSG of type 0x{0:X4}", lastSecmsg.Type);
                    }
                }
                if (IsStillSignedIn())
                {
                    Fail("We appear to still be signed in, expected to be disconnected after {0} seconds", (System.DateTime.Now-startTime).TotalSeconds);
                }
            }
        }


    
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSecmsgChalResp_Lua.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;


namespace XSGTest
{
    // -- base for a test

    class TestBase_AsyncLua: TestBase_ChalRespAsync
    {
#region Internal Workings
        // -- internal

        private uint numChalsPushed=0; //number of challenges we've stuck on the sg
        private bool isAnotherChallenge=false; //another challenge to wait for after this one?
        private bool skipAck=false; // Skip Sending back an ACK
        private bool doChalCleanup=true; //should we clean up our own challenges or let the test/group take care of it?

        private uint sgResponseTime=2000; //time SG has to respondto a QoS packet
        private uint sgChalTime; //time SG has to send an async challenge

        // -- overrides on base

        //main flow of test
        protected override void RunTest()
        {
            try
            {
                do //loop for as long as we have another challenge to handle
                {
                    WaitForChallenge();
                    if (ResultCode == TEST_RESULTS.FAILED)
                        return;
                    SendAck();
                    if (ResultCode == TEST_RESULTS.FAILED)
                        return;
                    ProcessChallenge();
                    if (ResultCode == TEST_RESULTS.FAILED)
                        return;
                } while (isAnotherChallenge);
            }
            finally
            {
                CleanUp();
            }
        }

        //(called from outside) init stuff then log in
        protected override void InitGroup()
        {
            sg.bUseConnectionServices = true;
            sg.Context.ClientType = base.clientType;

            Authdata_Base authData=sg.Context.Authdata;
            if (authData==null)
            {
                Fail("authData is broken???");
                throw new System.Exception();
            }

            //set some defaults
            authData.MajorVersion=0x5347;  // 'SG' in hex
            authData.MinorVersion=0x0003;
            authData.BuildNumber=0;
            authData.QFENumber=0x0001;  // any tests that may stomp on each other should change this!
            authData.TitleId=0;
            authData.TitleVersion=1;

            //call test's setup
            sgChalTime=(uint)ChalIntervalInSec*1000;
            PreloginSetup(authData);
            System.Threading.Thread.Sleep(1000); //give sg a chance to chew on reloads
            System.Threading.Thread.Sleep((new System.Random()).Next(250)); //for parallel runs, spread timing out a little

            //login (should be no login challenge)
            Global.RO.Debug("authdata:\n"+authData.ToString());

            DoKeyExchange();

            if (sg.KeyexResult.keyexChal!=null)
            {
                ro.Error("we got a login challenge, but shouldn't have.");
                throw new System.Exception("something screwy with test run...");
            }
        }

        //(called from outside) waits for a challenge to come in up to a certain amount of time
        protected override void WaitForChallenge()
        {
            WaitForChallenge((int)(sgChalTime+500)/1000);
            if (!GotChallenge)
            {
                ro.Info("did not get challenged.  checking connection...");
                if (!CheckConnection())
                    ro.Info("NOT connected to the SG");
            }
        }

        //(called from outside) sends ack if we got a challenge
        protected override void SendAck()
        {
            if (GotChallenge && skipAck == false)
            {
                SendAck(this.sgChallenge.ChallengeNonce);
            }
        }

        //(called from outside) handle getting a challenge
        protected override void ProcessChallenge()
        {
            isAnotherChallenge=false; //default don't wait for another afterwards

            if (!GotChallenge)
            {
                HandleChallenge(null,ref isAnotherChallenge);
            }
            else
            {
                HandleChallenge(sgChallenge,ref isAnotherChallenge);
            }
        }

        //(called from outside) burrnnnnnn..
        //protected override void WaitForAck() { }
        //(called from outside) burrrnnnnn...
        protected override bool VerifyTest() {return true;}
        //(called from outside) burrrrnnnn...!
        //protected override void SendResponse() { }

        //(called from outside) clean up resources
        protected override void CleanUp()
        {
            if (doChalCleanup)
            {
                lock (ChalManager) //this is a static member shared by all instances
                {
                    ChalManager.RemoveAllScripts();
                    numChalsPushed = 0;
                }
            }
        }

#endregion

#region Usable Interface
        // -- things you can implement (throw a SgTestException on failure)

        //called before login. set authData however you want it, and add any lua challenges you want to use
        protected virtual void PreloginSetup(Authdata_Base authData) {}

        //called when challenge is recieved (or with null if none was recieved) (by default does "not" wait for another challenge)
        protected virtual void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge) {}

        // -- things you can call

        //Enables or disables cleaning up challenges off server on a per-test basis (default on)
        protected void EnableAutoChallengeCleanup(bool allow)
        {
            doChalCleanup=allow;
        }

        //Registers another challenge (gets unregistered automatically when we destruct)
        protected bool AddChallenge(string chalScript)
        {
            return AddChallenge(new LuaScript() { Name = Name, Script = chalScript });
        }
        protected bool AddChallenge(LuaScript chal)
        {
            return AddChallenge(chal, true);
        }
        protected bool AddChallenge (LuaScript chal, bool reload)
        {
            return AddChallenge(chal, reload, chal.KickEnabled);
        }
        protected bool AddChallenge (LuaScript chal, bool reload, bool pcv_kick_enabled)
        {
            lock (ChalManager) //this is a static member shared by all instances
            {
                bool wasKickEnabled=chal.KickEnabled;
                chal.KickEnabled=pcv_kick_enabled;

                //add it.. carefully
                try
                {
                    ChalManager.AddScript(chal, reload);
                    ++numChalsPushed;
                    Global.RO.Info("added challenge: "+chal.Name);
                }
                catch (SgReloadConfigException)
                {
                    ChalManager.RemoveScript(chal);
                    Global.RO.Info("failed to add challenge: "+chal.Name);
                    return false;
                }
                finally
                {
                    chal.KickEnabled=wasKickEnabled;
                }

                System.Threading.Thread.Sleep(1000); //pounding the sg with reload requests too fast is bad..
            }

            return true;
        }

        //Registers a batch of challenges all at once (single sg reload)
        public bool AddChallenges(System.Collections.ArrayList clist)
        {
            lock (ChalManager) //this is a static member shared by all instances
            {
                foreach (object o in clist)
                {
                    //get the entry as a lua challenge
                    LuaScript chal;
                    if (o is string)
                    {
                        chal = new LuaScript() { Name = Name, Script = o as string };
                    }
                    else if (o is LuaScript)
                    {
                        chal = o as LuaScript;
                    }
                    else
                    {
                        Global.RO.Error("bad type is list for AddChallenges");
                        return false;
                    }

                    //add it
                    try
                    {
                        Global.RO.Info("pushed challenge: "+chal.Name);
                        ChalManager.AddScript(chal,false);
                        ++numChalsPushed;
                    }
                    catch (SgReloadConfigException)
                    {
                        ChalManager.RemoveScript(chal);
                        return false;
                    }
                }

                SgServerInfo.ReloadChallenges();
                ro.Info("finished sg reload_config");
            }
            return true;
        }

        //gets a challenge from the xml file with a specific name, after replacing {0} with a specific challenge ID, and {1} with a specific QFE# check, and postfixing a string to the name of the challenge
        public LuaScript GetXmlChallenge(string chalName, string namePostfix, uint chalID, uint qfeNumCheck)
        {
            return GetXmlChallenge(chalName, namePostfix, chalID, qfeNumCheck, true, true);
        }
        public LuaScript GetXmlChallenge(string chalName, string namePostfix, uint chalID, uint qfeNumCheck, bool kick, bool timeout)
        {
            LuaScript const_cl=ChallengeManager.PreconfiguredLuaScripts[chalName]; //gosh grr C#'s lack of a const

            LuaScript cl = new LuaScript(const_cl) { KickEnabled = kick, TimeoutEnabled = timeout };
            cl.Name+=namePostfix+".lua";
            cl.Script = string.Format(cl.Script, "0x" + Hexer.tohex(chalID), qfeNumCheck.ToString());
            return cl;
        }

        //send back a response to a challenge (must be 1024 bytes)
        protected void SendChallengeResponse(string resp)
        {
            SendChallengeResponse(Hexer.unhex(resp));
        }
        protected void SendChallengeResponse(byte []resp)
        {
            if (resp.Length!=1024)
            {
                ro.Debug("SendChallengeResponse MUST have 1024 bytes as parameter");
                throw new System.Exception("SendChallengeResponse MUST have 1024 bytes as parameter");
            }

            chalResponse=resp;
            SendResponse(this.sgChallenge.ChallengeNonce);
        }

        //sends a response that's not 1024 bytes size
        protected void SendNon1024ChallengeResponse(string resp, ushort dataSize)
        {
            SendNon1024ChallengeResponse(Hexer.unhex(resp),dataSize);
        }
        protected void SendNon1024ChallengeResponse(byte []data, ushort dataSize)
        {
            SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2();
            resp.ChallengeNonce = this.sgChallenge.ChallengeNonce;
            resp.Execute = data;
            resp.cbEnt=(short)(dataSize+8); //8 from size of headers
            sg.XspSend(resp);
            if (bVerbose)
                ro.Debug("[CR] [{2:X8}] Sent SECMSG_TYPE_XBTOSG_CHALRESP_2 type=0x{0:X}, size={1}", resp.Type, resp.cbEnt, resp.ChallengeNonce);
        }

        //waits the timeout time (responds to acks), and checks if we're still connected afterwards (true if still connected)
        protected bool WaitAndCheckConnected()
        {
            return WaitAndCheckConnected((uint)sgChalTime/1000+1);
        }
        protected bool WaitAndCheckConnected(uint seconds)
        {
            if (seconds>0) ro.Debug("Checking for "+seconds+" seconds to see if we're still connected...");
            for (uint i=0;i<seconds;++i)
            {
                RecvLoop(1,false,true); //handle acks and 1 sec pause
                
                if (!IsStillSignedIn((int)sgResponseTime))                        
                {
                    ro.Debug("lost connection after about "+(i+1)+" seconds");
                    return false;
                }
            }

            //we're still here
            if (IsStillSignedIn((int)sgResponseTime))
            {
                ro.Debug("still connected");
                return true;
            }
            else
            {
                ro.Debug("no longer connected");
                return false;
            }
        }

        //sets how long the SG has to respond to QoS packets
        protected void SetSGQosResponseTime(uint timeInMS)
        {
            sgResponseTime=timeInMS;
        }

        //sets how long the SG has to send us an async challenge before we give up waiting
        protected void SetSGChallengeTime(uint timeInMS)
        {
            sgChalTime=timeInMS;
        }

        protected void SetSkipAck(bool enable)
        {
            skipAck = enable;
        }
#endregion
    };

} //namespace XSGTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSecmsgChangeUsers.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

namespace XSGTest
{

    [TestGroup]
#if LSPTEST
    [CompoundCase("AuthData 3", 3)]
    [CompoundCase("AuthData 4", 4)]
#endif
    public class Secmsg_ChangeUsers : MultiAuthDataBase
    {

        [TestCase, TestCasePriority(1), Description("Send a ChangeUsers SecMsg, which should cause some notifications to go out the back end of the SG")]
            class ChangeUsers_Mainline : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // Log Xbox ID so we can look it up in the SG logs
                Authdata_Base ad = sg.Context.Authdata;
                ro.Debug("Before ChangeUsers: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                    ad.TitleId,
                    ad.XboxID,
                    ad.GetUser(0).qwUserID);

                // Set new info and build the TGS ticket
                ad.TitleId++;
                ad.GetUser(0).qwUserID++;
                sg.BuildFakeTicket(ad);

                if (!sg.SendChangeUsers())
                {
                    Fail("SendChangeUsers failed, qwXboxID=0x{0:X}", ad.XboxID);
                    return;
                }

                ro.Debug(" After ChangeUsers: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                    ad.TitleId,
                    ad.XboxID,
                    ad.GetUser(0).qwUserID);

                // TODO: We need to look for the notifications here
            }
        }


        [TestCase, TestCasePriority(1), Description("Send a XbToSg Data Pulse with Title Change message embedded")]
            class TitleChangePulse_Mainline : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // Send pulse with new title id in it
                sg.SendDataPulseTitleChange(sg.Context.TitleInfo.TitleId + 1);
                
                // Log Xbox ID so we can look it up in the SG logs
                Authdata_Base ad = sg.Context.Authdata;
                ro.Debug(" After TitleChangePulse: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                    sg.Context.TitleInfo.TitleId + 1,
                    ad.XboxID,
                    ad.GetUser(0).qwUserID);

                // TODO: We need to look for the presence notification here
            }
        }

        [TestCase, Description("Send a ChangeUsers SecMsg followed by a data pulse with a title change embedded. Mainline usage.")]
            class ChangeUsersThenTitleChangePulse_Mainline : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // Log Xbox ID so we can look it up in the SG logs
                Authdata_Base ad = sg.Context.Authdata;
                ro.Debug("Before ChangeUsersThenTitleChangePulse: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                    ad.TitleId,
                    ad.XboxID,
                    ad.GetUser(0).qwUserID);

                // Set new info and build the TGS ticket
                ad.TitleId++;
                ad.GetUser(0).qwUserID++;
                sg.BuildFakeTicket(ad);
                if (!sg.SendChangeUsers())
                {
                    Fail("SendChangeUsers failed, qwXboxID=0x{0:X}", ad.XboxID);
                    return;
                }

                // Send the pulse with the new title id in it
                sg.SendDataPulseTitleChange(ad.TitleId);

                ro.Debug(" After ChangeUsersThenTitleChangePulse: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                    ad.TitleId,
                    ad.XboxID,
                    ad.GetUser(0).qwUserID);

            }
        }

        [TestCase, Description("Send a ChangeUsers SecMsg, which should cause some notifications to go out the back end of the SG")]
        [EnvRequirement("TestFD")]
            class ChangeUsers_VerifyAuthdata : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // Log Xbox ID so we can look it up in the SG logs
                Authdata_Base ad = sg.Context.Authdata;
                uint titleid1 = ad.TitleId;
                ulong userid1 = ad.GetUser(0).qwUserID;

                // Set new info and build the TGS ticket
                ad.TitleId++;
                ad.GetUser(0).qwUserID++;
                sg.BuildFakeTicket(ad);

                if (!sg.SendChangeUsers())
                {
                    Fail("SendChangeUsers failed, qwXboxID=0x{0:X}", ad.XboxID);
                    return;
                }

                Authdata_Base ad2 = GetAuthdataFromSg();
                if (ad2 == null)
                    return;
                ro.Debug("titleId1=0x{0:X8}, titleId2=0x{1:X8}, userId1=0x{2:X16}, userId2=0x{3:X16}",
                    titleid1,
                    ad2.TitleId,
                    userid1,
                    ad2.GetUser(0).qwUserID);
                if (ad2.TitleId != titleid1 + 1)
                    Fail("Title ids don't match");
                if (ad2.GetUser(0).qwUserID != userid1 + 1)
                    Fail("User ids don't match");

            }
        }

        [TestCase, Description("Send a ChangeUsers SecMsg followed by a data pulse with a title change embedded. Mainline usage.")]
        [EnvRequirement("TestFD")]
            class ChangeUsersThenTitleChangePulse_VerifyAuthdata : TestBase_Secmsg
        {
            override protected void RunTest()
            {
                // Log Xbox ID so we can look it up in the SG logs
                Authdata_Base ad = sg.Context.Authdata;
                uint titleid1 = ad.TitleId;
                ulong userid1 = ad.GetUser(0).qwUserID;

                // Set new info and build the TGS ticket
                ad.TitleId = titleid1 + 1;
                ad.GetUser(0).qwUserID = userid1 + 1;
                sg.BuildFakeTicket(ad);
                if (!sg.SendChangeUsers())
                {
                    Fail("SendChangeUsers failed, qwXboxID=0x{0:X}", ad.XboxID);
                    return;
                }

                // Send the pulse with the new title id in it
                sg.SendDataPulseTitleChange(ad.TitleId);

                Authdata_Base ad2 = GetAuthdataFromSg();
                if (ad2 == null)
                    return;
                ro.Debug("titleId1=0x{0:X8}, titleId2=0x{1:X8}, userId1=0x{2:X16}, userId2=0x{3:X16}",
                    titleid1,
                    ad2.TitleId,
                    userid1,
                    ad2.GetUser(0).qwUserID);
                if (ad2.TitleId != titleid1 + 1)
                    Fail("Title ids aren't different");
                if (ad2.GetUser(0).qwUserID != userid1 + 1)
                    Fail("User ids aren't different");

            }
        }

        [TestCase, TestCasePriority(1), Description("Attempt to change title as a Panorama client. Should be blocked")]
            class TitleChange_Panorama : TestBase_Secmsg
        {
            override protected void SetDefaults()
            {
                clientType = AuthContext.ClientTypes.Panorama;
                base.SetDefaults();
            }

            override protected void RunTest()
            {
                // Save old info
                Authdata_Base ad = sg.Context.Authdata;
                uint titleid1 = ad.TitleId;

                // We've already signed in. Now send CHANGE_USERS_REQ with a new title id
                ad.TitleId = titleid1 + 1;
                sg.BuildFakeTicket(ad);
                if (sg.SendChangeUsers())
                    Fail("PC client changed title, but SendChangeUsers succeeded (got reply)");

                ro.Debug("PC client 0x{0:X} signed in with title 0x{1:X}, then changed to title 0x{2:X}",
                         ad.XboxID, titleid1, ad.TitleId);

                if (IsStillSignedIn())
                    Fail("PC client changed title, but we're still signed in");

            }
        }

        [TestCase, TestCasePriority(1), Description("Attempt to change title as a Panorama client, but to the same title we already had. Should be allowed")]
        class TitleChange_Panorama_SameTitle : TestBase_Secmsg
        {
            override protected void SetDefaults ()
            {
                clientType = AuthContext.ClientTypes.Panorama;
                base.SetDefaults();
            }

            override protected void RunTest ()
            {
                // Save old info
                Authdata_Base ad = sg.Context.Authdata;
                uint titleid1 = ad.TitleId;

                // We've already signed in. Now send CHANGE_USERS_REQ with a new title id
                sg.BuildFakeTicket(ad);
                if (!sg.SendChangeUsers())
                    Fail("PC client changed title (to same title), but SendChangeUsers failed");

                ro.Debug("PC client 0x{0:X} signed in with title 0x{1:X}, then changed to title 0x{2:X}",
                         ad.XboxID, titleid1, ad.TitleId);

                if (!IsStillSignedIn())
                    Fail("PC client changed title (to same title), but we were kicked :(");

            }
        }

#if !LSPTEST
        [TestGroup, TestCasePriority(1), TestFrequency("Regression")]
        class ChangeUsers_FilterCheck : TestNode_LuaScriptGroup
        {
            private const uint BlockedTitle = 0xC0FE0801;
            private const ulong BlockedXbox = 0xFA05578EA8B96C8A;
            private const ulong BlockedUser = 0x00090F8EA8B96C8B;

            public ChangeUsers_FilterCheck ()
            {
                // Format #s
                // 0 : Blocked Title ID
                // 1 : Blocked Xbox
                // 2 : Blocked User
                // 3 : Test Name
                string filter_string = @"
FilterDeclare('{3}')

function ApplyFilter ()
    if Spi.GetTitleId() == 0x{0:X8} and Spi.GetXboxId() == Qword.new('0x{1:X16}') and Spi.GetUserId(0) == Qword.new('0x{2:X16}') then
        Filter.Block()
    end
end
";
                filter_string = string.Format(filter_string,
                    BlockedTitle, BlockedXbox, BlockedUser, Name);
                Global.RO.Debug("Using this filter to block on:\n" + filter_string);

                AddScript(new LuaScript() { Name = Name, Script = filter_string });
            }

            [TestCase, Description("Make sure we are blocked when we change authdata.")]
            public class Block : TestBase_SgFake
            {
                override protected void RunTest ()
                {
                    Authdata_Base ad = sg.Context.Authdata;

                    // log in with a different title
                    ad.TitleId = BlockedTitle - 1;
                    ad.XboxID = BlockedXbox;
                    ad.GetUser(0).qwUserID = BlockedUser;

                    DoKeyExchange();

                    // Log Xbox ID so we can look it up in the SG logs
                    ro.Debug("Before ChangeUsers: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                        ad.TitleId,
                        ad.XboxID,
                        ad.GetUser(0).qwUserID);

                    // Set new info and build the TGS ticket
                    ad.TitleId = BlockedTitle;
                    sg.BuildFakeTicket(ad);

                    if (sg.SendChangeUsers())
                    {
                        Fail("We should have been blocked and got no response...");
                    }

                    ro.Debug(" After ChangeUsers: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                        ad.TitleId,
                        ad.XboxID,
                        ad.GetUser(0).qwUserID);

                    // just double check that we aren't signed in
                    QOS qos = sg.SendQos();

                    if (qos.Resp1 != null || qos.Resp2 != null)
                    {
                        Fail("Got a response from QoS test, we shouldn't be signed in...");
                    }
                }
            }

            [TestCase, Description("Make sure we aren't blocked when we change authdata.")]
            public class Allow : TestBase_SgFake
            {
                override protected void RunTest ()
                {
                    Authdata_Base ad = sg.Context.Authdata;

                    // log in with a different title
                    ad.TitleId = BlockedTitle - 1;
                    ad.XboxID = BlockedXbox;
                    ad.GetUser(0).qwUserID = BlockedUser;

                    DoKeyExchange();

                    // Log Xbox ID so we can look it up in the SG logs
                    ro.Debug("Before ChangeUsers: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                        ad.TitleId,
                        ad.XboxID,
                        ad.GetUser(0).qwUserID);

                    // Set new info and build the TGS ticket
                    ad.TitleId = BlockedTitle + 1;
                    sg.BuildFakeTicket(ad);

                    if (!sg.SendChangeUsers())
                    {
                        Fail("We shouldn't have been blocked, but we got no response...");
                    }

                    ro.Debug(" After ChangeUsers: titleId=0x{0:X8}, xboxId=0x{1:X16}, user1Id=0x{2:X16}",
                        ad.TitleId,
                        ad.XboxID,
                        ad.GetUser(0).qwUserID);

                    // just double check that we aren't signed in
                    QOS qos = sg.SendQos();

                    if (qos.Resp1 == null || qos.Resp2 == null)
                    {
                        Fail("Got no response from QoS test, we should be signed in...");
                    }
                }
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSgmsgSpidata.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.config;
 
namespace XSGTest
{

    // Test guests (dwUserFlags bit)
    // see sgrecv.cpp:1642
    // verify authdata qwUserIds

    abstract class TestBase_Spidata : TestBase_Sgmsg
    {
        // Datacenter-facing NIC
        public static IPEndPoint sgEP = null;

#if USELOCALSPIDATA

        protected override void SetDefaults()
        {
            base.SetDefaults();

            if (sgEP == null)
            {
                try
                {
                    // Get IP address of datacenter-facing SG 
                    IPEndPoint[] sgEPs = Global.XEnv.GetInterface(Interface.sgsvc_int);
                    if (sgEPs == null || sgEPs[0] == null)
                    {
                        throw new SGException("SG endpoint or remote endpoint is null, please fill out Back IP address for SG in XML file");
                    }
                    sgEP = sgEPs[0];
                }
                catch (System.Data.SqlClient.SqlException e)
                {
                    Fail("Error getting SG datacenter interface sgsvc_int: {0}", e.Message);
                    sgEP = null;
                }
            }
        }

        protected override void InitGroup()
        {
            if (sgEP == null)
            {
                Fail("No IP configured for SG datacenter NIC");
                return;
            }
            base.InitGroup();
        }
#endif

        public bool CompareAuthdata (Authdata_Base original, Authdata_Base retrieved)
        {
            // Check type first
            if (original.GetType() != retrieved.GetType())
            {
                if (original.IsXenon && retrieved.IsXbox2)
                    return CompareXenonToXbox2((Authdata_Xenon)original, (Authdata_Xbox2)retrieved, false);
                else if (retrieved.IsXenon && original.IsXbox2)
                    return CompareXenonToXbox2((Authdata_Xenon)retrieved, (Authdata_Xbox2)original, true);

                else if (original.IsXenon && retrieved.IsXenon2)
                    return CompareXenonToXenon2((Authdata_Xenon)original, (Authdata_Xenon2)retrieved, true);
                else if (retrieved.IsXenon && original.IsXenon2)
                    return CompareXenonToXenon2((Authdata_Xenon)retrieved, (Authdata_Xenon2)original, false);

                else if (original.IsXenon2 && retrieved.IsXbox2)
                    return CompareXenon2ToXbox2((Authdata_Xenon2)original, (Authdata_Xbox2)retrieved, false);
                else if (retrieved.IsXenon2 && original.IsXbox2)
                    return CompareXenon2ToXbox2((Authdata_Xenon2)retrieved, (Authdata_Xbox2)original, true);
            }
            else if (retrieved.IsXenon2)
            {
                return CompareXenon2((Authdata_Xenon2)original, (Authdata_Xenon2)retrieved);
            }
            else if (retrieved.IsXenon)
            {
                return CompareXenon((Authdata_Xenon)original, (Authdata_Xenon)retrieved);
            }
            else if (retrieved.IsXbox2)
            {
                return CompareXbox2((Authdata_Xbox2)original, (Authdata_Xbox2)retrieved);
            }
            else 
            {
                Fail("Authdata type is unknown, version is {0}", retrieved.wAuthDataVersion);
                return false;
            }
            return false;
        }

        public bool CompareXenon2(Authdata_Xenon2 ad1, Authdata_Xenon2 ad2)
        {
            // Bitwise for now.  Maybe need to make smarter.
            byte[] b1 = (byte[])ad1;
            byte[] b2 = (byte[])ad2;

            ValueCheck.TestAll("Authdata_Xenon2 bytes", b1, b2);

            return true;
        }

        public bool CompareXenon(Authdata_Xenon ad1, Authdata_Xenon ad2)
        {
            // Bitwise for now.  Maybe need to make smarter.
            byte[] b1 = (byte[])ad1;
            byte[] b2 = (byte[])ad2;

            ValueCheck.TestAll("Authdata_Xenon bytes", b1, b2);

            return true;
        }

        public bool CompareXbox2(Authdata_Xbox2 ad1, Authdata_Xbox2 ad2)
        {
            // Bitwise for now.  Maybe need to make smarter.
            byte[] b1 = (byte[])ad1;
            byte[] b2 = (byte[])ad2;

            ValueCheck.TestAll("Authdata_Xbox2 bytes", b1, b2);

            return true;
        }

        public bool CompareXenonToXbox2(Authdata_Xenon ad1, Authdata_Xbox2 ad2, bool upgraded)
        {
            try
            {
                ValueCheck.Test("MajorVersion", ad1.MajorVersion, ad2.MajorVersion);
                ValueCheck.Test("MinorVersion", ad1.MinorVersion, ad2.MinorVersion);
                ValueCheck.Test("BuildNumber", ad1.BuildNumber, ad2.BuildNumber);
                ValueCheck.Test("QFENumber", ad1.QFENumber, ad2.QFENumber);
                ValueCheck.Test("dwTitleID", ad1.dwTitleID, ad2.dwTitleID);
                ValueCheck.Test("dwTitleRegion", ad1.dwTitleRegion, ad2.dwTitleRegion);
                ValueCheck.Test("dwTitleVersion", ad1.dwTitleVersion, ad2.dwTitleVersion);
                ValueCheck.Test("qwXboxID", ad1.qwXboxID, ad2.qwXboxID);

                for (int u = 0; u < 4; u++)
                {
                    ValueCheck.Test("qwUserID", ad1.users[u].qwUserID, ad2.users[u].qwUserID);
                    ValueCheck.Test("dwUserFlags", ad1.users[u].dwUserFlags, ad2.users[u].dwUserFlags);
                    ValueCheck.Test("afltTrustFactor", ad1.afltTrustFactor[u], ad2.afltTrustFactor[u]);
                }
                for (int i = 0; i < 4; i++)
                {
                    ValueCheck.Test("dwAltTitleID", ad1.dwAltTitleID[i], ad2.dwAltTitleID[i]);
                }

                int dwordServiceCount = 0;
                bool fOkOverall = true;
                for (int s = 0; s < ad2.dwServiceID.Length; s++)
                {
                    uint id = ad2.dwServiceID[s];
                    if (id == 0)
                        continue;
                    uint expect = (uint)((id != 0) ? 1 : 0);
                    if (id < 256)
                    {
                        int dword = 0;
                        while (id >= 32)
                        {
                            dword++;
                            id -= 32;
                        }
                        int priv = 1 << (int)id;
                        ValueCheck.TestDifferent("dwPrivileges", expect, ad1.dwPrivileges[dword] & priv);
                    }
                    else
                    {
                        if (dwordServiceCount < ad1.dwServiceID.Length)
                        {
                            bool fOk = false;
                            for (int j = 0; j < 4; j++)
                            {
                                if (ad1.dwServiceID[j] == id)
                                {
                                    fOk = true;
                                    ++dwordServiceCount;
                                    break;
                                }
                            }
                            fOkOverall = fOkOverall && fOk;
                        }
                        else
                        {
                            Global.RO.Debug("Authdata_Xbox2 contained more dword services than could be held by Authdata_Xenon.");
                        }
                    }
                }
                ValueCheck.IsTrue(fOkOverall || (dwordServiceCount == ad1.dwServiceID.Length), "Dword Services");
                // TODO: reverse check of dwPrivileges to make sure no extras are granted
                ValueCheck.Test("Key", ad1.Key, ad2.Key);

                // for upgrade case, make sure xenon fields are blank
                if (upgraded)
                {
                    // TODO: Check all xenon fields to make sure no stray bits gets added
                }
            }
            catch (Exception e)
            {
                ro.Error("CompareXenonToXbox2 failed: " + e.ToString());
                return false;
            }
            return true;
        }

        public bool CompareXenon2ToXbox2 (Authdata_Xenon2 ad1, Authdata_Xbox2 ad2, bool upgraded)
        {
            try
            {
                ValueCheck.Test("MajorVersion", ad1.MajorVersion, ad2.MajorVersion);
                ValueCheck.Test("MinorVersion", ad1.MinorVersion, ad2.MinorVersion);
                ValueCheck.Test("BuildNumber", ad1.BuildNumber, ad2.BuildNumber);
                ValueCheck.Test("QFENumber", ad1.QFENumber, ad2.QFENumber);
                ValueCheck.Test("qwXboxID", ad1.qwXboxID, ad2.qwXboxID);
                ValueCheck.Test("dwTitleID", ad1.dwTitleID, ad2.dwTitleID);
                ValueCheck.Test("dwTitleRegion", ad1.dwTitleRegion, ad2.dwTitleRegion);
                ValueCheck.Test("dwTitleVersion", ad1.dwTitleVersion, ad2.dwTitleVersion);

                for (int u = 0; u < 4; u++)
                {
                    ValueCheck.Test("qwUserID", ad1.users[u].qwUserID, ad2.users[u].qwUserID);
                    ValueCheck.Test("dwUserFlags", ad1.users[u].dwUserFlags, ad2.users[u].dwUserFlags);
                    ValueCheck.Test("afltTrustFactor", ad1.afltTrustFactor[u], ad2.afltTrustFactor[u]);
                }
                for (int i = 0; i < 4; i++)
                {
                    ValueCheck.Test("dwAltTitleID", ad1.dwAltTitleID[i], ad2.dwAltTitleID[i]);
                }

                int dwordServiceCount = 0;
                bool fOkOverall = true;
                for (int s = 0; s < ad2.dwServiceID.Length; s++)
                {
                    uint id = ad2.dwServiceID[s];
                    if (id == 0)
                        continue;
                    uint expect = (uint)((id != 0) ? 1 : 0);
                    if (id < 128)
                    {
                        int dword = 0;
                        while (id >= 32)
                        {
                            dword++;
                            id -= 32;
                        }
                        int priv = 1 << (int)id;
                        ValueCheck.TestDifferent("dwBaseServices", expect, ad1.dwBaseServices[dword] & priv);
                    }
                    else
                    {
                        if (dwordServiceCount < ad1.dwExtendedServices.Length)
                        {
                            bool fOk = false;
                            for (int j = 0; j < 4; j++)
                            {
                                if (ad1.dwExtendedServices[j] == id)
                                {
                                    fOk = true;
                                    ++dwordServiceCount;
                                    break;
                                }
                            }
                            fOkOverall = fOkOverall && fOk;
                        }
                        else
                        {
                            Global.RO.Debug("Authdata_Xbox2 contained more dword services than could be held by Authdata_Xenon2.");
                        }
                    }
                }
                ValueCheck.IsTrue(fOkOverall || (dwordServiceCount == ad1.dwExtendedServices.Length), "Extended Services");
                // TODO: reverse check of dwPrivileges to make sure no extras are granted
                ValueCheck.Test("Key", ad1.Key, ad2.Key);

                // for upgrade case, make sure xenon fields are blank
                if (upgraded)
                {
                    // TODO: Check all xenon fields to make sure no stray bits gets added
                }
            }
            catch (Exception e)
            {
                ro.Error("CompareXenonToXbox2 failed: " + e.ToString());
                return false;
            }
            return true;
        }

        public bool CompareXenonToXenon2 (Authdata_Xenon ad1, Authdata_Xenon2 ad2, bool upgraded)
        {
            try
            {
                ValueCheck.Test("MajorVersion", ad1.MajorVersion, ad2.MajorVersion);
                ValueCheck.Test("MinorVersion", ad1.MinorVersion, ad2.MinorVersion);
                ValueCheck.Test("BuildNumber", ad1.BuildNumber, ad2.BuildNumber);
                ValueCheck.Test("QFENumber", ad1.QFENumber, ad2.QFENumber);
                ValueCheck.Test("dwAuthDataFlags", ad1.dwAuthDataFlags, ad2.dwAuthDataFlags);
                ValueCheck.Test("qwXboxID", ad1.qwXboxID, ad2.qwXboxID);
                ValueCheck.Test("dwTitleID", ad1.dwTitleID, ad2.dwTitleID);
                ValueCheck.Test("dwTitleRegion", ad1.dwTitleRegion, ad2.dwTitleRegion);
                ValueCheck.Test("dwTitleVersion", ad1.dwTitleVersion, ad2.dwTitleVersion);
                ValueCheck.Test("dwConsoleRegion", ad1.dwConsoleRegion, ad2.dwConsoleRegion);
                ValueCheck.Test("dwMediaID", ad1.dwMediaID, ad2.dwMediaID);
                ValueCheck.Test("wLanguageID", ad1.wLanguageID, ad2.wLanguageID);
                ValueCheck.Test("wNumDwordServices", ad1.wNumDwordServices, ad2.wNumExtendedServices);
                ValueCheck.Test("dwServiceID[0]", ad1.dwServiceID[0], ad2.dwExtendedServices[0]);
                ValueCheck.Test("dwServiceID[1]", ad1.dwServiceID[1], ad2.dwExtendedServices[1]);
                ValueCheck.Test("dwServiceID[2]", ad1.dwServiceID[2], ad2.dwExtendedServices[2]);
                ValueCheck.Test("dwServiceID[3]", ad1.dwServiceID[3], ad2.dwExtendedServices[3]);
                ValueCheck.Test("dwPrivileges[0]", ad1.dwPrivileges[0], ad2.dwBaseServices[0]);
                ValueCheck.Test("dwPrivileges[1]", ad1.dwPrivileges[1], ad2.dwBaseServices[1]);
                ValueCheck.Test("dwPrivileges[2]", ad1.dwPrivileges[2], ad2.dwBaseServices[2]);
                ValueCheck.Test("dwPrivileges[3]", ad1.dwPrivileges[3], ad2.dwBaseServices[3]);
                ValueCheck.Test("dwPrivileges[4]", ad1.dwPrivileges[4], ad2.dwMachinePrivileges[0]);

                for (int u = 0; u < 4; u++)
                {
                    ValueCheck.Test("qwUserID", ad1.users[u].qwUserID, ad2.users[u].qwUserID);
                    ValueCheck.Test("dwUserFlags", ad1.users[u].dwUserFlags, ad2.users[u].dwUserFlags);
                    ValueCheck.Test("afltTrustFactor", ad1.afltTrustFactor[u], ad2.afltTrustFactor[u]);
                    if (ad2.users[u].qwUserID != 0)
                    {
                        if (upgraded)
                        {
                            ValueCheck.Test("dwPrivileges[5]", ad1.dwPrivileges[5], ad2.dwUserPrivileges[u * 3 + 0]);
                            ValueCheck.Test("dwPrivileges[6]", ad1.dwPrivileges[6], ad2.dwUserPrivileges[u * 3 + 1]);
                            ValueCheck.Test("dwPrivileges[7]", ad1.dwPrivileges[7], ad2.dwUserPrivileges[u * 3 + 2]);
                        }
                        else
                        {
                            for (int i = 0; i < 3; ++i)
                            {
                                uint ad1privs = ad1.dwPrivileges[5 + i];
                                uint ad2privs = ad2.dwUserPrivileges[u * 3 + i];
                                ValueCheck.IsTrue((ad1privs | ad2privs) == ad2privs, 
                                    "Combined privileges granted a privilege not granted to a user.");
                            }
                        }
                    }
                    else
                    {
                        ValueCheck.Test("dwUserPrivileges", 0, ad2.dwUserPrivileges[u * 3 + 0]);
                        ValueCheck.Test("dwUserPrivileges", 0, ad2.dwUserPrivileges[u * 3 + 1]);
                        ValueCheck.Test("dwUserPrivileges", 0, ad2.dwUserPrivileges[u * 3 + 2]);
                    }
                }
                for (int i = 0; i < 4; i++)
                {
                    ValueCheck.Test("dwAltTitleID", ad1.dwAltTitleID[i], ad2.dwAltTitleID[i]);
                }
                ValueCheck.Test("Key", ad1.Key, ad2.Key);

                if (upgraded)
                {
                    ValueCheck.Test("fltConsoleTrustFactor", 0, ad2.fltConsoleTrustFactor);
                    ValueCheck.Test("flowToken", 0, ad2.flowToken);
                }
            }
            catch (Exception e)
            {
                ro.Error("CompareXenonToXenon2 failed: " + e.ToString());
                return false;
            }
            return true;
        }

        public bool CompareSpidata(SgMsgSpiDataRepPacket sdp)
        {
            // Shortcuts
            KeyExchangeInitResponse     kr = sg.KeyexResult.keyexResp;
            SgMsgSpiData                sd = sdp.SpiData;
            int i;

            if (sd.ClientSGAddr.XboxID != kr.SGAddressInit.XboxID)
                Fail("SGAddr XboxID mismatch");
            if (sd.ClientSGAddr.SpiSg != kr.SGAddressInit.SpiSg)
                Fail("SGAddr SpiSg mismatch");
            if (sd.ClientSGAddr.SgIP.S_addr != kr.SGAddressInit.SgIP.S_addr)
                Fail("SGAddr SgIP mismatch");

            bool fCs = ((sg.KeyexRequest.keyexInit.wFlags & KeyExchangeInit.XSIF_CONNECTION_SERVICE) == KeyExchangeInit.XSIF_CONNECTION_SERVICE);
            if ((sd.fCs > 0 && !fCs) || (sd.fCs == 0 && fCs))
                Fail("fCs mismatch");
            //if (sd.FlagsKeyEx != kr.Flags)   // no matchy, why?
            //    Fail("Flags mismatch");
            if (sd.VersionKeyEx != kr.Version)
                Fail("KeyexVersion mismatch");
            for (i = 0; i < sd.Nonce.Length; i++)
            {
                if (sd.Nonce[i] != kr.NonceResp[i])
                {
                    Fail("Nonce mismatch");
                    break;
                }
            }

            return ResultCode != TEST_RESULTS.FAILED;
        }

    }

    abstract class TestBase_SpidataRemote : TestBase_Spidata
    {
        protected bool _is_stress = false;

        public override void Run (RUN_TYPE runType)
        {
            _is_stress = (runType == RUN_TYPE.STRESS);
            base.Run(runType);
        }

        protected override void RunTest()
        {
            base.RunTest();
            if (GetAuthdataFromSg((_is_stress ? SGFakeService.IServicePort.Arbitration : ServicePort)) == null)
            {
                throw new SgTestException("Failed to get authdata from the SG - is the ThroughputReflector tool running?");
            }
        }
    }

    [TestGroup, TestCasePriority(1), EnvRequirement("TestFD")]
#if LSPTEST
    [CompoundCase("AuthData 3", 3)]
    [CompoundCase("AuthData 4", 4)]
#endif
    public class Sgmsg_Spidata : MultiAuthDataBase
    {


#if USELOCALSPIDATA
    #region Sgmsg_Local

        [TestCase, Description("Send a UDP packet throught the SG to service running locally")]
        class SendToTestService_Local_NoReply: TestBase_Spidata
        {
            override protected void RunTest()
            {
                // Start up service to receive this packet we're about to send
                SGFakeService service = new SGFakeService();
                
                try
                {
                    byte[] msg = new byte[800];
                    sg.XspSendData(
                        msg,
                        0,
                        SGFakeService.ActionType.Drop,
                        SGFakeService.IServicePort.Service6);

                    if (!service.DoThroughput())
                    {
                        Fail("SGFakeService failed to receive packet");
                        return;
                    }
                }
                finally
                {
                    sg.SendDelete();
                }            
            }
        }
        
        [TestCase, Description("Send a UDP packet throught the SG to service running remotely and check for reply")]
        class SendToTestService_Remote_CheckReply: TestBase_Spidata
        {
            override protected void RunTest()
            {
                try
                {
                    byte[] msg = new byte[800];
                    sg.XspSendData(
                        msg,
                        1,
                        SGFakeService.ActionType.Reflect,
                        SGFakeService.IServicePort.Service6);

                    // Get reply
                    XspPacket xspreply = sg.XspRecv(5000);
                    if (xspreply != null && xspreply.Message != null)
                    {
                        // ok, well, here it is
                        byte[] recvBuffer = xspreply.Message;
                        if (recvBuffer == null || recvBuffer.Length < 2)
                        {
                            Fail("Receive buffer is null or less than 2 bytes long, this is too short for the header");
                        }
                        else
                        {
                            ro.Debug("Got reply, action is {0} and seqence number is {1}", recvBuffer[0], recvBuffer[1]);
                        }
                    }
                    else
                    {
                        Fail("No reply after 5 seconds");
                    }
                }
                finally
                {
                    sg.SendDelete();
                }            
            }
        }
        
        [TestCase, Description("Get SpiData/AuthData for a valid user")]
            class SpiDataReq_ValidUser : TestBase_Spidata
        {
            override protected void RunTest()
            {
                // Start up service to receive this packet we're about to send
                SGFakeService service = new SGFakeService();

                try
                {
                    byte[] msg = new byte[800];
                    sg.XspSendData(
                        msg,
                        0,
                        SGFakeService.ActionType.DropAuthdata,
                        SGFakeService.IServicePort.Service6);

                    if (!service.DoThroughput())
                    {
                        Fail("SGFakeService failed to receive packet");
                        return;
                    }
                    if (service.authdata == null)
                    {
                        Fail("Failed to get authdata");
                    }
                }
                finally
                {
                    sg.SendDelete();
                }            
            }
        }

        [TestCase, Description("Get SpiData/AuthData for a non-existent user")]
            class SpiDataReq_InvalidUser: TestBase_Spidata
        {
            // Move random generator from TestBase
            private static RandomEx Random = new RandomEx();

            override protected void RunTest()
            {
                // Fake port.  We need to generate one that doesn't have a user associated with it.
                // I don't know a way to guarantee this, so hopefully our random value won't collide.
                ushort port = (ushort)(Random.Next(10000) + 30000);

                // Real IP address
                IPAddress address = ((IPEndPoint)sgEP).Address;

                SGFakeService service = new SGFakeService(sgEP);
        
                try
                {
                    byte[] addrbytes = ((IPEndPoint)sgEP).Address.GetAddressBytes();
                    uint ipaddr = (uint)((addrbytes[0] << 24) | (addrbytes[1] << 16) | (addrbytes[2] << 8) | (addrbytes[3]));
                    service.SGInfoSendRequest(ipaddr, port);
                    service.SGInfoGetReply();
                    if (service.spidataReply != null && service.spidataReply.SpiRep.fNotFound == 0)
                    {
                        Fail("SG said user exists.  This was for IP {0} and port {1}", address, port);
                    }
                }
                catch (SGNoReplyException)
                {
                    // No reply from SG
                    Fail("No reply from the SG");
                }
            }
        }


        [TestCase, Description("Get SpiData/AuthData for a valid user and verify the AuthData structure.")]
            class SpiDataReq_VerifyAuthdata3: TestBase_Spidata
        {
            override protected void RunTest()
            {
                // Start up service to receive this packet we're about to send
                SGFakeService service = new SGFakeService();

                try
                {
                    byte[] msg = new byte[800];
                    sg.XspSendData(
                        msg,
                        0,
                        SGFakeService.ActionType.DropAuthdata,
                        SGFakeService.IServicePort.Service6);

                    if (!service.DoThroughput())
                    {
                        Fail("SGFakeService failed to receive packet");
                        return;
                    }
                    if (service.authdata == null)
                    {
                        Fail("Failed to get authdata");
                        return;
                    }
                    if (!CompareAuthdata(service.authdata, sg.Context.Authdata))
                    {
                        Fail("Comparision of SG authdata and XKDC authdata failed");
                    }
                }
                finally
                {
                    sg.SendDelete();
                }
            }

        }

        [TestCase, Description("Get SpiData/AuthData for a valid user and verify the AuthData structure. KDC should return Xbox2 authdata, but SG will convert it to Xenon (AD3) format")]
            class SpiDataReq_VerifyAuthdata2WithAuthdata3: TestBase_Spidata
        {
            protected override void SetDefaults()
            {
                sg = new SgClient(new AuthContext(clientType));
                sg.Context.Authdata = new Authdata_Xbox2();
            }

            override protected void RunTest()
            {
                // Make sure we sign in with authdata v2 (Xbox2), the SG will convert this
                // to authdata v3 internally.  hopefully it does it correctly.

                // Start up service to receive this packet we're about to send
                SGFakeService service = new SGFakeService();

                try
                {
                    byte[] msg = new byte[800];
                    sg.XspSendData(
                        msg,
                        0,
                        SGFakeService.ActionType.DropAuthdata,
                        SGFakeService.IServicePort.Service6);

                    if (!service.DoThroughput())
                    {
                        Fail("SGFakeService failed to receive packet");
                        return;
                    }
                    if (service.authdata == null)
                    {
                        Fail("Failed to get authdata");
                        return;
                    }

                    if (!CompareAuthdata(service.authdata, sg.Context.Authdata))
                    {
                        Fail("Comparision of SG authdata (version {0}) and XKDC authdata (version {1}) failed",
                            service.authdata.wAuthDataVersion,
                            sg.Context.Authdata.wAuthDataVersion);
                    }
                }
                finally
                {
                    sg.SendDelete();
                }
            }

        }

    #endregion
#endif

        #region Sgmsg Remote

        [TestCase(BugDatabase = "Xbox 360 Console Software", BugID = 151345), TestCasePriority(3)]
        //[StressTest] // Made a stress case for testing Arbitration UDP SpiData lookup
        class Remote_VerifyAuthdata_NoForcePacket : TestBase_Spidata
        {

            protected override void RunTest ()
            {
                base.RunTest();
                if (GetAuthdataFromSg(ServicePort, false, 0, 0, false) == null)
                {
                    throw new SgTestException("Failed to get authdata from the SG - is the ThroughputReflector tool running?");
                }
            }

            protected override bool VerifyTest ()
            {
                ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                ro.Debug("Remote:\n" + spiData.SpiAuth.AuthData.ToString());

                if (!base.VerifyTest())
                    return false;

                if (!CompareAuthdata(sg.Context.Authdata, spiData.SpiAuth.AuthData))
                {
                    ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                    ro.Debug("Remote:\n" + spiData.SpiAuth.AuthData.ToString());
                    return false;
                }

                return true;
            }
        }

        [TestCase]
        //[StressTest] // Made a stress case for testing Arbitration UDP SpiData lookup
            class Remote_VerifyAuthdata : TestBase_SpidataRemote
        {
            protected override bool VerifyTest()
            {
                if (!_is_stress)
                {
                    ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                    ro.Debug("Remote:\n" + spiData.SpiAuth.AuthData.ToString());
                }

                if (!base.VerifyTest())
                    return false;

                if (!CompareAuthdata(sg.Context.Authdata, spiData.SpiAuth.AuthData))
                {
                    if (_is_stress)
                    {
                        ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                        ro.Debug("Remote:\n" + spiData.SpiAuth.AuthData.ToString());
                    }
                    return false;
                }

                return true;
            }
        }

        [TestCase]
            class Remote_VerifySpidata : TestBase_SpidataRemote
        {
            protected override bool VerifyTest()
            {
                ro.Debug(spiData.ToString());

                if (!base.VerifyTest())
                    return false;

                if (!CompareSpidata(spiData))
                    return false;

                return true;
            }
        }

        [TestCase]
            class Remote_Permutation : TestBase_SpidataRemote
        {
            // 0 to 2    1 to 3
            // 1 to 0    2 to 1
            // 2 to 1    3 to 2
            // 3 to 3    4 to 4
            int[] userDest = new int[] { 2, 0, 1, 3 }; 

            protected override void InitTest()
            {
                Authdata_Base ad = sg.Context.Authdata;

                // Add some more users
                ad.GetUser(0).qwUserID = 1;
                ad.GetUser(1).qwUserID = 2;
                ad.GetUser(2).qwUserID = 3;
                ad.GetUser(3).qwUserID = 4;

                // Set user flags
                ad.GetUser(0).dwUserFlags = 21;
                ad.GetUser(1).dwUserFlags = 22;
                ad.GetUser(2).dwUserFlags = 23;
                ad.GetUser(3).dwUserFlags = 24;

                // Set the trust values
                ad.TrustFactor[0] = 11;
                ad.TrustFactor[1] = 12;
                ad.TrustFactor[2] = 13;
                ad.TrustFactor[3] = 14;

                // Set permutation bits
                sg.KeyexRequest = new KeyExchangeRequestPacket();
                int userPerm = 0;
                for (int user = 0; user < 4; user++)
                {
                    // U1       U2       U3       U4
                    // uup00000 uup00000 uup00000 uup00000
                    userPerm |= ((user << KeyExchangeInit.KEYEX_USER_PERMUTATION_SHIFT) + KeyExchangeInit.KEYEX_USER_PERMUTE_MASK) << (userDest[user] * 8);
                }              
                sg.KeyexRequest.keyexInit.UserPerm = unchecked((uint)userPerm);
            }

            protected override bool VerifyTest()
            {
                ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                ro.Debug("Remote:\n" + spiData.SpiAuth.AuthData.ToString());

                if (!base.VerifyTest())
                    return false;

                Authdata_Base ad1 = sg.Context.Authdata as Authdata_Base;
                Authdata_Base ad2 = spiData.SpiAuth.AuthData as Authdata_Base;

                // Verify new order of users and trust
                for (uint i = 0; i < 4; i++)
                {
                    if (ad1.GetUser(i).qwUserID != ad2.GetUser((uint)userDest[i]).qwUserID)
                        Fail("User[{0}] puid mismatch", i);
                    if (ad1.GetUser(i).dwUserFlags != ad2.GetUser((uint)userDest[i]).dwUserFlags)
                        Fail("User[{0}] userflags mismatch", i);
                    if (ad1.TrustFactor[i] != ad2.TrustFactor[userDest[i]])
                        Fail("Trust[{0}] mismatch", i);
                }                

                return ResultCode != TEST_RESULTS.FAILED;
            }
        }

        [TestCase]
        class Remote_GuestUsers : TestBase_SpidataRemote
        {
            protected override void InitTest()
            {
                sg.KeyexRequest = new KeyExchangeRequestPacket();

                // User #2 is a guest of user #1
                sg.KeyexRequest.keyexInit.UserPerm |= (KeyExchangeInit.KEYEX_USER_GUEST_MASK << (1 * 8));
            }

            protected override bool VerifyTest()
            {
                ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                ro.Debug("Remote:\n" + spiData.SpiAuth.AuthData.ToString());

                if (!base.VerifyTest())
                    return false;

                Authdata_Base ad1 = sg.Context.Authdata as Authdata_Base;
                Authdata_Base ad2 = spiData.SpiAuth.AuthData as Authdata_Base;

                // Verify the guest has guest mask set in the userflags
                if ((ad2.GetUser(1).dwUserFlags & KeyExchangeInit.KEYEX_USER_GUEST_MASK ) != KeyExchangeInit.KEYEX_USER_GUEST_MASK)
                    Fail("Guest does not have guest bits set in userflags");

                return ResultCode != TEST_RESULTS.FAILED;
            }
        }

        [TestCase]
            class Remote_KeyexReinit_VerifyAuthdata : TestBase_SpidataRemote
        {
            protected override void RunTest()
            {
                Authdata_Base ad;

                DoKeyExchange();
                ad = GetAuthdataFromSg();
                if (ad == null)
                    return;
                if (!CompareAuthdata(sg.Context.Authdata, ad))
                {
                    Fail("First keyex authdata check failed");
                    return;
                }

                // Change authdata, sign in again
                sg.Context.Authdata.GetUser(0).qwUserID++;
                Thread.Sleep(1100);
                DoKeyExchange();
                ad = GetAuthdataFromSg();
                if (ad == null)
                    return;
                if (!CompareAuthdata(sg.Context.Authdata, ad))
                {
                    Fail("Second keyex authdata check failed");
                    return;
                }
            }
        }


        #endregion

        [TestCase]
        class Remote_SgMsg_SpiDataReq : TestBase_SpidataRemote
        {
            protected override void RunTest()
            {
                base.RunTest();

                // We need the original SpiData response in spiData in order to construct 
                // a valid request.

                SgMsgSpiReq req = new SgMsgSpiReq();
                req.ReqNum = 1;
                req.ClientAddr = this.spiData.SpiRep.ClientAddr;
                req.ClientPort = this.spiData.SpiRep.ClientPort;
                
                byte[] resp = SendSgMsg((byte[])req, true);
                if (resp == null)
                {
                    Fail("No response from SG for the SgMsg we sent");
                    return;
                }

                try
                {
                    SgMsgSpiDataRepPacket spiDataRep = new SgMsgSpiDataRepPacket();
                    spiDataRep.ReadBytes(resp);
                    ro.Debug("Remote:\n" + spiDataRep.ToString());

                    ValueCheck.Test("Expected authdata version", spiDataRep.SpiAuth.AuthData.wAuthDataVersion, 3);
                    if (!CompareAuthdata(sg.Context.Authdata, spiDataRep.SpiAuth.AuthData))
                    {
                        Fail("Local and remote authdata blocks don't match.");
                        ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                    }
                }
                catch (Exception)
                {
                    ro.Debug("Remote bytes: {0}", Hexer.tohex(resp));
                    throw;
                }
            }
        }

        [TestCase]
        class Remote_SgMsg_Unknown : TestBase_SpidataRemote
        {
            protected override void RunTest()
            {
                base.RunTest();

                SgMsgSpiReq req = new SgMsgSpiReq();
                req.ReqNum = 1;
                req.ClientAddr = this.spiData.SpiRep.ClientAddr;
                req.ClientPort = this.spiData.SpiRep.ClientPort;

                // Make a bad type!
                req.Type = (short)0x6464;
                
                byte[] resp = SendSgMsg((byte[])req, true);
                if (resp != null)
                {
                    Fail("Got a response. This is not expected. Got:\n{0}", Hexer.tohex(resp));
                    return;
                }

                // Ensure we can still send packets
                Authdata_Base ad = GetAuthdataFromSg();
                if (ad == null)
                {
                    Fail("Unable to retrieve authdata a second time.");
                    return;
                }
            }
        }

        [TestCase]
        [CompoundCase("AskForAuthdataV1", 1, true)]
        [CompoundCase("AskForAuthdataV2", 2, true)]
        [CompoundCase("AskForAuthdataV3", 3, false)]
        [CompoundCase("AskForAuthdataV4", 4, false)]
        [CompoundCase("AskForAuthdataV5", 5, false)]
        class Remote_SgMsg_SpiDataReq2 : TestBase_SpidataRemote
        {
            protected override void RunTest()
            {
                int adVer = (int)MyValues[0];
                bool timeoutExpected = (bool)MyValues[1];

                base.RunTest();

                // We need the original SpiData response in spiData in order to construct 
                // a valid request.

                SgMsgSpiReq2 req = new SgMsgSpiReq2();
                req.ReqNum = 1;
                req.ClientAddr = this.spiData.SpiRep.ClientAddr;
                req.ClientPort = this.spiData.SpiRep.ClientPort;
                req.AuthdataVersion = (ushort)adVer;

                ro.Debug("Sending a SgMsgSpiReq2 SGMSG with authdata version {0}", req.AuthdataVersion);
                
                byte[] resp = SendSgMsg((byte[])req, true);

                if (resp == null)
                {
                    if (!timeoutExpected)
                    {
                        Fail("No response from SG for the SgMsg we sent");
                    }
                    return;
                }
                else if (timeoutExpected)
                {
                    Fail("Got response from SG but timeout was expected");
                    // fall through, try to decode
                }

                try
                {
                    SgMsgSpiDataRepPacket spiDataRep = new SgMsgSpiDataRepPacket();
                    spiDataRep.ReadBytes(resp);
                    ro.Debug("Remote:\n" + spiDataRep.ToString());

                    int expectedAdVer = adVer <= 4 ? adVer : 4; // SG only supports up to v4
                    ValueCheck.Test("Expected authdata version", (ushort)expectedAdVer, spiDataRep.SpiAuth.AuthData.wAuthDataVersion);

                    if (!CompareAuthdata(sg.Context.Authdata, spiDataRep.SpiAuth.AuthData))
                    {
                        Fail("Local and remote authdata blocks don't match.");
                        ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                    }
                }
                catch (Exception)
                {
                    ro.Debug("Remote bytes: {0}", Hexer.tohex(resp));
                    throw;
                }
            }
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSecmsgQOS.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Auth;

 
namespace XSGTest
{
    public class TestBase_QOS : TestBase_Secmsg
    {
        protected QOS q;

        protected override void SetDefaults()
        {
            base.SetDefaults();
            q = new QOS();
        }

        protected override void RunTest()
        {
            // The QOS class doesn't throw a timeout exception
            if (!q.SendRecv(sg))
            {
                throw new ServerTestFramework.Utilities.TimeoutException("QOS exchange timed out");
            }
        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;

            if (bExpectedNoReply)
            {
                return q.NoReply && !q.Success;
            }
            else
            {
                return q.Success;
            }            
        }
    }

    class TestBase_QOSxsp : TestBase_QOS
    {
        // Don't want to do any verification, entirely done in RunTest()
        protected override bool VerifyTest()
        {
            return true;
        }
    }


    [TestGroup, TestCasePriority(1)]
    public class Secmsg_QOS : TestNode
    {

        [TestCase, Description("Valid QOS exchange")]
        class Valid : TestBase_QOS
        {
        }

        [TestCase, Description("Valid QoS exchange with large packets")]
        class Valid_LargePackets : TestBase_QOS
        {
            protected override void RunTest ()
            {
                q.UseLargePackets = true;
                base.RunTest();
            }
        }

        [TestCase, Description("Valid QOS exchange, verifying the reply IP")]
            class Valid_CheckReplyIP : TestBase_QOS
        {
            override protected bool VerifyTest()
            {
                if (!base.VerifyTest())
                    return false;

                IPEndPoint ep = (IPEndPoint)sg.Context.Udp.epRemote;
                ro.Debug("Sent QOS to {0}, got reply from {0} (should be the same)", sg.IpServer.ToString(), ep.ToString());
                if (!sg.IpServer.Equals(ep))
                {
                    return false;
                }
                return true;
            }
        }

        [TestCase, Description("Wait 5 seconds between sending packets")]
        class ValidTimeDelay : TestBase_QOS
        {
            override protected void InitTest()
            {
                q.DelayMs = 5000;
            }
        }

        
        [TestCase, Description("Send same pair of QoS packets twice")]
            class ValidRepeat : TestBase_QOS
        {
            override protected void RunTest()
            {
                base.RunTest();
                if (VerifyTest())
                {
                    // Rollback so we send the same packet again
                    QOS.PktIdx--;
                    base.RunTest();
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Different nonce in each packet")]
            class InvalidFlag : TestBase_QOS
        {
            override protected void InitTest()
            {
                bExpectedNoReply = true;
                q.Init1.Flags = 200;
                q.Init2.Flags = 200;
            }
        }

        [TestCase, TestCasePriority(3), Description("No first packet, both are second packets")]
            class InvalidNoFirstPacket : TestBase_QOS
        {
            override protected void InitTest()
            {
                bExpectedNoReply = true;
                q.Init1 = q.Init2;
            }
        }

        [TestCase, TestCasePriority(3), Description("No second packet, both are first packets")]
            class InvalidNoSecondPacket : TestBase_QOS
        {
            override protected void InitTest()
            {
                bExpectedNoReply = true;
                q.Init2 = q.Init1;
            }
        }

        //flip send order and no delay between send.  SG should reorder them since they're udp and their ordering can't be assumed.
        // Changing expectations as the bug is resolved Won't Fix, thus we expect it to fail
        [TestCase(BugID = 76066, BugDatabase = "Xenon"), Description("Send in reverse order"), TestCasePriority(3)]
        class FlippedOrderNoDelay: TestBase_Secmsg
        {
            protected override void RunTest()
            {
                QOS qos = new QOS(0);
                SecMsgQosInit tmp=qos.Init1;
                qos.Init1=qos.Init2;
                qos.Init2=tmp;

                if (qos.SendRecv(sg))
                {
                    throw new ServerTestFramework.Utilities.TimeoutException("QOS exchange succeeded, we didn't expect it to (but with no delay the packets could have been reordered)");
                }
            }
        }

        //flip send order with a delay between send.  SG should reorder them since they're udp and their ordering can't be assumed.
        // Changing expectations as the bug is resolved Won't Fix, thus we expect it to fail
        [TestCase(BugID = 76066, BugDatabase = "Xenon"), Description("Send in reverse order with a small delay between packets"), TestCasePriority(3)]
        class FlippedOrderDelay: TestBase_Secmsg
        {
            protected override void RunTest()
            {
                QOS qos = new QOS(400);
                SecMsgQosInit tmp=qos.Init1;
                qos.Init1=qos.Init2;
                qos.Init2=tmp;

                if (qos.SendRecv(sg))
                {
                    throw new ServerTestFramework.Utilities.TimeoutException("QOS exchange succeeded, we didn't expect it to");
                }
            }
        }

        //
        [TestCase, TestCasePriority(3), Description("Send two Qos1 packets then one Qos2 packet")]
            class MixedTwoFirstPacket : TestBase_QOS
        {
            private SecMsgQosInit init2;
            override protected void InitTest()
            {
                init2 = q.Init2;
                q.Init2 = null;
                bExpectedNoReply = true;
            }
            protected override void RunTest()
            {
                base.RunTest();
                if (VerifyTest())
                {
                    QOS.PktIdx--;  // roll back
                    q.Init2 = init2;
                    bExpectedNoReply = false;
                    base.RunTest();
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Send a valid pair, then send Qos2 packet again")]
            class MixedTwoSecondPacket : TestBase_QOS
        {
            override protected void RunTest()
            {
                base.RunTest();
                if (VerifyTest())
                {
                    QOS.PktIdx--;  // roll back
                    q.Init1 = null;
                    bExpectedNoReply = true;
                    base.RunTest();
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Send a valid pair of Qos packets, then another valid pair with a decreasing PktIdx")]
            class ValidDecreasingPacketIndex : TestBase_QOS
        {
            override protected void RunTest()
            {
                base.RunTest();
                if (VerifyTest())
                {
                    QOS.PktIdx -= 2;
                    base.RunTest();
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Send a valid pair of Qos packets, then another valid pair with the same PktIdx")]
            class ValidSamePacketIndex : TestBase_QOS
        {
            override protected void RunTest()
            {
                base.RunTest();
                if (VerifyTest())
                {
                    QOS.PktIdx -= 1;
                    base.RunTest();
                }
            }
        }

        [TestCase, TestCasePriority(2), Description("Send a pair of Qos packets where Qos1 has a different nonce than Qos2")]
            class InvalidMismatchNonce : TestBase_QOS
        {
            override protected void InitTest()
            {
                bExpectedNoReply = true;
                // AAAAAHH!!!!! Why does the line below not work?  Why does it insist on using the
                // same nonce??  If I step through it, it works fine.. but not when executing. AAAH!
                //q.Init1.Nonce = AuthUtils.GetNewNonce();
                q.Init1.Nonce[0]++;
                q.Init1.Nonce[2]++;
                q.Init1.Nonce[4]++;
                q.Init1.Nonce[6]++;
            }
        }

        [TestCase, TestCasePriority(3), Description("")]
            class InvalidMismatchQosIndex : TestBase_QOS
        {
            override protected void InitTest()
            {
                bExpectedNoReply = true;
                //q.Init1.QosIdx = (ushort) base.RandGen.Next(ushort.MaxValue);
                q.Init1.QosIdx = (ushort) DateTime.Now.Ticks;
                //q.Init2.QosIdx = q.Init1.QosIdx;                
            }
        }

        [TestCase, TestCasePriority(3), Description("")]
            class InvalidMismatchPacketIndex : TestBase_QOSxsp
        {
            protected override void RunTest()
            {
                q.Init1.PktIdx = 0;
                q.Init2.PktIdx = 1;
                sg.XspSend(q.Init1);
                sg.XspSend(q.Init2);
                if (q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }

        }

        [TestCase, TestCasePriority(2), Description("")]
            class MixedExtraSmallSize : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                byte[] bytesInit1 = (byte[])q.Init1;
                byte[] bytesInit2 = (byte[])q.Init2;
                byte[] smallInit2 = new byte[bytesInit2.Length - 1];
                Array.Copy(bytesInit2, 0, smallInit2, 0, smallInit2.Length);
                sg.XspSend(bytesInit1);
                sg.XspSend(smallInit2);
                sg.XspSend(bytesInit2);
                // Should receive 2 replies, make sure we don't receive 3 or more
                if (q.Recv(sg))
                {
                    int timeout = 2000;
                    while (timeout > 0)
                    {
                        if (!RecvLoop(ref timeout, true, false))
                            return;
                        if (lastSecmsg.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP)
                        {
                            Fail("Received a 3rd reply");
                            break;
                        }
                    }
                }
                else
                {
                    Fail("Did not receive the 2 QOS responses from the SG");
                }
            }
        }



        [TestCase, TestCasePriority(3), Description("Send only the CSecMsg header")]
            class InvalidEmpty : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                // This test was broken by bug Xbox Platform 37645.  It used to fail; now it succeeds.
                sg.XspSendAdjustSize((byte[])q.Init1, SecMsgHeader.SIZE - SecMsgQosInit.SIZE);
                sg.XspSendAdjustSize((byte[])q.Init2, SecMsgHeader.SIZE - SecMsgQosInit.SIZE);
                if (q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify correct size, send extra bytes")]
            class ValidLargeBy1_NoSpecify_YesSend : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                // This test was broken by bug Xbox Platform 37645.  It used to fail; now it succeeds.
                sg.XspSendAdjustSize((byte[])q.Init1, 1);
                sg.XspSendAdjustSize((byte[])q.Init2, 1);
                if (!q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify correct size, send extra bytes")]
            class ValidLargeBy8_NoSpecify_YesSend : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                sg.XspSendAdjustSize((byte[])q.Init1, 8);
                sg.XspSendAdjustSize((byte[])q.Init2, 8);
                if (!q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify extra bytes, send extra bytes")]
            class ValidLargeBy1_YesSpecify_YesSend : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                q.Init1.cbEnt += 1;
                sg.XspSendAdjustSize((byte[])q.Init1, 1);
                sg.XspSendAdjustSize((byte[])q.Init2, 1);
                if (!q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify extra bytes, send extra bytes")]
            class ValidLargeBy8_YesSpecify_YesSend : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                // Refer to bug Xbox Platform 28068
                q.Init1.cbEnt += 8;
                sg.XspSendAdjustSize((byte[])q.Init1, 8);
                sg.XspSendAdjustSize((byte[])q.Init2, 8);
                if (!q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify extra bytes, send correct bytes")]
            class InvalidLargeBy1_YesSpecify_NoSend : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                // Refer to bug Xbox Platform 28068
                // If you specify more bytes than you send, then it makes sense that the
                // SG tosses out your packet.
                q.Init1.cbEnt += 1;
                sg.XspSend(q.Init1);
                sg.XspSend(q.Init2);
                if (!q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify extra bytes, send correct bytes")]
            class InvalidLargeBy8_YesSpecify_NoSend : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                // Refer to bug Xbox Platform 28068
                q.Init1.cbEnt += 8;
                sg.XspSend(q.Init1);
                sg.XspSend(q.Init2);
                if (!q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify fewer bytes, send correct bytes")]
        class InvalidSmallBy1_YesSpecify_NoSend : TestBase_QOSxsp
        {
            override protected void RunTest ()
            {
                // Refer to bug Xbox Platform 28068
                // If you specify more bytes than you send, then it makes sense that the
                // SG tosses out your packet.
                q.Init1.cbEnt -= 1;
                sg.XspSend(q.Init1);
                sg.XspSend(q.Init2);
                if (q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Specify fewer bytes, send correct bytes")]
        class InvalidSmallBy8_YesSpecify_NoSend : TestBase_QOSxsp
        {
            override protected void RunTest ()
            {
                // Refer to bug Xbox Platform 28068
                q.Init1.cbEnt -= 8;
                sg.XspSend(q.Init1);
                sg.XspSend(q.Init2);
                if (q.Recv(sg))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
            }
        }
        
        [TestCase, Description("")]
            class Qos_SendRecv_0ms_Results : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                q.DelayMs = 0;
                bool bSuccess = q.SendRecv(sg);
                ro.Debug("Resp1: " + q.Resp1.ToString());
                ro.Debug("Resp2: " + q.Resp2.ToString());
                if (!bSuccess)
                    Fail("Qos failed");
            }
        }

        [TestCase, Description("")]
            class Qos_SendRecv_500ms_Results : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                q.DelayMs = 500;
                bool bSuccess = q.SendRecv(sg);
                ro.Debug("Resp1: " + q.Resp1.ToString());
                ro.Debug("Resp2: " + q.Resp2.ToString());
                if (!bSuccess)
                    Fail("Qos failed");
            }
        }

        [TestCase, Description("")]
            class Qos_SendRecv_1000ms_Results : TestBase_QOSxsp
        {
            override protected void RunTest()
            {
                q.DelayMs = 1000;
                bool bSuccess = q.SendRecv(sg);
                ro.Debug("Resp1: " + q.Resp1.ToString());
                ro.Debug("Resp2: " + q.Resp2.ToString());
                if (!bSuccess)
                    Fail("Qos failed");
            }
        }

        [TestCase]
            class Qos_Latency_LowLoad : TestBase_QOSxsp
        {
            protected override void RunTest()
            {
                int i;
                ro.Debug("Running 100 times synchronously...");
                long[] timeSent = new long[100];
                long[] timeRecv = new long[100];
                uint[,] timeRtt = new uint[2,100];
                uint[,] timeGap = new uint[2,100];
                for (i = 0; i < 100; i++)
                {
                    timeSent[i] = DateTime.Now.Ticks;
                    if (!q.SendRecv(sg))
                    {
                        Fail("No QOS reply from the SG");
                        return;
                    }
                    timeRecv[i] = DateTime.Now.Ticks;
                    timeRtt[0,i] = q.Resp1.Rtt;
                    timeRtt[1,i] = q.Resp2.Rtt;
                    timeGap[0,i] = q.Resp1.Gap;
                    timeGap[1,i] = q.Resp2.Gap;
                }

                long[] avg = new long[5];
                long[] max = new long[5];
                long[] min = new long[5];
                for (i = 0; i < 5; i++)
                {
                    avg[i]= 0;
                    max[i] = Int64.MinValue;
                    min[i] = Int64.MaxValue;
                }
                for (i = 0; i < 100; i++)
                {
                    for (int j = 0; j < avg.Length; j++)
                    {
                        long rtt = 0;
                        switch (j)
                        {
                        case 0: rtt = timeRecv[i] - timeSent[i]; break;
                        case 1: rtt = timeRtt[0,i]; break;
                        case 2: rtt = timeRtt[1,i]; break;
                        case 3: rtt = timeGap[0,i]; break;
                        case 4: rtt = timeGap[1,i]; break;
                        }
                        avg[j] += (rtt / 100);

                        if (rtt > max[j])
                            max[j] = rtt;
                        if (rtt < min[j])
                            min[j] = rtt;
                    }
                }
    
                long elapsed = (timeSent[99] - timeSent[0]) / 10000;
                ro.Debug("TEST RESULTS: Elapsed {0} ms, packet/sec: {1}", 
                        elapsed,
                        99  * 1000 / elapsed);
                ro.Debug("Latency results, client: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[0] / 10000),
                        (long)(max[0] / 10000),
                        (long)(min[0] / 10000));
                ro.Debug("Qos results, Rtt 1: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[1] / 10000),
                        (long)(max[1] / 10000),
                        (long)(min[1] / 10000));
                ro.Debug("Qos results, Rtt 2: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[2] / 10000),
                        (long)(max[2] / 10000),
                        (long)(min[2] / 10000));
                ro.Debug("Qos results, Gap 1: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[3] / 10000),
                        (long)(max[3] / 10000),
                        (long)(min[3] / 10000));
                ro.Debug("Qos results, Gap 2: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[4] / 10000),
                        (long)(max[4] / 10000),
                        (long)(min[4] / 10000));

            }
        }

        [TestCase]
            class Qos_Latency_HighLoad : TestBase_QOSxsp
        {
            public void LoadSg(uint count, object userData)
            {
                int iterations = (int)userData;
                byte[] payload = new byte[32];
                int seqnum = 0;
                SgClient sg = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));

                sg.SignInSG();
                ro.Debug("[LoadSg] Signed in to SG, now sending {0} packets", iterations);

                for (int i = 0; i < iterations; i++)
                {
                    sg.XspSendData(
                        payload,
                        (byte)(seqnum++ % 256),
                        SGFakeService.ActionType.Reflect,
                        0,
                        ServicePort,
                        1001);
                }
            }

            protected override void RunTest()
            {
                if (SgEnvironmentInfo.IsXblob)
                {
                    throw new DidNotExecuteException("This load test does not reliably execute on an xblob.");
                }

                int i;

                // Fire off separate threads to hammer the SG (err.. only 1 thread...???)
                int iterations = 100000;
                ParallelRunner.Status asyncStatus;
                asyncStatus = ParallelRunner.RunAsync(
                    LoadSg,
                    1,      // count
                    1,      // maxatonce
                    iterations,
                    0); //no delay between thread creates
                System.Threading.Thread.Sleep(2000);

                ro.Debug("Running 100 times synchronously...");
                long[] timeSent = new long[100];
                long[] timeRecv = new long[100];
                uint[,] timeRtt = new uint[2,100];
                uint[,] timeGap = new uint[2,100];
                for (i = 0; i < 100; i++)
                {
                    timeSent[i] = DateTime.Now.Ticks;
                    if (!q.SendRecv(sg))
                    {
                        Fail("No QOS reply from the SG");
                        return;
                    }
                    timeRecv[i] = DateTime.Now.Ticks;
                    timeRtt[0,i] = q.Resp1.Rtt;
                    timeRtt[1,i] = q.Resp2.Rtt;
                    timeGap[0,i] = q.Resp1.Gap;
                    timeGap[1,i] = q.Resp2.Gap;
                }

                long[] avg = new long[5];
                long[] max = new long[5];
                long[] min = new long[5];
                for (i = 0; i < 5; i++)
                {
                    avg[i]= 0;
                    max[i] = Int64.MinValue;
                    min[i] = Int64.MaxValue;
                }
                for (i = 0; i < 100; i++)
                {
                    for (int j = 0; j < avg.Length; j++)
                    {
                        long rtt = 0;
                        switch (j)
                        {
                        case 0: rtt = timeRecv[i] - timeSent[i]; break;
                        case 1: rtt = timeRtt[0,i]; break;
                        case 2: rtt = timeRtt[1,i]; break;
                        case 3: rtt = timeGap[0,i]; break;
                        case 4: rtt = timeGap[1,i]; break;
                        }
                        avg[j] += (rtt / 100);

                        if (rtt > max[j])
                            max[j] = rtt;
                        if (rtt < min[j])
                            min[j] = rtt;
                    }
                }

                long elapsed = (timeSent[99] - timeSent[0]) / 10000;
                ro.Debug("TEST RESULTS: Elapsed {0} ms, packet/sec: {1}", 
                        elapsed,
                        99  * 1000 / elapsed);
                ro.Debug("Latency results, client: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[0] / 10000),
                        (long)(max[0] / 10000),
                        (long)(min[0] / 10000));
                ro.Debug("Qos results, Rtt 1: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[1] / 10000),
                        (long)(max[1] / 10000),
                        (long)(min[1] / 10000));
                ro.Debug("Qos results, Rtt 2: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[2] / 10000),
                        (long)(max[2] / 10000),
                        (long)(min[2] / 10000));
                ro.Debug("Qos results, Gap 1: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[3] / 10000),
                        (long)(max[3] / 10000),
                        (long)(min[3] / 10000));
                ro.Debug("Qos results, Gap 2: avg {0} ms, max {1} ms, min {2} ms", 
                        (long)(avg[4] / 10000),
                        (long)(max[4] / 10000),
                        (long)(min[4] / 10000));

            }
        }

        [TestCase, Description("Client QoS emulation")]
        class EmulateClientQoS : TestBase_Secmsg
        {
            private static int ProbeCount = 24;

            protected override void RunTest ()
            {
                List<QOS> probes = new List<QOS>(ProbeCount);

                for (int i = 0; i < ProbeCount; ++i)
                {
                    QOS temp = new QOS((i & 1) == 1);
                    temp.SendRecv(sg);
                    probes.Add(temp);
                }

                QOS.Results results = QOS.ComputeClientQoS(probes);

                Global.RO.Info("               Requests : {0} sent, {1}% received", 
                               ProbeCount, (int)(results.SuccessRate * 100));
                Global.RO.Info("            RTT (in ms) : {0:f1} min, {1:f1} median, {2:f1} max",
                               results.RttMinInMsecs, results.RttMedInMsecs, results.RttMaxInMsecs);
                Global.RO.Info("    Bandwidth (in Mbps) : {0:f2} down, {1:f2} up",
                               results.DnBitsPerSec / 1000000, results.UpBitsPerSec / 1000000);

                if (results.RttMedInMsecs > 5)
                {
                    Global.RO.Warn("Median round-trip-time was above the arbitrarily chosen value of 5ms.  If this is not a fluke, there may be an issue with the SG.");
                    Global.RO.Warn("Consistent values of 1.25ms to 1.5ms were observed from a TestNet client on an SG with no other load when this test was developed.");
                    Fail("Median round-trip-time was higher than expected.");
                }
            }
        }


        [TestCase, Description("Mainline QoS exchange, make sure nothing broke because of previous tests")]
        class ValidFinal : TestBase_QOS
        {
        }



    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSGInfo.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.config;
using xonline.common.service;
 
namespace XSGTest
{
    // Note on these tests:
    //
    // To fully test the changes in SGInfo we are targetting, we need to run this group 
    // once with sginfo_useOldProtocol set to 0, then run them again with 
    // sginfo_useOldProtocol set to 1. The tests read that setting and adjust their 
    // expectations appropriately. I've tested changing that setting (and doing a 
    // configcacherefresh) manually, but am unclear of the best way to automate it. 
    //
    // We should probably make an effort to do that, if we have time.
    
    abstract class TestBase_SGInfo : TestBase_Spidata
    {
        public const int TestFDService = 28;

        protected byte useOldProtocol = 2;

        // Need unique machine ids, to get around the once-per-second thing in the SG.
        static private ulong s_machineSequence = 0;

        protected Authdata_Base remoteAD;
        protected Authdata_Base remoteAD_otherVersion;

        protected override void SetDefaults()
        {
            sg = new SgClient(new AuthContext(clientType));
            int adVersion = 4;

            TestNode versionParent = Parent;
            while (versionParent != null && versionParent.Parent != null && versionParent.Parent.Name != "SGInfo")
            {
                versionParent = versionParent.Parent;
            }

            if (versionParent.MyValues != null && versionParent.MyValues.Length > 0)
            {
                adVersion = (int)versionParent.MyValues[0];
                useOldProtocol = (byte)(int)versionParent.MyValues[1];
            }
            else
            {
                throw new UnexpectedTestResultException("Could not find proper MyValues, tried this node: " + versionParent.Name);
            }

            // Users in the context. SgClient.SetDefaultAuthdata() will generate unique 
            // puids for us, or we can override it.
            sg.Context.ClearUsers();
            sg.Context.SetUser("sgtestuser0", 0); // do this so we get Presence set by default
            sg.Context.SetUser("sgtestuser3", 3); // do this so we get Presence set by default

            CreateAuthdataForVersion(adVersion);
        }

        protected void CreateAuthdataForVersion (int version)
        {
            if (version == 2)
            {
                Authdata_Xbox2 ad = new Authdata_Xbox2();
                sg.Context.Authdata = ad;
                sg.SetDefaultAuthdata(ad);

                ad.qwXboxID = 0xFA00123400000002 | (s_machineSequence++ << 8);
                ad.users[0].qwUserID = 0x0009123400000002;
                ad.users[3].qwUserID = 0x0009567800000002;
                ad.users[0].dwUserFlags = 0x20666;
                ad.users[3].dwUserFlags = 0x10777;
                ad.afltTrustFactor[0] = 1;
                ad.afltTrustFactor[3] = 2;
                ad.dwAltTitleID[0] = 0xABCD0000;
                ad.dwAltTitleID[3] = 0xABCE0003;
            }
            else if (version == 3)
            {
                Authdata_Xenon ad = new Authdata_Xenon();
                sg.Context.Authdata = ad;
                sg.SetDefaultAuthdata(ad);

                ad.qwXboxID = 0xFA00123400000003 | (s_machineSequence++ << 8);
                ad.users[0].qwUserID = 0x0009123400000003;
                ad.users[3].qwUserID = 0x0009567800000003;
                ad.users[0].dwUserFlags = 0x20666;
                ad.users[3].dwUserFlags = 0x10777;
                ad.afltTrustFactor[0] = 1;
                ad.afltTrustFactor[3] = 2;
                ad.dwMediaID = 2;
                ad.dwAltTitleID[0] = 0xABCD0000;
                ad.dwAltTitleID[3] = 0xABCE0003;
            }
            else if (version == 4)
            {
                Authdata_Xenon2 ad = new Authdata_Xenon2();
                sg.Context.Authdata = ad;
                sg.SetDefaultAuthdata(ad);

                ad.qwXboxID = 0xFA00123400000004 | (s_machineSequence++ << 8);
                ad.users[0].qwUserID = 0x0009123400000004;
                ad.users[3].qwUserID = 0x0009567800000004;
                ad.users[0].dwUserFlags = 0x20666;
                ad.users[3].dwUserFlags = 0x10777;
                ad.afltTrustFactor[0] = 1;
                ad.afltTrustFactor[3] = 2;
                ad.dwMediaID = 2;
                ad.dwMachinePrivileges[0] = 0x00000101;
                ad.flowToken = 1;
                ad.dwAltTitleID[0] = 0xABCD0000;
                ad.dwAltTitleID[3] = 0xABCE0003;
            }
            else
            {
                throw new Exception("Unknown value for authdata version: " + version);
            }
        }

        protected override void RunTest()
        {
            base.RunTest();
            RetrieveAuthdata();
        }

        protected void RetrieveAuthdata ()
        {
            remoteAD = GetAuthdataFromSg(ServicePort, true, 0, useOldProtocol);
            if (remoteAD == null)
            {
                ro.Debug("Timed out retrieving Authdata from SG/Reflector, trying once more");
                remoteAD = GetAuthdataFromSg(ServicePort, true, 0, useOldProtocol);

                if (remoteAD == null)
                {
                    throw new UnexpectedTestResultException("Could not retrieve Authdata from the SG/Reflector after 2 tries.");
                }
            }

            // find out which version we got back, and get the other one
            ushort adv = remoteAD.wAuthDataVersion;
            adv = (adv == Authdata_Base.XONLINE_XENON_AUTHDATA_VERSION ?
                Authdata_Base.XONLINE_XENON2_AUTHDATA_VERSION : Authdata_Base.XONLINE_XENON_AUTHDATA_VERSION);

            remoteAD_otherVersion = GetAuthdataFromSg(ServicePort, true, (byte)adv, useOldProtocol);
            if (remoteAD == null)
            {
                ro.Debug("Timed out retrieving Authdata (off version) from SG/Reflector, trying once more");
                remoteAD_otherVersion = GetAuthdataFromSg(ServicePort, true, (byte)adv, useOldProtocol);
            }
        }

        protected bool CheckAuthdataVersion()
        {
            // Version what we expected?
            bool oldProt = (useOldProtocol == 1);

            int adVer = (int)remoteAD.wAuthDataVersion;
            if (oldProt && adVer != 3)
            {
                Fail("SGInfo is using old protocol, but we got Authdata version {0}. Expected 3.", adVer);
                return false;
            }
            else if (!oldProt && adVer != 4)
            {
                Fail("SGInfo is using new protocol, but we got Authdata version {0}. Expected 4.", adVer);
                return false;
            }
            return true;
        }


        protected override bool VerifyTest()
        {
            bool fResult = false;
            try
            {
                fResult = base.VerifyTest();
                if (!fResult)
                {
                    ro.Warn("TestBase_SgInfo: base.VerifyTest() failed");
                    return fResult;
                }

                fResult = CompareAuthdata(sg.Context.Authdata, remoteAD);
                if (!fResult)
                {
                    ro.Warn("TestBase_SgInfo: CompareAuthData() failed");
                    return fResult;
                }

                // compare the other version as well, but only if the SGInfo request didn't cause us to downgrade
                // ex. send 4, request 3, get the 4 version from SGInfo, they won't be byte for byte the same
                if (sg.Context.Authdata.wAuthDataVersion <= remoteAD.wAuthDataVersion)
                {
                    fResult = CompareAuthdata(sg.Context.Authdata, remoteAD_otherVersion);
                    if (!fResult)
                    {
                        ro.Warn("TestBase_SgInfo: CompareAuthData() with off version failed");
                        return fResult;
                    }
                }

                CheckAuthdataVersion();

            }
            finally
            {
                if (!fResult)
                {
                    ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                    ro.Debug("Remote:\n" + remoteAD.ToString());
                }
            }
            return fResult;
        }
    }

    [CompoundCase("SendV2_RequestV4", 2, 0)]
    [CompoundCase("SendV2_RequestV3", 2, 1)]
    [CompoundCase("SendV3_RequestV4", 3, 0)]
    [CompoundCase("SendV3_RequestV3", 3, 1)]
    [CompoundCase("SendV4_RequestV4", 4, 0)]
    [CompoundCase("SendV4_RequestV3", 4, 1)]
    [TestGroup, TestCasePriority(1), Description("Tests using the real SGInfo class against a real SG"), EnvRequirement("TestFD")]
    public class SGInfo : TestNode
    {
        [TestCase, Description("Sign in with ticket, verify on backside")]
        class BasicVerification : TestBase_SGInfo
        {
            // base methods do it all for us, like magic!
            protected override bool VerifyTest()
            {
                if (!base.VerifyTest())
                    return false;

                // Print out in PASS case as well, for convenience
                ro.Debug("Local:\n" + sg.Context.Authdata.ToString());
                ro.Debug("Remote:\n" + remoteAD.ToString());
                return true;
            }

        }


        [TestCase]
        class Permutation : TestBase_SGInfo
        {
            // 0 to 2    1 to 3
            // 1 to 0    2 to 1
            // 2 to 1    3 to 2
            // 3 to 3    4 to 4
            uint[] userDest = new uint[] { 2, 0, 1, 3 }; 

            protected override void InitTest()
            {
                Authdata_Base ad = sg.Context.Authdata as Authdata_Base;

                // Add some more users
                ad.GetUser(0).qwUserID = 1;
                ad.GetUser(1).qwUserID = 2;
                ad.GetUser(2).qwUserID = 3;
                ad.GetUser(3).qwUserID = 4;

                // Set user flags
                ad.GetUser(0).dwUserFlags = 21;
                ad.GetUser(1).dwUserFlags = 22;
                ad.GetUser(2).dwUserFlags = 23;
                ad.GetUser(3).dwUserFlags = 24;

                // Set the trust values
                ad.TrustFactor[0] = 11;
                ad.TrustFactor[1] = 12;
                ad.TrustFactor[2] = 13;
                ad.TrustFactor[3] = 14;

                // Set permutation bits
                sg.KeyexRequest = new KeyExchangeRequestPacket();
                uint userPerm = 0;
                for (uint user = 0; user < 4; user++)
                {
                    // U1       U2       U3       U4
                    // uup00000 uup00000 uup00000 uup00000
                    uint ushift = user << KeyExchangeInit.KEYEX_USER_PERMUTATION_SHIFT;
                    uint umask = ushift + (uint)KeyExchangeInit.KEYEX_USER_PERMUTE_MASK;
                    uint bigshift = umask << (int)(userDest[user] * 8);
                    userPerm |= bigshift;
                }              
                sg.KeyexRequest.keyexInit.UserPerm = unchecked((uint)userPerm);
            }

            protected override bool VerifyTest()
            {
                // Can't compare authdata's byte-for-byte, since some things have been 
                // re-arranged. We have to spot check stuff here.
                // if (!base.VerifyTest())
                //     return false;
                
                if (!CheckAuthdataVersion())
                    return false;

                Authdata_Base ad1 = sg.Context.Authdata;
                Authdata_Base ad2 = remoteAD;

                // Verify new order of users and trust
                for (uint i = 0; i < 4; i++)
                {
                    if (ad1.GetUser(i).qwUserID != ad2.GetUser(userDest[i]).qwUserID)
                        Fail("User[{0}] puid mismatch", i);
                    if (ad1.GetUser(i).dwUserFlags != ad2.GetUser(userDest[i]).dwUserFlags)
                        Fail("User[{0}] userflags mismatch", i);
                    if (ad1.TrustFactor[i] != ad2.TrustFactor[userDest[i]])
                        Fail("Trust[{0}] mismatch", i);
                }

                // Verify some other random fields did not change
                ValueCheck.Test("MajorVersion", ad1.MajorVersion, ad2.MajorVersion);
                ValueCheck.Test("MinorVersion", ad1.MinorVersion, ad2.MinorVersion);
                ValueCheck.Test("BuildNumber", ad1.BuildNumber, ad2.BuildNumber);
                ValueCheck.Test("QFENumber", ad1.QFENumber, ad2.QFENumber);
                ValueCheck.Test("XboxID", ad1.XboxID, ad2.XboxID);
                ValueCheck.Test("TitleId", ad1.TitleId, ad2.TitleId);
                ValueCheck.Test("Key", ad1.Key, ad2.Key);

                return ResultCode != TEST_RESULTS.FAILED;
            }
        }

        [TestCase]
        class GuestUsers : TestBase_SGInfo
        {
            protected override void InitTest()
            {
                sg.KeyexRequest = new KeyExchangeRequestPacket();

                // User #2 is a guest of user #1
                sg.KeyexRequest.keyexInit.UserPerm |= (KeyExchangeInit.KEYEX_USER_GUEST_MASK << (1 * 8));
            }

            protected override bool VerifyTest()
            {
                // Artificially change local AD to match what we expect
                sg.Context.Authdata.GetUser(1).dwUserFlags = 0x1F;

                if (!base.VerifyTest())
                    return false;

                Authdata_Base ad1 = sg.Context.Authdata;
                Authdata_Base ad2 = remoteAD;

                // Verify the guest has guest mask set in the userflags
                if ((ad2.GetUser(0).dwUserFlags & KeyExchangeInit.KEYEX_USER_GUEST_MASK ) == KeyExchangeInit.KEYEX_USER_GUEST_MASK)
                    Fail("User[0] has guest bits set in userflags");
                if ((ad2.GetUser(1).dwUserFlags & KeyExchangeInit.KEYEX_USER_GUEST_MASK ) != KeyExchangeInit.KEYEX_USER_GUEST_MASK)
                    Fail("Guest[1] does not have guest bits set in userflags");
                if ((ad2.GetUser(2).dwUserFlags & KeyExchangeInit.KEYEX_USER_GUEST_MASK ) == KeyExchangeInit.KEYEX_USER_GUEST_MASK)
                    Fail("User[2] has guest bits set in userflags");
                if ((ad2.GetUser(3).dwUserFlags & KeyExchangeInit.KEYEX_USER_GUEST_MASK ) == KeyExchangeInit.KEYEX_USER_GUEST_MASK)
                    Fail("User[3] has guest bits set in userflags");

                return ResultCode != TEST_RESULTS.FAILED;
            }
        }

        [TestCase]
        class KeyexReinit : TestBase_SGInfo
        {
            protected override void RunTest()
            {
                base.RunTest();
                if (!base.VerifyTest())
                {
                    Fail("Initial sign-in failed verification");
                    return;
                }

                // change some stuff and do it again!
                sg.Context.Authdata.GetUser(0).qwUserID++;
                sg.Context.Authdata.TitleId++;

                Thread.Sleep(1100);
                base.RunTest();
                if (!base.VerifyTest())
                {
                    Fail("Second sign-in failed verification");
                    return;
                }
            }
        }

        [TestCase]
        [CompoundCase("Change to {0}", 2)]
        [CompoundCase("Change to {0}", 3)]
        [CompoundCase("Change to {0}", 4)]
        class ChangeUsers : TestBase_SGInfo
        {
            protected override void RunTest ()
            {
                base.RunTest();
                if (!base.VerifyTest())
                {
                    Fail("Initial sign-in failed verification");
                    return;
                }

                int changeToVersion = (int)MyValues[0];

                CreateAuthdataForVersion(changeToVersion);

                // change some stuff and do it again!
                sg.Context.Authdata.GetUser(0).qwUserID++;
                sg.Context.Authdata.TitleId++;
                sg.BuildFakeTicket(sg.Context.Authdata);

                if (!sg.SendChangeUsers())
                {
                    throw new UnexpectedTestResultException("SendChangeUsers failed.");
                }
                RetrieveAuthdata();

                if (!base.VerifyTest())
                {
                    Fail("Change users failed verification");
                    return;
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class RandomAuthdata : TestBase_SGInfo
        {
            protected override void SetDefaults ()
            {
                sg = new SgClient(new AuthContext(clientType));
                int adVersion = 4;

                if (Parent != null && Parent.MyValues != null && Parent.MyValues.Length > 0)
                {
                    adVersion = (int)Parent.MyValues[0];
                    useOldProtocol = (byte)(int)Parent.MyValues[1];
                }

                int size = Math.Max(Math.Max(Authdata_Xbox2.SIZE, Authdata_Xenon.SIZE), Authdata_Xenon2.SIZE);
                byte[] blob = RandomEx.GlobalRandGen.GenerateRandomBlob(size);

                if (adVersion == (int)Authdata_Base.XONLINE_XBOX2_AUTHDATA_VERSION)
                {
                    Authdata_Xbox2 ad = new Authdata_Xbox2();
                    sg.Context.Authdata = ad;
                    ad.ReadBytes(blob);

                    ad.wAuthDataVersion = Authdata_Base.XONLINE_XBOX2_AUTHDATA_VERSION;
                    ad.wAuthDataSize = (ushort)Authdata_Xbox2.SIZE;

                    // ensure that we have service 28 (testfd), or we can't run the test
                    ad.dwNumServices = Math.Min(Math.Max(ad.dwNumServices, 1), 12);
                    ad.dwServiceID[0] = TestFDService;
                }
                else if (adVersion == (int)Authdata_Base.XONLINE_XENON_AUTHDATA_VERSION)
                {
                    Authdata_Xenon ad = new Authdata_Xenon();
                    sg.Context.Authdata = ad;
                    ad.ReadBytes(blob);

                    ad.wAuthDataVersion = Authdata_Base.XONLINE_XENON_AUTHDATA_VERSION;
                    ad.wAuthDataSize = (ushort)Authdata_Xenon.SIZE;

                    // ensure that we have service 28 (testfd), or we can't run the test
                    ad.dwPrivileges[0] |= (1 << TestFDService);

                    // Run through all 256 bits and count them
                    ad.wNumPrivileges = 0;
                    for (int i = 0; i < ad.dwPrivileges.Length; ++i)
                    {
                        // Count bits in the DWORD
                        uint mask = ad.dwPrivileges[i];
                        while (mask != 0)
                        {
                            ad.wNumPrivileges++;
                            mask &= mask - 1;
                        }
                    }

                    ad.wNumDwordServices = Math.Min(ad.wNumDwordServices, (ushort)4);
                }
                else if (adVersion == (int)Authdata_Base.XONLINE_XENON2_AUTHDATA_VERSION)
                {
                    Authdata_Xenon2 ad = new Authdata_Xenon2();
                    sg.Context.Authdata = ad;
                    ad.ReadBytes(blob);

                    ad.wAuthDataVersion = Authdata_Base.XONLINE_XENON2_AUTHDATA_VERSION;
                    ad.wAuthDataSize = (ushort)Authdata_Xenon2.SIZE;

                    // ensure that we have service 28 (testfd), or we can't run the test
                    ad.dwBaseServices[0] |= (1 << TestFDService);

                    ad.wNumExtendedServices = Math.Min(ad.wNumExtendedServices, (ushort)4);

                    // zero out reserved bytes, the SG ignores them
                    for (int i = 0; i < ad.abReserved.Length; ++i)
                    {
                        ad.abReserved[i] = 0;
                    }
                }
                else
                {
                    throw new Exception("Unknown value for authdata version: " + adVersion);
                }
            }

            protected override void InitGroup ()
            {
                base.InitGroup();

                sg.bUseConnectionServices = false;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncSecmsgXbToXbForward2.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService;
 
namespace XSGTest
{
    abstract class TestBase_Forward2 : TestBase_SgFake
    {
        public static IPEndPoint[]      SgIpAddresses = null;
        public const int                IPIDX_SENDER = 1;
        public const int                IPIDX_RECIPIENT = 0;

        protected bool                  bExpectNoReply = false;

        // 2 clients, 2 SGs
        protected SgClient              sgSender = null;
        protected SgClient              sgRecipient = null;

        // Used to override the sgSender/sgRecipient SGAddress fields
        protected SGAddress             sgaddrSender = null;
        protected SGAddress             sgaddrRecipient = null;

        // Payload
        protected byte[]                message = null;

        // Request to SG
        protected SecMsgXbToXbForward2  requestMsg = null;

        // Reply from SG
        protected SecMsgXbToXbForward2  replyMsg = null;

        // Move random generator from TestBase
        protected static RandomEx Random = new RandomEx();
        
        protected override void InitGroup()
        {
            // Get list of SG IP addresses, but only once
            if (SgIpAddresses == null)
            {
                SgIpAddresses = Global.XEnv.GetInterface("sgsvc");
                string sgips = "";
                for (int i = 0; i < SgIpAddresses.Length; i++)
                {
                    if (i > 0)
                        sgips += ", ";
                    sgips += SgIpAddresses[i].ToString();
                }
                ro.Debug("Using these SG servers: {0}", sgips);
                if (SgIpAddresses == null || SgIpAddresses.Length < 2)
                {
                    Fail("Unable to run these tests, they require at least 2 SG servers.");
                    SgIpAddresses = null;
                    throw new DidNotExecuteException("This test requires 2 or more SG servers");
                }
            }

            // Normally we would sign in to the SG here and set "sg". But we are going to 
            // ignore all of that and sign in 2 new SgClients to each real SG. This 
            // obviously requires access to 2 SG machines, like in Testnet.
            sgSender = SignInClient(SgIpAddresses[IPIDX_SENDER]);
            sgRecipient = SignInClient(SgIpAddresses[IPIDX_RECIPIENT]);
        }

        protected SgClient SignInClient(IPEndPoint sgIp)
        {
            return SignInClient(sgIp, true);
        }

        protected SgClient SignInClient(IPEndPoint sgIp, bool bUseCS)
        {
            SgClient sg2;
            sg2 = new SgClient(new AuthContext(clientType));
            sg2.Context.Site = SiteInfoManager.GetDefaultSgSite().CloneDeep();
            sg2.Context.Authdata = Authdata_Base.NewDefaultFromSite(sg2.Context.Site);
            sg2.Context.Site.siteIp = (IPEndPoint)sgIp;
            sg2.Context.ClearUsers();
            for (int i = 0; i < numSimulatedUsers; i++)
            {
                sg2.Context.SetUser("sgtestuser" + i, i);
            }
            sg2.SetDefaultAuthdata(sg2.Context.Authdata);
            sg2.bUseConnectionServices = bUseCS;
            sg2.BuildFakeTicket(sg2.Context.Authdata, sg2.Context.Site.serverName, sg2.Context.Site.siteName, sg2.Context.Site.siteKey);
            try
            {
                sg2.SignInSG();
            }
            catch
            {
                ro.Warn("Failed to sign in client to {0}", sgIp);
                throw;
            }
            return sg2;
        }
        
        protected void Init(int payloadSize)
        {
            Init(payloadSize, sgRecipient);
        }

        protected void Init(int payloadSize, SgClient sgDestination)
        {
            base.InitTest();
            
            // Fill message payload with random bytes that we can verify later
            message = new byte[payloadSize];
            Random.NextBytes(message);
          
            // Fill out with mainline case, adjust in tests as necessary
            sgaddrSender = sgSender.SGADDR;
            sgRecipient = sgDestination;
            sgaddrRecipient = sgDestination.SGADDR;

            // Create XbToXbForward2 SECMSG
            CreateRequest();
        }

        protected override void RunTest()
        {
            // For the 2-SG XbToXbForward scenario, the most interesting one, sgRecipient 
            // will be the SG we read the reply from.
            //SgClient sg2 = sgRecipient;

            // Auto-adjust the SG to receive from based on IP address in the recipient's 
            // SGADDR.
            //if (sgaddrRecipient.SgIP.EqualsIp(sgSender.IpServer.Address))
            //{
            //    // Recipient is on the sgSender SG
            //    sg2 = sgSender;
            //}

            // Helper functions
            SendIt();
            RecvIt();
        }

        protected void CreateRequest()
        {
            requestMsg = new SecMsgXbToXbForward2();
            requestMsg.sgaSender = sgaddrSender;
            requestMsg.sgaTarget = sgaddrRecipient;
            requestMsg.SetMessage(message);
        }

        protected void SendIt()
        {
            sgSender.XspSend(requestMsg);
        }

        protected void RecvIt()
        {
            // Receive reply on appropriate SG
            SecMsgHeader hdr = sgRecipient.SecMsgRecv(2000, SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD2);
            if (bExpectNoReply)
            {
                if (hdr != null)
                {
                    Fail("Expected no reply but got an XbToXbForward2 packet");
                }
                return;
            }
            
            if (hdr == null)
            {
                Fail("Did not receive the SecMsgXbToXbForward2 message from the SG");
                return;
            }
            replyMsg = (SecMsgXbToXbForward2)hdr;
        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;
            
            if (bExpectNoReply)
                return true;

            if (replyMsg == null || message == null || replyMsg.message == null)
            {
                Fail("Payload doesn't exist");
                return false;
            }

            // Check recipient (target) SGADDRs
            if (sgaddrRecipient != replyMsg.sgaTarget)
                Fail("Recipient SGADDR doesn't match: {0}, {1}", sgaddrRecipient.ToString(), replyMsg.sgaTarget.ToString());

            // Check sender SGADDRs
            if (sgaddrSender != replyMsg.sgaSender)
                Fail("Sender SGADDR doesn't match: {0}, {1}", sgaddrSender.ToString(), replyMsg.sgaSender.ToString());

            // Check the IP address of the source of the reply versus the recipient SGADDR  
            // IP address
            //IPEndPoint ep = (IPEndPoint)sgRecipient.Context.Udp.epRemote;
            //if (!sgaddrRecipient.SgIP.EqualsIp(ep.Address))
            //    Fail("Reply's IP address and recipient's SGADDR IP don't match: {0}, 
            //    {1}", ep.ToString(), sgaddrRecipient.SgIP.ToString());

            // Check payload length
            if (replyMsg.message.Length != message.Length)
            {
                Fail("Payload lengths don't match, sent length={0}, received length={1}", message.Length, replyMsg.message.Length);
                return false;
            }

            // Check payload
            for (int i = 0; i < message.Length; i++)
            {
                if (replyMsg.message[i] != message[i])
                {
                    Fail("Payload contents don't match at byte #{0}: sent 0x{1:X}, got 0x{2:X}", i, message[i], replyMsg.message[i]);
                    return false;
                }
            }

            return true;
        }

    }


    [TestGroup, TestCasePriority(3), EnvRequirement("MultipleSGs")]
    public class Secmsg_XbToXbForward2 : TestNode
    {
        [TestCase]
            class SecMsg_XbToXbForward2_Basic_SameSg_SameUser : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(256, sgSender);
                ro.Debug("[   Sender] {0}  SG IP {1}", sgaddrSender.ToString(), sgSender.IpServer.ToString());
                ro.Debug("[Recipient] {0}  SG IP {1}", sgaddrRecipient.ToString(), sgRecipient.IpServer.ToString());
            }

            protected override bool VerifyTest()
            {
                ro.Debug("[   Reply sender] {0}", replyMsg.sgaSender);
                ro.Debug("[Reply recipient] {0}", replyMsg.sgaTarget);
                return base.VerifyTest();
            }
        }

        [TestCase, TestCasePriority(1)]
            class SecMsg_XbToXbForward2_Basic_SameSg_DiffUser : TestBase_Forward2
        {
            protected override void InitTest()
            {
                // Sign-in the recipient SGClient to SG[1], which is the sgSender IP
                sgRecipient = SignInClient(SgIpAddresses[1]);
                Init(256, sgRecipient);
                ro.Debug("[   Sender] {0}  SG IP {1}", sgaddrSender.ToString(), sgSender.IpServer.ToString());
                ro.Debug("[Recipient] {0}  SG IP {1}", sgaddrRecipient.ToString(), sgRecipient.IpServer.ToString());
            }

            protected override bool VerifyTest()
            {
                ro.Debug("[   Reply sender] {0}", replyMsg.sgaSender);
                ro.Debug("[Reply recipient] {0}", replyMsg.sgaTarget);
                return base.VerifyTest();
            }
        }

        [TestCase, TestCasePriority(1)]
            class SecMsg_XbToXbForward2_Basic_OtherSg : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(256, sgRecipient);
                ro.Debug("[   Sender] {0}  SG IP {1}", sgaddrSender.ToString(), sgSender.IpServer.ToString());
                ro.Debug("[Recipient] {0}  SG IP {1}", sgaddrRecipient.ToString(), sgRecipient.IpServer.ToString());
            }

            protected override bool VerifyTest()
            {
                ro.Debug("[   Reply sender] {0}", replyMsg.sgaSender);
                ro.Debug("[Reply recipient] {0}", replyMsg.sgaTarget);
                return base.VerifyTest();
            }
        }


        [TestCase]
            class SecMsg_XbToXbForward2_NoPayload_Valid : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(0);
            }
        }


        [TestCase, TestCasePriority(2)]
            class SecMsg_XbToXbForward2_MaxPayload_Valid : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(KC.k_MaxXSPPayload - SecMsgXbToXbForward2.SIZE);
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_EvilSender_InvalidPlatform : TestBase_Forward2
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(1);
                sgaddrSender.Platform = 0xFF;
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_EvilSender_InvalidSpi : TestBase_Forward2
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(1);
                sgaddrSender.SpiSg++;
            }
        }
        
        [TestCase]
            class SecMsg_XbToXbForward2_EvilSender_InvalidPuid : TestBase_Forward2
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(1);
                sgaddrSender.XboxID++;
            }
        }


        [TestCase]
            class SecMsg_XbToXbForward2_EvilTarget_InvalidPlatform : TestBase_Forward2
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(1);
                sgaddrRecipient.Platform = 0xFF;
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_EvilTarget_InvalidSpi : TestBase_Forward2
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(1);
                sgaddrRecipient.SpiSg++;
            }
        }
        
        [TestCase]
            class SecMsg_XbToXbForward2_EvilTarget_InvalidPuid : TestBase_Forward2
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(1);
                sgaddrRecipient.XboxID++;
            }
        }



        [TestCase]
            class SecMsg_XbToXbForward2_BadSize_TooSmall : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(256);
                bExpectNoReply = true;
                requestMsg.cbEnt = SecMsgXbToXbForward2.SIZE - 1;
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_BadSize_Small_NoPayload : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(256);
                requestMsg.cbEnt = SecMsgXbToXbForward2.SIZE;
            }
            protected override bool VerifyTest()
            {
                // skip other stuff, too complicated to fiddle in
                // We specified exactly the SECMSG size, no payload possible, even though 
                // we sent the payload.
                if (replyMsg.message.Length != 0)
                {
                    Fail("Payload lengths don't match, got reply length={0}, expected 0", replyMsg.message.Length);
                    return false;
                }
                return true;
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_BadSize_0 : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(256);
                bExpectNoReply = true;
                requestMsg.cbEnt = 0;
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_BadSize_Large : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(256);
                bExpectNoReply = true;
                // Specify too much data, but send less, will result in event 50059
                requestMsg.cbEnt++;
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_BadSize_Max : TestBase_Forward2
        {
            protected override void InitTest()
            {
                Init(256);
                bExpectNoReply = true;
                // Specify too much data, but send less, will result in event 50059
                unchecked {
                    requestMsg.cbEnt = (short)0xFFFF;
                }
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_SenderNoCS : TestBase_Forward2
        {
            protected override void InitTest()
            {
                // Sign sender without connection services (CS)
                sgSender = SignInClient(SgIpAddresses[IPIDX_SENDER], false);
                Init(256);
                bExpectNoReply = true;
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward2_RecipientNoCS : TestBase_Forward2
        {
            protected override void InitTest()
            {
                // Sign in recipient without connection services (CS)
                sgRecipient = SignInClient(SgIpAddresses[IPIDX_RECIPIENT], false);
                Init(256);
                bExpectNoReply = true;
            }
        }






    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\FuncXbToXbForward.cs ===
using System;
using System.Collections;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService;
 
namespace XSGTest
{
    abstract class TestBase_Forward : TestBase_Secmsg
    {
        // Default behavior is to send a forward request to ourself

        static byte[] defaultMessage = new byte[42];

        protected bool bExpectNoReply = false;

        SGAddress recipient;
        byte[] message = null;
        SecMsgXbToXbForward rep = null;

        protected void Init(int payloadSize)
        {
            message = new byte[payloadSize];
            base.InitTest();
            // Send it to me
            recipient = sg.KeyexResult.keyexResp.SGAddressInit;
            ro.Debug("Recipient SGADDR {0}", recipient.ToString());
        }

        protected override void InitTest()
        {
            base.InitTest();
            // Send it to me
            recipient = sg.KeyexResult.keyexResp.SGAddressInit;
            ro.Debug("Recipient SGADDR {0}", recipient.ToString());
        }

        protected override void RunTest()
        {
            if (message == null)
                message = defaultMessage;

            //                    SGAddress recipient = new SGAddress();
            //                    recipient.SgIP = authContext.ServiceCtxXe.siteIPAddress;
            //                    recipient.SpiSg = (int)authContext.SecKeys.SpiRecv;
            //                    recipient.XboxID = authContext.UsersMachine.xuid.qwUserID;

            // Send it
            sg.SendXbToXbForward(recipient, message);

            // Since we sent it to ourself, let's receive it
            SecMsgHeader hdr = sg.SecMsgRecv(2000, SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD);
            if (bExpectNoReply)
            {
                if (hdr != null)
                {
                    Fail("Expected no reply but got an XbToXbForward packet");
                }
                return;
            }
            
            if (hdr == null)
            {
                Fail("Did not receive the SecMsgXbToXbForward message from the SG");
                return;
            }
            rep = (SecMsgXbToXbForward)hdr;
        }

        protected override bool VerifyTest()
        {
            if (!base.VerifyTest())
                return false;
            
            if (bExpectNoReply)
                return true;

            // Check reply ip
            IPEndPoint ep = (IPEndPoint)sg.Context.Udp.epRemote;
            ro.Debug("Sent XbToXbForward to {0}, got reply from {0} (should be the same)", sg.IpServer.ToString(), ep.ToString());
            if (!sg.IpServer.Equals(ep))
            {
                Fail("IP addresses don't match");
            }

            if (rep == null || message == null || rep.message == null)
            {
                Fail("Payload doesn't exist");
                return false;
            }
            
            if (rep.message.Length != message.Length)
            {
                Fail("Payload lengths don't match, sent length={0}, received length={1}", message.Length, rep.message.Length);
                return false;
            }

            // Check payload
            for (int i = 0; i < message.Length; i++)
            {
                if (rep.message[i] != message[i])
                {
                    Fail("Payload contents don't match at byte #{0}", i);
                    return false;
                }
            }

            return true;
        }

    }


    [TestGroup, TestCasePriority(3)]
    public class XbToXbForward : TestNode
    {
        [TestCase]
            class SecMsg_XbToXbForward_Self : TestBase_Forward
        {
        }

        [TestCase]
            class SecMsg_XbToXbForward_0payload : TestBase_Forward
        {
            protected override void InitTest()
            {
                Init(0);
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward_1payload : TestBase_Forward
        {
            protected override void InitTest()
            {
                Init(1);
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward_7payload : TestBase_Forward
        {
            protected override void InitTest()
            {
                Init(7);
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward_8payload : TestBase_Forward
        {
            protected override void InitTest()
            {
                Init(8);
            }
        }
    
        [TestCase]
            class SecMsg_XbToXbForward_9payload : TestBase_Forward
        {
            protected override void InitTest()
            {
                Init(9);
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward_MaxPayload : TestBase_Forward
        {
            protected override void InitTest()
            {
                // XbToXbForward packet has 4 byte header plus 20 byte SGADDR. The rest is payload.
                Init(KC.k_MaxXSPPayload - 4 - 20);
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward_MaxPayloadPlus1_Invalid : TestBase_Forward
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(KC.k_MaxXSPPayload - 4 - 20 + 1);
            }
        }

        [TestCase]
            class SecMsg_XbToXbForward_MaxPayloadPlus8_Invalid : TestBase_Forward
        {
            protected override void InitTest()
            {
                bExpectNoReply = true;
                Init(KC.k_MaxXSPPayload - 4 - 20 + 8);
            }
        }
        
           
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\PacketEventLogs.cs ===
using System;
using System.Collections.Generic;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XSGTest
{
    [TestGroup, TestCasePriority(3)]
    public class PacketEventLogs : TestNode
    {
        [TestGroupSetup]
        public static void Setup ()
        {
            SgServerInfo[] servers = SgServerInfo.Servers;

            foreach (SgServerInfo server in servers)
            {
                ManagementListener.Listen(server.XmgmtIp, "sg", "SgClientStats", Listener);
                Global.RO.Debug("Listening to SgClient stats on {0}", server.XmgmtIp);
            }

            // external group setups
            Packet_Validity.Setup();
        }

        [TestGroupTearDown]
        public static void Teardown ()
        {
            SgServerInfo[] servers = SgServerInfo.Servers;

            foreach (SgServerInfo server in servers)
            {
                ManagementListener.Stop(server.XmgmtIp, "sg", "SgClientStats", Listener);
            }

            // external group teardowns
            Packet_Validity.TearDown();
        }

        protected static Dictionary<int, List<PacketEventLogBase>> _tests = new Dictionary<int, List<PacketEventLogBase>>();

        public static void RegisterTest (int id, PacketEventLogBase test)
        {
            lock (_tests)
            {
                List<PacketEventLogBase> tests = null;

                if (!_tests.ContainsKey(id))
                {
                    tests = new List<PacketEventLogBase>();
                    _tests.Add(id, tests);
                }
                else
                {
                    tests = _tests[id];
                }

                tests.Add(test);
            }
        }

        public static void UnregisterTest (int id, PacketEventLogBase test)
        {
            lock (_tests)
            {
                if (_tests.ContainsKey(id))
                {
                    _tests[id].Remove(test);
                }
            }
        }

        public static void Listener (ManagementListener.Datagram dgram)
        {
            try
            {
                Global.RO.Info(dgram.ToString());

                if (dgram.Text == null || dgram.Text == string.Empty)
                {
                    Global.RO.Debug("Got empty text log: {0}", dgram);
                }
                else
                {
                    string[] logsplit = dgram.Text.Split('|');

                    // guaranteed to have at least one string in the array, check for packet event starter
                    if (logsplit[0] != "PEVT")
                    {
                        return;
                    }

                    if (logsplit.Length == 1)
                    {
                        Global.RO.Debug("Got short text log: {0}", dgram);
                    }
                    else
                    {
                        int pevt_id = int.Parse(logsplit[1]);
                        List<PacketEventLogBase> tests = null;

                        lock (_tests)
                        {
                            if (!_tests.ContainsKey(pevt_id))
                            {
                                Global.RO.Debug("Dropping log: {0}", dgram);
                                return;
                            }

                            tests = _tests[pevt_id];
                        }

                        // pass split log line to test
                        dgram.UserData = logsplit;

                        if (tests != null)
                        {
                            foreach (PacketEventLogBase test in tests)
                            {
                                test.HandleLog(dgram);
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Warn("Got exception from processing log:\r\n{0}", e);
            }
        }

        public enum PacketEventID : int
        {
            /// <summary>53862 - Kerberos ticket expired.</summary>
            EVENT_SG_INVALID_KERBEROS_TICKET_15 = 0xD266,
            /// <summary>53871 - Authenticator stamped too far from current time.</summary>
            EVENT_SG_INVALID_KERBEROS_TICKET_24 = 0xD26F,
            /// <summary>53801 - Bad SHA hash.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_1 = 0xD229,
            /// <summary>53832 - Fragmented packet</summary>
            EVENT_SG_INVALID_PACKET_8 = 0xD248,
            /// <summary>53806 - XSP length does not match IP length.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_6 = 0xD22E,
            /// <summary>53809 - bad XSP type, XR owns.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_9 = 0xD231,
            /// <summary>53814 - unknown SPI.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_14 = 0xD236,
            /// <summary>53816 - packet source IP does not match keyex source IP.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_16 = 0xD238,
            /// <summary>53817 - packet source port does not match keyex source port.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_17 = 0xD239,
            /// <summary>53818 - sequence outside of window.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_18 = 0xD23A,
            /// <summary>54012 - packet replay.</summary>
            EVENT_SG_REPLAYED_PACKET = 0xD2FC,
            /// <summary>53823 - source port is 0 or 0xFFFF.</summary>
            EVENT_SG_INVALID_IPSEC_PACKET_23 = 0xD23F,
            /// <summary>54018 - key exchange packet is too small.</summary>
            EVENT_SG_TOOSMALL_KEYEX_PACKET = 0xD302,
            /// <summary>53848 - Generic ApRequest event, after a more specific one.</summary>
            EVENT_SG_INVALID_KERBEROS_TICKET_1 = 0xD258,
            /// <summary>54011 - Replayed keyex.</summary>
            EVENT_SG_REPLAYED_KERBEROS_AUTHENTICATOR = 0xD2FB,
            /// <summary>54017 - Multiple key-exchange attempts within a short time.</summary>
            EVENT_SG_TOOSOON_KEYEX_PACKET = 0xD301,
            /// <summary>53835 - non echo ICMP message.</summary>
            EVENT_SG_INVALID_PACKET_11 = 0xD24B,
        }

        public PacketEventLogs ()
        {
            // expired kerb ticket
            AddChild(new PacketEventLogBase(new Keyex_Sg.Kerb_Ticket_Expired(),
                PacketEventID.EVENT_SG_INVALID_KERBEROS_TICKET_15), true, false);
            // expired authenticator
            AddChild(new PacketEventLogBase(new Keyex_Sg.Kerb_Authenticator_Expired(),
                PacketEventID.EVENT_SG_INVALID_KERBEROS_TICKET_24), true, false);
            // bad SHA hash
            AddChild(new PacketEventLogBase(new Packet_Validity.BadSHA(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_1), true, false);
            // fragmented packet
            AddChild(new PacketEventLogBase(new Packet_Validity.IPFragmentPacket(),
                PacketEventID.EVENT_SG_INVALID_PACKET_8), true, false);
            // udp size != ip size
            AddChild(new PacketEventLogBase(new Packet_Validity.BadUDPSize(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_6), true, false);
            // XR owns
            //AddChild(new PacketEventLogBase(new Packet_Validity.BadPacketType_Leak(),
            //    PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_9), true, false);
            // unknown SPI
            AddChild(new PacketEventLogBase(new Packet_Validity.UnknownSPI(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_14), true, false);
            // IP not the same as the keyex
            AddChild(new PacketEventLogBase(new Packet_Validity.ChangeSourceIP(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_16), true, false);
            // port not the same as the keyex
            AddChild(new PacketEventLogBase(new Packet_Validity.ChangeSourcePort(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_17), true, false);
            // outside sequence window
            AddChild(new PacketEventLogBase(new Packet_Validity.OutsideSequenceWindow(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_18), true, false);
            // packet replay
            AddChild(new PacketEventLogBase(new Packet_Validity.PacketReplay(),
                PacketEventID.EVENT_SG_REPLAYED_PACKET), true, false);
            // source port 0
            AddChild(new PacketEventLogBase(new Packet_Validity.SourcePortInvalid_0(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_23), true, false);
            // source port 0xFFFF
            AddChild(new PacketEventLogBase(new Packet_Validity.SourcePortInvalid_Max(),
                PacketEventID.EVENT_SG_INVALID_IPSEC_PACKET_23), true, false);
            // keyex too small
            AddChild(new PacketEventLogBase(new Packet_Validity.KeyExPacketTooSmall(),
                PacketEventID.EVENT_SG_TOOSMALL_KEYEX_PACKET), true, false);
            // bad ker ap
            AddChild(new PacketEventLogBase(new Packet_Validity.BadKerbApReq(),
                PacketEventID.EVENT_SG_INVALID_KERBEROS_TICKET_1), true, false);
            // replayed authenticator
            AddChild(new PacketEventLogBase(new Keyex_Sg.Keyex_Resend(),
                PacketEventID.EVENT_SG_REPLAYED_KERBEROS_AUTHENTICATOR), true, false);
            // key-exchange spam
            AddChild(new PacketEventLogBase(new Keyex_Sg.Keyex_User_KeyexTooSoon_WithDelete(),
                PacketEventID.EVENT_SG_TOOSOON_KEYEX_PACKET), true, false);
            // non echo icmp
            AddChild(new PacketEventLogBase(new Packet_Validity.IcmpEchoReply(),
                PacketEventID.EVENT_SG_INVALID_PACKET_11), true, false);
        }

        // Leaving this here as it is a handy way to watch the log if you really want
        [TestCase, Ignore]
        public class Wait100 : TestBase
        {
            protected override void Execute ()
            {
                System.Threading.Thread.Sleep(100 * 1000);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Base class for packet event log tests.
        /// </summary>
        public class PacketEventLogBase : TestBase
        {
            public int EventID = 0;
            public TestNode BaseTest = null;
            protected ManualResetEvent SyncObj = new ManualResetEvent(false);
            public int Timeout = 10000;

            public PacketEventLogBase (TestNode test, int id)
            {
                EventID = id;
                BaseTest = test;
                Name = test.Name + " - PEVT LogCheck";
            }

            public PacketEventLogBase (TestNode test, PacketEventID id) : this(test, (int) id) { }

            protected override void Execute ()
            {
                try
                {
                    PacketEventLogs.RegisterTest(EventID, this);
                    SyncObj.Reset();

                    BaseTest.Run();

                    // waiting for HandleLog to signal us, it will fail the test if necessary
                    if (!SyncObj.WaitOne(Timeout, false))
                    {
                        throw new UnexpectedTestResultException("Failed to receive log line within timeout.");
                    }

                    // verify that the SG is still running
                    TestBase_QOS qos = new TestBase_QOS();
                    qos.Run();
                }
                catch
                {
                    Global.RO.Error("Base test or qos failed, not waiting for the log line.");
                    throw;
                }
                finally
                {
                    PacketEventLogs.UnregisterTest(EventID, this);
                }
            }

            public virtual void HandleLog (ManagementListener.Datagram dgram)
            {
                // basic validation is just happy to see the log line
                SyncObj.Set();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\GroupManagedLuaScript.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using xonline.common.config;

namespace XSGTest
{
    /// <summary>
    /// Allows a group to collect Lua scripts and prop them together.
    /// </summary>
    public interface IGroupManagedLuaScript
    {
        /// <summary>
        /// Gets the script(s) associated with the test.
        /// </summary>
        IEnumerable<LuaScript> GetScripts ();
    }

    /// <summary>
    /// A base class for test groups that will automatically collect all children's
    /// Lua scripts and manage them together.
    /// </summary>
    public class GroupManagedLuaScriptTestNode : TestNode
    {
        /// <summary>Test-specific reporting object.</summary>
        protected static Report Ro = new Report("GroupLua");

        /// <summary>
        /// The context name of the ScriptManager.
        /// </summary>
        public const string ScriptManagerContext = "GroupManagedLuaScriptTestNode.ScriptManager";

        /// <summary>Manages our scripts.</summary>
        protected ChallengeManager ScriptManager;

        public GroupManagedLuaScriptTestNode ()
        {
            ScriptManager = new ChallengeManager();

            CreateContextData();
            SetContextData(ScriptManagerContext, ScriptManager);
        }

        public override void PreRun ()
        {
            // this just props the scripts
            RecurseChildrenForScripts(this);

            // now reload the servers
            SgServerInfo.ReloadChallenges();
        }

        public override void PostRun ()
        {
            ScriptManager.RemoveAllScripts();
        }

        /// <summary>Check our children for scripts.</summary>
        protected void RecurseChildrenForScripts (TestNode node)
        {
            if (node != null && node.Children != null)
            {
                foreach (TestNode child in node.Children)
                {
                    if (child.FunctionalData != null && child.FunctionalData.Enabled)
                    {
                        IGroupManagedLuaScript igmls = child as IGroupManagedLuaScript;

                        if (igmls != null)
                        {
                            IEnumerable<LuaScript> scripts = igmls.GetScripts();

                            if (scripts != null)
                            {
                                foreach (LuaScript ls in scripts)
                                {
                                    ScriptManager.AddScript(ls, false);
                                }
                            }
                        }

                        RecurseChildrenForScripts(child);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\sources.inc ===
USER_CS_FLAGS=$(USER_CS_FLAGS) /unsafe

REFERENCES = \

SOURCES=\
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\PropertiesPage.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace XSGTest
{
    public partial class PropertiesPage : Form
    {
        public PropertiesPage ()
        {
            InitializeComponent();
        }

        public void SetProperties (Dictionary<string, string> properties)
        {
            cmbProperty.BeginUpdate();

            cmbProperty.Items.Clear();
            txtValue.Clear();

            Property selected = null;

            foreach (string key in properties.Keys)
            {
                Property p = new Property();
                p.Name = key;
                p.Value = properties[key];
                p.Dirty = false;

                if (key == _lastSelected)
                {
                    selected = p;
                }

                cmbProperty.Items.Add(p);
            }

            if (selected != null)
            {
                cmbProperty.SelectedItem = selected;
            }

            cmbProperty.EndUpdate();
        }

        public Property[] GetProperties ()
        {
            Property[] ps = new Property[cmbProperty.Items.Count];
            int i = 0;

            foreach (object o in cmbProperty.Items)
            {
                ps[i++] = (Property)o;
            }

            return ps;
        }

        public class Property
        {
            public string Name;
            public string Value;
            public bool Dirty;

            public override string ToString ()
            {
                return Name;
            }
        }

        private string _lastSelected = null;

        private void cmbProperty_SelectedIndexChanged (object sender, EventArgs e)
        {
            Property p = (Property)cmbProperty.SelectedItem;

            if (p != null)
            {
                _lastSelected = p.Name;
                txtValue.Text = p.Value;
            }
        }

        private void txtValue_TextChanged (object sender, EventArgs e)
        {
            Property p = (Property)cmbProperty.SelectedItem;

            if (p != null)
            {
                if (txtValue.Text != p.Value)
                {
                    p.Value = txtValue.Text;
                    p.Dirty = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\QuickConnect.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace XSGTest
{
    public partial class QuickConnect : Form
    {
        public QuickConnect ()
        {
            InitializeComponent();
        }

        private class Connector : TestBase_SgFake
        {
            public void Defaults () { base.SetDefaults(); }
        }

        /// <summary>
        /// Does the actual connection to the SG.
        /// </summary>
        private void btnConnect_Click (object sender, EventArgs e)
        {
            Connector test = new Connector();

            test.Defaults();

            test.sg.Context.Authdata.XboxID = ulong.Parse(txtMachinePuid.Text, 
                System.Globalization.NumberStyles.AllowHexSpecifier);

            test.DoKeyExchange();

            lblCipher.Text = test.sg.Context.SecKeys.Cipher.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\PersistentKick.cs ===
using System;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Threading;

using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XSGTest
{

[TestCasePriority(1), TestFrequency("Regression")]
public class PersistentKick : TestNode_LuaScriptGroup
{
    #region Group Related

    public PersistentKick ()
    {
        AddScript(new LuaScript() { Name = "Persistent Kick Challenge", Script = MainChallengeBody });
    }

    /// <summary>
    /// Main challenge body.
    /// </summary>
    private const string MainChallengeBody = @"
ChallengeDeclare(0x504B, 'Persistent Block Challenge 0x504B', true, false, false)

__Binary = Buffer.new(
'BDFBB9D4E177EF4D7229F7F332C88E99289B67C1A9DF2B0352C97B629B630749'..
'7C3217747070E451DD105AD83EF8962982F469064ED0F6B6176FB7E5BCAA6D18'..
'0BCDDDBD044A13BB759810EC0C78F6851CE78FE4D4E6057119C695A8B9AFCA41'..
'6737D013B2BC21AFC0B133081F9F390D7E5FCD3EF560910DBF29185C36DC70C1'..
'A84A6AAFB0A52B30C1F597277B1738D72D3BB49DB1CE2CC078CD5541297995E9'..
'FA7329466F463B88513B1F7A3D84697166692A5A3EA9D4BFF8FE9F837682B36B'..
'372D93AEFFB25D4E9C93048573C4A9CEDAC876EBDB1DA5236D004BB709C328D7'..
'06D65F259198224AA989E7D233D046917CEE82A6FDA981019400661F4317CBE5'..
'0001011000020001'
)

-- Targetting Function Entry Point
function __Target()

    -- specific build will get you kicked
    if Spi.GetClientMajor() == 0x5347 and Spi.GetClientMinor() == 0x504B and Spi.GetClientBuild() == 0x4A4D then
        if Spi.GetClientQfe() == 0 then
            trace('Target: Strong Block')
            Chal.Block(true)
        elseif Spi.GetClientQfe() == 2 then
            trace('Target: Weak Block')
            Chal.Block(false)
        else
            trace('Target: Goto Analyze')
            Chal.SetParam(Buffer.new('BDFBB9D4E177EF4D7229F7F332C88E99'))
            return true
        end
    end
    
    -- don't actually target anyone
    return false
end

-- Analyze Function Entry Point
function __Analyze(buffer)
    if Spi.GetClientQfe() == 1 then
        trace('Analyze: Strong Block')
        Chal.Block(true)
    elseif Spi.GetClientQfe() == 3 then
        trace('Analyze: Weak Block')
        Chal.Block(false)
    else
        trace('Analyze: None')
    end
end
";

    public static void SetAuthdataForKick (Authdata_Base authdata, bool kickAfterResponse)
    {
        SetAuthdataForKick(authdata, kickAfterResponse, false);
    }

    public static void SetAuthdataForKick (Authdata_Base authdata, bool kickAfterResponse, bool weakKick)
    {
        authdata.MajorVersion = 0x5347;  // 'SG' in hex
        authdata.MinorVersion = 0x504B;  // 'PK' in hex
        authdata.BuildNumber = 0x4A4D;   // 'JM' in hex
        authdata.QFENumber = (ushort)((kickAfterResponse ? 1 : 0) | (weakKick ? 2 : 0));
    }

    #endregion

    #region Group TestNode

    private SettingState keyexBlockIntervalState = null;
    public const int ReducedKeyExBlockIntervalInSeconds = 10;

    public override void PreRun (RUN_TYPE runType)
    {
        // change setting to a shorter time
        keyexBlockIntervalState = Global.XEnv.OverrideSetting("ALL", "ALL", Setting.sg_KeyExBlockIntervalInSeconds, 
            ReducedKeyExBlockIntervalInSeconds.ToString(), -1);
        SgEnvironmentInfo.ConfigCacheRefresh();

        base.PreRun(runType);
    }

    public override void PostRun (RUN_TYPE runType)
    {
        // change setting to a shorter time
        Global.XEnv.RestoreOverrideSettingState(keyexBlockIntervalState);
        SgEnvironmentInfo.ConfigCacheRefresh();

        base.PreRun(runType);
    }

    #endregion

    [TestCase]
    [CompoundCase("TargetKick", PersistentKickTestBase.BlockMethod.TargetKick)]
    [CompoundCase("AnalyzeKick", PersistentKickTestBase.BlockMethod.AnalyzeKick)]
    [CompoundCase("XmgmtAdd", PersistentKickTestBase.BlockMethod.XmgmtAdd)]
    public class BlockedClient : PersistentKickTestBase
    {
        protected override void RunTest ()
        {
            // get kicked
            BlockClient(sg, CaseBlockMethod, true);

            // attempt to sign in
            WaitForKeyexTimer();
            UpdateClientToPass(sg);
            ValueCheck.Test("Client state after blocking", ClientState.Blocked, TestClientState(sg));

            // check that another client can sign in
            SgClient newClient = TestBase_SgFake.CreateNewClient(AuthContext.ClientTypes.Xenon, 1);
            newClient.BuildFakeTicket(newClient.Context.Authdata);
            ValueCheck.Test("New client state", ClientState.Enabled, TestClientState(newClient));
        }
    }

    [TestCase]
    [CompoundCase("TargetKick", PersistentKickTestBase.BlockMethod.TargetKickWeak)]
    [CompoundCase("AnalyzeKick", PersistentKickTestBase.BlockMethod.AnalyzeKickWeak)]
    public class WeakKick : PersistentKickTestBase
    {
        protected override void RunTest ()
        {
            // get "kicked"
            BlockClient(sg, CaseBlockMethod, false);

            // attempt to sign in (should be able to)
            WaitForKeyexTimer();
            UpdateClientToPass(sg);
            ValueCheck.Test("Client state after weak kick", ClientState.Enabled, TestClientState(sg));
        }
    }

    [TestCase, AsyncGroup(1, 1)]
    [CompoundCase("TargetKick", PersistentKickTestBase.BlockMethod.TargetKick)]
    [CompoundCase("AnalyzeKick", PersistentKickTestBase.BlockMethod.AnalyzeKick)]
    [CompoundCase("XmgmtAdd", PersistentKickTestBase.BlockMethod.XmgmtAdd)]
    public class BlockTimeout : PersistentKickTestBase
    {
        protected override void RunTest ()
        {
            // get kicked
            BlockClient(sg, CaseBlockMethod, true);

            // attempt to sign in
            WaitForKeyexTimer();
            UpdateClientToPass(sg);
            ValueCheck.Test("Client state after blocking", ClientState.Blocked, TestClientState(sg));

            // wait for the clients block to expire
            Thread.Sleep((CaseBlockMethod == BlockMethod.XmgmtAdd ? 5 : 1) * ReducedKeyExBlockIntervalInSeconds * 1000);

            // attempt to sign in (should be able to)
            ValueCheck.Test("Client state after waiting for expiration", ClientState.Enabled, TestClientState(sg));
        }
    }

    [TestCase]
    public class BlockTableFull : TestNode
    {
        protected const ulong BlockListOffset = 1000;

        protected ulong FirstXboxId;
        protected int BlockTableSize;

        public override void PreRun (RUN_TYPE runType)
        {
            FirstXboxId = SgClient.NextSgPuid | SgClient.k_XenonMachinePuidMask;
            BlockTableSize = Global.XEnv.GetIntSetting(Setting.sg_BlockLimit);

            // turn off this spam
            ManagementConsole.MCReport.DisableFilter(Report.DEBUG);

            for (int i = 0; i < SgServerInfo.NumServers; ++i)
            {
                TcpClient manCon = ManagementConsole.OpenManagementConnection(SgServerInfo.Servers[i].XmgmtIp);

                try
                {
                    for (int j = 0; j < BlockTableSize; ++j)
                    {
                        ulong toBlock = (FirstXboxId + BlockListOffset + (ulong)j);

                        string response;
                        if (ManagementConsole.Execute(manCon, "e :sg blocked add 0x" + toBlock.ToString("X"), out response) != HResult.S_OK)
                        {
                            throw new UnexpectedTestResultException("Failed to add puid to the block list [0x" + toBlock.ToString("X") +
                                "]: " + response);
                        }
                    }
                }
                finally
                {
                    manCon.Close();
                }
            }

            // I dislike it, but turn it back on
            ManagementConsole.MCReport.EnableFilter(Report.DEBUG);
        }

        public override void PostRun (RUN_TYPE runType)
        {
            // turn off this spam
            ManagementConsole.MCReport.DisableFilter(Report.DEBUG);

            for (int i = 0; i < SgServerInfo.NumServers; ++i)
            {
                TcpClient manCon = ManagementConsole.OpenManagementConnection(SgServerInfo.Servers[i].XmgmtIp);

                try
                {
                    for (int j = 0; j < BlockTableSize; ++j)
                    {
                        ulong toBlock = (FirstXboxId + BlockListOffset + (ulong)j);

                        string response;
                        if (ManagementConsole.Execute(manCon, "e :sg blocked remove 0x" + toBlock.ToString("X"), out response) != HResult.S_OK)
                        {
                            throw new UnexpectedTestResultException("Failed to remove puid from the block list [0x" + toBlock.ToString("X") +
                                "]: " + response);
                        }
                    }
                }
                finally
                {
                    manCon.Close();
                }
            }

            // I dislike it, but turn it back on
            ManagementConsole.MCReport.EnableFilter(Report.DEBUG);
        }

        [TestCase]
        [CompoundCase("TargetKick", PersistentKickTestBase.BlockMethod.TargetKick)]
        [CompoundCase("AnalyzeKick", PersistentKickTestBase.BlockMethod.AnalyzeKick)]
        [CompoundCase("XmgmtAdd", PersistentKickTestBase.BlockMethod.XmgmtAdd)]
        public class Cases : PersistentKickTestBase
        {
            protected override void RunTest ()
            {
                // initialize event monitor
                Events events = new Events(SgServerInfo.ServerNames);
                events.Init();

                // get kicked, but not blocked
                BlockClient(sg, CaseBlockMethod, false);

                // attempt to sign in (should be able to)
                WaitForKeyexTimer();
                UpdateClientToPass(sg);
                ValueCheck.Test("Client state after kick (block table full)", ClientState.Blocked, TestClientState(sg));

                // check for event about full block table
                // we should no longer get this event because of reusing an old item for a new block
                if (events.TestForChange(54061))
                {
                    throw new UnexpectedTestResultException("Should not have seen event 54061.");
                }
            }
        }
    }

    [TestCase, StressTest]
    [CompoundCase("AnalyzeKick", PersistentKickTestBase.BlockMethod.AnalyzeKick)]
    public class BlockedClientStress : PersistentKickTestBase
    {
        protected override void RunTest ()
        {
            // get kicked
            BlockClient(sg, CaseBlockMethod, true);

            // attempt to sign in
            WaitForKeyexTimer();
            UpdateClientToPass(sg);
            ValueCheck.Test("Client state after blocking", ClientState.Blocked, TestClientState(sg));
        }
    }
}

public class PersistentKickTestBase : TestBase_SgFake
{
    public enum ClientState
    {
        /// <summary>The client was kicked. Can only happen after sending a challenge response.</summary>
        Kicked,
        /// <summary>
        /// The client keyex response was ignored.
        ///  - Kicked by a challenge in the Target function
        ///  - On the blocked list
        ///  - Tried to keyex to fast after a previous one
        /// </summary>
        Blocked,
        /// <summary>The client signed in.</summary>
        Enabled
    }

    /// <summary>
    /// Determines if a client can sign in or not.
    /// </summary>
    /// <param name="client">The client to test.</param>
    /// <returns>The state of the client.</returns>
    public static ClientState TestClientState (SgClient client)
    {
        try
        {
            client.SignInSG();

            if (client.bGotChallenged)
            {
                SecMsgXbToSgChalResp response = new SecMsgXbToSgChalResp();
                client.XspSend(response);

                try
                {
                    QOS q = new QOS();
                    return (q.SendRecv(client) ? ClientState.Enabled : ClientState.Kicked);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return ClientState.Kicked;
                }
            }

            return ClientState.Enabled;
        }
        catch (ServerTestFramework.Utilities.TimeoutException)
        {
            return ClientState.Blocked;
        }
    }

    /// <summary>The BlockMethod for the current compound case.</summary>
    public BlockMethod CaseBlockMethod
    {
        get
        {
            return (BlockMethod)MyValues[0];
        }
    }

    /// <summary>The mothod used to get a puid into the block list.</summary>
    public enum BlockMethod
    {
        TargetKick,
        TargetKickWeak,
        AnalyzeKick,
        AnalyzeKickWeak,
        XmgmtAdd
    }

    /// <summary>
    /// Get a client on the block list.
    /// </summary>
    /// <param name="client">The client to block. It must have its authdata.</param>
    /// <param name="blockMethod">The method used to block the client.</param>
    /// <param name="checkList">If true, check for the machine on the block list.</param>
    public static void BlockClient (SgClient client, BlockMethod blockMethod, bool checkList)
    {
        switch (blockMethod)
        {
            case BlockMethod.TargetKick:
                {
                    PersistentKick.SetAuthdataForKick(client.Context.Authdata, false, false);
                    client.BuildFakeTicket(client.Context.Authdata, client.Context.Site.serverName, 
                        client.Context.Site.siteName, client.Context.Site.siteKey);
                    ValueCheck.Test("Client state", ClientState.Blocked, TestClientState(client));
                }
                break;

            case BlockMethod.TargetKickWeak:
                {
                    PersistentKick.SetAuthdataForKick(client.Context.Authdata, false, true);
                    client.BuildFakeTicket(client.Context.Authdata, client.Context.Site.serverName,
                        client.Context.Site.siteName, client.Context.Site.siteKey);
                    ValueCheck.Test("Client state", ClientState.Enabled, TestClientState(client));
                }
                break;

            case BlockMethod.AnalyzeKick:
                {
                    PersistentKick.SetAuthdataForKick(client.Context.Authdata, true, false);
                    client.BuildFakeTicket(client.Context.Authdata, client.Context.Site.serverName,
                        client.Context.Site.siteName, client.Context.Site.siteKey);
                    ValueCheck.Test("Client state", ClientState.Kicked, TestClientState(client));
                }
                break;

            case BlockMethod.AnalyzeKickWeak:
                {
                    PersistentKick.SetAuthdataForKick(client.Context.Authdata, true, true);
                    client.BuildFakeTicket(client.Context.Authdata, client.Context.Site.serverName,
                        client.Context.Site.siteName, client.Context.Site.siteKey);
                    ValueCheck.Test("Client state", ClientState.Enabled, TestClientState(client));
                }
                break;

            case BlockMethod.XmgmtAdd:
                {
                    string response;
                    if (!ManagementConsole.ExecuteOnAll(Interface.sgsvc, 
                        "e :sg blocked add 0x" + client.Context.Authdata.XboxID.ToString("X"), out response))
                    {
                        throw new UnexpectedTestResultException("Failed to add the client to the blocked list: " + response);
                    }
                }
                break;
        }

        if (checkList && !CheckBlockedListForPuid(client.Context.Authdata.XboxID))
        {
            throw new UnexpectedTestResultException("Did not find the client on the block list: " + client.Context.Authdata.XboxID.ToString("X"));
        }
    }

    /// <summary>
    /// Changes the authdata for a client so that it bypasses the challenge.
    /// </summary>
    /// <param name="client">The client to change.</param>
    public static void UpdateClientToPass (SgClient client)
    {
        client.Context.Authdata.MajorVersion += 1;
        client.BuildFakeTicket(client.Context.Authdata);
    }

    /// <summary>Waits for the minimum keyex timeout.</summary>
    public static void WaitForKeyexTimer ()
    {
        Thread.Sleep(1100);
    }

    /// <summary>
    /// Checks the blocked list(s) for a specific puid.
    /// </summary>
    /// <param name="puid">The puid to check for.</param>
    /// <returns>True if the puid is found; false otherwise.</returns>
    public static bool CheckBlockedListForPuid (ulong puid)
    {
        foreach (ulong p in ListBlocked())
        {
            if (p == puid)
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Enumerates the blocked puids from te SG.
    /// </summary>
    /// <returns>A list of puids that are blocked.</returns>
    public static IEnumerable<ulong> ListBlocked ()
    {
        foreach (ManagementConsole.XmgmtResponse resp in ManagementConsole.ExecuteOnAll(Interface.sgsvc, "e :sg blocked list"))
        {
            if (!resp.Result)
            {
                throw new UnexpectedTestResultException("Failed to get the blocked list: " + resp.Response);
            }

            System.IO.StringReader reader = new System.IO.StringReader(resp.Response);

            // throw away the header, unless it says there are none
            string header = reader.ReadLine();

            if (header.StartsWith("No blocked connections at"))
            {
                continue;
            }

            string line = null;
            while ((line = reader.ReadLine()) != null)
            {
                string[] fields = line.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                if (fields.Length < 2)
                {
                    throw new UnexpectedTestResultException("Strangely formatted block list line: " + line);
                }

                if (!fields[1].StartsWith("0x"))
                {
                    throw new UnexpectedTestResultException("Strangely formatted block list puid: " + line);
                }

                ulong ans;
                if (!ulong.TryParse(fields[1].Substring(2), System.Globalization.NumberStyles.AllowHexSpecifier, null, out ans))
                {
                    throw new UnexpectedTestResultException("Non-hex block list puid: " + line);
                }

                yield return ans;
            }
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\PropertiesPage.Designer.cs ===
namespace XSGTest
{
    partial class PropertiesPage
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose (bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            this.cmbProperty = new System.Windows.Forms.ComboBox();
            this.lblProperty = new System.Windows.Forms.Label();
            this.lblValue = new System.Windows.Forms.Label();
            this.txtValue = new System.Windows.Forms.TextBox();
            this.btnOk = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // cmbProperty
            // 
            this.cmbProperty.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbProperty.FormattingEnabled = true;
            this.cmbProperty.Location = new System.Drawing.Point(60, 12);
            this.cmbProperty.Name = "cmbProperty";
            this.cmbProperty.Size = new System.Drawing.Size(210, 21);
            this.cmbProperty.Sorted = true;
            this.cmbProperty.TabIndex = 0;
            this.cmbProperty.SelectedIndexChanged += new System.EventHandler(this.cmbProperty_SelectedIndexChanged);
            // 
            // lblProperty
            // 
            this.lblProperty.AutoSize = true;
            this.lblProperty.Location = new System.Drawing.Point(8, 15);
            this.lblProperty.Name = "lblProperty";
            this.lblProperty.Size = new System.Drawing.Size(46, 13);
            this.lblProperty.TabIndex = 1;
            this.lblProperty.Text = "Property";
            // 
            // lblValue
            // 
            this.lblValue.AutoSize = true;
            this.lblValue.Location = new System.Drawing.Point(20, 53);
            this.lblValue.Name = "lblValue";
            this.lblValue.Size = new System.Drawing.Size(34, 13);
            this.lblValue.TabIndex = 2;
            this.lblValue.Text = "Value";
            // 
            // txtValue
            // 
            this.txtValue.Location = new System.Drawing.Point(60, 50);
            this.txtValue.Name = "txtValue";
            this.txtValue.Size = new System.Drawing.Size(210, 20);
            this.txtValue.TabIndex = 3;
            this.txtValue.TextChanged += new System.EventHandler(this.txtValue_TextChanged);
            // 
            // btnOk
            // 
            this.btnOk.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.btnOk.Location = new System.Drawing.Point(122, 87);
            this.btnOk.Name = "btnOk";
            this.btnOk.Size = new System.Drawing.Size(66, 23);
            this.btnOk.TabIndex = 4;
            this.btnOk.Text = "Ok";
            this.btnOk.UseVisualStyleBackColor = true;
            // 
            // btnCancel
            // 
            this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.btnCancel.Location = new System.Drawing.Point(204, 87);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(66, 23);
            this.btnCancel.TabIndex = 5;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            // 
            // PropertiesPage
            // 
            this.AcceptButton = this.btnOk;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.btnCancel;
            this.ClientSize = new System.Drawing.Size(282, 122);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnOk);
            this.Controls.Add(this.txtValue);
            this.Controls.Add(this.lblValue);
            this.Controls.Add(this.lblProperty);
            this.Controls.Add(this.cmbProperty);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.Name = "PropertiesPage";
            this.ShowInTaskbar = false;
            this.Text = "Properties";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.ComboBox cmbProperty;
        private System.Windows.Forms.Label lblProperty;
        private System.Windows.Forms.Label lblValue;
        private System.Windows.Forms.TextBox txtValue;
        private System.Windows.Forms.Button btnOk;
        private System.Windows.Forms.Button btnCancel;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\SgPlugin.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using xonline.common.config;

using ServerTestFramework.Plugins;
using STFGui.Plugins;

namespace XSGTest
{
    class SgPluginException : Exception
    {
        public SgPluginException (string message) : base(message) { }
        public SgPluginException (string message, Exception e) : base(message, e) { }
    }

    /// <summary>
    /// SG plugin.
    /// </summary>
    public class SgPlugin : IPluginSetup, IPluginGui
    {
        public MenuItem GetNewMenu ()
        {
            MenuItem menu = new MenuItem("SG");

            MenuItem next = null;

#if !LSPTEST
            next = new MenuItem("Cipher Override");
            menu.MenuItems.Add(next);

            // add override options
            int current = CurrentCipherOverride;

            MenuItem temp = new MenuItem("Default");
            temp.Click += new EventHandler(cipherOverride_Click);
            temp.Tag = -1;
            if (current == -1) { temp.Checked = true; }
            next.MenuItems.Add(temp);

            temp = new MenuItem("DES");
            temp.Click += new EventHandler(cipherOverride_Click);
            temp.Tag = 0;
            if (current == 0) { temp.Checked = true; }
            next.MenuItems.Add(temp);

            temp = new MenuItem("DES3");
            temp.Click += new EventHandler(cipherOverride_Click);
            temp.Tag = 1;
            if (current == 1) { temp.Checked = true; }
            next.MenuItems.Add(temp);

            temp = new MenuItem("AES");
            temp.Click += new EventHandler(cipherOverride_Click);
            temp.Tag = 2;
            if (current == 2) { temp.Checked = true; }
            next.MenuItems.Add(temp);

            temp = new MenuItem("Null");
            temp.Click += new EventHandler(cipherOverride_Click);
            temp.Tag = 3;
            if (current == 3) { temp.Checked = true; }
            next.MenuItems.Add(temp);
#endif

            next = new MenuItem("Show Stress Form");
            next.Click += new EventHandler(showStressForm_Click);
            menu.MenuItems.Add(next);

            next = new MenuItem("Edit Properties");
            next.Click += new EventHandler(editProperties_Click);
            menu.MenuItems.Add(next);

            next = new MenuItem("Quick Connect");
            next.Click += new EventHandler(quickConnect_Click);
            menu.MenuItems.Add(next);

            return menu;
        }

        #region IPluginSetup Members

        /// <summary>
        /// Initializes the plugin based on input XML.
        /// </summary>
        /// <remarks>
        /// The layout of the XML is:
        /// - propertiespage element
        ///     - property element :: name attribute, value attribute
        /// </remarks>
        public void Initialize (XmlNode pluginSettings, string[] commandlineParameters)
        {
            XmlNode props_page = pluginSettings.SelectSingleNode("propertiespage");

            if (props_page != null)
            {
                XmlNodeList props = props_page.SelectNodes("property");

                foreach (XmlNode property in props)
                {
                    XmlAttribute name = property.Attributes["name"];
                    XmlAttribute val = property.Attributes["value"];

                    if (name != null && val != null)
                    {
                        AddOrSetProperty(name.Value, val.Value);
                    }
                }
            }

            // force the stress form to update
            TestBase_Stress.SgForm.ReadPluginProperties();
        }

        public void Shutdown (System.Xml.XmlNode pluginSettings)
        {
            if (CipherOverrideUsed)
            {
                Npdb npdb = new Npdb();

                try
                {
                    npdb.ConnectToServer();

                    // we want to delete it, its somewhat hacky...
                    DeleteCipherOverride(npdb);

                    ServerTestFramework.LiveService.Auth.SgServerInfo.ReloadConfiguration(10000, false);
                }
                finally
                {
                    npdb.Close();
                }
            }
        }

        #endregion

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion

        #region Event Handlers

        void cipherOverride_Click (object sender, EventArgs e)
        {
            try
            {
                MenuItem menu = (MenuItem)sender;

                // set override value
                CurrentCipherOverride = (int)menu.Tag;

                // make check be correct
                MenuItem parent = (MenuItem)menu.Parent;

                foreach (MenuItem m in parent.MenuItems)
                {
                    m.Checked = false;
                }

                menu.Checked = true;
            }
            catch (Exception exc)
            {
                Global.RO.Error("An error occured when trying to set the cipher override:\n" + 
                    exc.ToString());
            }
        }

        void showStressForm_Click (object sender, EventArgs e)
        {
            if (TestBase_Stress.SgForm != null)
            {
                TestBase_Stress.SgForm.Show();
            }
        }

        void editProperties_Click (object sender, EventArgs e)
        {
            PropertiesPage props = PropertiesPageDialog;
            lock (_properties)
            {
                props.SetProperties(_properties);
            }
            DialogResult result = props.ShowDialog();

            if (result == DialogResult.OK)
            {
                PropertiesPage.Property[] changed = props.GetProperties();

                lock (_properties)
                {
                    foreach (PropertiesPage.Property p in changed)
                    {
                        if (p.Dirty)
                        {
                            _properties[p.Name] = p.Value;
                        }
                    }
                }
            }
        }

        void quickConnect_Click (object sender, EventArgs e)
        {
            QuickConnect qc = new QuickConnect();
            qc.Show();
        }

        #endregion

        #region Cipher Override Functions

        private bool CipherOverrideUsed = false;
        public const string CipherOverrideFilterName = "SG Cipher Override Filter: ";
        // 0: Cipher Override
        // 1: IP & 0xff
        // 2: (IP & 0xff00) >> 8
        // 3: (IP & 0xff0000) >> 16
        // 4: (IP & 0xff000000) >> 24
        public const string CipherOverrideFilter = @"
FilterDeclare(""" + CipherOverrideFilterName + @"{0}"")

function ApplyFilter ()
    local ip_in = {{}}
    ip_in[0], ip_in[1], ip_in[2], ip_in[3] = {1}, {2}, {3}, {4}

    local ip_spi = {{}}
    ip_spi[0], ip_spi[1], ip_spi[2], ip_spi[3] = Spi.GetClientIpAddr()

    if ip_spi[0] == ip_in[0] and ip_spi[1] == ip_in[1] and ip_spi[2] == ip_in[2] and ip_spi[3] == ip_in[3] then
        Filter.SetCipher({0})
    end
end
";

        public int CurrentCipherOverride
        {
            get
            {
                string select_filter = "select {0} from t_sg_scripts where vc_script_name like '" +
                    CipherOverrideFilterName + "%'";

                Npdb npdb = new Npdb();

                try
                {
                    npdb.ConnectToServer();
                }
                catch
                {
                    // assume default, no filter
                    return -1;
                }

                try
                {
                    // check for the filter
                    int count = (int)npdb.ExecuteScalar(String.Format(select_filter, "count(*)"));

                    if (count == 0)
                    {
                        // default, no filter
                        return -1;
                    }
                    else if (count > 1)
                    {
                        // bad, multiple filters!
                        throw new SgPluginException("Multiple cipher overrides are in the database, please investigate/fix.");
                    }

                    string name = (string)npdb.ExecuteScalar(String.Format(select_filter, "vc_script_name"));

                    // extract override setting
                    int ans;

                    if (!int.TryParse(name.Substring(CipherOverrideFilterName.Length), out ans))
                    {
                        // bad filter name
                        throw new SgPluginException("Bad cipher override is in the database, please investigate/fix.");
                    }

                    return ans;
                }
                finally
                {
                    npdb.Close();
                }
            }
            set
            {
                NpdbUtility npdb = new NpdbUtility();

                try
                {
                    npdb.ConnectToServer();

                    // just in case, delete
                    DeleteCipherOverride(npdb);

                    if (value == -1)
                    {
                        goto reload;
                    }

                    TestBase_Keyex test = new TestBase_Keyex();

                    try
                    {
                        test.Run();
                    }
                    catch (Exception e)
                    {
                        throw new SgPluginException("An error occured trying to determine the local IP to use in the override.", e);
                    }

                    uint ip = test.sg.KeyexResult.keyexResp.IPInit.S_addr;
                    string script = String.Format(CipherOverrideFilter, value,
                        ip & 0xff,
                        (ip & 0xff00) >> 8,
                        (ip & 0xff0000) >> 16,
                        (ip & 0xff000000) >> 24);

                    // set it before attempting to prop the script, simply used to determine whether we need to delete or not
                    CipherOverrideUsed = true;

                    npdb.PropSgScript(CipherOverrideFilterName + value.ToString(), script, null);

                    // have to reload the SGs
                reload:
                    ServerTestFramework.LiveService.Auth.SgServerInfo.ReloadChallenges();
                }
                finally
                {
                    npdb.Close();
                }
            }
        }

        private void DeleteCipherOverride (Npdb npdb)
        {
            string delete_filter = "delete from t_sg_scripts where vc_script_name like '" +
                CipherOverrideFilterName + "%'";
            npdb.IssueCommand(delete_filter);
        }

        #endregion

        private PropertiesPage _propertiesPage = null;

        private PropertiesPage PropertiesPageDialog
        {
            get
            {
                if (_propertiesPage == null)
                {
                    PropertiesPage props = new PropertiesPage();
                    if (System.Threading.Interlocked.CompareExchange(ref _propertiesPage, props, null) != null)
                    {
                        props.Dispose();
                    }
                }

                return _propertiesPage;
            }
        }

        private static Dictionary<string, string> _properties = new Dictionary<string, string>();

        public static void AddOrSetProperty (string key, string value)
        {
            lock (_properties)
            {
                if (_properties.ContainsKey(key))
                {
                    _properties[key] = value;
                }
                else
                {
                    _properties.Add(key, value);
                }
            }
        }

        public static string GetProperty (string key)
        {
            lock (_properties)
            {
                string ans;
                if (_properties.TryGetValue(key, out ans))
                {
                    return ans;
                }

                return null;
            }
        }
    }

    /// <summary>
    /// Contains useful information relating to the SG and the environment.
    /// </summary>
    public static class SgEnvironmentInfo
    {
        #region AesMinClientVersionXbox360

        // Backing for AesMinClientVersionXbox360
        private static string _AesMinClientVersionXbox360_string = null;
        private static uint _AesMinClientVersionXbox360 = 0;

        /// <summary>
        /// The value of the setting AesMinClientVersionXbox360 as seen by the client.
        /// </summary>
        public static string AesMinClientVersionXbox360String
        {
            get
            {
                if (_AesMinClientVersionXbox360_string == null)
                {
                    _AesMinClientVersionXbox360_string = 
                        Global.XEnv.GetSetting(Setting.sg_AesMinClientVersionXbox360);
                }

                return _AesMinClientVersionXbox360_string;
            }
        }

        /// <summary>
        /// The value of the setting AesMinClientVersionXbox360 as seen by the client.
        /// Parsed into a uint.
        /// </summary>
        public static uint AesMinClientVersionXbox360
        {
            get
            {
                // 0 as the real value would mean all clients were AES capable
                if (_AesMinClientVersionXbox360 == 0)
                {
                    string temp = AesMinClientVersionXbox360String;
                    if (temp != null && temp.Length > 2 &&
                        temp[0] == '0' && (temp[1] == 'x' || temp[1] == 'X'))
                    {
                        _AesMinClientVersionXbox360 = uint.Parse(temp.Substring(2, temp.Length - 2), 
                            System.Globalization.NumberStyles.AllowHexSpecifier);
                    }
                    else
                    {
                        _AesMinClientVersionXbox360 = uint.Parse(temp, System.Globalization.NumberStyles.None);
                    }
                }

                return _AesMinClientVersionXbox360;
            }
        }

        // Constants for converting a DWORD client version to multiple WORDs
        public const uint ClientVersion_MajorMask = 0xF0000000;
        public const uint ClientVersion_MinorMask = 0x0F000000;
        public const uint ClientVersion_BuildMask = 0x00FFFF00;
        public const uint ClientVersion_QFEMask = 0x000000FF;
        public const int ClientVersion_MajorShift = 28;
        public const int ClientVersion_MinorShift = 24;
        public const int ClientVersion_BuildShift = 8;
        public const int ClientVersion_QFEShift = 0;

        /// <summary>
        /// The major version of the AesMinClientVersionXbox360.
        /// </summary>
        public static ushort AesMinClientVersionXbox360_Major
        {
            get
            {
                return (ushort)((AesMinClientVersionXbox360 & ClientVersion_MajorMask) >> ClientVersion_MajorShift);
            }
        }

        /// <summary>
        /// The minor version of the AesMinClientVersionXbox360.
        /// </summary>
        public static ushort AesMinClientVersionXbox360_Minor
        {
            get
            {
                return (ushort)((AesMinClientVersionXbox360 & ClientVersion_MinorMask) >> ClientVersion_MinorShift);
            }
        }

        /// <summary>
        /// The build version of the AesMinClientVersionXbox360.
        /// </summary>
        public static ushort AesMinClientVersionXbox360_Build
        {
            get
            {
                return (ushort)((AesMinClientVersionXbox360 & ClientVersion_BuildMask) >> ClientVersion_BuildShift);
            }
        }

        /// <summary>
        /// The QFE version of the AesMinClientVersionXbox360.
        /// </summary>
        public static ushort AesMinClientVersionXbox360_QFE
        {
            get
            {
                return (ushort)((AesMinClientVersionXbox360 & ClientVersion_QFEMask) >> ClientVersion_QFEShift);
            }
        }

        /// <summary>
        /// Sets the client version in the given authdata to be either AES capable or not.
        /// </summary>
        /// <param name="authdata">The authdata to modify.</param>
        /// <param name="useAES">True to set it at AesMinClientVersionXbox360, false below.</param>
        public static void SetXbox360ClientVersion (Authdata_Base authdata, bool useAES)
        {
            authdata.MajorVersion = AesMinClientVersionXbox360_Major;
            authdata.MinorVersion = AesMinClientVersionXbox360_Minor;
            authdata.BuildNumber = AesMinClientVersionXbox360_Build;
            authdata.QFENumber = AesMinClientVersionXbox360_QFE;

            // we now have a minimum AES client version
            // if not using AES, we want to decrement it by 1 at least
            // start on the build as many tests use the QFE for overriding
            if (!useAES)
            {
                if (authdata.BuildNumber != 0)
                {
                    authdata.BuildNumber -= 1;
                    return;
                }

                if (authdata.MinorVersion != 0)
                {
                    authdata.MinorVersion -= 1;
                    return;
                }

                if (authdata.MajorVersion != 0)
                {
                    authdata.MajorVersion -= 1;
                    return;
                }

                // not much we can do here... I guess give QFE a shot too
                if (authdata.QFENumber != 0)
                {
                    authdata.QFENumber -= 1;
                    return;
                }

                // I guess we should tell the user they are getting AES
                throw new SgEnvironmentInfoException("Could not go below the minimum AES version as it is 0 (actual string value '" + 
                    (AesMinClientVersionXbox360String ?? "<null>") + "')");
            }
        }

        /// <summary>
        /// Converts a version from multiple ushorts to a single uint representation.
        /// </summary>
        /// <param name="major">The major version.</param>
        /// <param name="minor">The minor version.</param>
        /// <param name="build">The build version.</param>
        /// <param name="qfe">The qfe version.</param>
        /// <returns>A uint representation of the version.</returns>
        public static uint ConvertVersionToUint (ushort major, ushort minor, ushort build, ushort qfe)
        {
            return (uint)(
                ((major << ClientVersion_MajorShift) & ClientVersion_MajorMask) |
                ((minor << ClientVersion_MinorShift) & ClientVersion_MinorMask) |
                ((build << ClientVersion_BuildShift) & ClientVersion_BuildMask) |
                ((qfe   << ClientVersion_QFEShift  ) & ClientVersion_QFEMask  )
                );
        }

        /// <summary>
        /// Converts a version from multiple ushorts from the authdata to a single uint representation.
        /// </summary>
        /// <param name="authdata">The authdata that contains the version.</param>
        /// <returns>A uint representation of the version.</returns>
        public static uint ConvertVersionToUint (Authdata_Base authdata)
        {
            return ConvertVersionToUint(authdata.MajorVersion, authdata.MinorVersion, authdata.BuildNumber, authdata.QFENumber);
        }

        #endregion

        /// <summary>
        /// Returns true if the environment is an xblob; false if it is not.
        /// </summary>
        public static bool IsXblob
        {
            get { return (Config.Environment.ToLower() == "xblob"); }
        }

        // Backing for SgExecutableName
        private static string _SgExecutableName = null;

        /// <summary>
        /// Returns the expected executable name for the current environment.
        /// </summary>
        public static string SgExecutableName
        {
            get
            {
                if (_SgExecutableName != null)
                {
                    return _SgExecutableName;
                }

                if (IsXblob)
                {
                    _SgExecutableName = "sgonebox";
                }
                else
                {
                    _SgExecutableName = "sgsvc";
                }

                return _SgExecutableName;
            }
        }

        /// <summary>
        /// Forces a CommonConfig update check on all normal (non-NAT) SG servers.
        /// </summary>
        public static void ConfigCacheRefresh ()
        {
            SgServerInfo[] servers = SgServerInfo.Servers;

            foreach (SgServerInfo serv in servers)
            {
                string outparam;
                if (!ManagementConsole.Execute(serv.XmgmtIp, "e " + SgExecutableName + ":xblconfig configcacherefresh", out outparam))
                {
                    throw new SGException(outparam);
                }
            }
        }

        // saved settings to be returned via RestoreChallengeTiming
        private static SettingState _state_SgToXbScanFrequencyInSeconds = null;
        private static SettingState _state_ChallengePeriodInSeconds = null;
        private static SettingState _state_ChallengeAckInSeconds = null;
        private static SettingState _state_ChallengeTimeoutInSeconds = null;
        private static SettingState _state_ChalHeartbeatTimeoutInSeconds = null;

        /// <summary>
        /// Overrides the challenge timers, reducing the time required for asynchronous challenge tests.
        /// </summary>
        public static void ReduceChallengeTiming ()
        {
            // this shouldn't be called so frequently that we would have a race condition
            if (_state_SgToXbScanFrequencyInSeconds == null)
            {
                _state_SgToXbScanFrequencyInSeconds = Global.XEnv.OverrideSetting("ALL", "ALL", Setting.sg_SgToXbScanFrequencyInSeconds, "1");
                _state_ChallengePeriodInSeconds = Global.XEnv.OverrideSetting("ALL", "ALL", Setting.sg_SgToXbChallengePeriodInSeconds, "6");
                _state_ChallengeAckInSeconds = Global.XEnv.OverrideSetting("ALL", "ALL", Setting.sg_XbToSgChallengeAckInSeconds, "4");
                _state_ChallengeTimeoutInSeconds = Global.XEnv.OverrideSetting("ALL", "ALL", Setting.sg_XbToSgChallengeTimeoutInSeconds, "5");
                _state_ChalHeartbeatTimeoutInSeconds = Global.XEnv.OverrideSetting("ALL", "ALL", Setting.sg_ChalHeartbeatTimeoutInSeconds, "2");
                ConfigCacheRefresh();

                // also force the local config system to drop its cache
                // this allows us to use normal config operations to get at the values we just changed
                Config.DiscardCachedValues();
            }
        }

        /// <summary>
        /// Returns the challenge timers to the previous state.
        /// </summary>
        public static void RestoreChallengeTiming ()
        {
            if (_state_SgToXbScanFrequencyInSeconds != null)
            {
                Global.XEnv.RestoreOverrideSettingState(_state_SgToXbScanFrequencyInSeconds);
                _state_SgToXbScanFrequencyInSeconds = null;
                Global.XEnv.RestoreOverrideSettingState(_state_ChallengePeriodInSeconds);
                _state_ChallengePeriodInSeconds = null;
                Global.XEnv.RestoreOverrideSettingState(_state_ChallengeAckInSeconds);
                _state_ChallengeAckInSeconds = null;
                Global.XEnv.RestoreOverrideSettingState(_state_ChallengeTimeoutInSeconds);
                _state_ChallengeTimeoutInSeconds = null;
                Global.XEnv.RestoreOverrideSettingState(_state_ChalHeartbeatTimeoutInSeconds);
                _state_ChalHeartbeatTimeoutInSeconds = null;
                ConfigCacheRefresh();

                // also force the local config system to drop its cache
                Config.DiscardCachedValues();
            }
        }

        /// <summary>
        /// Get the virtual interface information for the virtual interfaces that are mapped through the SG.
        /// </summary>
        /// <returns>A list of the virtual interfaces that are mapped through the SG.</returns>
        public static IEnumerable<IVirtualInterfaceInfo> GetSgVirtualInterfaceInfo ()
        {
            IVirtualInterfaceInfo[] all = Config.GetVirtualInterfaceInfoBySite(Site.main);
            List<IVirtualInterfaceInfo> ans = new List<IVirtualInterfaceInfo>();

            foreach (IVirtualInterfaceInfo vii in all)
            {
                if (vii.InternetPort != 0)
                {
                    ans.Add(vii);
                }
            }

            ans.Sort(delegate(IVirtualInterfaceInfo a, IVirtualInterfaceInfo b) { return a.ServiceId.CompareTo(b.ServiceId); });

            return ans;
        }
    }

    /// <summary>
    /// An exception generated by the SgEnvironmentInfo class.
    /// </summary>
    public class SgEnvironmentInfoException : Exception
    {
        public SgEnvironmentInfoException (string message) : base(message) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\QuickConnect.Designer.cs ===
namespace XSGTest
{
    partial class QuickConnect
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose (bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            this.lblMachinePuid = new System.Windows.Forms.Label();
            this.tbcInput = new System.Windows.Forms.TabControl();
            this.tbpCommon = new System.Windows.Forms.TabPage();
            this.txtMachinePuid = new System.Windows.Forms.TextBox();
            this.btnConnect = new System.Windows.Forms.Button();
            this.lblCipher = new System.Windows.Forms.Label();
            this.tbcInput.SuspendLayout();
            this.tbpCommon.SuspendLayout();
            this.SuspendLayout();
            // 
            // lblMachinePuid
            // 
            this.lblMachinePuid.AutoSize = true;
            this.lblMachinePuid.Location = new System.Drawing.Point(6, 13);
            this.lblMachinePuid.Name = "lblMachinePuid";
            this.lblMachinePuid.Size = new System.Drawing.Size(77, 13);
            this.lblMachinePuid.TabIndex = 0;
            this.lblMachinePuid.Text = "Machine PUID";
            // 
            // tbcInput
            // 
            this.tbcInput.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)));
            this.tbcInput.Controls.Add(this.tbpCommon);
            this.tbcInput.Location = new System.Drawing.Point(10, 10);
            this.tbcInput.Margin = new System.Windows.Forms.Padding(1);
            this.tbcInput.Name = "tbcInput";
            this.tbcInput.SelectedIndex = 0;
            this.tbcInput.Size = new System.Drawing.Size(239, 355);
            this.tbcInput.TabIndex = 1;
            // 
            // tbpCommon
            // 
            this.tbpCommon.Controls.Add(this.txtMachinePuid);
            this.tbpCommon.Controls.Add(this.lblMachinePuid);
            this.tbpCommon.Location = new System.Drawing.Point(4, 22);
            this.tbpCommon.Name = "tbpCommon";
            this.tbpCommon.Padding = new System.Windows.Forms.Padding(3);
            this.tbpCommon.Size = new System.Drawing.Size(231, 329);
            this.tbpCommon.TabIndex = 0;
            this.tbpCommon.Text = "Common";
            this.tbpCommon.UseVisualStyleBackColor = true;
            // 
            // txtMachinePuid
            // 
            this.txtMachinePuid.Location = new System.Drawing.Point(89, 10);
            this.txtMachinePuid.Name = "txtMachinePuid";
            this.txtMachinePuid.Size = new System.Drawing.Size(125, 20);
            this.txtMachinePuid.TabIndex = 1;
            // 
            // btnConnect
            // 
            this.btnConnect.Location = new System.Drawing.Point(170, 369);
            this.btnConnect.Name = "btnConnect";
            this.btnConnect.Size = new System.Drawing.Size(75, 23);
            this.btnConnect.TabIndex = 2;
            this.btnConnect.Text = "Connect";
            this.btnConnect.UseVisualStyleBackColor = true;
            this.btnConnect.Click += new System.EventHandler(this.btnConnect_Click);
            // 
            // lblCipher
            // 
            this.lblCipher.AutoSize = true;
            this.lblCipher.Location = new System.Drawing.Point(295, 45);
            this.lblCipher.Name = "lblCipher";
            this.lblCipher.Size = new System.Drawing.Size(43, 13);
            this.lblCipher.TabIndex = 3;
            this.lblCipher.Text = "<none>";
            // 
            // QuickConnect
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(449, 404);
            this.Controls.Add(this.lblCipher);
            this.Controls.Add(this.btnConnect);
            this.Controls.Add(this.tbcInput);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.MaximizeBox = false;
            this.Name = "QuickConnect";
            this.Text = "Quick Connect";
            this.tbcInput.ResumeLayout(false);
            this.tbpCommon.ResumeLayout(false);
            this.tbpCommon.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblMachinePuid;
        private System.Windows.Forms.TabControl tbcInput;
        private System.Windows.Forms.TabPage tbpCommon;
        private System.Windows.Forms.TextBox txtMachinePuid;
        private System.Windows.Forms.Button btnConnect;
        private System.Windows.Forms.Label lblCipher;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\StressLua.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

//NOTE: For lua stress to work, you must place the challenges (./SgTest/LuaStress*.lua) onto the sg and reload_config it.
//The login challenge challenges nothing, just spins some lua wheels on target.
//The async challenge targets everyone, but only kicks if the qfe number is 0x2079

namespace XSGTest
{
    //Special case
    [StressTest(Priority=0)]
    class LuaAsyncKickme: TestBase_AsyncLua
    {
        protected override void PreloginSetup (Authdata_Base authData)
        {
            SetSGQosResponseTime(5000);
            SetSGChallengeTime(45000); //45s max wait, as stress times a thread out after 2 min

            authData.QFENumber = 0x2079;
        }

        protected override void HandleChallenge(SecMsgSgToXbChal chal, ref bool waitForAnotherChallenge)
        {
            if (chal==null)
            {
                Fail("did NOT get challenged when we should have.");
                return;
            }

            //send response and check that we get kicked
            if (chal!=null)
            {
                byte []resp=new byte[1024];
                SendChallengeResponse(resp);

                //see if we're still connected
                bool isConn=WaitAndCheckConnected(45);
                if (isConn)
                {
                    Fail("did NOT get kicked and we should have");
                }
            }
        }
    }

    //reload config on SG.  both async and login challenge tests are verifying their spi store during this (related to Xenon bug 72066)
    [StressTest(Priority = 0)]
    class ReloadConfig : TestBase_Lua
    {
        protected override void RunLuaTest ()
        {
            SgServerInfo.ReloadConfiguration(10000, false);
        }
    }

    //reload config on SG.  both async and login challenge tests are verifying their spi store during this (related to Xenon bug 72066)
    [StressTest(Priority = 0)]
    class ReloadChallenges : TestBase_Lua
    {
        protected override void RunLuaTest ()
        {
            SgServerInfo.ReloadChallenges();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\TestBase_Lsp.cs ===
using System;
using System.Net;
using System.Management;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;


namespace XSGTest
{
    
    /// <summary>
    /// Useful base functions for LSPSG tests
    /// </summary>
    abstract class TestBase_Lsp : TestBase_SgFake
    {
        static new protected Report            ro           = new Report("Lsp");

        protected LspClient lsp
        {
            get { return (sg == null ? null : (sg as LspClient)); }
            set { lsp = value; }
        }

        protected SiteInfo site
        {
            get { return lsp.Context.Site; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\SgStressForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;

namespace XSGTest
{
    /// <summary>
    /// Summary description for SgStressForm.
    /// </summary>
    public class SgStressForm : System.Windows.Forms.Form
    {

        #region Windows Form Designer generated code


        private System.Windows.Forms.NumericUpDown TargetClients;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Timer UpdateTimer;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox AvailableClients;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.TextBox DeletedClients;
        private System.Windows.Forms.Label label8;
        private System.Windows.Forms.TextBox RecvPerSec;
        private System.Windows.Forms.Label label9;
        private System.Windows.Forms.NumericUpDown SocketPool;
        private System.Windows.Forms.TextBox SignedInClients;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox AvailableLockfails;
        private System.Windows.Forms.TextBox SignedInLockfails;
        private System.Windows.Forms.Label label10;
        private System.Windows.Forms.TextBox TotalLockDifference;
        private System.Windows.Forms.Label label21;
        private System.Windows.Forms.TextBox ReflectRtt;
        private System.Windows.Forms.Label label22;
        private System.Windows.Forms.TextBox SequenceGaps;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.TextBox SpiHashSize;
        private System.Windows.Forms.NumericUpDown NoChalResp;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.Label label11;
        private System.Windows.Forms.NumericUpDown NoChalAck;
        private System.Windows.Forms.Label label12;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.TextBox SgDataPulse;
        private System.Windows.Forms.Label label13;
        private System.Windows.Forms.Label label14;
        private System.Windows.Forms.Label label15;
        private System.Windows.Forms.TextBox SgDelete;
        private System.Windows.Forms.TextBox SgQos;
        private System.Windows.Forms.TextBox SgNatReply;
        private System.Windows.Forms.TextBox SgChallenge;
        private System.Windows.Forms.Label label16;
        private System.Windows.Forms.TextBox SgRespAck;
        private System.Windows.Forms.Label label17;
        private System.Windows.Forms.NumericUpDown ChalRespTimeDelay;
        private System.Windows.Forms.Label label18;
        private System.Windows.Forms.TextBox SgXbtoXbForward;
        private System.Windows.Forms.Label label19;
        private System.Windows.Forms.TextBox DataReflect;
        private System.Windows.Forms.Label label20;
        private MenuStrip menuStrip1;
        private ToolStripMenuItem optionsToolStripMenuItem;
        private ToolStripMenuItem serviceIDsToolStripMenuItem;
        private ToolStripMenuItem resetToolStripMenuItem;
        private ToolStripMenuItem serviceIDTSMI334;
        private ToolStripMenuItem selectClientTSMI;
        private ToolStripMenuItem selectPoolTSMI;
        private ToolStripSeparator toolStripSeparator2;
        private ToolStripMenuItem toolStripMenuItem3;
        private ToolStripSeparator toolStripSeparator1;
        private ToolStripMenuItem toolStripMenuItem4;
        private ToolStripMenuItem toolStripMenuItem5;
        private ToolStripMenuItem toolStripMenuItem6;
        private ToolStripMenuItem toolStripMenuItem7;
        private ToolStripMenuItem toolStripMenuItem8;
        private ToolStripMenuItem toolStripMenuItem9;
        private ToolStripMenuItem toolStripMenuItem10;
        private ToolStripMenuItem toolStripMenuItem11;
        private ToolStripMenuItem toolStripMenuItem12;
        private ToolStripMenuItem toolStripMenuItem13;
        private ToolStripSeparator toolStripSeparator3;
        private ToolStripMenuItem toolStripMenuItem2;
        private ToolStripMenuItem toolStripMenuItem1;
        private ToolStripSeparator toolStripSeparator4;
        private System.ComponentModel.IContainer components;


        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }
        
        
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.TargetClients = new System.Windows.Forms.NumericUpDown();
            this.label1 = new System.Windows.Forms.Label();
            this.UpdateTimer = new System.Windows.Forms.Timer(this.components);
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.SpiHashSize = new System.Windows.Forms.TextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.TotalLockDifference = new System.Windows.Forms.TextBox();
            this.label10 = new System.Windows.Forms.Label();
            this.SignedInLockfails = new System.Windows.Forms.TextBox();
            this.AvailableLockfails = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.DeletedClients = new System.Windows.Forms.TextBox();
            this.label7 = new System.Windows.Forms.Label();
            this.SignedInClients = new System.Windows.Forms.TextBox();
            this.label6 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.AvailableClients = new System.Windows.Forms.TextBox();
            this.ReflectRtt = new System.Windows.Forms.TextBox();
            this.label21 = new System.Windows.Forms.Label();
            this.SequenceGaps = new System.Windows.Forms.TextBox();
            this.label22 = new System.Windows.Forms.Label();
            this.label8 = new System.Windows.Forms.Label();
            this.RecvPerSec = new System.Windows.Forms.TextBox();
            this.label9 = new System.Windows.Forms.Label();
            this.SocketPool = new System.Windows.Forms.NumericUpDown();
            this.NoChalResp = new System.Windows.Forms.NumericUpDown();
            this.label5 = new System.Windows.Forms.Label();
            this.label11 = new System.Windows.Forms.Label();
            this.NoChalAck = new System.Windows.Forms.NumericUpDown();
            this.label12 = new System.Windows.Forms.Label();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.DataReflect = new System.Windows.Forms.TextBox();
            this.label20 = new System.Windows.Forms.Label();
            this.SgXbtoXbForward = new System.Windows.Forms.TextBox();
            this.label19 = new System.Windows.Forms.Label();
            this.SgRespAck = new System.Windows.Forms.TextBox();
            this.label17 = new System.Windows.Forms.Label();
            this.SgChallenge = new System.Windows.Forms.TextBox();
            this.label16 = new System.Windows.Forms.Label();
            this.SgNatReply = new System.Windows.Forms.TextBox();
            this.label15 = new System.Windows.Forms.Label();
            this.SgQos = new System.Windows.Forms.TextBox();
            this.label14 = new System.Windows.Forms.Label();
            this.SgDelete = new System.Windows.Forms.TextBox();
            this.label13 = new System.Windows.Forms.Label();
            this.SgDataPulse = new System.Windows.Forms.TextBox();
            this.ChalRespTimeDelay = new System.Windows.Forms.NumericUpDown();
            this.label18 = new System.Windows.Forms.Label();
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.serviceIDsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.selectClientTSMI = new System.Windows.Forms.ToolStripMenuItem();
            this.selectPoolTSMI = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
            this.serviceIDTSMI334 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem3 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.toolStripMenuItem4 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem5 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem6 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem7 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem8 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem9 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem10 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem11 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem12 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem13 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
            this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripMenuItem();
            this.resetToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator4 = new System.Windows.Forms.ToolStripSeparator();
            this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripMenuItem();
            ((System.ComponentModel.ISupportInitialize)(this.TargetClients)).BeginInit();
            this.groupBox1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.SocketPool)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NoChalResp)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.NoChalAck)).BeginInit();
            this.groupBox2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.ChalRespTimeDelay)).BeginInit();
            this.menuStrip1.SuspendLayout();
            this.SuspendLayout();
            // 
            // TargetClients
            // 
            this.TargetClients.Increment = new decimal(new int[] {
            100,
            0,
            0,
            0});
            this.TargetClients.Location = new System.Drawing.Point(16, 52);
            this.TargetClients.Maximum = new decimal(new int[] {
            500000,
            0,
            0,
            0});
            this.TargetClients.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.TargetClients.Name = "TargetClients";
            this.TargetClients.Size = new System.Drawing.Size(72, 20);
            this.TargetClients.TabIndex = 0;
            this.TargetClients.Value = new decimal(new int[] {
            10000,
            0,
            0,
            0});
            this.TargetClients.ValueChanged += new System.EventHandler(this.TargetClients_ValueChanged);
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(8, 36);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(96, 16);
            this.label1.TabIndex = 1;
            this.label1.Text = "Target clients:";
            // 
            // UpdateTimer
            // 
            this.UpdateTimer.Interval = 200;
            this.UpdateTimer.Tick += new System.EventHandler(this.UpdateTimer_Tick);
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.SpiHashSize);
            this.groupBox1.Controls.Add(this.label4);
            this.groupBox1.Controls.Add(this.TotalLockDifference);
            this.groupBox1.Controls.Add(this.label10);
            this.groupBox1.Controls.Add(this.SignedInLockfails);
            this.groupBox1.Controls.Add(this.AvailableLockfails);
            this.groupBox1.Controls.Add(this.label3);
            this.groupBox1.Controls.Add(this.DeletedClients);
            this.groupBox1.Controls.Add(this.label7);
            this.groupBox1.Controls.Add(this.SignedInClients);
            this.groupBox1.Controls.Add(this.label6);
            this.groupBox1.Controls.Add(this.label2);
            this.groupBox1.Controls.Add(this.AvailableClients);
            this.groupBox1.Controls.Add(this.ReflectRtt);
            this.groupBox1.Controls.Add(this.label21);
            this.groupBox1.Controls.Add(this.SequenceGaps);
            this.groupBox1.Controls.Add(this.label22);
            this.groupBox1.Location = new System.Drawing.Point(128, 36);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(168, 252);
            this.groupBox1.TabIndex = 8;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Status";
            // 
            // SpiHashSize
            // 
            this.SpiHashSize.Location = new System.Drawing.Point(88, 172);
            this.SpiHashSize.Name = "SpiHashSize";
            this.SpiHashSize.ReadOnly = true;
            this.SpiHashSize.Size = new System.Drawing.Size(72, 20);
            this.SpiHashSize.TabIndex = 25;
            this.SpiHashSize.Text = "0";
            // 
            // label4
            // 
            this.label4.Location = new System.Drawing.Point(8, 172);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(80, 16);
            this.label4.TabIndex = 24;
            this.label4.Text = "SPI Hash size";
            // 
            // TotalLockDifference
            // 
            this.TotalLockDifference.Location = new System.Drawing.Point(88, 148);
            this.TotalLockDifference.Name = "TotalLockDifference";
            this.TotalLockDifference.ReadOnly = true;
            this.TotalLockDifference.Size = new System.Drawing.Size(72, 20);
            this.TotalLockDifference.TabIndex = 23;
            this.TotalLockDifference.Text = "0";
            // 
            // label10
            // 
            this.label10.Location = new System.Drawing.Point(8, 148);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(64, 16);
            this.label10.TabIndex = 22;
            this.label10.Text = "Locks held:";
            // 
            // SignedInLockfails
            // 
            this.SignedInLockfails.Location = new System.Drawing.Point(88, 72);
            this.SignedInLockfails.Name = "SignedInLockfails";
            this.SignedInLockfails.ReadOnly = true;
            this.SignedInLockfails.Size = new System.Drawing.Size(72, 20);
            this.SignedInLockfails.TabIndex = 17;
            this.SignedInLockfails.Text = "0";
            // 
            // AvailableLockfails
            // 
            this.AvailableLockfails.Location = new System.Drawing.Point(88, 32);
            this.AvailableLockfails.Name = "AvailableLockfails";
            this.AvailableLockfails.ReadOnly = true;
            this.AvailableLockfails.Size = new System.Drawing.Size(72, 20);
            this.AvailableLockfails.TabIndex = 16;
            this.AvailableLockfails.Text = "0";
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(88, 16);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(72, 16);
            this.label3.TabIndex = 15;
            this.label3.Text = "Lock failures:";
            // 
            // DeletedClients
            // 
            this.DeletedClients.Location = new System.Drawing.Point(16, 112);
            this.DeletedClients.Name = "DeletedClients";
            this.DeletedClients.ReadOnly = true;
            this.DeletedClients.Size = new System.Drawing.Size(64, 20);
            this.DeletedClients.TabIndex = 9;
            this.DeletedClients.TabStop = false;
            this.DeletedClients.Text = "0";
            // 
            // label7
            // 
            this.label7.Location = new System.Drawing.Point(8, 96);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(80, 16);
            this.label7.TabIndex = 14;
            this.label7.Text = "Deleted clients:";
            // 
            // SignedInClients
            // 
            this.SignedInClients.Location = new System.Drawing.Point(16, 72);
            this.SignedInClients.Name = "SignedInClients";
            this.SignedInClients.ReadOnly = true;
            this.SignedInClients.Size = new System.Drawing.Size(64, 20);
            this.SignedInClients.TabIndex = 8;
            this.SignedInClients.TabStop = false;
            this.SignedInClients.Text = "0";
            // 
            // label6
            // 
            this.label6.Location = new System.Drawing.Point(8, 56);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(72, 16);
            this.label6.TabIndex = 12;
            this.label6.Text = "Signed in clients:";
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(8, 16);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(80, 16);
            this.label2.TabIndex = 7;
            this.label2.Text = "Available clients:";
            // 
            // AvailableClients
            // 
            this.AvailableClients.Location = new System.Drawing.Point(16, 32);
            this.AvailableClients.Name = "AvailableClients";
            this.AvailableClients.ReadOnly = true;
            this.AvailableClients.Size = new System.Drawing.Size(64, 20);
            this.AvailableClients.TabIndex = 6;
            this.AvailableClients.TabStop = false;
            this.AvailableClients.Text = "0";
            // 
            // ReflectRtt
            // 
            this.ReflectRtt.Location = new System.Drawing.Point(88, 196);
            this.ReflectRtt.Name = "ReflectRtt";
            this.ReflectRtt.ReadOnly = true;
            this.ReflectRtt.Size = new System.Drawing.Size(72, 20);
            this.ReflectRtt.TabIndex = 25;
            this.ReflectRtt.Text = "0";
            // 
            // label21
            // 
            this.label21.Location = new System.Drawing.Point(8, 196);
            this.label21.Name = "label21";
            this.label21.Size = new System.Drawing.Size(80, 16);
            this.label21.TabIndex = 24;
            this.label21.Text = "Reflect RTT";
            // 
            // SequenceGaps
            // 
            this.SequenceGaps.Location = new System.Drawing.Point(88, 220);
            this.SequenceGaps.Name = "SequenceGaps";
            this.SequenceGaps.ReadOnly = true;
            this.SequenceGaps.Size = new System.Drawing.Size(72, 20);
            this.SequenceGaps.TabIndex = 25;
            this.SequenceGaps.Text = "0";
            // 
            // label22
            // 
            this.label22.Location = new System.Drawing.Point(8, 220);
            this.label22.Name = "label22";
            this.label22.Size = new System.Drawing.Size(80, 16);
            this.label22.TabIndex = 24;
            this.label22.Text = "Seq gaps";
            // 
            // label8
            // 
            this.label8.Location = new System.Drawing.Point(8, 236);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(112, 16);
            this.label8.TabIndex = 17;
            this.label8.Text = "Suggested recv/sec:";
            // 
            // RecvPerSec
            // 
            this.RecvPerSec.Location = new System.Drawing.Point(16, 252);
            this.RecvPerSec.Name = "RecvPerSec";
            this.RecvPerSec.ReadOnly = true;
            this.RecvPerSec.Size = new System.Drawing.Size(72, 20);
            this.RecvPerSec.TabIndex = 4;
            this.RecvPerSec.TabStop = false;
            this.RecvPerSec.Text = "0";
            // 
            // label9
            // 
            this.label9.Location = new System.Drawing.Point(8, 76);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(100, 16);
            this.label9.TabIndex = 19;
            this.label9.Text = "Socket pool:";
            // 
            // SocketPool
            // 
            this.SocketPool.Location = new System.Drawing.Point(16, 92);
            this.SocketPool.Maximum = new decimal(new int[] {
            64000,
            0,
            0,
            0});
            this.SocketPool.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.SocketPool.Name = "SocketPool";
            this.SocketPool.Size = new System.Drawing.Size(72, 20);
            this.SocketPool.TabIndex = 2;
            this.SocketPool.Value = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            // 
            // NoChalResp
            // 
            this.NoChalResp.Location = new System.Drawing.Point(16, 172);
            this.NoChalResp.Name = "NoChalResp";
            this.NoChalResp.Size = new System.Drawing.Size(72, 20);
            this.NoChalResp.TabIndex = 22;
            // 
            // label5
            // 
            this.label5.Location = new System.Drawing.Point(8, 156);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(100, 16);
            this.label5.TabIndex = 23;
            this.label5.Text = "% No Chal Resp";
            // 
            // label11
            // 
            this.label11.Location = new System.Drawing.Point(8, 116);
            this.label11.Name = "label11";
            this.label11.Size = new System.Drawing.Size(96, 16);
            this.label11.TabIndex = 21;
            this.label11.Text = "% No Chal Ack";
            // 
            // NoChalAck
            // 
            this.NoChalAck.Location = new System.Drawing.Point(16, 132);
            this.NoChalAck.Name = "NoChalAck";
            this.NoChalAck.Size = new System.Drawing.Size(72, 20);
            this.NoChalAck.TabIndex = 20;
            // 
            // label12
            // 
            this.label12.Location = new System.Drawing.Point(8, 40);
            this.label12.Name = "label12";
            this.label12.Size = new System.Drawing.Size(72, 16);
            this.label12.TabIndex = 26;
            this.label12.Text = "Datapulse";
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.DataReflect);
            this.groupBox2.Controls.Add(this.label20);
            this.groupBox2.Controls.Add(this.SgXbtoXbForward);
            this.groupBox2.Controls.Add(this.label19);
            this.groupBox2.Controls.Add(this.SgRespAck);
            this.groupBox2.Controls.Add(this.label17);
            this.groupBox2.Controls.Add(this.SgChallenge);
            this.groupBox2.Controls.Add(this.label16);
            this.groupBox2.Controls.Add(this.SgNatReply);
            this.groupBox2.Controls.Add(this.label15);
            this.groupBox2.Controls.Add(this.SgQos);
            this.groupBox2.Controls.Add(this.label14);
            this.groupBox2.Controls.Add(this.SgDelete);
            this.groupBox2.Controls.Add(this.label13);
            this.groupBox2.Controls.Add(this.SgDataPulse);
            this.groupBox2.Controls.Add(this.label12);
            this.groupBox2.Location = new System.Drawing.Point(16, 292);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(280, 120);
            this.groupBox2.TabIndex = 27;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Packets from SG per sec";
            // 
            // DataReflect
            // 
            this.DataReflect.Location = new System.Drawing.Point(216, 88);
            this.DataReflect.Name = "DataReflect";
            this.DataReflect.ReadOnly = true;
            this.DataReflect.Size = new System.Drawing.Size(48, 20);
            this.DataReflect.TabIndex = 41;
            this.DataReflect.Text = "0";
            // 
            // label20
            // 
            this.label20.Location = new System.Drawing.Point(144, 88);
            this.label20.Name = "label20";
            this.label20.Size = new System.Drawing.Size(64, 16);
            this.label20.TabIndex = 40;
            this.label20.Text = "Data reflect";
            // 
            // SgXbtoXbForward
            // 
            this.SgXbtoXbForward.Location = new System.Drawing.Point(88, 88);
            this.SgXbtoXbForward.Name = "SgXbtoXbForward";
            this.SgXbtoXbForward.ReadOnly = true;
            this.SgXbtoXbForward.Size = new System.Drawing.Size(48, 20);
            this.SgXbtoXbForward.TabIndex = 39;
            this.SgXbtoXbForward.Text = "0";
            // 
            // label19
            // 
            this.label19.Location = new System.Drawing.Point(8, 88);
            this.label19.Name = "label19";
            this.label19.Size = new System.Drawing.Size(72, 16);
            this.label19.TabIndex = 38;
            this.label19.Text = "XbToXbFwd";
            // 
            // SgRespAck
            // 
            this.SgRespAck.Location = new System.Drawing.Point(216, 64);
            this.SgRespAck.Name = "SgRespAck";
            this.SgRespAck.ReadOnly = true;
            this.SgRespAck.Size = new System.Drawing.Size(48, 20);
            this.SgRespAck.TabIndex = 37;
            this.SgRespAck.Text = "0";
            // 
            // label17
            // 
            this.label17.Location = new System.Drawing.Point(144, 64);
            this.label17.Name = "label17";
            this.label17.Size = new System.Drawing.Size(64, 16);
            this.label17.TabIndex = 36;
            this.label17.Text = "RespAck";
            // 
            // SgChallenge
            // 
            this.SgChallenge.Location = new System.Drawing.Point(216, 40);
            this.SgChallenge.Name = "SgChallenge";
            this.SgChallenge.ReadOnly = true;
            this.SgChallenge.Size = new System.Drawing.Size(48, 20);
            this.SgChallenge.TabIndex = 35;
            this.SgChallenge.Text = "0";
            // 
            // label16
            // 
            this.label16.Location = new System.Drawing.Point(144, 40);
            this.label16.Name = "label16";
            this.label16.Size = new System.Drawing.Size(64, 16);
            this.label16.TabIndex = 34;
            this.label16.Text = "Challenge";
            // 
            // SgNatReply
            // 
            this.SgNatReply.Location = new System.Drawing.Point(216, 16);
            this.SgNatReply.Name = "SgNatReply";
            this.SgNatReply.ReadOnly = true;
            this.SgNatReply.Size = new System.Drawing.Size(48, 20);
            this.SgNatReply.TabIndex = 33;
            this.SgNatReply.Text = "0";
            // 
            // label15
            // 
            this.label15.Location = new System.Drawing.Point(144, 16);
            this.label15.Name = "label15";
            this.label15.Size = new System.Drawing.Size(64, 16);
            this.label15.TabIndex = 32;
            this.label15.Text = "NAT Reply";
            // 
            // SgQos
            // 
            this.SgQos.Location = new System.Drawing.Point(88, 64);
            this.SgQos.Name = "SgQos";
            this.SgQos.ReadOnly = true;
            this.SgQos.Size = new System.Drawing.Size(48, 20);
            this.SgQos.TabIndex = 31;
            this.SgQos.Text = "0";
            // 
            // label14
            // 
            this.label14.Location = new System.Drawing.Point(8, 64);
            this.label14.Name = "label14";
            this.label14.Size = new System.Drawing.Size(72, 16);
            this.label14.TabIndex = 30;
            this.label14.Text = "QOS";
            // 
            // SgDelete
            // 
            this.SgDelete.Location = new System.Drawing.Point(88, 16);
            this.SgDelete.Name = "SgDelete";
            this.SgDelete.ReadOnly = true;
            this.SgDelete.Size = new System.Drawing.Size(48, 20);
            this.SgDelete.TabIndex = 29;
            this.SgDelete.Text = "0";
            // 
            // label13
            // 
            this.label13.Location = new System.Drawing.Point(8, 16);
            this.label13.Name = "label13";
            this.label13.Size = new System.Drawing.Size(72, 16);
            this.label13.TabIndex = 28;
            this.label13.Text = "Delete";
            // 
            // SgDataPulse
            // 
            this.SgDataPulse.Location = new System.Drawing.Point(88, 40);
            this.SgDataPulse.Name = "SgDataPulse";
            this.SgDataPulse.ReadOnly = true;
            this.SgDataPulse.Size = new System.Drawing.Size(48, 20);
            this.SgDataPulse.TabIndex = 27;
            this.SgDataPulse.Text = "0";
            // 
            // ChalRespTimeDelay
            // 
            this.ChalRespTimeDelay.Location = new System.Drawing.Point(16, 212);
            this.ChalRespTimeDelay.Maximum = new decimal(new int[] {
            600,
            0,
            0,
            0});
            this.ChalRespTimeDelay.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.ChalRespTimeDelay.Name = "ChalRespTimeDelay";
            this.ChalRespTimeDelay.Size = new System.Drawing.Size(72, 20);
            this.ChalRespTimeDelay.TabIndex = 28;
            this.ChalRespTimeDelay.Value = new decimal(new int[] {
            1,
            0,
            0,
            0});
            // 
            // label18
            // 
            this.label18.Location = new System.Drawing.Point(8, 196);
            this.label18.Name = "label18";
            this.label18.Size = new System.Drawing.Size(120, 16);
            this.label18.TabIndex = 29;
            this.label18.Text = "Max Resp Time Delay";
            // 
            // menuStrip1
            // 
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.optionsToolStripMenuItem});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(308, 24);
            this.menuStrip1.TabIndex = 30;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // optionsToolStripMenuItem
            // 
            this.optionsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.serviceIDsToolStripMenuItem,
            this.resetToolStripMenuItem});
            this.optionsToolStripMenuItem.Name = "optionsToolStripMenuItem";
            this.optionsToolStripMenuItem.Size = new System.Drawing.Size(61, 20);
            this.optionsToolStripMenuItem.Text = "Options";
            // 
            // serviceIDsToolStripMenuItem
            // 
            this.serviceIDsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.selectClientTSMI,
            this.selectPoolTSMI,
            this.toolStripSeparator2,
            this.toolStripMenuItem1,
            this.toolStripSeparator4,
            this.serviceIDTSMI334,
            this.toolStripMenuItem3,
            this.toolStripSeparator1,
            this.toolStripMenuItem4,
            this.toolStripMenuItem5,
            this.toolStripMenuItem6,
            this.toolStripMenuItem7,
            this.toolStripMenuItem8,
            this.toolStripMenuItem9,
            this.toolStripMenuItem10,
            this.toolStripMenuItem11,
            this.toolStripMenuItem12,
            this.toolStripMenuItem13,
            this.toolStripSeparator3,
            this.toolStripMenuItem2});
            this.serviceIDsToolStripMenuItem.Name = "serviceIDsToolStripMenuItem";
            this.serviceIDsToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
            this.serviceIDsToolStripMenuItem.Text = "Service IDs";
            // 
            // selectClientTSMI
            // 
            this.selectClientTSMI.Name = "selectClientTSMI";
            this.selectClientTSMI.Size = new System.Drawing.Size(152, 22);
            this.selectClientTSMI.Text = "Select Client";
            this.selectClientTSMI.Click += new System.EventHandler(this.selectClientTSMI_Clicked);
            // 
            // selectPoolTSMI
            // 
            this.selectPoolTSMI.Name = "selectPoolTSMI";
            this.selectPoolTSMI.Size = new System.Drawing.Size(152, 22);
            this.selectPoolTSMI.Text = "Select Pool IIS";
            this.selectPoolTSMI.Click += new System.EventHandler(this.selectPoolTSMI_Click);
            // 
            // toolStripSeparator2
            // 
            this.toolStripSeparator2.Name = "toolStripSeparator2";
            this.toolStripSeparator2.Size = new System.Drawing.Size(149, 6);
            // 
            // serviceIDTSMI334
            // 
            this.serviceIDTSMI334.CheckOnClick = true;
            this.serviceIDTSMI334.Name = "serviceIDTSMI334";
            this.serviceIDTSMI334.Size = new System.Drawing.Size(152, 22);
            this.serviceIDTSMI334.Tag = ((ushort)(334));
            this.serviceIDTSMI334.Text = "334";
            this.serviceIDTSMI334.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem3
            // 
            this.toolStripMenuItem3.CheckOnClick = true;
            this.toolStripMenuItem3.Name = "toolStripMenuItem3";
            this.toolStripMenuItem3.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem3.Tag = ((ushort)(337));
            this.toolStripMenuItem3.Text = "337";
            this.toolStripMenuItem3.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(149, 6);
            // 
            // toolStripMenuItem4
            // 
            this.toolStripMenuItem4.CheckOnClick = true;
            this.toolStripMenuItem4.Name = "toolStripMenuItem4";
            this.toolStripMenuItem4.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem4.Tag = ((ushort)(2001));
            this.toolStripMenuItem4.Text = "2001";
            this.toolStripMenuItem4.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem5
            // 
            this.toolStripMenuItem5.CheckOnClick = true;
            this.toolStripMenuItem5.Name = "toolStripMenuItem5";
            this.toolStripMenuItem5.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem5.Tag = ((ushort)(3001));
            this.toolStripMenuItem5.Text = "3001";
            this.toolStripMenuItem5.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem6
            // 
            this.toolStripMenuItem6.CheckOnClick = true;
            this.toolStripMenuItem6.Name = "toolStripMenuItem6";
            this.toolStripMenuItem6.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem6.Tag = ((ushort)(2002));
            this.toolStripMenuItem6.Text = "2002";
            this.toolStripMenuItem6.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem7
            // 
            this.toolStripMenuItem7.CheckOnClick = true;
            this.toolStripMenuItem7.Name = "toolStripMenuItem7";
            this.toolStripMenuItem7.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem7.Tag = ((ushort)(3002));
            this.toolStripMenuItem7.Text = "3002";
            this.toolStripMenuItem7.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem8
            // 
            this.toolStripMenuItem8.CheckOnClick = true;
            this.toolStripMenuItem8.Name = "toolStripMenuItem8";
            this.toolStripMenuItem8.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem8.Tag = ((ushort)(2003));
            this.toolStripMenuItem8.Text = "2003";
            this.toolStripMenuItem8.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem9
            // 
            this.toolStripMenuItem9.CheckOnClick = true;
            this.toolStripMenuItem9.Name = "toolStripMenuItem9";
            this.toolStripMenuItem9.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem9.Tag = ((ushort)(3003));
            this.toolStripMenuItem9.Text = "3003";
            this.toolStripMenuItem9.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem10
            // 
            this.toolStripMenuItem10.CheckOnClick = true;
            this.toolStripMenuItem10.Name = "toolStripMenuItem10";
            this.toolStripMenuItem10.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem10.Tag = ((ushort)(2004));
            this.toolStripMenuItem10.Text = "2004";
            this.toolStripMenuItem10.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem11
            // 
            this.toolStripMenuItem11.CheckOnClick = true;
            this.toolStripMenuItem11.Name = "toolStripMenuItem11";
            this.toolStripMenuItem11.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem11.Tag = ((ushort)(3004));
            this.toolStripMenuItem11.Text = "3004";
            this.toolStripMenuItem11.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem12
            // 
            this.toolStripMenuItem12.CheckOnClick = true;
            this.toolStripMenuItem12.Name = "toolStripMenuItem12";
            this.toolStripMenuItem12.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem12.Tag = ((ushort)(2005));
            this.toolStripMenuItem12.Text = "2005";
            this.toolStripMenuItem12.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripMenuItem13
            // 
            this.toolStripMenuItem13.CheckOnClick = true;
            this.toolStripMenuItem13.Name = "toolStripMenuItem13";
            this.toolStripMenuItem13.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem13.Tag = ((ushort)(3005));
            this.toolStripMenuItem13.Text = "3005";
            this.toolStripMenuItem13.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // toolStripSeparator3
            // 
            this.toolStripSeparator3.Name = "toolStripSeparator3";
            this.toolStripSeparator3.Size = new System.Drawing.Size(149, 6);
            // 
            // toolStripMenuItem2
            // 
            this.toolStripMenuItem2.CheckOnClick = true;
            this.toolStripMenuItem2.Name = "toolStripMenuItem2";
            this.toolStripMenuItem2.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem2.Tag = ((ushort)(1000));
            this.toolStripMenuItem2.Text = "1000";
            this.toolStripMenuItem2.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // resetToolStripMenuItem
            // 
            this.resetToolStripMenuItem.Name = "resetToolStripMenuItem";
            this.resetToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
            this.resetToolStripMenuItem.Text = "Reset";
            this.resetToolStripMenuItem.Click += new System.EventHandler(this.resetToolStripMenuItem_Click);
            // 
            // toolStripSeparator4
            // 
            this.toolStripSeparator4.Name = "toolStripSeparator4";
            this.toolStripSeparator4.Size = new System.Drawing.Size(149, 6);
            // 
            // toolStripMenuItem1
            // 
            this.toolStripMenuItem1.Checked = true;
            this.toolStripMenuItem1.CheckOnClick = true;
            this.toolStripMenuItem1.CheckState = System.Windows.Forms.CheckState.Checked;
            this.toolStripMenuItem1.Name = "toolStripMenuItem1";
            this.toolStripMenuItem1.Size = new System.Drawing.Size(152, 22);
            this.toolStripMenuItem1.Tag = ((ushort)(128));
            this.toolStripMenuItem1.Text = "128";
            this.toolStripMenuItem1.Click += new System.EventHandler(this.serviceIDItem_Click);
            // 
            // SgStressForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(308, 422);
            this.Controls.Add(this.ChalRespTimeDelay);
            this.Controls.Add(this.label18);
            this.Controls.Add(this.groupBox2);
            this.Controls.Add(this.NoChalResp);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label11);
            this.Controls.Add(this.NoChalAck);
            this.Controls.Add(this.SocketPool);
            this.Controls.Add(this.label9);
            this.Controls.Add(this.RecvPerSec);
            this.Controls.Add(this.label8);
            this.Controls.Add(this.groupBox1);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.TargetClients);
            this.Controls.Add(this.menuStrip1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MainMenuStrip = this.menuStrip1;
            this.MaximizeBox = false;
            this.Name = "SgStressForm";
            this.Text = "SgStressForm";
            this.Closing += new System.ComponentModel.CancelEventHandler(this.SgStressForm_Closing);
            ((System.ComponentModel.ISupportInitialize)(this.TargetClients)).EndInit();
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.SocketPool)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NoChalResp)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.NoChalAck)).EndInit();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.ChalRespTimeDelay)).EndInit();
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }
        #endregion

        public SgStressForm()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
            this.Initialize();
        }

        // Property Names
        public const string TargetClientsProperty = "Stress: Connections";

        // Member variables
        //

        protected static RandomEx       Random = new RandomEx();

        protected KerbStoreGeneric      StoreAvailable;         // signed out
        protected KerbStoreGeneric      StoreSignedIn;          // signed in
        protected KerbStoreGeneric      StoreDeleted;           // recently signed out
        protected Hashtable             SpiInfoHash;            // maps SPI to SgClient (mostly care about SecReg)
        protected ushort[]              ServiceIDs = new ushort[] { 128 };
        
        protected bool                  Running;
        protected ArrayList             Sockets;
        protected int                   SocketIdx = 0;
        protected int                   SocketCount = 100;
        protected object                SocketLock = new object();

        protected int                   elapsedTimerTime = 0;
        protected int                   numSgDelete = 0;
        protected int                   numSgDataPulse = 0;
        protected int                   numSgQos = 0;
        protected int                   numSgXbToXbForward = 0;
        protected int                   numSgNatReply = 0;
        protected int                   numSgChallenge = 0;
        protected int                   numSgRespAck = 0;
        protected int                   numDataReflect = 0;
        protected int                   numDataReflectAuthdata = 0;
        protected int                   numDataSendBackX = 0;
        protected int                   numDataReflectTimestamp = 0;
        protected int                   totalDataReflectRttPackets = 0;
        protected int                   totalDataReflectRtt = 0;

        public int                      NumAvailableLockfails = 0;
        public int                      NumSignedInLockfails = 0;
        public int                      NumTotalLocks = 0;
        public int                      NumTotalUnlocks = 0;
        public int                      NumTimestampSeqGaps = 0;

        
        public int NumClientsTarget 
        {
            get
            {
                return (int)TargetClients.Value;
            }
        }

        public int NumSocketPool
        {
            get
            {
                return SocketCount;
            }
        }

        public int NumClientsAvailable
        {
            get
            {
                return (StoreAvailable != null) ? StoreAvailable.NumValidItems : 0;
            }
        }

        public int NumClientsSignedIn
        {
            get
            {
                return (StoreSignedIn != null) ? StoreSignedIn.NumValidItems : 0;
            }
        }
        
        public int NumClientsDeleted
        {
            get
            {
                return (StoreDeleted != null) ? StoreDeleted.NumWaitingItems + StoreDeleted.NumValidItems : 0;
            }
        }

        public int NumClientsCreated
        {
            get
            {
                return NumClientsAvailable + NumClientsSignedIn + NumClientsDeleted;
            }
        }

        public int DataReflectRtt
        {
            get
            {
                if (totalDataReflectRttPackets == 0)
                    return 0;
                else
                    return (int)(totalDataReflectRtt / totalDataReflectRttPackets);
            }
            set
            {
                totalDataReflectRttPackets++;
                totalDataReflectRtt += value;
            }
        }

         public bool IsRunning
        {
            get
            {
                return Running;
            }
        }

        public ushort[] ThroughputServiceIDs
        {
            get
            {
                return ServiceIDs;
            }
        }

        private void resetToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ResetAllClients();
        }

        /// <summary>
        /// Deletes all clients, which signs them out and prepares them for later use.
        /// </summary>
        public void ResetAllClients ()
        {
            SgClient sg;

            while ((sg = GetSignedInClient(false)) != null)
            {
                PutDeletedClient(sg);
            }
        }

        private void Initialize()
        {
            // Set some defaults
            this.StoreAvailable = new KerbStoreGeneric(0, (int)TargetClients.Maximum);
            this.StoreSignedIn = new KerbStoreGeneric(0, (int)TargetClients.Maximum);
            this.StoreDeleted = new KerbStoreGeneric(2000, (int)TargetClients.Maximum);
            this.SpiInfoHash = new Hashtable(200000);
            this.Sockets = new ArrayList((int)SocketPool.Maximum);
            this.Running = true;
            this.Update();

            UpdateTimer.Start();
        }

        /// <summary>
        /// Reads properties from the plugin.
        /// </summary>
        public void ReadPluginProperties ()
        {
            string target_clients = SgPlugin.GetProperty(TargetClientsProperty);
            if (target_clients != null)
            {
                decimal val;
                if (decimal.TryParse(target_clients, out val))
                {
                    try
                    {
                        TargetClients.Value = val;
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Got exception setting TargetClients property (" + TargetClientsProperty + "):\n" + e.ToString());
                    }
                }
                else
                {
                    Global.RO.Warn("TargetClients property (" + TargetClientsProperty + ") was not a decimal value (" + target_clients + ")");
                }
            }
        }

        public SgClient LookupClient(uint spi)
        {
            SgClient sg = (SgClient)SpiInfoHash[spi & XspHeader.XSP_SPI_MASK];
            if (sg == null)
            {
                Global.RO.Warn("[LookupClient] Failed to find client for SPI 0x{0:X}", spi);
                return null;
            }
            if (sg.Context.SecKeys.SpiXmit != spi)
            {
                Global.RO.Warn("[LookupClient] SecKeys SPI (0x{0:X}) doesn't match SecMsg SPI (0x{1:X})",
                    sg.Context.SecKeys.SpiXmit, spi);
                return null;
            }
            if (sg.KeyexResult.keyexResp.SpiInit != spi)
            {
                Global.RO.Warn("[LookupClient] KeyexResult SPI (0x{0:X}) doesn't match SecMsg SPI (0x{1:X})",
                    sg.KeyexResult.keyexResp.SpiInit, spi);
                return null;
            }
            return sg;
        }

        /// <summary>
        /// Finds the client based on the given spi.  Does not write any cache misses to ROs.
        /// </summary>
        /// <param name="spi">The spi to look up.</param>
        /// <returns>The client associated with the SPI, or null if no client.</returns>
        public SgClient LookupClientFast (uint spi)
        {
            return (SgClient) (SpiInfoHash[spi & XspHeader.XSP_SPI_MASK]);
        }

        public void RemoveSpiFromHash(uint spi)
        {
            lock (SpiInfoHash)
            {
                // If spi doesn't exist, this does nothing
                SpiInfoHash.Remove(spi & XspHeader.XSP_SPI_MASK);
            }
        }

        public void IncrementCounter(short type)
        {
            switch (type)
            {
                case SecMsgHeader.SECMSG_TYPE_DELETE: 
                    Interlocked.Increment(ref numSgDelete); break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2:
                    Interlocked.Increment(ref numSgDataPulse); break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP:
                    Interlocked.Increment(ref numSgQos); break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP:
                    Interlocked.Increment(ref numSgNatReply); break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL:
                    Interlocked.Increment(ref numSgChallenge); break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK:
                    Interlocked.Increment(ref numSgRespAck); break;
                case SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD:
                    Interlocked.Increment(ref numSgXbToXbForward); break;
                case (short)SGFakeService.ActionType.Reflect:
                    Interlocked.Increment(ref numDataReflect); break;
                case (short)SGFakeService.ActionType.ReflectAuthdata:
                    Interlocked.Increment(ref numDataReflectAuthdata); break;
                case (short)SGFakeService.ActionType.SendBackX: 
                    Interlocked.Increment(ref numDataSendBackX); break;
                case (short)SGFakeService.ActionType.ReflectTimestamp:
                    Interlocked.Increment(ref numDataReflectTimestamp); break;

            }
        }

        private bool Lock(SgClient sg)
        {
            bool r = Monitor.TryEnter(sg.Context.Udp, 0);
            if (r)
            {
                Interlocked.Increment(ref NumTotalLocks);
            }
            return r;
        }

        private void Unlock(SgClient sg)
        {
            if (sg == null)
                return;
            try
            {
                Monitor.Exit(sg.Context.Udp);
                Interlocked.Increment(ref NumTotalUnlocks);
            }
            catch (SynchronizationLockException sle)
            {
                // Swallow ArgumentNullException and SynchronizationLockExceptions
                Global.RO.Warn("[Unlock] Failed to unlocked client spi 0x{0}:\n{1}", sg.SPI, sle.StackTrace);
            }
        }
       
        public bool PutSignedInClient(SgClient client, bool newSignIn)
        {
            if (client == null)
                return false;

            // Add to SPI hash if new
            if (newSignIn && client.IsSignedIn)
            {
                uint spi = client.SPI;
                if (SpiInfoHash.ContainsKey(spi))
                {
                    SgClient existingClient = SpiInfoHash[spi] as SgClient;
                    Global.RO.Warn("[Hash] SPI 0x{0:X} already exists in hash, seconds since last recv={1}, isSignedIn={2}", spi, existingClient.SecondsElapsedSinceLastReceive, existingClient.IsSignedIn);
                    PutDeletedClient(client, false);
                    return false;
                }
                else
                {
                    lock (SpiInfoHash)
                    {
                        SpiInfoHash[spi] = client;
                    }
                }
            }
            else if (newSignIn)
            {
                Global.RO.Warn("[Hash] This appears to be a new sign in but the client isn't signed in");
                PutDeletedClient(client);
                return false;
            }

            // Now we're done with it
            StoreSignedIn.Add(client);
            Unlock(client);
            return true;
        }

        public void PutAvailableClient(SgClient client)
        {
            if (client == null)
                return;
            StoreAvailable.Add(client);
            Unlock(client);
        }

        public void PutDeletedClient (SgClient client)
        {
            PutDeletedClient(client, true);
        }

        public void PutDeletedClient(SgClient client, bool removeFromHash)
        {
            if (client == null)
                return;
            
            if (client.IsSignedIn)
            {
                client.SendDelete();
            }
            
            // Clear XSP cache
            client.ClearCache();

            // Purge the receive buffer 
            //int replysize;
            //byte[] reply;
            //do
            //{
            //    reply = client.AnyRecv(0, out replysize);
            //} while (replysize > 0);

            StoreDeleted.Add(client);
            if (removeFromHash)
            {
                RemoveSpiFromHash(client.SPI);
            }
            Unlock(client);
        }

        /// <summary>
        /// Get a signed in client and lock it.
        /// </summary>
        /// <param name="throwOnNoClient">If true, will throw a DidNotExecuteException instead of returning null.</param>
        /// <returns>null if lock failed or no clients available; an SgClient otherwise.</returns>
        public SgClient GetSignedInClient (bool throwOnNoClient)
        {
            SgClient client = (SgClient)StoreSignedIn.Pop();
            if (client != null)
            {
                // Is this client in use?
                if (!Lock(client))
                {
                    // Record failure and put back into queue
                    Interlocked.Increment(ref NumSignedInLockfails);
                    StoreSignedIn.Add(client);

                    if (throwOnNoClient)
                    {
                        throw new DidNotExecuteException("No client available from the pool.");
                    }
                    else
                    {
                        return null;
                    }
                }
            }
            else if (throwOnNoClient)
            {
                throw new DidNotExecuteException("No client available from the pool.");
            }

            return client;
        }

        /// <summary>
        /// Get a non-signed-in client (available) client and lock it. If none available, then
        /// create one if we haven't met our client target yet. 
        /// </summary>
        /// <param name="clientType"></param>
        /// <param name="numUsers"></param>
        /// <returns></returns>
        public SgClient GetOrCreateAvailableClient(AuthContext.ClientTypes clientType, int numUsers)
        {
            // Too many available for the target?
            if (this.NumClientsSignedIn >= NumClientsTarget)
            {
                return null;
            }

            SgClient sg = (SgClient)StoreAvailable.Pop();

            if (sg != null)
            {
                // Force a new machine, new nonces, etc
                sg.FakeSignInXkdc();
            }
            // Create if necessary
            else if (sg == null && NumClientsCreated < NumClientsTarget)
            {
                AuthContext ctx = new AuthContext(clientType);

                // Set socket from pool
                lock (SocketLock)
                {
                    int socketidx = Interlocked.Increment(ref SocketIdx) - 1;
                    Interlocked.CompareExchange(ref SocketIdx, 0, this.NumSocketPool); 
                    ctx.Udp = (SimpleUdpSG)Sockets[socketidx];
                }

                // Set users
                if (numUsers > 0)
                {
                    for (int i = 0; i < numUsers; i++)
                    {
                        ctx.SetUser("sgstressusr" + i, i);
                    }
                }


#if !LSPTEST
                sg = new SgClient(ctx);
                if (numUsers > 0)
                {
                    sg.bUseConnectionServices = true;
                }
                sg.Context.Site = SiteInfoManager.GetDefaultSgSite();
#else
                LspClient lsp = new LspClient(ctx);
                sg = (SgClient)lsp;
                sg.Context.Site = SiteInfoManager.GetDefaultLspSite();
#endif
                sg.TimeoutInMs = 2000;
                sg.bUseRealXKDC = false;

                // Get the authdata version right
                ctx.Authdata = Authdata_Base.NewDefaultFromSite(ctx.Site);
                sg.SetDefaultAuthdata(ctx.Authdata);
            }

            // Lock this client
            if (sg != null)
            {
                if (!Lock(sg))
                {
                    // Record failure and put back into queue
                    Interlocked.Increment(ref NumAvailableLockfails);
                    StoreAvailable.Add(sg);
                    return null;
                }
            }

            return sg;
        }

        public bool ShouldIDropChalAck()
        {
            int r = Random.Next(100);
            int chance = (int)NoChalAck.Value;
            return r < chance;            
        }
        
        public bool ShouldIDropChalResp()
        {
            int r = Random.Next(100);
            int chance = (int)NoChalResp.Value;
            return r < chance;            
        }

        /// <summary>
        /// How long to delay before sending a response to an async challenge
        /// </summary>
        /// <returns>Number of seconds between 0 and CHALLENGE_INTERVAL</returns>
        public int GetChalResponseDelayTime()
        {
            // I don't want to worry about settings and stuff, let's just assume
            // our max time to send a response is 600 seconds
            return Random.Next((int)ChalRespTimeDelay.Value);
        }

        private void MaintainClients()
        {
            // We can move items from Deleted to Available once the time has passed
            object o;
            while ((o = this.StoreDeleted.Pop()) != null)
            {
                this.StoreAvailable.Add(o);
            }
        }

        private void MaintainSocketPool()
        {
            lock (SocketLock)
            {
                // Update stored value with UI value
                this.SocketCount = (int)this.SocketPool.Value;

                if (this.NumSocketPool == Sockets.Count)
                {
                    return;
                }
                else if (this.NumSocketPool < Sockets.Count)
                {
                    // Need to delete
                    Global.RO.Debug("SocketPool: deleting {0} sockets", Sockets.Count - this.NumSocketPool);
                    Sockets.RemoveRange(this.NumSocketPool, Sockets.Count - this.NumSocketPool);
                    SocketIdx = 0;
                }
                else if (this.NumSocketPool > Sockets.Count)
                {
                    // Need to create
                    Global.RO.Debug("SocketPool: creating {0} sockets", this.NumSocketPool - Sockets.Count);
                    for (int i = Sockets.Count; i < this.NumSocketPool; i++)
                    {
                        SimpleUdpSG udp = new SimpleUdpSG();
                        Sockets.Add(udp);
                    }
                }
            }
        }

        private void TargetClients_ValueChanged(object sender, System.EventArgs e)
        {
            // Socket pool is related to this number, but only change if not running
            //SocketPool.Value = (this.TargetClients.Value / 100);
        }

        private void UpdateTimer_Tick(object sender, System.EventArgs e)
        {
            base.SuspendLayout();
            this.AvailableClients.Text = this.NumClientsAvailable.ToString();
            this.AvailableLockfails.Text = this.NumAvailableLockfails.ToString();
            this.SignedInClients.Text = this.NumClientsSignedIn.ToString();
            this.SignedInLockfails.Text = this.NumSignedInLockfails.ToString();
            this.DeletedClients.Text = this.NumClientsDeleted.ToString();
            //this.TotalLocks.Text = this.NumTotalLocks.ToString();
            //this.TotalUnlocks.Text = this.NumTotalUnlocks.ToString();
            this.TotalLockDifference.Text = (this.NumTotalLocks - this.NumTotalUnlocks).ToString();
            this.SpiHashSize.Text = this.SpiInfoHash.Count.ToString();

            int recvpersec = (int)((float)this.TargetClients.Value / (float)30.0);
            this.RecvPerSec.Text = recvpersec.ToString();

            // Update packet rates
            elapsedTimerTime += this.UpdateTimer.Interval;
            if (elapsedTimerTime >= 1000)
            {
                this.SgDelete.Text = this.numSgDelete.ToString();
                this.SgDataPulse.Text = this.numSgDataPulse.ToString();
                this.SgQos.Text = this.numSgQos.ToString();
                this.SgNatReply.Text = this.numSgNatReply.ToString();
                this.SgChallenge.Text = this.numSgChallenge.ToString();
                this.SgRespAck.Text = this.numSgRespAck.ToString();
                this.SgXbtoXbForward.Text = this.numSgXbToXbForward.ToString();
                this.DataReflect.Text = this.numDataReflect.ToString();
                this.ReflectRtt.Text = this.DataReflectRtt.ToString();
                this.SequenceGaps.Text = this.NumTimestampSeqGaps.ToString();

                // We're not displaying everything, fyi.

                numSgDelete = 0;
                numSgDataPulse = 0;
                numSgQos = 0;
                numSgNatReply = 0;
                numSgChallenge = 0;
                numSgRespAck = 0;
                numSgXbToXbForward = 0;
                numDataReflect = 0;
                numDataReflectAuthdata = 0;
                numDataSendBackX = 0;
                numDataReflectTimestamp = 0;
                NumTimestampSeqGaps = 0;
                totalDataReflectRttPackets = 0;
                totalDataReflectRtt = 0;
                elapsedTimerTime = 0;

                // Only want to do this work occasionally
                MaintainSocketPool();
            }

            MaintainClients();
            base.ResumeLayout();
        }

        new public void Show()
        {
            SgStressFormThread SgFormThread;
            SgFormThread = new SgStressFormThread(this);
            SgFormThread.Go();
            
        }

        private void SgStressForm_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            //e.Cancel = true;
        }

        private void selectClientTSMI_Clicked (object sender, EventArgs e)
        {
            SelectServiceIDs(new ushort[] { 334, 337 });
        }

        private void selectPoolTSMI_Click (object sender, EventArgs e)
        {
            SelectServiceIDs(new ushort[] { 2001, 2002, 2003, 2004, 2005, 3001, 3002, 3003, 3004, 3005 });
        }

        /// <summary>
        /// Selects the service IDs given.
        /// </summary>
        /// <param name="ids"></param>
        private void SelectServiceIDs (ushort[] ids)
        {
            ServiceIDs = ids;
            
            foreach (ToolStripItem item in serviceIDsToolStripMenuItem.DropDownItems)
            {
                if (item is ToolStripMenuItem)
                {
                    ToolStripMenuItem menuItem = (ToolStripMenuItem) item;
                    menuItem.Checked = false;

                    if (menuItem.Tag is ushort)
                    {
                        ushort id = (ushort) menuItem.Tag;

                        foreach (ushort selectID in ids)
                        {
                            if (id == selectID)
                            {
                                menuItem.Checked = true;
                                break;
                            }
                        }
                    }
                }
            }
        }

        private void serviceIDItem_Click (object sender, EventArgs e)
        {
            List<ushort> ids = new List<ushort>();

            foreach (ToolStripItem item in serviceIDsToolStripMenuItem.DropDownItems)
            {
                if (item is ToolStripMenuItem)
                {
                    ToolStripMenuItem menuItem = (ToolStripMenuItem) item;

                    if (menuItem.Tag is ushort && menuItem.Checked)
                    {
                        ids.Add((ushort) menuItem.Tag);
                    }
                }
            }

            ServiceIDs = ids.ToArray();
        }
    }

    public class SgStressFormThread : ThreadBase
    {
        System.Windows.Forms.Form form;

        public SgStressFormThread(System.Windows.Forms.Form f)
        {
            form = f;
        }

        protected override void ThreadBody()
        {
            TaskThread.Priority = ThreadPriority.AboveNormal;

            try
            {
                System.Threading.Thread.CurrentThread.Priority = System.Threading.ThreadPriority.AboveNormal;
                form.ShowDialog();
            }
            catch (Exception e)
            {
                Global.RO.Warn("SgStressFormThread got exception: {0}", e.Message);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\LspTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_lspsgtest_none_12.4.56.0_none_5bd07db9b3985bde
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lspsgtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.manifest
XP_MANIFEST_PATH=manifests\msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.cat
XP_CATALOG_PATH=manifests\msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.cat
XP_PAYLOAD_PATH=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lspsgtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\LspTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\LspTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_lspsgtest_none_12.4.56.0_none_5bd07db9b3985bde
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lspsgtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.manifest
XP_MANIFEST_PATH=manifests\msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.cat
XP_CATALOG_PATH=manifests\msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232.cat
XP_PAYLOAD_PATH=msil_lspsgtest_no-public-key_12.4.56.0_x-ww_77ca2232
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lspsgtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\LspTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\TestBase_Stress.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Net;
using System.Runtime.InteropServices;
using System.Collections;   
using System.Collections.Generic;   
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace XSGTest
{
    class SgStressException : Exception
    {
        public SgStressException(string format, params object[] args) : base(String.Format(format, args))
        {}
    }
              
    abstract public class TestBase_Stress : TestNode
    {
        static public Report                        ro              = new Report("SgStress");
        static public RandomEx                      rand            = new RandomEx();

        // Lock object for each store when initializing
        static private object                       lockInit        = new object();
        static private bool                         bInitialized    = false;

        static public SgStressForm                  SgForm          = null;
        static public SgStressFormThread            SgFormThread    = null;
        static public StreamWriter                  LogFile         = null;

        /// <summary>
        /// Return the current timer in milliseconds
        /// </summary>
        protected double TimerMs
        {
            get
            {
//                 return System.DateTime.Now.TimeOfDay.TotalMilliseconds;
                return System.DateTime.Now.Ticks / 10000;
            }
        }

        static TestBase_Stress()
        {
            if (!bInitialized)
                Initialize();
        }

        public static void Initialize()
        {
            lock(lockInit)
            {
                if (bInitialized)
                    return;

                // Open logging file
                LogFile = new StreamWriter("SgStress.log", false);

                // Show the form, which also holds data
                SgForm = new SgStressForm();
                System.Threading.Thread.Sleep(10);

                bInitialized = true;
            }
        }

        public static void Deinitialize()
        {
            SgForm.Close();
        }

        /// <summary>
        /// Receive only data throughput packets and do it synchonrously
        /// </summary>
        /// <param name="sg"></param>
        /// <param name="bDecrypt"></param>
        /// <param name="message"></param>
        /// <param name="messageSize"></param>
        /// <returns></returns>
        public TEST_RESULTS RecvFilter_Data(SgClient sg, int timeoutInMs, bool bDecrypt, out byte[] message, out int messageSize)
        {
            byte[] reply;
            int replysize;
            uint spi;
            uint xsptype;
            TEST_RESULTS result;

            // Clear outputs
            message = null;
            messageSize = 0;
            
            double startTime = TimerMs;
            double endTime = TimerMs + timeoutInMs;

            while (timeoutInMs > 0)
            {
                result = Recv(sg, out reply, out replysize, out spi, out xsptype, timeoutInMs);
                timeoutInMs = (int)(endTime - TimerMs);
                if (result == TEST_RESULTS.NOT_EXECUTED)
                    continue;
                if (result == TEST_RESULTS.FAILED)
                    return result;

                // If not our spi, try again
                if (sg.SPI != spi)
                    continue;

                // If not a data packet, try again
                if (xsptype == XspHeader.XSP_TYPE_SEC)
                    continue;

                // Make sure we got something
                if (reply == null || replysize == 0)
                    continue;

                // Decrypt it?
                if (bDecrypt)
                {
                    XspPacket xsp = CreateXspPacket(sg, reply, replysize);
                    if (xsp == null)
                        return TEST_RESULTS.FAILED;
                    if (xsp.Message == null)
                    {
                        ro.Warn("[Recv] xsptype says data packet but nothing was decrypted");
                        return TEST_RESULTS.FAILED;
                    }
                    message = xsp.Message;
                    messageSize = xsp.Message.Length;
                }
                return TEST_RESULTS.PASSED;
            }
            return TEST_RESULTS.FAILED;            
        }

        /// <summary>
        /// Quick recv and process incoming packets
        /// </summary>
        /// <param name="sg"></param>
        /// <returns></returns>
        public TEST_RESULTS Recv (SgClient sg)
        {
            byte[] reply;
            int replysize;
            uint spi;
            uint xsptype;
            return Recv(sg, out reply, out replysize, out spi, out xsptype, 0);
        }

        /// <summary>
        /// General purpose receive function
        /// </summary>
        /// <param name="sg"></param>
        /// <returns>PASSED if ok, FAILED if client is not longer connected, NOT_EXECUTED if nothing received</returns>
        public TEST_RESULTS Recv(SgClient inputSg, out byte[] reply, out int replysize, out uint spi, out uint xsptype, int timeoutInMs)
        {
            XspPacket xsp;

            // Clear output vars
            replysize = 0;
            reply = null;
            spi = 0;
            xsptype = 0;

            // Receive something
            reply = inputSg.AnyRecv(timeoutInMs, out replysize);

            // If it's been longer than the timeout, then the SG has likely shut us out
            if (inputSg.SecondsElapsedSinceLastReceive > 120)
            {
                ro.Debug("Over 120 seconds elapsed since last receive, removing client");
                return TEST_RESULTS.FAILED;
            }

            // Must be at least 6, as that's how many bytes we're reading below
            if (replysize < 6)
            {
                return TEST_RESULTS.NOT_EXECUTED;
            }

            // We got a reply. Let's see if we can do something with it.
            // Bytes 0-3 are the SPI
            spi = (uint)(reply[0] + (reply[1] << 8) + (reply[2] << 16) + (reply[3] << 24));
            xsptype = spi & XspHeader.XSP_TYPE_MASK;
            // Now trim off the flags
            spi &= XspHeader.XSP_SPI_MASK;
            if (spi == 0)
            {
                // This is a key exchange packet
                ro.Warn("[Recv] Got a key exchange packet");
                return TEST_RESULTS.PASSED;  // ?
            }

            // The input client is not necessarily the intended client of this
            // secmsg, since we are sharing UDP sockets.  Let's check it first 
            // to save a hash table lookup, but if it's not a match, then look
            // up the client based on SPI.
            SgClient sg = inputSg;
            if (inputSg.SPI != spi)
            {
                sg = SgForm.LookupClient(spi);
                if (sg == null)
                {
                    //ro.Warn("[Recv] Failed to find spi 0x{0:X} in hashtable", spi);
                    return TEST_RESULTS.NOT_EXECUTED; // ?
                }
            }

            //
            // Process it
            //

            // sg is the correct client to use, with the correct keys to 
            // successfully decrypt this packet. Or so we hope.
            //return Process(reply, replysize, recvSg);

            //            LogFile.WriteLine("XSPCREATE|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}",
            //                spihdr.ToString("X"),
            //                sg.SPI.ToString("X"),
            //                xsp.SpiHeader.SpiAndFlags.ToString("X"),
            //                sg.SequenceRecv,
            //                sg.SequenceXmit,
            //                xsp.SequenceNumber,
            //                replysize,
            //                System.Threading.Thread.CurrentThread.GetHashCode(),
            //                sg.GetHashCode());
            //            LogFile.Flush();
            
            if (xsptype == XspHeader.XSP_TYPE_SEC)
            {
                // Decrypt it
                xsp = CreateXspPacket(sg, reply, replysize);
                if (xsp == null)
                    return TEST_RESULTS.FAILED;
                SecMsgHeader hdr = xsp.SecMsg;
                
                // Make note of this packet in the GUI
                SgForm.IncrementCounter(hdr.Type);

                if (hdr.Type == SecMsgHeader.SECMSG_TYPE_DELETE)
                {
                    // we're getting kicked, oh noes!
                    SgForm.RemoveSpiFromHash(sg.SPI);
                    return TEST_RESULTS.FAILED;
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2)
                {
                    // got a pulse
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP)
                {
                    // response to a qos
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP)
                {
                    // nat detection reply
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL)
                {
                    // async challenge
                    sg.ChallengeNonce = (hdr as SecMsgSgToXbChal).ChallengeNonce;

                    // Sometimes send an ack, sometimes don't
                    if (!SgForm.ShouldIDropChalAck())
                    {
                        sg.SendChallengeAck();
                    
                        // Sometimes send a reply
                        if (!SgForm.ShouldIDropChalResp())
                        {
                            sg.timeToSendChalResponse = TimerMs + SgForm.GetChalResponseDelayTime() * 1000;
                            // note: when we end up sending this, set sg.timeToSendChalResponse to 0
                        }
                        else
                        {
                            // And sometimes don't send a reply
                            sg.timeToSendChalResponse = 0;
                        }
                    }
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK)
                {
                    // chal response ack from server
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD)
                {
                    // forward from our xbtoxbforward test
                }
            }
            else if (
                xsptype == XspHeader.XSP_TYPE_UDP_0 ||
                xsptype == XspHeader.XSP_TYPE_UDP_1 ||
                xsptype == XspHeader.XSP_TYPE_UDP_2
                )
            {
                // Decrypted message layout
                //   message[0] = (byte)action;
                //   message[1] = (byte)serviceSequenceNum;
                //   message[2] = parameter;
                //   message[3] = 0xFE;
                // No need to decrypt, as that is expensive and we don't really care what is inside.
                // Since we aren't decrypting, let's optimistically assume it is a Reflection
                SgForm.IncrementCounter((short)(SGFakeService.ActionType.Reflect));
            }

            return TEST_RESULTS.PASSED;
        }

        public XspPacket CreateXspPacket(SgClient sg, byte[] reply, int replysize)
        {
            try
            {
                return sg.XspCreate(reply, replysize);
            }
            catch (SGException e)
            {
                uint spihdr = (uint)(reply[0] + (reply[1] << 8) + (reply[2] << 16) + (reply[3] << 24)) & XspHeader.XSP_SPI_MASK;
                LogFile.WriteLine("XSPERR|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}",
                    spihdr.ToString("X"),
                    sg.SPI.ToString("X"),
                    sg.SequenceRecv,
                    sg.SequenceXmit,
                    replysize,
                    System.Threading.Thread.CurrentThread.GetHashCode(),
                    sg.GetHashCode(),
                    e.Message);
                LogFile.Flush();
                ro.Warn(e.Message);
                return null;
            }
        }

        public void SignIn (AuthContext.ClientTypes clientType, int numUsers)
        {
            SignIn(clientType, numUsers, 0);
        }
        public void SignIn (AuthContext.ClientTypes clientType, int numUsers, ushort buildNum)
        {
            SignIn(clientType, numUsers, buildNum, false);
        }

        public void SignIn (AuthContext.ClientTypes clientType, int numUsers, ushort buildNum, bool bTSKeyex)
        {
            string serverName = "sg";
            bool logAddErr = true;

            SgClient sg = SgForm.GetOrCreateAvailableClient(clientType, numUsers);
            if (sg == null)
            {
                throw new DidNotExecuteException("No available client.");
            }

            // Buildnum 0x0010 should cause us to get asynchronously challenged
            sg.Context.TitleInfo.BuildNumber = buildNum;

            string errMessage = "";
            try
            {
#if !LSPTEST
                serverName = "sg";
                sg.SignInSG();
#else
                try
                {
                serverName = "ts";
                if (!bTSKeyex)
                {
                    // SG-style key exchange
                    sg.SignInSG();
                }
                else
                {
                    // LSP TS-style key exchange
                    (sg as LspClient).SignInLSPWithTSKey();
                }
                }
                catch
                {
                    ro.Debug(sg.Context.Authdata.ToString());
                    throw;
                }
#endif

                if (SgForm.PutSignedInClient(sg, true))
                {
                    if (!(sg is LspClient))
                    {
                        // Log important info
                        LogFile.WriteLine("ADD|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}|{9}|{10}|{11}|{12}",
                            sg.KeyexRequest.keyexInit.SpiInit.ToString("X"),
                            Hexer.tohex(sg.KeyexRequest.keyexInit.NonceInit),
                            sg.Context.Udp.LocalIP.Address.ToString(),
                            sg.Context.Udp.LocalIP.Port,
                            sg.KeyexResult.keyexResp.SpiInit.ToString("X"),
                            Hexer.tohex(sg.KeyexResult.keyexResp.NonceInit),
                            sg.KeyexResult.keyexResp.IPInit.ToString(),
                            NetConstants.HTONS((ushort)sg.KeyexResult.keyexResp.PortInit),
                            sg.KeyexResult.keyexResp.SpiResp.ToString("X"),
                            Hexer.tohex(sg.KeyexResult.keyexResp.NonceResp),
                            serverName,
                            System.Threading.Thread.CurrentThread.GetHashCode(),
                            sg.GetHashCode());
                    }
                    LogFile.Flush();
                    logAddErr = false;
                    return;
                }
            }
            catch (Exception e)
            {
                ro.Debug("Got exception signing in, adding client back to deleted queue: {0}", e.Message);
                // prevent us from accidentally removing a good SPI from the hash
                sg.KeyexRequest.keyexInit.SpiInit = 0;
                SgForm.PutDeletedClient(sg);
                errMessage = e.Message;

                throw;
            }
            finally
            {
                // Log important info
                if (logAddErr && !(sg is LspClient))
                {
                    LogFile.WriteLine("ADDERR|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}|{9}|{10}|{11}|{12}|{13}",
                        sg.KeyexRequest.keyexInit.SpiInit.ToString("X"),
                        Hexer.tohex(sg.KeyexRequest.keyexInit.NonceInit),
                        sg.Context.Udp.LocalIP.Address.ToString(),
                        sg.Context.Udp.LocalIP.Port,
                        sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.SpiInit.ToString("X"),
                        sg.KeyexResult == null ? "" : Hexer.tohex(sg.KeyexResult.keyexResp.NonceInit),
                        "", //sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.IPInit.ToString(),
                        "", //sg.KeyexResult == null ? "" : NetConstants.HTONS((ushort)sg.KeyexResult.keyexResp.PortInit).ToString(),
                        sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.SpiResp.ToString("X"),
                        sg.KeyexResult == null ? "" : Hexer.tohex(sg.KeyexResult.keyexResp.NonceResp),
                        serverName,
                        System.Threading.Thread.CurrentThread.GetHashCode(),
                        sg.GetHashCode(),
                        errMessage);
                }
                LogFile.Flush();
            }

            throw new SgTestException("Failed to sign in, reason unknown.");
        }

        public static void DeleteClient(SgClient sg, string reason)
        {
            SgForm.PutDeletedClient(sg);
            if (!(sg is LspClient))
            {
                LogFile.WriteLine("DEL|{0}|{1}|{2}|{3}|{4}|{5}",
                    sg.KeyexRequest.keyexInit.SpiInit.ToString("X"),
                    sg.Context.SecKeys.SpiXmit.ToString("X"),
                    sg.Context.SecKeys.SpiRecv.ToString("X"),
                    System.Threading.Thread.CurrentThread.GetHashCode(),
                    sg.GetHashCode(),
                    reason);
            }
            LogFile.Flush();
        }

        public override void Run()
        {
            // Initialize array of stores
            // This will simply return if already intialized
            if (!bInitialized)
            {
                Initialize();
            }

            try
            {
                SgExecute();
            }
            catch (KerbErrException e)
            {
                // Catch timeskew errors
                if (e.KerbErr.Error == KerbErrCode.KRB_AP_ERR_SKEW)
                {
                    throw new DidNotExecuteException("TimeSkew -- client time adjusted.", e);
                }
                else
                {
                    throw;
                }
            }
        }

        protected abstract void SgExecute();

    }
    
    abstract public class Throughput_Base : TestBase_Stress
    {
        [ThreadStatic]
        static protected bool bMeasureTimestamp = false;

        // Pre-defined common payload sizes for your convenience. Notice they are static.  
        // And shared.
        static protected byte[] k_payload1400     = new byte[1396];
        static protected byte[] k_payload1024     = new byte[1020];
        static protected byte[] k_payload160      = new byte[156];
        static protected byte[] k_payload128      = new byte[124];
        static protected byte[] k_payload64       = new byte[60];
        static protected byte[] k_payload16       = new byte[12];
        
        static protected byte[] k_payload4        = new byte[4];
        static protected byte[] k_payload45       = new byte[45];
        static protected byte[] k_payload1200     = new byte[1200];
        static protected byte[] k_payload1244     = new byte[1244];

        public static int SequenceNumber    = 0;

        protected ushort ServiceCycle
        {
            get
            {
                ushort[] ids = SgForm.ThroughputServiceIDs;
                // Need to and out that pesky sign bit, or long stress runs will wrap around and throw here
                return ids[(SequenceNumber & 0x7FFFFFFF) % ids.Length];
            }
        }

        public void GoIfSignedIn (byte[] payload, SGFakeService.ActionType action, byte parameter, ushort servicePort)
        {
            GoIfSignedIn(payload, action, parameter, servicePort, 0);        
        }

        public void GoIfSignedIn (byte[] payload, SGFakeService.ActionType action, byte parameter, ushort servicePort, int timeToWaitForReplyInMs)
        {
            SgClient sg = SgForm.GetSignedInClient(true);

            if (!sg.Context.IsSignedInSg)
            {
                throw new DidNotExecuteException("SG client is not signed in. Why is this?");
            }

            try
            {
                Go(payload, action, parameter, servicePort, sg, timeToWaitForReplyInMs);
            }
            catch
            {
                DeleteClient(sg, "GoIfSignedIn exception");
                sg = null;
                throw;
            }
            finally
            {
                if (sg != null && !SgForm.PutSignedInClient(sg, false))
                {
                    if (!(sg is LspClient))
                    {
                        LogFile.WriteLine("ERR|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}|{9}|{10}|{11}|{12}",
                            sg.KeyexRequest.keyexInit.SpiInit.ToString("X"),
                            Hexer.tohex(sg.KeyexRequest.keyexInit.NonceInit),
                            sg.Context.Udp.LocalIP.Address.ToString(),
                            sg.Context.Udp.LocalIP.Port,
                            sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.SpiInit.ToString("X"),
                            sg.KeyexResult == null ? "" : Hexer.tohex(sg.KeyexResult.keyexResp.NonceInit),
                            "", //sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.IPInit.ToString(),
                            "", //sg.KeyexResult == null ? "" : NetConstants.HTONS((ushort)sg.KeyexResult.keyexResp.PortInit).ToString(),
                            sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.SpiResp.ToString("X"),
                            sg.KeyexResult == null ? "" : Hexer.tohex(sg.KeyexResult.keyexResp.NonceResp),
                            "",
                            System.Threading.Thread.CurrentThread.GetHashCode(),
                            sg.GetHashCode());
                    }
                    LogFile.Flush();
                }
            }
        }

        /// <summary>
        /// Send a payload through the SG
        /// </summary>
        /// <param name="action"></param>
        /// <param name="servicePort"></param>
        public void Go (
            byte[] payload, 
            SGFakeService.ActionType action, 
            byte parameter, 
            ushort servicePort, 
            SgClient sg, 
            int timeToWaitForReplyInMs)
        {
            uint     sentSequenceNum         = 0;
            ulong    sentTimestamp           = 0;
            uint     recvSequenceNum         = 0;
            ulong    recvTimestamp           = 0;
            
            // Retrieve our unique sequence number. Interlocked.Increment is atomic and
            // will incremement the number and return the incremented result. If the
            // value wraps, it will do so correctly and silently. Lovely.
            byte seqnum = 0;
            int mySequenceNumber = System.Threading.Interlocked.Increment(ref SequenceNumber);
            seqnum = (byte)(mySequenceNumber % 256);

            // Only applies for the first execution
            if (!sg.Context.IsSignedInSg)
            {
                throw new DidNotExecuteException("Client is not signed in.");
            }

            // Default source port. If we're verifying the return packet, then
            // we should change this a lot to cover port translation.
            ushort sourcePort = 1129;
            if (timeToWaitForReplyInMs > 0 && (sg.SequenceXmit % 3) == 0 && !bMeasureTimestamp)
            {
                // only change the port occasionally
                // ports 0 and 65535 are invalid
                // big 'ol prime gives me a somewhat "random" number
                sourcePort = (ushort)(((sg.SequenceXmit * 15485867) % 65534) + 1);
            }

            // Send it
            sg.XspSendData(
                payload,
                seqnum,
                action,
                parameter,
                servicePort,
                sourcePort,
                out sentSequenceNum,
                out sentTimestamp);

            // If less than 0, we're not receiving anything
            if (timeToWaitForReplyInMs <= 0)
                return;

            // Do receives, if necessary, and any other special processing
            //

            byte[] message;
            int messageSize;
            if (action == SGFakeService.ActionType.AuthdataLookup)
            {
                // Try for 2 seconds
                double endTime = TimerMs + timeToWaitForReplyInMs;

                // Get reply
                while (endTime > TimerMs)
                {
                    int remainingTime = (int)(endTime - TimerMs);
                    TEST_RESULTS result = RecvFilter_Data(sg, remainingTime, true, out message, out messageSize);
                    if (result == TEST_RESULTS.FAILED)
                    {
                        throw new SgTestException("Failed to receive authdata response.");
                    }
                    if (result == TEST_RESULTS.NOT_EXECUTED)
                    {
                        throw new DidNotExecuteException("Nothing to receive.");
                    }

                    if (message != null && messageSize > 0)
                    {
                        
                        // If this is a packet from an AuthdataLookup request, let's display the
                        // result.
                        // SGMSG_TYPE_SPIDATA_REP          = 0x4711;  // CSgMsgSpiRep

                        // Normally, we don't receive SgMsg packets (the SG does),
                        // so this is a bit of a hack.  We should first make sure
                        // this is the appropriate type of packet
                        int type = (int)(message[0] + (message[1] << 8));
                        if (type != SgMsgHeader.SGMSG_TYPE_SPIDATA_REP)
                            continue;
                        // Now we can create it
                        SgMsgSpiDataRepPacket spidata = new SgMsgSpiDataRepPacket();
                        spidata.ReadBytes(message);
                        if (!(sg is LspClient))
                        {
                            LogFile.WriteLine("AUTHDATA|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}",
                                sg.SPI.ToString("X"),
                                Hexer.tohex(sg.KeyexRequest.keyexInit.NonceInit),
                                sg.Context.Udp.LocalIP.Address.ToString(),
                                sg.Context.Udp.LocalIP.Port,
                                spidata.SpiRep.ClientAddr.ToString(),
                                NetConstants.HTONS(spidata.SpiRep.ClientPort),
                                spidata.SpiRep.fNotFound == 0 ? "ok" : "notfound",
                                spidata.SpiAuth == null ? (int)0 : (int)spidata.SpiAuth.AuthData.wAuthDataVersion);
                        }
                        LogFile.Flush();
                        return;
                    }
                }
                throw new SgTestException("Timed out waiting on an authdata response.");
            }
            else if (action == SGFakeService.ActionType.ReflectTimestamp 
                     && timeToWaitForReplyInMs > 0
                     && bMeasureTimestamp)
            {
                // We want to decrypt this so we can read the sequence number and 
                // timestamp fields.
                TEST_RESULTS result = RecvFilter_Data(sg, timeToWaitForReplyInMs, true, out message, out messageSize);
                if (result == TEST_RESULTS.FAILED)
                {
                    throw new SgTestException("Failed to receive response.");
                }
                if (result == TEST_RESULTS.NOT_EXECUTED)
                {
                    throw new DidNotExecuteException("Nothing to receive.");
                }

                if (message != null && messageSize >= 16)
                {
                    AuthClientBase.GetTimestamp(message, 4, out recvSequenceNum, out recvTimestamp);
                    if (recvTimestamp == 0)
                        throw new SgTestException("RecvTimestamp was 0.");

                    // Process the sequence numbers and timestamps
                    // recvTimestamp *should* match sentTimestamp, assuming no packets got 
                    // dropped, and sentTimestamp was taken before the packet got 
                    // encrypted. Let's measure the real latency instead using the 
                    // SGClient's timestamps. This works only for synchronous tests!
                    
                    //ulong recvTime = (ulong)(sg.lastRecvTime.Ticks - 
                    //sg.ClientBirth.Ticks);
                    //ulong elapsedMs = (recvTime - sentTimestamp) / 10000;
                    ulong elapsedMs = (ulong)(sg.lastRecvTime.Ticks - sg.lastSendTime.Ticks) / 10000;
                    uint seqGap = recvSequenceNum - sentSequenceNum;
                    SgForm.DataReflectRtt += (int)elapsedMs;
                    if (seqGap != 0)
                    {
                        SgForm.NumTimestampSeqGaps++;
                    }
                    
                    return;
                }

                throw new SgTestException("Response was malformed.");
            }
            else
            {
                TEST_RESULTS result = RecvFilter_Data(sg, timeToWaitForReplyInMs, false, out message, out messageSize);
                if (result == TEST_RESULTS.FAILED)
                {
                    throw new SgTestException("Failed to receive response.");
                }
                if (result == TEST_RESULTS.NOT_EXECUTED)
                {
                    throw new DidNotExecuteException("Nothing to receive.");
                }
            }

        }
    }

    abstract public class Throughput_Base_1Client : Throughput_Base
    {
        [ThreadStatic]
        protected static SgClient client;
        
        [ThreadStatic]
        protected static byte[] localPayload;

        [ThreadStatic]
        protected static ushort servicePort;

        protected virtual void InitializeTest()
        {
            localPayload = new byte[16];
            servicePort = ServiceCycle;
            bMeasureTimestamp = false;
        }

        protected abstract void RunTest();

        protected override void SgExecute()
        {
            // Let test initialize stuff
            if (localPayload == null)
                InitializeTest();

            // Need to sign in the client initially if it is null
            if (client == null)
            {
                client = SgForm.GetOrCreateAvailableClient(AuthContext.ClientTypes.Xenon, 1);
                if (client == null)
                {
                    throw new DidNotExecuteException("[Throughput_Base_1Client] No clients available. Please increase the client limit or log some off.");
                }
                client.SignInSG();
            }
            else if (!client.IsSignedIn)
            {
                client.SignInSG();
            }

            RunTest();
        }

    }
   

    abstract public class SecMsg_Base : Throughput_Base
    {
        protected bool bDontPutBack = false;

        protected override void SgExecute ()
        {
            // We will grab an SgClient from the local store, which has already been
            // signed in to the SG
            SgClient sg = SgForm.GetSignedInClient(true);

            try
            {
                SendPacket(sg);
                // Do a quick receive
                //Recv(sg);
                if (!bDontPutBack) 
                {
                    if (!SgForm.PutSignedInClient(sg, false))
                    {
                        if (!(sg is LspClient))
                        {
                            LogFile.WriteLine("ADDERR|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}|{9}|{10}|{11}|{12}",
                                sg.KeyexRequest.keyexInit.SpiInit.ToString("X"),
                                Hexer.tohex(sg.KeyexRequest.keyexInit.NonceInit),
                                sg.Context.Udp.LocalIP.Address.ToString(),
                                sg.Context.Udp.LocalIP.Port,
                                sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.SpiInit.ToString("X"),
                                sg.KeyexResult == null ? "" : Hexer.tohex(sg.KeyexResult.keyexResp.NonceInit),
                                "", //sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.IPInit.ToString(),
                                "", //sg.KeyexResult == null ? "" : NetConstants.HTONS((ushort)sg.KeyexResult.keyexResp.PortInit).ToString(),
                                sg.KeyexResult == null ? "" : sg.KeyexResult.keyexResp.SpiResp.ToString("X"),
                                sg.KeyexResult == null ? "" : Hexer.tohex(sg.KeyexResult.keyexResp.NonceResp),
                                "",
                                System.Threading.Thread.CurrentThread.GetHashCode(),
                                sg.GetHashCode());
                        }
                        LogFile.Flush();
                    }
                }
            }
            catch 
            {
                // If exception is thrown, move this client to the deleted list (?)
                DeleteClient(sg, "SecMsg_Base.SgExecute exception");
                throw;
            }
        }

        protected abstract void SendPacket(SgClient sg);
    }

    /// <summary>
    /// The stress test base that uses async calls to get things done.
    /// </summary>
    public abstract class TestBase_AsyncStress : AsyncStressTestNode
    {
        #region Packet Queue

        // TODO: Consider writing a utility collection that is a bag/set of commodities that is thread safe and quick
        //private static Dictionary<uint, LinkedList<byte[]>> PacketQueue = new Dictionary<uint, LinkedList<byte[]>>();

        protected static byte[] GetPacketBuffer ()
        {
            return null;
        }

        #endregion

        #region RecvAsync

        /// <summary>
        /// The signature of a callback from the RecvAsync function.
        /// TODO: Fill this with parameters after completing RecvAsync and associated functions
        /// </summary>
        public delegate void RecvAsyncCallback ();

        protected class RecvAsyncState
        {
            public SgClient Client = null;
            public bool Decrypt = false;
            public RecvAsyncCallback Callback = null;
            public object State = null;
        }

        public static void RecvAsync (SgClient client, bool decrypt, RecvAsyncCallback callback, 
            object state)
        {
            // TODO:
            // Need to check the clients queue of packets, we might be able to make the callback immediately
            // Determine where to do this and whether to do it on a seperate thread

            if (!client.IsSignedIn)
            {
                throw new SGException("Client is not signed in.");
            }

            // Assume that this value is correct, and that after 2 minutes we have been dropped
            if (client.SecondsElapsedSinceLastReceive > 120)
            {
                TestBase_Stress.DeleteClient(client, "SG connection timed out in RecvAsync");
                throw new SGException("SG connection timed out in RecvAsync");
            }

            RecvAsyncState state_obj = new RecvAsyncState();
            state_obj.Client = client;
            state_obj.Decrypt = decrypt;
            state_obj.Callback = callback;
            state_obj.State = state;

            client.Context.Udp.RecvAsync(GetPacketBuffer(), UdpRecvCallback, state_obj);
        }

        protected static void UdpRecvCallback (object state, byte[] buffer, int length, IPEndPoint endpoint,
            bool connection_reset, Exception exc)
        {
            // TODO:
            // Need to get the packet, process it and route it to the correct client's queue/original caller
            // Do we also need to handle common packets such as pulse and delete?
            // Might be a good thing to keep parity with Recv and RecvFilter_Data
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\TestBase_Sg.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Management;
using System.Net;
using System.Xml;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using xonline.common.service;

[assembly: RootNode(typeof(XSGTest.Suite))]

namespace XSGTest
{
    /// <summary>
    /// Initializer stuff goes here
    /// </summary>
    [Owner("johnmcp"), TestFrequency("Daily"), TestCasePriority(2)]
#if LSPTEST
    [EnvRequirement("Manual")]
#endif
    public class Suite : TestNode
    {
        public override void PostRun (RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.STRESS)
            {
                TestBase_Stress.SgForm.ResetAllClients();
            }
        }

        public override void OneTimeSetup (RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.STRESS)
            {
                TestBase_Stress.Initialize();
            }
        }

        public override void OneTimeCleanup (RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.STRESS)
            {
                TestBase_Stress.Deinitialize();
            }
        }
    }

    /// <summary>
    /// All exceptions in this test sutie should inherit from this exception, so that we can
    /// more explicitly catch it and avoid displaying a long stack trace.
    /// </summary>
    public class SgTestException : Exception
    {
        public SgTestException(string format, params object[] args) : base(String.Format(format, args)) { }
    }
    
    public class TestBase_SgFake : TestBase
    {
        // Test-specific reporting object
        static public Report        ro                  = new Report("Sg");

        // Expected no reply?
        public bool                 bExpectedNoReply    = false;

        // Continue verification steps or not? 
        public bool                 bContinue           = true;

        // How many users to add to authdata?
        public int                  numSimulatedUsers   = 1;

        // What kind of client should we be?
        public AuthContext.ClientTypes clientType       = AuthContext.ClientTypes.Xenon;

        // Our client, a fresh one for every test instance
        public SgClient             sg;

        // Used for data throughput and SGMSG stuff
        public int                  sequenceNumber      = 0;
        public XspPacket            lastXsp             = null;
        public SecMsgHeader         lastSecmsg          = null;
        public byte[]               lastData            = null;
        public int                  lastDataLength      = 0;

        // If GetAuthdataFromSg is called, the following fields will be set
        public SgMsgSpiDataRepPacket spiData            = null;

        /// <summary>If true, retry the keyex on timeout; if false, do not.</summary>
        public bool                 RetryKeyExOnTimeout = true;

        // Manages challenge/response files on the SG
        static private ChallengeManager chalManager     = null;  // super internal
        protected ChallengeManager ChalManager
        {
            get
            {
                if (chalManager == null)
                {
                    // Initialize it upon first use.
                    chalManager = new ChallengeManager();
                }
                return chalManager;
            }
        }

        /// <summary>
        /// Return the current timer in seconds
        /// </summary>
        protected double TimerSeconds
        {
            get
            {
                return System.DateTime.Now.TimeOfDay.TotalSeconds;
            }
        }

        /// <summary>
        /// Return the current timer in milliseconds
        /// </summary>
        protected double TimerMs
        {
            get
            {
                return System.DateTime.UtcNow.TimeOfDay.TotalMilliseconds;
            }
        }

        /// <summary>
        /// The port to send to.  Service6 should be XeClisXXX017.
        /// </summary>
        protected SGFakeService.IServicePort ServicePort
        {
            get { return SGFakeService.IServicePort.TestRefl; }
        }

        public static SgClient CreateNewClient (AuthContext.ClientTypes clientType, int numSimulatedUsers)
        {
            SgClient ans;

#if !LSPTEST
            ans = new SgClient(new AuthContext(clientType));
            ans.Context.Site = SiteInfoManager.GetDefaultSgSite().CloneDeep();
#else
            ans = new LspClient(new AuthContext(clientType));
            ans.Context.Site = SiteInfoManager.GetDefaultLspSite().CloneDeep();
#endif
            ans.Context.Authdata = Authdata_Base.NewDefaultFromSite(ans.Context.Site);

            // Set some user names.  DefaultAuthData() will detect this and
            // make up unique puids for us.
            ans.Context.ClearUsers();
            for (int i = 0; i < numSimulatedUsers; i++)
            {
                ans.Context.SetUser("sgtestuser" + i, i);
            }

            ans.SetDefaultAuthdata(ans.Context.Authdata);

            return ans;
        }

        /// <summary>
        /// Set base defaults
        /// </summary>
        protected virtual void SetDefaults()
        {
            // Reset defaults on members since test instances are cached
//             bExpectedNoReply    = false;
//             bContinue           = true;
//             numSimulatedUsers   = 1;
//             clientType          = clienttype;
// 
            sg = CreateNewClient(clientType, numSimulatedUsers);
        }
    
        /// <summary>
        /// Set group-specific defaults, called before InitTest
        /// </summary>
        protected virtual void InitGroup()
        {
            // This will create the appropriate authdata version, set defaults for it,
            // and build a TGS ticket.
            sg.FakeSignInXkdc();
        }

        /// <summary>
        /// Set test specific defaults and bring test to a consistent known state
        /// </summary>
        protected virtual void InitTest()
        {
        }

        /// <summary>
        /// Execute request
        /// </summary>
        protected virtual void RunTest()
        {
        }

        /// <summary>
        /// Verify result
        /// </summary>
        /// <returns></returns>
        protected virtual bool VerifyTest()
        {
            return true;
        }

        /// <summary>
        /// Called for each test case
        /// </summary>
        override protected void Execute()
        {
            // Reset everything. Apparently test instances are cached between Starts
            this.bExpectedNoReply = false;
            this.bContinue = true;
            this.numSimulatedUsers = 1;
            this.clientType = AuthContext.ClientTypes.Xenon;

            // Pass unless exception thrown or explicitly fail
            ResultCode = TEST_RESULTS.PASSED;

            try
            {
                // Tests should override these as needed

                // Step 1
                SetDefaults();
                if (!bContinue)
                    return;
                
                // Step 1.5 - prep group defaults
                InitGroup();
                if (!bContinue)
                    return;

                // Step 2 - prep request
                InitTest();
                if (!bContinue)
                    return;
                
                if (ResultCode != TEST_RESULTS.FAILED)
                {
                    // Step 3 - send it
                    RunTest();
                    if (!bContinue)
                        return;
                }
                
                // If we expected no reply but got one, that is bad
                if (this.bExpectedNoReply && ResultCode != TEST_RESULTS.FAILED)
                {
                    Fail("[SgTest] Got a reply when we expected none");
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                {
                    // Step 4 - verify reply
                    if (!VerifyTest())
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

            }
            catch (SgTestException e)
            {
                // We want to swallow these but still report the error message and fail the test
                Fail("[SgTest] " + e.Message);
            }
            catch (SGNoReplyException e)
            {
                if (!bExpectedNoReply)
                {
                    Fail("[SgTest] " + e.Message);
                }
            }
            catch (SGException e)
            {
                // We want to swallow these but still report the error message and fail the test
                Fail("(DEPRECATED) " + e.Message);
            }
            catch (ServerTestFramework.Utilities.TimeoutException e)
            {
                if (!bExpectedNoReply)
                {
                    Fail("[SgTest] " + e.Message);
                }
            }
            catch (Exception)
            {
                ResultCode = TEST_RESULTS.FAILED;
                throw;
            }

            if (bContinue && sg.IsSignedIn)
                sg.SendDelete();
        }

        /// <summary>
        /// Call if a test or verify step fails to set error code and log a message
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        protected void Fail(string format, params object[] args)
        {
            ro.Warn(format, args);
            bContinue = false;
            ResultCode = TEST_RESULTS.FAILED;
        }

        //        public void EnableConnectionServices()
        //        {
        //            // This assumes we are making an auto-discovered Xenon request to the XKDC,
        //            // since all of the following are required to request ConnectionServices:
        //            //     user logon (as opposed to machine logon)
        //            //     presence or signature service
        //            //
        //            // We'll try to support Xbox1 requests as well.
        //            //
        //            sg.bUseConnectionServices = true;
        //            if (sg.Context.NumUsers == 0)
        //            {
        //                sg.Context.SetUser("xktduusert2a", 0);
        //            }
        //        }

        
        public bool RecvLoop(ref int timeoutInMs, bool bExitOnSecmsg, bool bExitOnData)
        {
            double startTime = TimerMs;
            double stopTime = TimerMs + timeoutInMs;
            while (TimerSeconds < stopTime)
            {
                lastXsp = sg.XspRecv(timeoutInMs);
                timeoutInMs = (int)(stopTime - TimerMs);
                if (lastXsp == null)
                {
                    return false;
                }
                else if (lastXsp.SecMsg != null)
                {
                    lastSecmsg = lastXsp.SecMsg;
                    if (bExitOnSecmsg)
                    {
                        return true;
                    }
                }
                else if (lastXsp.Message != null)
                {
                    lastData = lastXsp.Message;
                    lastDataLength = lastXsp.MessageLength;

                    if (bExitOnData)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public void DoKeyExchange()
        {
            sg.BuildFakeTicket(sg.Context.Authdata, sg.Context.Site.serverName, sg.Context.Site.siteName, sg.Context.Site.siteKey);
            // TODO: don't forget about connection services
            try
            {
                sg.SignInSG();
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                if (!RetryKeyExOnTimeout)
                {
                    throw;
                }

                // Try once more only
                ro.Debug("SG key exchange timed out, trying once more");
                sg.Context.Udp.Reset();
                sg.SignInSG();
                ro.Debug("Succeeded on second attempt!");
            }
        }

        public bool IsStillSignedIn(int timeoutInMS)
        {
            if (!sg.IsSignedIn)
                return false;
            // Do QOS exchange as a verification step
            QOS q = new QOS();
            return q.SendRecv(sg,timeoutInMS);
        }
        public bool IsStillSignedIn()
        {
            if (!sg.IsSignedIn)
                return false;
            // Do QOS exchange as a verification step
            QOS q = new QOS();
            return q.SendRecv(sg);
        }

        public bool EnsureStillSignedIn()
        {
            if (!sg.IsSignedIn)
            {
                Fail("Not signed in to the SG");
                return false;
            }
            if (!IsStillSignedIn())
            {
                Fail("No response from the SG");
                return false;
            }
            return true;
        }

        public void SendKeyexChalResponse(string data)
        {
            SendKeyexChalResponse(Hexer.unhex(data));
        }

        public void SendKeyexChalResponse(byte[] data)
        {
            SecMsgXbToSgChalResp response = new SecMsgXbToSgChalResp();

            // data should be 256 bytes, but we'll be nice
            if (data != null)
                Array.Copy(data, 0, response.Execute, 0, Math.Min(data.Length, response.Execute.Length));

            sg.XspSend(response);
        }

        public void SendKeyexChalResponse3 (byte[] data)
        {
            SecMsgXbToSgChalResp3 response = new SecMsgXbToSgChalResp3();

            // data should be 1024 bytes, but we'll be nice
            if (data != null)
                Array.Copy(data, 0, response.Execute, 0, Math.Min(data.Length, response.Execute.Length));

            sg.XspSend(response);
        }
        
        /// <summary>
        /// Sends a AuthdataLookup request to the SGFakeService, which must be running. This will
        /// reflect the entire SPIDATA packet back to us for our client.
        /// </summary>
        /// <returns></returns>
        public Authdata_Base GetAuthdataFromSg ()
        {
            return GetAuthdataFromSg(ServicePort);
        }

        public Authdata_Base GetAuthdataFromSg(SGFakeService.IServicePort servicePort)
        {
            return GetAuthdataFromSg(servicePort, false);
        }

        public Authdata_Base GetAuthdataFromSg (SGFakeService.IServicePort servicePort, bool fRealSGInfo)
        {
            return GetAuthdataFromSg(servicePort, fRealSGInfo, 0, 2);
        }

        public Authdata_Base GetAuthdataFromSg (SGFakeService.IServicePort servicePort, bool fRealSGInfo, byte realSGInfoVersion, byte useOldProtocol)
        {
            return GetAuthdataFromSg(servicePort, fRealSGInfo, realSGInfoVersion, useOldProtocol, true);
        }

        /// <summary>
        /// Sends a AuthdataLookup request to the SGFakeService, which must be running. This will
        /// reflect the entire SPIDATA packet back to us for our client.
        /// </summary>
        /// <returns></returns>
        public Authdata_Base GetAuthdataFromSg (SGFakeService.IServicePort servicePort, bool fRealSGInfo, byte realSGInfoVersion, byte useOldProtocol, 
            bool forceResponseThrough)
        {
            if (!sg.IsSignedIn)
            {
                throw new SgTestException("Must be signed in to the SG to get the authdata");
            }

            byte[]                      payload     = new byte[12];
            SGFakeService.ActionType    action      = (SGFakeService.ActionType)(fRealSGInfo
                 ? xonline.common.protocol.TestReflAction.SGInfoLookup
                 : xonline.common.protocol.TestReflAction.AuthdataLookup);
            byte                        parameter   = (fRealSGInfo ? realSGInfoVersion : (byte)1);  // 1 means flush the buffer, necessary for functionals
            payload[4] = useOldProtocol;

            sg.XspSendData(
                payload,
                (byte)(this.sequenceNumber % 256),
                action,
                parameter,
                servicePort);

            if (forceResponseThrough)
            {
                // sleep just a little so the response will be in the queue
                System.Threading.Thread.Sleep(20);

                // due to a bug (X360CS 151345) we need to force the response packet to be sent
                // this will only affect xblobs that are being slow, most other environments this isn't necessary
                // but it doesn't hurt
                sg.XspSendData(
                    payload,
                    (byte)(this.sequenceNumber % 256),
                    (SGFakeService.ActionType)xonline.common.protocol.TestReflAction.Drop,
                    0,
                    servicePort);
            }

            int timeout = 2000;
            if (!RecvLoop(ref timeout, false, true))
            {
                Fail("GetAuthdataFromSg: Nothing received from the SG in 2 seconds. We sent to port {0}", (int)servicePort);
                return null;
            }

            if (this.lastDataLength == 0 || this.lastData == null)
            {
                Fail("GetAuthdataFromSg: No data received, this shouldn't happen");
                return null;
            }

            int type = (int)(lastData[0] + (lastData[1] << 8));
            if (type == SgMsgHeader.SGMSG_TYPE_SPIDATA_REP)
            {
                // Now we can create it.  Also store it for future use, there are lots of good 
                // fields in there.
                spiData = new SgMsgSpiDataRepPacket();
                spiData.ReadBytes(lastData);

                if (spiData.SpiRep.fNotFound != 0 || spiData.SpiAuth == null)
                {
                    Fail("GetAuthdataFromSg: SG says user wasn't found ({0}) for client IP {1} and port {2}",
                         spiData.SpiRep.fNotFound,
                         spiData.SpiRep.ClientAddr.ToString(),
                         spiData.SpiRep.ClientPort);
                    return null;
                }

                return spiData.SpiAuth.AuthData;
            }
            else if (type == xonline.common.service.SGInfo.XONLINE_AUTHDATA_VERSION)
            {
                // Authdata v2
                Authdata_Base ad = new Authdata_Xbox2();
                ad.ReadBytes(lastData);
                return ad;
            }
            else if (type == xonline.common.service.SGInfo.XONLINE_XENON_AUTHDATA_VERSION)
            {
                // Authdata v3
                Authdata_Base ad = new Authdata_Xenon();
                ad.ReadBytes(lastData);
                return ad;
            }
            else if (type == xonline.common.service.SGInfo.XONLINE_XENON2_AUTHDATA_VERSION)
            {
                // Authdata v4
                Authdata_Base ad = new Authdata_Xenon2();
                ad.ReadBytes(lastData);
                return ad;
            }
            else
            {
                Fail("GetAuthdataFromSg: expected reply to be SGMSG_TYPE_SPIDATA_REP (0x{0:X4}) but instead got type 0x{1:X4}",
                    SgMsgHeader.SGMSG_TYPE_SPIDATA_REP,
                    type);
                return null;
            }


        }

        public byte[] SendSgMsg(byte[] requestMsg)
        {
            return SendSgMsg(ServicePort, requestMsg);
        }

        public byte[] SendSgMsg (byte[] requestMsg, bool forceResponseThrough)
        {
            return SendSgMsg(ServicePort, requestMsg, forceResponseThrough);
        }

        public byte[] SendSgMsg (SGFakeService.IServicePort servicePort, byte[] requestMsg)
        {
            return SendSgMsg(servicePort, requestMsg, false);
        }

        public byte[] SendSgMsg(SGFakeService.IServicePort servicePort, byte[] requestMsg, bool forceResponseThrough)
        {
            if (!sg.IsSignedIn)
            {
                throw new SgTestException("Must be signed in to the SG");
            }

            MemoryStream                ms          = new MemoryStream();
            BinaryWriter                bw          = new BinaryWriter(ms);
            SGFakeService.ActionType    action      = SGFakeService.ActionType.SgMsg; // xonline.common.protocol.TestReflAction.SgMsg
            byte                        parameter   = 1;  // 1 means flush the buffer, necessary for functionals

            // Bogus 4 byte header, XspSendData will stomp over it for us.
            bw.Write((uint)0);
            bw.Write(requestMsg);
            byte[] payload = ms.ToArray();

            sg.XspSendData(
                payload,
                (byte)(this.sequenceNumber % 256),
                action,
                parameter,
                servicePort);

            if (forceResponseThrough)
            {
                // sleep just a little so the response will be in the queue
                System.Threading.Thread.Sleep(20);

                // due to a bug (X360CS 151345) we need to force the response packet to be sent
                // this will only affect xblobs that are being slow, most other environments this isn't necessary
                // but it doesn't hurt
                sg.XspSendData(
                    payload,
                    (byte)(this.sequenceNumber % 256),
                    (SGFakeService.ActionType)xonline.common.protocol.TestReflAction.Drop,
                    0,
                    servicePort);
            }

            int timeout = 1000;
            if (!RecvLoop(ref timeout, false, true))
            {
                return null;
            }

            // Raw reply from the SG is reflected to us. Let caller deal with it.
            return this.lastData;
        }

        public void DoXmgmtReloadConfig()
        {
            SgServerInfo.ReloadConfiguration();
        }
    }


    /// <summary>
    /// All tests that cover key exchanges (sign in) should inherit from this class
    /// </summary>
    public class TestBase_Keyex : TestBase_SgFake
    {
        public TestBase_Keyex ()
        {
            RetryKeyExOnTimeout = false;
        }

        /// <summary>
        /// Do the key exchange
        /// </summary>
        protected override void RunTest()
        {
            DoKeyExchange();
        }
    }

    /// <summary>
    /// All tests that cover SECMSG (Internet) should inherit from this class
    /// </summary>
    public class TestBase_Secmsg : TestBase_SgFake
    {
        /// <summary>
        /// Do the key exchange
        /// </summary>
        protected override void InitGroup()
        {
            base.InitGroup();
#if !LSPTEST
            sg.bUseConnectionServices = true;
#endif
            DoKeyExchange();
        }

        protected override void RunTest()
        {
        }
    }

    /// <summary>
    /// All tests that cover SGMSG (Datacenter) should inherit from this class
    /// </summary>
    public class TestBase_Sgmsg : TestBase_SgFake
    {
        /// <summary>
        /// Do the key exchange
        /// </summary>
        protected override void InitGroup()
        {
            base.InitGroup();
#if !LSPTEST
            sg.bUseConnectionServices = true;
#endif

        }

        protected override void RunTest()
        {
            DoKeyExchange();
        }
    }

    /// <summary>
    /// All tests that cover data throughput and XSP should inherit from this class
    /// </summary>
    public class TestBase_Data : TestBase_SgFake
    {
        protected byte[]                    defPayload = new byte[60];
        protected SGFakeService.ActionType  defAction = SGFakeService.ActionType.Reflect;
        protected byte                      defParam = 0;
        protected bool                      bEnsureLRUFunctions = true;

        protected override void InitGroup()
        {
            // Grant the ConnectionService (26) to the ticket prior to building the fake 
            // ticket
            if (sg.Context.Authdata.IsXenon)
            {
                Authdata_Xenon ad = sg.Context.Authdata as Authdata_Xenon;
                ad.dwPrivileges[0] |= (1 << 26);
            }
            else if (sg.Context.Authdata.IsXenon2)
            {
                Authdata_Xenon2 ad = sg.Context.Authdata as Authdata_Xenon2;
                ad.dwBaseServices[0] |= (1 << 26);
            }

            base.InitGroup ();
#if !LSPTEST
            sg.bUseConnectionServices = true;
#endif

            DoKeyExchange();
        }

//        protected override bool VerifyTest()
//        {
//            if (!base.VerifyTest())
//                return false;
//
//            // If we got a reply, verify the ports match
//            if (lastXsp != null && lastDataLength > 0)
//            {
//
//            }
//        }

        protected bool ReflectUdp(byte[] payload, ushort sourcePort)
        {
            return ReflectUdp(payload, sourcePort, ServicePort);
        }

        protected bool ReflectUdp(byte[] payload, ushort sourcePort, SGFakeService.IServicePort servicePort)
        {
            if (bEnsureLRUFunctions)
            {
                System.Threading.Thread.Sleep(200);
            }

            sg.XspSendData(
                payload,
                (byte)sequenceNumber,
                defAction,
                defParam,
                servicePort,
                sourcePort);
            sequenceNumber = (sequenceNumber + 1) % 256;
            
            int timeout = 2000;
            if (!RecvLoop(ref timeout, false, true))
            {
                Fail("No UDP reflection received in {0} ms for sourcePort {1}", 2000, sourcePort);
                return false;
            }

            return true;                                    
        }

        protected bool ReflectUdpVerify(byte[] payload, ushort sourcePort)
        {
            if (!privReflectUdpVerify(payload, sourcePort, ServicePort))
                return false;

            // Verify packet length matches payload
            if (payload.Length != lastDataLength)
            {
                Fail("Reflected packet length mismatch, xmitLen={0}, recvLen={1}", payload.Length, lastDataLength);
                return false;
            }

            // verify reflected payload matches
            for (int i = 0; i < payload.Length; i++)
            {
                if (payload[i] != lastData[i])
                {
                    Fail("Reflected packet data mismatch");
                    return false;
                }
            }
            return true;
        }

        protected bool ReflectUdpWithNATDataVerify(byte[] payload, ushort sourcePort)
        {
            return ReflectUdpWithNATDataVerify(payload, sourcePort, ServicePort);
        }

        protected bool ReflectUdpWithNATDataVerify(byte[] payload, ushort sourcePort, SGFakeService.IServicePort servicePort)
        {
            // Override the default action to reflect with the port map
            defAction = SGFakeService.ActionType.ReflectNATData;
            if (!privReflectUdpVerify(payload, sourcePort, servicePort))
                return false;

            // Last payload should come back as 12 bytes (4 bytes from original payload + 4 bytes endpoint IP + 4 bytes port)
            const int EXPECTED_LENGTH = 12;
            if (EXPECTED_LENGTH != lastDataLength)
            {
                Fail("Reflected packet length unexpected. Expected {0}, but received {1}", EXPECTED_LENGTH, lastDataLength);
                return false;
            }
            return true;
        }

        private bool privReflectUdpVerify(byte[] payload, ushort sourcePort, SGFakeService.IServicePort servicePort)
        {
            if (!ReflectUdp(payload, sourcePort, servicePort))
                return false;

            if (sourcePort != lastXsp.DestPort)
            {
                Fail("Mismatched ports, XspSourcePort={0}, XspDestPort={1}, LocalSourcePort={2}", lastXsp.SourcePort, lastXsp.DestPort, sourcePort);
                return false;
            }

            return true;
        }

    }

    /// <summary>
    /// This node is intended to simply handle propping any lua for the SG.
    /// </summary>
    public class TestNode_LuaScriptGroup : TestBase_SgFake
    {
        /// <summary>
        /// The context name of the lua scripts.
        /// Useful for children to register lua scripts with a parent.  Remember that
        /// they have to be added at construction time, as the PreRun of a parent will
        /// be run before that of a child.
        /// </summary>
        public const string LuaScriptContext = "TestNode_LuaScriptGroup.Scripts";

        /// <summary>
        /// Determines whether the PostRun reload occurs if needed.  Useful for optimizing
        /// tests that must reload frequently.
        /// </summary>
        public bool DoPostRunReload = true;

        /// <summary>
        /// Creates a TestNode_LuaScriptGroup.
        /// </summary>
        public TestNode_LuaScriptGroup ()
        {
            _lua_scripts = new List<LuaScript>();

            CreateContextData();
            SetContextData(LuaScriptContext, _lua_scripts);
        }

        /// <summary>Backing for LuaScripts.</summary>
        private List<LuaScript> _lua_scripts;

        /// <summary>
        /// The list of lua scripts that will be managed.
        /// </summary>
        public List<LuaScript> LuaScripts
        {
            get
            {
                return _lua_scripts;
            }
        }

        /// <summary>
        /// Adds a script to the list.
        /// </summary>
        /// <param name="script">The script to add.</param>
        public void AddScript (LuaScript script)
        {
            _lua_scripts.Add(script);
        }

        /// <summary>
        /// Adds a script to the list by name.
        /// </summary>
        /// <param name="script">The name of the script to add.</param>
        public void AddScript (string scriptName)
        {
            _lua_scripts.Add(ChallengeManager.PreconfiguredLuaScripts[scriptName]);
        }

        /// <summary>
        /// Props the lua scripts in the list.
        /// </summary>
        public override void PreRun (RUN_TYPE runType)
        {
            ChallengeManager chalman = ChalManager;
            bool reload = false;

            foreach (LuaScript script in LuaScripts)
            {
                chalman.AddScript(script, false);
                reload = true;
            }

            if (reload)
            {
                SgServerInfo.ReloadChallenges();
            }
        }

        /// <summary>
        /// Removes the scripts.
        /// </summary>
        public override void PostRun (RUN_TYPE runType)
        {
            ChallengeManager chalman = ChalManager;
            bool reload = false;

            foreach (LuaScript script in LuaScripts)
            {
                chalman.RemoveScript(script, false);
                reload = true;
            }

            if (DoPostRunReload && reload)
            {
                SgServerInfo.ReloadChallenges();
            }
        }
    }

    public class MultiAuthDataBase : TestNode
    {
        private int _PreviousAuthdataVersion;

        private SiteInfo GetDefaultSite ()
        {
#if !LSPTEST
            return SiteInfoManager.GetDefaultSgSite();
#else
            return SiteInfoManager.GetDefaultLspSite();
#endif
        }

        public override void PreRun ()
        {
            int adv = 0;

            if (MyValues != null && MyValues.Length > 0 && MyValues[0] != null)
            {
                adv = (int)MyValues[0];
            }

            if (adv == 0)
            {
                _PreviousAuthdataVersion = 0;
            }
            else
            {
                SiteInfo defaultSite = GetDefaultSite();
                _PreviousAuthdataVersion = defaultSite.authdataVersion;
                defaultSite.authdataVersion = adv;

                Global.RO.Debug("Changed default site to: " + defaultSite.ToString());
            }
        }

        public override void PostRun ()
        {
            if (_PreviousAuthdataVersion != 0)
            {
                SiteInfo defaultSite = GetDefaultSite();
                defaultSite.authdataVersion = _PreviousAuthdataVersion;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\SgTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\SgTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xsgtest_none_12.4.56.0_none_7a7324713ff96245
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xsgtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.manifest
XP_MANIFEST_PATH=manifests\msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.cat
XP_CATALOG_PATH=manifests\msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.cat
XP_PAYLOAD_PATH=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xsgtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\StressSg.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Net;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFD;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.protocol;

namespace XSGTest
{

    #region Sign in LSP style

    [StressTest(Priority=0)]
    public class SignIn_TSKeyExchange_Machine : TestBase_Stress
    {
        protected override void SgExecute()
        {
            SignIn(AuthContext.ClientTypes.Xenon, 0, 0x0011, true);
        }
    }

    [StressTest(Priority=0)]
    public class SignIn_TSKeyExchange_1User : TestBase_Stress
    {
        protected override void SgExecute()
        {
            SignIn(AuthContext.ClientTypes.Xenon, 1, 0x0011, true);
        }
    }

    #endregion

    #region Sign in

    [StressTest(Priority=0)]
    public class SignIn_KeyExchange_Machine : TestBase_Stress
    {
        protected override void SgExecute()
        {
            SignIn(AuthContext.ClientTypes.Xenon, 0);
        }
    }

    [StressTest(Priority=0)]
    public class SignIn_KeyExchange_1User : TestBase_Stress
    {
        protected override void SgExecute()
        {
            SignIn(AuthContext.ClientTypes.Xenon, 1);
        }
    }

    [StressTest(Priority=0)]
    public class SignIn_KeyExchange_4Users : TestBase_Stress
    {
        protected override void