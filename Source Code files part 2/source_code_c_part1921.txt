ion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // the monitor is not GTF.
    if  (!nEdidVersion)
        return  (FALSE);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // Edid version 1.X check for GTF monitor
        if  (lpV1->bFeatureSupport & 0x01)
            return  (TRUE);

        return (FALSE);
    }

    if (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

        // Edid version 2.X check for GTF monitor
        if  (lpV2->bGTFSupportInfo & 0xF0)
        {
            // The GTF monitor bits are set! But the spec also
            // says that the monitor is not truly GTF compliant
            // unless there is also a MONITORLIMITS descriptor
            if  (EdidGetMonitorLimits(lpEdidBuffer, dwEdidSize, &sML))
            {
                return  (TRUE);
            }
        }

        return (FALSE);
    }

    return  (FALSE);
}



/*
    Function:   EdidGetMonitorId

    Purpose:    This returns the monitorID from the EDID. The monitor
                ID is defined as a DWORD from high byte to low byte
                as follows:
                high byte of product code, low byte of product code, high
                byte of manufacturer code, low byte of manufacturer code.

                If there is any kind of error then return UKWN_ID which
                is defined in restime.h  It means any monitor for which
                an EDID is not defined. Since you can't parse the EDID
                for some reason, this is a reasonable return value.

    Arguments:  lpEdidBuffer    The EDID
                dwEdidSize      EDID size in bytes

    Returns:    TRUE            Display type supports GTF.
                FALSE           Display type does not support GTF.

    Preserve:
*/

ULONG CFUNC
EdidGetMonitorId (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int     nEdidVersion;
    ULONG   dwMonitorID;

    // Get the EDID version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // the monitor is not GTF.
    if  (!nEdidVersion)
        return  (UKWN_ID);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        dwMonitorID = (((ULONG) lpV1->wIDProductCode) << 16) |
                      ((ULONG) lpV1->wIDManufName);

        return  (dwMonitorID);
    }

    if (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

        dwMonitorID = (((ULONG) lpV2->wIDProductCode) << 16) |
                      ((ULONG) lpV2->wIDManufName);

        return  (dwMonitorID);
    }

    return  (UKWN_ID);
}



/*
    Function:   EdidBuildStandardTimingTable

    Purpose:    Using the Standard Timings field of the EDID block,
                create a table for the standard timings. NOTE: This
                procedure is only valid for Version 1.x EDID structures
                and the timings associated with these modes are assumed
                to be GTF timings.

    Arguments:  NONE

    Returns:    Nothing but copies supported modes to EDIDStandardTimingTable.

    Preserve:
*/

int CFUNC
EdidBuildStandardTimingTable (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    USHORT          wHorizontalRes;
    USHORT          wVerticalRes;
    USHORT          wRefreshRate;
    int             i, j, nIndex;
    int             FoundMode;
    int             nEdidVersion;
    GTFIN           GTFIn;
    GTFOUT          GTFOut;
    MODESTRUC       sGTF;
    LPMODESTRUC     lpDmtTable;
    LPEDIDV1STRUC   lpV1;

    lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

    // First, zero out all entries
    for (i = 0; i < 8; i++)
        EDIDStandardTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        for (nIndex = 0, i = 0; i < 8; i++)
        {
            wHorizontalRes = lpV1->wStandardTimingID[i] & 0x0FF;
            if  (wHorizontalRes != 0x01)                // Unused fields = 01
            {
                // The value in the EDID = (Horizontal active pixels/8) - 31
                wHorizontalRes += 31;
                wHorizontalRes <<= 3;
                wVerticalRes = lpV1->wStandardTimingID[i] >> 8;
                wRefreshRate = (wVerticalRes & 0x1F) + 60;

                switch (wVerticalRes & 0xC0)         // Aspect Ratio in 7:6
                {
                    case    0x00:
                        wVerticalRes = wHorizontalRes;          // 1:1
                        break;
                    case    0x40:
                        wVerticalRes = wHorizontalRes * 3 / 4;  // 4:3
                        break;
                    case    0x80:
                        wVerticalRes = wHorizontalRes * 4 / 5;  // 5:4
                        break;
                    case    0xC0:
                        wVerticalRes = wHorizontalRes * 9 / 16; // 16:9
                        break;
                }

                FoundMode = FALSE;

                // If monitor is not GTF, try DMT timings first.
                if (!EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize))
                {
                    //First try to find matching DMT mode.
                    DmtGetDmtTablePointer (&lpDmtTable);

                    j = FindMode(lpDmtTable, (ULONG) wHorizontalRes,
                                    (ULONG) wVerticalRes, (ULONG) wRefreshRate);

                    // If a DMT mode was found.
                    if  (j >= 0)
                    {
                        sGTF.wHorizVisible    = lpDmtTable[j].wHorizVisible;
                        sGTF.wVertVisible     = lpDmtTable[j].wVertVisible;
                        sGTF.wRefresh         = lpDmtTable[j].wRefresh;
                        sGTF.wHorizTotal      = lpDmtTable[j].wHorizTotal;
                        sGTF.wHorizBlankStart = lpDmtTable[j].wHorizBlankStart;
                        sGTF.wHorizSyncStart  = lpDmtTable[j].wHorizSyncStart;
                        sGTF.wHorizSyncEnd    = lpDmtTable[j].wHorizSyncEnd;
                        sGTF.wHorizBlankEnd   = lpDmtTable[j].wHorizBlankEnd;
                        sGTF.wVertTotal       = lpDmtTable[j].wVertTotal;
                        sGTF.wVertBlankStart  = lpDmtTable[j].wVertBlankStart;
                        sGTF.wVertSyncStart   = lpDmtTable[j].wVertSyncStart;
                        sGTF.wVertSyncEnd     = lpDmtTable[j].wVertSyncEnd;
                        sGTF.wVertBlankEnd    = lpDmtTable[j].wVertBlankEnd;
                        sGTF.wDotClock        = lpDmtTable[j].wDotClock;
                        sGTF.wHSyncPolarity   = lpDmtTable[j].wHSyncPolarity;
                        sGTF.wVSyncPolarity   = lpDmtTable[j].wVSyncPolarity;

                        FoundMode = TRUE;
                    }

                }

                // No DMT mode was found--use GTF.
                if (!FoundMode)
                {
                    // Get GTF timings for mode.
                    GTFIn.dwHPixels      = (ULONG) wHorizontalRes;
                    GTFIn.dwVLines       = (ULONG) wVerticalRes;
                    GTFIn.dwMarginsRqd   = FALSE;
                    GTFIn.dwIntRqd       = FALSE;
                    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
                    GTFIn.dwIPFreqRqd    = (ULONG) wRefreshRate;
                    ComputeGTFParameters(&GTFIn, &GTFOut);

                    // Store all parameters in temporary MODESTRUC buffer. Note that
                    // horizontal GTF parameters are returned in character clocks and
                    // need to be converted to pixels.
                    sGTF.wHorizVisible    = (USHORT) (GTFOut.dwHActiveChars << 3);
                    sGTF.wVertVisible     = (USHORT) GTFOut.dwVActiveScans;
                    sGTF.wRefresh         = (USHORT) wRefreshRate;
                    sGTF.wHorizTotal      = (USHORT) (GTFOut.dwHTotalChars << 3);
                    sGTF.wHorizBlankStart = (USHORT) (GTFOut.dwHBlankStartChar << 3);
                    sGTF.wHorizSyncStart  = (USHORT) ((GTFOut.dwHBlankStartChar
                                                     + GTFOut.dwHFrontPorchChars) << 3);
                    sGTF.wHorizSyncEnd    = (USHORT) (sGTF.wHorizSyncStart
                                                     + (GTFOut.dwHSyncChars << 3));
                    sGTF.wHorizBlankEnd   = (USHORT) (GTFOut.dwHBlankEndChar << 3);
                    sGTF.wVertTotal       = (USHORT) GTFOut.dwVTotalScans;
                    sGTF.wVertBlankStart  = (USHORT) GTFOut.dwVBlankStartScan;
                    sGTF.wVertSyncStart   = (USHORT) (GTFOut.dwVBlankStartScan
                                                     + GTFOut.dwVFrontPorchScans);
                    sGTF.wVertSyncEnd     = (USHORT) (sGTF.wVertSyncStart
                                                     + GTFOut.dwVSyncScans);
                    sGTF.wVertBlankEnd    = (USHORT) GTFOut.dwVBlankEndScan;
                    sGTF.wDotClock        = (USHORT) GTFOut.dwPixelClockIn10KHertz;
                    sGTF.wHSyncPolarity   = BUFFER_HSYNC_NEGATIVE;
                    sGTF.wVSyncPolarity   = BUFFER_VSYNC_POSITIVE;


                }

                EDIDStandardTimingTable[nIndex++] = sGTF;
            }
        }
    }


    return  (TRUE);
}


/*
    Function:   EdidFindStandardMode

    Purpose:    This routine finds if the mode exists in the EDID
                standard mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindStandardMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i, nEdidVersion;

    // First, zero out all entries
    for (i = 0; i < 8; i++)
        EDIDStandardTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    }

    i = FindMode (EDIDStandardTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDStandardTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}


/*
    Function:   EdidBuildEstablishedTimingTable

    Purpose:    Using the Established Timings field of the EDID block,
                create a table for the established timings. NOTE: This
                procedure is only valid for Version 1.x EDID structures.

    Arguments:  NONE

    Returns:    Nothing but copies supported modes from
                EDIDEstablishedTimingTable to EDIDEstablishedTimingTbl.

    Preserve:
*/

int CFUNC
EdidBuildEstablishedTimingTable (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG           dwTimingBits, dwT1, dwT2;
    int             i, nIndex;
    int             nEdidVersion;
    LPEDIDV1STRUC   lpV1;

    // Only use VESA Established timings and put them in contiguous
    // order from highest resolution to lowest resolution so they will
    // match the order of EDIDEstablishedTimingTable[].
    lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

    dwT1 = (ULONG) (lpV1->bEstablishedTimings1);
    dwT2 = (ULONG) (lpV1->bEstablishedTimings2);
    dwTimingBits  =  (dwT2 & 0x0F) + ((dwT2 & 0xC0) >> 2);
    dwTimingBits  |= ((dwT1 & 0x0F) << 6);

    // First, zero out all entries
    for (i = 0; i < 10; i++)
        EDIDEstablishedTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        for (nIndex = 0, i = 9; i >= 0; i--)
        {
            if (dwTimingBits & (1 << i))    // is this mode supported?
            {
                EDIDEstablishedTimingTable[nIndex++] = EDIDEstablishedTimingTbl[i];
            }
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidFindEstablishedMode

    Purpose:    This routine finds if the mode exists in the EDID
                established mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindEstablishedMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i, nEdidVersion;

    // First, zero out all entries
    for (i = 0; i < 10; i++)
        EDIDEstablishedTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Established timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    }

    i = FindMode (EDIDEstablishedTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDEstablishedTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}



/*
    Function:   EdidBuildDetailedTimingTable

    Purpose:    Using the Detailed Timing section of the EDID block,
                create a table for the detailed timings.

    Arguments:  EdidVersion     Version of EDID block.

    Returns:    Nothing but copies detailed timing modes to
                EDIDDetailedTimingTable.

    Preserve:
*/

int CFUNC
EdidBuildDetailedTimingTable(LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int         nEdidVersion;
    ULONG       dwNumTimings;
    ULONG       dwOffset;
    ULONG       i, j;
    ULONG       dwPixelClock;
    ULONG       dwHorizVertTotal;
    MODESTRUC   sTS;
    LPDETAILEDTIMINGDESCRIPTOR  lpDTD;
    LPEDIDV1STRUC   lpV1;
    TIMINGCODES     tc;
    LPCHAR          lpB;

    // First, zero out all entries in the detailed timing table
    for (i = 0; i < 10; i++)
        EDIDDetailedTimingTable[i] = sZeroMode[0];

    // Get the version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    if  (nEdidVersion < 0x200)
    {
        // Version 1.x
        lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // In version 1.XX, the detailed timings are at a fixed offset
        dwOffset = (ULONG)((LPCHAR) &(lpV1->DetailedTimingDesc[0]) - (LPCHAR) lpV1);

        // With version 1.XX of the EDID, there are 4 detailed timing
        // descriptor slots. Any or all of them can be used. Unused
        // ones are marked with a 0 in the first three bytes.
        dwNumTimings = 4;
    }
    else
    {
        // Version 2.XX of the EDID
        EdidFindNumTimingCodes (lpEdidBuffer, dwEdidSize, &tc);

        // In version 2.XX, the detailed timings are in a section of
        // the EDID which holds many items that are not required.
        // Hence, it is necessary to compute the offset based upon
        // which of the optional items is present. These items begin
        // at offset 80h in the EDID.
        dwOffset = (tc.dwNumLuminanceTables * tc.dwSizeLuminanceTables +
                   tc.dwNumFreqRanges * 8 + tc.dwNumRangeLimits * 27 +
                   tc.dwNumTimingCodes * 4) + 0x80;

        // With version 2.XX of the EDID, there are a variable number
        // of detailed timing descriptor slots. All of them are used.
        // There needn't be any checking for leading zeros.
        dwNumTimings = tc.dwNumDetailedTimings;
    }

    for (j = 0, i = 0; i < dwNumTimings; i++)
    {
        lpDTD = (LPDETAILEDTIMINGDESCRIPTOR) &(lpEdidBuffer[dwOffset]);
        lpB = (LPCHAR) lpDTD;

        // Although technically we should only do the "three leading zeros"
        // check for version 1 of the EDID, if the first three bytes of a
        // detailed timing are zeros, then we should probably ignore the
        // timing for version 2.XX of the EDID since the first two bytes
        // are the pixel clock!
        if  ((lpB[0]) || (lpB[1]) || (lpB[2]))
        {
            sTS.wHorizVisible    = (USHORT) (lpDTD->bDTHorizontalActive
                                    + ((lpDTD->bDTHorizActiveBlank & 0xF0) << 4));
            sTS.wVertVisible     = (USHORT)(lpDTD->bDTVerticalActive
                                    + ((lpDTD->bDTVertActiveBlank & 0xF0) << 4));
            sTS.wHorizTotal      = sTS.wHorizVisible
                                    + (USHORT)(lpDTD->bDTHorizontalBlanking
                                    + ((lpDTD->bDTHorizActiveBlank & 0x0F) << 8));
            sTS.wHorizBlankStart = sTS.wHorizVisible;
            sTS.wHorizSyncStart  = sTS.wHorizBlankStart
                                    + (USHORT)(lpDTD->bDTHorizontalSync
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0xC0) << 2));
            sTS.wHorizSyncEnd    = sTS.wHorizSyncStart
                                    + (USHORT)(lpDTD->bDTHorizontalSyncWidth
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x30) << 4));
            sTS.wHorizBlankEnd   = sTS.wHorizTotal;
            sTS.wVertTotal       = sTS.wVertVisible
                                    + (USHORT)(lpDTD->bDTVerticalBlanking
                                    + ((lpDTD->bDTVertActiveBlank & 0x0F) << 8));
            sTS.wVertBlankStart  = sTS.wVertVisible;
            sTS.wVertSyncStart   = sTS.wVertBlankStart
                                    + (USHORT)(((lpDTD->bDTVerticalSync & 0xF0) >> 4)
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x0C) << 2));
            sTS.wVertSyncEnd     = sTS.wVertSyncStart
                                    + (USHORT)((lpDTD->bDTVerticalSync & 0x0F)
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x03) << 4));
            sTS.wVertBlankEnd    = sTS.wVertTotal;
            sTS.wDotClock        = lpDTD->wDTPixelClock;

            if ((lpDTD->bDTFlags & 0x18) == 0x18)
            {
                sTS.wHSyncPolarity  = (lpDTD->bDTFlags & 0x2) >> 1;
                sTS.wVSyncPolarity  = (lpDTD->bDTFlags & 0x4) >> 2;
            }
            else if ((lpDTD->bDTFlags & 0x18) == 0x10)
            {
                sTS.wHSyncPolarity  = (lpDTD->bDTFlags & 0x2) >> 1;
                sTS.wVSyncPolarity  = BUFFER_VSYNC_POSITIVE;
            }
            else
            {
                sTS.wHSyncPolarity  = BUFFER_HSYNC_NEGATIVE;
                sTS.wVSyncPolarity  = BUFFER_VSYNC_POSITIVE;
            }

            dwPixelClock = Multiply32By32 (lpDTD->wDTPixelClock, 10000);
            dwHorizVertTotal = Multiply32By32 (sTS.wHorizTotal, sTS.wVertTotal);
            sTS.wRefresh = (USHORT) Divide32By32 (dwPixelClock +
                                    dwHorizVertTotal / 2, dwHorizVertTotal);

            EDIDDetailedTimingTable[j++] = sTS;
        }

        dwOffset += sizeof(DETAILEDTIMINGDESCRIPTOR);
    }

    return  (TRUE);
}


/*
    Function:   EdidFindDetailedMode

    Purpose:    This routine finds if the mode exists in the EDID
                detailed mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindDetailedMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i;

    if  (!EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize))
        return  (FALSE);

    i = FindMode (EDIDDetailedTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDDetailedTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}


/*
    Function:   EdidFindExactModeWithHighestRR

    Purpose:    This routine searches for the highest refresh rate
                in the detailed, established, or standard timing
                sections that has a resolution exactly equal to the
                dwXRes and dwYRes in lpModeDesc. The refresh rate
                for that mode is returned. If there is no matching xres,
                yres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindExactModeWithHighestRR (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc)
{
    int             i, nHighestRR;

    nHighestRR = 0;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDDetailedTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        nHighestRR = EDIDDetailedTimingTable[i].wRefresh;

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDEstablishedTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        if  (EDIDEstablishedTimingTable[i].wRefresh > (USHORT) nHighestRR)
            nHighestRR = EDIDEstablishedTimingTable[i].wRefresh;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDStandardTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        if  (EDIDStandardTimingTable[i].wRefresh > (USHORT) nHighestRR)
            nHighestRR = EDIDStandardTimingTable[i].wRefresh;

    if  (nHighestRR)
        return (nHighestRR);

    return  (FALSE);
}


/*
    Function:   EdidFindSameModeOrLargerWithHighestRR

    Purpose:    This routine searches for the highest refresh rate
                in the detailed, established, or standard timing
                sections that has a resolution greater than or equal
                to the dwXRes and dwYRes in lpModeDesc. The refresh rate
                for that mode is returned. If there is no matching xres,
                yres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindSameModeOrLargerWithHighestRR (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc)
{
    int             nHighestRR, nCurrentRR;
    MONITORLIMITS   ML;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    nHighestRR = EdidFindHighestRRinTable (EDIDDetailedTimingTable, lpModeDesc);

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    nCurrentRR = EdidFindHighestRRinTable (EDIDEstablishedTimingTable, lpModeDesc);
    if  (nCurrentRR > nHighestRR)
        nHighestRR = nCurrentRR;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    nCurrentRR = EdidFindHighestRRinTable (EDIDStandardTimingTable, lpModeDesc);
    if  (nCurrentRR > nHighestRR)
        nHighestRR = nCurrentRR;

    if  (nHighestRR < 60)
        nHighestRR = 60;

    if  (!EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &ML))
        return (nHighestRR);

    if  ((ML.dwMaxHorz) && (ML.dwMaxVert))
    {
        // NOTE: If the MonitorLimits ptr passed in to the function
        // GetMaximumRefreshRate has a non-0 dwMaxPixelClock field,
        // then the first three arguments to GetMaximumRefreshRate
        // are irrelevant. We know that ML.dwMaxPixelClock is non-0
        // at this time, so we just pass in 0s for the parameters.
        nCurrentRR = (int) GetMaximumRefreshRate (0, 0, 0, &ML,
                                lpModeDesc->dwXRes, lpModeDesc->dwYRes);


        if (nCurrentRR > nHighestRR)
            nHighestRR = nCurrentRR;
    }

    return  (nHighestRR);
}


/*
    Function:   EdidFindHighestRRinTable

    Purpose:    This routine searches for the highest refresh rate
                in the table passed in. If there is no mode mode greater
                than or equal to dwXRes dwYres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindHighestRRinTable (
        LPMODESTRUC lpMS,
        LPMODEINFO  lpModeDesc)
{
    int          i, nBestIndex;

    nBestIndex = -1;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible >= lpModeDesc->dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible >= lpModeDesc->dwYRes))
        {
            if  (nBestIndex != -1)
            {
                if  (lpMS[i].wRefresh > lpMS[nBestIndex].wRefresh)
                    nBestIndex = i;
            }
            else
            {
                nBestIndex = i;
            }
        }
    }

    // If we didn't even find a mode greater than or equal to dwXRes
    // and dwYRes ...
    if  (nBestIndex == -1)
        return  (0);

    // We found one. Return the refresh rate.
    return  ((int) lpMS[nBestIndex].wRefresh);
}


/*
    Function:   EdidFindLargestEdidMode

    Purpose:    This routine searches the EDID for the largest mode of
                the detailed, established, and standard timings.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeInfo      pointer to buffer for return parameters

    Returns:    TRUE and lpModeInfo filled out with largest XRes and YRes
                     found in EDID or 640x480.

*/
int CFUNC
EdidFindLargestEdidMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeInfo)
{
    // Start with 640x480. Color depth is specified in registry.
    lpModeInfo->dwXRes          = 640;
    lpModeInfo->dwYRes          = 480;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDDetailedTimingTable, lpModeInfo);

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDEstablishedTimingTable, lpModeInfo);

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDStandardTimingTable, lpModeInfo);

    return  (TRUE);
}


/*
    Function:   EdidFindLargestModeinTable

    Purpose:    This routine searches the table pointed to by lpMS for
                a mode that is larger than the mode pointed to by
                lpModeInfo.

    Arguments:  lpMS            pointer to table to search
                lpModeInfo      pointer to mode to compare and to return
                                parameters.

    Returns:    TRUE and lpModeInfo filled out with largest XRes and YRes
                     found in table or mode originally in ModeInfo.

*/
int CFUNC
EdidFindLargestModeinTable (
        LPMODESTRUC lpMS,
        LPMODEINFO  lpModeInfo)
{
    int i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if ((ULONG) lpMS[i].wHorizVisible >= lpModeInfo->dwXRes)
        {
            if ((ULONG) lpMS[i].wVertVisible >= lpModeInfo->dwYRes)
            {
                lpModeInfo->dwXRes = (ULONG) lpMS[i].wHorizVisible;
                lpModeInfo->dwYRes = (ULONG) lpMS[i].wVertVisible;
                if (lpMS[i].wRefresh > (USHORT) lpModeInfo->dwRefreshRate)
                     lpModeInfo->dwRefreshRate = (ULONG) lpMS[i].wRefresh;
            }
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidBuildRangeLimits

    Purpose:    This routine builds a MONITORLIMITS structure
                out of the modes in the EDID.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpML            LPMONITORLIMITS

    Returns:
                TRUE
                lpML is filled in with a range limits built from
                     all the modes in the EDID

    Preserve:
*/
int CFUNC
EdidBuildRangeLimits (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMONITORLIMITS  lpML)
{
    int         i, j;
    LPMODESTRUC lpMS;
    ULONG       dwHorzRate;

    // Build all EDID tables.
    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);

    lpML->dwMinHorz = 0x0FFFFFFFF;
    lpML->dwMaxHorz = 0x00;
    lpML->dwMinVert = 0x0FFFFFFFF;
    lpML->dwMaxVert = 0x00;
    lpML->dwMaxPixelClock = 0x00;

    for (j = 0; j < 3; j++)
    {
        if  (j == 0)
            lpMS = EDIDDetailedTimingTable;
        else if  (j == 1)
            lpMS = EDIDEstablishedTimingTable;
        else if  (j == 2)
            lpMS = EDIDStandardTimingTable;

        for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
        {
            // Find the largest pixel clock of the modes in this list
            if (lpMS[i].wDotClock > (lpML->dwMaxPixelClock / 10000))
                lpML->dwMaxPixelClock = ((ULONG) lpMS[i].wDotClock) * 10000;

            dwHorzRate = ((ULONG) lpMS[i].wDotClock) * 10000 /
                                    (ULONG) lpMS[i].wVertTotal;

            if  (dwHorzRate < lpML->dwMinHorz)
                lpML->dwMinHorz = dwHorzRate;

            if  (dwHorzRate > lpML->dwMaxHorz)
                lpML->dwMaxHorz = dwHorzRate;

            if  (lpMS[i].wRefresh < lpML->dwMinVert)
                lpML->dwMinVert = lpMS[i].wRefresh;

            if  (lpMS[i].wRefresh > lpML->dwMaxVert)
                lpML->dwMaxVert = lpMS[i].wRefresh;
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidFindLargestPixelClock

    Purpose:    This routine searches the EDID for the mode
                with the largest pixel clock and returns that
                largest pixel clock.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer

    Returns:    largest pixel clock (may be 0 if the EDID has
                no modes init)

    Preserve:
*/
ULONG CFUNC
EdidFindLargestPixelClock (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize)
{
    ULONG   dwMaxPixelClock;
    int     j;

    // Start out at 0
    dwMaxPixelClock = 0;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDDetailedTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDDetailedTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDDetailedTimingTable[j].wDotClock;

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDEstablishedTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDEstablishedTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDEstablishedTimingTable[j].wDotClock;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDStandardTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDStandardTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDStandardTimingTable[j].wDotClock;

    return  (dwMaxPixelClock);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\DMT.C ===
/*
    FILE:   dmt.c
    DATE:   4/8/99

    This file is the generic entry point for the dmt modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "debug.h"

//*****************************************************************************
//
// VESA 1.0 rev 0.7 DMT timings
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7
// Monitor Timing Specifications.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity
// VSync polarity
//
// NOTE: Unlike GTF timings, DMT does not dictate zero border widths.
// Therefore we must include blank start and end positions.
//
MODESTRUC    DMTTimingTable[] =
{
    // Settings for 320x200 (mode doubled 640x400):
    //  NOTE: There is no 60Hz 320x200, so use 70Hz if anyone wants 60Hz
    320,200,60,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    320,200,70,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    320,200,85,832/2,640/2,672/2,736/2,832/2,445,400,401,404,445,3150/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 320x240 (mode doubled 640x480):
    320,240,60,800/2,648/2,656/2,752/2,792/2,525,488,490,492,517,2518/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,72,832/2,648/2,664/2,704/2,824/2,520,488,489,492,512,3150/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,75,840/2,640/2,656/2,720/2,840/2,500,480,481,484,500,3150/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,85,832/2,640/2,696/2,752/2,832/2,509,480,481,484,509,3600/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 400x300 (mode doubled 800x600):
    400,300,60,1056/2,800/2,840/2,968/2,1056/2,628,600,601,605,628,4000/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,72,1040/2,800/2,856/2,976/2,1040/2,666,600,637,643,666,5000/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,75,1056/2,800/2,816/2,896/2,1056/2,625,600,601,604,625,4950/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,85,1048/2,800/2,832/2,896/2,1048/2,631,600,601,604,631,5625/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 512x384 (mode doubled 1024x768):
    512,384,60,1344/2,1024/2,1048/2,1184/2,1344/2,806,768,771,777,806,6500/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    512,384,70,1328/2,1024/2,1048/2,1184/2,1328/2,806,768,771,777,806,7500/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    512,384,75,1312/2,1024/2,1040/2,1136/2,1312/2,800,768,769,772,800,7875/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    512,384,85,1376/2,1024/2,1072/2,1168/2,1376/2,808,768,769,772,808,9450/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x350:
    640,350,85,832,640,672,736,832,445,350,382,385,445,3150,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 640x400:
    640,400,60,800,640,656,752,288,449,400,412,414,449,2518,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    640,400,85,832,640,672,736,832,445,400,401,404,445,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x480:
    640,480,60,800,648,656,752,792,525,488,490,492,517,2518,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,72,832,648,664,704,824,520,488,489,492,512,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,75,840,640,656,720,840,500,480,481,484,500,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,85,832,640,696,752,832,509,480,481,484,509,3600,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 720x400:
    720,400,85,936,720,756,828,936,446,400,401,404,446,3550,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 720x480
    720,480,60,800,728,744,776,792,525,488,490,492,517,2518,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 800x600:
    800,600,56,1024,800,824,896,1024,625,600,601,603,625,3600,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,60,1056,800,840,968,1056,628,600,601,605,628,4000,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,72,1040,800,856,976,1040,666,600,637,643,666,5000,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,75,1056,800,816,896,1056,625,600,601,604,625,4950,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,85,1048,800,832,896,1048,631,600,601,604,631,5625,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1024x768:
    1024,768,60,1344,1024,1048,1184,1344,806,768,771,777,806,6500,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,70,1328,1024,1048,1184,1328,806,768,771,777,806,7500,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,75,1312,1024,1040,1136,1312,800,768,769,772,800,7875,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1024,768,85,1376,1024,1072,1168,1376,808,768,769,772,808,9450,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1152x864:
    1152,864,75,1600,1152,1216,1344,1600,900,864,865,868,900,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1280x960:
    1280,960,60,1800,1280,1376,1488,1800,1000,960,961,964,1000,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,960,85,1728,1280,1344,1504,1728,1011,960,961,964,1011,14850,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1280x1024:
    1280,1024,60,1688,1280,1328,1440,1688,1066,1024,1025,1028,1066,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,1024,75,1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,1024,85,1728,1280,1344,1504,1728,1072,1024,1025,1028,1072,15750,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1600x1200:
    1600,1200,60,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,16200,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,65,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,17550,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,70,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,18900,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,75,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,20250,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,85,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,22950,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1792x1344:
    1792,1344,60,2448,1792,1920,2120,2448,1394,1344,1345,1348,1394,20475,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1792,1344,75,2456,1792,1888,2104,2456,1417,1344,1345,1348,1417,26100,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1856x1392:
    1856,1392,60,2528,1856,1952,2176,2528,1439,1392,1393,1396,1439,21825,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1856,1392,75,2560,1856,1984,2208,2560,1500,1392,1393,1396,1500,28800,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1920x1440:
    1920,1440,60,2600,1920,2048,2256,2600,1500,1440,1441,1444,1500,23400,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1920,1440,75,2640,1920,2064,2288,2640,1500,1440,1441,1444,1500,29700,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Flag end of table
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00
};
                   
/*
    Function:   DmtFindMode

    Purpose:    This routine looks for a mode in the DMT list of modes.

    Arguments:  lpModeIn    ptr to MODEINFO structure
                lpModeOut   ptr to MODEOUT  structure

    Returns:    If an DMT mode is found which matches the dwXRes, dwYRes,
                dwBpp, and dwRefreshRate fields in the MODEINFO structure
                pointed to by lpModeIn, then fill in the timing parameters
                in the lpModeOut structure and return TRUE.

                If there is no DMT mode match found, then return FALSE.

    Preserve:   Do not change any fields in lpModeIn.
*/

int CFUNC
DmtFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut)
{
    int     i;

    i = FindMode(DMTTimingTable, lpModeIn->dwXRes,
                    lpModeIn->dwYRes, lpModeIn->dwRefreshRate);

    // Was the mode found?
    if  (i < 0)
        return  (FALSE);

    // Yes! Convert to final output format
    SetupParamsForVidLutClass (DMTTimingTable + i, lpModeOut, lpModeIn);

    return  (TRUE);
}


/*
    Function:   DmtGetDmtTablePointer

    Purpose:    This routine returns a long pointer to the DMTTimingTable.

    Arguments:  lplpDmtTable    ptr to DMT Table pointer

    Returns:    Pointer to the DMT table.
*/

int CFUNC
DmtGetDmtTablePointer (LPMODESTRUC FAR *lplpDmtTable)
{

    *lplpDmtTable = DMTTimingTable;
    return  (TRUE);
}


/*
    DmtGetMaximumRefreshRate

    This routine calculates the maximum refresh rate for the target mode
    specified given the maimum XRes and YRes, and the maximum horizontal
    and vertical frequencies.

*/
#pragma warning(disable: 4296)

int CFUNC
DmtGetMaximumRefreshRate (ULONG dwXRes, ULONG dwYRes, ULONG dwPixelClk,
                          ULONG *dwRefreshRate)
{
    ULONG   i;

    // Assume at least 60 Hz.
    *dwRefreshRate = 60;

    i = FindModeWithoutRR(DMTTimingTable, dwXRes, dwYRes);

    // Was the mode found?
    if  (i < 0)
        return  (FALSE);

    // Find the mode with the greatest refresh rate which has a pixel
    // clock less than or equal to dwPixelClock.
    for (;DMTTimingTable[i].wHorizVisible != 0x00; i++)
    {
        if ((DMTTimingTable[i].wHorizVisible == (USHORT) dwXRes) &&
            (DMTTimingTable[i].wVertVisible == (USHORT) dwYRes))
        {
            if ((ULONG)DMTTimingTable[i].wDotClock <= dwPixelClk)
                *dwRefreshRate = (ULONG) DMTTimingTable[i].wRefresh;
        }
    }

    return  (TRUE);
}

#pragma warning(default: 4296)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\EDID.H ===
/*
    FILE:   edid.h
    DATE:   4/8/99

    This file contains the includes for the EDID code.
    Os Independent
*/

#ifdef WINNT
// This disables any packing optimizations of the compiler.
// We achieve this by telling the compiler to pack on a 1-byte boundary.
// Note: There must be a corresponding pragma call at the end of this file to
// restore the default compiler packing (specified by /Zp).
#pragma pack(1)
#endif

struct  _tagDETAILEDTIMINGDESCRIPTOR
{
    USHORT  wDTPixelClock;              // 0x00
    UCHAR   bDTHorizontalActive;        // 0x02
    UCHAR   bDTHorizontalBlanking;      // 0x03
    UCHAR   bDTHorizActiveBlank;        // 0x04
    UCHAR   bDTVerticalActive;          // 0x05
    UCHAR   bDTVerticalBlanking;        // 0x06
    UCHAR   bDTVertActiveBlank;         // 0x07
    UCHAR   bDTHorizontalSync;          // 0x08
    UCHAR   bDTHorizontalSyncWidth;     // 0x09
    UCHAR   bDTVerticalSync;            // 0x0A
    UCHAR   bDTHorizVertSyncOverFlow;   // 0x0B
    UCHAR   bDTHorizontalImage;         // 0x0C
    UCHAR   bDTVerticalImage;           // 0x0D
    UCHAR   bDTHorizVertImage;          // 0x0E
    UCHAR   bDTHorizontalBorder;        // 0x0F
    UCHAR   bDTVerticalBorder;          // 0x10
    UCHAR   bDTFlags;                   // 0x11
} __STRUCTURE_PACKING__;

typedef struct _tagDETAILEDTIMINGDESCRIPTOR DETAILEDTIMINGDESCRIPTOR;
typedef DETAILEDTIMINGDESCRIPTOR FAR *LPDETAILEDTIMINGDESCRIPTOR;


struct  _tagMONITORDESCRITOR
{
    USHORT  wZeroFlag;                  // 0x00
    UCHAR   bZeroFlag;                  // 0x02
    UCHAR   bTypeDescriptorBlock;       // 0x03
    UCHAR   bZeroFlag2;                 // 0x04
    UCHAR   bMinVertRateInHz;           // 0x05
    UCHAR   bMaxVertRateInHz;           // 0x06
    UCHAR   bMinHorzRateInKHz;          // 0x07
    UCHAR   bMaxHorzRateInKHz;          // 0x08
    UCHAR   bMaxPixelClockInCKHz;       // 0x09
    UCHAR   bUnused[8];                 // 0x0A
} __STRUCTURE_PACKING__;

typedef struct _tagMONITORDESCRITOR MONITORDESCRITOR;
typedef MONITORDESCRITOR FAR *LPMONITORDESCRITOR;

// Note: The bMaxPixelClockInCKHz is in centi-kilohertz which is
// Megahertz divided by 10. This field may not be specified in which
// case it is set to 0x0FF.

// These are the values that can be in the bTypeDescriptorBlock field.
// Note: 0x10-0xF9 are currently undefined. 0x00-0x09 are monitor-
// manufacturer specific.
#define DT_MONITOR_SERIAL_NUMBER        0x0FF
#define DT_ASCII_STRING_DATA            0x0FE
#define DT_MONITOR_RANGE_LIMITS         0x0FD
#define DT_MONITOR_NAME_AS_ASCII        0x0FC
#define DT_EXTRA_COLOR_POINT_DATA       0x0FB
#define DT_EXTRA_STANDARD_TIMINGS       0x0FA


struct  _tagEDIDV1STRUC
{
    UCHAR   bHeaderByte0;               // 0x00
    UCHAR   bHeaderByte1;               // 0x01
    UCHAR   bHeaderByte2;               // 0x02
    UCHAR   bHeaderByte3;               // 0x03
    UCHAR   bHeaderByte4;               // 0x04
    UCHAR   bHeaderByte5;               // 0x05
    UCHAR   bHeaderByte6;               // 0x06
    UCHAR   bHeaderByte7;               // 0x07
    USHORT  wIDManufName;               // 0x08
    USHORT  wIDProductCode;             // 0x0A
    ULONG   wIDSerialNumber;            // 0x0C
    UCHAR   bWeekManuf;                 // 0x10
    UCHAR   bYearManuf;                 // 0x11
    UCHAR   bVersionNumber;             // 0x12
    UCHAR   bRevisionNumber;            // 0x13
    UCHAR   bVideoInputDef;             // 0x14
    UCHAR   bMaxHorizImageSize;         // 0x15
    UCHAR   bMaxVertImageSize;          // 0x16
    UCHAR   bDisplayXferChar;           // 0x17
    UCHAR   bFeatureSupport;            // 0x18
    UCHAR   bRedGreenLowBits;           // 0x19
    UCHAR   bBlueWhiteLowBits;          // 0x1A
    UCHAR   bRedX;                      // 0x1B
    UCHAR   bRedY;                      // 0x1C
    UCHAR   bGreenX;                    // 0x1D
    UCHAR   bGreenY;                    // 0x1E
    UCHAR   bBlueX;                     // 0x1F
    UCHAR   bBlueY;                     // 0x20
    UCHAR   bWhiteX;                    // 0x21
    UCHAR   bWhiteY;                    // 0x22
    UCHAR   bEstablishedTimings1;       // 0x23
    UCHAR   bEstablishedTimings2;       // 0x24
    UCHAR   bManufReservedTimings;      // 0x25
    USHORT  wStandardTimingID[8];       // 0x26
    DETAILEDTIMINGDESCRIPTOR    DetailedTimingDesc[4];  // 0x36
    UCHAR   bExtensionFlag;             // 0x7E
    UCHAR   bChecksum;                  // 0x7F
} __STRUCTURE_PACKING__;

typedef struct _tagEDIDV1STRUC EDIDV1STRUC;
typedef EDIDV1STRUC FAR *LPEDIDV1STRUC;


struct  _tagEDIDV2STRUC
{
    UCHAR   bHeader;                        // 0x00
    USHORT  wIDManufName;                   // 0x01
    USHORT  wIDProductCode;                 // 0x03
    UCHAR   bWeekManuf;                     // 0x05
    USHORT  wYearManuf;                     // 0x06
    UCHAR   bProductIDString[32];           // 0x08
    UCHAR   bSerialNumber[16];              // 0x28
    UCHAR   bReserved1[8];                  // 0x38
    UCHAR   bPhysicalInterfaceType;         // 0x40
    UCHAR   bVideoInterfaceType;            // 0x41
    UCHAR   bInterfaceDataFormat[8];        // 0x42
    UCHAR   bInterfaceColor[5];             // 0x4A
    UCHAR   bDisplayTechType;               // 0x4F
    UCHAR   bMajorDisplayChar;              // 0x50
    UCHAR   bFeaturesSupported[3];          // 0x51
    USHORT  wDisplayResponseTime;           // 0x54
    ULONG   dwDisplayXferChar;              // 0x56
    ULONG   dwMaxLuminance;                 // 0x5A
    UCHAR   bColorimetry[20];               // 0x5E
    ULONG   dwMaxImageSize;                 // 0x72
    ULONG   dwMaxAddressability;            // 0x76
    USHORT  wDotPixelPitch;                 // 0x7A
    UCHAR   bReserved2;                     // 0x7C
    UCHAR   bGTFSupportInfo;                // 0x7D
    USHORT  wTimingInfoMap;                 // 0x7E
    UCHAR   bTableDescriptors[127];         // 0x80
    UCHAR   bChecksum;                      // 0xFF
} __STRUCTURE_PACKING__;

typedef struct _tagEDIDV2STRUC EDIDV2STRUC;
typedef EDIDV2STRUC FAR *LPEDIDV2STRUC;


struct  _tagTIMINGCODES
{
    ULONG   dwNumLuminanceTables;
    ULONG   dwSizeLuminanceTables;
    ULONG   dwNumFreqRanges;
    ULONG   dwNumRangeLimits;
    ULONG   dwNumTimingCodes;
    ULONG   dwNumDetailedTimings;
} __STRUCTURE_PACKING__;

typedef struct _tagTIMINGCODES TIMINGCODES;
typedef TIMINGCODES FAR *LPTIMINGCODES;


struct  _tagDISPLAYTIMINGRANGE
{
    UCHAR   bHiMinVert;
    UCHAR   bHiMaxVert;
    UCHAR   bHiMinHorz;
    UCHAR   bHiMaxHorz;
    UCHAR   bLoHV;
    UCHAR   bLoMinPixClock;
    UCHAR   bLoMaxPixClock;
    UCHAR   bHiMinMaxPixClock;
}  __STRUCTURE_PACKING__;

typedef struct _tagDISPLAYTIMINGRANGE DISPLAYTIMINGRANGE;
typedef DISPLAYTIMINGRANGE FAR *LPDISPLAYTIMINGRANGE;


struct  _tagDETAILEDTIMINGRANGE
{
    USHORT  wMinPixelClock;
    UCHAR   bLowMinHBlank;
    UCHAR   bLowMinVBlank;
    UCHAR   bHiMinHVBlank;
    UCHAR   bMinHSyncOffsetFromBlankStart;
    UCHAR   bLowMinHSyncPulseWidth;
    UCHAR   bLowMinVSyncPulseOffsetAndWidth;
    UCHAR   bHiMinSyncPulseOffsetsAndWidths;
    USHORT  wMaxPixelClock;
    UCHAR   bLowMaxHBlank;
    UCHAR   bLowMaxVBlank;
    UCHAR   bHiMaxHVBlank;
    UCHAR   bMaxHSyncOffset;
    UCHAR   bLowMaxHSyncPulseWidth;
    UCHAR   bLowMaxVSyncPulseOffsetAndWidth;
    UCHAR   bHiMaxSyncPulseOffsetsAndWidths;
    UCHAR   bLowHImageSizeInMM;
    UCHAR   bLowVImageSizeInMM;
    UCHAR   bHiHVImageSizeInMM;
    UCHAR   bLowHActive;
    UCHAR   bLowVActive;
    UCHAR   bHiHVActive;
    UCHAR   bHBorder;
    UCHAR   bVBorder;
    UCHAR   bFlags;
}   __STRUCTURE_PACKING__;

typedef struct _tagDETAILEDTIMINGRANGE DETAILEDTIMINGRANGE;
typedef DETAILEDTIMINGRANGE FAR *LPDETAILEDTIMINGRANGE;


extern int CFUNC EdidFindDetailedMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                            LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC EdidFindStandardMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                            LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC EdidFindEstablishedMode (LPCHAR lpEdidBuffer,
                            ULONG dwEdidSize, LPMODEINFO lpModeDesc,
                            LPMODEOUT lpModeOut);
extern int CFUNC EdidIsGtfMonitor (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine returns TRUE if the Monitor is a GTF monitor and
// FALSE, otherwise. Remember that the DOCS said that technically,
// a monitor is not fully GTF compliant unless in addition to the
// GTF bit, there was also a MONITORRANGELIMITS structure.

extern int CFUNC EdidGetMonitorLimits (LPCHAR lpEdidBuffer,
                            ULONG dwEdidSize, LPMONITORLIMITS lpML);
// This routine gets a MONITORLIMITS structure out of the EDID if
// the EDID is the correct version and a MONITORLIMITS structure
// is present (the structure is optional in v 2.x). If one is
// obtained the function returns TRUE; else it returns FALSE.

extern int CFUNC EdidFindSameModeOrLargerWithHighestRR (LPCHAR lpEdidBuffer,
                    ULONG dwEdidSize, LPMODEINFO lpModeDesc);
// EdidFindModeHighestRR should find a the highest refresh rate in
// the detailed, established, or standard timing sections that has a
// resolution greater than or equal to the dwXRes and dwYRes in
// lpModeDesc. The refresh rate for that mode is returned. If there
// is no matching xres, yres, then 0 is returned.

extern int CFUNC EdidFindHighestRRinTable (LPMODESTRUC lpMS,
                    LPMODEINFO  lpModeDesc);
// EdidFindHighestRRinTable should return the highest refresh rate
// in the table passed in which corresponds to a resolution which is
// greater than or equal to the requested mode.

extern int CFUNC EdidFindLargestEdidMode (LPCHAR lpEdidBuffer,
                    ULONG dwEdidSize, LPMODEINFO lpModeInfo);
// EdidFindLargestEdidMode should return the largest XRes and YRes
// that can be found in the EDID.

extern int CFUNC EdidFindLargestModeinTable (LPMODESTRUC lpMS,
                    LPMODEINFO lpModeInfo);
// EdidFindLargestModeinTable should return the largest XRes and YRes
// that can be found in the table.

// This looks through all the modes listed in the EDID to build a
// range limits structure (by finding the mode with the largest
// pixel clock, largest HFreq, smallest HFreq, largest VFreq,
// smallest VFreq).
extern int CFUNC EdidBuildRangeLimits (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                                LPMONITORLIMITS lpML);

extern int CFUNC EdidCheckIfModeIsSmaller (LPMODESTRUC lpMS,
                    LPMODEINFO  lpModeDesc);
// EdidCheckIfModeIsSmaller should return TRUE if an lpMS timing
// mode exists which is greater than or equal to the requested mode.

extern int CFUNC EdidFindTimingCodesHighestRR (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPMODEINFO lpModeDesc,
                        LPMODEOUT lpModeOut);
// EdidTimingCodesHighestRR should find a mode in the timing codes
// section (only in version 2.X of the EDID) that matches the dwXRes
// and dwYRes in lpModeDesc and has the highest refresh rate. That
// mode should be returned in lpModeOut.

extern int CFUNC EdidGetVersion (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine should return the EDID version multiplied by 0x100.
// So, for example, version 1.10 should be returned as 0x110.

extern ULONG CFUNC EdidGetMonitorId (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine should return the monitorID from the EDID. This is
// defined as a DWORD from high byte to low byte as follows:
// high byte of product code, low byte of product code, high byte of
// manufacturer code, low byte of manufacturer code. ASsemble these
// four bytes into a ULONG and return. If there is any kind of error
// then return XXXX_ID which is defined in restime.h  It means any
// monitor for which an EDID is not defined. Since you can't parse
// the EDID for some reason, this is a reasonable return value.

extern ULONG CFUNC EdidFindLargestPixelClock (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// Finds the EDID mode with the largest pixel clock and returns
// the pixel clock.

extern int CFUNC EdidFindExactModeWithHighestRR (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPMODEINFO lpModeDesc);
// This routine searches for the highest refresh rate in the detailed,
// established, or standard timing sections that has a resolution exactly
// equal to the dwXRes and dwYRes in lpModeDesc. The refresh rate for that
// mode is returned. If there is no matching Xres, Yres, then 0 is returned.

#ifdef WINNT
// Restore the compiler's default specified packing mode (specified by /Zp).
// This directive needs the corresponding directive in the beginning of this file.
#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpemini.h ===
#define _USE_DMA

#define NVP_MAX_EXTRA_SURF_422    10

// data structure used to communicate with miniport
typedef struct _NVP_CMD_OBJECT {
	U032		dwSize;
	U032		dwChipId;	// chip version Id
	U032		dwPortId;	// usually 0 unless there are more than one VP on the chip
	U032		dwDeviceId;	// NV_WIN_DEVICE
	U032		dwSrvId;	// service ID	
	U032		hClient;
	U032        pChannel;		// VPE pio channel
	U032        pOvrChannel;  	// Overlay channel
	U032		dwOvrSubChannel;
	U032		pFrameBuffer;
	U032		dwFBLen;


	U032		dwOverlayObjectID;
	U032		dwScalerObjectID;
	U032		dwDVDObjectID;
    U032        dwDVDObjectCtxDma;
	// VP flags
	U032		dwVPTypeFlags;	// VP connection flag
	U032		dwVPInfoFlags;

	// image attributes
	U032		dwImageStartLine;
	U032		dwVBIStartLine;
	U032		dwInWidth;
	U032		dwInHeight;
	U032		dwPreWidth;
	U032		dwPreHeight;
	U032		dwOriginX;
	U032		dwOriginY;
	U032		dwVBIHeight;

	// surface
	U032		pSurfVidMem;	// address of surface
	U032		dwSurfaceId;	// 0 based surface index 
	U032		dwSurfPitch;	// in bytes
	U032		dwSurfOffset;	// offset from the beginning of the framebuffer
	U032		bSurfVBI;		// TRUE if VBI surface, FALSE for video
	U032		bSurfUpdate;	// TRUE if updating the surfaces attibutes only

	// overlay
	U032 		dwOverlayFormat;
	U032 		dwOverlaySrcX;
	U032 		dwOverlaySrcY;
	U032 		dwOverlaySrcPitch;
	U032 		dwOverlaySrcSize;
	U032 		dwOverlaySrcWidth;
	U032 		dwOverlaySrcHeight;
	U032 		dwOverlayDstWidth;
	U032 		dwOverlayDstHeight;
	U032        dwOverlayDstX;
    U032        dwOverlayDstY;
	U032        dwOverlayDeltaX;
	U032        dwOverlayDeltaY;
	U032        dwOverlayColorKey;
	U032        dwOverlayMode;
	U032        dwOverlayMaxDownScale;
	U032 		aExtra422OverlayOffset[NVP_MAX_EXTRA_SURF_422];
    U032        dwExtra422NumSurfaces;
	U032        dwExtra422Index;
	U032        dwExtra422Pitch;
    U032        pNvPioFlipOverlayNotifierFlat;

    // VPE vsync events
    U032        hVPSyncEvent;

} NVP_CMD_OBJECT, *PNVP_CMD_OBJECT;

// data structure used to communicate with miniport
typedef struct _NVP_VPP_DISPATCH {
	U032		dwSize;
	U032		dwFlags;
	U032		dwOffset;
	U032		dwWidth;
	U032		dwHeight;
	U032		dwFourCC;
} NVP_VPP_DISPATCH, *PNVP_VPP_DISPATCH;

// Service ID used by NVP_CMD_OBJECT
#define NVP_SRV_INITIALIZE		0x01
#define NVP_SRV_UNINITIALIZE	0x02
#define NVP_SRV_START_VIDEO		0x03
#define NVP_SRV_STOP_VIDEO		0x04
#define NVP_SRV_UPDATE_VIDEO	0x05
#define NVP_SRV_REG_SURFACE		0x06
#define NVP_SRV_UPDATE_OVERLAY	0x07
#define NVP_SRV_PROG_STATE		0x08
#define NVP_SRV_FLIP_VIDEOPORT  0x09

// NVP object, channels and events
#define NVP_VPE_CHANNEL						0xA0010001
#define NVP_EXTERNAL_DECODER_OBJECT			0xA0010002
#define NVP_EXTERNAL_DECODER_NOTIFIER		0xA0010003
#define NVP_VIDEO_FIELD0_BUFFER_CONTEXT		0xA0010004
#define NVP_VIDEO_FIELD1_BUFFER_CONTEXT		0xA0010005
#define NVP_VBI_FIELD0_BUFFER_CONTEXT		0xA0010006
#define NVP_VBI_FIELD1_BUFFER_CONTEXT		0xA0010007
#define NVP_VIDEO_FIELD0_BUFFER_EVENT		0xA0010008
#define NVP_VIDEO_FIELD1_BUFFER_EVENT		0xA0010009
#define NVP_VBI_FIELD0_BUFFER_EVENT			0xA001000A
#define NVP_VBI_FIELD1_BUFFER_EVENT			0xA001000B
#define NVP_M2M_OBJECT						0xA001000C
#define NVP_M2M_NOTIFIER					0xA001000D
#define NVP_M2M_CONTEXT						0xA001000E
#define NVP_M2M_FROM_CONTEXT				0xA001000F
#define NVP_M2M_EVENT						0xA0020001
#define NVP_DMA_PUSHBUF_ERROR_NOTIFIER		0xA0020002
#define NVP_DMA_FROM_MEMORY_PUSHBUF			0xA0020003

#define NVP_OVERLAY_OBJECT                  0xA0020004
#define NVP_DVD_SUBPICTURE_OBJECT           0xA0020005
#define NVP_OVERLAY_NOTIFIER                0xA0020006
#define NVP_DVD_SUBPICTURE_CONTEXT          0xA0020007
#define NVP_OVERLAY_BUFFER_CONTEXT          0xA0020008

#define NVP_VSYNC_EVENT0					0xA0020009
#define NVP_VSYNC_EVENT1					0xA002000A

///// methods are equivalent to NV10_VIDEO_OVERLAY
#ifndef NV04_VIDEO_OVERLAY
#define NV04_VIDEO_OVERLAY (0x00000047)
#endif

// field definition (corresponds to H/W def)
#define NVP_FIELD_EVEN			0x00
#define NVP_FIELD_ODD			0x01

// VP state
#define NVP_STATE_STOPPED		0x01L
#define NVP_STATE_STARTED		0x02L
#define NVP_STATE_STARTED_VIDEO	0x04L
#define NVP_STATE_STARTED_VBI	0x10L

#define NVP_STOP_VIDEO          0x01L
#define NVP_STOP_VBI            0x02L

// End of Queue
#define NVP_EOQ		(-1)
#define NVP_UNDEF	(0xFFFFFFFF)

#define NVPE_VSYNC_EVENT_NAME	L"NVPE_VSYNc_EVENT"

// NV chip versions
#define NVP_GET_CHIP_VER(ver)	((ver) & 0xFFFF)

#define NVP_CHIP_VER_03			0x03
#define NVP_CHIP_VER_04			0x04
#define NVP_CHIP_VER_05			0x05
#define NVP_CHIP_VER_10			0x10

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\DMT.H ===
/*
    FILE:   dmt.h
    DATE:   4/8/99

    This file is the dmt find or set mode code.
*/

extern int CFUNC DmtFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut);

extern int CFUNC DmtGetDmtTablePointer (LPMODESTRUC FAR *lplpDmtTable);

extern int CFUNC DmtGetMaximumRefreshRate (ULONG dwXRes, ULONG dwYRes,
                                           ULONG dwPixelClk,
                                           ULONG *dwRefreshRate);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpewrap.c ===
//***************************************************************************
//  Module Name:
//
//      vpewrap.c
//
//  Abstract:
//
//      This module contains the miniport parts of the DXAPI "kernel-mode
//      VPE" interface for the .
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport.
//
//      The miniport code here comprises part of the DXAPI "kernel-mode
//      VPE" interface that can be called by other WDM drivers, such as
//      an MPEG driver.
//
// IMPORTANT NOTE ABOUT HARDWARE REQUIREMENTS:
//
//      Almost all of these miniport "kernel-mode VPE" routines may be
//      called asynchronously to what the display driver is currently
//      doing.  For example, a thread may be in the display driver in the
//      middle of programming an accelerated Blt at the exact moment that
//      the miniport gets called to do a videoport flip call.  Consequently,
//      your hardware MUST be able to handle these commands at any time
//      regardless of the state of the display driver.  So this means:
//
//          1. Your hardware has to be able to allow the programming of any
//             "kernel-mode VPE" command even while Blts or direct frame
//             buffer accesses or DMAs or whatever are occuring, without
//             hanging or incorrect drawing.
//
//          2. The registers used to program any of the "kernel-mode VPE"
//             services must be disjoint and separate from those used by
//             the display driver.  If you must program an indexed register
//             that is also used by the display driver (such as 0x3d4/0x3d5),
//             *YOU ARE PROBABLY TOAST*.  Both a thread in the display driver
//             and a thread calling these miniport services are preemptible,
//             meaning that even if you save and restore the index register,
//             there's no guarantee that the other thread won't wake up in
//             the middle and try to use the same (now incorrectly set)
//             register.
//
//      If your hardware does not guarantee both of the above, you CANNOT
//      support the "kernel-mode VPE" interface!  Go yell at your hardware
//      designers and get them to fix the hardware.  If both of the above
//      are not guaranteed, it's inevitable that your customers will randomly
//      hit system hangs and crashes while using VPE.  Your customers will
//      not be happy!
//
//      Also note that the likelihood of hitting a problem is significantly
//      increased when running on a multiple-processor machine.  Consequently,
//      you should try to test VPE on an MP machine while applications (such
//      as Winstone) are running in the background.
//
//      (Okay, okay, so I exaggerated a bit about pointer number 2.  You can
//      in fact use shared indexed registers in these VPE routines if you do
//      one of the following:
//
//          1. Disable VPE on multiple-processor machines.  (As of the time
//             of this writing, we haven't yet implemented a VideoPort or
//             Eng function that you can call to determine whether you're
//             running on a UP or MP machine, otherwise I would tell you
//             the name of the function to call.  But by the time you read
//             this, it will probably exist -- so have a look through the
//             VideoPort and Eng calls...)
//
//             You'll also have to save and restore the index register when
//             you're done.  Because a thread that calls a miniport function
//             is at raised IRQL, it may interrupt a thread in the display
//             driver at any point, but on a UP machine it's guaranteed that
//             the display driver thread will not interrupt the miniport
//             thread.
//
//          2. Use the CRTC register only in the DxEnableIrq routine --
//             DirectDraw automatically synchronizes with the display driver
//             before calling DxEnableIrq (this is not true for any other
//             Dx miniport calls).
//
// NOTE:
//
//      Most "kernel-mode VPE" routines can be called at raised IRQL, meaning
//      that they MUST be non-paged, and cannot call any pageable functions.
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef VPE_NT

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
// Commented out benign redefinition// typedef int      BOOL;

#define INITGUID     // Instantiate GUID_DxApi
#include "dxmini.h"

#include "nv.h"

DWORD
GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo
    );

VP_STATUS
nvVPEQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,nvVPEQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?

DWORD
GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo
    )

/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

    if ((hwDeviceExtension->BusInterruptLevel != 0) ||
        (hwDeviceExtension->BusInterruptVector != 0)) {

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
    }

    return status;
}

BOOLEAN
Interrupt(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    // add your IRQ handling code here
}

DWORD
EnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}


DWORD
FlipVideoPort(
    PVOID HwDeviceExtension,
    PDDFLIPVIDEOPORTINFO FlipVideoPortInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    ULONG offset;

    //
    // Get offset (from framebuffer) and add offset from surface:
    //

    offset = FlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + FlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here

    return DX_OK;
}


DWORD
FlipOverlay(
    PVOID HwDeviceExtension,
    PDDFLIPOVERLAYINFO FlipOverlayInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
BobNextField(
    PVOID HwDeviceExtension,
    PDDBOBNEXTFIELDINFO BobNextFieldInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
SetState(
    PVOID HwDeviceExtension,
    PDDSETSTATEININFO SetStateInInfo,
    PDDSETSTATEOUTINFO SetStateOutInfo
    )

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
SkipNextField(
    PVOID HwDeviceExtension,
    PDDSKIPNEXTFIELDINFO SkipNextFieldInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO GetPolarityInInfo,
    PDDGETPOLARITYOUTINFO GetPolarityOutInfo
    )

/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}

DWORD
GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PDDGETCURRENTAUTOFLIPININFO GetCurrentAutoflipInInfo,
    PDDGETCURRENTAUTOFLIPOUTINFO GetCurrentAutoflipOutInfo
    )

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PDDGETPREVIOUSAUTOFLIPININFO GetPreviousAutoflipInInfo,
    PDDGETPREVIOUSAUTOFLIPOUTINFO GetPreviousAutoflipOutInfo
    )

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


VP_STATUS
nvVPEQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    )

/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PDXAPI_INTERFACE DxApiInterface;
    VP_STATUS status;

    status = DXERR_UNSUPPORTED;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) {

        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = GetIrqInfo;
        DxApiInterface->DxEnableIrq           = EnableIrq;
        DxApiInterface->DxSkipNextField       = SkipNextField;
        DxApiInterface->DxBobNextField        = BobNextField;
        DxApiInterface->DxSetState            = SetState;
        DxApiInterface->DxFlipOverlay         = FlipOverlay;
        DxApiInterface->DxFlipVideoPort       = FlipVideoPort;
        DxApiInterface->DxGetPolarity         = GetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = GetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = GetPreviousAutoflip;

        status = DX_OK;
    }

    return status;
}

#endif /* VPE_NT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTFMATH.H ===
/*==========================================================================
;
; Copyright (C) 1999, Nvidia Corporation
;
; File:     gtf.h
;
; Purpose:  This file implements the GTF algorithm
==========================================================================*/

typedef struct  tagGTFIN
{
    ULONG   dwHPixels;
    ULONG   dwVLines;
    ULONG   dwMarginsRqd;
    ULONG   dwIntRqd;
    ULONG   dwIPParmType;
    ULONG   dwIPFreqRqd;
} GTFIN;

typedef GTFIN   FAR *LPGTFIN;

// The entire GTF based computation is based upon the variables provided
// in the GTFIN structure. They are defined as follows:
// HPixels      - the horizontal resolution in Pixels
// VLines       - the vertical resolution in scanlines
// MarginsRqd   - this is a flag -- TRUE if borders should be present
//                FALSE if they shouldn't be. Borders are also referred
//                to as the overscan area.
// IntRqd       - this is a flag -- TRUE if interlace mode is desired
//                FALSE if non-interlace mode is desired.
// IPParmType   - this indicates what the dwIPFreqRqd variables means.
//                assording to the following table.
//  If IPParm is this           IPFreqRqd is this
//  1                           vertical refresh rate in hz
//  2                           horizontal refresh rate in Khz
//  3                           pixel clock rate in Mhz

// These are the tree values that can be assumed by the
// dwIPParmType file din the GTFIN structure.
#define IPTYPE_VERTICAL_REFRESH_RATE    1
#define IPTYPE_HORIZONTAL_REFRESH_RATE  2
#define IPTYPE_PIXEL_CLOCK_RATE         3


typedef struct  tagGTFOUT
{
    ULONG   dwHTotalChars;
    ULONG   dwVTotalScans;
    ULONG   dwHActiveChars;
    ULONG   dwVActiveScans;
    ULONG   dwHBlankStartChar;
    ULONG   dwHFrontPorchChars;
    ULONG   dwHSyncChars;
    ULONG   dwHBackPorchChars;
    ULONG   dwHBlankEndChar;
    ULONG   dwVBlankStartScan;
    ULONG   dwVFrontPorchScans;
    ULONG   dwVSyncScans;
    ULONG   dwVBackPorchScans;
    ULONG   dwVBlankEndScan;
    ULONG   dwPixelClockIn10KHertz;
} GTFOUT;

typedef GTFOUT  FAR *LPGTFOUT;

// For those display devices which don't really need front and back
// porches, those fields can be ignored but they are always valid.


extern ULONG WINAPI ComputeGTFParameters(LPGTFIN lpGtfIn, LPGTFOUT lpGtfOut);
extern ULONG WINAPI Divide32By32(ULONG dwDividend, ULONG dwDivisor);
extern ULONG WINAPI Multiply32By32(ULONG dwMult1, ULONG dwMult2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTF.H ===
/*
    FILE:   gtf.h
    DATE:   4/8/99

    This file is the gtf find or set mode code.
*/

extern int CFUNC GtfFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\RESTIME.C ===
/*
    FILE:   restime.c
    DATE:   4/8/99

    This file holds code to process restriction and timing lists
    and also a few utility routines to get mode lists from the
    registry, etc.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "restime.h"
#include "debug.h"

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    ParseRTString

    This routine parses an R&T string given by szRTString into the
    RESTIME structure pointed to by lpRT. The function returns
    TRUE if the szRTString was a valid R&T string and parsed with
    no errors. Otherwise the routine returns FALSE.
*/
int CFUNC
ParseRTString (LPRESTIME lpRT, LPCHAR szRTString)
{
    int     nRet;
    ULONG   dwIndex;

    DBG_PRINT1(DL_5, "\r\nParsing R&T string %s", szRTString);

    // dwIndex is the offset into the szRTString we are currently looking at
    dwIndex = 0;

    // The first thing in an R&T string is the X-resolution. Make sure
    // it is there and get its value.
    if  (!ParseDecimalNumberComma (szRTString, &dwIndex, &(lpRT->dwXRes)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nXRes found to be %ld", lpRT->dwXRes);

    // The next thing in an R&T string is the Y-resolution. Make sure
    // it is there and get its value.
    if  (!ParseDecimalNumberComma (szRTString, &dwIndex, &(lpRT->dwYRes)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nYRes found to be %ld", lpRT->dwYRes);

    // The next thing in an R&T string is the pixel depth. This
    // is also allowed to be a wildcard indicating everything.
    if  (!ParseDecimalNumberOrWildcard (szRTString, &dwIndex, &(lpRT->dwPixelDepth)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nPixelDepth found to be %ld", lpRT->dwPixelDepth);

    // The next thing in an R&T string is the refresh rate. This
    // is also allowed to be a wildcard indicating everything.
    if  (!ParseDecimalNumberOrWildcard (szRTString, &dwIndex, &(lpRT->dwRefreshRate)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nRefreshRate found to be %ld", lpRT->dwRefreshRate);

    // The next thing in an R&T string is a dot separated list
    // of Device IDs.
    if  (!ParseDeviceIDs (szRTString, &dwIndex, lpRT->wDeviceID))
        return  (FALSE);

    // The next thing in an R&T string is a dot separated list
    // of Monitor IDs.
    if  (!ParseMonitorIDs (szRTString, &dwIndex, lpRT->dwMonitorID))
        return  (FALSE);

    // The next thing in an R&T string is a dot separated list
    // of Timing Standards.
    nRet = ParseTimingStandards (szRTString, &dwIndex, lpRT->dwTimingStandard);
    if  (!nRet)
        return  (FALSE);

    // If one of the timing standards was OEM, then there must be a set
    // of timing parameters in a MODEOUT format as the last thing in the
    // R&T string. We know if there was an OEM timing standard because
    // ParseTimingStandard returns a number greater than 1 if there was
    // an OEM timing standard listed.
    if  (nRet > 1)
    {
        // The timing parameter format is hexdigits;hexdigits; etc
        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHBlankStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHBlankStart found to be %lx", (ULONG) lpRT->sModeOut.wHBlankStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHBlankWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHblankWidth found to be %lx", (ULONG) lpRT->sModeOut.wHBlankWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHSyncStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHSyncStart found to be %lx", (ULONG) lpRT->sModeOut.wHSyncStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHSyncWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHSyncWidth found to be %lx", (ULONG) lpRT->sModeOut.wHSyncWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVBlankStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVBlankStart found to be %lx", (ULONG) lpRT->sModeOut.wVBlankStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVBlankWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHblankWidth found to be %lx", (ULONG) lpRT->sModeOut.wVBlankWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVSyncStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVSyncStart found to be %lx", (ULONG) lpRT->sModeOut.wVSyncStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVSyncWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVSyncWidth found to be %lx", (ULONG) lpRT->sModeOut.wVSyncWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHTotal)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nXTotal found to be %lx", (ULONG) lpRT->sModeOut.wHTotal);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVTotal)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nYTotal found to be %lx", (ULONG) lpRT->sModeOut.wVTotal);

        if  (!ParseHexDWord (szRTString, &dwIndex, &(lpRT->sModeOut.dwPixelClock)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nPixelClock found to be %lx", lpRT->sModeOut.dwPixelClock);

        if  (!ParseHexDWord (szRTString, &dwIndex, &(lpRT->sModeOut.dwFormat)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nFormat found to be %lx", lpRT->sModeOut.dwFormat);

        lpRT->sModeOut.wXRes = (USHORT) lpRT->dwXRes;
        lpRT->sModeOut.wYRes = (USHORT) lpRT->dwYRes;
        lpRT->sModeOut.wRefreshRate = (USHORT) lpRT->dwRefreshRate;
    }

    return  (TRUE);
}


/*
    ParseDecimalNumberComma

    This routine parses a field that can either be a decimal number
    or the wildcard character. Basically, if it isn't the wildcard
    character, then it is assumed to be a decimal number
    This routine parses a decimal number from the string passed in.
    It assigns it into lpNum. Upkn returning lpIndex is adjusted so
    that it points to the first char after the comma following the
    number parsed. If the number was bad, could not be found before
    the end of the string or before the next comma, FALSE is returned.
    If a number was found and everything is fine, TRUE is returned.
    in RESTIME structures of the array pointed to by lpRTList.
*/
int CFUNC
ParseDecimalNumberComma (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    return  (ParseDecimalSeparator (szRTString, lpIndex, lpNum, ',', ','));
}



/*
    ParseDecimalNumberOrWildcard

    This routine parses a field that can either be a decimal number
    or the wildcard character. Basically, if it isn't the wildcard
    character, then it is assumed to be a decimal number
    This routine parses a decimal number from the string passed in.
    It assigns it into lpNum. Upkn returning lpIndex is adjusted so
    that it points to the first char after the comma following the
    number parsed. If the number was bad, could not be found before
    the end of the string or before the next comma, FALSE is returned.
    If a number was found and everything is fine, TRUE is returned.
    in RESTIME structures of the array pointed to by lpRTList.
*/
int CFUNC
ParseDecimalNumberOrWildcard (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    if  (szRTString[*lpIndex] == ALL_WILDCARD)
    {
        *lpNum = ALL_WILDCARD;

        // If the next char is not immediately a comma, then error
        if  (szRTString[*lpIndex + 1] != ',')
        {
            DBG_PRINT1(DL_5, "\r\nComma not found after wildcard number in %s.", szRTString);
            return  (FALSE);
        }

        *lpIndex += 2;
    }
    else
    {
        // Not a wildcard, so parse a number
        if  (!ParseDecimalNumberComma (szRTString, lpIndex, lpNum))
            return  (FALSE);
    }

    return  (TRUE);
}



/*
    ParseDeviceIDs

    This routine parses a '.' separated list of DeviceIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each deviceID is assumed to be exactly four hex
    digits long. The alphabetic characters can be upper or lower case.
*/
int CFUNC
ParseDeviceIDs (LPCHAR szRTString, LPULONG lpIndex, LPUSHORT lpNum)
{
    int     nRet;
    ULONG   dwID, dwNum;

    // Set all the device IDs to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // The deviceID can be a WILDCARD char
        if  (szRTString[*lpIndex] == ALL_WILDCARD)
        {
            lpNum[dwID] = ALL_WILDCARD;
            *lpIndex += 1;
        }
        else
        {
            nRet = ParseHexSeparator (szRTString, lpIndex,
                                     &dwNum, 4, ',', '.');

            if  (!nRet)
            {
                DBG_PRINT1(DL_5, "\r\nBad DeviceID in %s", szRTString);
                return  (FALSE);
            }

            // We found a number!
            lpNum[dwID] = (USHORT) dwNum;

            // Backup pointer to put to separator.
            *lpIndex = *lpIndex - 1;
        }

        // If the next char is not either a '.' indicating another
        // deviceID follows, or a ',' indicating we are done with the
        // deviceID parsing, then there is a parse error.
        if  (szRTString[*lpIndex] == ',')
        {
            *lpIndex += 1;
            DBG_PRINT1(DL_5, "\r\nFound %ld DeviceIDs.", dwID + 1);
            return  (TRUE);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad DeviceID separator in %s", szRTString);
            return  (FALSE);
        }

        // Skip over the '.' and keep going for the next deviceID
        *lpIndex += 1;

    }

    DBG_PRINT1(DL_5, "\r\nFound %ld deviceIDs.", dwID + 1);
    return  (TRUE);
}


/*
    ParseMonitorIDs

    This routine parses a '.' separated list of MonitorIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each MonitorID is assumed to be exactly four byte
    characters long. An ALL_WILDCARD character is allowed.
*/
ULONG CFUNC
ParseIsHexChar (UCHAR c)
{
    if  ((c >= '0') && (c <= '9'))
        return  (c - '0');

    if  ((c >= 'A') && (c <= 'F'))
        return  ((c - 'A') + 10);
    
    if  ((c >= 'a') && (c <= 'f'))
        return  ((c - 'a') + 10);

    return  (0xFFFFFFFF);
}


/*
    ParseMonitorIDs

    This routine parses a '.' separated list of MonitorIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each MonitorID is assumed to be exactly four byte
    characters long. An ALL_WILDCARD character is allowed.
*/
int CFUNC
ParseMonitorIDs (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    ULONG   c1, c2;
    int     i;
    ULONG   dwID;

    // Set all the monitor IDs to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // The monitorID can be a WILDCARD char
        if  (szRTString[*lpIndex] == ALL_WILDCARD)
        {
            lpNum[dwID] = ALL_WILDCARD;
            *lpIndex += 1;
        }
        else
        {
            for (i = 0; i < 4; i++)
            {
                c1 = ParseIsHexChar(szRTString[*lpIndex + i * 2 + 0]);
                c2 = ParseIsHexChar(szRTString[*lpIndex + i * 2 + 1]);

                if  ((c1 == 0xFFFFFFFF) || (c2 == 0xFFFFFFFF))
    
                {
                    DBG_PRINT1(DL_5, "\r\nBad MonitorID in %s", szRTString);
                    return  (FALSE);
                }

                lpNum[dwID] |= ((c1 * 0x10) + c2) << (24 - i * 8);
            }

            *lpIndex += 8;
        }

        // If the next char is not either a '.' indicating another
        // monitorID follows, or a ',' indicating we are done with the
        // monitorID parsing, then there is a parse error.
        if  (szRTString[*lpIndex] == ',')
        {
            *lpIndex += 1;
            DBG_PRINT1(DL_5, "\r\nFound %ld monitorIDs.", dwID + 1);
            return  (TRUE);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad MonitorID separator in %s", szRTString);
            return  (FALSE);
        }

        // Skip over the '.' and keep going for the next monitorID
        *lpIndex += 1;
    }

    return  (TRUE);
}


/*
    ParseTimingStandards

    This routine parses a '.' separated list of Timing Standards. There
    can be up to MAX_DOT_FIELDS Timing Standards. Any more than this
    constitutes a parse error. Each Timing Standard is up to four
    characters long. The permissable ones are in restime.h

    Returns: 0 is returned if there was any parse error
             1 is returned if there were no parse errors but OEMN was
                 not one of the timing standards
             2 is returned if there were no parse errors and OEMN was
                 one of the timing standards.
*/
int CFUNC
ParseTimingStandards (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    ULONG   dwID, dwTS;
    int     nRet;

    nRet = 1;

    // Set all the Timing Standards to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // Make sure the next thing is a Timing Stndard
        dwTS = * ((LPULONG) (szRTString + *lpIndex));

        if  ((dwTS != NONE_ID) &&
             (dwTS != EDID_ID) &&
             (dwTS != DMTV_ID) &&
             (dwTS != DMTR_ID) &&
             (dwTS != GTFV_ID) &&
             (dwTS != GTFR_ID) &&
             (dwTS != OEMX_ID) &&
             (dwTS != OEMR_ID) &&
             (dwTS != FGTF_ID) &&
             (dwTS != FGTR_ID))
        {
            DBG_PRINT1(DL_5, "\r\nBad Timing Standard in %s", szRTString);
            return  (0);
        }

        if  ((dwTS == OEMX_ID) || (dwTS == OEMR_ID))
            nRet = 2;

        lpNum[dwID] = dwTS;
        *lpIndex += 4;

        // If the next char is not either a '.' indicating another
        // TimingStandard follows, or a ',' indicating we are done
        // with the TimingStandard parsing, then there is a parse error.
        if  ((szRTString[*lpIndex] == ',') || (szRTString[*lpIndex] == 0))
        {
            DBG_PRINT1(DL_5, "\r\nFound %ld Timing Standards.", dwID + 1);

            // If a comma follows, skip over it
            if  (szRTString[*lpIndex] == ',')
                *lpIndex += 1;

            return  (nRet);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad Timing Standard separator in %s", szRTString);
            return (0);
        }

        // Skip over the '.' and keep going for the next timing standard
        *lpIndex += 1;
    }

    return  (TRUE);
}




/*
    RTFindNextMatchingString

    This procedure finds a string in the RTList that matches all the
    parameters in the R&T string. This is board data, mode, and
    monitor id. It returns an index into the list. If no match is
    found, then RTERR_NOT_FOUND is returned.
*/

int CFUNC
RTFindNextMatchingString (
    LPRESTIME   lpRTList,
    int         nIndex,
    LPDISPDATA  lpDispData,
    LPRTMODE    lpRTMode,
    ULONG       dwMonitorID)
{
    int i, b;
    int bMatchDevice, bMatchMode, bMatchMonitor;

    if  ((ULONG) nIndex > lpRTList->dwXRes)
    {
        // The requested index of the string at which to begin
        // searching is larger than the total number of R&T
        // strings in the array. So return error.
        return  (RTERR_NOT_FOUND);
    }

    for  (i = nIndex; i <= (int) lpRTList->dwXRes; i++)
    {
        bMatchDevice  = FALSE;
        bMatchMode    = FALSE;
        bMatchMonitor = FALSE;
        for (b = 0; b < MAX_DOT_FIELDS; b++)
        {
            // Return index if there is a wildcard match
            if  (lpRTList[i].wDeviceID[b] == ALL_WILDCARD)
                bMatchDevice = TRUE;

            // Return index if there is an exact match
            if  (lpRTList[i].wDeviceID[b] == (USHORT) lpDispData->dwDeviceID)
                bMatchDevice = TRUE;
        }

        // Match on the mode
        if  ((lpRTList[i].dwXRes == lpRTMode->dwXRes) &&
             (lpRTList[i].dwYRes == lpRTMode->dwYRes) &&
             ((lpRTList[i].dwPixelDepth == ALL_WILDCARD) ||
              (lpRTList[i].dwPixelDepth == lpRTMode->dwBpp)) &&
             ((lpRTList[i].dwRefreshRate == ALL_WILDCARD) ||
              (lpRTList[i].dwRefreshRate == lpRTMode->dwRefreshRate)))
            bMatchMode = TRUE;

        for (b = 0; b < MAX_DOT_FIELDS; b++)
        {
            // Return success on a wildcard match
            if  (lpRTList[i].dwMonitorID[b] == ALL_WILDCARD)
                bMatchMonitor = TRUE;;

            // Return success on an exact match
            if  (lpRTList[i].dwMonitorID[b] == dwMonitorID)
                bMatchMonitor = TRUE;;
        }
        
        if  (bMatchDevice && bMatchMode & bMatchMonitor)
            return  (i);
    }

    return  (RTERR_NOT_FOUND);
}


/*
    RTRestrictByTimingStandard

    This procedure looks at the R&T string given by nIndex in the
    lpRTList and sees if there is a match on the TimingStandard given
    by dwTimingStandard. If there is, TRUE is returned, else FALSE is
    returned.
*/
int CFUNC
RTRestrictByTimingStandard (
    LPRESTIME   lpRTList,
    int         nIndex,
    ULONG       dwTimingStandard)
{
    int b;

    for (b = 0; b < MAX_DOT_FIELDS; b++)
        if  (lpRTList[1].dwTimingStandard[b] == dwTimingStandard)
            return  (TRUE);

    return  (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTF.C ===
/*
    FILE:   gtf.c
    DATE:   4/8/99

    This file is the generic entry point for the gtf modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "gtf.h"
#include "gtfmath.h"
#include "utils.h"

/*
    Function:   GtfFindMode

    Purpose:    This routine looks for a mode in the GTF list of modes.

    Arguments:  lpModeIn    ptr to MODEINFO structure
                lpModeOut   ptr to MODEOUT structure

    Returns:    Gtf is a formula based mode computation. Given a set
                of input parameters which describe the mode, the
                set of timing parameters to display the mode is
                computed.

                Hence, this routine always returns TRUE and lpModeOut
                is filled in with the corret timing parameters.

    Preserve:   Do not change any fields in lpModeIn.
*/

int CFUNC
GtfFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut)
{
    GTFIN       GTFIn;
    GTFOUT      GTFOut;
    MODESTRUC   sGTF;

    GTFIn.dwHPixels      = lpModeIn->dwXRes;
    GTFIn.dwVLines       = lpModeIn->dwYRes;
    GTFIn.dwMarginsRqd   = FALSE;
    GTFIn.dwIntRqd       = FALSE;
    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
    GTFIn.dwIPFreqRqd    = lpModeIn->dwRefreshRate;

    // Be careful of double scan modes. 512x384 needs to be calculated
    // as if it is 1024x768.
    if (lpModeIn->dwYRes < 400)
    {
        GTFIn.dwHPixels = (GTFIn.dwHPixels * 2);
        GTFIn.dwVLines  = (GTFIn.dwVLines  * 2);
    }

    // Get the timing parameters.
    ComputeGTFParameters(&GTFIn, &GTFOut);

    // Store all parameters in temporary MODESTRUC buffer. Note that
    // horizontal GTF parameters are returned in character clocks and
    // need to be converted to pixels.
    sGTF.wHorizVisible    = (USHORT) (GTFOut.dwHActiveChars << 3);
    sGTF.wVertVisible     = (USHORT) GTFOut.dwVActiveScans;
    sGTF.wRefresh         = (USHORT) lpModeIn->dwRefreshRate;
    sGTF.wHorizTotal      = (USHORT) (GTFOut.dwHTotalChars << 3);
    sGTF.wHorizBlankStart = (USHORT) (GTFOut.dwHBlankStartChar << 3);
    sGTF.wHorizSyncStart  = (USHORT) ((GTFOut.dwHBlankStartChar
                                     + GTFOut.dwHFrontPorchChars) << 3);
    sGTF.wHorizSyncEnd    = (USHORT) (sGTF.wHorizSyncStart
                                     + (GTFOut.dwHSyncChars << 3));
    sGTF.wHorizBlankEnd   = (USHORT) (GTFOut.dwHBlankEndChar << 3);
    sGTF.wVertTotal       = (USHORT) GTFOut.dwVTotalScans;
    sGTF.wVertBlankStart  = (USHORT) GTFOut.dwVBlankStartScan;
    sGTF.wVertSyncStart   = (USHORT) (GTFOut.dwVBlankStartScan
                                     + GTFOut.dwVFrontPorchScans);
    sGTF.wVertSyncEnd     = (USHORT) (sGTF.wVertSyncStart
                                     + GTFOut.dwVSyncScans);
    sGTF.wVertBlankEnd    = (USHORT) GTFOut.dwVBlankEndScan;
    sGTF.wDotClock        = (USHORT) GTFOut.dwPixelClockIn10KHertz;
    sGTF.wHSyncPolarity   = BUFFER_HSYNC_NEGATIVE;
    sGTF.wVSyncPolarity   = BUFFER_VSYNC_POSITIVE;

    // Be careful of double scan modes. Need to reduce the horizontals and
    // pixel clock by half since the GTF calculations were done with
    // GTFIn.dwHPixels and GTFIn.dwVLines doubled. All verticals except
    // VertVisible remain the same.
    if (lpModeIn->dwYRes < 400)
    {
        // Add 1 to account for rounding off--otherwise values will
        // be truncated.
        sGTF.wHorizVisible    = ((sGTF.wHorizVisible + 1)/2);
        sGTF.wVertVisible     = ((sGTF.wVertVisible + 1)/2);
        sGTF.wHorizTotal      = ((sGTF.wHorizTotal + 1)/2);
        sGTF.wHorizBlankStart = ((sGTF.wHorizBlankStart + 1)/2);
        sGTF.wHorizSyncStart  = ((sGTF.wHorizSyncStart + 1)/2);
        sGTF.wHorizSyncEnd    = ((sGTF.wHorizSyncEnd + 1)/2);
        sGTF.wHorizBlankEnd   = ((sGTF.wHorizBlankEnd + 1)/2);
        sGTF.wDotClock        = ((sGTF.wDotClock + 1)/2);
    }

    // Convert to final output format
    SetupParamsForVidLutClass (&sGTF, lpModeOut, lpModeIn);

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\tvmode.c ===
/*
    FILE:   tvmode.c
    DATE:   4/8/99

    This file contains the high level logic for the tv modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "tvmode.h"
#include "dmt.h"
#include "gtf.h"

extern int CFUNC IsTvModeAccepted (LPDISPDATA lpDispData,
                                   LPMODEINFO lpModeDesc, LPRESTIME lpRTList);

extern int CFUNC SetupParamsForVidLutClass (LPMODESTRUC         lpMS,
                                            LPMODEOUT           lpModeOut,
                                            LPMODEINFO          lpModeIn);

/*
    FindTVModeEntry

    Timing info for NTSC and PAL modes is always DMT. The thing
    to remember here is that both are restricted to be 800x600
    or less.
*/

int CFUNC
FindTVModeEntry (
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEENTRY lpModeList,
    LPRESTIME   lpRTList)
{
    int         nRet, nIsNtsc;
    ULONG       MaxXRes;
    ULONG       MaxYRes;
    MODEINFO    ModeDesc;

    // Copy to a local
    MaxXRes = (lpDispData->dwMaxTVOutResolution >> 16) & 0xffff;
    MaxYRes = lpDispData->dwMaxTVOutResolution & 0xffff;
    ModeDesc = lpModeDesc[0];

    // Since this is a TV, which is a fixed frequency device, force the
    // refresh rate to appropriate refresh rate.
    if  ((lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCM) ||
         (lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCJ))
        nIsNtsc = TRUE;
    else
        nIsNtsc = FALSE;


    if  (nIsNtsc)
    {
        ModeDesc.dwRefreshRate = 60;
    }
    else
    {
        // 60 Hz works, 50 Hz doesn't (on Bt869), don't know why
        ModeDesc.dwRefreshRate = 60;
    }

    // Set this up
    nRet = MODE_EXACT_MATCH;

    // If the input resolution is greater than 800x600,
    // then drop it to 800x600.
    if  ((ModeDesc.dwXRes > MaxXRes) || (ModeDesc.dwYRes > MaxYRes))
    {
        ModeDesc.dwXRes = MaxXRes;
        ModeDesc.dwYRes = MaxYRes;
        nRet |= MODE_RESOLUTION_ADJUSTED;
    }

    do
    {
        // Start with the current mode. See if we can set this mode.
        // To do this, we process the RTList and see if this mode is
        // allowed or restricted in some way. At the time of this
        // writing the only way to restrict a TV mode is if there is
        // a NONE in the TimingStandard field of an R&T string. Then
        // the mode is rejected. Let's see if this happens with the
        // requested mode.
        if  (IsTvModeAccepted (lpDispData, &ModeDesc, lpRTList))
        {
            // Great! Return appropriately.
            if  (!DmtFindMode (&ModeDesc, lpModeOut))
            {
                // Bt 868/9
                MODESTRUC ntscModeBt = {720,512,60,870,720,770,820,870,525,512,518,520,525,2738,
                                        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                MODESTRUC palModeBt = {720,544,60,840,720,770,820,840,550,544,546,548,550,2775,
                                       BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                // Chrontel 7007/8
                MODESTRUC ntscModeChrontel = {720,576,60,880,720,760,840,880,597,576,585,588,597,3150,
                                              BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                MODESTRUC palModeChrontel = {720,576,60,880,720,760,840,880,597,576,585,588,597,3150,
                                             BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};

                MODESTRUC *pNtscMode, *pPalMode, *pMode;
                switch (lpDispData->dwTVEncoderType & 0xFF00) {
                case TV_ENCODER_BROOKTREE:
                    pNtscMode = &ntscModeBt;
                    pPalMode = &palModeBt;
                    break;
                case TV_ENCODER_CHRONTEL:
                default:
                    pNtscMode = &ntscModeChrontel;
                    pPalMode = &palModeChrontel;
                    break;
                }

                pMode = nIsNtsc ? pNtscMode : pPalMode;

                // safe mode is 720x480 on NTSC, or 720x576 on PAL
                SetupParamsForVidLutClass (pMode, lpModeOut, lpModeDesc);
	        if(lpModeOut->wXRes != lpModeDesc->dwXRes)
	            nRet |= MODE_RESOLUTION_ADJUSTED;
            }
            return  (nRet);
        }

        // The TV mode wasn't accepted. Go to the registry mode
        // list and get the next lower resolution mode at the
        // pixel depth requested. We shall try that for the TV.
        nRet |= MODE_RESOLUTION_ADJUSTED;

        if  (!FindNextSmallerResolution (lpModeList, &ModeDesc))
        {
            // OK, if this doesn't happen, then we are already at
            // the losest mode available. Use a safe setting.
            DBG_PRINT0(DL_0, "\r\nNo lower resolution found.");
            DBG_PRINT0 (DL_0, "\r\nFailing TV Timing Standards. Use Safe Settings.");
            nRet = GetSafeTiming (lpModeDesc, lpModeOut);
            return  (nRet);
        }
    }
    while (TRUE);
}


/*
    IsTvModeAccepted

    This routine determines whether the mode in lpModeDesc is
    a valid TV mode (PAL or NTSC as determined by lpModeDesc->dwDevType.)
*/
int CFUNC
IsTvModeAccepted (
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPRESTIME   lpRTList)
{
    int     nIndex, nIsNtsc;
    RTMODE  sRTMode;
    ULONG   dwMonitorID;

    // Start with the first restriction string
    nIndex = 1;

    if  ((lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCM) ||
         (lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCJ))
        nIsNtsc = TRUE;
    else
        nIsNtsc = FALSE;

    do
    {
        // There is an R&T string for this graphics board.
        // Does this string also match the mode requested?
        sRTMode.dwXRes = lpModeDesc->dwXRes;
        sRTMode.dwYRes = lpModeDesc->dwYRes;
        sRTMode.dwBpp  = lpModeDesc->dwBpp;
        sRTMode.dwRefreshRate = lpModeDesc->dwRefreshRate;


	// Reject the modes 720x576 & 720x480 for unsupported encoders
	if  ((lpDispData->dwTVEncoderType & 0xFF00) != TV_ENCODER_BROOKTREE &&
         (lpDispData->dwTVEncoderType & 0xFF00) != TV_ENCODER_CHRONTEL &&
	      sRTMode.dwXRes == 720)
		return  (FALSE);

        if  (nIsNtsc)
	{
            dwMonitorID = NTSC_ID;

	    // Reject 720x576 for NTSC
//	    if(sRTMode.dwXRes == 720 && sRTMode.dwYRes == 576)
//		return  (FALSE);
	}
        else
	{
            dwMonitorID = PALX_ID;

	    // Reject 720x480 for PAL
//	    if(sRTMode.dwXRes == 720 && sRTMode.dwYRes == 480)
//		return  (FALSE);
	}

        // Find a restriction string that matches the board data.
        nIndex = RTFindNextMatchingString (lpRTList, nIndex,
                    lpDispData, &sRTMode, dwMonitorID);

        if  (nIndex == RTERR_NOT_FOUND)
        {
            // If there were no R&T strings found for the graphics board
            // installed, then the mode is OK.
            return  (TRUE);
        }

        // See if there is a NONE entry in the TimingStandard
        // Field. If there isn't then the mode is OK
        if  (RTRestrictByTimingStandard (lpRTList, nIndex, NONE_ID))
            return  (FALSE);

        // This R&T string did not prohibit this mode. However,
        // since there might be another R&T string that restricts
        // NTSC or PAL, we continue with the rest of the RTList.
        nIndex++;
    }
    while   (nIndex <= (int) lpRTList[0].dwXRes);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\MODESET.C ===
/*
    FILE:   modeset.c
    DATE:   4/8/99

    This file is the generic entry point for the modeset code.
    It contains all the high level logic when modesetting.

    The main entry point is
    FindModeEntry (lpDispData,lpEdidBuffer,dwEdidSize,lpModeDesc,lpModeOut);

    You should consult the header for FindModeEntry for specific details
    about the arguments.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "tvmode.h"
#include "digmode.h"
#include "dmt.h"
#include "osapi.h"
#include "utils.h"

char    szDebug[512];
ULONG   dwDebugLevel = 0;

/*
    Function:   FindModeEntry

    Purpose:

    This routine validates and/or sets the mode. General idea:

    1) For NTSC and PAL devices, the requested mode is compared
       against the restriction list and the master mode list.
       The resolution is adjusted downward as necessary to find
       a mode that is allowed. If no mode is found that is
       permitted, the safe timing is returned.
       MODE_RESOLUTION_ADJUSTED is the actual return value if
       the mode timings returned are not for the mode that was
       requested.

       For NTSC and PAL, the only relevant input fields are:
       lpDispData (all fields), lpEdidBuffer should be NULL,
       dwEdidSize should be 0, lpModeDesc->nXRes, lpModeDesc->nYRes,
       lpModeDesc->nBpp, lpModeDesc->dwDevType should be DEVTYPE_NTSC
       or DEVTYPE_PAL as appropriate.

       On Exit, lpModeOut->rXRes and lpModeOut->rYRes will be assigned
       with the "best fit" mode that can be set. If you are validating
       an NTSC or PAL mode, then if this routine returns anything
       except MODE_EXACT_MATCH, the mode did not validate.

    2) For CRT and PANEL devices, the requested mode is compared
       against the restriction list and the master mode list.
       If necessary, first the refresh rate and as a last resort
       the resolution can be adjusted downward to find a mode that
       is allowed. If no mode is found that is permitted, a set of
       safe settings for some default mode is returned.

       For CRT and PANEL, the only relevant input fields are:
       lpDispData (all fields), lpEdidBuffer should point to a
       valid EDID if the device has one -- otherwise it shoud be NULL,
       dwEdidSize should be the size of the EDID in bytes -- otherwise
       it should be 0, lpModeDesc->nXRes, lpModeDesc->nYRes,
       lpModeDesc->nBpp, lpModeDesc->dwRefreshRate, lpModeDesc->dwDevType
       should be DEVTYPE_CRT or DEVTYPE_PANEL as appropriate,
       lpModeDesc->dwRefreshRate is a specific refresh rate value.

       For CRT and PANEL, the only possible return values are:
       MODE_RESOLUTION_ADJUSTED, MODE_REFRESH_RATE_ADJUSTED,
       or MODE_RESOLUTION_ADJUSTED | MODE_REFRESH_RATE_ADJUSTED.
       This flavor of the routine can NEVER fail. The lpModeOut
       structure should be filled out in its entirety -- all fields
       need to have describe a coherent valid timing. No exceptions.

    Arguments:
        LPDISPDATA      lpDispData
        LPCHAR          lpEdidBuffer
        ULONG           dwEdidSize
        LPMODEINFO      lpModeDesc
        LPMODEOUT       lpModeOut

    Preserve:   Do not change any fields in any of the arguments except
                to pass back the actual mode that was set in lpModeOut.
*/

int WINAPI
FindModeEntry (
    LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew)
{
    int         nRet;
    LPRESTIME   lpRTList;
    LPMODEENTRY lpModeList;
    MODEINFO    ModeDesc;
    ULONG       dwModeSize;

    // Dump out what we are searching for
    DBG_PRINT0(DL_0, "\r\nSearching to match the following mode:");
    DBG_PRINT1(DL_0, "\r\nXRes           = %ld", lpModeDesc->dwXRes);
    DBG_PRINT1(DL_0, "\r\nYRes           = %ld", lpModeDesc->dwYRes);
    DBG_PRINT1(DL_0, "\r\nBpp            = %ld", lpModeDesc->dwBpp);
    DBG_PRINT1(DL_0, "\r\nRefreshRate    = %ld", lpModeDesc->dwRefreshRate);
    DBG_PRINT1(DL_0, "\r\ndwDevType      = %ld", lpModeDesc->MIDevData.cType);

    DBG_PRINT0(DL_0, "\r\n\nFor the following board:");
    DBG_PRINT1(DL_0, "\r\nDeviceID                = %lx", lpDispData->dwDeviceID);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz8bpp  = %lx", lpDispData->dwMaxDacSpeedInHertz8bpp);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz16bpp = %lx", lpDispData->dwMaxDacSpeedInHertz16bpp);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz32bpp = %lx", lpDispData->dwMaxDacSpeedInHertz32bpp);
    DBG_PRINT1(DL_0, "\r\nVideoMemorySize         = %lx", lpDispData->dwVideoMemoryInBytes);

    // Grab the restriction and timing list
    lpRTList = GetMasterRTList (lpDispData);

    // Next, grab the mode list
    lpModeList = GetMasterModeList (lpDispData);

    // Let's assign this to a local so we can change it if we need
    // to without affecting the source.
    ModeDesc = lpModeDesc[0];

    // Let's handle the NTSC/PAL cases here, and be done with them.
    if  (lpModeDesc->MIDevData.cType == DEVTYPE_TV)
    {
        DBG_PRINT0 (DL_0, "\r\nDevice type is NTSC or PAL.");
        nRet = FindTVModeEntry (lpDispData, &ModeDesc, lpModeOut,
                                lpModeList, lpRTList);
    }
    else
    {
        // At this point, we know we are a CRT or FLAT PANEL.
        DBG_PRINT0 (DL_0, "\r\nDevice type is CRT or FLAT PANEL.");

        nRet = FindDigModeEntry (lpEdidBuffer, dwEdidSize, lpDispData,
                          &ModeDesc, lpModeOut, lpModeList, lpRTList);
    }

    // We need to set the pitch in the MODEOUT
    GetPitchAndSize (lpDispData, ModeDesc.dwXRes, ModeDesc.dwYRes,
                ModeDesc.dwBpp, &(lpModeOut->dwPitchInBytes), &dwModeSize);

    // Convert the MODEOUT structure back into a MODEINFO structure
    SetupParamsForModeInfo (lpModeOut, &ModeDesc, lpModeNew);

    FreeMasterRTList (lpRTList);
    FreeMasterModeList (lpModeList);

    return  (nRet);
}


/*
    Function:   FindVirtualModeEntry

    Purpose:

    This routine validates modes just against the amount of memory
    they will consume.No checking is done to see if the mode is
    settable on a CRTC or to get timing parameters for the mode.

    If the mode does not fit in the size specified, the mode is
    backed off progressively in resolution until it will fit.

    Arguments:
                lpRegData       LPREGDATA
                lpModeToTest    LPMODEINFO desribing the mode we want to
                                start out with
                lpModeThatFit   This will hold the mode that actually
                                will fit in dwAvailableMemory. It might
                                be the same as lpModeToTest.
                dwAvailableMemory memory available for the mode
                pfnGetModeMemory  Callback function to get the amount
                                of memory a mode takes up
                dwContext1      data to be passed into callback
                dwContext2      data to be passed into callback

        The format of the callback is:
        pfnGetModeMemory (dwContext1, dwContext2, xres, yres, bpp)
        It returns a ULONG that specifies the memory required to set
        the mode.

    Returns:    TRUE
    Preserve:
*/
typedef int (WINAPI *PFNGETMODEMEMORY) (ULONG, ULONG, ULONG, ULONG, ULONG);

int WINAPI
FindVirtualModeEntry (LPDISPDATA lpDispData, LPMODEINFO lpModeToTest,
                      LPMODEINFO lpModeThatFit, ULONG dwAvailableMemory)
{
    LPMODEENTRY lpModeList;
    ULONG       dwModeMemory, dwPitch;

    // Next, grab the mode list
    lpModeList = GetMasterModeList (lpDispData);

    // Let's assign this to a local so we can change it if we need
    // to without affecting the source.
    *lpModeThatFit = *lpModeToTest;

    do
    {
        GetPitchAndSize (lpDispData, lpModeThatFit->dwXRes,
                        lpModeThatFit->dwYRes, lpModeThatFit->dwBpp,
                        &dwPitch, &dwModeMemory);

        if  (dwModeMemory <= dwAvailableMemory)
            break;
    }
    while   (BackOffDigModeEntry (lpModeList, lpModeThatFit, lpModeToTest, 0));

    // Free this up
    FreeMasterModeList (lpModeList);

    return  (TRUE);
}


/*
    Function:   FindNextSmallerResolution

    Purpose:    This routine finds the next lower resolution at the
                same refresh rate and pixel depth as requested. If
                it finds one, it modifies lpModeDesc to reflect the
                new mode and returns TRUE, else it returns FALSE.

                There are certain modes that the other code in the
                modeset DLL will accept if they are received exactly
                as requested, but which we will never "back off" to
                reach. These modes are the non-desktop modes --
                things like modes smaller.than 640x480 and also the
                960x720 mode for DirectX. These modes will not be
                "found" as next smaller resolutions.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/
int CFUNC
FindNextSmallerResolution (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeSmaller;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next smaller spatial resolution mode in lpModeList
    // that is at the same pixel depth. Smaller mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    // Set up the smaller mode to be 0 initially
    ModeSmaller.dwXRes = 0;
    ModeSmaller.dwYRes = 0;

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes >= 640) &&
             (lpModeList[i].dwYRes >= 480) &&
             (lpModeList[i].dwXRes != 960) &&
             (((lpModeList[i].dwXRes <= ModeIn.dwXRes) && (lpModeList[i].dwYRes <  ModeIn.dwYRes)) ||
              ((lpModeList[i].dwXRes < ModeIn.dwXRes) && (lpModeList[i].dwYRes <=  ModeIn.dwYRes)) ||
              ((lpModeList[i].dwXRes * lpModeList[i].dwYRes) < (ModeIn.dwXRes * ModeIn.dwYRes))))
        {
            // The lpModeList resolution is smaller. But is it the
            // largest of the smaller modes? Remember we are looking
            // for the next immediate smaller mode.
            if  ((ModeSmaller.dwXRes < lpModeList[i].dwXRes) ||
                 ((ModeSmaller.dwXRes == lpModeList[i].dwXRes) &&
                  (ModeSmaller.dwYRes <  lpModeList[i].dwYRes)))
            {
                ModeSmaller.dwXRes = lpModeList[i].dwXRes;
                ModeSmaller.dwYRes = lpModeList[i].dwYRes;
                ModeSmaller.dwBpp  = lpModeList[i].dwBpp;
                ModeSmaller.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            }
        }
    }

    if  (ModeSmaller.dwXRes != 0)
    {
        ModeSmaller.MIDevData.cType = lpModeDesc->MIDevData.cType;
        lpModeDesc[0] = ModeSmaller;
        return  (TRUE);
    }

    return  (FALSE);
}


/*
    FindNextSmallerRefreshRate

    Purpose:    This routine finds the next lower refresh rate at
                the same resolution and pixel depth as requested.
                If it finds one, it modifies lpModeDesc to reflect
                the new mode and returns TRUE, else it returns FALSE.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/

int CFUNC
FindNextSmallerRefreshRate (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeSmaller;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next smaller spatial resolution mode in lpModeList
    // that is at the same pixel depth. Smaller mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    // Set up the smaller mode to be 0 initially
    ModeSmaller.dwRefreshRate = 0;

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes == ModeIn.dwXRes) &&
             (lpModeList[i].dwYRes == ModeIn.dwYRes) &&
             (lpModeList[i].dwRefreshRate < ModeIn.dwRefreshRate))
        {
            // The lpModeList refreshRate is smaller. But is it the
            // largest of the smaller modes? Remember we are looking
            // for the next immediate smaller mode.
            if  ((ModeSmaller.dwRefreshRate < lpModeList[i].dwRefreshRate))
            {
                ModeSmaller.dwXRes = lpModeList[i].dwXRes;
                ModeSmaller.dwYRes = lpModeList[i].dwYRes;
                ModeSmaller.dwBpp  = lpModeList[i].dwBpp;
                ModeSmaller.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            }
        }
    }

    if  (ModeSmaller.dwRefreshRate != 0)
    {
        ModeSmaller.MIDevData.cType = lpModeDesc->MIDevData.cType;
        lpModeDesc[0] = ModeSmaller;
        return  (TRUE);
    }

    return  (FALSE);
}


/*
    FindNextLargerRefreshRate

    Purpose:    This routine finds the next higher refresh rate at
                the same resolution and pixel depth as requested.
                If it finds one, it modifies lpModeDesc to reflect
                the new mode and returns TRUE, else it returns FALSE.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/

int CFUNC
FindNextLargerRefreshRate (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeLarger;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next larger spatial resolution mode in lpModeList
    // that is at the same pixel depth. Larger mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes == ModeIn.dwXRes) &&
             (lpModeList[i].dwYRes == ModeIn.dwYRes) &&
             (lpModeList[i].dwRefreshRate > ModeIn.dwRefreshRate))
        {
            // The lpModeList refreshRate is larger.
            ModeLarger.dwXRes = lpModeList[i].dwXRes;
            ModeLarger.dwYRes = lpModeList[i].dwYRes;
            ModeLarger.dwBpp  = lpModeList[i].dwBpp;
            ModeLarger.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            ModeLarger.MIDevData.cType = lpModeDesc->MIDevData.cType;
            lpModeDesc[0] = ModeLarger;
            return  (TRUE);
        }
    }

    return  (FALSE);
}


/*
    Function:   GetSafeTiming

    Purpose:    This routine returns a "safe" set of timings for
                a special default mode. At the time this was
                written, that was 640x480 @ 60Hz DMT timing.

    Arguments:
                lpModeOrig  ptr to MODEINFO -- requested mode
                lpModeOut   ptr to MODEOUT  -- place to store
                            timings for safe mode

    Returns:    This routine returns the difference betweeen the
                mode specified by lpModeDesc and the mode
                specified by lpModeOut as logical ORs of the
                flags in modeext.h.
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
*/
int WINAPI
GetSafeTiming (LPMODEINFO lpModeOrig, LPMODEOUT lpModeOut)
{
    MODEINFO    ModeDesc;

    DBG_PRINT0(DL_0, "\r\nEntering GetSafeTiming.");

    ModeDesc.dwXRes = 640;
    ModeDesc.dwYRes = 480;
    ModeDesc.dwBpp  = lpModeOrig->dwBpp;
    ModeDesc.dwRefreshRate = 60;
    ModeDesc.MIDevData.cType = lpModeOrig->MIDevData.cType;
    ModeDesc.dwOriginalRefreshRate = lpModeOrig->dwOriginalRefreshRate;

    // Account for case where pixel depth is 24-bit which is not supported.
    if  (lpModeOrig->dwBpp == 24)
        ModeDesc.dwBpp  = 16;

    DmtFindMode (&ModeDesc, lpModeOut);

    return  (GetModeFlags (lpModeOrig, &ModeDesc));
}


/*
    Function:   GetModeFlags

    Purpose:    This routine computes the difference betweeen the
                mode specified by lpModeOrig and the mode
                specified by lpModeFound as logical ORs of the
                flags in modeext.h.

    Purpose:    This routine returns a "safe" set of timings for
                a special default mode. At the time this was
                written, that was 640x480 @ 60Hz DMT timing.

    Arguments:
                lpModeDesc  ptr to MODEINFO -- requested mode
                lpModeOut   ptr to MODEOUT  -- place to store
                            timings for safe mode

    Returns:    This routine returns the difference betweeen the
                mode specified by lpModeOrig and the mode
                specified by lpModeFound as logical ORs of the
                flags in modeext.h.
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
*/
int CFUNC
GetModeFlags (LPMODEINFO lpModeOrig, LPMODEINFO lpModeFound)
{
    int     nRet;

    // Figure out how the input mode differs from the safe mode and
    // return flags indicating the differences.
    nRet = 0;

    if  ((lpModeOrig->dwXRes != lpModeFound->dwXRes) ||
         (lpModeOrig->dwYRes != lpModeFound->dwYRes))
        nRet |= MODE_RESOLUTION_ADJUSTED;

    if  (lpModeOrig->dwRefreshRate != lpModeFound->dwRefreshRate)
        nRet |= MODE_REFRESH_RATE_ADJUSTED;

    if  (lpModeOrig->dwBpp != lpModeFound->dwBpp)
        nRet |= MODE_PIXEL_DEPTH_ADJUSTED;

    return  (nRet);
}


/*
    FormatModeList

    This routine parses the passed in modelist into the desired
    mode structure format.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
FormatModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType, LPMODEENTRY lpME)
{
    int         j;
    ULONG       dwModeSize;

    switch  (dwType)
    {
        case MODETYPE_MODEENTRY:
        {
            LPMODEENTRY lpDst;
            lpDst = (LPMODEENTRY) lpModes;

            // Just copy the list if they provide a ptr
            // If not, at least count the items
            for (j = 0; lpME[j].dwXRes != 0; j++)
                if  (lpDst)
                    lpDst[j] = lpME[j];

            break;
        }

        case MODETYPE_MODEENTRYNORR:
        {
            // Only one mode per refresh rate

            int             k, l;
            int             nDuplicate;
            LPMODEENTRYNORR lpDst;

            lpDst = (LPMODEENTRYNORR) lpModes;
            j = 0;

            for (k = 0; lpME[k].dwXRes != 0; k++)
            {
                nDuplicate = FALSE;

                for (l = 0; l < j; l++)
                {
                    if  ((lpDst[l].dwXRes == lpME[k].dwXRes) &&
                         (lpDst[l].dwYRes == lpME[k].dwYRes) &&
                         (lpDst[l].dwBpp  == lpME[k].dwBpp))
                    {
                        nDuplicate = TRUE;
                        break;
                    }
                }

                if  (!nDuplicate)
                {
                    // Copy the entry if it is a valid ptr.
                    // Otherwise just count them.
                    if  (lpDst)
                    {
                        lpDst[j].dwXRes = lpME[k].dwXRes;
                        lpDst[j].dwYRes = lpME[k].dwYRes;
                        lpDst[j].dwBpp  = lpME[k].dwBpp;
                    }
                    j++;
                }
            }
            break;
        }

        case MODETYPE_MODEENTRYANDPITCH:
        {
            // We don't actually fill in the pitch here, but
            // we use the correct structure so that the caller can.
            // Only one mode per refresh rate

            int                 k, l;
            int                 nDuplicate;
            LPMODEENTRYANDPITCH lpDst;

            lpDst = (LPMODEENTRYANDPITCH) lpModes;
            j = 0;

            for (k = 0; lpME[k].dwXRes != 0; k++)
            {
                nDuplicate = FALSE;

                for (l = 0; l < j; l++)
                {
                    if  ((lpDst[l].dwXRes == lpME[k].dwXRes) &&
                         (lpDst[l].dwYRes == lpME[k].dwYRes) &&
                         (lpDst[l].dwBpp  == lpME[k].dwBpp))
                    {
                        nDuplicate = TRUE;
                        break;
                    }
                }

                if  (!nDuplicate)
                {
                    // Copy the entry if it is a valid ptr.
                    // Otherwise just count them.
                    if  (lpDst)
                    {
                        lpDst[j].dwXRes  = lpME[k].dwXRes;
                        lpDst[j].dwYRes  = lpME[k].dwYRes;
                        lpDst[j].dwBpp   = lpME[k].dwBpp;
                        GetPitchAndSize (lpDispData, lpME[k].dwXRes,
                                    lpME[k].dwYRes, lpME[k].dwBpp,
                                    &(lpDst[j].dwPitch), &dwModeSize);
                    }
                    j++;
                }
            }
            break;
        }
    }

    return  (j);
}


/*
    GetModeList

    This routine gets the master mode list and returns it.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
GetModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType)
{
    LPMODEENTRY lpME;
    int         j;

    lpME = GetMasterModeList (lpDispData);

    j = FormatModeList (lpDispData, lpModes, dwType, lpME);

    FreeMasterModeList (lpME);
    return  (j);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTFMATH.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtf.asm
;
; Purpose:      This file implements the GTF algorithm
;
;       Just come important comments and definitions I extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
.586
include macros.dat
include gtfmath.inc

.listall

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, USE32, CODE

fZeroPointFour                  REAL4   0.4
fZeroPointFive                  REAL4   0.5
fOne                            REAL4   1.0
fOnePointEight                  REAL4   1.8
fTwo                            REAL4   2.0
fThree                          REAL4   3.0
fEight                          REAL4   8.0
fTwenty                         REAL4   20.0
fForty                          REAL4   40.0
fOneHundred                     REAL4   100.0
fOneHundredTwentyEight          REAL4   128.0
fTwoHundredFiftySix             REAL4   256.0
fFiveHundredFifty               REAL4   550.0
fSixHundred                     REAL4   600.0
fOneThousand                    REAL4   1000.0
fOneMillion                     REAL4   1000000.0

;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    lpGTFIn         FAR ptr to GTFIN structure
;               lpGTFOut        FAR ptr to GTFOUT structure
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
IFDEF  _WIN32
DECPROC ComputeGTFParameters, STANDARD, FRAME, NEAR
ELSE
DECPROC ComputeGTFParameters, PASCAL, FRAME, FAR16
ENDIF
PARMD   lpGTFIn
PARMD   lpGTFOut
OPENPROC
        PUSHR   ds,ebx,esi,edi
IFDEF _WIN32
        mov     ebx,lpGTFIn
        mov     esi,lpGTFOut
ELSE
        sub     ebx,ebx
        lds     bx,lpGTFIn
        sub     esi,esi
        les     si,lpGTFOut
ENDIF
        call    ComputeGTFParameters1
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     ComputeGTFParameters1
;
; Purpose:      This function computes the data for the GTFOut structure
;               from teh arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    ds:ebx  GTFIN ptr
;               es:esi  GTFOUT ptr
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
DECPROC ComputeGTFParameters1, PASCAL, FRAME, NEAR
LOCALD  dwTemp
LOCALR4 fVLinesRnd
LOCALR4 fAddrLinesPerFrame
LOCALR4 fCellGran
LOCALR4 fPixelFreq
LOCALR4 fCharTime
LOCALR4 fTopMarginLines
LOCALR4 fBottomMarginLines
LOCALR4 fVSyncPlusBackPorch
LOCALR4 fMinPorch
LOCALR4 fInterlace
LOCALR4 fTotalLinesPerFrame
LOCALR4 fTotalPixels
LOCALR4 fTotalHTimeChars
LOCALR4 fHPixelsRnd
LOCALR4 fHAddrTime
LOCALR4 fHAddrTimeChars
LOCALR4 fHBlankPixels
LOCALR4 fHBlank
LOCALR4 fHBlankChars
LOCALR4 fLeftMarginPixels
LOCALR4 fRightMarginPixels
LOCALR4 fHBlankPlusMargin
LOCALR4 fHBlankPlusMarginChars
LOCALR4 fActualDutyCycle
LOCALR4 fBlankPlusMarginDutyCycle
LOCALR4 fLeftMargin
LOCALR4 fLeftMarginChars
LOCALR4 fRightMargin
LOCALR4 fRightMarginChars
LOCALR4 fHSyncPercent
LOCALR4 fHSyncPixels
LOCALR4 fHFrontPorchPixels
LOCALR4 fHBackPorchPixels
LOCALR4 fHSyncChars
LOCALR4 fHSync
LOCALR4 fHFrontPorchChars
LOCALR4 fHFrontPorch
LOCALR4 fHBackPorchChars
LOCALR4 fHBackPorch
LOCALR4 fTotalVLines
LOCALR4 fHPeriod
LOCALR4 fVFramePeriod
LOCALR4 fVFieldPeriod
LOCALR4 fVAddrTimePerFrame
LOCALR4 fVAddrTimePerField
LOCALR4 fVOddBlankingLines
LOCALR4 fVOddBlanking
LOCALR4 fVEvenBlankingLines
LOCALR4 fVEvenBlanking
LOCALR4 fTopMargin
LOCALR4 fVOddFrontPorch
LOCALR4 fVOddFrontPorchLines
LOCALR4 fVEvenFrontPorch
LOCALR4 fVSyncRqd
LOCALR4 fVSync
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorch
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorchLines
LOCALR4 fVOddBackPorch
LOCALR4 fBottomMargin
LOCALR4 fMarginPercent
LOCALR4 fMinVSyncPlusBackPorch
LOCALR4 fGTF_M
LOCALR4 fGTF_C
LOCALR4 fGTF_J
LOCALR4 fGTF_K
LOCALR4 fGTF_CPrime
LOCALR4 fGTF_MPrime
LOCALR4 fVFieldRateRqd
LOCALR4 fHPeriodEst
LOCALR4 fVFieldRateEst
LOCALR4 fVFieldRate
LOCALR4 fVFrameRate
LOCALR4 fTotalActivePixels
LOCALR4 fIdealDutyCycle
LOCALR4 fHFreq
LOCALR4 fIdealHPeriod
OPENPROC
        PUSHR   ds,ebx,esi,edi

        ; Reset the floating point unit
        fninit

        ; Set up all the constants we need
        call    SetupGTFConstants

        ; Now we compute the stage 1 parameters. There are three cases
        ; depending upon the IPParm which gives the type of the IPFreqRqd.
        push    OFFSET DoneStage1Parms
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_VERTICAL_REFRESH_RATE
        je      VerticalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_HORIZONTAL_REFRESH_RATE
        je      HorizontalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_PIXEL_CLOCK_RATE
        je      PixelClockToStage1Parameters
        pop     eax
        sub     eax,eax
        jmp     Done

DoneStage1Parms:
        ; Convert stage 1 to stage 2 parameters

        ; 1) Find the adressable lines per frame
        fld     fVLinesRnd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fAddrLinesPerFrame

        ; 2) Find the character time in nanoseconds
        fld     fCellGran
        fdiv    fPixelFreq
        fmul    fOneThousand
        fstp    fCharTime

        ; 3) Find total number of lines in a frame
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fTotalLinesPerFrame

        ; 4) Find total number of chars in a horizontal line
        fld     fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fTotalHTimeChars

        ; 5) Find the horizontal addressable time in microseconds
        fld     fHPixelsRnd
        fdiv    fPixelFreq
        fstp    fHAddrTime

        ; 6) Find the horizontal addressable time in chars
        fld     fHPixelsRnd
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHAddrTimeChars

        ; 7) Find horizontal blanking time in microseconds
        fld     fHBlankPixels
        fdiv    fPixelFreq
        fstp    fHBlank

        ; 8) Find horizontal blanking time in chars
        fld     fHBlankPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankChars

        ; 9) Find the horizontal blanking plus margin time in microseconds
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fPixelFreq
        fstp    fHBlankPlusMargin

        ; 10) Find the horizontal blanking plus margin time in chars
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankPlusMarginChars

        ; 11) Find the actual horizontal active video duty cycle in %
        fld     fHBlankChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fActualDutyCycle

        ; 12) Find the image video duty cycle in %
        fld     fHBlankPlusMarginChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fBlankPlusMarginDutyCycle

        ; 13) Find the left margin time in microseconds
        fld     fLeftMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fLeftMargin

        ; 14) Find the number of chars in the left margin
        fld     fLeftMarginPixels
        fdiv    fCellGran
        fstp    fLeftMarginChars

        ; 15) Find the right margin time in microseconds
        fld     fRightMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fRightMargin

        ; 16) Find the number of chars in the rightt margin
        fld     fRightMarginPixels
        fdiv    fCellGran
        fstp    fRightMarginChars

        ; 17) Find the number of pixels inteh horizontal sync period
        fld     fHSyncPercent
        fdiv    fOneHundred
        fmul    fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHSyncPixels

        ; 18) Find number of pixels in horizontal front porch period
        fld     fHBlankPixels
        fdiv    fTwo
        fsub    fHSyncPixels
        fstp    fHFrontPorchPixels

        ; 19) Find number of pixels in horizontal front porch period
        fld     fHFrontPorchPixels
        fadd    fHSyncPixels
        fstp    fHBackPorchPixels

        ; 20) Find number of characters in the horizontal sync period
        fld     fHSyncPixels
        fdiv    fCellGran
        fstp    fHSyncChars

        ; 21) Find the horizontal sync period in microseconds
        fld     fHSyncPixels
        fdiv    fPixelFreq
        fstp    fHSync

        ; 22) Find the number of chars in the horizontal front porch
        fld     fHFrontPorchPixels
        fdiv    fCellGran
        fstp    fHFrontPorchChars

        ; 23) Find the horizontal front porch period in microseconds
        fld     fHFrontPorchPixels
        fdiv    fPixelFreq
        fstp    fHFrontPorch

        ; 24) Find the number of chars in the horizontal back porch
        fld     fHBackPorchPixels
        fdiv    fCellGran
        fstp    fHBackPorchChars

        ; 25) Find the horizontal front back period in microseconds
        fld     fHBackPorchPixels
        fdiv    fPixelFreq
        fstp    fHBackPorch

        ; 26) Find the vertical frame period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVFramePeriod

        ; 27) Find the vertical field period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVFieldPeriod

        ; 28) Find the addressable vertical period per frame in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVAddrTimePerFrame

        ; 29) Find the addressable vertical period per field in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVAddrTimePerField

        ; 30) Find the number of lines in teh odd blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fstp    fVOddBlankingLines

        ; 31) Find the odd blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVOddBlanking

        ; 32) Find the number of lines in the even blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fstp    fVEvenBlankingLines

        ; 33) Find the even blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVEvenBlanking

        ; 34) Find the top margin period in microseconds
        fld     fTopMarginLines
        fmul    fHPeriod
        fstp    fTopMargin

        ; 35) Find the odd front porch in microseconds
        fld     fMinPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVOddFrontPorch

        ; 36) Find the number of lines in the odd front porch period
        fld     fMinPorch
        fadd    fInterlace
        fstp    fVOddFrontPorchLines

        ; 37) Find the even front porch period
        fld     fMinPorch
        fmul    fHPeriod
        fstp    fVEvenFrontPorch

        ; 38) Find the vertcial sync period in microseconds
        fld     fVSyncRqd
        fmul    fHPeriod
        fstp    fVSync

        ; 39) Find the even front porch period in microseconds
        fld     fVBackPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVEvenBackPorch

        ; 40) Find the number of lines in the even fron tporch period
        fld     fVBackPorch
        fadd    fInterlace
        fstp    fVEvenBackPorchLines

        ; 41) Find the odd back porch period in microseconds
        fld     fVBackPorch
        fmul    fHPeriod
        fstp    fVOddBackPorch

        ; 42) Find the bottom margin period in microseconds
        fld     fBottomMarginLines
        fmul    fHPeriod
        fstp    fBottomMargin

        ; Cram all the data into GTFOut
        fld     fTotalHTimeChars
        fistp   es:[esi].GTFOUT.dwHTotalChars
        fld     fTotalLinesPerFrame
        fistp   es:[esi].GTFOUT.dwVTotalScans
        fld     fHAddrTimeChars
        fistp   es:[esi].GTFOUT.dwHActiveChars
        fld     fVLinesRnd
        fistp   es:[esi].GTFOUT.dwVActiveScans
        fld     fHAddrTimeChars
        fadd    fRightMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankStartChar
        fld     fHFrontPorchChars
        fistp   es:[esi].GTFOUT.dwHFrontPorchChars
        fld     fHSyncChars
        fistp   es:[esi].GTFOUT.dwHSyncChars
        fld     fHBackPorchChars
        fistp   es:[esi].GTFOUT.dwHBackPorchChars
        fld     fTotalHTimeChars
        fsub    fLeftMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankEndChar
        fld     fVLinesRnd
        fadd    fBottomMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankStartScan
        fld     fVOddFrontPorchLines
        fistp   es:[esi].GTFOUT.dwVFrontPorchScans
        fld     fVSyncRqd
        fistp   es:[esi].GTFOUT.dwVSyncScans
        fld     fVEvenBackPorchLines
        fistp   es:[esi].GTFOUT.dwVBackPorchScans
        fld     fTotalLinesPerFrame
        fsub    fTopMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankEndScan
        fld     fPixelFreq
;;;        fmul    fOneMillion
        fmul    fOneHundred
        fistp   es:[esi].GTFOUT.dwPixelClockIn10KHertz

        ; Return success
        mov     eax,1

Done:
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC SetupGTFConstants, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; This is the size of the top (or bottom -- they are the same)
        ; overscan area as a percentage of the total vertcical time.
        fld     fOnePointEight
        fstp    fMarginPercent

        ; Number of pixels per character cell
        fld     fEight
        fstp    fCellGran

        ; Minimum horizontal front porch in character cells and
        ; minimum vertical front porch in scanlines (they are the same.)
        fld     fOne
        fstp    fMinPorch

        ; Width of vsync pulse in scanlines
        fld     fThree
        fstp    fVSyncRqd

        ; Width of the hsync pulse as a percentage of horizontal line time
        fld     fEight
        fstp    fHSyncPercent

        ; minimum time for vertical sync plus back porch in microseconds
        fld     fFiveHundredFifty
        fstp    fMinVSyncPlusBackPorch

        ; These apply to the Basic Blanking Duty Cycle Equation.
        ; See the top of the file.
        fld     fSixHundred
        fstp    fGTF_M
        fld     fForty
        fstp    fGTF_C
        fld     fOneHundredTwentyEight
        fstp    fGTF_K
        fld     fTwenty
        fstp    fGTF_J

        ; This is forced by GTF definitions
        ; C' = ((C - J) * (K / 256) + J
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fld     fGTF_C
        fsub    fGTF_J
        fmulp   ST(1),ST(0)
        fadd    fGTF_J
        fstp    fGTF_CPrime

        ; This is forced by GTF definitions
        ; M' = (K / 256) * M
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fmul    fGTF_M
        fstp    fGTF_MPrime

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Arguments:    ds:ebx  ptr to lpGTFIn structure
;               You have the stack frame available to ComputeGTFParameters
;               but be careful about ptrs, because they are flat 32bit ptrs
;               if you are running under WinNT and 16:16 ptrs if you are
;               running under Win9X. You shouldn't need to load any ptrs
;               since lpGTFIn is already passed into this routine in the
;               correct format.
;
; Returns:      None
;
; Preserve:     ds,esi,edi,ebx
;==============================================================================
DECPROC VerticalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the frame rate required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fVFieldRateRqd

        ; 4) Find the number of lines in the top margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Estimate the horizontal period
        fld1
        fdiv    fVFieldRateRqd
        fld     fMinVSyncPlusBackPorch
        fdiv    fOneMillion
        fsubp   ST(1),ST(0)
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fTopMarginLines
        fadd    fMinPorch
        fadd    fInterlace
        fdivp   ST(1),ST(0)
        fmul    fOneMillion
        fstp    fHPeriodEst

        ; 8) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fdiv    fHPeriodEst
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 9) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 10) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 11) Estimate the vertical field frequency
        fld1
        fdiv    fHPeriodEst
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRateEst

        ; 12) Find the actual horizontal period
        fld     fHPeriodEst
        fmul    fVFieldRateEst
        fdiv    fVFieldRateRqd
        fstp    fHPeriod

        ; 13) Find the actual vertical field frequency
        fld1
        fdiv    fHPeriod
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRate

        ; 14) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 15) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 16) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 17) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 18) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 19) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 20) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 21) Find the pixel clock frequency
        fld     fTotalPixels
        fdiv    fHPeriod
        fstp    fPixelFreq

        ; 22) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHPeriod
        fstp    fHFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC HorizontalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fHFreq

        ; 4) Find the number of lines in the top margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 8) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 9) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 10) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 11) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 12) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 13) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 14) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 15) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fdiv    fHFreq
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 16) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 17) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 18) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 19) Find the pixel clock frequency
        fld     fTotalPixels
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fPixelFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC PixelClockToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fPixelFreq

        ; 4) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 5) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 6) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 7) Find the ideal horizontal period from blanking duty cycle Eq
        fld     fOneHundred
        fsub    fGTF_CPrime
        fmul    ST(0),ST(0)
        fld     fTotalActivePixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fmul    fGTF_MPrime
        fmul    fZeroPointFour
        fdiv    fPixelFreq
        faddp   ST(1),ST(0)
        fsqrt
        fadd    fGTF_CPrime
        fsub    fOneHundred
        fdiv    fTwo
        fdiv    fGTF_MPrime
        fmul    fOneThousand
        fstp    fIdealHPeriod

        ; 8) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fIdealHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 9) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 10) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 11) Find the horizontal frequency
        fld     fPixelFreq
        fdiv    fTotalPixels
        fmul    fOneThousand
        fstp    fHFreq

        ; 12) Find the horizontal period
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 13) Find the number of lines in the top margin
        fldz    
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 14) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 15) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 16) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fVSyncPlusBackPorch

        ; 17) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 18) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 19) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 20) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     Divide32By32
;
; Purpose:      This function divides a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Divide32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Divide32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwDividend
PARMD   dwDivisor
OPENPROC
        sub     edx,edx
        mov     eax,dwDividend
        cmp     dwDivisor,edx
        jne     valid
divbyzero:
        cmp     eax,edx                 ; is numerator zero?
        je      done                    ; yes - eax:edx = 0
        mov     eax,-1                  ; no - call it infinity
        mov     edx,-1                  ; eax:edx = -1
        jmp     done
valid:  
        div     dwDivisor
done:
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC


;==============================================================================
;
; Function:     Multiply32By32
;
; Purpose:      This function multiplies a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Multiply32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Multiply32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwMult1
PARMD   dwMult2
OPENPROC
        mov     eax,dwMult1
        imul    eax,dwMult2
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\gtfmathc.c ===
#if !defined(_WIN32) || defined(_WIN64)
/*
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtfmath.c (ported from gtfmath.asm)
;
; Purpose:      This file implements the GTF algorithm
;
;       Just some important comments and definitions extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
*/
#include "cmntypes.h"
#include "gtfmath.h"

/*
 * These math routines need to be defined in the OS specific code.
 */
float calcROUND(float);
float calcFLOOR(float);
float calcSQRT(float);

#define const_fZero                     0.0f
#define const_fZeroPointFour            0.4f
#define const_fZeroPointFive            0.5f
#define const_fOne                      1.0f
#define const_fOnePointEight            1.8f
#define const_fTwo                      2.0f
#define const_fThree                    3.0f
#define const_fEight                    8.0f
#define const_fTwenty                   20.0f
#define const_fForty                    40.0f
#define const_fOneHundred               100.0f
#define const_fOneHundredTwentyEight    128.0f
#define const_fTwoHundredFiftySix       256.0f
#define const_fFiveHundredFifty         550.0f
#define const_fSixHundred               600.0f
#define const_fOneThousand              1000.0f
#define const_fOneMillion               1000000.0f

static float    fTemp;
static float    fVLinesRnd;
static float    fAddrLinesPerFrame;
static float    fCellGran;
static float    fPixelFreq;
static float    fCharTime;
static float    fTopMarginLines;
static float    fBottomMarginLines;
static float    fVSyncPlusBackPorch;
static float    fMinPorch;
static float    fInterlace;
static float    fTotalLinesPerFrame;
static float    fTotalPixels;
static float    fTotalHTimeChars;
static float    fHPixelsRnd;
static float    fHAddrTime;
static float    fHAddrTimeChars;
static float    fHBlankPixels;
static float    fHBlank;
static float    fHBlankChars;
static float    fLeftMarginPixels;
static float    fRightMarginPixels;
static float    fHBlankPlusMargin;
static float    fHBlankPlusMarginChars;
static float    fActualDutyCycle;
static float    fBlankPlusMarginDutyCycle;
static float    fLeftMargin;
static float    fLeftMarginChars;
static float    fRightMargin;
static float    fRightMarginChars;
static float    fHSyncPercent;
static float    fHSyncPixels;
static float    fHFrontPorchPixels;
static float    fHBackPorchPixels;
static float    fHSyncChars;
static float    fHSync;
static float    fHFrontPorchChars;
static float    fHFrontPorch;
static float    fHBackPorchChars;
static float    fHBackPorch;
static float    fTotalVLines;
static float    fHPeriod;
static float    fVFramePeriod;
static float    fVFieldPeriod;
static float    fVAddrTimePerFrame;
static float    fVAddrTimePerField;
static float    fVOddBlankingLines;
static float    fVOddBlanking;
static float    fVEvenBlankingLines;
static float    fVEvenBlanking;
static float    fTopMargin;
static float    fVOddFrontPorch;
static float    fVOddFrontPorchLines;
static float    fVEvenFrontPorch;
static float    fVSyncRqd;
static float    fVSync;
static float    fVEvenBackPorch;
static float    fVBackPorch;
static float    fVEvenBackPorchLines;
static float    fVOddBackPorch;
static float    fBottomMargin;
static float    fMarginPercent;
static float    fMinVSyncPlusBackPorch;
static float    fGTF_M;
static float    fGTF_C;
static float    fGTF_J;
static float    fGTF_K;
static float    fGTF_CPrime;
static float    fGTF_MPrime;
static float    fVFieldRateRqd;
static float    fHPeriodEst;
static float    fVFieldRateEst;
static float    fVFieldRate;
static float    fVFrameRate;
static float    fTotalActivePixels;
static float    fIdealDutyCycle;
static float    fHFreq;
static float    fIdealHPeriod;
/*
;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
; Returns:      None
;
;==============================================================================
*/
static void SetupGTFConstants
(
    void
)
{
    /*
     * This is the size of the top (or bottom -- they are the same)
     * overscan area as a percentage of the total vertcical time.
     */
    fMarginPercent = const_fOnePointEight;
    /*
     * Number of pixels per character cell
     */
    fCellGran = const_fEight;
    /*
     * Minimum horizontal front porch in character cells and
     * minimum vertical front porch in scanlines (they are the same.)
     */
    fMinPorch = const_fOne;
    /*
     * Width of vsync pulse in scanlines
     */
    fVSyncRqd = const_fThree;
    /*
     * Width of the hsync pulse as a percentage of horizontal line time
     */
    fHSyncPercent = const_fEight;
    /*
     * minimum time for vertical sync plus back porch in microseconds
     */
    fMinVSyncPlusBackPorch = const_fFiveHundredFifty;
    /*
     * These apply to the Basic Blanking Duty Cycle Equation.
     * See the top of the file.
     */
    fGTF_M = const_fSixHundred;
    fGTF_C = const_fForty;
    fGTF_K = const_fOneHundredTwentyEight;
    fGTF_J = const_fTwenty;
    /*
     * This is forced by GTF definitions
     * C' = ((C - J) * (K / 256) + J
     *         fld     fGTF_K
     *         fdiv    fTwoHundredFiftySix
     *         fld     fGTF_C
     *         fsub    fGTF_J
     *         fmulp   ST(1),ST(0)
     *         fadd    fGTF_J
     *         fstp    fGTF_CPrime
     */
    fGTF_CPrime = ((fGTF_C - fGTF_J) 
                *  (fGTF_K / const_fTwoHundredFiftySix))
                + fGTF_J;
    /*
     * This is forced by GTF definitions
     * M' = (K / 256) * M
     */
    fGTF_MPrime = (fGTF_K / const_fTwoHundredFiftySix) * fGTF_M;
    return;
}
/*
;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Returns:      None
;
;==============================================================================
*/
static void VerticalRefreshToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *
     * [H PIXELS RND] = ROUND([H PIXELS] / [CELL GRAN RND], 0) * [CELL GRAN RND]
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran) * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *
     * [V LINES RND] = IF([INT RQD?]="y", ROUND([V LINES] / 2, 0),
     *                                    ROUND([V LINES], 0))
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the frame rate required
     *
     * [V FIELD RATE RQD] = IF([INT RQD?]="y", [I/P FREQ RQD] * 2,
     *                                         [I/P FREQ RQD])
     */
    fVFieldRateRqd = (float)lpGtfIn->dwIPFreqRqd;
    if (lpGtfIn->dwIntRqd != 0)
        fVFieldRateRqd += fVFieldRateRqd;
    /*
     * 4) Find the number of lines in the top margin
     *
     * [TOP MARGIN (LINES)] = IF([MARGINS RQD?]="Y", ROUND(([MARGIN%] / 100 * [V LINES RND]), 0),
     *                                               0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 5) Find the number of lines in the bottom margin
     *
     * [BOT MARGIN (LINES)] = IF([MARGINS RQD?]="Y", ROUND(([MARGIN%] / 100 * [V LINES RND]), 0),
     *                                               0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fBottomMarginLines = const_fZero;
    /*
     * 6) If interlace is required, set dwInterlace to 0.5
     *
     * [INTERLACE]=IF([INT RQD?] = "y", 0.5,
     *                                  0)
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 7) Estimate the horizontal period
     *
     * [H PERIOD EST] = ((1 / [V FIELD RATE RQD]) - [MIN VSYNC+BP] / 1000000)
     *                / ([V LINES RND] + (2 * [TOP MARGIN (LINES)]) + [MIN PORCH RND] + [INTERLACE])
     *                * 1000000
     */
    fHPeriodEst = ((const_fOne / fVFieldRateRqd) - fMinVSyncPlusBackPorch / const_fOneMillion)
                / (fVLinesRnd + (const_fTwo * fTopMarginLines) + fMinPorch + fInterlace)
                * const_fOneMillion;
    /*
     * 8) Find the number of lines in fMinVSyncPlusBackPorch
     *
     * [V SYNC+BP] = ROUND(([MIN VSYNC+BP] / [H PERIOD EST]) ,0)
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch / fHPeriodEst);
    /*
     * 9) Find the number of lines in VBackPorch alone
     *
     * [V BACK PORCH] = [V SYNC+BP] - [V SYNC RND]
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 10) Find the total number of lines in the vertical field
     *
     * [TOTAL V LINES] = [V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)]
     *                 + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fVSyncPlusBackPorch
                 + fInterlace
                 + fMinPorch;
    /*
     * 11) Estimate the vertical field frequency
     *
     * [V FIELD RATE EST] = 1 / [H PERIOD EST] / [TOTAL V LINES] * 1000000
     */
    fVFieldRateEst = const_fOne / fHPeriodEst / fTotalVLines * const_fOneMillion;
    /*
     * 12) Find the actual horizontal period
     *
     * [H PERIOD] = [H PERIOD EST] / ([V FIELD RATE RQD] / [V FIELD RATE EST])
     */
    fHPeriod = fHPeriodEst / (fVFieldRateRqd / fVFieldRateEst);
    /*
     * 13) Find the actual vertical field frequency
     *
     * [V FIELD RATE] = 1 / [H PERIOD] / [TOTAL V LINES] * 1000000
     */
    fVFieldRate = const_fOne / fHPeriod / fTotalVLines * const_fOneMillion;
    /*
     * 14) Find the vertical frame frequency
     *
     * [V FRAME RATE] = IF([INT RQD?]="y", [V FIELD RATE] / 2,
     *                                     [V FIELD RATE])
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    /*
     * 15) Find the number of pixels in the left margin
     *
     * [LEFT MARGIN (PIXELS)] = IF([MARGINS RQD?]="Y", ROUND([H PIXELS RND] * [MARGIN%] / 100 / [CELL GRAN RND], 0) * [CELL GRAN RND],
     *                                                 0)
     */
    if (lpGtfIn->dwMarginsRqd)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 16) Find the number of pixels in the right margin
     *
     * [RIGHT MARGIN (PIXELS)] = IF([MARGINS RQD?]="Y", ROUND([H PIXELS RND] * [MARGIN%] / 100 / [CELL GRAN RND], 0) * [CELL GRAN RND],
     *                                                  0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 17) Find total number of active pixels in image+left+right margin
     *
     * [TOTAL ACTIVE PIXELS] = [H PIXELS RND] + [LEFT MARGIN (PIXELS)] + [RIGHT MARGIN (PIXELS)]
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 18) Find the ideal Blanking duty cycle
     *
     * [IDEAL DUTY CYCLE] = [C'] - ([M'] * [H PERIOD] / 1000)
     */
    fIdealDutyCycle = fGTF_CPrime
                    - (fGTF_MPrime * fHPeriod / const_fOneThousand);
    /*
     * 19) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *
     * [H BLANK (PIXELS)] = ROUND([TOTAL ACTIVE PIXELS] * [IDEAL DUTY CYCLE]
     *                    /       (100 - [IDEAL DUTY CYCLE])
     *                    /       (2 * [CELL GRAN RND]), 0)
     *                    * (2 * [CELL GRAN RND])
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo * fCellGran);
    /*
     * 20) Find the total number of pixels
     *
     * [TOTAL PIXELS] = [TOTAL ACTIVE PIXELS] + [H BLANK (PIXELS)]
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 21) Find the pixel clock frequency
     *
     * [PIXEL FREQ] = [TOTAL PIXELS] / [H PERIOD]
     */
    fPixelFreq = fTotalPixels / fHPeriod;
    /*
     * 22) Find the horizontal frequency
     *
     * [H FREQ] = 1000 / [H PERIOD]
     */
    fHFreq = const_fOneThousand / fHPeriod;
    return;
}
/*
;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Returns:      None
;
;==============================================================================
*/
static void HorizontalRefreshToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *         fild    ds:[ebx].GTFIN.dwHPixels
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     *         fstp    fHPixelsRnd
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran)
                * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *         fild    ds:[ebx].GTFIN.dwVLines
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVLinesRnd
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the horizontal freqency required
     *         fild    ds:[ebx].GTFIN.dwIPFreqRqd
     *         fstp    fHFreq
     */
    fHFreq = (float)lpGtfIn->dwIPFreqRqd;
    /*
     * 4) Find the number of lines in the top margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fTopMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 5) Find the number of lines in the bottom margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fBottomMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = fMarginPercent / const_fOneHundred * fVLinesRnd;
    else
        fBottomMarginLines = const_fZero;
    /*
     * 6) If interlace is required, set dwInterlace to 0.5
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fZeroPointFive
     * @@:     fstp    fInterlace
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 7) Find the number of lines in fMinVSyncPlusBackPorch
     *         fld     fMinVSyncPlusBackPorch
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fstp    fVSyncPlusBackPorch
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch * fHFreq / const_fOneThousand);
    /*
     * 8) Find the number of lines in VBackPorch alone
     *         fld     fVSyncPlusBackPorch
     *         fsub    fVSyncRqd
     *         fstp    fVBackPorch
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 9) Find the total number of lines in the vertical field
     *         fld     fVLinesRnd
     *         fadd    fTopMarginLines
     *         fadd    fBottomMarginLines
     *         fadd    fVSyncPlusBackPorch
     *         fadd    fMinPorch
     *         fadd    fInterlace
     *         fstp    fTotalVLines
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fInterlace
                 + fVSyncPlusBackPorch
                 + fMinPorch;
    /*
     * 10) Find the actual vertical field frequency
     *         fld     fHFreq
     *         fdiv    fTotalVLines
     *         fmul    fOneThousand
     *         fstp    fVFieldRate
     */
    fVFieldRate = fHFreq / fTotalVLines * const_fOneThousand;
    /*
     * 11) Find the vertical frame frequency
     *         fld     fVFieldRate
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVFrameRate
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    /*
     * 12) Find the number of pixels in the left margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fLeftMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 13) Find the number of pixels in the right margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fRightMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 14) Find total number of active pixels in image+left+right margin
     *         fld     fHPixelsRnd
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fstp    fTotalActivePixels
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 15) Find the ideal Blanking duty cycle
     *         fld     fGTF_CPrime
     *         fld     fGTF_MPrime
     *         fdiv    fHFreq
     *         fsubp   ST(1),ST(0)
     *         fstp    fIdealDutyCycle
     */
    fIdealDutyCycle = fGTF_CPrime - (fGTF_MPrime / fHFreq);
    /*
     * 16) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *         fld     fTotalActivePixels
     *         fmul    fIdealDutyCycle
     *         fld     fOneHundred
     *         fsub    fIdealDutyCycle
     *         fdivp   ST(1),ST(0)
     *         fld     fCellGran
     *         fadd    ST(0),ST(0)
     *         fdivp   ST(1),ST(0)
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fadd    ST(0),ST(0)
     *         fmul    fCellGran
     *         fstp    fHBlankPixels
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo *fCellGran);
    /*
     * 17) Find the total number of pixels
     *         fld     fTotalActivePixels
     *         fadd    fHBlankPixels
     *         fstp    fTotalPixels
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 18) Find the horizontal frequency
     *         fld     fOneThousand
     *         fdiv    fHFreq
     *         fstp    fHPeriod
     */
    fHPeriod = const_fOneThousand / fHFreq;
    /*
     * 19) Find the pixel clock frequency
     *         fld     fTotalPixels
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fstp    fPixelFreq
     */
    fPixelFreq = fTotalPixels * fHFreq / const_fOneThousand;
    return;
}
/*
;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Returns:      None
;
;==============================================================================
*/
static void PixelClockToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *         fild    ds:[ebx].GTFIN.dwHPixels
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     *         fstp    fHPixelsRnd
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran)
                * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *         fild    ds:[ebx].GTFIN.dwVLines
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVLinesRnd
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the horizontal freqency required
     *         fild    ds:[ebx].GTFIN.dwIPFreqRqd
     *         fstp    fPixelFreq
     */
    fPixelFreq = (float)lpGtfIn->dwIPFreqRqd;
    /*
     * 4) Find the number of pixels in the left margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fLeftMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 5) Find the number of pixels in the right margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fRightMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 6) Find total number of active pixels in image+left+right margin
     *         fld     fHPixelsRnd
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fstp    fTotalActivePixels
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 7) Find the ideal horizontal period from blanking duty cycle Eq
     *         fld     fOneHundred
     *         fsub    fGTF_CPrime
     *         fmul    ST(0),ST(0)
     *         fld     fTotalActivePixels
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fmul    fGTF_MPrime
     *         fmul    fZeroPointFour
     *         fdiv    fPixelFreq
     *         faddp   ST(1),ST(0)
     *         fsqrt
     *         fadd    fGTF_CPrime
     *         fsub    fOneHundred
     *         fdiv    fTwo
     *         fmul    fGTF_MPrime
     *         fmul    fOneThousand
     *         fstp    fIdealHPeriod
     */
    fTemp         = const_fOneHundred - fGTF_CPrime;
    fTemp        *= fTemp;
    fTemp         = fTemp
                  + (const_fZeroPointFour * fGTF_MPrime 
                  *  (fTotalActivePixels + fLeftMarginPixels + fRightMarginPixels)
                  /  fPixelFreq);
    fIdealHPeriod = ((fGTF_CPrime - const_fOneHundred)
                  +  (float)calcSQRT(fTemp))
                  / const_fTwo
                  / fGTF_MPrime
                  * const_fOneThousand;
    /*
     * 8) Find the ideal Blanking duty cycle
     *         fld     fGTF_CPrime
     *         fld     fGTF_MPrime
     *         fmul    fIdealHPeriod
     *         fdiv    fOneThousand
     *         fsubp   ST(1),ST(0)
     *         fstp    fIdealDutyCycle
     */

    fIdealDutyCycle = fGTF_CPrime - 
                      (fGTF_MPrime * fIdealHPeriod / const_fOneThousand);
    /*
     * 9) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *         fld     fTotalActivePixels
     *         fmul    fIdealDutyCycle
     *         fld     fOneHundred
     *         fsub    fIdealDutyCycle
     *         fdivp   ST(1),ST(0)
     *         fld     fCellGran
     *         fadd    ST(0),ST(0)
     *         fdivp   ST(1),ST(0)
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fadd    ST(0),ST(0)
     *         fmul    fCellGran
     *         fstp    fHBlankPixels
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo * fCellGran);
    /*
     * 10) Find the total number of pixels
     *         fld     fTotalActivePixels
     *         fadd    fHBlankPixels
     *         fstp    fTotalPixels
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 11) Find the horizontal frequency
     *         fld     fPixelFreq
     *         fdiv    fTotalPixels
     *         fmul    fOneThousand
     *         fstp    fHFreq
     */
    fHFreq = fPixelFreq / fTotalPixels * const_fOneThousand;
    /*
     * 12) Find the horizontal period
     *         fld     fOneThousand
     *         fdiv    fHFreq
     *         fstp    fHPeriod
     */
    fHPeriod = const_fOneThousand / fHFreq;
    /*
     * 13) Find the number of lines in the top margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fTopMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 14) Find the number of lines in the bottom margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fBottomMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fBottomMarginLines = const_fZero;
    /*
     * 15) If interlace is required, set dwInterlace to 0.5
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fZeroPointFive
     * @@:     fstp    fInterlace
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 16) Find the number of lines in fMinVSyncPlusBackPorch
     *         fld     fMinVSyncPlusBackPorch
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fstp    fVSyncPlusBackPorch
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch * fHFreq / const_fOneThousand);
    /*
     * 17) Find the number of lines in VBackPorch alone
     *         fld     fVSyncPlusBackPorch
     *         fsub    fVSyncRqd
     *         fstp    fVBackPorch
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 18) Find the total number of lines in the vertical field
     *         fld     fVLinesRnd
     *         fadd    fTopMarginLines
     *         fadd    fBottomMarginLines
     *         fadd    fVSyncPlusBackPorch
     *         fadd    fMinPorch
     *         fadd    fInterlace
     *         fstp    fTotalVLines
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fVSyncPlusBackPorch
                 + fMinPorch
                 + fInterlace;
    /*
     * 19) Find the actual vertical field frequency
     *         fld     fHFreq
     *         fdiv    fTotalVLines
     *         fmul    fOneThousand
     *         fstp    fVFieldRate
     */
    fVFieldRate = fHFreq /fTotalVLines * const_fOneThousand;
    /*
     * 20) Find the vertical frame frequency
     *         fld     fVFieldRate
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVFrameRate
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    return;
}
/*
;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Returns:      0       failure and lpGTFOut was not filled in
;               non-0   success and lpGTFOut was filled in
;
;==============================================================================
*/
ULONG WINAPI ComputeGTFParameters
(
        LPGTFIN  lpGtfIn,
        LPGTFOUT lpGtfOut
)
{
    /*
     * Set up all the constants we need
     */
    SetupGTFConstants();
    /*
     * Now we compute the stage 1 parameters. There are three cases
     * depending upon the IPParm which gives the type of the IPFreqRqd.
     */
    switch (lpGtfIn->dwIPParmType)
    {
        case IPTYPE_VERTICAL_REFRESH_RATE:
            VerticalRefreshToStage1Parameters(lpGtfIn);
            break;
        case IPTYPE_HORIZONTAL_REFRESH_RATE:
            HorizontalRefreshToStage1Parameters(lpGtfIn);
            break;
        case IPTYPE_PIXEL_CLOCK_RATE:
            PixelClockToStage1Parameters(lpGtfIn);
            break;
    }
    /*
     * Convert stage 1 to stage 2 parameters
     *
     * 1) Find the adressable lines per frame
     *
     * [ADDR LINES PER FRAME] = IF([INT RQD?]="y", [V LINES RND] * 2,
     *                                             [V LINES RND])
     */
    fAddrLinesPerFrame = fVLinesRnd;
    if (lpGtfIn->dwIntRqd != 0)
        fAddrLinesPerFrame += fVLinesRnd;
    /*
     * 2) Find the character time in nanoseconds
     *
     * [CHAR TIME] = [CELL GRAN RND] / [PIXEL FREQ] * 1000
     */
    fCharTime = fCellGran / fPixelFreq * const_fOneThousand;
    /*
     * 3) Find total number of lines in a frame
     *
     * [TOTAL LINES PER FRAME] = IF([INT RQD?]="y", 2 * ([V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]),
     *                                              ([V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]))
     */
    fTotalLinesPerFrame = fVLinesRnd
                        + fTopMarginLines
                        + fBottomMarginLines
                        + fVSyncPlusBackPorch
                        + fInterlace
                        + fMinPorch;
    if (lpGtfIn->dwIntRqd != 0)
        fTotalLinesPerFrame += fTotalLinesPerFrame;
    /*
     * 4) Find total number of chars in a horizontal line
     *
     * [TOTAL H TIME (CHARS)] = ROUND([TOTAL PIXELS] / [CELL GRAN RND], 0)
     */
    fTotalHTimeChars = calcROUND(fTotalPixels / fCellGran);
    /*
     * 5) Find the horizontal addressable time in microseconds
     *
     * [H ADDR TIME] = [H PIXELS RND] / [PIXEL FREQ]
     */
    fHAddrTime = fHPixelsRnd / fPixelFreq;
    /*
     * 6) Find the horizontal addressable time in chars
     *
     * [H ADDR TIME (CHARS)] = ROUND([H PIXELS RND] / [CELL GRAN RND], 0)
     */
    fHAddrTimeChars = calcROUND(fHPixelsRnd / fCellGran);
    /*
     * 7) Find horizontal blanking time in microseconds
     *
     * [H BLANK] = [H BLANK (PIXELS)] / [PIXEL FREQ]
     */
    fHBlank = fHBlankPixels / fPixelFreq;
    /*
     * 8) Find horizontal blanking time in chars
     *
     * [H BLANK (CHARS)] = ROUND([H BLANK (PIXELS)] / [CELL GRAN RND], 0)
     */
    fHBlankChars = calcROUND(fHBlankPixels / fCellGran);
    /*
     * 9) Find the horizontal blanking plus margin time in microseconds
     *
     * [H BLANK + MARGIN] = ([H BLANK (PIXELS)] + [RIGHT MARGIN (PIXELS)] + [LEFT MARGIN (PIXELS)])
     *                    / [PIXEL FREQ]
     */
    fHBlankPlusMargin = (fHBlankPixels + fRightMarginPixels + fLeftMarginPixels)
                      / fPixelFreq;
    /*
     * 10) Find the horizontal blanking plus margin time in chars
     *
     * [H BLANK + MARGIN(CHARS)] = ROUND(([H BLANK (PIXELS)] + [RIGHT MARGIN (PIXELS)] + [LEFT MARGIN (PIXELS)]) / [CELL GRAN RND], 0)
     */
    fHBlankPlusMarginChars = calcROUND((fHBlankPixels + fRightMarginPixels + fLeftMarginPixels) / fCellGran);
    /*
     * 11) Find the actual horizontal active video duty cycle in %
     *
     * [ACTUAL DUTY CYCLE] = [H BLANK (CHARS)] / [TOTAL H TIME (CHARS)] * 100
     */
    fActualDutyCycle = fHBlankChars / fTotalHTimeChars * const_fOneHundred;
    /*
     * 12) Find the image video duty cycle in %
     *
     * [BLANK + MARGIN DUTY CYCLE] = [H BLANK + MARGIN(CHARS)] / [TOTAL H TIME (CHARS)] * 100
     */
    fBlankPlusMarginDutyCycle = fHBlankPlusMarginChars / fTotalHTimeChars * const_fOneHundred;
    /*
     * 13) Find the left margin time in microseconds
     *
     * [LEFT MARGIN] = [LEFT MARGIN (PIXELS)] / [PIXEL FREQ] * 1000
     */
    fLeftMargin = fLeftMarginPixels * fPixelFreq * const_fOneThousand;
    /*
     * 14) Find the number of chars in the left margin
     *
     * [LEFT MARGIN (CHARS)] = [LEFT MARGIN (PIXELS)] / [CELL GRAN RND]
     */
    fLeftMarginChars = fLeftMarginPixels / fCellGran;
    /*
     * 15) Find the right margin time in microseconds
     *
     * [RIGHT MARGIN] = [RIGHT MARGIN (PIXELS)] / [PIXEL FREQ] * 1000
     */
    fRightMargin = fRightMarginPixels * fPixelFreq * const_fOneThousand;
    /*
     * 16) Find the number of chars in the rightt margin
     *
     * [RIGHT MARGIN (CHARS)] = [RIGHT MARGIN (PIXELS)] / [CELL GRAN RND]
     */
    fRightMarginChars = fRightMarginPixels / fCellGran;
    /*
     * 17) Find the number of pixels inteh horizontal sync period
     *
     * [H SYNC (PIXELS)] = ROUND(([H SYNC%] / 100 * [TOTAL PIXELS] / [CELL GRAN RND]), 0)
     *                   * [CELL GRAN RND]
     */
    fHSyncPixels = calcROUND(fHSyncPercent / const_fOneHundred * fTotalPixels / fCellGran)
                 * fCellGran;
    /*
     * 18) Find number of pixels in horizontal front porch period
     *
     * [H FRONT PORCH (PIXELS)] = ([H BLANK (PIXELS)] / 2) - [H SYNC (PIXELS)]
     */
    fHFrontPorchPixels = (fHBlankPixels / const_fTwo) - fHSyncPixels;
    /*
     * 19) Find number of pixels in horizontal front porch period
     *
     * [H BACK PORCH (PIXELS)] = [H FRONT PORCH (PIXELS)] + [H SYNC (PIXELS)]
     */
    fHBackPorchPixels = fHFrontPorchPixels + fHSyncPixels;
    /*
     * 20) Find number of characters in the horizontal sync period
     *
     * [H SYNC (CHARS)] = [H SYNC (PIXELS)] / [CELL GRAN RND]
     */
    fHSyncChars = fHSyncPixels / fCellGran;
    /*
     * 21) Find the horizontal sync period in microseconds
     *
     * [H SYNC] = [H SYNC (PIXELS)] / [PIXEL FREQ]
     */
    fHSync = fHSyncPixels / fPixelFreq;
    /*
     * 22) Find the number of chars in the horizontal front porch
     *
     * [H FRONT PORCH (CHARS)] = [H FRONT PORCH (PIXELS)] / [CELL GRAN RND]
     */
    fHFrontPorchChars = fHFrontPorchPixels / fCellGran;
    /*
     * 23) Find the horizontal front porch period in microseconds
     *
     * [H FRONT PORCH] = [H FRONT PORCH (PIXELS)] / [PIXEL FREQ]
     */
    fHFrontPorch = fHFrontPorchPixels / fPixelFreq;
    /*
     * 24) Find the number of chars in the horizontal back porch
     *
     * [H BACK PORCH (CHARS)] = [H BACK PORCH (PIXELS)] / [CELL GRAN RND]
     */
    fHBackPorchChars = fHBackPorchPixels / fCellGran;
    /*
     * 25) Find the horizontal front back period in microseconds
     *
     * [H BACK PORCH] = [H BACK PORCH (PIXELS)] / [PIXEL FREQ]
     */
    fHBackPorch = fHBackPorchPixels / fPixelFreq;
    /*
     * 26) Find the vertical frame period in milliseconds
     *
     * [V FRAME PERIOD] = IF([INT RQD?]="y", [TOTAL V LINES] * [H PERIOD] / 1000 * 2,
     *                                       [TOTAL V LINES] * [H PERIOD] / 1000)
     */
    fVFramePeriod = fTotalVLines * fHPeriod / const_fOneThousand;
    if (lpGtfIn->dwIntRqd != 0)
        fVFramePeriod += fVFramePeriod;
    /*
     * 27) Find the vertical field period in milliseconds
     *
     * [V FIELD PERIOD] = [TOTAL V LINES] * [H PERIOD] / 1000
     */
    fVFieldPeriod = fTotalVLines * fHPeriod / const_fOneThousand;
    /*
     * 28) Find the addressable vertical period per frame in milliseconds
     *
     * [V ADDR TIME PER FRAME] = IF([INT RQD?]="y", [V LINES RND] * [H PERIOD] / 1000 * 2,
     *                                              [V LINES RND] * [H PERIOD] / 1000)
     */
    fVAddrTimePerFrame = fVLinesRnd * fHPeriod / const_fOneThousand;
    if (lpGtfIn->dwIntRqd != 0)
        fVAddrTimePerFrame += fVAddrTimePerFrame;
    /*
     * 29) Find the addressable vertical period per field in milliseconds
     *
     * [V ADDR TIME PER FIELD] = [V LINES RND] * [H PERIOD] / 1000
     */
    fVAddrTimePerField = fVLinesRnd * fHPeriod / const_fOneThousand;
    /*
     * 30) Find the number of lines in teh odd blanking period
     *
     * [V ODD BLANKING (LINES)] = [V SYNC+BP] + [MIN PORCH RND]
     */
    fVOddBlankingLines = fVSyncPlusBackPorch + fMinPorch;
    /*
     * 31) Find the odd blanking period in milliseconds
     *
     * [V ODD BLANKING] = ([V SYNC+BP] + [MIN PORCH RND]) * [H PERIOD] / 1000
     */
    fVOddBlanking = (fVSyncPlusBackPorch + fMinPorch) * fHPeriod / const_fOneThousand;
    /*
     * 32) Find the number of lines in the even blanking period
     *
     * [V EVEN BLANKING (LINES)] = [V SYNC+BP] + (2 * [INTERLACE]) + [MIN PORCH RND]
     */
    fVEvenBlankingLines = fVSyncPlusBackPorch
                        + (const_fTwo * fInterlace)
                        + fMinPorch;
    /*
     * 33) Find the even blanking period in milliseconds
     *
     * [V EVEN BLANKING] = ([V SYNC+BP] + (2 * [INTERLACE]) + [MIN PORCH RND])
     *                   / 1000 * [H PERIOD]
     */
    fVEvenBlanking = (fVSyncPlusBackPorch + (const_fTwo * fInterlace) + fMinPorch)
                   / const_fOneThousand
                   *  fHPeriod;
    /*
     * 34) Find the top margin period in microseconds
     *
     * [TOP MARGIN ] = [TOP MARGIN (LINES)] * [H PERIOD]
     */
    fTopMargin = fTopMarginLines * fHPeriod;
    /*
     * 35) Find the odd front porch in microseconds
     *
     * [V ODD FRONT PORCH] = ([MIN PORCH RND] + [INTERLACE]) * [H PERIOD]
     */
    fVOddFrontPorch = (fMinPorch + fInterlace) * fHPeriod;
    /*
     * 36) Find the number of lines in the odd front porch period
     *
     * [V ODD FRONT PORCH(LINES)] = [MIN PORCH RND] + [INTERLACE]
     */
    fVOddFrontPorchLines = fMinPorch + fInterlace;
    /*
     * 37) Find the even front porch period
     *
     * [V EVEN FRONT PORCH] = [MIN PORCH RND] * [H PERIOD]
     */
    fVEvenFrontPorch = fMinPorch * fHPeriod;
    /*
     * 38) Find the vertcial sync period in microseconds
     *
     * [V SYNC] = [V SYNC RND] * [H PERIOD]
     */
    fVSync = fVSyncRqd * fHPeriod;
    /*
     * 39) Find the even front porch period in microseconds
     *
     * [V EVEN BACK PORCH] = ([V BACK PORCH] + [INTERLACE]) * [H PERIOD]
     */
    fVEvenBackPorch = (fVBackPorch + fInterlace) * fHPeriod;
    /*
     * 40) Find the number of lines in the even fron tporch period
     *
     * [V EVEN BACK PORCH (LINES)] = [V BACK PORCH] + [INTERLACE]
     */
    fVEvenBackPorchLines = fVBackPorch + fInterlace;
    /*
     * 41) Find the odd back porch period in microseconds
     *
     * [V ODD BACK PORCH] = [V BACK PORCH] * [H PERIOD]
     */
    fVOddBackPorch = fVBackPorch * fHPeriod;
    /*
     * 42) Find the bottom margin period in microseconds
     *
     * [BOT MARGIN] = [BOT MARGIN (LINES)] * [H PERIOD]
     */
    fBottomMargin = fBottomMarginLines * fHPeriod;
    /*
     * Cram all the data into GTFOut
     */
    lpGtfOut->dwHTotalChars          = (ULONG)fTotalHTimeChars;
    lpGtfOut->dwVTotalScans          = (ULONG)fTotalLinesPerFrame;
    lpGtfOut->dwHActiveChars         = (ULONG)fHAddrTimeChars;
    lpGtfOut->dwVActiveScans         = (ULONG)fVLinesRnd;
    lpGtfOut->dwHBlankStartChar      = (ULONG)(fHAddrTimeChars + fRightMarginChars);
    lpGtfOut->dwHFrontPorchChars     = (ULONG)fHFrontPorchChars;
    lpGtfOut->dwHSyncChars           = (ULONG)fHSyncChars;
    lpGtfOut->dwHBackPorchChars      = (ULONG)fHBackPorchChars;
    lpGtfOut->dwHBlankEndChar        = (ULONG)(fTotalHTimeChars - fLeftMarginChars);
    lpGtfOut->dwVBlankStartScan      = (ULONG)(fVLinesRnd + fBottomMarginLines);
    lpGtfOut->dwVFrontPorchScans     = (ULONG)fVOddFrontPorchLines;
    lpGtfOut->dwVSyncScans           = (ULONG)fVSyncRqd;
    lpGtfOut->dwVBackPorchScans      = (ULONG)fVEvenBackPorchLines;
    lpGtfOut->dwVBlankEndScan        = (ULONG)(fTotalLinesPerFrame - fTopMarginLines);
    lpGtfOut->dwPixelClockIn10KHertz = (ULONG)(fPixelFreq * const_fOneHundred);
    /*
     * Return success
     */
    return(1);
}
ULONG WINAPI Divide32By32
(
        ULONG dwDividend,
        ULONG dwDivisor
)
{
    return (dwDividend / dwDivisor);
}
ULONG WINAPI Multiply32By32
(
        ULONG dwMult1,
        ULONG dwMult2
)
{
    return (dwMult1 * dwMult2);
}
#endif /* !defined(_WIN32)  || defined(_WIN64) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\i386\gtfmath.inc ===
option expr32
option casemap:none

; Begin of file temp.h
ULONG		TYPEDEF		DWORD

tagGTFIN		STRUCT 2t
dwHPixels		ULONG		?
dwVLines		ULONG		?
dwMarginsRqd		ULONG		?
dwIntRqd		ULONG		?
dwIPParmType		ULONG		?
dwIPFreqRqd		ULONG		?
tagGTFIN		ENDS

GTFIN		TYPEDEF		tagGTFIN

LPGTFIN		TYPEDEF		PTR GTFIN

IPTYPE_VERTICAL_REFRESH_RATE		EQU		1t
IPTYPE_HORIZONTAL_REFRESH_RATE		EQU		2t
IPTYPE_PIXEL_CLOCK_RATE		EQU		3t
tagGTFOUT		STRUCT 2t
dwHTotalChars		ULONG		?
dwVTotalScans		ULONG		?
dwHActiveChars		ULONG		?
dwVActiveScans		ULONG		?
dwHBlankStartChar		ULONG		?
dwHFrontPorchChars		ULONG		?
dwHSyncChars		ULONG		?
dwHBackPorchChars		ULONG		?
dwHBlankEndChar		ULONG		?
dwVBlankStartScan		ULONG		?
dwVFrontPorchScans		ULONG		?
dwVSyncScans		ULONG		?
dwVBackPorchScans		ULONG		?
dwVBlankEndScan		ULONG		?
dwPixelClockIn10KHertz		ULONG		?
tagGTFOUT		ENDS

GTFOUT		TYPEDEF		tagGTFOUT

LPGTFOUT		TYPEDEF		PTR GTFOUT

; End of file temp.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\tvmode.h ===
/*
    FILE:   tvmode.h
    DATE:   4/8/99

    This file contains the high level logic for the tv modeset code.
    OS Independent.
*/

extern int CFUNC FindTVModeEntry (LPDISPDATA lpDispData,
                                LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut,
                                LPMODEENTRY lpModeList, LPRESTIME lpRTList);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\i386\gtfmath.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtf.asm
;
; Purpose:      This file implements the GTF algorithm
;
;       Just come important comments and definitions I extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
.586
include ..\include\macros.dat
include gtfmath.inc

.listall

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, USE32, CODE

fZeroPointFour                  REAL4   0.4
fZeroPointFive                  REAL4   0.5
fOne                            REAL4   1.0
fOnePointEight                  REAL4   1.8
fTwo                            REAL4   2.0
fThree                          REAL4   3.0
fEight                          REAL4   8.0
fTwenty                         REAL4   20.0
fForty                          REAL4   40.0
fOneHundred                     REAL4   100.0
fOneHundredTwentyEight          REAL4   128.0
fTwoHundredFiftySix             REAL4   256.0
fFiveHundredFifty               REAL4   550.0
fSixHundred                     REAL4   600.0
fOneThousand                    REAL4   1000.0
fOneMillion                     REAL4   1000000.0

;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    lpGTFIn         FAR ptr to GTFIN structure
;               lpGTFOut        FAR ptr to GTFOUT structure
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
IFDEF  _WIN32
DECPROC ComputeGTFParameters, STANDARD, FRAME, NEAR
ELSE
DECPROC ComputeGTFParameters, PASCAL, FRAME, FAR16
ENDIF
PARMD   lpGTFIn
PARMD   lpGTFOut
OPENPROC
        PUSHR   ds,ebx,esi,edi
IFDEF _WIN32
        mov     ebx,lpGTFIn
        mov     esi,lpGTFOut
ELSE
        sub     ebx,ebx
        lds     bx,lpGTFIn
        sub     esi,esi
        les     si,lpGTFOut
ENDIF
        call    ComputeGTFParameters1
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     ComputeGTFParameters1
;
; Purpose:      This function computes the data for the GTFOut structure
;               from teh arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    ds:ebx  GTFIN ptr
;               es:esi  GTFOUT ptr
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
DECPROC ComputeGTFParameters1, PASCAL, FRAME, NEAR
LOCALD  dwTemp
LOCALR4 fVLinesRnd
LOCALR4 fAddrLinesPerFrame
LOCALR4 fCellGran
LOCALR4 fPixelFreq
LOCALR4 fCharTime
LOCALR4 fTopMarginLines
LOCALR4 fBottomMarginLines
LOCALR4 fVSyncPlusBackPorch
LOCALR4 fMinPorch
LOCALR4 fInterlace
LOCALR4 fTotalLinesPerFrame
LOCALR4 fTotalPixels
LOCALR4 fTotalHTimeChars
LOCALR4 fHPixelsRnd
LOCALR4 fHAddrTime
LOCALR4 fHAddrTimeChars
LOCALR4 fHBlankPixels
LOCALR4 fHBlank
LOCALR4 fHBlankChars
LOCALR4 fLeftMarginPixels
LOCALR4 fRightMarginPixels
LOCALR4 fHBlankPlusMargin
LOCALR4 fHBlankPlusMarginChars
LOCALR4 fActualDutyCycle
LOCALR4 fBlankPlusMarginDutyCycle
LOCALR4 fLeftMargin
LOCALR4 fLeftMarginChars
LOCALR4 fRightMargin
LOCALR4 fRightMarginChars
LOCALR4 fHSyncPercent
LOCALR4 fHSyncPixels
LOCALR4 fHFrontPorchPixels
LOCALR4 fHBackPorchPixels
LOCALR4 fHSyncChars
LOCALR4 fHSync
LOCALR4 fHFrontPorchChars
LOCALR4 fHFrontPorch
LOCALR4 fHBackPorchChars
LOCALR4 fHBackPorch
LOCALR4 fTotalVLines
LOCALR4 fHPeriod
LOCALR4 fVFramePeriod
LOCALR4 fVFieldPeriod
LOCALR4 fVAddrTimePerFrame
LOCALR4 fVAddrTimePerField
LOCALR4 fVOddBlankingLines
LOCALR4 fVOddBlanking
LOCALR4 fVEvenBlankingLines
LOCALR4 fVEvenBlanking
LOCALR4 fTopMargin
LOCALR4 fVOddFrontPorch
LOCALR4 fVOddFrontPorchLines
LOCALR4 fVEvenFrontPorch
LOCALR4 fVSyncRqd
LOCALR4 fVSync
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorch
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorchLines
LOCALR4 fVOddBackPorch
LOCALR4 fBottomMargin
LOCALR4 fMarginPercent
LOCALR4 fMinVSyncPlusBackPorch
LOCALR4 fGTF_M
LOCALR4 fGTF_C
LOCALR4 fGTF_J
LOCALR4 fGTF_K
LOCALR4 fGTF_CPrime
LOCALR4 fGTF_MPrime
LOCALR4 fVFieldRateRqd
LOCALR4 fHPeriodEst
LOCALR4 fVFieldRateEst
LOCALR4 fVFieldRate
LOCALR4 fVFrameRate
LOCALR4 fTotalActivePixels
LOCALR4 fIdealDutyCycle
LOCALR4 fHFreq
LOCALR4 fIdealHPeriod
OPENPROC
        PUSHR   ds,ebx,esi,edi

        ; Reset the floating point unit
        fninit

        ; Set up all the constants we need
        call    SetupGTFConstants

        ; Now we compute the stage 1 parameters. There are three cases
        ; depending upon the IPParm which gives the type of the IPFreqRqd.
        push    OFFSET DoneStage1Parms
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_VERTICAL_REFRESH_RATE
        je      VerticalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_HORIZONTAL_REFRESH_RATE
        je      HorizontalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_PIXEL_CLOCK_RATE
        je      PixelClockToStage1Parameters
        pop     eax
        sub     eax,eax
        jmp     Done

DoneStage1Parms:
        ; Convert stage 1 to stage 2 parameters

        ; 1) Find the adressable lines per frame
        fld     fVLinesRnd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fAddrLinesPerFrame

        ; 2) Find the character time in nanoseconds
        fld     fCellGran
        fdiv    fPixelFreq
        fmul    fOneThousand
        fstp    fCharTime

        ; 3) Find total number of lines in a frame
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fTotalLinesPerFrame

        ; 4) Find total number of chars in a horizontal line
        fld     fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fTotalHTimeChars

        ; 5) Find the horizontal addressable time in microseconds
        fld     fHPixelsRnd
        fdiv    fPixelFreq
        fstp    fHAddrTime

        ; 6) Find the horizontal addressable time in chars
        fld     fHPixelsRnd
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHAddrTimeChars

        ; 7) Find horizontal blanking time in microseconds
        fld     fHBlankPixels
        fdiv    fPixelFreq
        fstp    fHBlank

        ; 8) Find horizontal blanking time in chars
        fld     fHBlankPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankChars

        ; 9) Find the horizontal blanking plus margin time in microseconds
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fPixelFreq
        fstp    fHBlankPlusMargin

        ; 10) Find the horizontal blanking plus margin time in chars
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankPlusMarginChars

        ; 11) Find the actual horizontal active video duty cycle in %
        fld     fHBlankChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fActualDutyCycle

        ; 12) Find the image video duty cycle in %
        fld     fHBlankPlusMarginChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fBlankPlusMarginDutyCycle

        ; 13) Find the left margin time in microseconds
        fld     fLeftMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fLeftMargin

        ; 14) Find the number of chars in the left margin
        fld     fLeftMarginPixels
        fdiv    fCellGran
        fstp    fLeftMarginChars

        ; 15) Find the right margin time in microseconds
        fld     fRightMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fRightMargin

        ; 16) Find the number of chars in the rightt margin
        fld     fRightMarginPixels
        fdiv    fCellGran
        fstp    fRightMarginChars

        ; 17) Find the number of pixels inteh horizontal sync period
        fld     fHSyncPercent
        fdiv    fOneHundred
        fmul    fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHSyncPixels

        ; 18) Find number of pixels in horizontal front porch period
        fld     fHBlankPixels
        fdiv    fTwo
        fsub    fHSyncPixels
        fstp    fHFrontPorchPixels

        ; 19) Find number of pixels in horizontal front porch period
        fld     fHFrontPorchPixels
        fadd    fHSyncPixels
        fstp    fHBackPorchPixels

        ; 20) Find number of characters in the horizontal sync period
        fld     fHSyncPixels
        fdiv    fCellGran
        fstp    fHSyncChars

        ; 21) Find the horizontal sync period in microseconds
        fld     fHSyncPixels
        fdiv    fPixelFreq
        fstp    fHSync

        ; 22) Find the number of chars in the horizontal front porch
        fld     fHFrontPorchPixels
        fdiv    fCellGran
        fstp    fHFrontPorchChars

        ; 23) Find the horizontal front porch period in microseconds
        fld     fHFrontPorchPixels
        fdiv    fPixelFreq
        fstp    fHFrontPorch

        ; 24) Find the number of chars in the horizontal back porch
        fld     fHBackPorchPixels
        fdiv    fCellGran
        fstp    fHBackPorchChars

        ; 25) Find the horizontal front back period in microseconds
        fld     fHBackPorchPixels
        fdiv    fPixelFreq
        fstp    fHBackPorch

        ; 26) Find the vertical frame period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVFramePeriod

        ; 27) Find the vertical field period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVFieldPeriod

        ; 28) Find the addressable vertical period per frame in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVAddrTimePerFrame

        ; 29) Find the addressable vertical period per field in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVAddrTimePerField

        ; 30) Find the number of lines in teh odd blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fstp    fVOddBlankingLines

        ; 31) Find the odd blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVOddBlanking

        ; 32) Find the number of lines in the even blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fstp    fVEvenBlankingLines

        ; 33) Find the even blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVEvenBlanking

        ; 34) Find the top margin period in microseconds
        fld     fTopMarginLines
        fmul    fHPeriod
        fstp    fTopMargin

        ; 35) Find the odd front porch in microseconds
        fld     fMinPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVOddFrontPorch

        ; 36) Find the number of lines in the odd front porch period
        fld     fMinPorch
        fadd    fInterlace
        fstp    fVOddFrontPorchLines

        ; 37) Find the even front porch period
        fld     fMinPorch
        fmul    fHPeriod
        fstp    fVEvenFrontPorch

        ; 38) Find the vertcial sync period in microseconds
        fld     fVSyncRqd
        fmul    fHPeriod
        fstp    fVSync

        ; 39) Find the even front porch period in microseconds
        fld     fVBackPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVEvenBackPorch

        ; 40) Find the number of lines in the even fron tporch period
        fld     fVBackPorch
        fadd    fInterlace
        fstp    fVEvenBackPorchLines

        ; 41) Find the odd back porch period in microseconds
        fld     fVBackPorch
        fmul    fHPeriod
        fstp    fVOddBackPorch

        ; 42) Find the bottom margin period in microseconds
        fld     fBottomMarginLines
        fmul    fHPeriod
        fstp    fBottomMargin

        ; Cram all the data into GTFOut
        fld     fTotalHTimeChars
        fistp   es:[esi].GTFOUT.dwHTotalChars
        fld     fTotalLinesPerFrame
        fistp   es:[esi].GTFOUT.dwVTotalScans
        fld     fHAddrTimeChars
        fistp   es:[esi].GTFOUT.dwHActiveChars
        fld     fVLinesRnd
        fistp   es:[esi].GTFOUT.dwVActiveScans
        fld     fHAddrTimeChars
        fadd    fRightMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankStartChar
        fld     fHFrontPorchChars
        fistp   es:[esi].GTFOUT.dwHFrontPorchChars
        fld     fHSyncChars
        fistp   es:[esi].GTFOUT.dwHSyncChars
        fld     fHBackPorchChars
        fistp   es:[esi].GTFOUT.dwHBackPorchChars
        fld     fTotalHTimeChars
        fsub    fLeftMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankEndChar
        fld     fVLinesRnd
        fadd    fBottomMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankStartScan
        fld     fVOddFrontPorchLines
        fistp   es:[esi].GTFOUT.dwVFrontPorchScans
        fld     fVSyncRqd
        fistp   es:[esi].GTFOUT.dwVSyncScans
        fld     fVEvenBackPorchLines
        fistp   es:[esi].GTFOUT.dwVBackPorchScans
        fld     fTotalLinesPerFrame
        fsub    fTopMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankEndScan
        fld     fPixelFreq
;;;        fmul    fOneMillion
        fmul    fOneHundred
        fistp   es:[esi].GTFOUT.dwPixelClockIn10KHertz

        ; Return success
        mov     eax,1

Done:
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC SetupGTFConstants, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; This is the size of the top (or bottom -- they are the same)
        ; overscan area as a percentage of the total vertcical time.
        fld     fOnePointEight
        fstp    fMarginPercent

        ; Number of pixels per character cell
        fld     fEight
        fstp    fCellGran

        ; Minimum horizontal front porch in character cells and
        ; minimum vertical front porch in scanlines (they are the same.)
        fld     fOne
        fstp    fMinPorch

        ; Width of vsync pulse in scanlines
        fld     fThree
        fstp    fVSyncRqd

        ; Width of the hsync pulse as a percentage of horizontal line time
        fld     fEight
        fstp    fHSyncPercent

        ; minimum time for vertical sync plus back porch in microseconds
        fld     fFiveHundredFifty
        fstp    fMinVSyncPlusBackPorch

        ; These apply to the Basic Blanking Duty Cycle Equation.
        ; See the top of the file.
        fld     fSixHundred
        fstp    fGTF_M
        fld     fForty
        fstp    fGTF_C
        fld     fOneHundredTwentyEight
        fstp    fGTF_K
        fld     fTwenty
        fstp    fGTF_J

        ; This is forced by GTF definitions
        ; C' = ((C - J) * (K / 256) + J
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fld     fGTF_C
        fsub    fGTF_J
        fmulp   ST(1),ST(0)
        fadd    fGTF_J
        fstp    fGTF_CPrime

        ; This is forced by GTF definitions
        ; M' = (K / 256) * M
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fmul    fGTF_M
        fstp    fGTF_MPrime

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Arguments:    ds:ebx  ptr to lpGTFIn structure
;               You have the stack frame available to ComputeGTFParameters
;               but be careful about ptrs, because they are flat 32bit ptrs
;               if you are running under WinNT and 16:16 ptrs if you are
;               running under Win9X. You shouldn't need to load any ptrs
;               since lpGTFIn is already passed into this routine in the
;               correct format.
;
; Returns:      None
;
; Preserve:     ds,esi,edi,ebx
;==============================================================================
DECPROC VerticalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the frame rate required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fVFieldRateRqd

        ; 4) Find the number of lines in the top margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Estimate the horizontal period
        fld1
        fdiv    fVFieldRateRqd
        fld     fMinVSyncPlusBackPorch
        fdiv    fOneMillion
        fsubp   ST(1),ST(0)
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fTopMarginLines
        fadd    fMinPorch
        fadd    fInterlace
        fdivp   ST(1),ST(0)
        fmul    fOneMillion
        fstp    fHPeriodEst

        ; 8) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fdiv    fHPeriodEst
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 9) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 10) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 11) Estimate the vertical field frequency
        fld1
        fdiv    fHPeriodEst
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRateEst

        ; 12) Find the actual horizontal period
        fld     fHPeriodEst
        fmul    fVFieldRateEst
        fdiv    fVFieldRateRqd
        fstp    fHPeriod

        ; 13) Find the actual vertical field frequency
        fld1
        fdiv    fHPeriod
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRate

        ; 14) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 15) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 16) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 17) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 18) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 19) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 20) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 21) Find the pixel clock frequency
        fld     fTotalPixels
        fdiv    fHPeriod
        fstp    fPixelFreq

        ; 22) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHPeriod
        fstp    fHFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC HorizontalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fHFreq

        ; 4) Find the number of lines in the top margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 8) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 9) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 10) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 11) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 12) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 13) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 14) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 15) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fdiv    fHFreq
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 16) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 17) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 18) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 19) Find the pixel clock frequency
        fld     fTotalPixels
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fPixelFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC PixelClockToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fPixelFreq

        ; 4) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 5) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 6) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 7) Find the ideal horizontal period from blanking duty cycle Eq
        fld     fOneHundred
        fsub    fGTF_CPrime
        fmul    ST(0),ST(0)
        fld     fTotalActivePixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fmul    fGTF_MPrime
        fmul    fZeroPointFour
        fdiv    fPixelFreq
        faddp   ST(1),ST(0)
        fsqrt
        fadd    fGTF_CPrime
        fsub    fOneHundred
        fdiv    fTwo
        fdiv    fGTF_MPrime
        fmul    fOneThousand
        fstp    fIdealHPeriod

        ; 8) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fIdealHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 9) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 10) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 11) Find the horizontal frequency
        fld     fPixelFreq
        fdiv    fTotalPixels
        fmul    fOneThousand
        fstp    fHFreq

        ; 12) Find the horizontal period
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 13) Find the number of lines in the top margin
        fldz    
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 14) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 15) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 16) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fVSyncPlusBackPorch

        ; 17) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 18) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 19) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 20) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     Divide32By32
;
; Purpose:      This function divides a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Divide32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Divide32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwDividend
PARMD   dwDivisor
OPENPROC
        sub     edx,edx
        mov     eax,dwDividend
        cmp     dwDivisor,edx
        jne     valid
divbyzero:
        cmp     eax,edx                 ; is numerator zero?
        je      done                    ; yes - eax:edx = 0
        mov     eax,-1                  ; no - call it infinity
        mov     edx,-1                  ; eax:edx = -1
        jmp     done
valid:  
        div     dwDivisor
done:
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC


;==============================================================================
;
; Function:     Multiply32By32
;
; Purpose:      This function multiplies a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Multiply32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Multiply32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwMult1
PARMD   dwMult2
OPENPROC
        mov     eax,dwMult1
        imul    eax,dwMult2
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\MODESET.H ===
/*
    FILE:   modeset.h
    DATE:   4/8/99

    This file holds the format for some tables and structures used
    internally by the DLL. OS independent.
*/

// This is the structure format in which we the mode timing tables
// in this DLL are stored. This should never need to be changed.
typedef struct  _tagMODESTRUC
{
    USHORT  wHorizVisible;
    USHORT  wVertVisible;
    USHORT  wRefresh;
    USHORT  wHorizTotal;
    USHORT  wHorizBlankStart;
    USHORT  wHorizSyncStart;
    USHORT  wHorizSyncEnd;
    USHORT  wHorizBlankEnd;
    USHORT  wVertTotal;
    USHORT  wVertBlankStart;
    USHORT  wVertSyncStart;
    USHORT  wVertSyncEnd;
    USHORT  wVertBlankEnd;
    USHORT  wDotClock;
    USHORT  wHSyncPolarity;
    USHORT  wVSyncPolarity;
} MODESTRUC;

typedef MODESTRUC FAR *LPMODESTRUC;

// These constants are used in internal tables
#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1


// This information can often be gotten from an EDID. It can be
// used to restrict mode settings.
typedef struct  _tagMONITORLIMITS
{
    ULONG   dwMinHorz;
    ULONG   dwMaxHorz;
    ULONG   dwMinVert;
    ULONG   dwMaxVert;
    ULONG   dwMaxPixelClock;
} MONITORLIMITS;

typedef MONITORLIMITS FAR *LPMONITORLIMITS;


// Here are the external functions
extern int CFUNC  FindNextSmallerResolution (LPMODEENTRY lpModeList,
                                            LPMODEINFO lpModeDesc);

extern int CFUNC  FindNextSmallerRefreshRate (LPMODEENTRY lpModeList,
                                            LPMODEINFO  lpModeDesc);
extern int CFUNC  FindNextLargerRefreshRate (LPMODEENTRY lpModeList,
                                            LPMODEINFO  lpModeDesc);
extern int WINAPI GetSafeTiming (LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC  GetModeFlags (LPMODEINFO lpModeOrig, LPMODEINFO lpModeFound);
extern int WINAPI FormatModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType, LPMODEENTRY lpME);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\UTILS.C ===
/*
    FILE:   utils.c
    DATE:   4/8/99

    This file provides common utilities other modules.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "debug.h"
#include "gtfmath.h"

/*
    Function:   FindMode

    Purpose:    This routine searches the table passed in lpMS for the
                XRes, YRes, and RRate specified.

    Arguments:  lpMS        ptr to current MODESTRUC table
                lpModeOut   ptr to MODEOUT structure where timing
                            parameters are placed if the mode given
                            by lpMS is found.
                dwXRes      X-Resolution
                dwYRes      Y-Resolution
                dwRRate     Refresh Rate

    Returns:    Index into MODESTRUC table if a matching mode is found.
                -1 if no matching mode is found.
*/

int CFUNC
FindMode (
    LPMODESTRUC lpMS,
    ULONG       dwXRes,
    ULONG       dwYRes,
    ULONG       dwRRate)
{
    int     i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible == dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible == dwYRes)  &&
            ((ULONG) lpMS[i].wRefresh == dwRRate))
        return  (i);
    }

    return  (-1);
}



/*
    Function:   FindModeWithoutRR

    Purpose:    This routine searches the table passed in lpMS for the
                XRes, YRes specified with the highest RRate.

    Arguments:  lpMS        ptr to current MODESTRUC table
                dwXRes      X-Resolution
                dwYRes      Y-Resolution
                dwRRate     Refresh Rate

    Returns:    Index into MODESTRUC table if a matching mode is found.
                -1 if no matching mode is found.
*/

int CFUNC
FindModeWithoutRR (
    LPMODESTRUC lpMS,
    ULONG       dwXRes,
    ULONG       dwYRes)
{
    int     i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible == dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible == dwYRes))
        return  (i);
    }

    return  (-1);
}



/*
    Function:   SetupParamsForVidLutClass

    Purpose:    This routine translates the mode found into the
                parameter format of the VIDEOLUTCURSORDAC class.

    Arguments:  lpMS        ptr to MODESTRUC structure
                lpModeOut   ptr to MODEOUT structure where parameters go.
                lpModeIn    MODEINFO ptr describing mode

    Returns:    Ptr to table with parameters in proper format for the
                VIDEOLUTCURSORDAC class.
*/

int CFUNC
SetupParamsForVidLutClass (
    LPMODESTRUC         lpMS,
    LPMODEOUT           lpModeOut,
    LPMODEINFO          lpModeIn)
{
    ULONG   dwFormat;

    lpModeOut->wXRes        = lpMS->wHorizVisible;
    lpModeOut->wYRes        = lpMS->wVertVisible;
    lpModeOut->wRefreshRate = lpMS->wRefresh;
    lpModeOut->wHBlankStart = lpMS->wHorizBlankStart;
    lpModeOut->wHBlankWidth = lpMS->wHorizBlankEnd - lpMS->wHorizBlankStart;
    lpModeOut->wHSyncStart  = lpMS->wHorizSyncStart;
    lpModeOut->wHSyncWidth  = lpMS->wHorizSyncEnd - lpMS->wHorizSyncStart;
    lpModeOut->wVBlankStart = lpMS->wVertBlankStart;
    lpModeOut->wVBlankWidth = lpMS->wVertBlankEnd - lpMS->wVertBlankStart;
    lpModeOut->wVSyncStart  = lpMS->wVertSyncStart;
    lpModeOut->wVSyncWidth  = lpMS->wVertSyncEnd - lpMS->wVertSyncStart;
    lpModeOut->wHTotal      = lpMS->wHorizTotal;
    lpModeOut->wVTotal      = lpMS->wVertTotal;

    lpModeOut->dwPixelClock = (ULONG) lpMS->wDotClock;

    dwFormat = 0;
    if  (lpModeOut->wYRes < 400)    // if YRes < 400 then this is a double
        dwFormat |= 1;              // scan mode, set dwFormat[0] = 1
    if  (!lpMS->wHSyncPolarity)     // 1 = positive polarity in tbl
        dwFormat |= 4;              // 1 = negative polarity in format field
    if  (!lpMS->wVSyncPolarity)     // 1 = positive polarity in tbl
        dwFormat |= 8;              // 1 = negative polarity in format field

    if  (lpModeIn->dwBpp == 15)
        dwFormat |= 0x20000;        // 15 BPP
    if  (lpModeIn->dwBpp == 16)
        dwFormat |= 0x10000;        // 16 BPP
    if  (lpModeIn->dwBpp == 32)
        dwFormat |= 0x30000;        // 32 BPP

    // Set the display type. Note: DEVTYPE_CRT = 0 so no bits need to be
    // set in dwFormat.
    if  (lpModeIn->MIDevData.cType == DEVTYPE_DFP)
        dwFormat |= 0x300000;
    if  (lpModeIn->MIDevData.cType == DEVTYPE_TV)
    {
        dwFormat |= 0x100000;
        // Set the TV Format
        dwFormat |= ((ULONG) (lpModeIn->MIDevData.cFormat)) << 22;
    }

    lpModeOut->dwFormat = dwFormat; // Store Format

    return  (TRUE);
}



/*
    Function:   SetupParamsForModeINfo

    Purpose:    This routine translates the mode found into the
                parameter format of the MODEINFO structure.

    Arguments:  lpModeOut   MODEOUT ptr to mode found
                lpModeOrig  This is the originally requested mode
                lpModeIn    This will be a MODEINFO structure that
                            describes the same thing as the lpModeOut
                            describes

    Returns:    dwXRes, dwYRes, dwBpp, dwRefreshRate from MODEOUT structure
                in MODEINFO structure.
*/

int CFUNC
SetupParamsForModeInfo (
    LPMODEOUT           lpModeOut,
    LPMODEINFO          lpModeOrig,
    LPMODEINFO          lpModeIn)
{
    ULONG   dwBpp;

    *lpModeIn = *lpModeOrig;

    dwBpp = 0;
    if ((lpModeOut->dwFormat & 0x30000) == 0x00000)
        dwBpp = 8;
    if ((lpModeOut->dwFormat & 0x30000) == 0x20000)
        dwBpp = 15;
    if ((lpModeOut->dwFormat & 0x30000) == 0x10000)
        dwBpp = 16;
    if ((lpModeOut->dwFormat & 0x30000) == 0x30000)
        dwBpp = 32;

    if (lpModeOut->wXRes == 720 && lpModeOut->wYRes == 544) {
        lpModeIn->dwXRes = 720;
        lpModeIn->dwYRes = 576;
    } else {
        lpModeIn->dwXRes = (ULONG) lpModeOut->wXRes;
        lpModeIn->dwYRes = (ULONG) lpModeOut->wYRes;
    }
    lpModeIn->dwBpp         = dwBpp;
    lpModeIn->dwRefreshRate = (ULONG) lpModeOut->wRefreshRate;

    return  (TRUE);
}


/*
    ParseDecimalSeparator

    This routine parses a decimal number from the string passed in. It
    assigns it into lpNum. Upon returning lpIndex is adjusted so that it
    points to the first char after the separator following the number
    parsed. If a NULL followed the number parse (i.e. end of the string),
    lpIndex is left pointing to the NULL, but the routine still
    succeeds. If the number was bad or wasn't found before the comma
    separatorthe separator wasn't a could not be found before the end of
    the string or before the next comma, FALSE is returned. If a number
    was found and everything is fine, TRUE is returned.
*/
int CFUNC
ParseDecimalSeparator (
    LPCHAR  lpStr,
    LPULONG lpIndex,
    LPULONG lpNum,
    char    cSeparator1,
    char    cSeparator2)
{
    ULONG   dwIsNum;
    USHORT  wDec;

    *lpNum  = 0;
    dwIsNum = FALSE;
    while   (TRUE)
    {
        if  ((lpStr[*lpIndex] == cSeparator1) ||
             (lpStr[*lpIndex] == cSeparator2))
        {
            // If we did not find at least one decimal digit, then
            // the Num field was not present -- this is an error.
            if  (!dwIsNum)
            {
                DBG_PRINT1(DL_5, "\r\nNo Num found before comma in %s", lpStr);
                return  (FALSE);
            }

            DBG_PRINT1(DL_5, "\r\nParseDecimal found %ld.", *lpNum);

            // Only bump to after the separator if the separator was
            // not the end of the string
            if  (lpStr[*lpIndex] != 0)
                *lpIndex += 1;

            return  (TRUE);
        }

        wDec = (USHORT) GetDecimalValue (lpStr[*lpIndex]);
        if  (wDec == 0x0FFFF)
        {
			if  (!dwIsNum)
            {
                DBG_PRINT1(DL_5, "\r\nNo Num found before comma in %s", lpStr);
                return  (FALSE);
            }
			else
                return  (TRUE);
        }

        // We have found at least one decimal digit
        dwIsNum = TRUE;

        // Keep a running computation going here.
        *lpNum = *lpNum * 10 + (ULONG) wDec;

        // go to next char
        *lpIndex += 1;
    }

    return  (TRUE);
}


/*
    ParseDecimalNumberAndFractionAndSeparator

    This routine parses a decimal number from the string passed in. It
    assigns it into lpNum. Upon returning lpIndex is adjusted so that it
    points to the first char after the separator following the number
    parsed. If the number has a decimal point and some fraction following
    it, like 50.03, the fractional portion is parsed but discarded and
    *lpIndex is updated to the first character after the separator
    following 50.03
    If a NULL followed the number parse (i.e. end of the string),
    lpIndex is left pointing to the NULL, but the routine still
    succeeds. If the number was bad or wasn't found before the
    separator or the separator couldd not be found before the end of
    the string , FALSE is returned. If a number
    was found and everything is fine, TRUE is returned.
*/
int CFUNC
ParseDecimalNumberAndFractionAndSeparator (
    LPCHAR  lpStr,
    LPULONG lpIndex,
    LPULONG lpNum,
    char    cSeparator1,
    char    cSeparator2)
{

    ParseDecimalSeparator (lpStr, lpIndex, lpNum, cSeparator1, cSeparator2);

    if  (lpStr[*lpIndex] == '.')
    {
        do
        {
            (*lpIndex)++;
        }
        while   ((lpStr[*lpIndex] != '-') && (lpStr[*lpIndex] != ','));

        (*lpIndex)++;
    }

    return  (TRUE);
}


/*
    GetDecimalValue

    This routine accepts a single char as an argument and returns
    the decimal value of that character.  If the char is not
    0-9 then 0x0FFFF is returned.
*/
ULONG CFUNC
GetDecimalValue (char cDigit)
{
    if  ((cDigit >= '0') && (cDigit <= '9'))
    {
        return  ((ULONG) (cDigit - '0'));
    }

    return  (0x0FFFFFFFF);
}


/*
    GetHexValue

    This routine accepts a single char as an argument and returns
    the hexidecimal value of that character.  If the char is not
    0-9,A-F,or a-f, then 0x0FFFF is returned.
*/
ULONG CFUNC
GetHexValue (char cDigit)
{
    if  ((cDigit >= '0') && (cDigit <= '9'))
    {
        return  ((ULONG) (cDigit - '0'));
    }
    else
    {
        if  ((cDigit >= 'A') && (cDigit <= 'F'))
        {
            return  ((ULONG) (cDigit - 'A' + 10));
        }
        else
        {
            if  ((cDigit >= 'a') && (cDigit <= 'f'))
            {
                return  ((ULONG) (cDigit - 'a' + 10));
            }
            else
            {
                return  (0x0FFFFFFFF);
            }
        }
    }
}


/*
    ParseHexSeparator

    This routine parses up to 8 hex digits from the string passed in.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the separator following the
    number parsed. If the number was bad, or if the separator was not
    one of two possible types or if the end of string was not found
    (i.e. NULL) immediately after it, then a FALSE is returned.
    Otherwise TRUE is returned.
*/
int CFUNC
ParseHexSeparator (
        LPCHAR  lpStr,
        LPULONG lpIndex,
        LPULONG lpNum,
        ULONG   dwLen,
        char    cSeparator1,
        char    cSeparator2)
{
    ULONG   dwI;
    ULONG   bFoundDigit;
    ULONG   dwHex;

    // We have to find at least one digit or there is an error.
    bFoundDigit = FALSE;

    // Start off lpNum at 0
    *lpNum = 0;

    // Get the value of the next eight hex digits.
    for (dwI = 0; dwI < dwLen; dwI++)
    {
        if  ((lpStr[*lpIndex] == cSeparator1) ||
             (lpStr[*lpIndex] == cSeparator2))
        {
            if  (!bFoundDigit)
            {
                DBG_PRINT1(DL_5, "\r\nBad Hex value in %s", lpStr);
                return  (FALSE);
            }

            DBG_PRINT1(DL_5, "\r\nParseHex found %lx.", *lpNum);

            // Only bump to after the separator if the separator was
            // not the end of the string
            if  (lpStr[*lpIndex] != 0)
                *lpIndex += 1;

            return  (TRUE);
        }

        // See if it is a hex digit
        dwHex = GetHexValue(lpStr[*lpIndex]);
        if  (dwHex == 0x0FFFFFFFF)
        {
            DBG_PRINT1(DL_5, "\r\nBad Hex value in %s", lpStr);
            return  (FALSE);
        }

        // We have found at least one decimal digit
        bFoundDigit = TRUE;

        *lpNum = (*lpNum << 4) + dwHex;

        // go to next char
        *lpIndex += 1;
    }

    // We fell out of the loop. That means that the maximum number of
    // hex digits has been seen. That is OK, but if the next char is
    // not one of the separators, then there is a parse error.
    if  ((lpStr[*lpIndex] != cSeparator1) &&
         (lpStr[*lpIndex] != cSeparator2))
    {
        DBG_PRINT1(DL_5, "\r\nHex value too big in %s", lpStr);
        return (FALSE);
    }

    // Only bump to after the separator if it was there
    if  ((lpStr[*lpIndex] == cSeparator1) ||
         (lpStr[*lpIndex] == cSeparator2))
        *lpIndex += 1;

    return  (TRUE);
}


/*
    ParseHexWord

    This routine parses up to 4 hex digits from the string passed in.
    If there are more than 4, then it is a parse error.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the semicolon following the
    number parsed. If the number was bad, or there was no semicolon
    or end of string (i.e. NULL) immediately after it, then a FALSE
    is returned. Otherwise TRUE is returned.
*/
int CFUNC
ParseHexWord (LPCHAR lpStr, LPULONG lpIndex, LPUSHORT lpNum)
{
    int     nRet;
    ULONG   dwNum;

    nRet = ParseHexSeparator (lpStr, lpIndex, &dwNum, 4, ';', ';');
    *lpNum = (USHORT) dwNum;

    return  (nRet);
}


/*
    ParseHexDWord

    This routine parses up to 8 hex digits from the string passed in.
    If there are more than 8, then it is a parse error.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the semicolon following the
    number parsed. If the number was bad, or there was no semicolon
    or end of string (i.e. NULL) immediately after it, then a FALSE
    is returned. Otherwise TRUE is returned.
*/
int CFUNC
ParseHexDWord (LPCHAR lpStr, LPULONG lpIndex, LPULONG lpNum)
{
    return  (ParseHexSeparator (lpStr, lpIndex, lpNum, 8, ';', 0));
}


/*
    GetMaximumRefreshRate

    This routine calculates the maximum refresh rate for the target mode
    specified given the maimum XRes and YRes, and the maximum horizontal
    and vertical frequencies.

*/

ULONG CFUNC
GetMaximumRefreshRate (ULONG dwPixelClkXRes,
                       ULONG dwPixelClkYRes,
                       ULONG dwPixelClkRR,
                       LPMONITORLIMITS lpML,
                       ULONG dwTargetXRes,
                       ULONG dwTargetYRes)
{
    ULONG   i;
    ULONG   dwRefreshRate;
    GTFIN   GTFIn;
    GTFOUT  GTFOut;
    ULONG   dwTotalPixels;
    ULONG   dwPixelClockInHz;
    ULONG   dwPixelClockInMHz;
    ULONG   dwHorizRR;
    ULONG   dwHTotalPixels;
    char    FoundRR;

    // If no pixel clock was passed in, calculate one.
    if (!lpML->dwMaxPixelClock)
    {
        // Find a pixel clock from the dwPixelClkXRes, dwPixelClkXRes, and
        // dwPixelClkRR.
        GTFIn.dwHPixels      = dwPixelClkXRes;
        GTFIn.dwVLines       = dwPixelClkYRes;
        GTFIn.dwMarginsRqd   = FALSE;
        GTFIn.dwIntRqd       = FALSE;
        GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
        GTFIn.dwIPFreqRqd    = dwPixelClkRR;

        // Get the timing parameters.
        ComputeGTFParameters(&GTFIn, &GTFOut);
        dwPixelClockInHz = Multiply32By32(GTFOut.dwPixelClockIn10KHertz,
                                          10000);
        lpML->dwMaxPixelClock = dwPixelClockInHz;
    }
    else
        dwPixelClockInHz = lpML->dwMaxPixelClock;

    for (i = 0, FoundRR = FALSE; (FoundRR != TRUE) && i < 50; i++)
    {
        dwPixelClockInMHz = Divide32By32(dwPixelClockInHz + 1000000/2, 1000000);
    
        GTFIn.dwHPixels      = dwTargetXRes;
        GTFIn.dwVLines       = dwTargetYRes;
        GTFIn.dwMarginsRqd   = FALSE;
        GTFIn.dwIntRqd       = FALSE;
        GTFIn.dwIPParmType   = IPTYPE_PIXEL_CLOCK_RATE;
        GTFIn.dwIPFreqRqd    = dwPixelClockInMHz;
    
        // Get the timing parameters.
        ComputeGTFParameters(&GTFIn, &GTFOut);
    
        dwTotalPixels = Multiply32By32((GTFOut.dwHTotalChars << 3), GTFOut.dwVTotalScans);
    
        dwPixelClockInHz = Multiply32By32(GTFOut.dwPixelClockIn10KHertz, 10000);
        dwRefreshRate = Divide32By32(dwPixelClockInHz + dwTotalPixels/2, dwTotalPixels);
    
        if (dwRefreshRate < 56)
          dwRefreshRate = 60;

        dwHTotalPixels = GTFOut.dwHTotalChars << 3;
        dwHorizRR = Divide32By32(dwPixelClockInHz + dwHTotalPixels/2, dwHTotalPixels);
        if (dwHorizRR > lpML->dwMaxHorz)
        {
          dwPixelClockInHz = Multiply32By32(lpML->dwMaxHorz, dwHTotalPixels);
        }
        else if (dwRefreshRate > lpML->dwMaxVert)
        {
          dwPixelClockInHz = Multiply32By32(lpML->dwMaxVert, dwHTotalPixels);
          dwPixelClockInHz = Multiply32By32(dwPixelClockInHz, GTFOut.dwVTotalScans);
        }
        else
          FoundRR = TRUE;
    }
            
    if  (dwRefreshRate != 0)
        return  (dwRefreshRate);

    return  (60);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\cmntypes.h ===
/*
    FILE:   cmntypes.h
    DATE:   10/12/1999

    This file contains common type definitions needed in other
    include files and source files so that they don't need to be
    defined in multiple places.
*/

// A few constants
#define TRUE    1
#define FALSE   0
#ifndef NULL
#define NULL    0
#endif

// Need these for C To ASM conversion reason.
#ifndef FAR
#ifdef _WIN32
#define FAR
#define CFUNC   __cdecl
#define WINAPI  _stdcall
#else   // !_WIN32

#if     defined(LINUX) | defined(MAC)

#define FAR 
#define CFUNC
#define WINAPI

#else   // !LINUX
#define FAR __far
#define CFUNC   __cdecl  _loadds
#define WINAPI  _far _pascal  _loadds
#endif  // !LINUX
#endif  // !WIN32
#endif  // FAR

// A few basic types
#ifndef ULONG
typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef UCHAR  FAR *    LPCHAR;
typedef USHORT FAR *    LPUSHORT;
typedef ULONG  FAR *    LPULONG;
typedef void       *    PVOID;
#endif  // ULONG



#ifdef LINUX
#define __STRUCTURE_PACKING__ __attribute__((packed))
#else
#define __STRUCTURE_PACKING__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\MODEEXT.H ===
/*
    FILE:   modeext.h
    DATE:   4/8/99

    This file is the external API to the world for the
    FindModeExtry and GetModeList functions in the modeset DLL.
    There can be other EXTERNAL function that are OS specific,
    but they should be defined in other header files.
*/


#ifndef __MODEEXT_H__
#define __MODEEXT_H__

#if defined(LINUX) | defined(MAC)

#define FAR

#if defined(MAC)
typedef unsigned short  USHORT;
#endif

#else
// Need these for C To ASM conversion reason.
#ifndef ULONG
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR             __far
#endif
#endif

typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef unsigned char   UCHAR;
typedef UCHAR FAR   *   LPCHAR;
typedef void        *   PVOID;
#endif
#endif  // !linux


// Here is the calling format for both 16bit and 32bit land.
// ULONG __cdecl
// FindModeEntry (
//              LPDISPDATA  lpDispData,
//              LPCHAR      lpEdidBuffer,
//              ULONG       dwEdidSize,
//              LPMODEINFO  lpModeDesc,
//              LPMODEOUT   lpModeOut)
//
// All the structures and types you need are defined in this file.
//
// The FindModeEntry function will always return some legal set of
// values to program in the lpModeOut structure. It may not be the
// requested mode, but the function will never fail to return some
// legitimate values. The actual number returned by the function can
// be a logical OR of the following to indicate whether the parameters
// being returned in lpModeOut are for the requested mode or are for
// a different mode (because the requested mode was not allowed.)
// Note that the return value tells you how different the mode
// returned is from the requested mode -- i.e. whether the mode is
// the same, differes only in the resolution, differes in the pixel
// depth, differs in the refresh rate or some combination thereof.

#define MODE_EXACT_MATCH            0x00
#define MODE_RESOLUTION_ADJUSTED    0x01
#define MODE_PIXEL_DEPTH_ADJUSTED   0x02
#define MODE_REFRESH_RATE_ADJUSTED  0x04

// Although this is kind of Win9X/WinNT specific, it won't hurt to
// put in here. This structure is only used for some calls in the
// Win9X and WinNT specific portion of the modeset dll.
typedef struct  tagREGDATA
{
    ULONG   dwMainKey;
    char    szRegPath[128];
}   REGDATA;
typedef REGDATA FAR *LPREGDATA;

typedef struct  tagDISPDATA
{
    // Every OS probably uses these
    ULONG       dwDeviceID;
    ULONG       dwCRTCIndex;
    ULONG       dwMaxTVOutResolution;
    ULONG       dwVideoMemoryInBytes;
    ULONG       dwMaxDacSpeedInHertz8bpp;
    ULONG       dwMaxDacSpeedInHertz16bpp;
    ULONG       dwMaxDacSpeedInHertz32bpp;
    ULONG       dwMaxDfpScaledXResInPixels;
    ULONG       dwTVEncoderType;
    PVOID       lpfnGetModeSize;
    PVOID       dwContext1;
    PVOID       dwContext2;
    PVOID       lpRTList;
    PVOID       lpModeList;

    /////////////////////////////////////////////////////////////
    // Win9X uses these
    // Registry base path to ...DISPLAY\000X and MONITOR\000X key.
    REGDATA     *lpBoardRegistryData;
    REGDATA     *lpMonitorRegistryData;
    ULONG       dwMonitorInfType;
    ULONG       lpDevData;
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // MAC uses these
    ULONG       edidSize;
    // MAC Done
    /////////////////////////////////////////////////////////////
}   DISPDATA;

typedef DISPDATA FAR *LPDISPDATA;

// dwInfType can have one of the following three values
#define SPECIFIC_DEVICE         0
#define UNKNOWN_DEVICE          1
#define PLUG_AND_PLAY_DEVICE    2

typedef struct  tagDEVDATA
{
    char    cType;
    char    cNumber;
    char    cFormat;
    char    cReserved;
}   DEVDATA;

typedef DEVDATA   FAR *LPDEVDATA;


// Unfortunately we need to pass the TVEncoderType in here. Optimal
// mode timing paramteres for the different TVEncoders are different.
// I hate having aliased constant, but I dont wat to include the
// RM files right now. I'm thinking about how to do this whole thing
// in a bit better a fashion.
#define TV_ENCODER_NONE                 0x000
#define TV_ENCODER_BROOKTREE            0x100
#define TV_ENCODER_CHRONTEL             0x200
#define TV_ENCODER_PHILIPS              0x400
#define NV_ENCODER_NONE                 TV_ENCODER_NONE
#define NV_ENCODER_BROOKTREE_868        (TV_ENCODER_BROOKTREE + 1)
#define NV_ENCODER_BROOKTREE_869        (TV_ENCODER_BROOKTREE + 2)
#define NV_ENCODER_BROOKTREE_871        (TV_ENCODER_BROOKTREE + 3)
#define NV_ENCODER_CHRONTEL_7003        (TV_ENCODER_CHRONTEL + 3)
#define NV_ENCODER_CHRONTEL_7004        (TV_ENCODER_CHRONTEL + 4)
#define NV_ENCODER_CHRONTEL_7005        (TV_ENCODER_CHRONTEL + 5)
#define NV_ENCODER_CHRONTEL_7006        (TV_ENCODER_CHRONTEL + 6)
#define NV_ENCODER_CHRONTEL_7007        (TV_ENCODER_CHRONTEL + 7)
#define NV_ENCODER_CHRONTEL_7008        (TV_ENCODER_CHRONTEL + 8)
#define NV_ENCODER_PHILIPS_7102	        (TV_ENCODER_PHILIPS + 2)
#define NV_ENCODER_PHILIPS_7103	        (TV_ENCODER_PHILIPS + 3)
// = 7102 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7108	        (TV_ENCODER_PHILIPS + 8)
// = 7103 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7109	        (TV_ENCODER_PHILIPS + 9)
// early version of 7108 with clock active edge reversed
#define NV_ENCODER_PHILIPS_7108B        (TV_ENCODER_PHILIPS + 8 + 0x10)


// This is a description of the incoming mode to try and validate/set.
// The dwXRes, dwYRes, and dwBpp fields should be filled in with the
// desired values. dwRefreshRate must be an actual refresh rate in hertz.
// dwDevType should be set to one of the special device type constants
// (CRT, NTSC, PAL, FLAT_PANEL, etc.) given later in this file.
// The dwOriginalRefreshRate is not used as an input parameter, but
// some of the functions in the modeset DLL that return a MODEINFO
// structure return information in this field. Also, dwCRTCIndex is
// not used by the modeset DLL, but by other modules that utilize
// this structure.
typedef struct  tagMODEINFO
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
    ULONG   dwDevType;
    ULONG   dwTVFormat;
    DEVDATA MIDevData;
    ULONG   dwOriginalRefreshRate;
}   MODEINFO;

typedef MODEINFO FAR *LPMODEINFO;

// Display Device Types which can be in MODEINFO.dwDevType
#define DEVTYPE_CRT         0x00
#define DEVTYPE_TV          0x01
#define DEVTYPE_DFP         0x02
#define MAX_DEVTYPES        0x03

// These are for the TvType -- they weren't being used in the generic
// code at the time they were added, but they may be needed in the
// future, or the OS-specific sections may need them. We might as well
// all agree on their values.
#define TVTYPE_NTSCM                0x00
#define TVTYPE_NTSCJ                0x01
#define TVTYPE_PALM                 0x02
#define TVTYPE_PALA                 0x03
#define TVTYPE_PALN                 0x04
#define TVTYPE_PALNC                0x05
#define MAX_TVTYPES                 0x06

// This is the format that the mode timing parameters are handed back
// to the caller. This format was chosen because, as of the time of
// this writing, it matches the format of an NVidia object -- class 46.
typedef struct  _tagMODEOUT
{
    USHORT  wXRes;
    USHORT  wYRes;
    USHORT  wHBlankStart;
    USHORT  wHBlankWidth;
    USHORT  wHSyncStart;
    USHORT  wHSyncWidth;
    USHORT  wVBlankStart;
    USHORT  wVBlankWidth;
    USHORT  wVSyncStart;
    USHORT  wVSyncWidth;
    USHORT  wHTotal;
    USHORT  wVTotal;
    ULONG   dwPixelClock;
    ULONG   dwFormat;
    USHORT  wRefreshRate;
    ULONG   dwPitchInBytes;
} MODEOUT;

typedef MODEOUT FAR *LPMODEOUT;


// There is an API call in this DLL --
// int GetModeList (LPDISPDATA lpDD, LPCHAR lpModes, ULONG dwType)
// lpDD specifies the board to fetch the modelist for.
// If lpModes is NULL, the routine returns the number of modes.
// If lpModes is not NULL, the routine returns the number of modes
// and fills in lpModes with an array of either MODEENTRY, MODEENTRYNORR,
// or MODEENTRYANDPITCH structures depending upon the value of dwType.

// The routine will never return more than this number of modes
#define MAX_MODEENTRYS  2048

// dwType can be one of these values.
#define MODETYPE_MODEENTRYNORR      0
#define MODETYPE_MODEENTRY          1
#define MODETYPE_MODEENTRYANDPITCH  2

// dwType of MODETYPE_MODEENTRYNORR causes these structurs to be returned
typedef struct  tagMODEENTRYNORR
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
} MODEENTRYNORR;

typedef MODEENTRYNORR FAR *LPMODEENTRYNORR;

// dwType of MODETYPE_MODEENTRY causes these structurs to be returned
typedef struct  tagMODEENTRY
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
} MODEENTRY;

typedef MODEENTRY FAR *LPMODEENTRY;

// dwType of MODETYPE_MODEENTRYANDPITCH causes these structurs to be returned
typedef struct  tagMODEENTRYANDPITCH
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwPitch;
} MODEENTRYANDPITCH;

typedef MODEENTRYANDPITCH FAR *LPMODEENTRYANDPITCH;

#endif /* __MODEEXT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\DEBUG.H ===
/*
    FILE:   debug.h
    DATE:   4/8/99

    This file has some things in it for debug.  Since the debug
    facilities are OS dependent, the macros invoke functions that
    can be written in the OS specific libraries.
*/

extern  char    szDebug[512];
extern  ULONG   dwDebugLevel;

// A little bit of debugging support.
#ifdef DEBUG
#define DL_0    1
#define DL_1    2
#define DL_2    3
#define DL_3    4
#define DL_4    5
#define DL_5    6

#ifdef LINUX
#include "os.h" // Xserver header file for definition of ErrorF
#define PrintString0(y)     ErrorF (y);
#define PrintString1(y,z)   ErrorF (y,z);
#endif

#define DBG_PRINT0(x,y)     {                                   \
                                if  ((x) <= dwDebugLevel)       \
                                    PrintString0(y);            \
                            }

#define DBG_PRINT1(x,y,z)   {                                   \
                                if  ((x) <= dwDebugLevel)       \
                                    PrintString1(y,z);          \
                            }
#else
#define DBG_PRINT0(x,y)
#define DBG_PRINT1(x,y,z)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\RESTIME.H ===
/*
    FILE:   restime.h
    DATE:   4/8/99

    This file has routines to support getting and parsing the restriction
    and timing strings. OS independent stuff.
*/

// This is the maximum number of R&T strings allowed.
#define MAX_RESTIMES    128

// For any of the fields in the R&T string that can be separated by a
// '.' (see specification for details), there can be at most the
// following number of DOT separated values per field. For example,
// the MonitorID field can have up to MAX_DOT_FIELDS monitorIDs.
// Example DT71.SN17.VS85 is three monitor IDS.
#define MAX_DOT_FIELDS  16

// For those R&T strings which allow a wildcard indicating ALL, this
// is the wildcard character.
#define ALL_WILDCARD    ('*')

// For each restriction and timing string that gets parsed, the string
// is parsed into the following structure.
typedef struct  tagRESTIME
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwPixelDepth;
    ULONG   dwRefreshRate;
    USHORT  wDeviceID[MAX_DOT_FIELDS];
    ULONG   dwMonitorID[MAX_DOT_FIELDS];
    ULONG   dwTimingStandard[MAX_DOT_FIELDS];
    MODEOUT sModeOut;
} RESTIME;

typedef RESTIME FAR *LPRESTIME;

// A couple of special MonitorIDs. UKWN_ID is a monitor ID which matches
// all monitors that do not have an EDID.
// A couple of special MonitorIDs. UKWN_ID is a monitor ID which matches
// all monitors that do not have an EDID.
#define UKWN_ID ((ULONG) 'U') + (((ULONG) 'K') << 8) + (((ULONG) 'W') << 16) + (((ULONG) 'N') << 24)
#define NTSC_ID ((ULONG) 'N') + (((ULONG) 'T') << 8) + (((ULONG) 'S') << 16) + (((ULONG) 'C') << 24)
#define PALX_ID ((ULONG) 'P') + (((ULONG) 'A') << 8) + (((ULONG) 'L') << 16) + (((ULONG) 'X') << 24)
#define PANL_ID ((ULONG) 'P') + (((ULONG) 'A') << 8) + (((ULONG) 'N') << 16) + (((ULONG) 'L') << 24)

// Several TimingStandardIDs.
#define NONE_ID ((ULONG) 'N') + (((ULONG) 'O') << 8) + (((ULONG) 'N') << 16) + (((ULONG) 'E') << 24)
#define EDID_ID ((ULONG) 'E') + (((ULONG) 'D') << 8) + (((ULONG) 'I') << 16) + (((ULONG) 'D') << 24)
#define DMTV_ID ((ULONG) 'D') + (((ULONG) 'M') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'V') << 24)
#define DMTR_ID ((ULONG) 'D') + (((ULONG) 'M') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'R') << 24)
#define GTFV_ID ((ULONG) 'G') + (((ULONG) 'T') << 8) + (((ULONG) 'F') << 16) + (((ULONG) 'V') << 24)
#define GTFR_ID ((ULONG) 'G') + (((ULONG) 'T') << 8) + (((ULONG) 'F') << 16) + (((ULONG) 'R') << 24)
#define OEMX_ID ((ULONG) 'O') + (((ULONG) 'E') << 8) + (((ULONG) 'M') << 16) + (((ULONG) 'X') << 24)
#define OEMR_ID ((ULONG) 'O') + (((ULONG) 'E') << 8) + (((ULONG) 'M') << 16) + (((ULONG) 'R') << 24)
#define FGTF_ID ((ULONG) 'F') + (((ULONG) 'G') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'F') << 24)
#define FGTR_ID ((ULONG) 'F') + (((ULONG) 'G') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'R') << 24)

// A few of the R&T parsing functions require that a mode be passed in.
// This is the structure that the R&T functions require the mode to be in.
typedef struct  tagRTMODE
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
} RTMODE;

typedef RTMODE FAR *LPRTMODE;

extern int CFUNC RTFindNextMatchingString (LPRESTIME lpRTList,
                        int nIndex, LPDISPDATA lpDispData,
                        LPRTMODE lpRTMode, ULONG dwMonitorID);;

// Return values for a successful RTFindNextMatchingString are any
// positive integer which represents the index of the RTstring in the
// RTList that was a match. The value below is returned if there was no
// match.
#define RTERR_NOT_FOUND -1

extern int CFUNC RTRestrictByTimingStandard (LPRESTIME lpRTList, int nIndex,
                                    ULONG dwTimingStandard);

int CFUNC ParseRTString (LPRESTIME lpRT, LPCHAR szRTString);
int CFUNC ParseDecimalNumberOrWildcard (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
int CFUNC ParseDeviceIDs (LPCHAR szRTString, LPULONG lpIndex,
                                LPUSHORT lpNum);
int CFUNC ParseMonitorIDs (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
int CFUNC ParseTimingStandards (LPCHAR szRTString,
                                LPULONG lpIndex, LPULONG lpNum);
int CFUNC ParseDecimalNumberComma (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\UTILS.H ===
/*
    FILE:   utils.h

    DATE:   4/8/99

    This file holds some utility routines.  OS independent
*/

extern int CFUNC FindMode (LPMODESTRUC lpMS, ULONG dwXRes,
                            ULONG dwYRes, ULONG dwRRate);
extern int CFUNC FindModeWithoutRR (LPMODESTRUC lpMS, ULONG dwXRes,
                            ULONG dwYRes);
extern int CFUNC SetupParamsForVidLutClass (LPMODESTRUC lpMS,
                            LPMODEOUT lpModeOut,
                            LPMODEINFO lpModeIn);
extern int CFUNC SetupParamsForModeInfo (LPMODEOUT lpModeOut,
                            LPMODEINFO lpModeOrig, LPMODEINFO lpModeIn);
extern int CFUNC ParseDecimalNumber (LPCHAR szRTString, LPULONG lpIndex,
                            LPULONG lpNum);
extern ULONG CFUNC GetDecimalValue (char cDigit);
extern int CFUNC ParseHexWord (LPCHAR szRTString, LPULONG lpIndex,
                            LPUSHORT lpNum);
extern int CFUNC ParseHexDWord (LPCHAR szRTString, LPULONG lpIndex,
                            LPULONG lpNum);
extern int CFUNC ParseDecimalSeparator (LPCHAR lpStr, LPULONG lpIndex,
                            LPULONG lpNum, char cSeparator1,
                            char cSeparator2);
extern int CFUNC ParseDecimalNumberAndFractionAndSeparator (LPCHAR  lpStr,
                            LPULONG lpIndex, LPULONG lpNum,
                            char    cSeparator1, char    cSeparator2);
extern int CFUNC ParseHexSeparator (LPCHAR  lpStr, LPULONG lpIndex,
                            LPULONG lpNum, ULONG   dwLen,
                            char cSeparator1, char cSeparator2);
extern ULONG CFUNC GetHexValue (char cDigit);

extern ULONG CFUNC GetMaximumRefreshRate (ULONG dwPixelClkXRes,
                            ULONG dwPixelClkYRes, ULONG dwPixelClkRR,
                            LPMONITORLIMITS lpML, ULONG dwTargetXRes,
                            ULONG dwTargetYRes);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\linux\MODELIST.C ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to get the master mode list.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "osapi.h"

/*
 * List of safe modes...
 */
MODEENTRY   modeEntries[] = 
{
    {640,   480,  8, 60},
    {800,   600,  8, 60},
    {1024,  768,  8, 60},
    {1152,  864,  8, 60},
    {1280, 1024,  8, 60},
    {640,   480, 16, 60},
    {800,   600, 16, 60},
    {1024,  768, 16, 60},
    {1152,  864, 16, 60},
    {1280, 1024, 16, 60},
    {640,   480, 32, 60},
    {800,   600, 32, 60},
    {1024,  768, 32, 60},
    {1152,  864, 32, 60},
    {1280, 1024, 32, 60},
    {1152,  864, 32, 60},
    {1280, 1024, 32, 60},
    {   0,    0,  0,  0}
};
LPMODEENTRY lpMasterModeList = modeEntries;

/*
 * SetMasterModeList
 *
 * The XServer needs to be able to pass in a list of available modes.
 */
void SetMasterModeList(void *lpModeList)
{
    /*
     * Store the pointer to the master mode list.
     */
    lpMasterModeList = (LPMODEENTRY)lpModeList;
}


/*
    GetMasterModeList

    This routine returns a ptr to a an array of MODEENTRY
    structures which describe the list of available modes for
    the board specified. This routine needs to ALWAYS return
    some mode list. If you have to just return a list of safe
    modes like 640,480,8,60Hz.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPBOARDDATA lpBoardData)
{
    // You can't return NULL -- this is just a template.
    return  (lpMasterModeList);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    /*
     * Reset the master mode list to the default mode list.
     */
    lpMasterModeList = modeEntries;
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\OSAPI.H ===
/*
    FILE:   osapi.h
    DATE:   4/8/99

    This file holds the externs for the os-specific routines that
    support the mode set code.
*/

extern LPMODEENTRY CFUNC GetMasterModeList (LPDISPDATA lpDispData);
extern int CFUNC FreeMasterModeList (LPMODEENTRY lpModeList);

extern LPRESTIME CFUNC GetMasterRTList (LPDISPDATA lpDispData);
extern int CFUNC FreeMasterRTList (LPRESTIME lpRTList);

extern ULONG CFUNC GetTimingStandardOverride (LPDISPDATA lpDispData);
extern ULONG CFUNC GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes,
            ULONG dwYRes, ULONG dwBpp, ULONG *dwPitch, ULONG *dwModeSize);

extern int CFUNC GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo);

int CFUNC GetMonitorInfRangeLimits (LPDISPDATA lpDispData,
                     LPMONITORLIMITS lpML, ULONG *lpdwXRes, ULONG *lpdwYRes);

ULONG WINAPI GetAllowAllModesFlag(LPREGDATA lpRegData);

#ifdef LINUX
void SetMonitorLimitMode (void *lpModeLimit, int display_device);
void SetMonitorInfRangeLimits (void *lpRangeLimits, int display_device);
void SetMasterModeList (void *lpModeList, int display_device);
void SetMasterRTList (void *lpRtList, int display_device);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\linux\osapi.c ===
#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "osapi.h"

#include "xf86_ansic.h" // need the declaration of xf86memcpy()	

/*****************************************************************************/
/*

  osapi.c - this source file contains the linux implementation of the following
  functions:

  GetPitchAndSize ()
  SetMonitorLimitMode ()
  GetMonitorLimitMode ()
  SetMonitorInfRangeLimits ()
  GetMonitorInfRangeLimits ()
  SetMasterModeList ()
  GetMasterModeList ()
  FreeMasterModeList ()
  SetMasterRTList ()
  GetMasterRTList ()
  FreeMasterRTList ()  
  GetTimingStandardOverride ()
  GetAllowAllModesFlag ()


*/
/*****************************************************************************/




typedef ULONG   (*LPFNGETMODESIZE) (PVOID, PVOID, ULONG, ULONG,
                                    ULONG, ULONG *, ULONG *);


  
/* List of safe modes; these are the defaults, in case a good master mode
   list isn't set with a call to SetMasterModeList () */

MODEENTRY defaultModeEntries[] = 
{
	{640,   480,  0, 60},
	{640,   480,  0, 72},
	{640,   480,  0, 75},
	{640,   480,  0, 85},
	{800,   600,  0, 56},
	{800,   600,  0, 60},
	{800,   600,  0, 72},
	{800,   600,  0, 75},
	{800,   600,  0, 85},
	{1024,  768,  0, 60},
	{1024,  768,  0, 70},
	{1024,  768,  0, 75},
	{1024,  768,  0, 85},
	{1152,  864,  0, 75},
	{1280, 1024,  0, 60},
	{1280, 1024,  0, 75},
	{1280, 1024,  0, 85},
	{1600, 1024,  0, 60},
	{1600, 1024,  0, 65},
	{1600, 1024,  0, 70},
	{1600, 1024,  0, 75},
	{1600, 1024,  0, 85},
	{1600, 1200,  0, 60},
	{1600, 1200,  0, 65},
	{1600, 1200,  0, 70},
	{1600, 1200,  0, 75},
	{1600, 1200,  0, 85},
	{1792, 1344,  0, 60},
	{1792, 1344,  0, 75},
	{1856, 1392,  0, 60},
	{1856, 1392,  0, 75},
	{1920, 1440,  0, 60},
	{1920, 1440,  0, 75},
	{   0,    0,  0,  0}
};

RESTIME defaultRTList [] =
{
    { 0, 0, 0, 0,
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
    }
};


/* data that is global to these routines */

MONITORLIMITS *lpMonitorRangeLimits[8] = {NULL, NULL, NULL, NULL,
                                          NULL, NULL, NULL, NULL};

MODEINFO *lpMonitorLimitMode[8] = {NULL, NULL, NULL, NULL,
                                   NULL, NULL, NULL, NULL};

MODEENTRY *lpMasterModeList[8] = {NULL, NULL, NULL, NULL,
                                  NULL, NULL, NULL, NULL};

RESTIME *lpResTimeList[8] = {NULL, NULL, NULL, NULL,
                             NULL, NULL, NULL, NULL};









/*****************************************************************************/
/* GetPitchAndSize () - This routine returns the pitch for a given mode;
   this implementation assumes that the function pointer
   pDispData->lpfnGetModeSize has been set by the caller of FindModeEntry.

   Arguments:  lpDispData  - identifies the specific board that we
                             want the active display port for.
               dwXRes      - The X res in pixels for the mode
                             should be returned.
               dwBpp       - the bits per pixel for the mode

   Returns:    The pitch in bytes */
/*****************************************************************************/

ULONG GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwYRes,
                       ULONG dwBpp, ULONG *dwPitch, ULONG *dwModeSize)
{
    LPFNGETMODESIZE lpfnGetModeSize;
    
    lpfnGetModeSize = (LPFNGETMODESIZE) lpDispData->lpfnGetModeSize;
    return  ((*lpfnGetModeSize) (lpDispData->dwContext1,
                                 lpDispData->dwContext2,
                                 dwXRes, dwYRes, dwBpp, dwPitch, dwModeSize));
} // GetPitchAndSize




/*****************************************************************************/
/* SetMonitorLimitMode ()
   GetMonitorLimitMode ()

   This pair of functions provides a means for the caller of modeset code to
   define a mode which should be used as an upper bound for a specific
   display device (aka. physical head).  In general, the user should only
   need to call SetMonitorLimitMode, and GetMonitorLimitMode will be used
   internally by modeset.

   Note that GetMonitorLimitMode is currently only called if both EDIDs and
   inf fail to define maximum mode values. */
/*****************************************************************************/

void SetMonitorLimitMode (void *lpModeLimit, int display_device)
{
    lpMonitorLimitMode[display_device] = (LPMODEINFO)lpModeLimit;
}


int GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    int display_device = lpDispData->dwDeviceID;
    
    if (lpMonitorLimitMode[display_device]) {
        xf86memcpy (lpModeInfo, lpMonitorLimitMode[display_device],
                sizeof (MODEINFO));
        return (TRUE);
    }
    return (FALSE);
}



/*****************************************************************************/
/* SetMonitorInfRangeLimits ()
   GetMonitorInfRangeLimits ()

   This pair of functions provides a means for the caller of modeset code to
   define range limits for a specific display device (aka. physical head).
   In general, the user should only need to call SetMonitorInfRangeLimits,
   and GetMonitorInfRangeLimits will be called internally by modeset.

   Note that the implementation of GetMonitorInfRangeLimits requires both
   the lpMonitorRangeLimits AND lpMonitorLimitMode arrays to be defined
   for the given display device (the user should be calling both
   SetMonitorInfRangeLimits and SetMonitorLimitMode).

   Note also that these range limits are only used if no EDIDs are available
   (see ModeWithinMonitorTimingLimits() in digmode.c) */
/*****************************************************************************/

void SetMonitorInfRangeLimits (void *lpRangeLimits, int display_device)
{
    lpMonitorRangeLimits[display_device] = (LPMONITORLIMITS)lpRangeLimits;
}

int GetMonitorInfRangeLimits (LPDISPDATA lpDispData, LPMONITORLIMITS lpML,
                              ULONG *lpdwXRes, ULONG *lpdwYRes)
{
    int display_device = lpDispData->dwDeviceID;

    if ((lpMonitorRangeLimits[display_device]) &&
        (lpMonitorLimitMode[display_device])) {
        xf86memcpy (lpML, lpMonitorRangeLimits[display_device],
                sizeof (MONITORLIMITS));
        
        *lpdwXRes = lpMonitorLimitMode[display_device]->dwXRes;
        *lpdwYRes = lpMonitorLimitMode[display_device]->dwYRes;
        
        return (TRUE);
    }
    return FALSE;
}



/*****************************************************************************/
/* SetMasterModeList ()
   GetMasterModeList ()
   FreeMasterModeList ()

   This set of functions provides a mechanism for the user to define the master
   list of modes for a specific display device.

   SetMasterModeList should be called to set the modelist for a given display
   device; GetMasterModeList is called internally by modeset to retrieve the
   list set by the user (a default is supplied because GetMasterModeList is
   not allowed to fail); and finally, FreeMasterModeList is called internally
   by modeset to free any memory allocated by the implementation of the
   {Set,Get}MasterModeList routines. */
/*****************************************************************************/

void SetMasterModeList (void *lpModeList, int display_device)
{
    lpMasterModeList[display_device] = (LPMODEENTRY)lpModeList;
}

LPMODEENTRY GetMasterModeList (LPDISPDATA lpDispData)
{
    int display_device = lpDispData->dwDeviceID;

    if (lpMasterModeList[display_device])
        return (lpMasterModeList[display_device]);

    return (defaultModeEntries);
}

int FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return (TRUE);
}







/*****************************************************************************/
/* SetMasterRTList ()
   GetMasterRTList ()
   FreeMasterRTList ()

   This set of functions provides an interface for the user of modeset to
   define a restriction and timing list for a specific head.  

   SetMasterRTList should be called to set the RT list for a given display
   device; GetMasterRTList is called internally by modeset to retrieve the
   list set by the user (a default empty list is supplied because
   GetMasterRTList is not allowed to fail); and finally, FreeMasterRTList is
   called internally by modeset to free any memory allocated by the
   implementation of the {Set,Get}MasterRTList routines. */
/*****************************************************************************/

void SetMasterRTList(void *lpRtList, int display_device)
{
    lpResTimeList[display_device] = (LPRESTIME)lpRtList;
}

LPRESTIME GetMasterRTList (LPDISPDATA lpDispData)
{
    int display_device = lpDispData->dwDeviceID;
    
    if (lpResTimeList[display_device])
        return (lpResTimeList[display_device]);
    
    // Here is returning a blank list.
    return (defaultRTList);
}

int FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}



/*****************************************************************************/
/* GetTimingStandardOverride () - This routine gets any timing standard
   override for the board specified. It should return one of the constants
   defined in restime.h like DMTV_ID. A timing standard override is a timing
   standard that applies to all modes. Just something that the user might want
   to enforce.

   This is currently not implemented on linux. */
/*****************************************************************************/

ULONG GetTimingStandardOverride (LPDISPDATA lpDispData)
{
    /* what should we do here? */
    
    return (NONE_ID);
}


/*****************************************************************************/
/* GetAllowAllModesFlag () - not needed on linux */
/*****************************************************************************/

ULONG GetAllowAllModesFlag (LPREGDATA lpRegData)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\linux\getit.c ===
#include "cmntypes.h"
#include "modeext.h"
#include "restime.h"

/*
    Function:   GetPitch

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpBoardData - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/
typedef ULONG   (*LPFNGETPITCH) (ULONG, ULONG);

ULONG CFUNC
GetPitch (LPBOARDDATA lpBoardData, ULONG dwXRes, ULONG dwBpp)
{
    LPFNGETPITCH    lpfnGetPitchNew;

    lpfnGetPitchNew = (LPFNGETPITCH) lpBoardData->lpfnGetDisplayPitch;
    return  ((*lpfnGetPitchNew) (dwXRes, dwBpp));
}
/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board
    specified. It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC
GetTimingStandardOverride (LPBOARDDATA lpBoardData)
{
    return  (NONE_ID);
}

/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpBoardData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC
GetMonitorLimitMode (LPBOARDDATA lpBoardData, LPMODEINFO lpModeInfo)
{
    /*
     * CHASCHAS - not yet implemented!!!
     */
//    return  (GrabModeInfoString (lpBoardData, NV4_REG_DRV_MONITOR_LIMIT_MODE, lpModeInfo));
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\linux\mathrtns.c ===
/*
    FILE:   mathrtns.c
    DATE:   12/22/99

    This file contains math routines which need to be handled in an OS
    specific manner.  The X driver should not include system header files,
    so we have to include "xf86_ansic.h".
*/

#include "xf86_ansic.h"


float calcFLOOR(float fInput)
{
    return (floor(fInput));
}

float calcROUND(float fInput)
{
    return (calcFLOOR(fInput+0.5f));
}

float calcSQRT(float fInput)
{
    return ((float)sqrt((double)fInput));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\linux\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "osapi.h"

// Just in case we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine returns a ptr to a an array of RESTIME
    structures which describe the list of R&T strings for
    the board specified. This routine needs to ALWAYS return
    some RT list. If you have to just return a blank list.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPRESTIME CFUNC
GetMasterRTList (LPBOARDDATA lpBoardData)
{
    LPRESTIME   lpRTList;

    // Here is returning a blank list.
    lpRTList = &sRTList;
    lpRTList[0].dwXRes = 0;
    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\mac\defines.h ===
#define MAC     1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\mac\mathrtns.c ===
/*
    FILE:   mathrtns.c
    DATE:   12/22/99

    This file contains math routines which need to be handled in an OS
    specific manner.
*/

#include "math.h"

float calcFLOOR(float fInput);
float calcROUND(float fInput);
float calcSQRT(float fInput);

float calcFLOOR(float fInput)
{
    return (floor(fInput));
}

float calcROUND(float fInput)
{
    return (calcFLOOR(fInput+0.5f));
}

float calcSQRT(float fInput)
{
    return ((float)sqrt((double)fInput));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\mac\getit.c ===
/*
    FILE:   getit.c
    DATE:   4/8/99

    This file holds code to get the mode, and output device from
    the registry for the given board.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
//#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "::code:edid.h"
#include "::code:gtfmath.h"

typedef struct  tagDEVNAMEANDTYPE
{
    LPCHAR  lpszName;
    LPCHAR  lpszForceModeName;
    LPCHAR  lpszLastDevMode;
    LPCHAR  lpszDefRefName;
    LPCHAR  lpszOptRefName;
    ULONG   dwDevType;
    ULONG   dwTvType;
} DEVNAMEANDTYPE;

ULONG CFUNC GetPitch(LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwBpp);
ULONG CFUNC GetTimingStandardOverride(LPDISPDATA lpDispData);
int WINAPI GetDisplayDevice(LPDISPDATA lpDispData, LPULONG lpDevType, LPULONG lpTvFormat);
int WINAPI SetDisplayDevice(LPDISPDATA lpDispData, ULONG dwDevType, ULONG dwTvFormat);
int WINAPI SetLastDisplayDevice(LPDISPDATA lpDispData, ULONG dwDevType, ULONG dwTvFormat);
int WINAPI SetDisplayDeviceMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo);
int WINAPI GetEdidRegistryKey(LPDISPDATA lpDispData);
int WINAPI GetDisplayOverrideKey(LPDISPDATA lpDispData);
int CFUNC GrabModeInfoString(LPDISPDATA lpDispData, LPCHAR lpModeString, LPMODEINFO lpMI);
int CFUNC GetMonitorInfRangeLimits(LPDISPDATA lpDispData, LPMONITORLIMITS lpML, ULONG *lpdwXRes, ULONG *lpdwYRes);
ULONG CFUNC GetDefaultRefreshRate(LPDISPDATA lpDispData, ULONG dwDevType);
ULONG CFUNC GetOptimalRefreshRate(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int CFUNC GrabRefreshRateFromKey(ULONG hKey, LPDISPDATA lpDispData, LPCHAR lpszPath, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int WINAPI GetForcedMode(LPDISPDATA lpDispData, LPMODEINFO lpSuggMode, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int WINAPI GetFirstBootMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int WINAPI GetDisplayDeviceMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize, ULONG dwFirstBootLogic);
int CFUNC GetMonitorLimitMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo);



/*
    Function:   GetPitch

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/
typedef ULONG   (*LPFNGETMODESIZE) (ULONG, ULONG, ULONG, ULONG, ULONG, ULONG *, ULONG *);
ULONG CFUNC GetPitchAndSize
(
    LPDISPDATA  lpDispData,
    ULONG       dwXRes,
    ULONG       dwYRes,
    ULONG       dwBpp,
    ULONG      *pdwPitch,
    ULONG      *pdwSize
)
{
    LPFNGETMODESIZE lpfnGetModeSize;

    lpfnGetModeSize = (LPFNGETMODESIZE) lpDispData->lpfnGetModeSize;
    return  ((*lpfnGetModeSize) (lpDispData->dwContext1, lpDispData->dwContext2, dwXRes, dwYRes, dwBpp, pdwPitch, pdwSize));
}


/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board
    specified. It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC GetTimingStandardOverride
(
    LPDISPDATA lpDispData
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (NONE_ID);
}


/*
    Function:   GetDisplayDevice

    Purpose:    This routine gets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpDevType   - ptr to where the basic display type
                              should be returned.
                lpTvFormart - ptr to where the specific flavor of
                              the tv type should be returned.

    Returns:    lpDevType should be filled in with one of the
                DEVTYPE_XXXX constants defined in modeext.h
                If lpDevType is set to DEVTYPE_NTSC or DEVTYPE_PAL,
                then lpTvFormat should be set to one of the
                TVTYPE_XXXX constants defined in modeext.h
*/
int WINAPI GetDisplayDevice
(
    LPDISPDATA lpDispData,
    LPULONG lpDevType,
    LPULONG lpTvFormat
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */


    *lpDevType  = DEVTYPE_CRT;
    *lpTvFormat = 0; // Always 0 for CRTC
    return  (TRUE);
}


/*
    Function:   SetDisplayDevice

    Purpose:    This routine sets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                dwDevType   - the basic display type
                              should be one of the DEVTYPE_XXXX
                              sonstants definde in modeext.h
                dwTvFormart - the specific flavor of the tv type
                              should be one of the TVTYPE_XXXX
                              sonstants definde in modeext.h

    Returns:    Always returns TRUE
*/
int WINAPI SetDisplayDevice
(
    LPDISPDATA lpDispData,
    ULONG dwDevType,
    ULONG dwTvFormat
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    Function:   SetLastDisplayDevice

    Purpose:    This routine sets the display device for the board
                specified. The particular display device is stored
                in the registry. This routine is subtley different
                than SetDisplayDevice.  It is a different key in
                the registry and is used by the caller to track
                mode changes, etc.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                dwDevType   - the basic display type
                              should be one of the DEVTYPE_XXXX
                              sonstants definde in modeext.h
                dwTvFormart - the specific flavor of the tv type
                              should be one of the TVTYPE_XXXX
                              sonstants definde in modeext.h

    Returns:    Always returns TRUE
*/
int WINAPI SetLastDisplayDevice
(
    LPDISPDATA lpDispData,
    ULONG dwDevType,
    ULONG dwTvFormat
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    Function:   SetDisplayDeviceMode

    Purpose:    This routine writes a string in the registry
                inidcating the xres,yres,bpp,refrate for a
                given display device (CRT,PAL,NTSC,DFP) on
                a specific board (given by the location of
                the string in the registry.)

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - tells the mode and display device
                              to write.

    Returns:    Always returns TRUE
*/
int WINAPI SetDisplayDeviceMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    Function:   GetEdidRegistryKey

    Purpose:    This routine gets the registry key that tells
                whether or not we are supposed to read the EDID.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.

    Returns:    0       registry key does not exist or says not to
                        read the EDID
                non-0   registry key exists and says to read the EDID
*/
int WINAPI GetEdidRegistryKey
(
    LPDISPDATA lpDispData
)
{
    int     nFlag;

/*
 * CHASCHAS - How will we do this on Mac?
 */
    nFlag = 0;
    return  (nFlag);
}


/*
    Function:   GetDisplayOverrideKey

    Purpose:    This routine reads the key that determines if we
                are supposed to force to a particular display
                device (like DFP over CRT, etc.)

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.

    Returns:
                DEVTYPE_CRT registry key exists and says to use CRT
                DEVTYPE_DFP registry key exists and says to use DFP
                else        registry key does not exist or does not
                            specify one of the possible display override
                            options.
*/
int WINAPI GetDisplayOverrideKey
(
    LPDISPDATA lpDispData
)
{
    int     nFlag;

/*
 * CHASCHAS - How will we do this on Mac?
 */

    nFlag = DEVTYPE_NONE;
    return  (nFlag);
}


/*
    Function:   GrabModeInfoString

    Purpose:    This routine reads and parses a string of the
                form "xres,yres,bpp,refrate" from the registry.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeString - Name of entry in registry (relative
                              to XXXX\NVidia\Display) that tells the
                              specific mode string to read.
                lpMI        - MODEINFO ptr where parsed mode goes

    Returns:    TRUE  that a valid mode was parsed and stored in lpMI
                FALSE there was a problem with the parsing and lpMI
                does not contain valid data.

                NOTE: Even if this routine returns TRUE, it does not
                mean the mode is reasonable. 1,1,55,9876 would be parsed
                fine, but it is not a valid mode string. The caller
                must check for validity if it needs to ensure this.
*/
int CFUNC GrabModeInfoString
(
    LPDISPDATA lpDispData,
    LPCHAR lpModeString,
    LPMODEINFO lpMI
)
{
    int     bModeValid = FALSE;

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (bModeValid);
}


/*
    Function:   GetMonitorInfRangeLimits

    Purpose:    This routine reads the "MaxResolution" key in the
                active monitor node in the registry to get the
                maximum resolution the monitor can do. It uses
                the maximum resolution itself (like "1600,1200")
                as another subkey under which is typically a
                monitor range limits string which looks like
                "30-95,60-120,-,+" where the first range is
                the horizontal limits inKHz and the second is
                the vertical range in hertz. The last two characters
                are horizontal and vertical sync polarities.
                This range limits string doesn't always exist.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
                lpML        - ptr to a monitor limits structure
                              that will be filled in with range
                              limits obtained or computed from
                              values stuffed in the registry
                              by the moitor .inf file.
                lpdwXRes    - ptr to a variable that will be set
                              to the maximum X-resolution found
                              for this monitor.
                lpdwYRes    - ptr to a variable that will be set
                              to the maximum Y-resolution found
                              for this monitor.

    Returns:    TRUE    then lpML, lpdwXRes, and lpdwYRes have been
                        filled in correctly.
                FALSE   then there was an error getting some value.
*/
int CFUNC GetMonitorInfRangeLimits
(
    LPDISPDATA lpDispData,
    LPMONITORLIMITS lpML,
    ULONG *lpdwXRes,
    ULONG *lpdwYRes
)
{
    if (lpDispData->edidSize == 0)
	    /*
	     * When there's no EDID, just continue processing as normal.
	     */
	    return (FALSE);        
    /*
     * When there's an EDID and this routine is called, that means
     * the EDID didn't have any range limits, but there has been
     * a maximum pixel clock calculated.  Set up a dummy monitor
     * limits table and return true so that modes that use pixel
     * clocks higher than the max pixel clock calculated will get
     * rejected.  All other modes will be accepted.
     */
    /*
     * This just shows that we don't know what the maximum
     * horizontal and vertical values are.
     */
    lpML->dwMaxHorz = 0;
    lpML->dwMaxVert = 0;
    return (TRUE);
}


/*
    Function:   GetDefaultRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
                dwDevType   - tells which display device port is being
                              used since there might be different
                              default refresh rates for DFPs and CRTs.

    Returns:    always returns a value that is the default refresh rate
*/
ULONG CFUNC GetDefaultRefreshRate
(
    LPDISPDATA lpDispData,
    ULONG dwDevType
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (60);
}


/*
    Function:   GetOptimalRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - Current mode and device identifier.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    always returns a value that is the optimal refresh rate
*/
ULONG CFUNC GetOptimalRefreshRate
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (60);
}



/*
    Function:   GrabRefreshRateFromKey

    Purpose:    This routine reads the "RefreshRate" string value
                from the key and path provided and does a little
                preprocessing on what it finds. i.e. it handles
                optimal (-1) and default (0) cases.

    Arguments:  hKey        base Key in registry from which to read
                lpDispData - identifies the specific board that we
                              want the active display port for.
                lpszPath    path in registry to access which may
                            contain a "RefreshRate" string.
                lpModeInfo  - Current mode and device identifier.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    TRUE  then lpModeInfo->dwRefreshRate has a real
                      value stuffed in it. Also the field
                      lpModeInfo->dwOriginalRefreshRate has the
                      "Windows" value in it which might be the same
                      as ->dwRefreshRate if Windows was requesting
                      a specific refresh rate, or it can be 0 for
                      default or -1 for optimal.
                FALSE if nothing was found or there was an error.
*/
int CFUNC GrabRefreshRateFromKey
(
    ULONG hKey,
    LPDISPDATA lpDispData,
    LPCHAR lpszPath,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (FALSE);
}


/*
    Function:   GetForcedMode

    Purpose:    This routine gte s a forced mode if one exists
                in the registry. It then erases the forced mode
                string and processes it appropriately.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    This routine may override the mode provided in the
                lpModeInfo structure. Whether it does or not, it
                MUST do the following:
                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).
                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.
                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.
*/
int WINAPI GetForcedMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpSuggMode,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */
    return  (FALSE);
}



/*
    Function:   GetFirstBootMode

    Purpose:    This routine does some special logic for first
                boot after a restart.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    This routine may override the mode provided in the
                lpModeInfo structure. Whether it does or not, it
                MUST do the following:
                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).
                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.
                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.
*/
int WINAPI GetFirstBootMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */
    return  (FALSE);
}


/*
    Function:   GetDisplayDeviceMode

    Purpose:    This routine gets the correct display mode for
                the device specified by lpDispData and the
                display device given by lpModeInfo->dwDevType.
                lpModeInfo->dwXRes, lpModeInfo->dwYRes, and
                lpModeInfo->dwBpp are valid, but the field
                lpModeInfo->dwRefreshRate is not.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.
                dwFirstBootLogic  If this variable is non-0, then
                              this is the first boot after a power
                              up.  This is just a flag so that this
                              routine can use different logic if it
                              wants to.

    Returns:    This routine may override the mode provided in the
                lpModeInfo structure. Whether it does or not, it
                MUST do the following:
                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).
                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.
                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.

                It Always returns TRUE.
*/
int WINAPI GetDisplayDeviceMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize,
    ULONG dwFirstBootLogic
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */


    // Well, we just have to set up a default refresh rate then
    lpModeInfo->dwRefreshRate = 60;
    lpModeInfo->dwOriginalRefreshRate = lpModeInfo->dwRefreshRate;

    return  (TRUE);
}


/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC GetMonitorLimitMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo
)
{
    return  (GrabModeInfoString (lpDispData, NULL, lpModeInfo));
}

/*
    Function:   GetAllowAllModesFlag

    Purpose:    WIN9X specific function for testing only.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
    Returns:    FALSE.
*/
ULONG WINAPI GetAllowAllModesFlag
(
    LPREGDATA lpRegData
)
{
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\mac\modelist.c ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to build a modelist from the registry
    and to walk the list looking for different things.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "utils.h"
//#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"

MODEENTRY   SafeModeList[] =
{
    { 640,  480, 8,  60 },
    { 800,  600, 8,  60 },
    { 1024, 768, 8,  60 },
    { 640,  480, 16, 60 },
    { 800,  600, 16, 60 },
    { 1024, 768, 16, 60 },
    { 640,  480, 32, 60 },
    { 800,  600, 32, 60 },
    { 1024, 768, 32, 60 },
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   FullModeList[] =
{
    { 640,  480,  8,  60},
    { 640,  480,  8,  67},
    { 640,  480,  8,  75},
    { 640,  480,  8,  85},
    { 640,  480,  8,  153},
    { 800,  600,  8,  60},
    { 800,  600,  8,  72},
    { 800,  600,  8,  75},
    { 800,  600,  8,  85},
    { 800,  600,  8, 125},
    { 832,  624,  8,  75},
    { 832,  624,  8, 120},
    {1024,  768,  8,  60},
    {1024,  768,  8,  70},
    {1024,  768,  8,  75},
    {1024,  768,  8,  85},
    {1024,  768,  8,  99},
    {1056,  792,  8,  96},
    {1152,  870,  8,  75},
    {1280, 1024,  8,  60},
    {1280, 1024,  8,  75},
    {1280, 1024,  8,  85},
    {1600, 1024,  8,  60},
    {1600, 1200,  8,  60},
    {1600, 1200,  8,  65},
    {1600, 1200,  8,  75},
    {1600, 1200,  8,  85},
    {1920, 1440,  8,  60},
    {1920, 1440,  8,  75},
    { 640,  480, 15,  60},
    { 640,  480, 15,  67},
    { 640,  480, 15,  75},
    { 640,  480, 15,  85},
    { 640,  480, 15,  153},
    { 800,  600, 15,  60},
    { 800,  600, 15,  72},
    { 800,  600, 15,  75},
    { 800,  600, 15,  85},
    { 800,  600, 15, 125},
    { 832,  624, 15,  75},
    { 832,  624, 15, 120},
    {1024,  768, 15,  60},
    {1024,  768, 15,  70},
    {1024,  768, 15,  75},
    {1024,  768, 15,  85},
    {1024,  768, 15,  99},
    {1056,  792, 15,  96},
    {1152,  870, 15,  75},
    {1280, 1024, 15,  60},
    {1280, 1024, 15,  75},
    {1280, 1024, 15,  85},
    {1600, 1024, 15,  60},
    {1600, 1200, 15,  60},
    {1600, 1200, 15,  65},
    {1600, 1200, 15,  75},
    {1600, 1200, 15,  85},
    {1920, 1440, 15,  60},
    {1920, 1440, 15,  75},
    { 640,  480, 32,  60},
    { 640,  480, 32,  67},
    { 640,  480, 32,  75},
    { 640,  480, 32,  85},
    { 640,  480, 32,  153},
    { 800,  600, 32,  60},
    { 800,  600, 32,  72},
    { 800,  600, 32,  75},
    { 800,  600, 32,  85},
    { 800,  600, 32, 125},
    { 832,  624, 32,  75},
    { 832,  624, 32, 120},
    {1024,  768, 32,  60},
    {1024,  768, 32,  70},
    {1024,  768, 32,  75},
    {1024,  768, 32,  85},
    {1024,  768, 32,  99},
    {1056,  792, 32,  96},
    {1152,  870, 32,  75},
    {1280, 1024, 32,  60},
    {1280, 1024, 32,  75},
    {1280, 1024, 32,  85},
    {1600, 1024, 32,  60},
    {1600, 1200, 32,  60},
    {1600, 1200, 32,  65},
    {1600, 1200, 32,  75},
    {1600, 1200, 32,  85},
    {1920, 1440, 32,  60},
    {1920, 1440, 32,  75},
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   sLowModes[] =
{
    { 320,  200, 8,  60 },
    { 320,  200, 8,  70 },
    { 320,  200, 8,  72 },
    { 320,  200, 8,  75 },
    { 320,  200, 8,  85 },
    { 320,  200, 8,  100 },
    { 320,  200, 8,  120 },
    { 320,  240, 8,  60 },
    { 320,  240, 8,  70 },
    { 320,  240, 8,  72 },
    { 320,  240, 8,  75 },
    { 320,  240, 8,  85 },
    { 320,  240, 8,  100 },
    { 320,  240, 8,  120 },
    { 400,  300, 8,  60 },
    { 400,  300, 8,  70 },
    { 400,  300, 8,  72 },
    { 400,  300, 8,  75 },
    { 400,  300, 8,  85 },
    { 400,  300, 8,  100 },
    { 400,  300, 8,  120 },
    { 480,  360, 8,  60 },
    { 480,  360, 8,  70 },
    { 480,  360, 8,  72 },
    { 480,  360, 8,  75 },
    { 480,  360, 8,  85 },
    { 480,  360, 8,  100 },
    { 480,  360, 8,  120 },
    { 512,  384, 8,  60 },
    { 512,  384, 8,  70 },
    { 512,  384, 8,  72 },
    { 512,  384, 8,  75 },
    { 512,  384, 8,  85 },
    { 512,  384, 8,  100 },
    { 640,  400, 8,  60 },
    { 640,  400, 8,  70 },
    { 640,  400, 8,  72 },
    { 640,  400, 8,  75 },
    { 640,  400, 8,  85 },
    { 640,  400, 8,  100 },
    { 640,  400, 8,  120 },
    { 320,  200, 16, 60 },
    { 320,  200, 16, 70 },
    { 320,  200, 16, 72 },
    { 320,  200, 16, 75 },
    { 320,  200, 16, 85 },
    { 320,  200, 16, 100 },
    { 320,  200, 16, 120 },
    { 320,  240, 16, 60 },
    { 320,  240, 16, 70 },
    { 320,  240, 16, 72 },
    { 320,  240, 16, 75 },
    { 320,  240, 16, 85 },
    { 320,  240, 16, 100 },
    { 320,  240, 16, 120 },
    { 400,  300, 16, 60 },
    { 400,  300, 16, 70 },
    { 400,  300, 16, 72 },
    { 400,  300, 16, 75 },
    { 400,  300, 16, 85 },
    { 400,  300, 16, 100 },
    { 400,  300, 16, 120 },
    { 480,  360, 16, 60 },
    { 480,  360, 16, 70 },
    { 480,  360, 16, 72 },
    { 480,  360, 16, 75 },
    { 480,  360, 16, 85 },
    { 480,  360, 16, 100 },
    { 480,  360, 16, 120 },
    { 512,  384, 16, 60 },
    { 512,  384, 16, 70 },
    { 512,  384, 16, 72 },
    { 512,  384, 16, 75 },
    { 512,  384, 16, 85 },
    { 512,  384, 16, 100 },
    { 640,  400, 16, 60 },
    { 640,  400, 16, 70 },
    { 640,  400, 16, 72 },
    { 640,  400, 16, 75 },
    { 640,  400, 16, 85 },
    { 640,  400, 16, 100 },
    { 640,  400, 16, 120 },
    { 320,  200, 32, 60 },
    { 320,  200, 32, 70 },
    { 320,  200, 32, 72 },
    { 320,  200, 32, 75 },
    { 320,  200, 32, 85 },
    { 320,  200, 32, 100 },
    { 320,  200, 32, 120 },
    { 320,  240, 32, 60 },
    { 320,  240, 32, 70 },
    { 320,  240, 32, 72 },
    { 320,  240, 32, 75 },
    { 320,  240, 32, 85 },
    { 320,  240, 32, 100 },
    { 320,  240, 32, 120 },
    { 400,  300, 32, 60 },
    { 400,  300, 32, 70 },
    { 400,  300, 32, 72 },
    { 400,  300, 32, 75 },
    { 400,  300, 32, 85 },
    { 400,  300, 32, 100 },
    { 400,  300, 32, 120 },
    { 480,  360, 32, 60 },
    { 480,  360, 32, 70 },
    { 480,  360, 32, 72 },
    { 480,  360, 32, 75 },
    { 480,  360, 32, 85 },
    { 480,  360, 32, 100 },
    { 480,  360, 32, 120 },
    { 512,  384, 32, 60 },
    { 512,  384, 32, 70 },
    { 512,  384, 32, 72 },
    { 512,  384, 32, 75 },
    { 512,  384, 32, 85 },
    { 512,  384, 32, 100 },
    { 640,  400, 32, 60 },
    { 640,  400, 32, 70 },
    { 640,  400, 32, 72 },
    { 640,  400, 32, 75 },
    { 640,  400, 32, 85 },
    { 640,  400, 32, 100 },
    { 640,  400, 32, 120 },
    { 960,  720, 8,  60 },
    { 960,  720, 8,  70 },
    { 960,  720, 8,  72 },
    { 960,  720, 8,  75 },
    { 960,  720, 8,  85 },
    { 960,  720, 8,  100 },
    { 960,  720, 8,  120 },
    { 960,  720, 8,  140 },
    { 960,  720, 8,  144 },
    { 960,  720, 8,  150 },
    { 960,  720, 8,  170 },
    { 960,  720, 8,  200 },
    { 960,  720, 8,  240 },
    { 960,  720, 16, 60 },
    { 960,  720, 16, 70 },
    { 960,  720, 16, 72 },
    { 960,  720, 16, 75 },
    { 960,  720, 16, 85 },
    { 960,  720, 16, 100 },
    { 960,  720, 16, 120 },
    { 960,  720, 16, 140 },
    { 960,  720, 16, 144 },
    { 960,  720, 16, 150 },
    { 960,  720, 16, 170 },
    { 960,  720, 16, 200 },
    { 960,  720, 16, 240 },
    { 960,  720, 32, 60 },
    { 960,  720, 32, 70 },
    { 960,  720, 32, 72 },
    { 960,  720, 32, 75 },
    { 960,  720, 32, 85 },
    { 960,  720, 32, 100 },
    { 960,  720, 32, 120 },
    { 960,  720, 32, 140 },
    { 960,  720, 32, 144 },
    { 960,  720, 32, 150 },
    { 960,  720, 32, 170 },
    { 960,  720, 32, 200 },
    { 960,  720, 32, 240 },
    { 0,    0,   0,  0  },
};

LPMODEENTRY lpMasterModeList = SafeModeList;

#define USE_60HZ                        0x00
#define USE_REFRESH_RATES_FROM_LOWER    0x01
#define USE_REFRESH_RATES_FROM_STRING   0x02

extern int CFUNC GetSafeModeList (LPMODEENTRY lpModeList);

/*
 * SetMasterModeList
 *
 * The XServer needs to be able to pass in a list of available modes.
 */
void SetMasterModeList(void *lpModeList);
void SetMasterModeList(void *lpModeList)
{
    /*
     * Store the pointer to the master mode list.
     */
#if 1 /* CHASCHAS - Temporary */
    if (lpModeList)
        lpMasterModeList = FullModeList;
    else
        lpMasterModeList = SafeModeList;
#else
    if (lpModeList)
        lpMasterModeList = (LPMODEENTRY)lpModeList;
    else
        lpMasterModeList = SafeModeList;
#endif
}

/*
    GetMasterModeList

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpDispData)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (lpMasterModeList);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    int     i;

    for (i = 0; SafeModeList[i].dwXRes != 1; i++)
        lpModeList[i] = SafeModeList[i];

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\mac\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "restime.h"
#include "debug.h"

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     rtList;
LPRESTIME   lpResTimeList = NULL;

LPRESTIME CFUNC GetMasterRTList(LPDISPDATA lpDispData);
int CFUNC FreeMasterRTList(LPRESTIME lpRTList);
/*
 * SetResTimeList
 */
void SetResTimeList(void *lpRtList)
{
    lpResTimeList = (LPRESTIME)lpRtList;
    return;
}
/*
    GetMasterRTList

    This routine extracts the Restriction and Timing list for the
    device requested from the registry. nRTListLen is the length
    in RESTIME structures of the array pointed to by lpRTList.
*/
LPRESTIME CFUNC GetMasterRTList
(
    LPDISPDATA lpDispData
)
{
    LPRESTIME   lpRTList;

    if (lpResTimeList)
        lpRTList = lpResTimeList;
    else
    {
        // Here is returning a blank list.
        lpRTList = &rtList;
        lpRTList[0].dwXRes = 0;
    }
    return  (lpRTList);
}
/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC FreeMasterRTList
(
    LPRESTIME lpRTList
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\osapi.c ===
/*
    FILE:   osapi.c
    DATE:   4/8/99

    This file holds code for functions that are called back to by
    the generic modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "..\code\edid.h"
#include "..\code\gtfmath.h"
#include "..\code\dmt.h"

MODEENTRY   SafeModeList[] =
{
    { 640,  480, 8,  60 },
    { 800,  600, 8,  60 },
    { 1024, 768, 8,  60 },
    { 640,  480, 16, 60 },
    { 800,  600, 16, 60 },
    { 1024, 768, 16, 60 },
    { 640,  480, 32, 60 },
    { 800,  600, 32, 60 },
    { 1024, 768, 32, 60 },
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   sLowModes[] =
{
    { 320,  200, 8,  60 },
    { 320,  200, 8,  70 },
    { 320,  200, 8,  72 },
    { 320,  200, 8,  75 },
    { 320,  200, 8,  85 },
    { 320,  200, 8,  100 },
    { 320,  200, 8,  120 },
    { 320,  240, 8,  60 },
    { 320,  240, 8,  70 },
    { 320,  240, 8,  72 },
    { 320,  240, 8,  75 },
    { 320,  240, 8,  85 },
    { 320,  240, 8,  100 },
    { 320,  240, 8,  120 },
    { 400,  300, 8,  60 },
    { 400,  300, 8,  70 },
    { 400,  300, 8,  72 },
    { 400,  300, 8,  75 },
    { 400,  300, 8,  85 },
    { 400,  300, 8,  100 },
    { 400,  300, 8,  120 },
    { 480,  360, 8,  60 },
    { 480,  360, 8,  70 },
    { 480,  360, 8,  72 },
    { 480,  360, 8,  75 },
    { 480,  360, 8,  85 },
    { 480,  360, 8,  100 },
    { 480,  360, 8,  120 },
    { 512,  384, 8,  60 },
    { 512,  384, 8,  70 },
    { 512,  384, 8,  72 },
    { 512,  384, 8,  75 },
    { 512,  384, 8,  85 },
    { 512,  384, 8,  100 },
    { 640,  400, 8,  60 },
    { 640,  400, 8,  70 },
    { 640,  400, 8,  72 },
    { 640,  400, 8,  75 },
    { 640,  400, 8,  85 },
    { 640,  400, 8,  100 },
    { 640,  400, 8,  120 },
    { 320,  200, 16, 60 },
    { 320,  200, 16, 70 },
    { 320,  200, 16, 72 },
    { 320,  200, 16, 75 },
    { 320,  200, 16, 85 },
    { 320,  200, 16, 100 },
    { 320,  200, 16, 120 },
    { 320,  240, 16, 60 },
    { 320,  240, 16, 70 },
    { 320,  240, 16, 72 },
    { 320,  240, 16, 75 },
    { 320,  240, 16, 85 },
    { 320,  240, 16, 100 },
    { 320,  240, 16, 120 },
    { 400,  300, 16, 60 },
    { 400,  300, 16, 70 },
    { 400,  300, 16, 72 },
    { 400,  300, 16, 75 },
    { 400,  300, 16, 85 },
    { 400,  300, 16, 100 },
    { 400,  300, 16, 120 },
    { 480,  360, 16, 60 },
    { 480,  360, 16, 70 },
    { 480,  360, 16, 72 },
    { 480,  360, 16, 75 },
    { 480,  360, 16, 85 },
    { 480,  360, 16, 100 },
    { 480,  360, 16, 120 },
    { 512,  384, 16, 60 },
    { 512,  384, 16, 70 },
    { 512,  384, 16, 72 },
    { 512,  384, 16, 75 },
    { 512,  384, 16, 85 },
    { 512,  384, 16, 100 },
    { 640,  400, 16, 60 },
    { 640,  400, 16, 70 },
    { 640,  400, 16, 72 },
    { 640,  400, 16, 75 },
    { 640,  400, 16, 85 },
    { 640,  400, 16, 100 },
    { 640,  400, 16, 120 },
    { 320,  200, 32, 60 },
    { 320,  200, 32, 70 },
    { 320,  200, 32, 72 },
    { 320,  200, 32, 75 },
    { 320,  200, 32, 85 },
    { 320,  200, 32, 100 },
    { 320,  200, 32, 120 },
    { 320,  240, 32, 60 },
    { 320,  240, 32, 70 },
    { 320,  240, 32, 72 },
    { 320,  240, 32, 75 },
    { 320,  240, 32, 85 },
    { 320,  240, 32, 100 },
    { 320,  240, 32, 120 },
    { 400,  300, 32, 60 },
    { 400,  300, 32, 70 },
    { 400,  300, 32, 72 },
    { 400,  300, 32, 75 },
    { 400,  300, 32, 85 },
    { 400,  300, 32, 100 },
    { 400,  300, 32, 120 },
    { 480,  360, 32, 60 },
    { 480,  360, 32, 70 },
    { 480,  360, 32, 72 },
    { 480,  360, 32, 75 },
    { 480,  360, 32, 85 },
    { 480,  360, 32, 100 },
    { 480,  360, 32, 120 },
    { 512,  384, 32, 60 },
    { 512,  384, 32, 70 },
    { 512,  384, 32, 72 },
    { 512,  384, 32, 75 },
    { 512,  384, 32, 85 },
    { 512,  384, 32, 100 },
    { 640,  400, 32, 60 },
    { 640,  400, 32, 70 },
    { 640,  400, 32, 72 },
    { 640,  400, 32, 75 },
    { 640,  400, 32, 85 },
    { 640,  400, 32, 100 },
    { 640,  400, 32, 120 },
    { 720,  480, 16, 60 },
    { 720,  480, 16, 75 },
    { 720,  480, 16, 85 },
    { 720,  480, 32, 60 },
    { 720,  480, 32, 75 },
    { 720,  480, 32, 85 },
    { 720,  576, 16, 60 },
    { 720,  576, 16, 75 },
    { 720,  576, 16, 85 },
    { 720,  576, 32, 60 },
    { 720,  576, 32, 75 },
    { 720,  576, 32, 85 },
    { 960,  720, 8,  60 },
    { 960,  720, 8,  70 },
    { 960,  720, 8,  72 },
    { 960,  720, 8,  75 },
    { 960,  720, 8,  85 },
    { 960,  720, 8,  100 },
    { 960,  720, 8,  120 },
    { 960,  720, 8,  140 },
    { 960,  720, 8,  144 },
    { 960,  720, 8,  150 },
    { 960,  720, 8,  170 },
    { 960,  720, 8,  200 },
    { 960,  720, 8,  240 },
    { 960,  720, 16, 60 },
    { 960,  720, 16, 70 },
    { 960,  720, 16, 72 },
    { 960,  720, 16, 75 },
    { 960,  720, 16, 85 },
    { 960,  720, 16, 100 },
    { 960,  720, 16, 120 },
    { 960,  720, 16, 140 },
    { 960,  720, 16, 144 },
    { 960,  720, 16, 150 },
    { 960,  720, 16, 170 },
    { 960,  720, 16, 200 },
    { 960,  720, 16, 240 },
    { 960,  720, 32, 60 },
    { 960,  720, 32, 70 },
    { 960,  720, 32, 72 },
    { 960,  720, 32, 75 },
    { 960,  720, 32, 85 },
    { 960,  720, 32, 100 },
    { 960,  720, 32, 120 },
    { 960,  720, 32, 140 },
    { 960,  720, 32, 144 },
    { 960,  720, 32, 150 },
    { 960,  720, 32, 170 },
    { 960,  720, 32, 200 },
    { 960,  720, 32, 240 },
    { 0,    0,   0,  0  },
};

#define USE_60HZ                        0x00
#define USE_REFRESH_RATES_FROM_LOWER    0x01
#define USE_REFRESH_RATES_FROM_STRING   0x02

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

extern int CFUNC GetSafeModeList (LPMODEENTRY lpModeList);


/*
    GetModeListFromRegistry

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetModeListFromRegistry (LPDISPDATA lpDispData)
{
    ULONG       i, j, pd, dwIndex, dwXRes, dwYRes;
    ULONG       hModeBppKey, hModeResKey, dwSize, dwMatchIndex;
    ULONG       dwSubKey, dwValue;
    ULONG       dwMajorKey;
    ULONG       dwValueNameSize;
    LPCHAR      lpC;
    int         nMode, nFlagRR;
    char        szValueName[MAX_KEY_LEN];
    char        szRegPath[MAX_KEY_LEN];
    char        szPDPath[MAX_KEY_LEN];
    char        szRes[MAX_KEY_LEN];
    char        szResPath[MAX_KEY_LEN];
    char        szRefreshRate[MAX_KEY_LEN];
    long        lRet;
    LPMODEENTRY lpML;

    DBG_PRINT0(DL_0, "\r\nEntering GetModeListFromRegistry.");

    // Next, grab the mode list from the registry
    if  (!(lpML = (LPMODEENTRY) MemoryAlloc ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY))))
    {
        DBG_PRINT0(DL_0, "\r\nAllocation of Registry Mode List Failed.");
        DBG_PRINT0(DL_0, "\r\nSetting up a default safe mode list.");
        lpML = SafeModeList;
        return  (lpML);
    }

    // Zero out the memory
    lpC = (LPCHAR) lpML;
    for (i = 0; i < ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY)); i++)
        lpC[i] = 0;

    // Use the safe mode list settings initially
    GetSafeModeList(lpML);

    // Try to get the path in the registry to where the mode list is.
    if  (GetLocalPath (lpDispData->lpBoardRegistryData, szRegPath) < 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nGetLocalRegistryPath failed. Returning safe mode list.");
        return  (lpML);
    }

    // Tack on "\\MODES" to the returned regpath
    dwMajorKey = lpDispData->lpBoardRegistryData->dwMainKey;
    lstrcat (szRegPath, "\\Modes");

    // Start off with the first mode
    nMode = 0;

    // Create a loop so we can extract the modes for each pixel depth
    for (pd = 0; pd < 4; pd++)
    {
        // Copy the path to ...DISPLAY\000X\MODES and then tack on
        // the correct pixel depth key
        lstrcpy (szPDPath, szRegPath);

        switch  (pd)
        {
            case 0:
                lstrcat (szPDPath, "\\8");
                break;
            case 1:
                lstrcat (szPDPath, "\\16");
                break;
            case 2:
                lstrcat (szPDPath, "\\24");
                break;
            case 3:
                lstrcat (szPDPath, "\\32");
                break;
        }

        // We now have the key where the pixel depth specific modes are.
        // Go ahead and open the key.
        lRet = RegOpenKey (dwMajorKey, szPDPath, &hModeBppKey);

        if  (lRet != ERROR_SUCCESS)
        {
            // If we have trouble opening a Bpp key, that is OK, since
            // we might not support a particular pixel depth. Just go
            // on to the next one.
            continue;
        }

        // Enumerate the subkeys -- each key is a spatial resolution.
        // Within each key there is a "(default)" string which has a
        // list of refresh rates which looks like: "60,72,75,85"
        // If the key does not have a list of refresh rates, then
        // look at the same resolution in the next lower pixel depth
        // and use that its refresh rates. Finally, if there is no
        // lower color depth, then assume just a 60Hz refresh rate.
        for (dwSubKey = 0; TRUE; dwSubKey++)
        {
            lRet = RegEnumKey (hModeBppKey, dwSubKey, szRes, MAX_KEY_LEN);

            if  (lRet != ERROR_SUCCESS)
            {
                // If there was an error, it probably means that there are
                // no more subkeys -- i.e. resolutions for this pixel
                // depth. That's fine. Break out of the loop.
                break;
            }

            // Get the xres and yres from the key string.
            dwIndex = 0;
            ParseDecimalSeparator (szRes, &dwIndex, &dwXRes, ',', ',');
            ParseDecimalSeparator (szRes, &dwIndex, &dwYRes, 0, 0);

            // Build a full path to the resolution key so we can open it
            lstrcpy (szResPath, szPDPath);
            lstrcat (szResPath, "\\");
            lstrcat (szResPath, szRes);

            // OK, now open the spatial resolution key so that we can
            // get the list of refresh rates for this resolution.
            lRet = RegOpenKey (dwMajorKey, szResPath, &hModeResKey);

            if  (lRet == ERROR_SUCCESS)
            {
                // The refresh rate string which looks like "60,72,75"
                // or some such thing, does not have a tag name associated
                // with it, so I cannot just query a value -- there is no
                // name to query the value of!  Must enumerate the values.
                for (dwValue = 0; TRUE; dwValue++)
                {
                    dwValueNameSize = MAX_KEY_LEN;
                    dwSize = MAX_KEY_LEN;
                    lRet = RegEnumValue (hModeResKey, dwValue, szValueName,
                                        &dwValueNameSize, NULL, NULL,
                                        szRefreshRate, &dwSize);


                    if  (lRet == ERROR_SUCCESS)
                    {
                        // We got back a key. Technically we should
                        // check to see if this is a valid refresh rate
                        // string, but we won't. We do a quick check
                        // here to see if the value name is NULL --
                        // that is the way MSoft stores it for some
                        // reason. The actual refresh rate string
                        // values will get pseudo-validated later in
                        // this routine.
                        if  ((dwValueNameSize == 0) &&
                             (szRefreshRate[0] != 0))
                        {
                            // Close the resolution key
                            RegCloseKey (hModeResKey);

                            nFlagRR = USE_REFRESH_RATES_FROM_STRING;
                            break;
                        }
                    }
                    else
                    {
                        // If we got an error, it is porbbaly because
                        // there are no more values to enumerate in the
                        // key. Unfortunately we didn't find a refresh
                        // rate string, so just close the key. The logic
                        // in the next section handles the error.
                        RegCloseKey (hModeResKey);
                        break;
                    }
                }
            }

            if  (lRet != ERROR_SUCCESS)
            {
                // Here's the thing. If either opening the resolution key
                // to query the refresh rate string, OR if the query of
                // the refresh rate string failed, we still have to come
                // up with a list of refresh rates somehow,
                // so check if we are looking for 8bpp modes.
                if  (pd == 0)
                {
                    // In 8bpp, there is no lower pixel depth so we
                    // have to assume a single value of 60Hz
                    nFlagRR = USE_60HZ;
                }
                else
                {
                    // We can make a good guess as to the refresh
                    // rates by using the ones for the same
                    // resolution mode in a lower pixel depth,
                    // if a lower pixel depth has the same
                    // resolution mode. IF not, use 60Hz.
                    nFlagRR = USE_REFRESH_RATES_FROM_LOWER;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_STRING)
            {
                dwIndex = 0;

                // Generate a new mode for each refresh rate in the string
                while   (ParseDecimalSeparator (szRefreshRate,
                            &dwIndex, &(lpML[nMode].dwRefreshRate),
                            ',', 0))
                {
                    lpML[nMode].dwXRes = dwXRes;
                    lpML[nMode].dwYRes = dwYRes;
                    lpML[nMode].dwBpp  = (pd + 1) * 8;
                    if  (nMode < MAX_MODEENTRYS)
                        nMode++;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_LOWER)
            {
                dwMatchIndex = FALSE;

                // Start with the pixel depth immediately below, but
                // if no matching res is found at that one, keep going.
                for (j = pd - 1; (((long) j) >= 0) && (!dwMatchIndex); j--)
                {
                    // Search through all modes already added to the table
                    for (i = 0; i < (ULONG) nMode; i++)
                    {
                        // Matching xres, yres, and prior pixel depth
                        // is a hit!
                        if  ((dwXRes == lpML[i].dwXRes) &&
                             (dwYRes == lpML[i].dwYRes) &&
                             (((j + 1) * 8) == lpML[i].dwBpp))
                        {
                            // Grab the prior mode, and modify the bpp
                            lpML[nMode] = lpML[i];
                            lpML[nMode].dwBpp = (pd + 1) * 8;
                            if  (nMode < MAX_MODEENTRYS)
                                nMode++;
                            dwMatchIndex = TRUE;
                        }
                    }
                }

                if  (!dwMatchIndex)
                {
                    // If there wasn't a lower pixel depth with a
                    // matching resolution, then do a single 60Hz mode.
                    nFlagRR = USE_60HZ;
                }
            }

            if  (nFlagRR == USE_60HZ)
            {
                lpML[nMode].dwXRes = dwXRes;
                lpML[nMode].dwYRes = dwYRes;
                lpML[nMode].dwBpp  = (pd + 1) * 8;
                lpML[nMode].dwRefreshRate = 60;
                if  (nMode < MAX_MODEENTRYS)
                    nMode++;
            }
        }

        // Close this bpp key
        RegCloseKey (hModeBppKey);
    }

    // Only one thing. If we didn't find any modes, then use a safe list
    if  (nMode == 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nNo modes found. Returning safe mode list.");
        return  (lpML);
    }

    return  (lpML);
}


/*
    GetMasterModeList

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpDispData)
{
    int         i, nLen;
    LPMODEENTRY lpML;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterModeList.");

    if(lpDispData->lpModeList != NULL)
        return  lpDispData->lpModeList;

    lpDispData->lpModeList = lpML = GetModeListFromRegistry (lpDispData);

    // Count the number of items in the list
    for (nLen = 0; nLen < MAX_MODEENTRYS; nLen++)
        if  (lpML[nLen].dwXRes == 0)
            break;

    // Add all the non-desktop, low resolution modes.
    for (i = 0; sLowModes[i].dwXRes != 0; i++)
    {
        lpML[nLen] = sLowModes[i];
        if  (nLen < MAX_MODEENTRYS)
            nLen++;
    }

    DBG_PRINT0(DL_0, "\r\nExiting GetMasterModeList.");
    return  (lpML);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeListW9X (LPMODEENTRY lpModeList)
{
    if  (lpModeList != SafeModeList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on lpModeList.");
        MemoryFree ((LPULONG) lpModeList);
    }

    return  (TRUE);
}


/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    int     i;

    for (i = 0; SafeModeList[i].dwXRes != 1; i++)
        lpModeList[i] = SafeModeList[i];

    return  (TRUE);
}


/*
    GetMasterRTList

    This routine extracts the Restriction and Timing list for the
    device requested from the registry. nRTListLen is the length
    in RESTIME structures of the array pointed to by lpRTList.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpDispData)
{
    int         i;
    long        lRet;
    ULONG       dwSubKey;
    ULONG       dwSize, dwValueNameSize;
    ULONG       hRTKey;
    char        szItem[MAX_KEY_LEN];
    char        szRTString[MAX_KEY_LEN];
    LPRESTIME   lpRTList;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterRTList.");

    if(lpDispData->lpRTList != NULL)
        return  lpDispData->lpRTList;

    if  (!(lpRTList = (LPRESTIME) MemoryAlloc (MAX_RESTIMES * sizeof(RESTIME))))
    {
        DBG_PRINT0 (DL_0, "\r\nAllocation of Restriction And Timing List Failed.");
        DBG_PRINT0 (DL_0, "\r\nSetting up a default list with no restrictions.");
        lpRTList = &sRTList;

        // Use the dwXRes field in the first array element as a count
        // of the number of restriction list entries.
        lpRTList[0].dwXRes = 0;
        return  (lpRTList);
    }
    else
        lpDispData->lpRTList = lpRTList;

    // Use the dwXRes field in the first array element as a count
    // of the number of restriction list entries.
    lpRTList[0].dwXRes = 0;

    // First, find the path to the restriction and timing strings.
    if  (!(hRTKey = GetLocalNvidiaDisplaySubKey (lpDispData->lpBoardRegistryData)))
    {
        DBG_PRINT0(DL_0, "\r\nGetLocalDisplaySubKey failed. Returning empty RTList.");
        return  (lpRTList);
    }

    // Start enumerating and parsing the R&T strings.
    for (dwSubKey = 0; TRUE; dwSubKey++)
    {
        // Zero out the strings
        for (i = 0; i < MAX_KEY_LEN; i++)
        {
            szItem[i] = 0;
            szRTString[i] = 0;
        }

        dwValueNameSize = MAX_KEY_LEN;
        dwSize = MAX_KEY_LEN;
        lRet = RegEnumValue (hRTKey, dwSubKey, szItem,
                            &dwValueNameSize, NULL, NULL,
                            szRTString, &dwSize);

        // If there was an error, it probably means that there are
        // no more values to enumerate. That's fine. We are done.
        if  (lRet != ERROR_SUCCESS)
            break;

        // Is this subkey an R&T string? It is if it begins "R&T"
        if  ((szItem[0] == 'R') && (szItem[1] == '&') && (szItem[2] == 'T'))
        {
            // If the R&T string parses legitimately, include it in the list.
            if  (lpRTList[0].dwXRes < (MAX_RESTIMES - 1))
            {
                if  (ParseRTString (lpRTList + lpRTList[0].dwXRes + 1, szRTString))
                {
                    DBG_PRINT1(DL_0, "\r\nR&T string %s parsed fine.", (ULONG) szRTString);
                    lpRTList[0].dwXRes++;
                }
            }
        }
    }

    // Close the key
    RegCloseKey (hRTKey);

    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTListW9X (LPRESTIME lpRTList)
{
    // The dwYRes field in the first array element is used as a flag
    // to indicate that the array was GlobalAlloced.
    if  (lpRTList != &sRTList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on RTList.");
        MemoryFree ((LPULONG) lpRTList);
    }

    return  (TRUE);
}

/*
    FreeMasterLists

    This routine is called from Display driver when the CRTC context is destroying.
*/
int WINAPI
FreeMasterLists ( LPDISPDATA lpDispData )
{
    if(lpDispData->lpRTList)
    {
        FreeMasterRTListW9X (lpDispData->lpRTList);
        lpDispData->lpRTList = NULL;
    }

    if(lpDispData->lpModeList)
    {
        FreeMasterModeListW9X (lpDispData->lpModeList);
        lpDispData->lpModeList = NULL;
    }
    return  (TRUE);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the ModeList.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}

/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board,
    logical device, and output device specified.
    It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC
GetTimingStandardOverride (LPDISPDATA lpDispData)
{
    char    szVal[32];

    if (GetLocalNvidiaDisplayDevRegString (lpDispData->lpBoardRegistryData,
        (LPDEVDATA) lpDispData->lpDevData, NV4_REG_DRV_MONITOR_TIMING, szVal))
    {
        if  (!lstrcmpi(szVal, NV4_REG_DRV_MONITOR_TIMING_DMT))
            return  (DMTV_ID);

        if  (!lstrcmpi(szVal, NV4_REG_DRV_MONITOR_TIMING_GTF))
            return  (GTFV_ID);
    }

    return  (NONE_ID);
}


/*
    Function:   GetPitchAndSize

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/
typedef ULONG   (__far __pascal *LPFNGETMODESIZE) (PVOID, PVOID, ULONG, ULONG, ULONG, ULONG *, ULONG *);

ULONG CFUNC
GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwYRes, ULONG dwBpp, ULONG *pdwPitch, ULONG *pdwSize)
{
    LPFNGETMODESIZE lpfnGetModeSize;

    lpfnGetModeSize = (LPFNGETMODESIZE) lpDispData->lpfnGetModeSize;
    return  ((*lpfnGetModeSize) (lpDispData->dwContext1, lpDispData->dwContext2, dwXRes, dwYRes, dwBpp, pdwPitch, pdwSize));
}


/*
    Function:   GetMonitorInfRangeLimits

    Purpose:    This routine reads the "MaxResolution" key in the
                active monitor node in the registry to get the
                maximum resolution the monitor can do. It uses
                the maximum resolution itself (like "1600,1200")
                as another subkey under which is typically a
                monitor range limits string which looks like
                "30-95,60-120,-,+" where the first range is
                the horizontal limits inKHz and the second is
                the vertical range in hertz. The last two characters
                are horizontal and vertical sync polarities.
                This range limits string doesn't always exist.

    Arguments:
                lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpML        - ptr to a monitor limits structure
                              that will be filled in with range
                              limits obtained or computed from
                              values stuffed in the registry
                              by the moitor .inf file.
                lpdwXRes    - ptr to a variable that will be set
                              to the maximum X-resolution found
                              for this monitor.
                lpdwYRes    - ptr to a variable that will be set
                              to the maximum Y-resolution found
                              for this monitor.

    Returns:    TRUE    then lpML, lpdwXRes, and lpdwYRes have been
                        filled in correctly.
                FALSE   then there was an error getting some value.
*/
int CFUNC
GetMonitorInfRangeLimits (
    LPDISPDATA      lpDispData,
    LPMONITORLIMITS lpML,
    ULONG           *lpdwXRes,
    ULONG           *lpdwYRes)
{
    ULONG   i;
    char    szMaxResolution[10];
    ULONG   hMonitor, lRet;
    ULONG   dwSize;
    ULONG   dwHorizMin;
    ULONG   dwHorizMax;
    ULONG   dwVertMin;
    ULONG   dwVertMax;
    char    szBuffer[MAX_KEY_LEN];
    GTFIN   GTFIn;
    GTFOUT  GTFOut;

    // First zero out monitor limits structure.
    lpML->dwMinHorz = 0;
    lpML->dwMaxHorz = 0;
    lpML->dwMinVert = 0;
    lpML->dwMaxVert = 0;
    lpML->dwMaxPixelClock = 0;

    szMaxResolution[0] = 0;
    if  (!GetMonitorLocalRegString (lpDispData->lpMonitorRegistryData,
                                "MaxResolution", szMaxResolution))
        return  (FALSE);

    // If no string was returned from RegQueryEx, just return 60Hz.
    if (!szMaxResolution[0])
        return (FALSE);

    // Now convert the strings to numbers.
    i = 0;
    *lpdwXRes = 0;
    *lpdwYRes = 0;
    ParseDecimalSeparator (szMaxResolution, &i, lpdwXRes, ',', ',');
    ParseDecimalSeparator (szMaxResolution, &i, lpdwYRes, 0, 0);

    // Create path for MODES subkey.
    lstrcpy (szBuffer, lpDispData->lpMonitorRegistryData->szRegPath);
    lstrcat (szBuffer, "\\MODES");
    lstrcat (szBuffer, "\\");
    lstrcat (szBuffer, szMaxResolution);
    lRet = RegOpenKey (lpDispData->lpMonitorRegistryData->dwMainKey, szBuffer, &hMonitor);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    szBuffer[0] = 0;
    dwSize = MAX_KEY_LEN;
    RegQueryValueEx (hMonitor, "Mode1", NULL, NULL,
                         szBuffer, (ULONG FAR *) &dwSize);

    RegCloseKey (hMonitor);

    // If no string was returned from RegQueryEx, just return 60Hz.
    if (!szBuffer[0])
        return (FALSE);

    // Now convert the strings to numbers. Be careful here because some
    // INF range limits are in the form xx.x-yy.y (a range) while others
    // are of the form xx.x (fixed frequency). For fixed frequency, set
    // max horizontal and max vertical to the same value as the minimums.
    i = 0;
    ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwHorizMin, '-', ',');
    if (i > 0)
    {
        if (szBuffer[i - 1] == ',')
            dwHorizMax = dwHorizMin;
        else
            ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwHorizMax, ',', ',');
    }
    ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwVertMin, '-', ',');
    if (i > 0)
    {
        if (szBuffer[i - 1] == ',')
            dwVertMax = dwVertMin;
        else
            ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwVertMax, ',', ',');
    }

    // Change horizontals from KHz to Hz.
    dwHorizMin = Multiply32By32(dwHorizMin, 1000);
    dwHorizMax = Multiply32By32(dwHorizMax, 1000);

    lpML->dwMinHorz = dwHorizMin;
    lpML->dwMaxHorz = dwHorizMax;
    lpML->dwMinVert = dwVertMin;
    lpML->dwMaxVert = dwVertMax;

    // Find a pixel clock limit.
    GTFIn.dwHPixels      = *lpdwXRes;
    GTFIn.dwVLines       = *lpdwYRes;
    GTFIn.dwMarginsRqd   = FALSE;
    GTFIn.dwIntRqd       = FALSE;
    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
    GTFIn.dwIPFreqRqd    = lpML->dwMaxVert;

    // Get the timing parameters.
    ComputeGTFParameters(&GTFIn, &GTFOut);
    lpML->dwMaxPixelClock = Multiply32By32(GTFOut.dwPixelClockIn10KHertz, 10000);

    // Make sure there's at least some kind of pixel clock. The fallback
    // pixel clock being used is the pixel clock for DMT 640x480@60Hz.
    if (lpML->dwMaxPixelClock == 0)
        lpML->dwMaxPixelClock = 25180000;

    return  (TRUE);
}


/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC
GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    return  (GrabModeInfoString (lpDispData->lpBoardRegistryData,
                0x0FFFFFFFF, NULL,
                NV4_REG_DRV_MONITOR_LIMIT_MODE, lpModeInfo, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\getit.c ===
/*
    FILE:   getit.c
    DATE:   4/8/99

    This file holds code to get the mode, and output device from
    the registry for the given board.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "..\code\edid.h"
#include "..\code\gtfmath.h"
#include "..\code\dmt.h"

DEVICEANDTYPE   DeviceTypes[] =
{
    { "CRT", DEVTYPE_CRT },
    { "TV",  DEVTYPE_TV },
    { "DFP", DEVTYPE_DFP },
    { NULL,  0 }
};

typedef struct  tagTVFORMATANDTYPE
{
    LPCHAR  lpszName;
    char    cFormat;
}   TVFORMATANDTYPE;

TVFORMATANDTYPE TVFormat[] =
{
    { "NTSCM", TVTYPE_NTSCM },
    { "NTSCJ", TVTYPE_NTSCJ },
    { "PALM",  TVTYPE_PALM },
    { "PALA",  TVTYPE_PALA },
    { "PALN",  TVTYPE_PALN },
    { "PALNC", TVTYPE_PALNC },
    { NULL,    0 }
};

char sz640_480[] = "640,480";
char szSettings[] = "Display\\Settings";
char szControl[] = "System\\CurrentControlSet\\Control";
char szDefUser[] = "Config\\0001\\Display\\Settings";
char szDeviceType[MAX_KEY_LEN];
char szLastDevice[MAX_KEY_LEN];
char szPath[MAX_KEY_LEN];
char szFullPath[MAX_KEY_LEN];
char szExtraKey[MAX_KEY_LEN];

extern int CFUNC GrabRefreshRateFromKey (ULONG hKey, LPDISPDATA lpDispData,
                                        LPCHAR lpszPath, LPMODEINFO lpModeInfo,
                                        LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                                        char *RefreshRateName);
extern LPMODEENTRY CFUNC GetModeListFromRegistry (LPDISPDATA lpDispData);
extern int WINAPI ParseDeviceTypeAndNumber (LPCHAR lpszString, LPDEVDATA lpDevData);

/*
    GetBootDevice

    Purpose:    This routine gets the Initial Boot display device for
                the board given. lpDevtype should be filled in with one
                of the basic types like DEVTYPE_CRT, DEVTYPE_NTSC, etc
                defined in modeext.h or filled with 0xffffffff if subkey
                is not found or invlalid Device type is found.
                If the basic type is either NTSC or PAL, then the
                lpTvFormat should be filled in with the specific NTSC
                or PAL formats like: TVTYPE_NTSC_M, TYTYPE_NTSC_J etc
                which are given in modeext.h

    Arguments:  lpRegData   - identifies the specific board
                lpDevData   - where to place the device found

    Returns:    TRUE    if lpDevType is filled in correctly.
                FALSE   otherwise
*/
int WINAPI
GetBootDevice (LPREGDATA lpRegData, LPDEVDATA lpDevData)
{
    char    szDev[MAX_KEY_LEN];

    DBG_PRINT0 (DL_0, "\r\nEntering GetBootDevice");

    szDeviceType[0] = 0;
    GetLocalNvidiaDisplayRegString (lpRegData,
                            NV4_REG_DRV_BOOT_DEVICE_TYPE, szDev);

    // Parse the device type
    if  (!ParseDeviceTypeAndNumber (szDev, lpDevData))
        return  (FALSE);

    lpDevData->cFormat = 0;

    // If this was a TV, then get the last format
    if  (lpDevData->cType == DEVTYPE_TV)
    {
        // JKTODO -- for now
        lpDevData->cFormat = TVTYPE_NTSCM;
    }

    DBG_PRINT0 (DL_1, "\r\nExiting GetBootDevice");
    return  (TRUE);
}


/*
    GetBootDeviceSelection
    Purpose:    This routine gets the Initial Boot device selection
                for desktop to use HW selected device. (Mobile Behaviour)


    Arguments:  lpRegData   - identifies the specific board

    Returns:    TRUE    If HW selected device will be used as boot device
                FALSE   otherwise
*/
int WINAPI
GetBootDeviceSelection (LPREGDATA lpRegData)
{
    int nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetBootDeviceSelection");

    nRet = GetLocalNvidiaDisplayRegValue (lpRegData,
                NV4_REG_DRV_USE_HW_SELECTED_DEVICE, 0);

    DBG_PRINT0 (DL_1, "\r\nExiting GetBootDeviceSelection");
    return  (nRet);
}

/*
    Function:   GetLastDisplayFormat

    Purpose:    This routine gets called to get the last display
                format used on a particular display device. This
                really only applies in the case of a TV. It will
                set the format field of lpDevData to 0 if the device
                type is not DEVTYPE_TV.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpDevData   - ptr to the DEVDATA structure to be filled in

    Returns:    lpDevData filled in correctly
*/
int WINAPI
GetLastDisplayFormat (LPREGDATA lpRegData, LPDEVDATA lpDevData)
{
    int     i;
    char    szTvFormat[16];

    DBG_PRINT0 (DL_0, "\r\nEntering GetLastDisplayFormat.");

    // Assume the format is 0
    lpDevData->cFormat = 0;

    // If this was a TV, then get the last format
    if  (lpDevData->cType == DEVTYPE_TV)
    {
        szTvFormat[0] = 0;
        GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                NV4_REG_DRV_LAST_TV_FORMAT, szTvFormat);
        if(szTvFormat[0] == 0)
                                return(FALSE);

        // Parse the device type and reduce it a bit
        for (i = 0; TVFormat[i].lpszName != NULL; i++)
            if  (!lstrcmpi (TVFormat[i].lpszName, szTvFormat))
                break;

        lpDevData->cFormat = TVFormat[i].cFormat;
    }

    DBG_PRINT0 (DL_1, "\r\nExiting GetDisplayDevice.");
    return  (TRUE);
}


/*
    Function:   GetDisplayDevice

    Purpose:    This routine gets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                dwLogDevice - 0 based logical device number
                dwPhysDevice- 0 based physical device number
                lpDevData   - ptr to the DEVDATA structure to be filled in

    Returns:    lpDevData filled in correctly
*/
int WINAPI
GetDisplayDevice (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG dwPhysDevice,
                    LPDEVDATA lpDevData)
{
    char    szDev[32];
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering GetDisplayDevice.");

    wsprintf (szTemp, "%s%c", NV4_REG_DRV_PHYSICAL_DEVICE,
                                (char) (dwPhysDevice + '0'));
    GetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice, szTemp, szDev);

    if  (!ParseDeviceTypeAndNumber (szDev, lpDevData))
        return  (FALSE);

    GetLastDisplayFormat (lpRegData, lpDevData);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDisplayDevice.");
    return  (TRUE);
}


/*
    Function:   SetDisplayDevice

    Purpose:    This routine sets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpRegData   - identifies the specific board
                dwLogDevice - 0 based logical device number
                dwPhysDevice - 0 based physical device number
                lpDevData   - the basic display type
                              should be one of the DEVTYPE_XXXX
                              sonstants definde in modeext.h

    Returns:    Always returns TRUE
*/
int WINAPI
SetDisplayDevice (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG dwPhysDevice,
                    LPDEVDATA lpDevData)
{
    char    szTemp[MAX_KEY_LEN];
    char    szDev[16];

    DBG_PRINT0 (DL_0, "\r\nEntering SetDisplayDevice.");

    if  (lpDevData->cType > MAX_DEVTYPES)
        lpDevData->cType = 0;

    if  (lpDevData->cNumber > 9)
        lpDevData->cNumber = 0;

    wsprintf (szDev, "%s%c", DeviceTypes[lpDevData->cType].lpszName,
                            lpDevData->cNumber + '0');

    wsprintf (szTemp, "%s%d", NV4_REG_DRV_PHYSICAL_DEVICE, dwPhysDevice);
    SetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice, szTemp,
                                        szDev, lstrlen(szDev));

    // If this was a TV device, then write out the format
    if  (lpDevData->cType == DEVTYPE_TV)
    {
        SetLocalNvidiaDisplayDevRegString (lpRegData,
                                lpDevData, NV4_REG_DRV_LAST_TV_FORMAT,
                                TVFormat[lpDevData->cFormat].lpszName,
                                lstrlen(TVFormat[lpDevData->cFormat].lpszName));
    }

    DBG_PRINT0 (DL_1, "\r\nExiting SetDisplayDevice.");
    return  (TRUE);
}


/*
    Function:   GetForcedDesktopMode

    Purpose:    This routine gets a forced desktop mode if one exists
                in the registry. Then it deletes the key.

    Arguments:  lpRegData    - identifies the specific board
                lpSuggMode   - This has a suggested mode on the way in
                               If a forced mode is found it is saved
                               here on the way out.

    Returns:    lpSuggMode is updated to the forced mode if one is
                found and the routine returns TRUE. Otherwise,
                lpSuggMode is left alone and the routine returns FALSE.

                Note that at the time of this call, the only fields
                in lpSuggMode that are valid are: dwXRes, dwYRes, dwBpp.

                The values in the other fields should be ignored by
                this routine. The caller will overwrite the other
                fields after this routine returns, so changing the
                other fields in this routine will make no difference.

                FALSE   no forced desktop mode was found
                TRUE    a forced desktop mode was found.
*/
int WINAPI
GetForcedDesktopMode (LPREGDATA lpRegData, LPMODEINFO lpSuggMode)
{
    MODEINFO    sMI;

    DBG_PRINT0 (DL_0, "\r\nEntering GetForcedMode");

    // If the force mode string exists in the registry, then it specifies
    // the mode that should be set period, regardless of anything else.
    if  (!GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpSuggMode->MIDevData,
                                NV4_REG_DRV_FORCED_DESKTOP_MODE, &sMI, 1))
    {
        DBG_PRINT0 (DL_0, "\r\nExiting GetForcedMode with Failure.");
        return  (FALSE);
    }

    // Now erase the force mode string
    DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, &lpSuggMode->MIDevData,
                                        NV4_REG_DRV_FORCED_DESKTOP_MODE);
    // Return the mode.
    sMI.MIDevData = lpSuggMode->MIDevData;
    *lpSuggMode = sMI;

    DBG_PRINT0 (DL_1, "\r\nExiting GetForcedMode with Success.");
    return  (TRUE);
}


/*
    Function:   GetLargestEdidMode

    Purpose:    This routine gets the largest edid mode found.

    Arguments:
                lpEdidBuffer - points to a buffer with EDID data in
                               it if dwEdidSize is not 0. If dwEdidSize
                               is 0, this argument is ignored.
                dwEdidSize     tells the size of the lpEdidBuffer
                               in bytes. If this variables is 0,
                               then lpEdidBuffer ptr may be invalid.
                lpModeFound    MODEINFO ptr where the largest EDID mode
                               found should be stored.

    Returns:    TRUE    then lpModeFound was updated with the largest
                        EDID mode
                FALSE   lpModeFound was not updated. This could be because
                        there was no EDID or there was an error parsing
                        the EDID. It doesn't matter.
*/
int WINAPI
GetLargestEdidMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                    LPMODEINFO lpModeFound)
{
    if  (!dwEdidSize)
    {
        // Ignore the force mode if it asks us to look through an
        // EDID which is not there.
        DBG_PRINT0 (DL_0, "\r\nExiting GetLargestEdidMode with Failure.");
        return  (FALSE);
    }

    EdidFindLargestEdidMode (lpEdidBuffer, dwEdidSize, lpModeFound);
    return  (TRUE);
}



/*
    Function:   GetDeviceDesktopMode

    Purpose:    This routine gets the desktop mode for the board
                specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return. Note that only the x,y,bpp
                              are relevent here. Refresh rates are
                              CRTC specific

    Returns:    lpModeInfo -> dwXRes, dwYRes, and dwBpp are filled in
*/
int WINAPI
GetDeviceDesktopMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    int     nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetDeviceDesktopMode.");

    nRet = GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpModeInfo->MIDevData,
                            NV4_REG_DRV_LAST_DESKTOP_MODE, lpModeInfo, 1);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDeviceDesktopMode.");
    return  (nRet);
}


/*
    Function:   SetDeviceDesktopMode

    Purpose:    This routine writes the desktop mode given into the
                registry for the particular deivce and board specified.

    Arguments:  lpRegData   - identifies the specific board
                lpModeInfo    MODEINFO ptr specifying desktop mode

    Returns:    Always returns TRUE
*/
int WINAPI
SetDeviceDesktopMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering SetDeviceDesktopMode.");

    // Set it into the registry
    wsprintf (szTemp, "%ld,%ld,%ld", lpModeInfo->dwXRes,
                lpModeInfo->dwYRes, lpModeInfo->dwBpp);
    SetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                NV4_REG_DRV_LAST_DESKTOP_MODE, szTemp, lstrlen(szTemp));

    DBG_PRINT0 (DL_1, "\r\nExiting SetDeviceDesktopMode.");
    return  (TRUE);
}


/*
    Function:   GetForcedDisplayMode

    Purpose:    This routine gets the forced display mode for the board
                and device specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return.

    Returns:    TRUE    lpModeInfo is filled in with a forced mode
                FALSE   there was no forced mode
*/
int WINAPI
GetForcedDisplayMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    int     nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetForcedDisplayMode.");

    nRet = GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpModeInfo->MIDevData,
                            NV4_REG_DRV_FORCED_MODE, lpModeInfo, 0);

    // Now erase the force mode string
    DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, &lpModeInfo->MIDevData,
                                        NV4_REG_DRV_FORCED_MODE);

    DBG_PRINT0 (DL_1, "\r\nExiting GetForcedDisplayMode.");
    return  (nRet);
}


/*
    Function:   GetDeviceDisplayMode

    Purpose:    This routine gets the display mode for the board
                and device specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return.

    Returns:    lpModeInfo is filled in
*/
int WINAPI
GetDeviceDisplayMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    int     nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetDeviceDisplayMode.");

    nRet = GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpModeInfo->MIDevData,
                            NV4_REG_DRV_LAST_MODE, lpModeInfo, 0);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDeviceDisplayMode.");
    return  (nRet);
}


/*
    Function:   SetDeviceDisplayMode

    Purpose:    This routine writes the display mode given into the
                registry for the particular device and board specified.

    Arguments:  lpRegData   - identifies the specific board
                lpModeInfo    MODEINFO ptr specifying desktop mode

    Returns:    Always returns TRUE
*/
int WINAPI
SetDeviceDisplayMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering SetDeviceDisplayMode.");

    // Set it into the registry
    wsprintf (szTemp, "%ld,%ld,%ld,%ld", lpModeInfo->dwXRes,
                lpModeInfo->dwYRes, lpModeInfo->dwBpp,
                lpModeInfo->dwRefreshRate);
    SetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                    NV4_REG_DRV_LAST_MODE, szTemp, lstrlen(szTemp));

    DBG_PRINT0 (DL_1, "\r\nExiting SetDeviceDisplayMode.");
    return  (TRUE);
}


/*
    Function:   GetPanningFlag

    Purpose:    This routine gets the panning flag especially for the clone mode
                 for the board and device specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return.

    Returns:    0 - the clone device has the maximum possible resolution
                1 - resolution limited (custom panning enabled).
*/
int WINAPI
GetClonePanningFlag (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    ULONG nRet = 0;

    DBG_PRINT0 (DL_0, "\r\nEntering GetPanningFlag.");

    GetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                                NV4_REG_DRV_PANNING_FLAG, (char*)&nRet);

    DBG_PRINT0 (DL_1, "\r\nExiting GetPanningFlag.");
    return  (int)(nRet & 1);
}


/*
    Function:   SetPanningFlag

    Purpose:    This routine writes the panning flag especially for the clone mode
                 for the board and device specified.

    Arguments:  lpRegData   - identifies the specific board
                lpModeInfo    MODEINFO ptr specifying desktop mode

    Returns:    Always returns TRUE
*/
int WINAPI
SetClonePanningFlag (LPREGDATA lpRegData, LPMODEINFO lpModeInfo, ULONG dwFlag)
{
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering SetPanningFlag.");

    // Set it into the registry
    wsprintf (szTemp, "%ld", dwFlag);
    SetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                    NV4_REG_DRV_PANNING_FLAG, szTemp, lstrlen(szTemp));

    DBG_PRINT0 (DL_1, "\r\nExiting SetPanningFlag.");
    return  (TRUE);
}

/*
    Function:   GetRefreshRateForDesktop

    Purpose:    This routine gets the correct refresh rate for
                the desktop as Windows has it buried in the registry.
                display device given by lpModeInfo->dwDevData.
                lpModeInfo->dwXRes, lpModeInfo->dwYRes, and
                lpModeInfo->dwBpp are valid, but the field
                lpModeInfo->dwRefreshRate is not.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer- points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    This routine should not override the Xres,Yres, and Bpp
                in lpModeInfo. Only the dwRefreshRate field should be
                adjusted. The rest of the mode is provided just in case
                it is needed to determine the correct refresh rate.

                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).

                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.

                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.

                It Always returns TRUE.
*/
int WINAPI
GetRefreshRateForDesktop (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo,
                            LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG       dwSize, hControl;
    long        lRet;
#ifdef  STEREO_SUPPORT
    char        StereoKey[256];
    ULONG       StereoEnabled;
    ULONG       dwType = REG_DWORD;
#endif  //STEREO_SUPPORT

    DBG_PRINT0 (DL_0, "\r\nEntering GetRefreshRateForDesktop.");

#ifdef  STEREO_SUPPORT
    // If stereo is enabled the StereoRefreshRate associated with the mode always overrides
    // what windows wants.
    lstrcpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    lstrcat(StereoKey, "\\");
    lstrcat(StereoKey, NV4_REG_STEREO_SUBKEY);

    if  (RegOpenKey (NV4_REG_GLOBAL_BASE_KEY, StereoKey, &hControl) == ERROR_SUCCESS)
    {
        // Read the current user name
        dwSize = sizeof (long);
        lRet = RegQueryValueEx (hControl, NV_REG_STEREO_ENABLED, NULL, &dwType, 
                        (UCHAR *)&StereoEnabled, (ULONG FAR *) &dwSize);
        RegCloseKey (hControl);
        if  (lRet == ERROR_SUCCESS && StereoEnabled)
        {
            // We know stereo is on. Now let's see if there is a StereoRefreshRate setting
            // in the folder like
            // HKLM\System\CurrentControlSet\Services\Class\Display\000X\MODES\16\1024,768
            GetLocalPath (lpDispData->lpBoardRegistryData, szPath);
            wsprintf(szFullPath, "%s\\MODES\\%ld\\%ld,%ld", szPath,
                                lpModeInfo->dwBpp,
                                lpModeInfo->dwXRes, lpModeInfo->dwYRes);
            // Try to read the user refresh rate from there
            if  (GrabRefreshRateFromKey (HKEY_LOCAL_MACHINE, lpDispData, szFullPath,
                                            lpModeInfo, lpEdidBuffer, dwEdidSize, "StereoRefreshRate"))
                 return  (TRUE);
        }   
    }
#endif  //STEREO_SUPPORT

    // First, is there a current user?
    lRet = RegOpenKey (HKEY_LOCAL_MACHINE, szControl, &hControl);
    if  (lRet == ERROR_SUCCESS)
    {
        // Read the current user name
        szPath[0] = 0;
        dwSize = MAX_KEY_LEN;
        RegQueryValueEx (hControl, "Current User", NULL, NULL,
                         szPath, (ULONG FAR *) &dwSize);

        RegCloseKey (hControl);

        // Try to open HKU\szPath as a key
        lRet = RegOpenKey (HKEY_USERS, szPath, &hControl);
        if  (lRet == ERROR_SUCCESS)
        {
            // Try to read HKU\szPath\Display\Settings
            RegCloseKey (hControl);

            lstrcat (szPath, "\\Display\\Settings");

            // Try to read the user refresh rate
            if  (GrabRefreshRateFromKey (HKEY_USERS, lpDispData, szPath,
                                    lpModeInfo, lpEdidBuffer, dwEdidSize, "RefreshRate"))
                 return  (TRUE);
        }
    }


    // OK, we didn't find it there, so go onto the next stage.
    // This is a path something like
    // HKLM\System\CurrentControlSet\Services\Class\Display\000X\MODES\16\1024,768
    GetLocalPath (lpDispData->lpBoardRegistryData, szPath);
    wsprintf(szFullPath, "%s\\MODES\\%ld\\%ld,%ld", szPath,
                        lpModeInfo->dwBpp,
                        lpModeInfo->dwXRes, lpModeInfo->dwYRes);

    // Try to read the user refresh rate from there
    if  (GrabRefreshRateFromKey (HKEY_LOCAL_MACHINE, lpDispData, szFullPath,
                                    lpModeInfo, lpEdidBuffer, dwEdidSize, "RefreshRate"))
         return  (TRUE);


    // Well, that didn't work either, so last chance is:
    // HKLM\System\CurrentControlSet\Services\Class\Display\000X\Default
    GetLocalPath (lpDispData->lpBoardRegistryData, szPath);
    lstrcat (szPath, "\\Default");
    // Try to read the user refresh rate from there
    if  (GrabRefreshRateFromKey (HKEY_LOCAL_MACHINE, lpDispData, szPath,
                                    lpModeInfo, lpEdidBuffer, dwEdidSize, "RefreshRate"))
         return  (TRUE);

    // Well, we just have to set up a default refresh rate then
    lpModeInfo->dwRefreshRate = 60;
    lpModeInfo->dwOriginalRefreshRate = lpModeInfo->dwRefreshRate;

    return  (TRUE);
}


/*
    Function:   GrabModeInfoString

    Purpose:    This routine reads and parses a string of the
                form "xres,yres,bpp,refrate" from the registry.

    Arguments:  lpRegData    - identifies the specific board
                dwLogDevice  - 0 based logical device number
                               if 0x0FFFFFFFF, then not used.
                lpDevData    - 0 based physical device number
                               if 0x0FFFFFFFF, then not used.
                lpModeString - Name of entry in registry (relative
                               to XXXX\NVidia\Display) that tells the
                               specific mode string to read.
                lpMI         - MODEINFO ptr where parsed mode goes
                nType        - 0 then this is a CRTC info string of the
                               form "xres,yres,bpp,refrate"
                             - 1 then this is a Desktop info string of the
                               form "xres,yres,bpp"

    Returns:    TRUE  that a valid mode was parsed and stored in lpMI
                FALSE there was a problem with the parsing and lpMI
                does not contain valid data.

                NOTE: Even if this routine returns TRUE, it does not
                mean the mode is reasonable. 1,1,55,9876 would be parsed
                fine, but it is not a valid mode string. The caller
                must check for validity if it needs to ensure this.
*/
int CFUNC
GrabModeInfoString (LPREGDATA lpRegData, ULONG dwLogDevice, LPDEVDATA lpDevData,
                    LPCHAR lpModeString, LPMODEINFO lpMI, int nType)
{
    char    szModeInfo[MAX_KEY_LEN];
    ULONG   dwIndex;
    int     bModeValid = FALSE;

    DBG_PRINT0 (DL_0, "\r\nEntering GrabModeInfoString.");

    szModeInfo[0] = 0;

    // If dwLogDevice is 0x0FFFFFFFF, then we get the string from ...
    if  ((dwLogDevice == 0x0FFFFFFFF) && (lpDevData == NULL))
    {
        // ... Nvidia\Display
        GetLocalNvidiaDisplayRegString (lpRegData, lpModeString, szModeInfo);
    }
    else
    {
        // If lpDevData is 0x0FFFFFFFF, then we get the string from ...
        if  (lpDevData == NULL)
        {
            // ... Nvidia\Display\LogDevice%dwLogDevice%.
            GetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice,
                                            lpModeString, szModeInfo);
        }
        else
        {
            // ... otherwise we get the string from
            // Nvidia\Display\LogDevice%dwLogDevice%\PhysDevice%dwPhysDevice%
            GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                                lpModeString, szModeInfo);
        }
    }

    // if we got something back from reading the key, then use it
    if  (szModeInfo[0] != 0)
    {
        // Try to parse the mode
        dwIndex = 0;
        bModeValid = TRUE;

        if  (!ParseDecimalNumberComma (szModeInfo, &dwIndex, &lpMI->dwXRes))
            bModeValid = FALSE;
        DBG_PRINT1(DL_2, "\r\nXRes found to be %ld", lpMI->dwXRes);

        if  (!ParseDecimalNumberComma (szModeInfo, &dwIndex, &lpMI->dwYRes))
            bModeValid = FALSE;
        DBG_PRINT1(DL_2, "\r\nYRes found to be %ld", lpMI->dwYRes);

        if  (!ParseDecimalNumberComma (szModeInfo, &dwIndex, &lpMI->dwBpp))
            bModeValid = FALSE;
        DBG_PRINT1(DL_2, "\r\nBpp found to be %ld", lpMI->dwBpp);

        // The XRes and YRes can be whatever, but let's validate the
        // Bpp here.
        if  ((lpMI->dwBpp != 8) && (lpMI->dwBpp != 16) && (lpMI->dwBpp != 32))
        {
            DBG_PRINT0(DL_2, "\r\nBpp invalid. Changed to 8.");
            lpMI->dwBpp = 8;
        }

        if  (nType == 0)
        {
            if  (!ParseDecimalSeparator (szModeInfo, &dwIndex, &lpMI->dwRefreshRate, ',', 0))
                bModeValid = FALSE;
            DBG_PRINT1(DL_2, "\r\nRefresh Rate found to be %ld", lpMI->dwRefreshRate);
        }
    }

    DBG_PRINT0 (DL_1, "\r\nExiting GrabModeInfoString.");
    return  (bModeValid);
}


/*
    Function:   GetDefaultRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData  - identifies the specific board
                lpModeInfo  - tells which display device port is being
                              used since there might be different
                              default refresh rates for DFPs and CRTs.

    Returns:    always returns a value that is the default refresh rate
*/
ULONG CFUNC
GetDefaultRefreshRate (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    int     nRet;
    ULONG   dwRefreshRate, dwIndex;
    char    szDev[32];

    // Filter out TVs here -- always say 60Hz.
    if  (lpModeInfo->MIDevData.cType == DEVTYPE_TV)
        return  (60);

    if  (lpModeInfo->MIDevData.cType == DEVTYPE_CRT)
        lstrcpy (szDev, NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE);
    else
        lstrcpy (szDev, NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE);

    nRet = GetLocalNvidiaDisplayRegString (lpDispData->lpBoardRegistryData,
                                            szDev, szPath);
    if  (nRet)
    {
        dwIndex = 0;
        if  (ParseDecimalSeparator (szPath, &dwIndex, &dwRefreshRate, 0, 0))
        {
            return  (dwRefreshRate);
        }
    }

    return  (60);
}


/*
    Function:   GetOptimalRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData   - identifies the specific board
                lpModeInfo   - Current mode and device identifier.
                lpEdidBuffer - points to a buffer with EDID data in
                               it if dwEdidSize is not 0. If dwEdidSize
                               is 0, this argument is ignored.
                dwEdidSize     tells the size of the lpEdidBuffer
                               in bytes. If this variables is 0,
                               then lpEdidBuffer ptr may be invalid.

    Returns:    always returns a value that is the optimal refresh rate
*/
ULONG CFUNC
GetOptimalRefreshRate (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo,
                        LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG           dwRefreshRate, dwRegRefreshRate, dwIndex;
    ULONG           dwMaxXRes;
    ULONG           dwMaxYRes;
    MONITORLIMITS   ML;
    char            szDev[32];

    if ((dwEdidSize == 0) && (lpDispData->dwMonitorInfType == UNKNOWN_DEVICE))
    {
        // If monitor is unknown and no EDID, then only 60Hz allowed.
        return  (60);
    }

    // Filter out TVs here -- always say 60Hz.
    if  (lpModeInfo->MIDevData.cType == DEVTYPE_TV)
        return  (60);

    // Check if RestrictOptimal key exists and is equal to ASCII "1".
    // If so, check detailed, established, and standard timings for
    // an exact match of the XRes and YRes and use that RefreshRate
    // if it exists.
    if (GetLocalNvidiaDisplayRegString (lpDispData->lpBoardRegistryData,
            NV4_REG_DRV_USE_REFRESH_RATE_OF_XYRES_EDID_MODE_MATCH, szPath))
    {
        if  (!lstrcmpi (szPath, NV4_REG_DRV_TRUE))
        {
            if (dwEdidSize)
            {
                dwRefreshRate = (ULONG) EdidFindExactModeWithHighestRR
                                             (lpEdidBuffer, dwEdidSize,
                                              lpModeInfo);
                if  (dwRefreshRate)
                    return  (dwRefreshRate);
            }
        }
    }

    // Now let's deal with an EDID if it exists
    if  (dwEdidSize != 0)
    {
        // Use the mode in the EDID with the largest refresh rate
        // whose resolution is at least as big as the one passed in.
        dwRefreshRate = (ULONG) EdidFindSameModeOrLargerWithHighestRR (
                                lpEdidBuffer, dwEdidSize, lpModeInfo);
    }
    else
    {
        if  (!GetMonitorInfRangeLimits (lpDispData, &ML, &dwMaxXRes, &dwMaxYRes))
        {
            // Something went wrong getting monitor range limits.
            // Limit ourselves to 60Hz
            return (60);
        }

        if  ((!dwMaxXRes) || (!dwMaxYRes))
        {
            return  (60);
        }

        // Use the maximum xres and yres at the max vertical refresh rate
        // to compute what the monitor limits will be at the desired target
        // resolution.
        dwRefreshRate = GetMaximumRefreshRate (dwMaxXRes, dwMaxYRes,
                        ML.dwMaxVert, &ML, lpModeInfo->dwXRes,
                        lpModeInfo->dwYRes);
    }

    // See if the registry has an upper limit on the optimal
    // refresh rate value.
    dwRegRefreshRate = 0;
    if  (lpModeInfo->MIDevData.cType == DEVTYPE_CRT)
        lstrcpy (szDev, NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE);
    else
        lstrcpy (szDev, NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE);

    if (GetLocalNvidiaDisplayRegString (lpDispData->lpBoardRegistryData,
                                    szDev, szPath))
    {
        dwIndex = 0;
        if  (!ParseDecimalSeparator (szPath, &dwIndex, &dwRegRefreshRate, 0, 0))
        {
            // Parsing the refresh rate found in the registry failed,
            // so set the refresh rate back to 0.
            dwRegRefreshRate = 0;
        }
    }

    // If we found an upper bound in the registry, use it
    if  (dwRegRefreshRate)
    {
        if  (dwRefreshRate > dwRegRefreshRate)
            dwRefreshRate = dwRegRefreshRate;
    }

    // Now return the refresh rate or 60Hz.
    if  (dwRefreshRate != 0)
        return  (dwRefreshRate);

    return  (60);
}



/*
    Function:   GrabRefreshRateFromKey

    Purpose:    This routine reads the RefreshRateName string value
                from the key and path provided and does a little
                preprocessing on what it finds. i.e. it handles
                optimal (-1) and default (0) cases.

    Arguments:  hKey          base Key in registry from which to read
                lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpszPath      path in registry to access which may
                              contain a RefreshRateName string.
                lpModeInfo  - Current mode and device identifier.
                lpEdidBuffer- points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    TRUE  then lpModeInfo->dwRefreshRate has a real
                      value stuffed in it. Also the field
                      lpModeInfo->dwOriginalRefreshRate has the
                      "Windows" value in it which might be the same
                      as ->dwRefreshRate if Windows was requesting
                      a specific refresh rate, or it can be 0 for
                      default or -1 for optimal.
                FALSE if nothing was found or there was an error.
*/
int CFUNC
GrabRefreshRateFromKey (ULONG hKey, LPDISPDATA lpDispData, LPCHAR lpszPath,
                LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize, char *RefreshRateName)
{
    ULONG   hControl;
    char    szRefreshRate[8];
    int     bFoundRefRate;
    ULONG   dwIndex, dwSize;
    long    lRet;

    lRet = RegOpenKey (hKey, lpszPath, &hControl);
    if  (lRet != ERROR_SUCCESS)
    {
        return  (FALSE);
    }

    // OK, now hUser is a key to someplace in the registry that
    // may have a RefreshRateName value string in it. Find out.
    szRefreshRate[0] = 0;
    dwSize = 8;
    RegQueryValueEx (hControl, RefreshRateName, NULL, NULL,
                         szRefreshRate, (ULONG FAR *) &dwSize);

    bFoundRefRate = FALSE;
    if  (szRefreshRate[0] != 0)
    {
        // OK -- if the value is a specific refresh rate then
        // that is what we use.
        dwIndex = 0;
        if  (ParseDecimalSeparator (szRefreshRate, &dwIndex, &lpModeInfo->dwOriginalRefreshRate, 0, 0))
        {
            if  (lpModeInfo->dwOriginalRefreshRate == 0)
            {
                // If we actually parsed a '0' that means adapter default
                lpModeInfo->dwRefreshRate =
                GetDefaultRefreshRate (lpDispData, lpModeInfo);
            }
            else
            {
                // dwOriginalRefreshRate has specific refresh rate. Save
                // in dwRefreshRate.
                lpModeInfo->dwRefreshRate = lpModeInfo->dwOriginalRefreshRate;
            }

            bFoundRefRate = TRUE;
        }

        // Is the refresh rate set to "-1"?  'Cause that is optimal.
        if  (!lstrcmpi(szRefreshRate, "-1"))
        {
            lpModeInfo->dwOriginalRefreshRate = 0x0FFFFFFFF;
            lpModeInfo->dwRefreshRate = GetOptimalRefreshRate (lpDispData,
                                                    lpModeInfo, lpEdidBuffer,
                                                    dwEdidSize);
            bFoundRefRate = TRUE;
        }

        // OK, we either found a value and parsed it or the value was
        // set to "-1". If either one of those things happened, then
        // we "found" a refresh rate. If neither happened, we didn't.
    }

    // Done with the key
    RegCloseKey (hControl);

    if  (bFoundRefRate)
    {
        // Just as a safety precausion, force refresh rates < 60 up to 60
        if  (lpModeInfo->dwRefreshRate < 60)
        {
            lpModeInfo->dwRefreshRate = 60;
            lpModeInfo->dwOriginalRefreshRate = lpModeInfo->dwRefreshRate;
        }

        return  (TRUE);
    }

    return  (FALSE);
}


char  *(szBppAppend[]) =
{
    "\\8", "\\16", "\\24", "\\32"
};

// I would put these locally on the stack in the following function,
// but we ran out of stack space!!
char            szResPath[MAX_KEY_LEN];
char            szRefreshRateList[MAX_KEY_LEN];
char            szNewRefreshRateList[MAX_KEY_LEN];
char            szPDPath[MAX_KEY_LEN];
char            szNPDPath[MAX_KEY_LEN];

/*
    Function:   ResetRefreshRates

    Purpose:    This routine walks through the refresh rate strings in
                all the leaf subkeys of ....\DISPLAY\000X\MODES and updates
                the Default string. The Default string has a refresh
                rate list of something like "60,70,72,75,85,100,120".
                This string is replaced with a new refresh rate string
                containing those refresh rates that are supported in
                the current configuration which is given by lpDispData.

                This routine assumes that all of the leaf subkeys of
                ....\DISPLAY\000X\MODES have in them a master refresh
                rate list string somethig like:
                "ModeRefreshRateList"   "60,70,72,75,85,etc.."

    Arguments:
                lpDevData    - LPDEVDATA
                lpDispData   - identifies the specific board and
                               configuration that we want the refresh
                               rate list to agree with.
                lpEdidBuffer - ptr to EDID
                dwEdidSize   - length of edid in bytes. 0 if no edid.

    Returns:    TRUE    if refresh rate list was updated
                FALSE   if it wasn't because of some error dealing with
                        the registry
*/
int WINAPI
ResetRefreshRates (LPDEVDATA lpDevData, LPDISPDATA lpDispData,
                    LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG           dwSrcIndex;
    int             i, pd, npd, bDone;
    ULONG           dwSubKey, dwMajorKey;
    ULONG           hModeBppKey, hModeResKey, dwSize;
    ULONG           hModeNewBppKey, hModeNewResKey;
    ULONG           dwIndex, dwMaxDacSpeed, dwMaxRefreshRate, dwRefreshRate;
    ULONG           dwMaxXRes, dwMaxYRes;
    ULONG           dwXRes, dwYRes, dwTotalPixels;
    GTFIN           GTFIn;
    GTFOUT          GTFOut;
    LPCHAR          lpMasterRefreshRateList, lpNewRefreshRateList;
    long            lRet;
    char            szRes[32];
    char            szRegPath[MAX_KEY_LEN];
    char            szAddedRefreshRate[16];
    MONITORLIMITS   sML;

    // Start off with a "Last" value that will never match
#define MAX_CACHE_EDID_SIZE 512
    int             nMustReset, nSmallerSize;
    static          DEVDATA sLastDevData = { -1, 0, 0, 0 };
    static          ULONG   dwLastEdidSize = 0x0FFFFFFFF;
    static          unsigned char  szLastEdid[MAX_CACHE_EDID_SIZE];
    static          ULONG   dwLastMonitorInfType = 0x0FFFFFFFF;
    static          ULONG   dwLastMaxDacSpeed8bpp = 0x0FFFFFFFF;
    static          ULONG   dwLastMaxDacSpeed16bpp = 0x0FFFFFFFF;
    static          ULONG   dwLastMaxDacSpeed32bpp = 0x0FFFFFFFF;

    DBG_PRINT0(DL_0, "\r\nEntering ResetRefreshRates.");

    ///////////////////////////////////////////////////////////////
    // A little caching scheme to speed things up.
    // If the device type is DIFFERENT from the last one passed
    // into this routine then we definitely need to update the
    // refresh rate list. If it is the same type of device, then
    // we do some other checks.
    nMustReset = FALSE;
    if  (sLastDevData.cType != lpDevData->cType)
        nMustReset = TRUE;
    else
    {
        // Same device type. Do the current and last devices
        // both have EDIDS?
        if  (dwEdidSize != dwLastEdidSize)
            nMustReset = TRUE;
        else
        {
            // Edid Sizes are the same. If the edid size is not 0,
            // then compare the two EDIDs
            if  (dwEdidSize != 0)
            {
                if  (dwLastEdidSize < dwEdidSize)
                    nSmallerSize = (int) dwLastEdidSize;
                else
                    nSmallerSize = (int) dwEdidSize;

                for (i = 0; i < nSmallerSize; i++)
                {
                    if  (szLastEdid[i] != lpEdidBuffer[i])
                    {
                        nMustReset = TRUE;
                        break;
                    }
                }
            }

            // Make sure that both have the same type of .inf file
            if  (dwLastMonitorInfType != lpDispData->dwMonitorInfType)
                nMustReset = TRUE;

            // If we have different limits on the DAC speed ....
            if  ((dwLastMaxDacSpeed8bpp != lpDispData->dwMaxDacSpeedInHertz8bpp)
              || (dwLastMaxDacSpeed16bpp != lpDispData->dwMaxDacSpeedInHertz16bpp)
              || (dwLastMaxDacSpeed32bpp != lpDispData->dwMaxDacSpeedInHertz32bpp))
                nMustReset = TRUE;
        }
    }

    if  (!nMustReset)
    {
        // Last device and current device are the same.
        // Nothing to do.
        return  (TRUE);
    }
    else
    {
        // Save off all the stuff for cache comparison next time.
        sLastDevData = *lpDevData;
        dwLastEdidSize = dwEdidSize;
        dwLastMonitorInfType = lpDispData->dwMonitorInfType;
        if  (dwLastEdidSize)
        {
            // We simply can't cache EDIDs larger than 512 bytes
            if  (dwLastEdidSize > MAX_CACHE_EDID_SIZE)
                 dwLastEdidSize = 0;

            for (i = 0; i < (int) dwLastEdidSize; i++)
                szLastEdid[i] = lpEdidBuffer[i];
        }

        dwLastMaxDacSpeed8bpp = lpDispData->dwMaxDacSpeedInHertz8bpp;
        dwLastMaxDacSpeed16bpp = lpDispData->dwMaxDacSpeedInHertz16bpp;
        dwLastMaxDacSpeed32bpp = lpDispData->dwMaxDacSpeedInHertz32bpp;

        // Fall through and let's reset the refresh rate list correctly.
    }
    ///////////////////////////////////////////////////////////////


    // Try to get the path in the registry to where the mode list is.
    if  (GetLocalPath (lpDispData->lpBoardRegistryData, szRegPath) < 0)
    {
        DBG_PRINT0(DL_0, "\r\nExiting ResetRefreshRates because RegOpenKey (...MODES) failed.");
        return  (FALSE);
    }

    dwMajorKey = lpDispData->lpBoardRegistryData->dwMainKey;

    // Tack on "\\MODES" to the returned regpath
    lstrcat (szRegPath, "\\Modes");

    // Create a loop so we can extract the modes for each pixel depth
    for (pd = 0; pd < 4; pd++)
    {
        // Copy the path to ...DISPLAY\000X\MODES and then tack on
        // the correct pixel depth key
        lstrcpy (szPDPath, szRegPath);

        switch  (pd)
        {
            case 0:
                lstrcat (szPDPath, "\\8");
                dwMaxDacSpeed = lpDispData->dwMaxDacSpeedInHertz8bpp;
                break;
            case 1:
                lstrcat (szPDPath, "\\16");
                dwMaxDacSpeed = lpDispData->dwMaxDacSpeedInHertz16bpp;
                break;
            case 2:
                lstrcat (szPDPath, "\\24");
                // We don't support 24bpp so don't need to worry here.
                break;
            case 3:
                lstrcat (szPDPath, "\\32");
                dwMaxDacSpeed = lpDispData->dwMaxDacSpeedInHertz32bpp;
                break;
        }

        // We now have the key where the pixel depth specific modes are.
        // Go ahead and open the key.
        lRet = RegOpenKey (dwMajorKey, szPDPath, &hModeBppKey);

        if  (lRet != ERROR_SUCCESS)
        {
            // If we have trouble opening a Bpp key, that is OK, since
            // we might not support a particular pixel depth. Just go
            // on to the next one.
            continue;
        }

        // Enumerate the subkeys -- each key is a spatial resolution.
        // Within each key there is a "(default)" string which has a
        // list of refresh rates which looks like: "60,72,75,85"
        // If the key does not have a list of refresh rates, then
        // we just write 60Hz as the only available refresh rate for
        // that mode.

        for (dwSubKey = 0; TRUE; dwSubKey++)
        {
            lRet = RegEnumKey (hModeBppKey, dwSubKey, szRes, MAX_KEY_LEN);

            if  (lRet != ERROR_SUCCESS)
            {
                // If there was an error, it probably means that there are
                // no more subkeys -- i.e. resolutions for this pixel
                // depth. That's fine. Break out of the loop.
                break;
            }

            // Get the xres and yres from the key string.
            dwIndex = 0;
            ParseDecimalSeparator (szRes, &dwIndex, &dwXRes, ',', ',');
            ParseDecimalSeparator (szRes, &dwIndex, &dwYRes, 0, 0);

            // So, here's the thing. We have set dwMaxDacSpeed to the
            // maximum dac speed for the pixel depth we are currently
            // working with. dwMaxDacSpeed takes into account memory
            // speed limitations, graphics chip CRTC limitations, etc.
            // Given this MaxSpeed, we need to come up with a max
            // vertical refresh rate. We need Microsoft's algorithm
            // here so that we could match what they would show, but
            // we don't have it, so for now we do our best.
            // Use GTF to find a refresh rate.

            dwMaxRefreshRate = 0;
            if  ((dwEdidSize == 0) ||
                 (!EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &sML)))
            {
                if  ((lpDispData->dwMonitorInfType != SPECIFIC_DEVICE) ||
                     (!GetMonitorInfRangeLimits (lpDispData, &sML, &dwMaxXRes, &dwMaxYRes)))
                {
                    // There are no monitor limits, from either an EDID
                    // or an .inf, so just say YES.
                    GTFIn.dwHPixels = dwXRes;
                    GTFIn.dwVLines  = dwYRes;
                    GTFIn.dwMarginsRqd = FALSE;
                    GTFIn.dwIntRqd = FALSE;
                    GTFIn.dwIPParmType = IPTYPE_PIXEL_CLOCK_RATE;
                    GTFIn.dwIPFreqRqd = Divide32By32 (dwMaxDacSpeed, 1000000);

                    // Get the timing parameters.
                    ComputeGTFParameters(&GTFIn, &GTFOut);
                    dwMaxRefreshRate = Multiply32By32 (GTFOut.dwPixelClockIn10KHertz, 10000);
                    dwTotalPixels = Multiply32By32 (GTFOut.dwVTotalScans, (GTFOut.dwHTotalChars << 3));
                    dwMaxRefreshRate = Divide32By32 (dwMaxRefreshRate, dwTotalPixels);
                }
            }

            if  (dwMaxRefreshRate == 0)
            {
                if (sML.dwMaxPixelClock > dwMaxDacSpeed)
                    sML.dwMaxPixelClock = dwMaxDacSpeed;
                dwMaxRefreshRate = GetMaximumRefreshRate (0, 0, 0, &sML,
                                        dwXRes, dwYRes);
            }

            DmtGetMaximumRefreshRate (dwXRes, dwYRes, sML.dwMaxPixelClock,
                                      &dwRefreshRate);

            if (dwRefreshRate > dwMaxRefreshRate)
                dwMaxRefreshRate = dwRefreshRate;

            // Build a full path to the resolution key so we can open it
            lstrcpy (szResPath, szPDPath);
            lstrcat (szResPath, "\\");
            lstrcat (szResPath, szRes);

            // OK, now open the spatial resolution key so that we can
            // get the list of refresh rates for this resolution.
            lRet = RegOpenKey (dwMajorKey, szResPath, &hModeResKey);

            if  (lRet == ERROR_SUCCESS)
            {
                // Read the "ModeRefreshRateList" key.
                dwSize = MAX_KEY_LEN;
                lRet = RegQueryValueEx (hModeResKey, "ModeRefreshRateList",
                                NULL, NULL, szRefreshRateList, &dwSize);

                if  (lRet != ERROR_SUCCESS)
                {
                    // If we didn't find a ModeRefreshRateList, there
                    // might be several reasons. Asuume, though, that
                    // we could find one if we looked at the same
                    // resolution key in a lower color depth.
                    for (npd = pd - 1; npd >= 0; npd--)
                    {
                        lstrcpy (szNPDPath, szRegPath);
                        lstrcat (szNPDPath, szBppAppend[npd]);
                        lRet = RegOpenKey (dwMajorKey, szNPDPath, &hModeNewBppKey);
                        if  (lRet == ERROR_SUCCESS)
                        {
                            lstrcat (szNPDPath, "\\");
                            lstrcat (szNPDPath, szRes);
                            lRet = RegOpenKey (dwMajorKey, szNPDPath, &hModeNewResKey);
                            if  (lRet == ERROR_SUCCESS)
                            {
                                // Read the "ModeRefreshRateList" key.
                                dwSize = MAX_KEY_LEN;
                                lRet = RegQueryValueEx (hModeNewResKey,
                                        "ModeRefreshRateList", NULL,
                                        NULL, szRefreshRateList, &dwSize);

                                RegCloseKey (hModeNewResKey);
                            }

                            RegCloseKey (hModeNewBppKey);
                        }

                        if  (lRet == ERROR_SUCCESS)
                            break;
                    }
                }


                if  (lRet == ERROR_SUCCESS)
                {
                    // Now build a refresh rate string consisting of
                    // those refresh rates that are supported according
                    // to the BoardData.

                    // Always specify 60Hz.
                    lpNewRefreshRateList = szNewRefreshRateList;
                    wsprintf (lpNewRefreshRateList, "%d", 60);

                    if  ((lpDevData->cType == DEVTYPE_CRT) ||
                         (lpDevData->cType == DEVTYPE_DFP))
                    {
                        dwSrcIndex = 0;
                        bDone = FALSE;
                        lpMasterRefreshRateList = szRefreshRateList;
                        for (i = 0; !bDone; i++)
                        {
                            // Get the next refresh rate in the naster list
                            bDone = !ParseDecimalSeparator (lpMasterRefreshRateList, &dwSrcIndex, &dwRefreshRate, ',', 0);

                            if  (!bDone)
                            {
                                // We found a decimal number refresh rate
                                // Is this one within bounds?
                                if  (dwRefreshRate <= dwMaxRefreshRate)
                                {
                                    // Add it to the new list if it is not 60Hz
                                    // since we already added that in above
                                    if  (dwRefreshRate != 60)
                                    {
                                        wsprintf (szAddedRefreshRate, ",%d", dwRefreshRate);
                                        lstrcat (lpNewRefreshRateList, szAddedRefreshRate);
                                    }
                                }
                            }
                        }
                    }

                    // Write back the updated refresh rate list as
                    // the defaukt field in this key. That is what
                    // windows expects.
                    RegSetValueEx (hModeResKey, "", NULL, REG_SZ, lpNewRefreshRateList, lstrlen(lpNewRefreshRateList));
                }
            }

            // Close this bpp key
            RegCloseKey (hModeResKey);
        }

        // Close this bpp key
        RegCloseKey (hModeBppKey);
    }

    DBG_PRINT0(DL_0, "\r\nExiting ResetRefreshRates.");

    return  (TRUE);
}

/*
    Function:   GetEdidRegistryKey

    Purpose:    This routine gets the registry key that tells
                whether or not we are supposed to read the EDID.

    Arguments:  lpRegData   - identifies the specific board

    Returns:    0       registry key does not exist or says not to
                        read the EDID
                non-0   registry key exists and says to read the EDID
*/
int WINAPI
GetEdidRegistryKey (LPREGDATA lpRegData)
{
    int     nFlag;

    DBG_PRINT0 (DL_0, "\r\nEntering GetEdidRegistryKey.");

    nFlag = GetLocalNvidiaDisplayRegValue (lpRegData,
                                        NV4_REG_DRV_FORCE_EDID_READ, 0);

    DBG_PRINT1(DL_1, "\r\nExiting GetEdidRegistryKey.", nFlag);
    return  (nFlag);
}


int WINAPI
SetResolutionAndColorDepth (ULONG Bpp, ULONG XRes, ULONG YRes)
{
    ULONG       hDisplay;
    long        lRet;
    char        szResolution[MAX_KEY_LEN];
    char        szBpp[MAX_KEY_LEN];

    wsprintf (szResolution, "%ld,%ld", XRes, YRes);
    wsprintf (szBpp, "%ld", Bpp);

    // Open display settings key
    lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szSettings, &hDisplay);
    if  (lRet == ERROR_SUCCESS)
    {
        RegSetValueEx (hDisplay, "Resolution", NULL, REG_SZ, szResolution, strlen(szResolution));
        RegCloseKey (hDisplay);
        return  (TRUE);
    }
    return  (FALSE);
}


/*
    GetDesktopModeList

    This routine gets the desktop mode list and returns it.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
GetDesktopModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType)
{
    LPMODEENTRY lpME;
    int         j;

    lpME = GetModeListFromRegistry (lpDispData);

    j = FormatModeList (lpDispData, lpModes, dwType, lpME);

    FreeMasterModeList (lpME);
    return  (j);
}


/*
    Function:   GetAllowAllModesFlag

    Purpose:    WIN9X spacific function for testing only.
                This function get "AllowAllModes" registry key
                for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "AllowAllModes" key value or FALSE.
*/
ULONG WINAPI GetAllowAllModesFlag(LPREGDATA lpRegData)
{

    int     nDefault = 0;
    int     wAllowAllModes = 0;

    wAllowAllModes =
        GetLocalNvidiaDisplayRegValue (lpRegData,
                                    NV4_REG_DRV_ALLOW_ALL_MODES, nDefault);

    return ((ULONG) wAllowAllModes);
}


/*
    Function:   GetAllowMightyModesFlag

    Purpose:    WIN9X spacific function for testing only.
                This function gets "AllowMightyModes" registry key
                for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "AllowMightyModes" key value or FALSE.
*/
ULONG WINAPI GetAllowMightyModesFlag(LPREGDATA lpRegData)
{

    int     nDefault = 0;
    int     wAllowMightyModes = 0;

    wAllowMightyModes =
        GetLocalNvidiaDisplayRegValue (lpRegData,
                                    NV4_REG_DRV_ALLOW_MIGHTY_MODES, nDefault);

    return ((ULONG) wAllowMightyModes);
}

/*
    Function:   GetControlVisionFlag

    Purpose:    WIN9X spacific function for testing only.
        This function get "ControlVision" registry key
        for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "ControlVision" key value or FALSE.
*/


int WINAPI
GetControlVisionFlag(LPDISPDATA lpDispData)
{

    int     nDefault = 0;
    int     wControlVisionFlag = 0;

    wControlVisionFlag = GetLocalNvidiaDisplayRegValue (lpDispData->lpBoardRegistryData,
                                   "ControlVision", nDefault);

    return wControlVisionFlag;
}


/*
    Function:   GetCheckSXGAPanelFlag

    Purpose:    This function gets "CheckSXGAPanel" registry key
                for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "CheckSXGAPanel" key value or FALSE.
*/
ULONG WINAPI GetCheckSXGAPanelFlag(LPREGDATA lpRegData)
{

    int     nDefault = 0;
    int     wCheckSXGAPanel = 0;

    wCheckSXGAPanel =
        GetLocalNvidiaDisplayRegValue (lpRegData,
                                    NV4_REG_DRV_CHECK_SXGA_PANEL, nDefault);

    return ((ULONG) wCheckSXGAPanel);
}


/*
    ParseDeviceTypeAndNumber

    Purpose:    This routine parses a string of the form "CRT4"
                or "TV2".  It gets the device type followed by
                the device number hich can be 0 - 9.

    Arguments:  lpszString  - string of the form described in Purpose:
                lpDevData   - ptr to a DEVTYPE structure.

    Returns:    TRUE    if lpDevData is filled in correctly.
                        Note: Only the DEVTYPE.cType and DEVTYPE.cNumber
                        are filled in. The DEVTYPE.cFormat is untouched.
                FALSE   otherwise
*/
int WINAPI
ParseDeviceTypeAndNumber (LPCHAR lpszString, LPDEVDATA lpDevData)
{
    int     i, nIndex, nEnd, nRet;
    char    cOld;

    nIndex = 0;
    for (i = 0; DeviceTypes[i].lpszName != NULL; i++)
    {
        // lstrncmpi does not exist, so I do it this way ...
        nEnd = (int) lstrlen (DeviceTypes[i].lpszName);
        cOld = lpszString[nEnd];

        lpszString[nEnd] = 0;
        nRet = (int) lstrcmpi (DeviceTypes[i].lpszName, lpszString);
        lpszString[nEnd] = cOld;

        if  (!nRet)
        {
            lpDevData->cType = DeviceTypes[i].cType;
            nIndex = nEnd;
            break;
        }
    }

    if  (nIndex != 0)
    {
        // We must have found a device type
        lpDevData->cNumber = lpszString[nIndex] - '0';
        if  ((lpDevData->cNumber < 0) || (lpDevData->cNumber > 9))
            lpDevData->cNumber = 0;

        return  (TRUE);
    }

    return  (FALSE);
}


/*
    IsDriverAttachedToDesktop

    Purpose:    This routine reads a Widnows OS maintained string
                in part of the registry that says whether or not
                the device specified is part of the virtual desktop
                in a multi-mon sceanrio. This way we can tell whether
                the device is enabled or not.

    Arguments:  lpszPciSpecifier
                This is a string that looks something like:
                PCI\VEN_10DE&DEV_0110&SUBSYS_00000000&REV_A1\000800

                We will need to convert this to
                PCI_VEN_10DE&DEV_0110&SUBSYS_00000000&REV_A1_000800_0001

                NOTE that the '\' got changed to an underscore and
                the _0001 got tacked on the end. Look for this key
                under HKEY_CURRENT_CONFIG\Display\Settings. Then go
                into it and look for something called "AttachToDesktop"
                It is a string value and if is present and has value "1"
                then return TRUE. Else we return FALSE.

    Returns:    TRUE    Driver is attached to desktop (device is enabled)
                FALSE   otherwise
*/
int WINAPI
IsDriverAttachedToDesktop (LPCHAR lpszPciSpecifier,ULONG ulDeviceNum)
{
    char    szRegPath[128], szRet[MAX_KEY_LEN];
    int     i, nLen, nRet, nUseCurrentConfig;
    ULONG   lRet, hKey;

    // First read registry to see if a user is logged in. The
    // AttachToDesktop key is valid in different locations in the
    // registry depending on whether or not a user is logged in.
    lstrcpy (szRegPath, "System\\CurrentControlSet\\Control\\");
    nLen = (int) lstrlen (szRegPath);

    lRet = RegOpenKey (HKEY_LOCAL_MACHINE, szRegPath, &hKey);

    // If we don't know, then play it safe and return TRUE
    if  (lRet != ERROR_SUCCESS)
        return  (TRUE);

    // Now read the AttachToDesktop value name
    nRet = GetRegString (hKey, "Current User", szRet);

    // If Current User exists, can only use HKEY_CURRENT_USER if
    // the user in "Current User" has a registry subdirectory in
    // HKEY_USERS.
    nUseCurrentConfig = TRUE;
    if (nRet)
    {
        lRet = RegOpenKey (HKEY_USERS, szRet, &hKey);
        if (lRet == ERROR_SUCCESS)
        {
            nUseCurrentConfig = FALSE;
            RegCloseKey (hKey);
        }
    }

    lstrcpy (szRegPath, "Display\\Settings\\");
    nLen = (int) lstrlen (szRegPath);

    // Copy lpszPciSpecifier replacing any '\' with an underscore
    for (i = 0; lpszPciSpecifier[i] != 0; i++)
    {
        szRegPath[nLen + i] = lpszPciSpecifier[i];
        if  (szRegPath[nLen + i] == '\\')
            szRegPath[nLen + i] = '_';
    }

    // Null terminate it
    szRegPath[nLen + i] = 0;

    // Tack a _0001 on the end for the second device on this board
	if(ulDeviceNum != 0)
	{
		wsprintf (szRegPath + nLen + i, "_000%1d", ulDeviceNum);
	}

    // Open the key. If "Current User" exists, use HKEY_CURRENT_USER;
    // otherwise, use HKEY_CURRENT_CONFIG.
    if (nUseCurrentConfig)
        lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szRegPath, &hKey);
    else
        lRet = RegOpenKey (HKEY_CURRENT_USER, szRegPath, &hKey);

    // If we don't know, then play it safe and return TRUE
    if  (lRet != ERROR_SUCCESS)
        return  (TRUE);

    szRet[0] = 0;

    // Now read the AttachToDesktop value name
    nRet = GetRegString (hKey, "AttachToDesktop", szRet);

    if (nRet == TRUE)
    {
        // AttachToDesktop can be '0'. Make sure the key not only exists
        // but is equal to '1'.
        if (szRet[0] == '1')
            return  (TRUE);
    }

    return  (FALSE);
}


/*
    lpfnResetDisabledDeviceResolutions

    Purpose:    This routine runs through all the devices that have
                ever been secondaries and reset their resolutions
                to 640x480

    Arguments:  None

    Returns:    TRUE
*/
int WINAPI
lpfnResetDisabledDeviceResolutions ()
{
    char    szRegPath[128], szYes[4];
    ULONG   dwSubKey, lRet, dwSize;
    ULONG   hKey, hFullKey;

    lstrcpy (szRegPath, szSettings);

    // Open the key
    lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szRegPath, &hKey);

    // Just return if it failed.
    if  (lRet != ERROR_SUCCESS)
        return  (TRUE);

    for (dwSubKey = 0; TRUE; dwSubKey++)
    {
        lRet = RegEnumKey (hKey, dwSubKey, szExtraKey, MAX_KEY_LEN);
        if  (lRet != ERROR_SUCCESS)
        {
            // If there was an error, it probably means that there are
            // no more subkeys -- i.e. no more secondaries to look at.
            break;
        }

        // Tack the base key onto this and open
        lstrcpy (szFullPath, szRegPath);
        lstrcat (szFullPath, "\\");
        lstrcat (szFullPath, szExtraKey);

        lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szFullPath, &hFullKey);
        if  (lRet == ERROR_SUCCESS)
        {
            // Is this device enabled?
            // Read the AttachToDesktop key
            szYes[0] = 0;
            dwSize = 4;
            lRet = RegQueryValueEx (hFullKey, "AttachToDesktop", NULL,
                                NULL, (LPCHAR) &szYes, &dwSize);

            if  ((szYes[0] == 0) || (szYes[0] == '0'))
            {
                // If the AttachToDesktop key doesn't exist OR
                // it exists AND it is explicitly set to "0", then
                // the device is disabled.

                RegSetValueEx (hFullKey, "Resolution", NULL,
                                    REG_SZ, sz640_480, lstrlen(sz640_480));
            }

            RegCloseKey (hFullKey);
        }
    }

    RegCloseKey (hKey);
    return  (TRUE);
}

int WINAPI
DisplayDriverControl()
{
    //Just set breakpoint here and you will control any driver Loading-Unloading.
    //ax should be the value for SYMLOC
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\MODELIST.C ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to build a modelist from the registry
    and to walk the list looking for different things.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "utils.h"
#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"

MODEENTRY   SafeModeList[] =
{
    { 640,  480, 8,  60 },
    { 800,  600, 8,  60 },
    { 1024, 768, 8,  60 },
    { 640,  480, 16, 60 },
    { 800,  600, 16, 60 },
    { 1024, 768, 16, 60 },
    { 640,  480, 32, 60 },
    { 800,  600, 32, 60 },
    { 1024, 768, 32, 60 },
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   sLowModes[] =
{
    { 320,  200, 8,  60 },
    { 320,  200, 8,  70 },
    { 320,  200, 8,  72 },
    { 320,  200, 8,  75 },
    { 320,  200, 8,  85 },
    { 320,  200, 8,  100 },
    { 320,  200, 8,  120 },
    { 320,  240, 8,  60 },
    { 320,  240, 8,  70 },
    { 320,  240, 8,  72 },
    { 320,  240, 8,  75 },
    { 320,  240, 8,  85 },
    { 320,  240, 8,  100 },
    { 320,  240, 8,  120 },
    { 400,  300, 8,  60 },
    { 400,  300, 8,  70 },
    { 400,  300, 8,  72 },
    { 400,  300, 8,  75 },
    { 400,  300, 8,  85 },
    { 400,  300, 8,  100 },
    { 400,  300, 8,  120 },
    { 480,  360, 8,  60 },
    { 480,  360, 8,  70 },
    { 480,  360, 8,  72 },
    { 480,  360, 8,  75 },
    { 480,  360, 8,  85 },
    { 480,  360, 8,  100 },
    { 480,  360, 8,  120 },
    { 512,  384, 8,  60 },
    { 512,  384, 8,  70 },
    { 512,  384, 8,  72 },
    { 512,  384, 8,  75 },
    { 512,  384, 8,  85 },
    { 512,  384, 8,  100 },
    { 640,  400, 8,  60 },
    { 640,  400, 8,  70 },
    { 640,  400, 8,  72 },
    { 640,  400, 8,  75 },
    { 640,  400, 8,  85 },
    { 640,  400, 8,  100 },
    { 640,  400, 8,  120 },
    { 320,  200, 16, 60 },
    { 320,  200, 16, 70 },
    { 320,  200, 16, 72 },
    { 320,  200, 16, 75 },
    { 320,  200, 16, 85 },
    { 320,  200, 16, 100 },
    { 320,  200, 16, 120 },
    { 320,  240, 16, 60 },
    { 320,  240, 16, 70 },
    { 320,  240, 16, 72 },
    { 320,  240, 16, 75 },
    { 320,  240, 16, 85 },
    { 320,  240, 16, 100 },
    { 320,  240, 16, 120 },
    { 400,  300, 16, 60 },
    { 400,  300, 16, 70 },
    { 400,  300, 16, 72 },
    { 400,  300, 16, 75 },
    { 400,  300, 16, 85 },
    { 400,  300, 16, 100 },
    { 400,  300, 16, 120 },
    { 480,  360, 16, 60 },
    { 480,  360, 16, 70 },
    { 480,  360, 16, 72 },
    { 480,  360, 16, 75 },
    { 480,  360, 16, 85 },
    { 480,  360, 16, 100 },
    { 480,  360, 16, 120 },
    { 512,  384, 16, 60 },
    { 512,  384, 16, 70 },
    { 512,  384, 16, 72 },
    { 512,  384, 16, 75 },
    { 512,  384, 16, 85 },
    { 512,  384, 16, 100 },
    { 640,  400, 16, 60 },
    { 640,  400, 16, 70 },
    { 640,  400, 16, 72 },
    { 640,  400, 16, 75 },
    { 640,  400, 16, 85 },
    { 640,  400, 16, 100 },
    { 640,  400, 16, 120 },
    { 320,  200, 32, 60 },
    { 320,  200, 32, 70 },
    { 320,  200, 32, 72 },
    { 320,  200, 32, 75 },
    { 320,  200, 32, 85 },
    { 320,  200, 32, 100 },
    { 320,  200, 32, 120 },
    { 320,  240, 32, 60 },
    { 320,  240, 32, 70 },
    { 320,  240, 32, 72 },
    { 320,  240, 32, 75 },
    { 320,  240, 32, 85 },
    { 320,  240, 32, 100 },
    { 320,  240, 32, 120 },
    { 400,  300, 32, 60 },
    { 400,  300, 32, 70 },
    { 400,  300, 32, 72 },
    { 400,  300, 32, 75 },
    { 400,  300, 32, 85 },
    { 400,  300, 32, 100 },
    { 400,  300, 32, 120 },
    { 480,  360, 32, 60 },
    { 480,  360, 32, 70 },
    { 480,  360, 32, 72 },
    { 480,  360, 32, 75 },
    { 480,  360, 32, 85 },
    { 480,  360, 32, 100 },
    { 480,  360, 32, 120 },
    { 512,  384, 32, 60 },
    { 512,  384, 32, 70 },
    { 512,  384, 32, 72 },
    { 512,  384, 32, 75 },
    { 512,  384, 32, 85 },
    { 512,  384, 32, 100 },
    { 640,  400, 32, 60 },
    { 640,  400, 32, 70 },
    { 640,  400, 32, 72 },
    { 640,  400, 32, 75 },
    { 640,  400, 32, 85 },
    { 640,  400, 32, 100 },
    { 640,  400, 32, 120 },
    { 960,  720, 8,  60 },
    { 960,  720, 8,  70 },
    { 960,  720, 8,  72 },
    { 960,  720, 8,  75 },
    { 960,  720, 8,  85 },
    { 960,  720, 8,  100 },
    { 960,  720, 8,  120 },
    { 960,  720, 8,  140 },
    { 960,  720, 8,  144 },
    { 960,  720, 8,  150 },
    { 960,  720, 8,  170 },
    { 960,  720, 8,  200 },
    { 960,  720, 8,  240 },
    { 960,  720, 16, 60 },
    { 960,  720, 16, 70 },
    { 960,  720, 16, 72 },
    { 960,  720, 16, 75 },
    { 960,  720, 16, 85 },
    { 960,  720, 16, 100 },
    { 960,  720, 16, 120 },
    { 960,  720, 16, 140 },
    { 960,  720, 16, 144 },
    { 960,  720, 16, 150 },
    { 960,  720, 16, 170 },
    { 960,  720, 16, 200 },
    { 960,  720, 16, 240 },
    { 960,  720, 32, 60 },
    { 960,  720, 32, 70 },
    { 960,  720, 32, 72 },
    { 960,  720, 32, 75 },
    { 960,  720, 32, 85 },
    { 960,  720, 32, 100 },
    { 960,  720, 32, 120 },
    { 960,  720, 32, 140 },
    { 960,  720, 32, 144 },
    { 960,  720, 32, 150 },
    { 960,  720, 32, 170 },
    { 960,  720, 32, 200 },
    { 960,  720, 32, 240 },
    { 0,    0,   0,  0  },
};

#define USE_60HZ                        0x00
#define USE_REFRESH_RATES_FROM_LOWER    0x01
#define USE_REFRESH_RATES_FROM_STRING   0x02

extern int CFUNC GetSafeModeList (LPMODEENTRY lpModeList);


/*
    GetMasterModeList

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpDispData)
{
    ULONG       i, j, pd, dwIndex, dwXRes, dwYRes;
    ULONG       hModeBppKey, hModeResKey, dwSize, dwMatchIndex;
    ULONG       dwSubKey, dwValue;
    ULONG       dwMajorKey;
    ULONG       dwValueNameSize;
    LPCHAR      lpC;
    int         nMode, nFlagRR;
    char        szValueName[MAX_KEY_LEN];
    char        szRegPath[MAX_KEY_LEN];
    char        szPDPath[MAX_KEY_LEN];
    char        szRes[MAX_KEY_LEN];
    char        szResPath[MAX_KEY_LEN];
    char        szRefreshRate[MAX_KEY_LEN];
    long        lRet;
    LPMODEENTRY lpML;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterModeList.");

    // Next, grab the mode list from the registry
    if  (!(lpML = (LPMODEENTRY) MemoryAlloc ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY))))
    {
        DBG_PRINT0(DL_0, "\r\nAllocation of Registry Mode List Failed.");
        DBG_PRINT0(DL_0, "\r\nSetting up a default safe mode list.");
        lpML = SafeModeList;
    }

    // Zero out the memory
    lpC = (LPCHAR) lpML;
    for (i = 0; i < ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY)); i++)
        lpC[i] = 0;

    // Use the safe mode list settings initially
    GetSafeModeList(lpML);

    // Try to get the path in the registry to where the mode list is.
    if  (GetLocalPath (lpDispData, szRegPath) < 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nGetLocalRegistryPath failed. Returning safe mode list.");
        return  (lpML);
    }

    // Tack on "\\MODES" to the returned regpath
    dwMajorKey = * ((ULONG *) szRegPath);
    lstrcat (szRegPath + 4, "\\Modes");

    // Start off with the first mode
    nMode = 0;

    // Create a loop so we can extract the modes for each pixel depth
    for (pd = 0; pd < 4; pd++)
    {
        // Copy the path to ...DISPLAY\000X\MODES and then tack on
        // the correct pixel depth key
        lstrcpy (szPDPath, szRegPath + 4);

        switch  (pd)
        {
            case 0:
                lstrcat (szPDPath, "\\8");
                break;
            case 1:
                lstrcat (szPDPath, "\\16");
                break;
            case 2:
                lstrcat (szPDPath, "\\24");
                break;
            case 3:
                lstrcat (szPDPath, "\\32");
                break;
        }

        // We now have the key where the pixel depth specific modes are.
        // Go ahead and open the key.
        lRet = RegOpenKey (dwMajorKey, szPDPath, &hModeBppKey);

        if  (lRet != ERROR_SUCCESS)
        {
            // If we have trouble opening a Bpp key, that is OK, since
            // we might not support a particular pixel depth. Just go
            // on to the next one.
            continue;
        }

        // Enumerate the subkeys -- each key is a spatial resolution.
        // Within each key there is a "(default)" string which has a
        // list of refresh rates which looks like: "60,72,75,85"
        // If the key does not have a list of refresh rates, then
        // look at the same resolution in the next lower pixel depth
        // and use that its refresh rates. Finally, if there is no
        // lower color depth, then assume just a 60Hz refresh rate.
        for (dwSubKey = 0; TRUE; dwSubKey++)
        {
            lRet = RegEnumKey (hModeBppKey, dwSubKey, szRes, MAX_KEY_LEN);

            if  (lRet != ERROR_SUCCESS)
            {
                // If there was an error, it probably means that there are
                // no more subkeys -- i.e. resolutions for this pixel
                // depth. That's fine. Break out of the loop.
                break;
            }

            // Get the xres and yres from the key string.
            dwIndex = 0;
            ParseDecimalSeparator (szRes, &dwIndex, &dwXRes, ',', ',');
            ParseDecimalSeparator (szRes, &dwIndex, &dwYRes, 0, 0);

            // Build a full path to the resolution key so we can open it
            lstrcpy (szResPath, szPDPath);
            lstrcat (szResPath, "\\");
            lstrcat (szResPath, szRes);

            // OK, now open the spatial resolution key so that we can
            // get the list of refresh rates for this resolution.
            lRet = RegOpenKey (dwMajorKey, szResPath, &hModeResKey);

            if  (lRet == ERROR_SUCCESS)
            {
                // The refresh rate string which looks like "60,72,75"
                // or some such thing, does not have a tag name associated
                // with it, so I cannot just query a value -- there is no
                // name to query the value of!  Must enumerate the values.
                for (dwValue = 0; TRUE; dwValue++)
                {
                    dwValueNameSize = MAX_KEY_LEN;
                    dwSize = MAX_KEY_LEN;
                    lRet = RegEnumValue (hModeResKey, dwValue, szValueName,
                                        &dwValueNameSize, NULL, NULL,
                                        szRefreshRate, &dwSize);


                    if  (lRet == ERROR_SUCCESS)
                    {
                        // We got back a key. Technically we should
                        // check to see if this is a valid refresh rate
                        // string, but we won't. We do a quick check
                        // here to see if the value name is NULL --
                        // that is the way MSoft stores it for some
                        // reason. The actual refresh rate string
                        // values will get pseudo-validated later in
                        // this routine.
                        if  ((dwValueNameSize == 0) &&
                             (szRefreshRate[0] != 0))
                        {
                            // Close the resolution key
                            RegCloseKey (hModeResKey);

                            nFlagRR = USE_REFRESH_RATES_FROM_STRING;
                            break;
                        }
                    }
                    else
                    {
                        // If we got an error, it is porbbaly because
                        // there are no more values to enumerate in the
                        // key. Unfortunately we didn't find a refresh
                        // rate string, so just close the key. The logic
                        // in the next section handles the error.
                        RegCloseKey (hModeResKey);
                        break;
                    }
                }
            }

            if  (lRet != ERROR_SUCCESS)
            {
                // Here's the thing. If either opening the resolution key
                // to query the refresh rate string, OR if the query of
                // the refresh rate string failed, we still have to come
                // up with a list of refresh rates somehow,
                // so check if we are looking for 8bpp modes.
                if  (pd == 0)
                {
                    // In 8bpp, there is no lower pixel depth so we
                    // have to assume a single value of 60Hz
                    nFlagRR = USE_60HZ;
                }
                else
                {
                    // We can make a good guess as to the refresh
                    // rates by using the ones for the same
                    // resolution mode in a lower pixel depth,
                    // if a lower pixel depth has the same
                    // resolution mode. IF not, use 60Hz.
                    nFlagRR = USE_REFRESH_RATES_FROM_LOWER;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_STRING)
            {
                dwIndex = 0;

                // Generate a new mode for each refresh rate in the string
                while   (ParseDecimalSeparator (szRefreshRate,
                            &dwIndex, &(lpML[nMode].dwRefreshRate),
                            ',', 0))
                {
                    lpML[nMode].dwXRes = dwXRes;
                    lpML[nMode].dwYRes = dwYRes;
                    lpML[nMode].dwBpp  = (pd + 1) * 8;
                    if  (nMode < MAX_MODEENTRYS)
                        nMode++;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_LOWER)
            {
                dwMatchIndex = FALSE;

                // Start with the pixel depth immediately below, but
                // if no matching res is found at that one, keep going.
                for (j = pd - 1; (((long) j) >= 0) && (!dwMatchIndex); j--)
                {
                    // Search through all modes already added to the table
                    for (i = 0; i < (ULONG) nMode; i++)
                    {
                        // Matching xres, yres, and prior pixel depth
                        // is a hit!
                        if  ((dwXRes == lpML[i].dwXRes) &&
                             (dwYRes == lpML[i].dwYRes) &&
                             (((j + 1) * 8) == lpML[i].dwBpp))
                        {
                            // Grab the prior mode, and modify the bpp
                            lpML[nMode] = lpML[i];
                            lpML[nMode].dwBpp = (pd + 1) * 8;
                            if  (nMode < MAX_MODEENTRYS)
                                nMode++;
                            dwMatchIndex = TRUE;
                        }
                    }
                }

                if  (!dwMatchIndex)
                {
                    // If there wasn't a lower pixel depth with a
                    // matching resolution, then do a single 60Hz mode.
                    nFlagRR = USE_60HZ;
                }
            }

            if  (nFlagRR == USE_60HZ)
            {
                lpML[nMode].dwXRes = dwXRes;
                lpML[nMode].dwYRes = dwYRes;
                lpML[nMode].dwBpp  = (pd + 1) * 8;
                lpML[nMode].dwRefreshRate = 60;
                if  (nMode < MAX_MODEENTRYS)
                    nMode++;
            }
        }

        // Close this bpp key
        RegCloseKey (hModeBppKey);
    }

    // Only one thing. If we didn't find any modes, then use a safe list
    if  (nMode == 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nNo modes found. Returning safe mode list.");
        return  (lpML);
    }

    // Add all the non-desktop, low resolution modes.
    for (i = 0; sLowModes[i].dwXRes != 0; i++)
    {
        lpML[nMode] = sLowModes[i];
        if  (nMode < MAX_MODEENTRYS)
            nMode++;
    }

    return  (lpML);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    if  (lpModeList != SafeModeList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on lpModeList.");
        MemoryFree ((LPULONG) lpModeList);
    }

    return  (TRUE);
}


/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    int     i;

    for (i = 0; SafeModeList[i].dwXRes != 1; i++)
        lpModeList[i] = SafeModeList[i];

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\REGFUNCS.C ===
 /*
    FILE:   regfuncs.c
    DATE:   4/8/99

    This file holds code to get certain things from the registry.
*/

#include "cmntypes.h"
#include "mywin.h"
#include "modeext.h"
#include "modeset.h"
#include "regfuncs.h"
#include "..\..\common\inc\nvreg.h"
#include "utils.h"
#include "debug.h"

extern  DEVICEANDTYPE   DeviceTypes[8];

/*
    GetLocalPath

    Purpose:    This routine extracts the local registry path
                from the lpRegData structure.

    Arguments:  lpRegData   LPREGDATA
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to ....\Display\000X

                Always returns TRUE.
*/
int CFUNC
GetLocalPath (LPREGDATA lpRegData, LPCHAR lpBuffer)
{
    lstrcpy (lpBuffer, lpRegData->szRegPath);
    return  (TRUE);
}


/*
    GetLocalNvidiaPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia substring.

    Arguments:  lpRegData   LPREGDATA
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to ....\Display\000X\Nvidia

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaPath (LPREGDATA lpRegData, LPCHAR lpBuffer)
{
    // Get the local path
    GetLocalPath (lpRegData, lpBuffer);

    // Tack on Nvidia.
    lstrcat (lpBuffer, "\\NVidia");
    return  (TRUE);
}


/*
    GetLocalNvidiaDisplayPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia\Display string.

    Arguments:  lpRegData   LPREGDATA
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to ....\Display\000X\Nvidia\Display

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaDisplayPath (LPREGDATA lpRegData, LPCHAR lpBuffer)
{
    // Get the local path
    GetLocalNvidiaPath (lpRegData, lpBuffer);

    // Tack on "Display"
    lstrcat (lpBuffer, "\\");
    lstrcat (lpBuffer, NV4_REG_DISPLAY_DRIVER_SUBKEY);
    return  (TRUE);
}


/*
    GetLocalNvidiaDisplayLogPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia\Display\LogDevice? string.

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to
                ....\Display\000X\Nvidia\Display\LogicalDevice?

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaDisplayLogPath (LPREGDATA lpRegData, ULONG dwLogDevice,
                                LPCHAR lpBuffer)
{
    char    szTemp[32];

    // Get the local path
    GetLocalNvidiaDisplayPath (lpRegData, lpBuffer);

    // Tack on LogicalDevice? where ? is the logical device number
    wsprintf (szTemp, "\\LogicalDevice%ld", dwLogDevice);
    lstrcat (lpBuffer, szTemp);
    return  (TRUE);
}


/*
    GetLocalNvidiaDisplayDevPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia\Display\%DEV#% string.

    Arguments:  lpRegData    LPREGDATA
                dwLogDevice  0 based logical device number
                lpDevData    LPDEVDATA
                lpBuffer     Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to
                ..\Display\000X\Nvidia\Display\%DEV#%

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaDisplayDevPath (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                    LPCHAR lpBuffer)
{
    char    szTemp[12];

    // Get the local path
    GetLocalNvidiaDisplayPath (lpRegData, lpBuffer);

    // Tack on PhysicalDevice? where ? is the physical device number
    wsprintf (szTemp, "\\%s%d", DeviceTypes[lpDevData->cType].lpszName,
                                lpDevData->cNumber);
    lstrcat (lpBuffer, szTemp);
    return  (TRUE);
}


/*
    GetLocalSubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X

    Arguments:  lpRegData   LPREGDATA

    Returns:    The registry key to ....\Display\000X
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalSubKey (LPREGDATA lpRegData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalPath (lpRegData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaSubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X\Nvidia.

    Arguments:  lpRegData   LPREGDATA

    Returns:    The registry key to ....\Display\000X\Nvidia.
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaSubKey (LPREGDATA lpRegData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalNvidiaPath (lpRegData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaDisplaySubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X\Nvidia\Display.

    Arguments:  lpRegData   LPREGDATA

    Returns:    The registry key to ....\Display\000X\Nvidia\Display
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaDisplaySubKey (LPREGDATA lpRegData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia/Display
    GetLocalNvidiaDisplayPath (lpRegData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaDisplayLogSubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number

    Returns:    The registry key to
                ..\Display\000X\Nvidia\Display\LogicalDevice?
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaDisplayLogSubKey (LPREGDATA lpRegData, ULONG dwLogDevice)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalNvidiaDisplayLogPath (lpRegData, dwLogDevice, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaDisplayDevSubKey

    Purpose:    This routine gets the local subkey which is
                ..Display\000X\Nvidia\Display\LogicalDevice?\PhysicalDevice?

    Arguments:  lpRegData    LPREGDATA
                lpDevData    LPDEVDATA

    Returns:    The registry key to
                ..\Display\000X\Nvidia\Display\LogicalDevice?
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaDisplayDevSubKey (LPREGDATA lpRegData, LPDEVDATA lpDevData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalNvidiaDisplayDevPath (lpRegData, lpDevData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetRegValue

    Purpose:    This routine reads a decimal value from the key passed in

    Arguments:  hKey        key which holds value to read
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The registry key and entry are read.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetRegValue (ULONG hKey, LPCHAR lpStr, int nDefault)
{
    ULONG   dwNum, dwSize;
    long    lRet;

    // Query the value from the lpStr entry
    dwNum = 0;
    dwSize = 4;
    lRet = RegQueryValueEx (hKey, lpStr, NULL, NULL, (LPCHAR) &dwNum, &dwSize);

    // CLose the key
    RegCloseKey (hKey);

    // If there was an error or no such key, then use the default value
    if  ((lRet != ERROR_SUCCESS) || (dwSize == 0))
        dwNum = (ULONG) nDefault;

    return  ((int) dwNum);
}


/*
    GetLocalRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is ....Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetLocalRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is ....Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/

int CFUNC
GetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaDisplayRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is ....Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia\Display key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/

int CFUNC
GetLocalNvidiaDisplayRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaDisplayLogRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia\Display\LogicalDevice? key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetLocalNvidiaDisplayLogRegValue (LPREGDATA lpRegData, ULONG dwLogDevice,
                                    LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaDisplayDevRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\LogicalDevice?\PhysDevice?

    Arguments:  lpRegData    LPREGDATA
                lpDevData    LPDEVDATA
                lpStr        string pointing to value name
                nDefault     value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia\Display\%DEV#% key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetLocalNvidiaDisplayDevRegValue (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                    LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetRegString

    This routine reads a string value from the ...\DISPLAY\000X key.
    If the value specified by the lpStr string does not exist or there
    is any error in reading the registry, then FALSE is returned. Otherwise,
    TRUE is returned and lpRet gets set to the string read from the registry.
*/
int CFUNC
GetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   dwSize, lRet;

    // Query the value from the lpStr entry
    dwSize = MAX_KEY_LEN;
    lRet = RegQueryValueEx (hKey, lpStr, NULL, NULL, lpRet, &dwSize);

    // Close the key
    RegCloseKey (hKey);

    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (TRUE);
}


/*
    GetLocalRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/

int CFUNC
GetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaDisplayRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaDisplayLogRegString

    Purpose:    This routine reads a string value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number
                lpStr       string pointing to entry name
                lpRet       place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice,
                                    LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaDisplayDevRegString

    Purpose:    This routine reads a string value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\%DEV#%

    Arguments:  lpRegData   LPREGDATA
                lpDevData   LPDEVDATA
                lpStr       string pointing to entry name
                lpRet       place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                    LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    DeleteRegEntry

    Purpose:    This routine deletes an entry from a registry key.

    Arguments:  hKey    Key containgin element to delete
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteRegEntry (ULONG hKey, LPCHAR lpStr)
{
    // Delete the value
    RegDeleteValue (hKey, lpStr);

    // CLose the key
    RegCloseKey (hKey);

    return  (TRUE);
}


/*
    DeleteLocalRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalRegEntry (LPREGDATA lpRegData, LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    DeleteLocalNvidiaRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaRegEntry (LPREGDATA lpRegData, LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}



/*
    DeleteLocalNvidiaDisplayRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaDisplayRegEntry (LPREGDATA lpRegData, LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    DeleteLocalNvidiaDisplayLogRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based Logical device number
                lpStr       string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaDisplayLogRegEntry (LPREGDATA lpRegData, ULONG dwLogDevice,
                                        LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    DeleteLocalNvidiaDisplayDevRegEntry

    Purpose:    This routine deletes an entry from the registry
                path
                ..Display\000X\Nvidia\Display\LogicalDevice?\PhysicalDevice?

    Arguments:  lpRegData   LPREGDATA
                lpDevData   LPDEVDATA
                lpStr       string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaDisplayDevRegEntry (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                        LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    SetRegString

    Purpose:    This routine writes an entry into the registry
                path passed in.

    Arguments:  hKey    key to write to
                lpStr   string pointing to entry name to set
                lpData  "string value" of entry
                dwDataLen  length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    long    lRet;

    // Write the value from the lpStr entry
    lRet = RegSetValueEx (hKey, lpStr, NULL, REG_SZ, lpData, dwDataLen);

    // Close the key
    RegCloseKey (hKey);

    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (TRUE);
}


/*
    SetRegValue

    Purpose:    This routine writes an entry into the registry
                path passed in.

    Arguments:  hKey    key to write to
                lpStr   string pointing to entry name to set
                lpData  "string value" of entry
                dwDataLen  length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetRegValue (ULONG hKey, LPCHAR lpStr, int nVal)
{
    long    lRet;
    ULONG   ulVal;

    ulVal = (ULONG) nVal;
    // Write the value from the lpStr entry
    lRet = RegSetValueEx (hKey, lpStr, NULL, REG_DWORD, (LPCHAR) &ulVal, sizeof (ulVal));

    // Close the key
    RegCloseKey (hKey);

    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (TRUE);
}


/*
    SetLocalRegString

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to set
                lpData  "string value" of entry
                dwDataLen  length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaRegString

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaRegValue

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nVal)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegValue (hDisplay, lpStr, nVal));
}


/*
    SetLocalNvidiaDisplayRegString

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaDisplayLogRegString

    Purpose:    This routine writes an entry into the registry
                path
                ..\Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData    LPREGDATA
                dwLogDevice  0 based logical device number
                lpStr        string pointing to entry name to set
                lpData       "string value" of entry
                dwDataLen    length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice,
                            LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaDisplayDevRegString

    Purpose:    This routine writes an entry into the registry
                path
                ..\Display\000X\Nvidia\Display\LogicalDevice?\PhyscialDevice?

    Arguments:  lpRegData   LPREGDATA
                lpDevData   LPDEVDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                            LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    GetMonitorLocalSubKey

    Purpose:    This routine gets the key for the local monitor
                path which looks like ....\Monitor\000X

    Arguments:  lpRegData   LPREGDATA

    Returns:    The key to the ....\Monitor\000X registry path
                0 is returned if there is an error
*/
ULONG CFUNC
GetMonitorLocalSubKey (LPREGDATA lpRegData)
{
    ULONG   hMonitor, lRet;

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, lpRegData->szRegPath, &hMonitor);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hMonitor);
}


/*
    GetMonitorLocalRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Monitor\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
ULONG CFUNC
GetMonitorLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData)
{
    ULONG   hMonitor;

    if  (!(hMonitor = GetMonitorLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hMonitor, lpStr, lpData));
}


/*
    PrintString0

    This routine prints a debug string.
*/
int CFUNC
PrintString0 (LPCHAR lpStr)
{
    OutputDebugString (lpStr);
    return  (TRUE);
}

/*
    PrintString1

    This routine prints a debug string with 1 argument.
*/
int CFUNC
PrintString1 (LPCHAR lpStr, ULONG dwValue)
{
    wsprintf (szDebug, lpStr, dwValue);
    OutputDebugString (szDebug);
    return  (TRUE);
}


/*
    MemoryAlloc

    This routine allocates the amount of memory requested and
    returns a ptr to the memory block.
*/
LPCHAR CFUNC
MemoryAlloc (ULONG dwSize)
{
    int     hMem;
    LPCHAR  lpMem;

    hMem = (int) GlobalAlloc (GMEM_SHARED, dwSize);

    if  (hMem)
    {
        lpMem = GlobalLock (hMem);

        if  (lpMem)
            return  (lpMem);
    }

    return  (FALSE);
}


/*
    MemoryFree

    This routine frees the memory block.
*/
int CFUNC
MemoryFree (LPULONG lpMem)
{
    int hMem;

    if  (lpMem)
    {
        hMem = (int) GlobalHandle ((USHORT) (((ULONG) lpMem) >> 16));

        if  (hMem)
        {
            GlobalUnlock (hMem);
            GlobalFree (hMem);
        }
    }

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\OSMODE.C ===
/*
    FILE:   osmode.c
    DATE:   4/8/99

    This file has os-specific entry points for the modeset DLLs.
*/

#include "cmntypes.h"
#include "mywin.h"
#include "debug.h"

// 16bit Windows DLLs screw up if there is not at least one piece of
// data in the data segment. This is just to make sure there is one.
int     dummy;


/*
    DllEntryPoint

    Purpose:    This function is called by the OS when the 16bit Dll
                loads. We don't need to do anything in this routine
                right now. It is just a stub function.

    Arguments:  OS defined arguments.
                dwReason    -
                hInstance   - The module handle
                wDS         - Data segment for this module
                wHeapSize   - Size specified in the .def file for the heap
                dwReserved1 - not used
                wReserved2  - not used

    Returns:    Always return TRUE
*/
int WINAPI __export DllEntryPoint
(
    ULONG   dwReason,
    USHORT  hInstance,
    USHORT  wDS,
    USHORT  wHeapSize,
    ULONG   dwReserved1,
    USHORT  wReserved2
)
{
    DBG_PRINT0(DL_0, "\r\nDllEntryPoint for 16bit ModeSet DLL called -- Dll Loaded.");
    return  (TRUE);
}


/*
    WEP

    Purpose:    This function is called by the OS when the 16bit Dll
                unloads. We don't need to do anything in this routine
                right now. It is just a stub function.

    Arguments:  OS defined arguments.
                nExitType   - why the Dll is unloading

    Returns:    Always return TRUE
*/
int WINAPI WEP(int nExitType)
{
    DBG_PRINT0(DL_0, "\r\nWEP for 16bit ModeSet DLL called -- Dll Unloaded.");
	return	(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\MYWIN.H ===
/*
    FILE:   mywin.h
    DATE:   4/8/99

    This file has some things in it that are in windows.h, but I
    don't want to include windows.h because it just makes a mess.
*/

// A few constants
#define TRUE    1
#define FALSE   0
#define NULL    0

// These are constants for the registry functions
#define MAX_KEY_LEN             0x200
#define HKEY_CLASSES_ROOT       0x80000000
#define HKEY_CURRENT_USER       0x80000001
#define HKEY_LOCAL_MACHINE      0x80000002
#define HKEY_USERS              0x80000003
#define HKEY_PERFORMANCE_DATA   0x80000004
#define HKEY_CURRENT_CONFIG     0x80000005
#define HKEY_DYN_DATA           0x80000006
#define ERROR_SUCCESS           0x00

// This is for memory allocation
#define GMEM_SHARED 0x2000

// A few more constants
#define DLL_PROCESS_DETACH 0
#define DLL_PROCESS_ATTACH 1
#define DLL_THREAD_ATTACH  2
#define DLL_THREAD_DETACH  3

// Handle the WIN16, WIN32 difference as seemlessly as possible.
#ifdef  _WIN32
#define FAR
#define CFUNC   __cdecl
#define WINAPI  _stdcall
#else
#define FAR     __far
#define CFUNC   __cdecl  _loadds
#define WINAPI  _far _pascal  _loadds
#endif

// A few basic types
typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef UCHAR  FAR *    LPCHAR;
typedef USHORT FAR *    LPUSHORT;
typedef ULONG  FAR *    LPULONG;

// A few Windows functions that we need.
#ifdef _WIN32
#define RegOpenKey      RegOpenKeyA
#define RegEnumKey      RegEnumKeyA
#define RegEnumValue    RegEnumValueA
#define RegDeleteValue  RegDeleteValueA
#define RegQueryValueEx RegQueryValueExA
#define RegSetValueEx   RegSetValueExA
#define RegCreateKey    RegCreateKeyA
#define wsprintf  wsprintfA
#define OutputDebugString OutputDebugStringA
extern int    CFUNC  wsprintf(LPSTR, LPCSTR, ...);
#else
extern int    CFUNC  wsprintf();
#endif

#define REG_NONE        0x000000000
#define REG_SZ          0x000000001
#define REG_EXPAND_SZ   0x000000002
#define REG_BINARY      0x000000003
#define REG_DWORD       0x000000004

extern int    WINAPI GlobalAlloc (int nflags, ULONG dwSize);
extern void   WINAPI GlobalUnlock (int hMem);
extern void   WINAPI GlobalFree (int hMem);
extern int    WINAPI GlobalHandle (USHORT wSelector);
extern LPCHAR WINAPI GlobalLock (int hMem);
extern void   WINAPI OutputDebugString(LPCHAR lpStr);
extern long   WINAPI RegOpenKey   (ULONG hKey, LPCHAR lpName, LPULONG lphKey);
extern long   WINAPI RegCreateKey (ULONG hKey, LPCHAR lpName, LPULONG lphKey);
extern long   WINAPI RegCloseKey (ULONG hEnumCMEnumKey);
extern long   WINAPI RegEnumKey (ULONG hEnumCMEnumKey, ULONG dwSubKey,
                                LPCHAR szItem, ULONG dwLen);
extern long   WINAPI RegEnumValue (ULONG hEnumCMEnumKey, ULONG dwValueIndex,
                                LPCHAR lpValueName, LPULONG dwValueNameSize,
                                LPULONG lpReserved, LPULONG lpType,
                                LPCHAR lpData, LPULONG lpDataSize);
extern long   WINAPI RegQueryValueEx (ULONG hKey, LPCHAR lpValue,
                                LPULONG lpRes, LPULONG lpType,
                                LPCHAR lpBuf,  LPULONG lpSize);
extern long   WINAPI RegSetValueEx (ULONG hKey, LPCHAR lpValue,
                                LPULONG lpRes, ULONG dwType,
                                LPCHAR lpBuf,  ULONG dwSize);
extern long   WINAPI RegDeleteValue (ULONG hKey, LPCHAR lpValue);
extern LPCHAR WINAPI lstrcat (LPCHAR lpDst, LPCHAR lpSrc);
extern LPCHAR WINAPI lstrcpy (LPCHAR lpDst, LPCHAR lpSrc);
extern ULONG  WINAPI lstrlen (LPCHAR lpDst);
extern ULONG  WINAPI lstrcmpi (LPCHAR lpDst, LPCHAR lpSrc);

// A little bit of debugging support.
#ifdef DEBUG
extern  char szTemp[512];
#define DBG_PRINTF(x)       OutputDebugString((LPCHAR) (x))
#define DBG_PRINT_1DEC(x,y) {   wsprintf (szTemp, (x), (y));   \
                                OutputDebugString (szTemp);    \
                            }
#else
#define DBG_PRINTF(x)
#define DBG_PRINT_1DEC(x,y)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\panel.c ===
/*
    FILE:   panel.c
    DATE:   5/3/00

    This file holds code to support the control panel by writing
    the registry for the given board.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "..\..\common\inc\nvreg.h"
#include "..\..\common\win9x\inc\escape.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "..\code\edid.h"
#include "..\code\gtfmath.h"
#include "..\code\dmt.h"

typedef struct  _DESKTOP_STATE_DATA
{
    char    szName[8];
    int     nID;
}   DESKTOP_STATE_DATA;

DESKTOP_STATE_DATA  DesktopStateData[] =
{
    { NV4_REG_DRV_DESKTOP_STATE_NORMAL,     NVTWINVIEW_STATE_NORMAL },
    { NV4_REG_DRV_DESKTOP_STATE_MULTI_MON,  NVTWINVIEW_STATE_MULTIMON },
    { NV4_REG_DRV_DESKTOP_STATE_CLONE,      NVTWINVIEW_STATE_CLONE },
    { "\0",                                 NVTWINVIEW_STATE_NORMAL }
};


/*
    Function:   SetVirtualDesktop

    Purpose:    This routine writes the registry key VirtualDesktop
                with a "1" if dwState is non-zero or deletes the key
                if dwState = 0.

    Arguments:  lpRegData   - identifies the specific board
                dwLogDevice - 0 based logical device number
                dwState     - If 1 -> enable the key
                              if 0 -> delete it

    Returns:    Always returns TRUE
*/
int WINAPI
SetVirtualDesktop (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG dwState)
{
    DBG_PRINT0 (DL_0, "\r\nEntering SetVirtualDesktop.");

    if  (dwState)
        SetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice,
                    NV4_REG_DRV_VIRTUALDESKTOP, NV4_REG_DRV_TRUE, 1);
    else
        DeleteLocalNvidiaDisplayLogRegEntry (lpRegData, dwLogDevice,
                    NV4_REG_DRV_VIRTUALDESKTOP);

    DBG_PRINT0 (DL_1, "\r\nExiting SetVirtualDesktop.");
    return  (TRUE);
}


/*
    Function:   GetVirtualDesktop

    Purpose:    This routine reads the registry key VirtualDesktop

    Arguments:  lpRegData   - identifies the specific board
                dwLogDevice - 0 based logical device number
                lpState     - pointer to variable for return value

    Returns:    Always returns TRUE
*/
int WINAPI
GetVirtualDesktop (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG *lpState)
{
    DBG_PRINT0 (DL_0, "\r\nEntering GetVirtualDesktop.");

    lpState[0] = 0;
    GetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice,
                        NV4_REG_DRV_VIRTUALDESKTOP, (LPCHAR) lpState);
    if  (lpState[0] == '1')
        *lpState = 1;
    else
        *lpState = 0;

    DBG_PRINT0 (DL_1, "\r\nExiting GetVirtualDesktop.");
    return  (TRUE);
}


/*
    Function:   SetDesktopState

    Purpose:    This routine writes the registry key DesktopState with
                the desired desktop state.

    Arguments:  lpRegData   - identifies the specific board
                dwState     -  0 -> NVTWINVIEW_STATE_NORMAL
                               1 -> NVTWINVIEW_STATE_MULTIMON
                               2 -> NVTWINVIEW_STATE_CLONE

    Returns:    Always returns TRUE
*/
int WINAPI
SetDesktopState (LPREGDATA lpRegData, ULONG dwState)
{
    DBG_PRINT0 (DL_0, "\r\nEntering SetDesktopState.");

    if  (dwState > NVTWINVIEW_STATE_CLONE)
        dwState = NVTWINVIEW_STATE_NORMAL;

    SetLocalNvidiaRegValue (lpRegData, NV4_REG_DRV_DESKTOPSTATE, (int) dwState);

    DBG_PRINT0 (DL_1, "\r\nExiting SetDesktopState.");
    return  (TRUE);
}


/*
    Function:   GetDesktopState

    Purpose:    This routine reads the registry key DesktopState

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpState     - pointer to variable for return value

    Returns:    Always returns TRUE
*/
int WINAPI
GetDesktopState (LPREGDATA lpRegData, ULONG *lpState)
{

    DBG_PRINT0 (DL_0, "\r\nEntering GetDesktopState.");

    *lpState = GetLocalNvidiaRegValue (lpRegData, NV4_REG_DRV_DESKTOPSTATE, 0);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDesktopState.");
    return  (TRUE);
}


/*
    Function:   SetAutoPanMode

    Purpose:    This routine writes the registry key AutoPanMode
                with the coordinates of the Top Left corner of the display
                if dwState = 1 (disable auto-panning: freeze origin)
                or deletes the key if dwState = 0 (enable auto-panning:
                unfreeze origin).

    Arguments:  lpRegData   - identifies the specific board
                dwState     - If 1 -> write the key
                              if 0 -> delete the key
                lpDevData   - LPDEVDATA
                dwLeft      - if dwState is TRUE, then the auto pan
                dwTop       - is locked at this rectangle.
                dwRight
                dwBottom

    Returns:    Always returns TRUE
*/
int WINAPI
SetAutoPanMode (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG dwLeft,
                ULONG dwTop, ULONG dwRight, ULONG dwBottom, ULONG dwState)
{
    char    szTemp[256];

    DBG_PRINT0 (DL_0, "\r\nEntering SetAutoPanMode.");

    if  (dwState)
    {
        wsprintf (szTemp, "%ld,%ld,%ld,%ld", dwLeft, dwTop, dwRight, dwBottom);
        SetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                    NV4_REG_DRV_AUTOPANMODE, szTemp, 1);
    }
    else
        DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, lpDevData,
                                            NV4_REG_DRV_AUTOPANMODE);

    DBG_PRINT0 (DL_1, "\r\nExiting SetAutoPanMode.");
    return  (TRUE);
}


/*
    Function:   GetAutoPanMode

    Purpose:    This routine reads the registry key AutoPanMode

    Arguments:  lpRegData   - identifies the specific board that we
                lpDevData   - LPDEVDATA
                lpState     - pointer to variable for return value
                lpLeft      - if the autopan key exists dwState is TRUE, then the auto pan
                lpTop       - is locked at this rectangle.
                lpRight
                lpBottom

    Returns:    Always returns TRUE
*/
int WINAPI
GetAutoPanMode (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG *lpLeft,
                ULONG *lpTop, ULONG *lpRight, ULONG *lpBottom)
{
    char    szTemp[256];
    ULONG   dwIndex;

    DBG_PRINT0 (DL_0, "\r\nEntering GetAutoPanMode.");

    szTemp[0] = 0;
    GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                        NV4_REG_DRV_AUTOPANMODE, szTemp);

    if (szTemp[0] != 0)
    {
        dwIndex = 0;
        ParseDecimalSeparator (szTemp, &dwIndex, lpLeft, ',', ',');
        ParseDecimalSeparator (szTemp, &dwIndex, lpTop, ',', ',');
        ParseDecimalSeparator (szTemp, &dwIndex, lpRight, ',', ',');
        ParseDecimalSeparator (szTemp, &dwIndex, lpBottom, 0, 0);
    }
    else
        return (FALSE);

    DBG_PRINT0 (DL_1, "\r\nExiting GetAutoPanMode.");
    return  (TRUE);
}


/*
    Function:   SetTimingOverride

    Purpose:    This routine writes the registry key MonitorTiming
                or deletes the key if dwState = 0 (AUTO).

    Arguments:  lpRegData   - identifies the specific board
                lpDevData   - LPDEVDATA
                dwState     - If 0 -> Delete the key (AUTO)
                dwState     - If 1 -> DMT
                              if 2 -> GTF

    Returns:    Always returns TRUE
*/
int WINAPI
SetTimingOverride (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG dwState)
{
    char    szTemp[256];

    DBG_PRINT0 (DL_0, "\r\nEntering SetTimingOverride.");

    if (dwState == 1)
    {
        wsprintf (szTemp, "DMT");
        SetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                NV4_REG_DRV_MONITOR_TIMING, szTemp, 1);
    }
    else if (dwState == 2)
    {
        wsprintf (szTemp, "GTF");
        SetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                NV4_REG_DRV_MONITOR_TIMING, szTemp, 1);
    }
    else
        DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, lpDevData,
                                NV4_REG_DRV_MONITOR_TIMING);

    DBG_PRINT0 (DL_1, "\r\nExiting SetTimingOverride.");
    return  (TRUE);
}


/*
    Function:   GetTimingOverride

    Purpose:    This routine reads the registry key MonitorTiming

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpDevData   - LPDEVDATA
                lpState     - pointer to variable for return value

    Returns:    Always returns TRUE
*/
int WINAPI
GetTimingOverride (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG *lpState)
{
    char    szTemp[256];

    DBG_PRINT0 (DL_0, "\r\nEntering GetTimingOverride.");

    szTemp[0] = 0;
    GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                            NV4_REG_DRV_MONITOR_TIMING, szTemp);

    if (szTemp[0] != 0)
    {
        if  (!lstrcmpi(szTemp, NV4_REG_DRV_MONITOR_TIMING_DMT))
            *lpState = 1;
        else if  (!lstrcmpi(szTemp, NV4_REG_DRV_MONITOR_TIMING_GTF))
            *lpState = 2;
        else
            *lpState = 0;
    }
    else
        return (FALSE);

    DBG_PRINT0 (DL_1, "\r\nExiting GetTimingOverride.");
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\REGFUNCS.H ===
/*
    FILE:   regfuncs.h
    DATE:   4/8/99

    This file holds code to get certain things from the registry.
*/

typedef struct  tagDEVICEANDTYPE
{
    LPCHAR  lpszName;
    char    cType;
}   DEVICEANDTYPE;

typedef DEVICEANDTYPE FAR *LPDEVICEANDTYPE;


// This routine is in getit.c
extern int CFUNC GrabModeInfoString (LPREGDATA lpRegData, ULONG dwLogDevice, LPDEVDATA lpDevData, LPCHAR lpModeString, LPMODEINFO lpMI, int nType);

// All these are in regfuncs.c
extern int CFUNC GetLocalPath (LPREGDATA lpRegData, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaPath (LPREGDATA lpRegData, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaDisplayPath (LPREGDATA lpRegData, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaDisplayLogPath (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaDisplayDevPath (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpBuffer);
extern ULONG CFUNC GetLocalSubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetLocalNvidiaSubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetLocalNvidiaDisplaySubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetLocalNvidiaDisplayLogSubKey (LPREGDATA lpRegData, ULONG dwLogDevice);
extern ULONG CFUNC GetLocalNvidiaDisplayDevSubKey (LPREGDATA lpRegData, LPDEVDATA lpDevData);
extern int CFUNC GetRegValue (ULONG hKey, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaDisplayRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaDisplayLogRegValue (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaDisplayDevRegValue (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC SetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetRegValue (ULONG hKey, LPCHAR lpStr, int nVal);
extern int CFUNC SetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nVal);
extern int CFUNC SetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int WINAPI DeleteRegEntry (ULONG hKey, LPCHAR lpStr);
extern int WINAPI DeleteLocalRegEntry (LPREGDATA lpRegData, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaRegEntry (LPREGDATA lpRegData, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaDisplayRegEntry (LPREGDATA lpRegData, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaDisplayLogRegEntry (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaDisplayDevRegEntry (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr);
extern ULONG CFUNC GetMonitorLocalSubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetMonitorLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData);
extern int CFUNC PrintString0 (LPCHAR lpStr);
extern int CFUNC PrintString1 (LPCHAR lpStr, ULONG dwValue);
extern LPCHAR CFUNC MemoryAlloc (ULONG dwSize);
extern int CFUNC MemoryFree (LPULONG lpMem);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\winnt\MODELIST.C ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to get the master mode list.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "utils.h"
//#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"

/*
    GetMasterModeList

    This routine returns a ptr to a an array of MODEENTRY
    structures which describe the list of available modes for
    the board specified. This routine needs to ALWAYS return
    some mode list. If you have to just return a list of safe
    modes like 640,480,8,60Hz.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpBoardData)
{
    // You can't return NULL -- this is just a template.
    return  (NULL);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\dload.h ===
/*****************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2001 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2001  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* Module: dload.c                                                           *|
|*    These are the OS-specific bits of implementing dynamic loading of      *|
|* driver code.  Be that from file, ROM/BIOS, etc.                           *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* History:                                                                  *|
|*       Ken Adams (kadams)     02/2001 - wrote it based upon investigatory  *|
|*                                        code from Todd Poynter.            *|
|*                                                                           *|
\*****************************************************************************/
#ifndef _DLOAD_H
#define _DLOAD_H


RM_STATUS initDload     ( PHWINFO);
RM_STATUS DldLoadModule ( PHWINFO, U008 *rawImage );


NV_UINTPTR_T DldFindMemOffset       (PDLD_MODULE, char *); 
NV_UINTPTR_T DldGetImageOffset      (PDLD_MODULE, unsigned);
NvU16        DldGetSymbolSection    (PDLD_MODULE, unsigned symIndex);
NV_UINTPTR_T DldGetSectionMemOffset (PDLD_MODULE, unsigned secNumber);
NV_UINTPTR_T DldGetMemOffset        (PDLD_MODULE, unsigned symIndex);
void         DldPrintImgInfo        (PDLD_MODULE);
void         DldPrintSectionInfo    (PDLD_MODULE);
void         DldPrintRelocationInfo (PDLD_MODULE);
void         DldPrintSymbolTableInfo(PDLD_MODULE);

RM_STATUS    DldInflate             (NvU8 *in, NvU8* out);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\aos.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* aos.h
*
* OS-independent functions implemented by the RM
*
*/


#if !defined _AUDIOOS_H_
#define _AUDIOOS_H_

#if defined __cplusplus
extern "C" {
#endif

// init calls
RM_STATUS   RmInitAudioDevice(VOID *pResList, VOID *pDevObj, PHWINFO_COMMON_FIELDS pDev);
VOID        RmShutdownAudioDevice(PHWINFO_COMMON_FIELDS pDev);


/* specifies the dont care bits from bit 12 onwards */
#define ALIGN_4K					0x00000000
#define ALIGN_8K					0x00000001		
#define ALIGN_16K					0x00000003
#define ALIGN_32K					0x00000007
#define ALIGN_64K					0x0000000F
#define ALIGN_128K					0x0000001F
#define ALIGN_DONT_CARE				0xFFFFFFFF

// exported services
RM_STATUS	aosAllocateMem(U032 uSize, U032 uAlignMask, VOID **ppLinAddr, VOID **ppPhysAddr);
VOID		aosFreeMem(VOID *pLinAddr);

RM_STATUS	aosMapLinearAddress(VOID *pPhys, U032 uSize, VOID **ppLinear);
VOID		aosUnmapLinearAddress(VOID *pLinear, U032 uSize);

RM_STATUS   aosGetPhysicalAddress(VOID *pLinAddr, U032 uSize, VOID **pPhysAddr);

VOID        aosZeroMemory(VOID *pLinAddr, U032 uSize);
VOID        aosMemCopy(VOID *pDestination, VOID *pSource, U032 uSize);

// debug print stuff
VOID        aosDbgPrintString(int iDbgLevel, char *pStr);
VOID        aosDbgBreakPoint();

// OS-independent functions for doing file i/o - used for debugging drivers without real HW
VOID *      aosCreateDiskFile();
VOID        aosWriteDiskFile(VOID *pHandle, VOID *pBuffer, U032 uSize);
VOID        aosCloseDiskFile(VOID *pHandle);


#define PAGEOFF(p)			        (((U032)(p)) & 0xFFF)
#define MAX_SIMUL_ALLOCATIONS       2048     /* maximum number of simultaneous memory allocations */

#if !defined PAGE_SIZE
#define PAGE_SIZE                   4096
#endif

#if !defined PAGE_SHIFT
#define PAGE_SHIFT			        12L
#endif

#if !defined PAGENUM
#define PAGENUM(p)			        (((U032)(p)) >> PAGE_SHIFT)
#endif

// this is all defined in os.h for Win9x, but not for NT (??)
#if !defined DEBUGLEVEL_TRACEINFO
#define DEBUGLEVEL_TRACEINFO	    0       // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO	    1       // For informational debug setup info
#define DEBUGLEVEL_USERERRORS	    2       // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS	        3       // For RM debug warning info
#define DEBUGLEVEL_ERRORS	        4       // For RM debug error info
#endif

#define MIN(a,b)                    (((a)<(b))?(a):(b))
#define MAX(a,b)                    (((a)>(b))?(a):(b))

#if defined __cplusplus
};
#endif

#if defined __cplusplus
// only include the class definition for c++
class CFpState
{
public:
    CFpState();
    ~CFpState();

private:
#if defined WDM
    KFLOATING_SAVE m_State;
#else
    U032 m_dwFpuSave[32];
    U032 m_dwCr0;
#endif
};

#endif      // C++

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvagp.h ===
#ifndef NVAGP_H
#define NVAGP_H

#include <nvrm.h>

#include <os.h>
#ifdef LINUX
#include <os-interface.h>
#endif

// AGP memory allocation tracking
typedef struct _AGP_MEM_INFO
{
    VOID *SysAddr;              // original pages
    U032 PageCount;
    U032 Offset;                // index into AGP Bitmap
    VOID *pMdl;                  // MDL for user mapping
} AGP_MEM_INFO, *PAGP_MEM_INFO;

/* export AGP functionality to rest of resman */
BOOL RmInitAGP (PHWINFO);
BOOL RmTeardownAGP (PHWINFO);
RM_STATUS NvInitChipset(PHWINFO, VOID **handle, U032 *chipset);
RM_STATUS NvSetAGPRate(PHWINFO, VOID *handle, U032 *agprate);
VOID NvUpdateAGPConfig(PHWINFO);
RM_STATUS NvGetAGPBaseLimit(PHWINFO, U032 *base, U032 *limit);
VOID NvEnableAGP(PHWINFO);
VOID NvDisableAGP(PHWINFO);
VOID NvSaveRestoreAGPChipset(PHWINFO pDev, U032 state);
VOID NvSetupAGPConfig(PHWINFO);
RM_STATUS NvAllocAGPPages ( PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS NvMapAGPPages ( PHWINFO, VOID **, U032, VOID *);
RM_STATUS NvFreeAGPPages ( PHWINFO, VOID **, VOID  *);
BOOL NvSetBusDeviceFunc(PHWINFO);
RM_STATUS NvSetCapIDOffset(PHWINFO, VOID *, U032 *);

/* OS-specific functionality imported from resman */
/* probably need to split this into a different file */
#ifdef LINUX
#include <linux/types.h>		/* for size_t */
#endif

#define AgpInfo(pdev)      (((PRMINFO)(pdev)->pRmInfo)->AGP)

#define PCI_VENDOR_ID		0x00
#define PCI_DEVICE_ID		0x02
#define PCI_COMMAND  		0x04
#define PCI_BASE_ADDRESS_0	0x10   /* Aperture Base */
#define PCI_BASE_ADDRESS_1	0x14   /* Aperture Base */
#define PCI_CAPABILITY_LIST     0x34
#define PCI_DEVICE_SPECIFIC     0x40

#define PCI_MAX_SLOTS            255

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_INVALID_VENDORID                0xFFFF

#define PCI_CLASS_DISPLAY_DEV               0x03
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_MULTIFUNCTION                   0x80

#define AGP_NB_ADDR_VALID       0x80000000

#define AGP_CAP_ID              0x02
#define AGP_CAP_STATUS          0x04
#define AGP_CAP_COMMAND         0x08

#define PCI_VENDOR_ID_INTEL       0x8086
#define PCI_VENDOR_ID_AMD         0x1022
#define PCI_VENDOR_ID_VIA         0x1106
#define PCI_VENDOR_ID_RCC         0x1166
#define PCI_VENDOR_ID_MICRON_1    0x1042
#define PCI_VENDOR_ID_MICRON_2    0x1344

#define AGP_STATUS            AgpInfo(pDev).AGPCapPtr+4
#define AGP_COMMAND           AgpInfo(pDev).AGPCapPtr+8

#define INTEL_CHIPSET_CONFIG    0x50
#define INTEL_ERRSTS            0x92
#define INTEL_GART_CONTROL      0xB0
#define INTEL_APER_SIZE         0xB4
#define INTEL_GART_BASE         0xB8
#define INTEL_MULTI_TRANS_TIMER         0xBC
#define INTEL_LOW_PRI_TRANS_TIMER       0xBD

#define VIA_GART_CONTROL        0x80
#define VIA_APER_SIZE           0x84
#define VIA_GART_BASE           0x88
#define VIA_AGP_CONTROL         0xAC

#define AMD_APER_SIZE           0xAC

/* Memory space registers - hex offsets */
#define AMD_GART_STATUS         0x02
#define AMD_GART_BASE           0x04
#define AMD_GART_CONTROL        0x10

#define RCC_APER_SIZE           0x60

#define osPciOrByte(handle, offset, value)			\
    {								\
        volatile unsigned char tmp = osPciReadByte(handle, offset);	\
        tmp |= (U008) value;						\
		osPciWriteByte(handle, offset, tmp);			\
    }

#define osPciOrWord(handle, offset, value)			\
    {								\
        volatile unsigned short tmp = osPciReadWord(handle, offset); \
        tmp |= (U016) value;						\
		osPciWriteWord(handle, offset, tmp);			\
    }

#define osPciOrDword(handle, offset, value)			\
    {								\
        volatile unsigned int tmp = osPciReadDword(handle, offset);	\
        tmp |= (U032) value;						\
		osPciWriteDword(handle, offset, tmp);		\
    }

#define osPciAndByte(handle, offset, value)			\
    {								\
        volatile unsigned char tmp = osPciReadByte(handle, offset);	\
        tmp &= (U008) value;						\
		osPciWriteByte(handle, offset, tmp);			\
    }

#define osPciAndWord(handle, offset, value)			\
    {								\
        volatile unsigned short tmp = osPciReadWord(handle, offset);	\
        tmp &= (U016) value;						\
		osPciWriteWord(handle, offset, tmp);			\
    }

#define osPciAndDword(handle, offset, value)			\
    {								\
        volatile unsigned int tmp = osPciReadDword(handle, offset);	\
        tmp &= (U032) value;						\
		osPciWriteDword(handle, offset, tmp);		\
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\win9x\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "utils.h"
#include "restime.h"
#include "regfuncs.h"
#include "debug.h"

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine extracts the Restriction and Timing list for the
    device requested from the registry. nRTListLen is the length
    in RESTIME structures of the array pointed to by lpRTList.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpDispData)
{
    int         i;
    long        lRet;
    ULONG       dwSubKey;
    ULONG       dwSize, dwValueNameSize;
    ULONG       hRTKey;
    char        szItem[MAX_KEY_LEN];
    char        szRTString[MAX_KEY_LEN];
    LPRESTIME   lpRTList;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterRTList.");

    if  (!(lpRTList = (LPRESTIME) MemoryAlloc (MAX_RESTIMES * sizeof(RESTIME))))
    {
        DBG_PRINT0 (DL_0, "\r\nAllocation of Restriction And Timing List Failed.");
        DBG_PRINT0 (DL_0, "\r\nSetting up a default list with no restrictions.");
        lpRTList = &sRTList;

        // Use the dwXRes field in the first array element as a count
        // of the number of restriction list entries.
        lpRTList[0].dwXRes = 0;
        return  (lpRTList);
    }

    // Use the dwXRes field in the first array element as a count
    // of the number of restriction list entries.
    lpRTList[0].dwXRes = 0;

    // First, find the path to the restriction and timing strings.
    if  (!(hRTKey = GetLocalNvidiaDisplaySubKey (lpDispData->lpBoardRegistryData)))
    {
        DBG_PRINT0(DL_0, "\r\nGetLocalDisplaySubKey failed. Returning empty RTList.");  
        return  (lpRTList);
    }

    // Start enumerating and parsing the R&T strings.
    for (dwSubKey = 0; TRUE; dwSubKey++)
    {
        // Zero out the strings
        for (i = 0; i < MAX_KEY_LEN; i++)
        {
            szItem[i] = 0;
            szRTString[i] = 0;
        }

        dwValueNameSize = MAX_KEY_LEN;
        dwSize = MAX_KEY_LEN;
        lRet = RegEnumValue (hRTKey, dwSubKey, szItem,
                            &dwValueNameSize, NULL, NULL,
                            szRTString, &dwSize);

        // If there was an error, it probably means that there are
        // no more values to enumerate. That's fine. We are done.
        if  (lRet != ERROR_SUCCESS)
            break;

        // Is this subkey an R&T string? It is if it begins "R&T"
        if  ((szItem[0] == 'R') && (szItem[1] == '&') && (szItem[2] == 'T'))
        {
            // If the R&T string parses legitimately, include it in the list.
            if  (lpRTList[0].dwXRes < (MAX_RESTIMES - 1))
            {
                if  (ParseRTString (lpRTList + lpRTList[0].dwXRes + 1, szRTString))
                {
                    DBG_PRINT1(DL_0, "\r\nR&T string %s parsed fine.", szRTString);
                    lpRTList[0].dwXRes++;
                }
            }
        }
    }

    // Close the key
    RegCloseKey (hRTKey);

    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    // The dwYRes field in the first array element is used as a flag
    // to indicate that the array was GlobalAlloced.
    if  (lpRTList != &sRTList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on RTList.");
        MemoryFree ((LPULONG) lpRTList);
    }

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\winnt\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/
#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "restime.h"
#include "debug.h"

// Just in case we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine returns a ptr to a an array of RESTIME
    structures which describe the list of R&T strings for
    the board specified. This routine needs to ALWAYS return
    some RT list. If you have to just return a blank list.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpBoardData)
{
    LPRESTIME   lpRTList;

    // Here is returning a blank list.
    lpRTList = &sRTList;
    lpRTList[0].dwXRes = 0;
    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\client.h ===
#ifndef _CLIENT_H_
#define _CLIENT_H_
/******************************************************************************
*
*   File:  client.h
*
*   Description:
*       This file contains the data structures needed to describe all
*   client information.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#define NUM_CLIENTS 160
#define NUM_DEVICES 8

typedef struct _def_client_memory_info
{
    PHWINFO             pDev;
    U032                Handle;
    U032                Parent;
    U032                Class;
    VOID*               Address;
    U032                Length;
    U032                Type;
    U032                Physicality;
    U032                Coherency;
    U032                Instance;
    U032                version;   // used to keep track of how an instance of class NV01_MEMORY_LOCAL_USER was allocated - C.Moidel
    U032                HeapOwner; /* if version > 0 then HeapOwner is the handle to a valid instance of NV04_HEAP_OWNER
                                                     This means that both the memory and HeapOwner were allocated with RmAlloc()
                                      if version = 0 then HeapOwner is a non-unique user created ID and there 
                                                     is NOT a HeapOwner object behind that ID.  Do not register and unregister with the HeapOwner!
                                                     This means that the memory was allocated with either RmAllocMemory() or RmArchHeap()  - C.Moidel*/  
    VOID*               MemData;   // private per-alloc data
    struct _def_client_memory_info* Next;
    struct _def_client_memory_info* Prev;

} CLI_MEMORY_INFO, *PCLI_MEMORY_INFO;

// FIFO channel info
typedef struct _def_client_fifo_info
{
    U032                Handle;
    U032                Device;
    U032                Class;
    U032                ErrorDmaContext;
    U032                DataDmaContext;
    VOID*               FifoPtr;
    U032                DevID;
    U032                InUse;
    U032                ChID;
    U032                AppID;
    void               *AppHandle;
    U032                Selector;
    VOID*               Flat;
    U032                heventWait;
    V032                hwndNotify;
    V032                hwndError;
    U032                msgNotify;
    U032                msgError;
    VOID*               lpSysCallback;
    U032                eventNotify;
    VOID*               pDmaObject;

} CLI_FIFO_INFO, *PCLI_FIFO_INFO;

// device information
typedef struct _def_client_device_info
{
    U032                Handle;
    U032                Client;
    U032                Class;
    U032                InUse;
    U032                AppID;
    U032                DevID;
    void               *AppHandle;
    PCLI_FIFO_INFO      DevFifoList;
    PCLI_MEMORY_INFO    DevMemoryList;

} CLI_DEVICE_INFO, *PCLI_DEVICE_INFO;

typedef struct _def_client_event_user
{
    U032                Handle;
    U032                Channel;
    struct _def_client_event_user* Next;
    struct _def_client_event_user* Prev;

} CLI_EVENT_USER, *PCLI_EVENT_USER;

typedef struct _def_client_event_info
{
    U032                Handle;
    U032                Class;
    PCLI_EVENT_USER     UserList;
    struct _def_client_event_info* Next;
    struct _def_client_event_info* Prev;

} CLI_EVENT_INFO, *PCLI_EVENT_INFO;


//Heap Owner info structure - added by Chuck Moidel
/* TODO: Create a heap_owner data structure that stores device & handle information about allocations
   that it "ownes" rather than doing a search throughout the data structres. */

typedef struct _def_client_heap_owner_info
{
    U032                Handle;
    U032                Client;
    U032                Class;
    U032                BlockReferenceCount;
//  PCLI_MEMORY_INFO    HeapOwnerMemoryList; 
//  PCLI_DEVICE_INFO    CliDeviceList;
    struct _def_client_heap_owner_info* Next;
    struct _def_client_heap_owner_info* Prev;

} CLI_HEAP_OWNER_INFO, *PCLI_HEAP_OWNER_INFO;

// client information
typedef struct _def_client_info
{
    U032                 Handle;
    U032                 Class;
    U032                 InUse;
    U032                 AppID;
    U032                 ProcID;
    void                *AppHandle;
    U032                 ProcContext;
    U032                 FifoCount;
    PCLI_DMA_INFO        CliDmaList;
    PCLI_DEVICE_INFO     CliDeviceList;
    PCLI_MEMORY_INFO     CliMemoryList;
    PCLI_EVENT_INFO      CliEventList;
    PCLI_HEAP_OWNER_INFO CliHeapOwnerList;   // modified by Chuck Moidel

} CLIENTINFO, *PCLIENTINFO;

//
// FIFO channel info.
//

typedef struct _def_channel_info
{
    U032  InUse;
    U032  ChID;
    U032  AppID;
    VOID *AppHandle;
    U032  Selector;
    VOID* Flat;
    U032  heventWait;
    V032  hwndNotify;
    V032  hwndError;
    U032  msgNotify;
    U032  msgError;
    VOID* lpSysCallback;
} CHANNELINFO, *PCHANNELINFO;


RM_STATUS           CliAddClient            (U032*, U032);
BOOL                CliDelClient            ();
BOOL                CliGetClientHandle      (U032*);
BOOL                CliGetClientIndex       (U032, U032*);
BOOL                CliGetClientAppHandle   (U032, void**);
BOOL                CliSetClientContext     (U032);
BOOL                CliSetClientAppHandle   (U032, void*);
BOOL                CliSetClientInstance    (U032);
RM_STATUS           CliGetClientHandleFromChID(PHWINFO, U032, U032*);
RM_STATUS           CliAddDevice            (U032, U032, U032);
BOOL                CliDelDevice            (U032);
BOOL                CliMakeDeviceList       (U032, U032, PCLI_DEVICE_INFO*);
BOOL                CliGetDeviceInfo        (U032, PCLI_DEVICE_INFO*);
PCLI_DEVICE_INFO    CliGetDeviceList        ();
BOOL                CliGetDeviceHandle      (U032, U032*);
BOOL                CliGetDeviceAppHandle   (U032, void**);
BOOL                CliSetDeviceContext     (U032, PHWINFO*);
BOOL                CliSetDeviceAppHandle   (U032, void*);
BOOL                CliGetDeviceClassString (U032, char*);
RM_STATUS           CliAddDeviceFifo        (PHWINFO, U032, U032, U032, U032, U032, U032, U032, U032, VOID*);
BOOL                CliDelDeviceFifo        (U032, U032);
BOOL                CliMakeDeviceFifoList   (U032, U032, U032, PCLI_FIFO_INFO*);
BOOL                CliGetDeviceFifoInfo    (U032, U032, PCLI_FIFO_INFO*);
BOOL                CliGetDeviceFifoList    (U032, PCLI_FIFO_INFO*);
RM_STATUS           CliAddDeviceMemory      (U032, U032, U032, VOID*, U032, U032, U032, U032);
BOOL                CliDelDeviceMemory      (U032, U032);
BOOL                CliDelDeviceHeapOwner   (U032, U032);
BOOL                CliGetDeviceMemoryInfo  (U032, U032, PCLI_MEMORY_INFO*);
PCLI_MEMORY_INFO    CliGetDeviceMemoryList  (U032);
RM_STATUS           CliAddDma               (U032, U032, U032, U032, U032, VOID*, U032, PCLI_DMA_INFO*);
BOOL                CliDelDma               (U032);
BOOL                CliGetDmaInfo           (U032, PCLI_DMA_INFO*);
PCLI_DMA_INFO       CliGetDmaList           ();
RM_STATUS           CliAddMemory            (PHWINFO, U032, U032, U032, U032, VOID*, U032, VOID*);
BOOL                CliDelMemory            (U032);
BOOL                CliGetMemoryInfo        (U032, PCLI_MEMORY_INFO*);
BOOL                CliGetMemoryInfoForLinAddr(VOID *, PCLI_MEMORY_INFO *);
PCLI_MEMORY_INFO    CliGetMemoryList        ();
RM_STATUS           CliAddEvent             (U032, U032, U032, U032, PCLI_EVENT_INFO*);
BOOL                CliDelEvent             (U032);
BOOL                CliDelEventUser         (U032, U032);
U032                CliGetEventUserHandle   (PCLI_EVENT_USER, U032);
BOOL                CliGetEventInfo         (U032, PCLI_EVENT_INFO*);
PCLI_EVENT_INFO     CliGetEventList         ();
BOOL                CliFindObject           (U032, POBJECT*, U032*);
BOOL                CliGetClass             (U032, U032, U032*);
BOOL                CliIsUniqueHandle       (U032, BOOL);
BOOL                CliGetPhysicalDevice    (U032, U032*);

#endif // _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvarch.h ===
#ifndef _NVARCH_H
#define _NVARCH_H
/**************************************************************************************************************
*
*    File:  nvarch.h
*
*    Description:
*        Defines the functions that implement the nvalloc architecture
*
**************************************************************************************************************/


// macros for IOCTL argument passing and return values
#define ARGS_PTR(t) t *pArgs = (t*)parameters    // declare and define a pointer to the arg struct (arg struct type)
#define ARG(a) (pArgs->a)                         // reference to a member of the arg struct (element name)
#define ARG_P064(a) NvP64_VALUE(pArgs->a)         // extraction of a pointer from a NvP64 in the arg struct (element name)
#define ARG_SELECTOR(a) NvP64_SELECTOR(pArgs->a) // extraction of a selector from a NvP64 in the arg struct (element name)
#define ARG_U064(a) NvU64_VALUE(pArgs->a)        // extraction of a value from a NvU64 in the arg struct (element name)

// macros for error checking
#define RM_SUCCESS(s) ((s) == RM_OK)

// TO DO: clean this up by retrieving values from the registry
// display info constants and structure taken from win95's vdd.h
#define REGISTRY_BPP_NOT_VALID          0x0008
#define MONITOR_INFO_NOT_VALID          0x0080
#define MONITOR_INFO_DISABLED_BY_USER   0x0100

//---------------------------------------------------------------------------
//
//  External variable definitions.
//
//---------------------------------------------------------------------------

extern PCLIENTINFO clientInfo;

extern U032         rmInService;
extern U032         osInService;
extern U032         rmInSafeService;
extern U032         rmInCallback;
extern U032       * rmStackBase;
extern U032       * rmStack;
extern U032         vmmStack;

//---------------------------------------------------------------------------
//
// Function prototypes.
//
//---------------------------------------------------------------------------

// discardable initialization routines
RM_STATUS   initSemaphore           (VOID);
RM_STATUS   initCallbackFreeList    (VOID);
RM_STATUS   initClientInfo          (VOID);
RM_STATUS   destroyClientInfo       (VOID);
RM_STATUS   initMemoryAllocTable    (VOID);

// exported API functions
VOID        Nv01AllocRoot           (NVOS01_PARAMETERS*);
VOID        Nv01AllocDevice         (NVOS06_PARAMETERS*);
VOID        Nv01AllocContextDma     (NVOS03_PARAMETERS*);
VOID        Nv01AllocChannelPio     (NVOS04_PARAMETERS*);
VOID        Nv03AllocChannelDma     (NVOS07_PARAMETERS*);
VOID        Nv01AllocMemory         (NVOS02_PARAMETERS*);
VOID        Nv01AllocObject         (NVOS05_PARAMETERS*);
VOID        Nv04Alloc               (NVOS21_PARAMETERS*);
VOID        Nv01Free                (NVOS00_PARAMETERS*);
VOID        Nv03DmaFlowControl      (NVOS08_PARAMETERS*);
VOID        Nv01Interrupt           (NVOS09_PARAMETERS*);
VOID        Nv01AllocEvent          (NVOS10_PARAMETERS*);
VOID        Nv03ArchHeap            (NVOS11_PARAMETERS*);
VOID        Nv01ConfigVersion       (NVOS12_PARAMETERS*);
VOID        Nv01ConfigGet           (NVOS13_PARAMETERS*);
VOID        Nv01ConfigSet           (NVOS14_PARAMETERS*);
VOID        Nv01ConfigUpdate        (NVOS15_PARAMETERS*);
VOID        Nv01DebugControl        (NVOS20_PARAMETERS*);
VOID        NvRing0Callback         (NVRM_RING0CALLBACK_PARAMS*);
VOID        Nv04ConfigGetEx         (NVOS_CONFIG_GET_EX_PARAMS*);
VOID        Nv04ConfigSetEx         (NVOS_CONFIG_SET_EX_PARAMS*);
VOID        Nv04I2CAccess           (NVOS_I2C_ACCESS_PARAMS*);

// RM support functions
NvV32       RmAllocClient           (U032*, U032);
NvV32       RmAllocDevice           (U032, U032, U032, char*);
NvV32       RmAllocContextDma       (U032, U032, U032, U032, U032, VOID*, U032);
NvV32       RmAllocChannelPio       (U032, U032, U032, U032, U032, VOID**, U032);
NvV32       RmAllocChannelDma       (U032, U032, U032, U032, U032, U032, U032, VOID**);
RM_STATUS   RmAllocChannel          (U032, U032, U032, U032, U032, U032, U032, VOID**, U032);
NvV32       RmAllocMemory           (U032, U032, U032, U032, U032, VOID**, U032*);
RM_STATUS   RmAllocSystemMemory     (PHWINFO, U032, VOID**, U032*, VOID**, U032);
RM_STATUS   RmAllocInstanceMemory   (PHWINFO, U032, VOID**, U032*, U032*, U032*);
RM_STATUS   RmAllocFrameBufferMapping(PHWINFO, U032, VOID**, U032*);
NvV32       RmAllocObject           (U032, U032, U032, U032);
NvV32       RmAllocEvent            (U032, U032, U032, U032, U032, U064);
NvV32       RmAlloc                 (U032, U032, U032, U032, VOID*);
RM_STATUS   RmAllocObjectEx         (U032, U032, U032, VOID*);
NvV32       RmFree                  (U032, U032, U032);
RM_STATUS   RmFreeClient            (U032);
RM_STATUS   RmFreeDevice            (U032, U032);
RM_STATUS   RmFreeContextDma        (U032, U032);
RM_STATUS   RmFreeChannel           (U032, U032, U032);
RM_STATUS   RmFreeMemory            (U032, U032, U032, U032);
RM_STATUS   RmFreeSystemMemory      (PHWINFO, U032);
RM_STATUS   RmFreeSystemMemoryWithArgs(PHWINFO, VOID**, U032, VOID*, U032);
RM_STATUS   RmFreeInstanceMemory    (PHWINFO, U032, U032, U032);
RM_STATUS   RmFreeFrameBuffer       (PHWINFO, U032, U032, U032);
RM_STATUS   RmFreeObject            (U032, U032);
RM_STATUS   RmFreeEvent             (U032, U032);
NvV32       RmDmaChannelWritePut    (U032, U032);
NvV32       RmDmaChannelWritePutWithGet(U032, U032, U032);
NvV32       RmDmaChannelReadGet     (U032, U032*);
NvV32       RmDmaChannelSetJump     (U032, U032);
NvV32       RmInterrupt             (U032, U032);
NvV32       RmArchHeap              (U032, U032, U032, U032, U032, U032, U032, U032, S032*, U032*, U032*, VOID**, U032*, U032*, U032*);
NvV32       RmConfigVersion         (U032, U032, U032*);
NvV32       RmConfigGet             (U032, U032, U032, U032*);
NvV32       RmConfigSet             (U032, U032, U032, U032*, U032);
NvV32       RmConfigUpdate          (U032, U032, U032);
NvV32       RmConfigGetEx           (U032, U032, U032, VOID*, U032);
NvV32       RmConfigSetEx           (U032, U032, U032, VOID*, U032);
RM_STATUS   RmAllocDeviceInstance   (U032*);
NvV32       RmArchStatus            (RM_STATUS, U032);
VOID        RmInitCpuInfo           (PHWINFO);
VOID        RmInitBusInfo           (PHWINFO);
NvV32       RmI2CAccess             (U032, U032, VOID*);
NvV32       RmDirectMethodCall      (U032, U032, U032, U032, U032);
RM_STATUS   RmDebugEx               (U032, U032, U032, VOID*);
RM_STATUS   RmSwapInit              (PHWINFO);
RM_STATUS   RmSwapExt               (PHWINFO, U032, U032, U032, U032, U032, U032);
RM_STATUS   RmSwapClient            (PHWINFO, U032, U032);
RM_STATUS   RmSwapClientGone        (U032);

#endif // _NVARCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvcmrsvd.h ===
#ifndef _NVCMRSVD_H_
#define _NVCMRSVD_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NVTYPES_INCLUDED
#include "nvtypes.h"
#endif

//------------------------------------------------------------------------------
// Configuration manager reserved properties.
//
// #define NV_CFGEX_RESERVED 150
//------------------------------------------------------------------------------

typedef struct
{
    U032   Property;
    U032 * In;
    U032 * Out;
} NV_CFGEX_RESERVED_PROPERTY;

enum
{
    // Register read and write.
     PROPERTY_REG_RD08              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_RD16              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_RD32              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_WR08              // In:[Offset, Data] Out:[]
    ,PROPERTY_REG_WR16              // In:[Offset, Data] Out:[]
    ,PROPERTY_REG_WR32              // In:[Offset, Data] Out:[]

    // Frame buffer read and write.
    ,PROPERTY_FB_RD08               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_RD16               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_RD32               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_WR08               // In:[Offset, Data] Out:[]
    ,PROPERTY_FB_WR16               // In:[Offset, Data] Out:[]
    ,PROPERTY_FB_WR32               // In:[Offset, Data] Out:[]

    // PCI read and write.
    ,PROPERTY_PCI_RD08              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_RD16              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_RD32              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_WR08              // In:[Bus, Device, Function, Offset, Data] Out:[]
    ,PROPERTY_PCI_WR16              // In:[Bus, Device, Function, Offset, Data] Out:[]
    ,PROPERTY_PCI_WR32              // In:[Bus, Device, Function, Offset, Data] Out:[]

    // Set clocks.
    ,PROPERTY_SET_GRAPHICS_CLOCK    // In:[Frequency (Hz)]       Out:[]
    ,PROPERTY_SET_MEMORY_CLOCK      // In:[Frequency (Hz)]       Out:[]
    ,PROPERTY_SET_PIXEL_CLOCK       // In:[Head, Frequency (Hz)] Out:[]
};

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVCMRSVD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvutypes.h ===
#ifndef NVUTYPES_INCLUDED
#define NVUTYPES_INCLUDED
/*
 * nvutypes.h
 *
 * Copyright (C) 1995,1996 NVIDIA Corporation.
 *
 * This file contains unpacked types corresponding to the packed 32-bit 
 * types in <nv32.h>.  For example, the byte/bit alignment of Nvu1Pt16
 * is the same as required by renderSolidRectangle.Rectangle[0].y_x.
 *
 * If you want to manipulate elements smaller than 32 bits in your code, 
 * use these structures or define similar structures.  But when
 * you make assignments to hardware offsets in the NV Architecture,
 * you must use at least 32-bit wide quantities -- you must perform 
 * 32-bit writes.  You can cast these structures to 32 bits or combine
 * them in a union with pure 32-bit elements.
 *
 * An alternative to using these structures is to store values in your
 * own chosen format, and use the macros in <nvmacros.h> to assemble 
 * them into 32-bit values before writing to the chip.  But such macros 
 * take CPU cycles (except for constant values).
 */

/* Note that in the type names, "u" means unpacked, not "U" for unsigned". */

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for V008, U032, etc. typedefs */
#endif

typedef short	S016;

typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                reserved01[0x003];                /*0001-0003*/
} Nvu1Color08;
typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                c1;                               /*0001-0001*/
	V008                c2;                               /*0002-0002*/
	V008                c3;                               /*0003-0003*/
} Nvu4Color08;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                reserved01[0x001];                /*0002-0003*/
} Nvu1Color16;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                c1;                               /*0002-0003*/
} Nvu2Color16;
typedef struct {
	V032                c0;                               /*0000-0003*/
} Nvu1Color32;
typedef union {
	Nvu1Color08         v008;                             /*0000-0003*/
	Nvu1Color16         v016;                             /*0000-0003*/
	Nvu1Color32         v032;                             /*0000-0003*/
	V032                p;                                /*0000-0003*/
} Nvu1Color;

typedef union {
	Nvu4Color08         v_4_008;                          /*0000-0003*/
	Nvu2Color16         v_2_016;                          /*0000-0003*/
	Nvu1Color32         v_1_032;                          /*0000-0003*/
	Nvu1Color16         v_1_016;                          /*0000-0003*/
	Nvu1Color08         v_1_008;                          /*0000-0003*/
	V032                p;                                /*0000-0003*/
} NvuColor;

typedef struct {
	U016                fractHertz;                       /*0000-0001*/
	U016                intHertz;                         /*0002-0003*/
} NvuHertz;

typedef struct {
	U016                fractPart;                        /*0000-0001*/
	U016                intPart;                          /*0002-0003*/
} NvuFract;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
	U016                w;                                /*0004-0005*/
	U016                h;                                /*0006-0007*/
} NvuRect16;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
} Nvu1Pt16;

typedef struct {
	U016                w;                                /*0000-0001*/
	U016                h;                                /*0002-0003*/
} NvuDim16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
} Nvu2Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
} Nvu3Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
} Nvu4Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
	S016                x4;                               /*0010-0011*/
	S016                y4;                               /*0012-0013*/
	S016                x5;                               /*0014-0015*/
	S016                y5;                               /*0016-0017*/
	S016                x6;                               /*0018-0019*/
	S016                y6;                               /*001a-001b*/
	S016                x7;                               /*001c-001d*/
	S016                y7;                               /*001e-001f*/
	S016                x8;                               /*0020-0021*/
	S016                y8;                               /*0022-0023*/
} Nvu9Pt16;


#endif /* NVUTYPES_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvmath.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* nvmath.h
*
* OS-independent math utility functions implemented
*
*/

#if !defined _NVMATH_H_
#define _NVMATH_H_

#include <math.h>


// most functions (sqrt, sin.. etc) can be used by turning
// intrinsic functions on (option /Oi)
// see... http://msdn.microsoft.com/library/devprods/vs6/visualc/vccore/_core_.2f.oi.htm
// not-true intrinsic functions are implemented here...

// /Og messes up the .NMS
#pragma optimize ("g", on)
// not required if i use /Oi
// #pragma intrinsic (exp, log)

__inline double r0_pow (double a, double u)
{
    if (a == 0.0)
        return 0.0;
    else if (u == 0.0)
        return 1.0;
    else
        return (exp(u*log(a)));
}

__inline double r0_sinh(double a)
{
    return (0.5*(exp(a)-exp(-a)));
}

static __inline long FTOL(float ftmp1)
{
    long lTemp1;

    __asm
    {
        fld ftmp1
        fistp lTemp1
    }
    return lTemp1;
}

static __inline long DTOL(double ftmp1)
{
    long lTemp1;

    __asm
    {
        fld ftmp1
        fistp lTemp1
    }
    return lTemp1;
}


#pragma optimize ("g", off)

#define pow(x,y)    r0_pow ((x),(y))
#define sinh(x)     r0_sinh((x))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvrm_obscure.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 2000 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * Obscure resman symbols in the build by defining them away.
 *
 * Periodically should look at symbols in output to make sure no
 * new ones have snuck in.
 *
 * This should be os-independent.  Symbols that don't exist for one release
 *   or another are harmless
 *
 * TODO:
 *    need a perl script to undo this in arbitrary text (cut'n'paste
 *    debugger output for example)
 */

#define BT_Init                                      _nv_rmsym_00001
#define Bt_NC                                        _nv_rmsym_00002
#define Bt_NC400                                     _nv_rmsym_00003
#define Bt_NC480                                     _nv_rmsym_00004
#define Bt_NC600                                     _nv_rmsym_00005
#define Bt_NJ                                        _nv_rmsym_00006
#define Bt_NJ400                                     _nv_rmsym_00007
#define Bt_NJ480                                     _nv_rmsym_00008
#define Bt_NJ600                                     _nv_rmsym_00009
#define Bt_NM                                        _nv_rmsym_00010
#define Bt_NM400                                     _nv_rmsym_00011
#define Bt_NM480                                     _nv_rmsym_00012
#define Bt_NM600                                     _nv_rmsym_00013
#define Bt_PA                                        _nv_rmsym_00014
#define Bt_PA400                                     _nv_rmsym_00015
#define Bt_PA480                                     _nv_rmsym_00016
#define Bt_PA600                                     _nv_rmsym_00017
#define Bt_PM                                        _nv_rmsym_00018
#define Bt_PM400                                     _nv_rmsym_00019
#define Bt_PM480                                     _nv_rmsym_00020
#define Bt_PM600                                     _nv_rmsym_00021
#define Bt_PN                                        _nv_rmsym_00022
#define Bt_PN400                                     _nv_rmsym_00023
#define Bt_PN480                                     _nv_rmsym_00024
#define Bt_PN600                                     _nv_rmsym_00025
#define Btc_NC                                       _nv_rmsym_00026
#define Btc_NJ                                       _nv_rmsym_00027
#define Btc_NM                                       _nv_rmsym_00028
#define Btc_NM200                                    _nv_rmsym_00029
#define Btc_NM240                                    _nv_rmsym_00030
#define Btc_NM300                                    _nv_rmsym_00031
#define Btc_NM360                                    _nv_rmsym_00032
#define Btc_NM384                                    _nv_rmsym_00033
#define Btc_NM3x4                                    _nv_rmsym_00034
#define Btc_NM400                                    _nv_rmsym_00035
#define Btc_NM480                                    _nv_rmsym_00036
#define Btc_NM600                                    _nv_rmsym_00037
#define Btc_PA                                       _nv_rmsym_00038
#define Btc_PA200                                    _nv_rmsym_00039
#define Btc_PA240                                    _nv_rmsym_00040
#define Btc_PA300                                    _nv_rmsym_00041
#define Btc_PA360                                    _nv_rmsym_00042
#define Btc_PA384                                    _nv_rmsym_00043
#define Btc_PA3x4                                    _nv_rmsym_00044
#define Btc_PA400                                    _nv_rmsym_00045
#define Btc_PA480                                    _nv_rmsym_00046
#define Btc_PA600                                    _nv_rmsym_00047
#define Btc_PM                                       _nv_rmsym_00048
#define Btc_PN                                       _nv_rmsym_00049
#define CHRONTEL_NTSC                                _nv_rmsym_00050
#define CHRONTEL_PAL                                 _nv_rmsym_00051
#define CH_Disable                                   _nv_rmsym_00052
#define CH_FBC                                       _nv_rmsym_00053
#define CH_Init                                      _nv_rmsym_00054
#define CH_NTSC320X200                               _nv_rmsym_00055
#define CH_NTSC320X240                               _nv_rmsym_00056
#define CH_NTSC400X300                               _nv_rmsym_00057
#define CH_NTSC480X360                               _nv_rmsym_00058
#define CH_NTSC512X384                               _nv_rmsym_00059
#define CH_NTSC640X400                               _nv_rmsym_00060
#define CH_NTSC640X480                               _nv_rmsym_00061
#define CH_NTSC800X600                               _nv_rmsym_00062
#define CH_NULL_STRING                               _nv_rmsym_00063
#define CH_PAL320X200                                _nv_rmsym_00064
#define CH_PAL320X240                                _nv_rmsym_00065
#define CH_PAL400X300                                _nv_rmsym_00066
#define CH_PAL480X360                                _nv_rmsym_00067
#define CH_PAL512X384                                _nv_rmsym_00068
#define CH_PAL640X400                                _nv_rmsym_00069
#define CH_PAL640X480                                _nv_rmsym_00070
#define CH_PAL800X600                                _nv_rmsym_00071
#define CliAddClient                                 _nv_rmsym_00072
#define CliAddDevice                                 _nv_rmsym_00073
#define CliAddDeviceFifo                             _nv_rmsym_00074
#define CliAddDeviceMemory                           _nv_rmsym_00075
#define CliAddDma                                    _nv_rmsym_00076
#define CliAddEvent                                  _nv_rmsym_00077
#define CliAddMemory                                 _nv_rmsym_00078
#define CliDelClient                                 _nv_rmsym_00079
#define CliDelDevice                                 _nv_rmsym_00080
#define CliDelDeviceFifo                             _nv_rmsym_00081
#define CliDelDeviceHeapOwner                        _nv_rmsym_00082
#define CliDelDeviceMemory                           _nv_rmsym_00083
#define CliDelDma                                    _nv_rmsym_00084
#define CliDelEvent                                  _nv_rmsym_00085
#define CliDelEventUser                              _nv_rmsym_00086
#define CliDelMemory                                 _nv_rmsym_00087
#define CliFindObject                                _nv_rmsym_00088
#define CliGetClass                                  _nv_rmsym_00089
#define CliGetClientHandle                           _nv_rmsym_00090
#define CliGetClientHandleFromChID                   _nv_rmsym_00091
#define CliGetClientIndex                            _nv_rmsym_00092
#define CliGetDeviceClassString                      _nv_rmsym_00093
#define CliGetDeviceFifoInfo                         _nv_rmsym_00094
#define CliGetDeviceFifoList                         _nv_rmsym_00095
#define CliGetDeviceHandle                           _nv_rmsym_00096
#define CliGetDeviceInfo                             _nv_rmsym_00097
#define CliGetDeviceList                             _nv_rmsym_00098
#define CliGetDeviceMemoryInfo                       _nv_rmsym_00099
#define CliGetDeviceMemoryList                       _nv_rmsym_00100
#define CliGetDmaInfo                                _nv_rmsym_00101
#define CliGetDmaList                                _nv_rmsym_00102
#define CliGetEventInfo                              _nv_rmsym_00103
#define CliGetEventList                              _nv_rmsym_00104
#define CliGetEventUserHandle                        _nv_rmsym_00105
#define CliGetMemoryInfo                             _nv_rmsym_00106
#define CliGetMemoryList                             _nv_rmsym_00107
#define CliGetPhysicalDevice                         _nv_rmsym_00108
#define CliIsUniqueHandle                            _nv_rmsym_00109
#define CliSetClientContext                          _nv_rmsym_00110
#define CliSetClientInstance                         _nv_rmsym_00111
#define CliSetDeviceContext                          _nv_rmsym_00112
#define ClientInstance                               _nv_rmsym_00113
#define Common_ClassDescriptors                      _nv_rmsym_00114
#define Commonclass04DGetImageOffsetNotify           _nv_rmsym_00115
#define Commonclass04DGetVbiOffsetNotify             _nv_rmsym_00116
#define Commonclass04DNotify                         _nv_rmsym_00117
#define Commonclass04DSetContextDmaImage             _nv_rmsym_00118
#define Commonclass04DSetContextDmaNotifies          _nv_rmsym_00119
#define Commonclass04DSetContextDmaVbi               _nv_rmsym_00120
#define Commonclass04DSetImage                       _nv_rmsym_00121
#define Commonclass04DSetImageConfig                 _nv_rmsym_00122
#define Commonclass04DSetImageStartLine              _nv_rmsym_00123
#define Commonclass04DSetVbi                         _nv_rmsym_00124
#define Commonclass04DStopTransferImage              _nv_rmsym_00125
#define Commonclass04DStopTransferVbi                _nv_rmsym_00126
#define Commonclass04ENotify                         _nv_rmsym_00127
#define Commonclass04EReadData                       _nv_rmsym_00128
#define Commonclass04ESetContextDmaData              _nv_rmsym_00129
#define Commonclass04ESetContextDmaImage             _nv_rmsym_00130
#define Commonclass04ESetContextDmaNotifies          _nv_rmsym_00131
#define Commonclass04EStopTransfer                   _nv_rmsym_00132
#define Commonclass04EWriteImage                     _nv_rmsym_00133
#define Commonclass04FNotify                         _nv_rmsym_00134
#define Commonclass04FRead                           _nv_rmsym_00135
#define Commonclass04FSetContextDmaNotifies          _nv_rmsym_00136
#define Commonclass04FSetInterruptNotify             _nv_rmsym_00137
#define Commonclass04FStopTransfer                   _nv_rmsym_00138
#define Commonclass04FWrite                          _nv_rmsym_00139
#define Commonclass63GetOffsetNotify                 _nv_rmsym_00140
#define Commonclass63ImageScan                       _nv_rmsym_00141
#define Commonclass63SetImageCtxDma                  _nv_rmsym_00142
#define Commonclass63SetNotify                       _nv_rmsym_00143
#define Commonclass63SetNotifyCtxDma                 _nv_rmsym_00144
#define Commonclass63SetVideoOutput                  _nv_rmsym_00145
#define Commonclass63StopTransfer                    _nv_rmsym_00146
#define Commonclass64SetDeltaDuDx                    _nv_rmsym_00147
#define Commonclass64SetDeltaDvDy                    _nv_rmsym_00148
#define Commonclass64SetNotify                       _nv_rmsym_00149
#define Commonclass64SetNotifyCtxDma                 _nv_rmsym_00150
#define Commonclass64SetPoint                        _nv_rmsym_00151
#define Commonclass64SetVideoInput                   _nv_rmsym_00152
#define Commonclass64SetVideoOutput                  _nv_rmsym_00153
#define Commonclass65SetColorFormat                  _nv_rmsym_00154
#define Commonclass65SetColorKey                     _nv_rmsym_00155
#define Commonclass65SetNotify                       _nv_rmsym_00156
#define Commonclass65SetNotifyCtxDma                 _nv_rmsym_00157
#define Commonclass65SetPoint                        _nv_rmsym_00158
#define Commonclass65SetSize                         _nv_rmsym_00159
#define Commonclass65SetVideoInput                   _nv_rmsym_00160
#define Commonclass65SetVideoOutput                  _nv_rmsym_00161
#define CompatColors                                 _nv_rmsym_00162
#define DevinitCrtcToPriv                            _nv_rmsym_00163
#define DevinitExtractDataFromBios                   _nv_rmsym_00164
#define DevinitFetchByte                             _nv_rmsym_00165
#define DevinitFetchDword                            _nv_rmsym_00166
#define DevinitFetchWord                             _nv_rmsym_00167
#define DevinitGetInitTableInfo                      _nv_rmsym_00168
#define DevinitInitDataToCode                        _nv_rmsym_00169
#define DevinitInitializeDevice                      _nv_rmsym_00170
#define EDIDCopy                                     _nv_rmsym_00171
#define EDIDGetMaxRefreshRate                        _nv_rmsym_00172
#define EDIDIsMonitorGTF                             _nv_rmsym_00173
#define EDIDIsValid                                  _nv_rmsym_00174
#define EDIDRead                                     _nv_rmsym_00175
#define EDIDV1Copy                                   _nv_rmsym_00176
#define EDIDV1GetMaxRefreshRate                      _nv_rmsym_00177
#define EDIDV1IsMonitorGTF                           _nv_rmsym_00178
#define EDIDV2Copy                                   _nv_rmsym_00179
#define EDIDV2GetMaxRefreshRate                      _nv_rmsym_00180
#define EDIDV2IsMonitorGTF                           _nv_rmsym_00181
#define EngineInfos                                  _nv_rmsym_00182
#define FindRegistryKeyDisplayPosition               _nv_rmsym_00183
#define FixupColors                                  _nv_rmsym_00184
#define FlushWB                                      _nv_rmsym_00185
#define Fog_EyeDist_Passthr_Mode                     _nv_rmsym_00186
#define Fog_Passthr_Mode                             _nv_rmsym_00187
#define GetTimingFromCode                            _nv_rmsym_00188
#define GrayColors                                   _nv_rmsym_00189
#define HalRmFuncs_000                               _nv_rmsym_00190
#define ImageNotify                                  _nv_rmsym_00191

#define InitNV                                       _nv_rmsym_00193
#define IntenseTable                                 _nv_rmsym_00194
#define IsMonitorDDC                                 _nv_rmsym_00195
#define IsNV0A_NV04                                  _nv_rmsym_00196
#define IsNV10MaskRevA02orBetter_NV10                _nv_rmsym_00197
#define IsNV10MaskRevA03orBetter_NV10                _nv_rmsym_00198
#define IsNV10_NV10                                  _nv_rmsym_00199
#define IsNV15_NV10                                  _nv_rmsym_00200
#define IsNV15orBetter_NV10                          _nv_rmsym_00201
#define IsNV4_NV04                                   _nv_rmsym_00202
#define IsNV5_NV04                                   _nv_rmsym_00203
#define IsNV5orBetter_NV04                           _nv_rmsym_00204
#define IsNVXX                                       _nv_rmsym_00205
#define MTRR_Types                                   _nv_rmsym_00206
#define NTSCstr640                                   _nv_rmsym_00207
#define NTSCstr800                                   _nv_rmsym_00208
#define NV04_ClassDescriptors                        _nv_rmsym_00209
#define NV04_EngineDescriptors                       _nv_rmsym_00210
#define NV04_HalFuncs_000                            _nv_rmsym_00211
#define NV04_MultiChipFuncs                          _nv_rmsym_00212
#define NV04_NumClassDescs                           _nv_rmsym_00213
#define NV04_NumEngineDescs                          _nv_rmsym_00214
#define NV04_NvChipGetRasterPosition                 _nv_rmsym_00216
#define NV04_RmUpdateArbitrationSettings             _nv_rmsym_00217
#define NV04_class04DCreate                          _nv_rmsym_00218
#define NV04_class04DDestroy                         _nv_rmsym_00219
#define NV04_class04DGetImageOffsetNotify            _nv_rmsym_00220
#define NV04_class04DGetVbiOffsetNotify              _nv_rmsym_00221
#define NV04_class04DNotify                          _nv_rmsym_00222
#define NV04_class04DService                         _nv_rmsym_00223
#define NV04_class04DSetContextDmaImage              _nv_rmsym_00224
#define NV04_class04DSetContextDmaNotifies           _nv_rmsym_00225
#define NV04_class04DSetContextDmaVbi                _nv_rmsym_00226
#define NV04_class04DSetImage                        _nv_rmsym_00227
#define NV04_class04DSetImageConfig                  _nv_rmsym_00228
#define NV04_class04DSetImageStartLine               _nv_rmsym_00229
#define NV04_class04DSetVbi                          _nv_rmsym_00230
#define NV04_class04DStopTransferImage               _nv_rmsym_00231
#define NV04_class04DStopTransferVbi                 _nv_rmsym_00232
#define NV04_class04EAudioNotify                     _nv_rmsym_00233
#define NV04_class04ECreate                          _nv_rmsym_00234
#define NV04_class04EDestroy                         _nv_rmsym_00235
#define NV04_class04EImageNotify                     _nv_rmsym_00236
#define NV04_class04ENotify                          _nv_rmsym_00237
#define NV04_class04EReadData                        _nv_rmsym_00238
#define NV04_class04ESetContextDmaData               _nv_rmsym_00239
#define NV04_class04ESetContextDmaImage              _nv_rmsym_00240
#define NV04_class04ESetContextDmaNotifies           _nv_rmsym_00241
#define NV04_class04EStopTransfer                    _nv_rmsym_00242
#define NV04_class04EVideoNotify                     _nv_rmsym_00243
#define NV04_class04EWriteImage                      _nv_rmsym_00244
#define NV04_class04FCreate                          _nv_rmsym_00245
#define NV04_class04FDestroy                         _nv_rmsym_00246
#define NV04_class04FNotify                          _nv_rmsym_00247
#define NV04_class04FRead                            _nv_rmsym_00248
#define NV04_class04FSetContextDmaNotifies           _nv_rmsym_00249
#define NV04_class04FSetInterruptNotify              _nv_rmsym_00250
#define NV04_class04FStopTransfer                    _nv_rmsym_00251
#define NV04_class04FWrite                           _nv_rmsym_00252
#define NV04_class04F_VMI                            _nv_rmsym_00253
#define NV04_dacAGPClockTable                        _nv_rmsym_00254
#define NV04_dacProgramCursorImage                   _nv_rmsym_00255
#define NV04_dacProgramMClk                          _nv_rmsym_00256
#define NV04_dacProgramNVClk                         _nv_rmsym_00257
#define NV04_dacValidateArbitrationSettings          _nv_rmsym_00258
#define NV04_initMp                                  _nv_rmsym_00259
#define NV04_mpPriorityService                       _nv_rmsym_00260
#define NV04_mpService                               _nv_rmsym_00261
#define NV10_ClassDescriptors                        _nv_rmsym_00262
#define NV10_EngineDescriptors                       _nv_rmsym_00263
#define NV10_HalFuncs_000                            _nv_rmsym_00264
#define NV10_MultiChipFuncs                          _nv_rmsym_00265
#define NV10_NumClassDescs                           _nv_rmsym_00266
#define NV10_NumEngineDescs                          _nv_rmsym_00267
#define NV10_NvChipGetRasterPosition                 _nv_rmsym_00269
#define NV10_RmUpdateArbitrationSettings             _nv_rmsym_00270
#define NV10_class04DCreate                          _nv_rmsym_00271
#define NV10_class04DDestroy                         _nv_rmsym_00272
#define NV10_class04DGetImageOffsetNotify            _nv_rmsym_00273
#define NV10_class04DGetVbiOffsetNotify              _nv_rmsym_00274
#define NV10_class04DNotify                          _nv_rmsym_00275
#define NV10_class04DService                         _nv_rmsym_00276
#define NV10_class04DSetContextDmaImage              _nv_rmsym_00277
#define NV10_class04DSetContextDmaNotifies           _nv_rmsym_00278
#define NV10_class04DSetContextDmaVbi                _nv_rmsym_00279
#define NV10_class04DSetImage                        _nv_rmsym_00280
#define NV10_class04DSetImageConfig                  _nv_rmsym_00281
#define NV10_class04DSetImageStartLine               _nv_rmsym_00282
#define NV10_class04DSetVbi                          _nv_rmsym_00283
#define NV10_class04DStopTransferImage               _nv_rmsym_00284
#define NV10_class04DStopTransferVbi                 _nv_rmsym_00285
#define NV10_class04ECreate                          _nv_rmsym_00286
#define NV10_class04EDestroy                         _nv_rmsym_00287
#define NV10_class04EImageNotify                     _nv_rmsym_00288
#define NV10_class04ENotify                          _nv_rmsym_00289
#define NV10_class04EReadData                        _nv_rmsym_00290
#define NV10_class04ESetContextDmaData               _nv_rmsym_00291
#define NV10_class04ESetContextDmaImage              _nv_rmsym_00292
#define NV10_class04ESetContextDmaNotifies           _nv_rmsym_00293
#define NV10_class04EStopTransfer                    _nv_rmsym_00294
#define NV10_class04EVideoNotify                     _nv_rmsym_00295
#define NV10_class04EWriteImage                      _nv_rmsym_00296
#define NV10_class04FCreate                          _nv_rmsym_00297
#define NV10_class04FDestroy                         _nv_rmsym_00298
#define NV10_class04FNotify                          _nv_rmsym_00299
#define NV10_class04FRead                            _nv_rmsym_00300
#define NV10_class04FSetContextDmaNotifies           _nv_rmsym_00301
#define NV10_class04FSetInterruptNotify              _nv_rmsym_00302
#define NV10_class04FStopTransfer                    _nv_rmsym_00303
#define NV10_class04FWrite                           _nv_rmsym_00304
#define NV10_class04F_VMI                            _nv_rmsym_00305
#define NV10_dacAGPClockTable                        _nv_rmsym_00306
#define NV10_dacCalculateArbitration                 _nv_rmsym_00307
#define NV10_dacCalculateVideoCaps                   _nv_rmsym_00308
#define NV10_dacProgramCursorImage                   _nv_rmsym_00309
#define NV10_dacProgramMClk                          _nv_rmsym_00310
#define NV10_dacProgramNVClk                         _nv_rmsym_00311
#define NV10_dacValidateArbitrationSettings          _nv_rmsym_00312
#define NV10_initMp                                  _nv_rmsym_00313
#define NV10_mpPriorityService                       _nv_rmsym_00314
#define NV10_mpService                               _nv_rmsym_00315
#define NVExtractBiosImage                           _nv_rmsym_00316
#define NotifyImageBuffer                            _nv_rmsym_00317

#define NotifyVbiBuffer                              _nv_rmsym_00319

#define Nv01AllocChannelPio                          _nv_rmsym_00321
#define Nv01AllocContextDma                          _nv_rmsym_00322
#define Nv01AllocDevice                              _nv_rmsym_00323
#define Nv01AllocEvent                               _nv_rmsym_00324
#define Nv01AllocMemory                              _nv_rmsym_00325
#define Nv01AllocObject                              _nv_rmsym_00326
#define Nv01AllocRoot                                _nv_rmsym_00327
#define Nv01ConfigGet                                _nv_rmsym_00328
#define Nv01ConfigSet                                _nv_rmsym_00329
#define Nv01ConfigUpdate                             _nv_rmsym_00330
#define Nv01ConfigVersion                            _nv_rmsym_00331
#define Nv01DebugControl                             _nv_rmsym_00332
#define Nv01Free                                     _nv_rmsym_00333
#define Nv01Interrupt                                _nv_rmsym_00334
#define Nv03AllocChannelDma                          _nv_rmsym_00335
#define Nv03ArchHeap                                 _nv_rmsym_00336
#define Nv03DmaFlowControl                           _nv_rmsym_00337
#define Nv04ConfigGetEx                              _nv_rmsym_00338
#define Nv04ConfigSetEx                              _nv_rmsym_00339
#define Nv04I2CAccess                                _nv_rmsym_00340
#define Nv04MemLatchMemConfig                        _nv_rmsym_00341
#define Nv04MemResizeMemory                          _nv_rmsym_00342
#define Nv04MemResizeSdram                           _nv_rmsym_00343
#define Nv04MemResizeSgram                           _nv_rmsym_00344
#define Nv04VideoLUTCursorDACMethods                 _nv_rmsym_00345
#define Nv04VideoOverlayMethods                      _nv_rmsym_00346
#define Nv04_bmp_GenInitTbl                          _nv_rmsym_00347
#define Nv05MemLatchMemConfig                        _nv_rmsym_00348
#define Nv05MemResizeMemory                          _nv_rmsym_00349
#define Nv05VideoLUTCursorDACMethods                 _nv_rmsym_00350
#define Nv05_bmp_GenInitTbl                          _nv_rmsym_00351
#define Nv05_bmp_MemInitTbl                          _nv_rmsym_00352
#define Nv05_bmp_ScrambleTbl                         _nv_rmsym_00353
#define Nv10CelsiusPrimitiveHalMethods               _nv_rmsym_00354
#define Nv10CelsiusPrimitiveMethods                  _nv_rmsym_00355
#define Nv10ContextSurfaces2DMethods                 _nv_rmsym_00356
#define Nv10ContextSurfaces3DMethods                 _nv_rmsym_00357
#define Nv10DX5TexturedTriangleMethods               _nv_rmsym_00358
#define Nv10DX6MultiTextureTriangleMethods           _nv_rmsym_00359
#define Nv10DvdSubpictureMethods                     _nv_rmsym_00360
#define Nv10ImageFromCpuMethods                      _nv_rmsym_00361
#define Nv10MemChipPreInit                           _nv_rmsym_00362
#define Nv10MemComputeMemory                         _nv_rmsym_00363
#define Nv10MemConfigureClocks                       _nv_rmsym_00364
#define Nv10MemConfigureMemory                       _nv_rmsym_00365
#define Nv10ScaledImageFromMemoryMethods             _nv_rmsym_00366
#define Nv10TextureFromCpuMethods                    _nv_rmsym_00367
#define Nv10VideoLUTCursorDACMethods                 _nv_rmsym_00368
#define Nv10VideoOverlayMethods                      _nv_rmsym_00369
#define Nv10_DDR_Sequence_Table                      _nv_rmsym_00370
#define Nv10_SDR_Sequence_Table                      _nv_rmsym_00371
#define Nv10_bmp_GenInitTbl                          _nv_rmsym_00372
#define Nv10_bmp_MemInitTbl                          _nv_rmsym_00373
#define Nv15CelsiusPrimitiveHalMethods               _nv_rmsym_00374
#define Nv15CelsiusPrimitiveMethods                  _nv_rmsym_00375
#define Nv15ImageBlitMethods                         _nv_rmsym_00376
#define Nv15VideoLUTCursorDACMethods                 _nv_rmsym_00377
#define Nv1BetaSolidMethods                          _nv_rmsym_00378
#define Nv1ExternalParallelBusMethods                _nv_rmsym_00379
#define Nv1ImageBlitMethods                          _nv_rmsym_00380
#define Nv1ImageFromCpuMethods                       _nv_rmsym_00381
#define Nv1ImagePatternMethods                       _nv_rmsym_00382
#define Nv1ImageRectangleBlackMethods                _nv_rmsym_00383
#define Nv1ImageSolidMethods                         _nv_rmsym_00384
#define Nv1RenderSolidLinMethods                     _nv_rmsym_00385
#define Nv1RenderSolidRectangleMethods               _nv_rmsym_00386
#define Nv1RenderSolidTriangleMethods                _nv_rmsym_00387
#define Nv1TimerMethods                              _nv_rmsym_00388
#define Nv3ContextRopMethods                         _nv_rmsym_00389
#define Nv3ContextSurface0Methods                    _nv_rmsym_00390
#define Nv3ContextSurface1Methods                    _nv_rmsym_00391
#define Nv3ContextSurface2Methods                    _nv_rmsym_00392
#define Nv3ContextSurface3Methods                    _nv_rmsym_00393
#define Nv3DX3TexturedTriangleMethods                _nv_rmsym_00394
#define Nv3ExternalMonitorBusMethods                 _nv_rmsym_00395
#define Nv3ExternalVideoDecoderMethods               _nv_rmsym_00396
#define Nv3ExternalVideoDecompressorMethods          _nv_rmsym_00397
#define Nv3GDIRectangleTextMethods                   _nv_rmsym_00398
#define Nv3MemoryToMemoryFormatMethods               _nv_rmsym_00399
#define Nv3ScaledImageFromMemoryMethods              _nv_rmsym_00400
#define Nv3StretchedImageFromCPUMethods              _nv_rmsym_00401
#define Nv4ContextBetaMethods                        _nv_rmsym_00402
#define Nv4ContextColorKeyMethods                    _nv_rmsym_00403
#define Nv4ContextPatternMethods                     _nv_rmsym_00404
#define Nv4ContextSurfaceSwizzledMethods             _nv_rmsym_00405
#define Nv4ContextSurfaces2DMethods                  _nv_rmsym_00406
#define Nv4ContextSurfacesArgbZsHalMethods           _nv_rmsym_00407
#define Nv4ContextSurfacesArgbZsMethods              _nv_rmsym_00408
#define Nv4DX5TexturedTriangleMethods                _nv_rmsym_00409
#define Nv4DX6MultiTextureTriangleMethods            _nv_rmsym_00410
#define Nv4DvdSubpictureMethods                      _nv_rmsym_00411
#define Nv4ExternalSerialBusMethods                  _nv_rmsym_00412
#define Nv4GDIRectangleTextMethods                   _nv_rmsym_00413
#define Nv4ImageBlitMethods                          _nv_rmsym_00414
#define Nv4ImageFromCpuMethods                       _nv_rmsym_00415
#define Nv4IndexedImageFromCpuHalMethods             _nv_rmsym_00416
#define Nv4IndexedImageFromCpuMethods                _nv_rmsym_00417
#define Nv4RenderSolidLinMethods                     _nv_rmsym_00418
#define Nv4RenderSolidRectangleMethods               _nv_rmsym_00419
#define Nv4RenderSolidTriangleMethods                _nv_rmsym_00420
#define Nv4ScaledImageFromMemoryMethods              _nv_rmsym_00421
#define Nv4StretchedImageFromCpuMethods              _nv_rmsym_00422
#define Nv5ImageFromCpuMethods                       _nv_rmsym_00423
#define Nv5IndexedImageFromCpuMethods                _nv_rmsym_00424
#define Nv5ScaledImageFromMemoryMethods              _nv_rmsym_00425
#define Nv5StretchedImageFromCpuMethods              _nv_rmsym_00426
#define NvChipTetrisTileTable                        _nv_rmsym_00427
#define NvClassMethods                               _nv_rmsym_00428
#define NvControlClass                               _nv_rmsym_00429
#define NvControlMethods                             _nv_rmsym_00430
#define NvDBPtr_Table                                _nv_rmsym_00431
#define NvDmaFromMemoryMethods                       _nv_rmsym_00432
#define NvDmaInMemoryMethods                         _nv_rmsym_00433
#define NvDmaToMemoryMethods                         _nv_rmsym_00434
#define NvPatchcordMethods                           _nv_rmsym_00435
#define NvRing0Callback                              _nv_rmsym_00436
#define NvVideoColorKeyMethods                       _nv_rmsym_00437
#define NvVideoColormapMethods                       _nv_rmsym_00438
#define NvVideoFromMemoryMethods                     _nv_rmsym_00439
#define NvVideoScalerMethods                         _nv_rmsym_00440
#define NvVideoSinkMethods                           _nv_rmsym_00441
#define NvWatchInstanceMemFuncs                      _nv_rmsym_00442
#define NvWatch_DumpBtreeContents                    _nv_rmsym_00443
#define NvWatch_DumpCRTCRegs                         _nv_rmsym_00444
#define NvWatch_Dump_ClientInfo                      _nv_rmsym_00445
#define NvWatch_Dump_HT_Object_From_Channel          _nv_rmsym_00446
#define NvWatch_Dump_HT_Object_From_Class            _nv_rmsym_00447
#define NvWatch_Dump_HT_Object_From_Engine           _nv_rmsym_00448
#define NvWatch_Dump_HT_Object_From_Handle           _nv_rmsym_00449
#define NvWatch_Dump_HT_Object_From_Instance         _nv_rmsym_00450
#define NvWatch_Dump_HT_Objects                      _nv_rmsym_00451
#define NvWatch_Dump_InstanceFifoContext             _nv_rmsym_00452
#define NvWatch_Dump_NvInfo                          _nv_rmsym_00453
#define NvWatch_EditCRTCReg                          _nv_rmsym_00454
#define NvWatch_FrontEnd                             _nv_rmsym_00455
#define NvWatch_GetObjectFromInst                    _nv_rmsym_00456
#define NvWatch_NV04_DumpFifoContents                _nv_rmsym_00457
#define NvWatch_NV04_DumpUserDmaBuffersAtGet         _nv_rmsym_00458
#define NvWatch_NV04_Dump_Fifo                       _nv_rmsym_00459
#define NvWatch_NV04_Dump_Graphics                   _nv_rmsym_00460
#define NvWatch_NV04_Dump_Master                     _nv_rmsym_00461
#define NvWatch_NV04_Dump_SubChannelContext          _nv_rmsym_00462
#define NvWatch_NV04_Dump_Video                      _nv_rmsym_00463
#define NvWatch_NV04_FillDiagStruct                  _nv_rmsym_00464
#define NvWatch_NV04_GetHashSize                     _nv_rmsym_00465
#define NvWatch_NV10_DumpFifoContents                _nv_rmsym_00466
#define NvWatch_NV10_DumpUserDmaBuffersAtGet         _nv_rmsym_00467
#define NvWatch_NV10_Dump_Fifo                       _nv_rmsym_00468
#define NvWatch_NV10_Dump_Graphics                   _nv_rmsym_00469
#define NvWatch_NV10_Dump_Master                     _nv_rmsym_00470
#define NvWatch_NV10_Dump_Video                      _nv_rmsym_00471
#define NvWatch_NV10_FillDiagStruct                  _nv_rmsym_00472
#define NvWatch_NV10_GetHashSize                     _nv_rmsym_00473
#define NvWatch_ObjectStrings                        _nv_rmsym_00474
#define NvWatch_Process_Hash_Entry                   _nv_rmsym_00475
#define NvWatch_QuickDiag                            _nv_rmsym_00476
#define NvWatch_QuickDiag_fifo                       _nv_rmsym_00477
#define NvWatch_QuickDiag_master                     _nv_rmsym_00478
#define NvWatch_ascii2hex                            _nv_rmsym_00479
#define NvWatch_btreeDumpBranch                      _nv_rmsym_00480
#define NvWatch_dumpraw                              _nv_rmsym_00481
#define NvWatch_engine_dump                          _nv_rmsym_00482
#define NvWatch_num_objects                          _nv_rmsym_00483
#define NvWatch_nvedit                               _nv_rmsym_00484
#define NvWatch_nvread                               _nv_rmsym_00485
#define NvWatch_spaceit                              _nv_rmsym_00486
#define PALMstr640                                   _nv_rmsym_00487
#define PALMstr800                                   _nv_rmsym_00488
#define PALstr640                                    _nv_rmsym_00489
#define PALstr800                                    _nv_rmsym_00490
#define ParseEDID11                                  _nv_rmsym_00491
#define ParseEDID12                                  _nv_rmsym_00492
#define ParseEDID13                                  _nv_rmsym_00493
#define ParseEDID2                                   _nv_rmsym_00494

#define ReadCRTCLock                                 _nv_rmsym_00496
#define ReadSCL                                      _nv_rmsym_00497
#define ReadSDA                                      _nv_rmsym_00498
#define ReadVDIF                                     _nv_rmsym_00499
#define ResetSCLLine                                 _nv_rmsym_00500
#define ResetSDALine                                 _nv_rmsym_00501
#define RmAllocChannel                               _nv_rmsym_00502
#define RmAllocChannelDma                            _nv_rmsym_00503
#define RmAllocChannelPio                            _nv_rmsym_00504
#define RmAllocClient                                _nv_rmsym_00505
#define RmAllocContextDma                            _nv_rmsym_00506
#define RmAllocDevice                                _nv_rmsym_00507
#define RmAllocDeviceInstance                        _nv_rmsym_00508
#define RmAllocEvent                                 _nv_rmsym_00509
#define RmAllocFrameBufferMapping                    _nv_rmsym_00510
#define RmAllocInstanceMemory                        _nv_rmsym_00511
#define RmAllocMemory                                _nv_rmsym_00512
#define RmAllocObject                                _nv_rmsym_00513
#define RmAllocSystemMemory                          _nv_rmsym_00514
#define RmArchHeap                                   _nv_rmsym_00515
#define RmArchStatus                                 _nv_rmsym_00516
#define RmConfigGet                                  _nv_rmsym_00517
#define RmConfigGetEx                                _nv_rmsym_00518
#define RmConfigGetExKernel                          _nv_rmsym_00519
#define RmConfigGetKernel                            _nv_rmsym_00520
#define RmConfigSet                                  _nv_rmsym_00521
#define RmConfigSetEx                                _nv_rmsym_00522
#define RmConfigUpdate                               _nv_rmsym_00523
#define RmConfigVersion                              _nv_rmsym_00524
#define RmDisableInterrupts                          _nv_rmsym_00525
#define RmEnableInterrupts                           _nv_rmsym_00526
#define RmFailureTriggered                           _nv_rmsym_00527
#define RmFailuresDisable                            _nv_rmsym_00528
#define RmFailuresEnable                             _nv_rmsym_00529
#define RmFree                                       _nv_rmsym_00530
#define RmFreeChannel                                _nv_rmsym_00531
#define RmFreeClient                                 _nv_rmsym_00532
#define RmFreeContextDma                             _nv_rmsym_00533
#define RmFreeDevice                                 _nv_rmsym_00534
#define RmFreeEvent                                  _nv_rmsym_00535
#define RmFreeFrameBuffer                            _nv_rmsym_00536
#define RmFreeInstanceMemory                         _nv_rmsym_00537
#define RmFreeMemory                                 _nv_rmsym_00538
#define RmFreeObject                                 _nv_rmsym_00539
#define RmFreeSystemMemory                           _nv_rmsym_00540
#define RmI2CAccess                                  _nv_rmsym_00541

#define RmInitCpuInfo                                _nv_rmsym_00543
#define RmInitNvDevice                               _nv_rmsym_00544
#define RmInitNvMapping                              _nv_rmsym_00545
#define RmInterrupt                                  _nv_rmsym_00546
#define RmInterruptPending                           _nv_rmsym_00547
#define RmLoadState                                  _nv_rmsym_00548
#define RmPostNvDevice                               _nv_rmsym_00549
#define RmSetMode                                    _nv_rmsym_00550

#define RmUnloadState                                _nv_rmsym_00552
#define SavedBiosImageArray                          _nv_rmsym_00553
#define ScaleOffset_Passthr_Mode                     _nv_rmsym_00554
#define SetRetraceH                                  _nv_rmsym_00555
#define SetRetraceV                                  _nv_rmsym_00556
#define SetSCLLine                                   _nv_rmsym_00557
#define SetSDALine                                   _nv_rmsym_00558
#define StopDDC1                                     _nv_rmsym_00559
#define VBlank                                       _nv_rmsym_00560
#define VBlankAddCallback                            _nv_rmsym_00561
#define VBlankDeleteCallback                         _nv_rmsym_00562
#define VGATable                                     _nv_rmsym_00563
#define VPFilterCos                                  _nv_rmsym_00564
#define VT_BT_NTSC                                   _nv_rmsym_00565
#define VT_BT_PAL                                    _nv_rmsym_00566
#define VbiNotify                                    _nv_rmsym_00567


#define Vertex_Passthr_Mode                          _nv_rmsym_00570
#define WaitHighSCLLine                              _nv_rmsym_00571
#define WaitHighSDALine                              _nv_rmsym_00572
#define _nvHalClass053SetClipHorizontal              _nv_rmsym_00573
#define _nvHalClass053SetClipVertical                _nv_rmsym_00574
#define _nvHalClass056GetState                       _nv_rmsym_00575
#define _nvHalClass056SetMaterialEmission            _nv_rmsym_00576
#define _nvHalClass060SetColorConversion             _nv_rmsym_00577
#define _nvHalClass096GetState                       _nv_rmsym_00578
#define _nvHalGrClassSoftwareMethod_NV04             _nv_rmsym_00579
#define _nvHalGrClassSoftwareMethod_NV10             _nv_rmsym_00580
#define _nvHalGrInitCelsius_NV10                     _nv_rmsym_00581
#define _nvHalGrInitDx5_NV10                         _nv_rmsym_00582
#define _nvHalGrInitInstance_NV04                    _nv_rmsym_00583
#define _nvHalGrInitObjectContext_NV10               _nv_rmsym_00584
#define _nvHalGrSetContextColorKeyWar_NV04           _nv_rmsym_00585
#define allocHalEnginePvts                           _nv_rmsym_00586

#define blockFree                                    _nv_rmsym_00588
#define btreeBalance                                 _nv_rmsym_00589
#define btreeBalanceBranch                           _nv_rmsym_00590
#define btreeBranchValidate                          _nv_rmsym_00591
#define btreeDelete                                  _nv_rmsym_00592
#define btreeDumpBranch                              _nv_rmsym_00593
#define btreeDumpTree                                _nv_rmsym_00594
#define btreeEnumNext                                _nv_rmsym_00595
#define btreeEnumStart                               _nv_rmsym_00596
#define btreeInsert                                  _nv_rmsym_00597
#define btreeInsertBranch                            _nv_rmsym_00598
#define btreeNodeValidate                            _nv_rmsym_00599
#define btreeSearch                                  _nv_rmsym_00600
#define btreeTreeValidate                            _nv_rmsym_00601
#define class01CSetContextBeta1                      _nv_rmsym_00602
#define class01CSetContextClip                       _nv_rmsym_00603
#define class01CSetContextPattern                    _nv_rmsym_00604
#define class01CSetContextRop                        _nv_rmsym_00605
#define class01CSetContextSurface                    _nv_rmsym_00606
#define class01CSetOperation                         _nv_rmsym_00607
#define class01CValidate                             _nv_rmsym_00608
#define class01DSetContextBeta1                      _nv_rmsym_00609
#define class01DSetContextClip                       _nv_rmsym_00610
#define class01DSetContextPattern                    _nv_rmsym_00611
#define class01DSetContextRop                        _nv_rmsym_00612
#define class01DSetContextSurface                    _nv_rmsym_00613
#define class01DSetOperation                         _nv_rmsym_00614
#define class01DValidate                             _nv_rmsym_00615
#define class01ESetContextBeta1                      _nv_rmsym_00616
#define class01ESetContextClip                       _nv_rmsym_00617
#define class01ESetContextPattern                    _nv_rmsym_00618
#define class01ESetContextRop                        _nv_rmsym_00619
#define class01ESetContextSurface                    _nv_rmsym_00620
#define class01ESetOperation                         _nv_rmsym_00621
#define class01EValidate                             _nv_rmsym_00622
#define class01FSetContextBeta1                      _nv_rmsym_00623
#define class01FSetContextClip                       _nv_rmsym_00624
#define class01FSetContextColorKey                   _nv_rmsym_00625
#define class01FSetContextPattern                    _nv_rmsym_00626
#define class01FSetContextRop                        _nv_rmsym_00627
#define class01FSetContextSurface                    _nv_rmsym_00628
#define class01FSetContextSurfaceSource              _nv_rmsym_00629
#define class01FSetOperation                         _nv_rmsym_00630
#define class01FValidate                             _nv_rmsym_00631
#define class021SetContextBeta1                      _nv_rmsym_00632
#define class021SetContextClip                       _nv_rmsym_00633
#define class021SetContextColorKey                   _nv_rmsym_00634
#define class021SetContextPattern                    _nv_rmsym_00635
#define class021SetContextRop                        _nv_rmsym_00636
#define class021SetContextSurface                    _nv_rmsym_00637
#define class021SetOperation                         _nv_rmsym_00638
#define class021Validate                             _nv_rmsym_00639
#define class036SetContextBeta1                      _nv_rmsym_00640
#define class036SetContextColorKey                   _nv_rmsym_00641
#define class036SetContextPattern                    _nv_rmsym_00642
#define class036SetContextRop                        _nv_rmsym_00643
#define class036SetContextSurface                    _nv_rmsym_00644
#define class036SetOperation                         _nv_rmsym_00645
#define class036Validate                             _nv_rmsym_00646
#define class037SetContextBeta1                      _nv_rmsym_00647
#define class037SetContextPattern                    _nv_rmsym_00648
#define class037SetContextRop                        _nv_rmsym_00649
#define class037SetContextSurface                    _nv_rmsym_00650
#define class037SetOperation                         _nv_rmsym_00651
#define class037Validate                             _nv_rmsym_00652
#define class046CursorImageNotify                    _nv_rmsym_00653
#define class046GetOffset                            _nv_rmsym_00654
#define class046ImageNotify                          _nv_rmsym_00655
#define class046ProgramLUT                           _nv_rmsym_00656
#define class046SetCursorCtxDma                      _nv_rmsym_00657
#define class046SetCursorImageValues                 _nv_rmsym_00658
#define class046SetCursorPoint                       _nv_rmsym_00659
#define class046SetDACValues                         _nv_rmsym_00660
#define class046SetImageCtxDma                       _nv_rmsym_00661
#define class046SetImageValues                       _nv_rmsym_00662
#define class046SetLUTCtxDma                         _nv_rmsym_00663
#define class046SetLUTValues                         _nv_rmsym_00664
#define class046SetNotify                            _nv_rmsym_00665
#define class046SetNotifyCtxDma                      _nv_rmsym_00666
#define class046StopCursorImage                      _nv_rmsym_00667
#define class046StopDAC                              _nv_rmsym_00668
#define class046StopImage                            _nv_rmsym_00669
#define class046StopLUT                              _nv_rmsym_00670
#define class047GetExceptionData_NV04                _nv_rmsym_00671
#define class047GetOffset                            _nv_rmsym_00672
#define class047InitXfer_NV04                        _nv_rmsym_00673
#define class047KickoffBuffer_NV04                   _nv_rmsym_00674
#define class047Method_NV04                          _nv_rmsym_00675
#define class047Method_NV10                          _nv_rmsym_00676
#define class047Service_NV04                         _nv_rmsym_00677
#define class047SetNotify                            _nv_rmsym_00678
#define class047SetNotifyCtxDma                      _nv_rmsym_00679
#define class047SetOverlayCtxDma                     _nv_rmsym_00680
#define class047SetOverlayPointOutNow                _nv_rmsym_00681
#define class047SetOverlayValues                     _nv_rmsym_00682
#define class047StartXfer_NV04                       _nv_rmsym_00683
#define class047StopOverlay                          _nv_rmsym_00684
#define class047StopOverlayNow                       _nv_rmsym_00685
#define class048SetContextClip                       _nv_rmsym_00686
#define class048SetContextSurfaceColor               _nv_rmsym_00687
#define class048SetContextSurfaceZeta                _nv_rmsym_00688
#define class048Validate                             _nv_rmsym_00689
#define class049CursorImageNotify                    _nv_rmsym_00690
#define class049GetOffset                            _nv_rmsym_00691
#define class049ImageNotify                          _nv_rmsym_00692
#define class049ProgramLUT                           _nv_rmsym_00693
#define class049SetCursorCtxDma                      _nv_rmsym_00694
#define class049SetCursorImageValues                 _nv_rmsym_00695
#define class049SetCursorPoint                       _nv_rmsym_00696
#define class049SetDACValues                         _nv_rmsym_00697
#define class049SetImageCtxDma                       _nv_rmsym_00698
#define class049SetImageValues                       _nv_rmsym_00699
#define class049SetLUTCtxDma                         _nv_rmsym_00700
#define class049SetLUTValues                         _nv_rmsym_00701
#define class049SetNotify                            _nv_rmsym_00702
#define class049SetNotifyCtxDma                      _nv_rmsym_00703
#define class049StopCursorImage                      _nv_rmsym_00704
#define class049StopDAC                              _nv_rmsym_00705
#define class049StopImage                            _nv_rmsym_00706
#define class049StopLUT                              _nv_rmsym_00707
#define class04ASetContextBeta1                      _nv_rmsym_00708
#define class04ASetContextBeta4                      _nv_rmsym_00709
#define class04ASetContextPattern                    _nv_rmsym_00710
#define class04ASetContextRop                        _nv_rmsym_00711
#define class04ASetContextSurface                    _nv_rmsym_00712
#define class04ASetOperation                         _nv_rmsym_00713
#define class04AValidate                             _nv_rmsym_00714
#define class04BSetContextBeta1                      _nv_rmsym_00715
#define class04BSetContextPattern                    _nv_rmsym_00716
#define class04BSetContextRop                        _nv_rmsym_00717
#define class04BSetContextSurface                    _nv_rmsym_00718
#define class04BSetOperation                         _nv_rmsym_00719
#define class04BValidate                             _nv_rmsym_00720
#define class04DCalculateScaleIncrement              _nv_rmsym_00721
#define class04DFindNearestScaleFactor               _nv_rmsym_00722
#define class04DProgramWeights                       _nv_rmsym_00723
#define class04DStartImage                           _nv_rmsym_00724

#define class04DStartVbi                             _nv_rmsym_00726

#define class04EStartAudRead                         _nv_rmsym_00728
#define class04EStartRead                            _nv_rmsym_00729
#define class04EStartVidRead                         _nv_rmsym_00730
#define class04EStartWrite                           _nv_rmsym_00731
#define class050Create                               _nv_rmsym_00732
#define class050Destroy                              _nv_rmsym_00733
#define class050Notify                               _nv_rmsym_00734
#define class050Read                                 _nv_rmsym_00735
#define class050SetContextDmaNotifies                _nv_rmsym_00736
#define class050SetInterruptNotify                   _nv_rmsym_00737
#define class050StopTransfer                         _nv_rmsym_00738
#define class050Write                                _nv_rmsym_00739
#define class051Create                               _nv_rmsym_00740
#define class051Destroy                              _nv_rmsym_00741
#define class051Notify                               _nv_rmsym_00742
#define class051Read                                 _nv_rmsym_00743
#define class051SetContextDmaNotifies                _nv_rmsym_00744
#define class051SetInterruptNotify                   _nv_rmsym_00745
#define class051StopTransfer                         _nv_rmsym_00746
#define class051Write                                _nv_rmsym_00747
#define class053SetClipHorizontal                    _nv_rmsym_00748
#define class053SetClipVertical                      _nv_rmsym_00749
#define class05CSetContextBeta1                      _nv_rmsym_00750
#define class05CSetContextBeta4                      _nv_rmsym_00751
#define class05CSetContextClip                       _nv_rmsym_00752
#define class05CSetContextPattern                    _nv_rmsym_00753
#define class05CSetContextRop                        _nv_rmsym_00754
#define class05CSetContextSurface                    _nv_rmsym_00755
#define class05CSetOperation                         _nv_rmsym_00756
#define class05CValidate                             _nv_rmsym_00757
#define class05DSetContextBeta1                      _nv_rmsym_00758
#define class05DSetContextBeta4                      _nv_rmsym_00759
#define class05DSetContextClip                       _nv_rmsym_00760
#define class05DSetContextPattern                    _nv_rmsym_00761
#define class05DSetContextRop                        _nv_rmsym_00762
#define class05DSetContextSurface                    _nv_rmsym_00763
#define class05DSetOperation                         _nv_rmsym_00764
#define class05DValidate                             _nv_rmsym_00765
#define class05ESetContextBeta1                      _nv_rmsym_00766
#define class05ESetContextBeta4                      _nv_rmsym_00767
#define class05ESetContextClip                       _nv_rmsym_00768
#define class05ESetContextPattern                    _nv_rmsym_00769
#define class05ESetContextRop                        _nv_rmsym_00770
#define class05ESetContextSurface                    _nv_rmsym_00771
#define class05ESetOperation                         _nv_rmsym_00772
#define class05EValidate                             _nv_rmsym_00773
#define class05FSetContextBeta1                      _nv_rmsym_00774
#define class05FSetContextBeta4                      _nv_rmsym_00775
#define class05FSetContextClip                       _nv_rmsym_00776
#define class05FSetContextColorKey                   _nv_rmsym_00777
#define class05FSetContextPattern                    _nv_rmsym_00778
#define class05FSetContextRop                        _nv_rmsym_00779
#define class05FSetContextSurfaces2d                 _nv_rmsym_00780
#define class05FSetOperation                         _nv_rmsym_00781
#define class05FValidate                             _nv_rmsym_00782
#define class060SetColorConversion                   _nv_rmsym_00783
#define class060SetContextBeta1                      _nv_rmsym_00784
#define class060SetContextBeta4                      _nv_rmsym_00785
#define class060SetContextClip                       _nv_rmsym_00786
#define class060SetContextColorKey                   _nv_rmsym_00787
#define class060SetContextPattern                    _nv_rmsym_00788
#define class060SetContextRop                        _nv_rmsym_00789
#define class060SetContextSurface                    _nv_rmsym_00790
#define class060SetOperation                         _nv_rmsym_00791
#define class060Validate                             _nv_rmsym_00792
#define class061SetContextBeta1                      _nv_rmsym_00793
#define class061SetContextBeta4                      _nv_rmsym_00794
#define class061SetContextClip                       _nv_rmsym_00795
#define class061SetContextColorKey                   _nv_rmsym_00796
#define class061SetContextPattern                    _nv_rmsym_00797
#define class061SetContextRop                        _nv_rmsym_00798
#define class061SetContextSurface                    _nv_rmsym_00799
#define class061SetOperation                         _nv_rmsym_00800
#define class061Validate                             _nv_rmsym_00801
#define class063SetColorConversion                   _nv_rmsym_00802
#define class063SetContextBeta1                      _nv_rmsym_00803
#define class063SetContextBeta4                      _nv_rmsym_00804
#define class063SetContextColorKey                   _nv_rmsym_00805
#define class063SetContextPattern                    _nv_rmsym_00806
#define class063SetContextRop                        _nv_rmsym_00807
#define class063SetContextSurface                    _nv_rmsym_00808
#define class063SetOperation                         _nv_rmsym_00809
#define class063Validate                             _nv_rmsym_00810
#define class064SetColorConversion                   _nv_rmsym_00811
#define class064SetContextBeta1                      _nv_rmsym_00812
#define class064SetContextBeta4                      _nv_rmsym_00813
#define class064SetContextClip                       _nv_rmsym_00814
#define class064SetContextColorKey                   _nv_rmsym_00815
#define class064SetContextPattern                    _nv_rmsym_00816
#define class064SetContextRop                        _nv_rmsym_00817
#define class064SetContextSurface                    _nv_rmsym_00818
#define class064SetOperation                         _nv_rmsym_00819
#define class064Validate                             _nv_rmsym_00820
#define class065SetColorConversion                   _nv_rmsym_00821
#define class065SetContextBeta1                      _nv_rmsym_00822
#define class065SetContextBeta4                      _nv_rmsym_00823
#define class065SetContextClip                       _nv_rmsym_00824
#define class065SetContextColorKey                   _nv_rmsym_00825
#define class065SetContextPattern                    _nv_rmsym_00826
#define class065SetContextRop                        _nv_rmsym_00827
#define class065SetContextSurface                    _nv_rmsym_00828
#define class065SetOperation                         _nv_rmsym_00829
#define class065Validate                             _nv_rmsym_00830
#define class066SetColorConversion                   _nv_rmsym_00831
#define class066SetContextBeta1                      _nv_rmsym_00832
#define class066SetContextBeta4                      _nv_rmsym_00833
#define class066SetContextColorKey                   _nv_rmsym_00834
#define class066SetContextPattern                    _nv_rmsym_00835
#define class066SetContextRop                        _nv_rmsym_00836
#define class066SetContextSurface                    _nv_rmsym_00837
#define class066SetOperation                         _nv_rmsym_00838
#define class066Validate                             _nv_rmsym_00839
#define class067CursorImageNotify                    _nv_rmsym_00840
#define class067GetOffset                            _nv_rmsym_00841
#define class067ImageNotify                          _nv_rmsym_00842
#define class067ProgramLUT                           _nv_rmsym_00843
#define class067SetCursorCtxDma                      _nv_rmsym_00844
#define class067SetCursorImageValues                 _nv_rmsym_00845
#define class067SetCursorPoint                       _nv_rmsym_00846
#define class067SetDACValues                         _nv_rmsym_00847
#define class067SetImageCtxDma                       _nv_rmsym_00848
#define class067SetImageValues                       _nv_rmsym_00849
#define class067SetLUTCtxDma                         _nv_rmsym_00850
#define class067SetLUTValues                         _nv_rmsym_00851
#define class067SetNotify                            _nv_rmsym_00852
#define class067SetNotifyCtxDma                      _nv_rmsym_00853
#define class067StopCursorImage                      _nv_rmsym_00854
#define class067StopDAC                              _nv_rmsym_00855
#define class067StopImage                            _nv_rmsym_00856
#define class067StopLUT                              _nv_rmsym_00857
#define class076SetContextBeta1                      _nv_rmsym_00858
#define class076SetContextBeta4                      _nv_rmsym_00859
#define class076SetContextColorKey                   _nv_rmsym_00860
#define class076SetContextPattern                    _nv_rmsym_00861
#define class076SetContextRop                        _nv_rmsym_00862
#define class076SetContextSurface                    _nv_rmsym_00863
#define class076SetOperation                         _nv_rmsym_00864
#define class076Validate                             _nv_rmsym_00865
#define class077SetContextBeta1                      _nv_rmsym_00866
#define class077SetContextBeta4                      _nv_rmsym_00867
#define class077SetContextColorKey                   _nv_rmsym_00868
#define class077SetContextPattern                    _nv_rmsym_00869
#define class077SetContextRop                        _nv_rmsym_00870
#define class077SetContextSurface                    _nv_rmsym_00871
#define class077SetOperation                         _nv_rmsym_00872
#define class077Validate                             _nv_rmsym_00873
#define class07AGetOffset                            _nv_rmsym_00874
#define class07ASetNotify                            _nv_rmsym_00875
#define class07ASetNotifyCtxDma                      _nv_rmsym_00876
#define class07ASetOverlayChrominanceNow             _nv_rmsym_00877
#define class07ASetOverlayCtxDma                     _nv_rmsym_00878
#define class07ASetOverlayLuminanceNow               _nv_rmsym_00879
#define class07ASetOverlayPointOutNow                _nv_rmsym_00880
#define class07ASetOverlayValues                     _nv_rmsym_00881
#define class07AStopOverlay                          _nv_rmsym_00882
#define class07CCursorImageNotify                    _nv_rmsym_00883
#define class07CGetOffset                            _nv_rmsym_00884
#define class07CImageNotify                          _nv_rmsym_00885
#define class07CProgramLUT                           _nv_rmsym_00886
#define class07CSetCursorCtxDma                      _nv_rmsym_00887
#define class07CSetCursorImageValues                 _nv_rmsym_00888
#define class07CSetCursorPoint                       _nv_rmsym_00889
#define class07CSetDACValues                         _nv_rmsym_00890
#define class07CSetImageCtxDma                       _nv_rmsym_00891
#define class07CSetImageValues                       _nv_rmsym_00892
#define class07CSetLUTCtxDma                         _nv_rmsym_00893
#define class07CSetLUTValues                         _nv_rmsym_00894
#define class07CSetNotify                            _nv_rmsym_00895
#define class07CSetNotifyCtxDma                      _nv_rmsym_00896
#define class07CSetOffsetRange                       _nv_rmsym_00897
#define class07CStopCursorImage                      _nv_rmsym_00898
#define class07CStopDAC                              _nv_rmsym_00899
#define class07CStopImage                            _nv_rmsym_00900
#define class07CStopLUT                              _nv_rmsym_00901
#define class07aMethod_NV10                          _nv_rmsym_00902
#define class63ColorKey_NV04                         _nv_rmsym_00903
#define class63ColorKey_NV10                         _nv_rmsym_00904
#define class63DualSurfaceDesktop_NV04               _nv_rmsym_00905
#define class63DualSurfaceDesktop_NV10               _nv_rmsym_00906
#define class63DualSurface_NV04                      _nv_rmsym_00907
#define class63DualSurface_NV10                      _nv_rmsym_00908
#define class63GetExceptionData_NV04                 _nv_rmsym_00909
#define class63GetOffsetNotify                       _nv_rmsym_00910
#define class63ImageScan                             _nv_rmsym_00911
#define class63InitXfer_NV04                         _nv_rmsym_00912
#define class63InitXfer_NV10                         _nv_rmsym_00913
#define class63KickoffBuffer_NV04                    _nv_rmsym_00914
#define class63Method_NV04                           _nv_rmsym_00915
#define class63Method_NV10                           _nv_rmsym_00916
#define class63Service_NV04                          _nv_rmsym_00917
#define class63SetImageCtxDma                        _nv_rmsym_00918
#define class63SetNotify                             _nv_rmsym_00919
#define class63SetNotifyCtxDma                       _nv_rmsym_00920
#define class63SetVideoOutput                        _nv_rmsym_00921
#define class63StartXfer_NV04                        _nv_rmsym_00922
#define class63StartXfer_NV10                        _nv_rmsym_00923
#define class63StopTransfer                          _nv_rmsym_00924
#define class63VBlank                                _nv_rmsym_00925
#define class63WaitVBlank                            _nv_rmsym_00926
#define class63XferComplete                          _nv_rmsym_00927
#define class64Method_NV04                           _nv_rmsym_00928
#define class64Method_NV10                           _nv_rmsym_00929
#define class64SetDeltaDuDx                          _nv_rmsym_00930
#define class64SetDeltaDvDy                          _nv_rmsym_00931
#define class64SetNotify                             _nv_rmsym_00932
#define class64SetNotifyCtxDma                       _nv_rmsym_00933
#define class64SetPoint                              _nv_rmsym_00934
#define class64SetVideoInput                         _nv_rmsym_00935
#define class64SetVideoOutput                        _nv_rmsym_00936
#define class65Method_NV04                           _nv_rmsym_00937
#define class65Method_NV10                           _nv_rmsym_00938
#define class65SetColorFormat                        _nv_rmsym_00939
#define class65SetColorKey                           _nv_rmsym_00940
#define class65SetNotify                             _nv_rmsym_00941
#define class65SetNotifyCtxDma                       _nv_rmsym_00942
#define class65SetPoint                              _nv_rmsym_00943
#define class65SetSize                               _nv_rmsym_00944
#define class65SetVideoInput                         _nv_rmsym_00945
#define class65SetVideoOutput                        _nv_rmsym_00946
#define classAddZombie                               _nv_rmsym_00947
#define classBuildDB                                 _nv_rmsym_00948
#define classCreate                                  _nv_rmsym_00949
#define classCreateWellKnownObjects                  _nv_rmsym_00950
#define classDeleteWellKnownObjects                  _nv_rmsym_00951
#define classDestroy                                 _nv_rmsym_00952
#define classDestroyDB                               _nv_rmsym_00953
#define classGetClass                                _nv_rmsym_00954
#define classGetInfo                                 _nv_rmsym_00955
#define classInitCommonObject                        _nv_rmsym_00956
#define classMethodsTable                            _nv_rmsym_00957
#define classSoftwareMethod                          _nv_rmsym_00958
#define clientHandle                                 _nv_rmsym_00959
#define clientInfo                                   _nv_rmsym_00960
#define clientInfoSelector                           _nv_rmsym_00961
#define clientSize                                   _nv_rmsym_00962
#define dac128Name                                   _nv_rmsym_00963
#define dac16Name                                    _nv_rmsym_00964
#define dac32Name                                    _nv_rmsym_00965
#define dac64Name                                    _nv_rmsym_00966
#define dacAdjustCRTCForFlatPanel                    _nv_rmsym_00967
#define dacAdjustCRTCForTV                           _nv_rmsym_00968
#define dacCalcMNP                                   _nv_rmsym_00969
#define dacCalcPLL                                   _nv_rmsym_00970
#define dacCalculateArbitration                      _nv_rmsym_00971
#define dacCreateObj                                 _nv_rmsym_00972
#define dacDestroyObj                                _nv_rmsym_00973
#define dacDetectTrigger                             _nv_rmsym_00974
#define dacDisableCursor                             _nv_rmsym_00975
#define dacEnableCursor                              _nv_rmsym_00976
#define dacFlatPanelConnectStatus                    _nv_rmsym_00977
#define dacGetDefaultTVPosition                      _nv_rmsym_00978
#define dacGetDisplayType                            _nv_rmsym_00979
#define dacGetFlatPanelConfig                        _nv_rmsym_00980
#define dacGetFlatPanelInfo                          _nv_rmsym_00981
#define dacGetI2CModeString                          _nv_rmsym_00982
#define dacGetMonitorDefaultPosition                 _nv_rmsym_00983
#define dacGetMonitorInfo                            _nv_rmsym_00984
#define dacGetTVAdjustTableArray                     _nv_rmsym_00985
#define dacGetTVAdjustTableEntry                     _nv_rmsym_00986
#define dacGetTVmode                                 _nv_rmsym_00987
#define dacLoadColor256DAC                           _nv_rmsym_00988
#define dacLoadColorDACTable                         _nv_rmsym_00989
#define dacLoadIdentityDAC                           _nv_rmsym_00990
#define dacLoadIndexRange                            _nv_rmsym_00991
#define dacLoadPalette                               _nv_rmsym_00992
#define dacLoadWidthDepth                            _nv_rmsym_00993
#define dacMonitorConnectStatus                      _nv_rmsym_00994
#define dacProgramBrooktree                          _nv_rmsym_00995
#define dacProgramCRTC                               _nv_rmsym_00996
#define dacProgramChrontel                           _nv_rmsym_00997
#define dacProgramCursorPosition                     _nv_rmsym_00998
#define dacProgramCustomCRTC                         _nv_rmsym_00999
#define dacProgramDefaultCRTC                        _nv_rmsym_01000
#define dacProgramLUT                                _nv_rmsym_01001
#define dacProgramScanRegion                         _nv_rmsym_01002
#define dacProgramVideoStart                         _nv_rmsym_01003
#define dacReadBIOSI2CSettings                       _nv_rmsym_01004
#define dacReadDesktopPositionFromRegistry           _nv_rmsym_01005
#define dacReadDisplayTypeFromRegistry               _nv_rmsym_01006
#define dacReadTVDesktopPositionFromRegistry         _nv_rmsym_01007
#define dacReadTVOutFromRegistry                     _nv_rmsym_01008
#define dacReadTVTypeFromRegistry                    _nv_rmsym_01009
#define dacSaveMonitorDefaultPosition                _nv_rmsym_01010
#define dacSetCursorBlink                            _nv_rmsym_01011
#define dacSetDpmLevel                               _nv_rmsym_01012
#define dacSetFan                                    _nv_rmsym_01013
#define dacSetFlatPanelMode                          _nv_rmsym_01014
#define dacSetMonitorPosition                        _nv_rmsym_01015
#define dacSetTVPosition                             _nv_rmsym_01016
#define dacSetupTVEncoder                            _nv_rmsym_01017
#define dacTVConnectStatus                           _nv_rmsym_01018
#define dacTransferFromBIOSCopy                      _nv_rmsym_01019
#define dacVBlank                                    _nv_rmsym_01020
#define dacWriteColor                                _nv_rmsym_01021
#define dacWriteColor2                               _nv_rmsym_01022
#define dacWriteDesktopPositionToRegistry            _nv_rmsym_01023
#define dacWriteDisplayTypeToRegistry                _nv_rmsym_01024
#define dacWriteTVOutToRegistry                      _nv_rmsym_01025
#define dacWriteTVTypeToRegistry                     _nv_rmsym_01026
#define dbgDumpHeap                                  _nv_rmsym_01027
#define dbgDumpMTRRs                                 _nv_rmsym_01028
#define destroyHal                                   _nv_rmsym_01029
#define disableCursor                                _nv_rmsym_01030
#define dmaAllocInstance                             _nv_rmsym_01031
#define dmaAllocate                                  _nv_rmsym_01032
#define dmaBindToChannel                             _nv_rmsym_01033
#define dmaContextInstanceToObject                   _nv_rmsym_01034
#define dmaCreate                                    _nv_rmsym_01035
#define dmaDeallocate                                _nv_rmsym_01036
#define dmaDelete                                    _nv_rmsym_01037
#define dmaFindContext                               _nv_rmsym_01038
#define dmaFreeInstance                              _nv_rmsym_01039
#define dmaGetMappedAddress                          _nv_rmsym_01040
#define dmaHalInstanceToHalInfo_NV04                 _nv_rmsym_01041
#define dmaHalInstanceToHalInfo_NV10                 _nv_rmsym_01042
#define dmaListElementPool                           _nv_rmsym_01043
#define dmaRegisterToDevice                          _nv_rmsym_01044
#define dmaSetBufferCtxDma                           _nv_rmsym_01045
#define dmaSetBufferLength                           _nv_rmsym_01046
#define dmaSetBufferPitch                            _nv_rmsym_01047
#define dmaSetBufferStart                            _nv_rmsym_01048
#define dmaUnbindFromChannel                         _nv_rmsym_01049
#define dmaUnregisterFromDevice                      _nv_rmsym_01050
#define dmaValidateObjectName                        _nv_rmsym_01051
#define dmaValidateXlate                             _nv_rmsym_01052
#define edidGetVersion                               _nv_rmsym_01053
#define edidIsAnalogDisplay                          _nv_rmsym_01054
#define edidParseDetailed1                           _nv_rmsym_01055
#define edidParseDetailed2                           _nv_rmsym_01056
#define edidParseDetailedTimingBlock                 _nv_rmsym_01057
#define enableCursor                                 _nv_rmsym_01058
#define engineGetBufferSize                          _nv_rmsym_01059
#define engineGetInfo                                _nv_rmsym_01060
#define engineGetInstMemSize                         _nv_rmsym_01061
#define eventRemoveObjectEventNotify                 _nv_rmsym_01062
#define eventSetEventNotify                          _nv_rmsym_01063
#define eventSetObjectEventNotify                    _nv_rmsym_01064
#define fbAllocInstMem                               _nv_rmsym_01065
#define fbAllocInstMemAlign                          _nv_rmsym_01066
#define fbCalcScreenMemSize                          _nv_rmsym_01067
#define fbFreeInstMem                                _nv_rmsym_01068
#define fbInitializeInstMemBitMap                    _nv_rmsym_01069
#define fbService                                    _nv_rmsym_01070
#define fifoAddHashEntry                             _nv_rmsym_01071
#define fifoAddObject                                _nv_rmsym_01072
#define fifoAlloc                                    _nv_rmsym_01073
#define fifoAllocDma                                 _nv_rmsym_01074
#define fifoDelHashEntry                             _nv_rmsym_01075
#define fifoDelObject                                _nv_rmsym_01076
#define fifoDeleteObjectInstance                     _nv_rmsym_01077
#define fifoEnumObjects                              _nv_rmsym_01078
#define fifoFree                                     _nv_rmsym_01079
#define fifoResend                                   _nv_rmsym_01080
#define fifoResetChannelState                        _nv_rmsym_01081
#define fifoSearchObject                             _nv_rmsym_01082
#define fifoService                                  _nv_rmsym_01083
#define fifoSoftwareMethod                           _nv_rmsym_01084
#define fifoUpdateObjectInstance                     _nv_rmsym_01085
#define fifolog                                      _nv_rmsym_01086
#define findex                                       _nv_rmsym_01087
#define fpParseEDID                                  _nv_rmsym_01088
#define getI2CPort                                   _nv_rmsym_01089
#define get_winice_input                             _nv_rmsym_01090
#define grCancelVBlank                               _nv_rmsym_01091
#define grContextInstanceToObject                    _nv_rmsym_01092
#define grCreateObj                                  _nv_rmsym_01093
#define grCreateOrdinal                              _nv_rmsym_01094
#define grCreateVideoColormap                        _nv_rmsym_01095
#define grCreateVideoPatchcord                       _nv_rmsym_01096
#define grCreateVideoSink                            _nv_rmsym_01097
#define grDefaultMethods                             _nv_rmsym_01098
#define grDeleteObjectInstance                       _nv_rmsym_01099
#define grDeleteOrdinal                              _nv_rmsym_01100
#define grDeleteVideoColormap                        _nv_rmsym_01101
#define grDeleteVideoPatchcord                       _nv_rmsym_01102
#define grDeleteVideoSink                            _nv_rmsym_01103
#define grDestroyObj                                 _nv_rmsym_01104
#define grGetLastIllegalMthdObject                   _nv_rmsym_01105
#define grHWMethod                                   _nv_rmsym_01106
#define grInitCommon                                 _nv_rmsym_01107
#define grInitPipeContextAddr                        _nv_rmsym_01108
#define grInitRenderCommon                           _nv_rmsym_01109
#define grInvalidateVideoPatchcord                   _nv_rmsym_01110
#define grIsRenderObject                             _nv_rmsym_01111
#define grLoadPipeContext                            _nv_rmsym_01112
#define grResubmitVertexContextDma                   _nv_rmsym_01113
#define grService                                    _nv_rmsym_01114
#define grSetLastIllegalMthdObject                   _nv_rmsym_01115
#define grUnloadPipeContext                          _nv_rmsym_01116
#define grVBlank                                     _nv_rmsym_01117
#define grValidateVideoPatchcord                     _nv_rmsym_01118
#define grVideoSwitchComplete                        _nv_rmsym_01119
#define grWaitVBlank                                 _nv_rmsym_01120
#define heapAlloc                                    _nv_rmsym_01121
#define heapCompact                                  _nv_rmsym_01122
#define heapCreate                                   _nv_rmsym_01123
#define heapDestroy                                  _nv_rmsym_01124
#define heapDump                                     _nv_rmsym_01125
#define heapFree                                     _nv_rmsym_01126
#define heapGetBase                                  _nv_rmsym_01127
#define heapGetFree                                  _nv_rmsym_01128
#define heapGetMaxFree                               _nv_rmsym_01129
#define heapGetSize                                  _nv_rmsym_01130
#define heapInfo                                     _nv_rmsym_01131
#define heapPurge                                    _nv_rmsym_01132
#define heapValidate                                 _nv_rmsym_01133
#define i2cAccess                                    _nv_rmsym_01134
#define i2cAck                                       _nv_rmsym_01135
#define i2cHardwareInit                              _nv_rmsym_01136
#define i2cInit                                      _nv_rmsym_01137
#define i2cRead                                      _nv_rmsym_01138
#define i2cReadCRTCStatusIndex                       _nv_rmsym_01139
#define i2cReadCRTCWrIndex                           _nv_rmsym_01140
#define i2cReadCtrl                                  _nv_rmsym_01141
#define i2cRead_ALT                                  _nv_rmsym_01142
#define i2cRead_ALT2                                 _nv_rmsym_01143
#define i2cReceiveByte                               _nv_rmsym_01144
#define i2cSend                                      _nv_rmsym_01145
#define i2cSendByte                                  _nv_rmsym_01146
#define i2cStart                                     _nv_rmsym_01147
#define i2cStop                                      _nv_rmsym_01148
#define i2cWrite                                     _nv_rmsym_01149
#define i2cWriteCRTCWrIndex                          _nv_rmsym_01150
#define i2cWriteCtrl                                 _nv_rmsym_01151
#define i2cWrite_ALT                                 _nv_rmsym_01152
#define initClientInfo                               _nv_rmsym_01153
#define initDac                                      _nv_rmsym_01154
#define initDacEx                                    _nv_rmsym_01155
#define initDisplayInfo                              _nv_rmsym_01156
#define initDmaListElementPool                       _nv_rmsym_01157
#define initFb                                       _nv_rmsym_01158
#define initFbEx                                     _nv_rmsym_01159
#define initFifo                                     _nv_rmsym_01160
#define initFifoEx                                   _nv_rmsym_01161
#define initGrEx                                     _nv_rmsym_01162
#define initHal                                      _nv_rmsym_01163
#define initMapping                                  _nv_rmsym_01164
#define initMc                                       _nv_rmsym_01165
#define initRModeEx                                  _nv_rmsym_01166
#define initTmr                                      _nv_rmsym_01167
#define init_COMPUTE_Memory                          _nv_rmsym_01168
#define init_CONFIGURE_Clocks                        _nv_rmsym_01169
#define init_CONFIGURE_Memory                        _nv_rmsym_01170
#define init_CONFIGURE_PreInit                       _nv_rmsym_01171
#define init_INDEX_IO_Write                          _nv_rmsym_01172
#define init_MEM_RESTRICT_SCRIPT                     _nv_rmsym_01173
#define init_NV                                      _nv_rmsym_01174
#define init_PLL_Values                              _nv_rmsym_01175
#define init_Reset_Chip                              _nv_rmsym_01176
#define init_STRAP_RESTRICT_SCRIPT                   _nv_rmsym_01177
#define init_TIME_Delay                              _nv_rmsym_01178
#define init_ZM                                      _nv_rmsym_01179
#define init_ZMW                                     _nv_rmsym_01180
#define mcService                                    _nv_rmsym_01181
#define mcSetBiosRevision                            _nv_rmsym_01182
#define memTypeFlags                                 _nv_rmsym_01183
#define mpCreateObj                                  _nv_rmsym_01184
#define mpDestroyObj                                 _nv_rmsym_01185
#define mthdColormapDirtyLength                      _nv_rmsym_01186
#define mthdColormapDirtyNotify                      _nv_rmsym_01187
#define mthdColormapDirtyStart                       _nv_rmsym_01188
#define mthdCreate                                   _nv_rmsym_01189
#define mthdDestroy                                  _nv_rmsym_01190
#define mthdNoOperation                              _nv_rmsym_01191
#define mthdSetAlarmNotify                           _nv_rmsym_01192
#define mthdSetAlarmNotifyCtxDma                     _nv_rmsym_01193
#define mthdSetAlarmTime                             _nv_rmsym_01194
#define mthdSetBufferCtxDma                          _nv_rmsym_01195
#define mthdSetBufferLength                          _nv_rmsym_01196
#define mthdSetBufferNotify                          _nv_rmsym_01197
#define mthdSetBufferNotifyCount                     _nv_rmsym_01198
#define mthdSetBufferNotifyCtxDma                    _nv_rmsym_01199
#define mthdSetBufferPitch                           _nv_rmsym_01200
#define mthdSetBufferPosNotify                       _nv_rmsym_01201
#define mthdSetBufferPosNotifyCtxDma                 _nv_rmsym_01202
#define mthdSetBufferStart                           _nv_rmsym_01203
#define mthdSetColormapCtxDma                        _nv_rmsym_01204
#define mthdSetColormapFormat                        _nv_rmsym_01205
#define mthdSetColormapLength                        _nv_rmsym_01206
#define mthdSetColormapStart                         _nv_rmsym_01207
#define mthdSetDmaSpecifier                          _nv_rmsym_01208
#define mthdSetNotify                                _nv_rmsym_01209
#define mthdSetNotifyCtxDma                          _nv_rmsym_01210
#define mthdSetNumberChannels                        _nv_rmsym_01211
#define mthdSetObject                                _nv_rmsym_01212
#define mthdSetSampleRate                            _nv_rmsym_01213
#define mthdSetSampleRateAdjust                      _nv_rmsym_01214
#define mthdSetTime                                  _nv_rmsym_01215
#define mthdSetVideoInput                            _nv_rmsym_01216
#define mthdSetVideoOutput                           _nv_rmsym_01217

#define nopCreate                                    _nv_rmsym_01219
#define nopDelete                                    _nv_rmsym_01220
#define notifyBufferComplete                         _nv_rmsym_01221
#define notifyBufferHWComplete                       _nv_rmsym_01222
#define notifyDefaultError                           _nv_rmsym_01223
#define notifyFillNotifier                           _nv_rmsym_01224
#define notifyFillNotifierArray                      _nv_rmsym_01225
#define notifyMethodComplete                         _nv_rmsym_01226
#define notifySetBufferNotify                        _nv_rmsym_01227
#define notifySetBufferNotifyCtxDma                  _nv_rmsym_01228
#define nvClassEngineDescriptor                      _nv_rmsym_01229

#define nvHalDacAlloc                                _nv_rmsym_01231
#define nvHalDacAlloc_NV04                           _nv_rmsym_01232
#define nvHalDacAlloc_NV10                           _nv_rmsym_01233
#define nvHalDacControl                              _nv_rmsym_01234
#define nvHalDacControl_NV04                         _nv_rmsym_01235
#define nvHalDacControl_NV10                         _nv_rmsym_01236
#define nvHalDacFree                                 _nv_rmsym_01237
#define nvHalDacFree_NV04                            _nv_rmsym_01238
#define nvHalDacFree_NV10                            _nv_rmsym_01239
#define nvHalDacSetStartAddr                         _nv_rmsym_01240
#define nvHalDacSetStartAddr_NV04                    _nv_rmsym_01241
#define nvHalDacSetStartAddr_NV10                    _nv_rmsym_01242
#define nvHalDmaAlloc                                _nv_rmsym_01243
#define nvHalDmaAlloc_NV04                           _nv_rmsym_01244
#define nvHalDmaAlloc_NV10                           _nv_rmsym_01245
#define nvHalDmaControl                              _nv_rmsym_01246
#define nvHalDmaControl_NV04                         _nv_rmsym_01247
#define nvHalDmaControl_NV10                         _nv_rmsym_01248
#define nvHalDmaFree                                 _nv_rmsym_01249
#define nvHalDmaFree_NV04                            _nv_rmsym_01250
#define nvHalDmaFree_NV10                            _nv_rmsym_01251
#define nvHalDmaGetInstSize                          _nv_rmsym_01252
#define nvHalDmaGetInstSize_NV04                     _nv_rmsym_01253
#define nvHalDmaGetInstSize_NV10                     _nv_rmsym_01254
#define nvHalFbAlloc                                 _nv_rmsym_01255
#define nvHalFbAlloc_NV04                            _nv_rmsym_01256
#define nvHalFbAlloc_NV10                            _nv_rmsym_01257
#define nvHalFbControl                               _nv_rmsym_01258
#define nvHalFbControl_NV04                          _nv_rmsym_01259
#define nvHalFbControl_NV10                          _nv_rmsym_01260
#define nvHalFbFree                                  _nv_rmsym_01261
#define nvHalFbFree_NV04                             _nv_rmsym_01262
#define nvHalFbFree_NV10                             _nv_rmsym_01263
#define nvHalFbGetSurfacePitch                       _nv_rmsym_01264
#define nvHalFbGetSurfacePitch_NV04                  _nv_rmsym_01265
#define nvHalFbGetSurfacePitch_NV10                  _nv_rmsym_01266
#define nvHalFbRoundToTiledPitch_NV10                _nv_rmsym_01267
#define nvHalFbSetAllocParameters                    _nv_rmsym_01268
#define nvHalFbSetAllocParameters_NV04               _nv_rmsym_01269
#define nvHalFbSetAllocParameters_NV10               _nv_rmsym_01270
#define nvHalFifoAccess                              _nv_rmsym_01271
#define nvHalFifoAccess_NV04                         _nv_rmsym_01272
#define nvHalFifoAccess_NV10                         _nv_rmsym_01273
#define nvHalFifoAllocDma                            _nv_rmsym_01274
#define nvHalFifoAllocDma_NV04                       _nv_rmsym_01275
#define nvHalFifoAllocDma_NV10                       _nv_rmsym_01276
#define nvHalFifoAllocPio                            _nv_rmsym_01277
#define nvHalFifoAllocPio_NV04                       _nv_rmsym_01278
#define nvHalFifoAllocPio_NV10                       _nv_rmsym_01279
#define nvHalFifoContextSwitch_NV04                  _nv_rmsym_01280
#define nvHalFifoContextSwitch_NV10                  _nv_rmsym_01281
#define nvHalFifoControl                             _nv_rmsym_01282
#define nvHalFifoControl_NV04                        _nv_rmsym_01283
#define nvHalFifoControl_NV10                        _nv_rmsym_01284
#define nvHalFifoFree                                _nv_rmsym_01285
#define nvHalFifoFree_NV04                           _nv_rmsym_01286
#define nvHalFifoFree_NV10                           _nv_rmsym_01287
#define nvHalFifoGetExceptionData                    _nv_rmsym_01288
#define nvHalFifoGetExceptionData_NV04               _nv_rmsym_01289
#define nvHalFifoGetExceptionData_NV10               _nv_rmsym_01290
#define nvHalFifoHashAdd                             _nv_rmsym_01291
#define nvHalFifoHashAdd_NV04                        _nv_rmsym_01292
#define nvHalFifoHashAdd_NV10                        _nv_rmsym_01293
#define nvHalFifoHashDelete                          _nv_rmsym_01294
#define nvHalFifoHashDelete_NV04                     _nv_rmsym_01295
#define nvHalFifoHashDelete_NV10                     _nv_rmsym_01296
#define nvHalFifoHashFunc                            _nv_rmsym_01297
#define nvHalFifoHashFunc_NV04                       _nv_rmsym_01298
#define nvHalFifoHashFunc_NV10                       _nv_rmsym_01299
#define nvHalFifoService                             _nv_rmsym_01300
#define nvHalFifoService_NV04                        _nv_rmsym_01301
#define nvHalFifoService_NV10                        _nv_rmsym_01302
#define nvHalGrAlloc                                 _nv_rmsym_01303
#define nvHalGrAlloc_NV04                            _nv_rmsym_01304
#define nvHalGrAlloc_NV10                            _nv_rmsym_01305
#define nvHalGrControl                               _nv_rmsym_01306
#define nvHalGrControl_NV04                          _nv_rmsym_01307
#define nvHalGrControl_NV10                          _nv_rmsym_01308
#define nvHalGrFree                                  _nv_rmsym_01309
#define nvHalGrFree_NV04                             _nv_rmsym_01310
#define nvHalGrFree_NV10                             _nv_rmsym_01311
#define nvHalGrGetExceptionData                      _nv_rmsym_01312
#define nvHalGrGetExceptionData_NV04                 _nv_rmsym_01313
#define nvHalGrGetExceptionData_NV10                 _nv_rmsym_01314
#define nvHalGrGetNotifyData                         _nv_rmsym_01315
#define nvHalGrGetNotifyData_NV04                    _nv_rmsym_01316
#define nvHalGrGetNotifyData_NV10                    _nv_rmsym_01317
#define nvHalGrGetState_NV10                         _nv_rmsym_01318
#define nvHalGrLoadChannelContext_NV04               _nv_rmsym_01319
#define nvHalGrLoadChannelContext_NV10               _nv_rmsym_01320
#define nvHalGrMethods_NV04                          _nv_rmsym_01321
#define nvHalGrMethods_NV10                          _nv_rmsym_01322
#define nvHalGrPutState_NV10                         _nv_rmsym_01323
#define nvHalGrService                               _nv_rmsym_01324
#define nvHalGrService_NV04                          _nv_rmsym_01325
#define nvHalGrService_NV10                          _nv_rmsym_01326
#define nvHalGrSetMaterialEmission_NV10              _nv_rmsym_01327
#define nvHalGrSetObjectContext                      _nv_rmsym_01328
#define nvHalGrSetObjectContext_NV04                 _nv_rmsym_01329
#define nvHalGrSetObjectContext_NV10                 _nv_rmsym_01330
#define nvHalGrUnloadChannelContext_NV04             _nv_rmsym_01331
#define nvHalGrUnloadChannelContext_NV10             _nv_rmsym_01332
#define nvHalMcChipId                                _nv_rmsym_01333
#define nvHalMcChipId_NV04                           _nv_rmsym_01334
#define nvHalMcChipId_NV10                           _nv_rmsym_01335
#define nvHalMcControl                               _nv_rmsym_01336
#define nvHalMcControl_NV04                          _nv_rmsym_01337
#define nvHalMcControl_NV10                          _nv_rmsym_01338
#define nvHalMcPower                                 _nv_rmsym_01339
#define nvHalMcPower_NV04                            _nv_rmsym_01340
#define nvHalMcPower_NV10                            _nv_rmsym_01341
#define nvHalMpAlloc                                 _nv_rmsym_01342
#define nvHalMpAlloc_NV04                            _nv_rmsym_01343
#define nvHalMpAlloc_NV10                            _nv_rmsym_01344
#define nvHalMpControl                               _nv_rmsym_01345
#define nvHalMpControl_NV04                          _nv_rmsym_01346
#define nvHalMpControl_NV10                          _nv_rmsym_01347
#define nvHalMpFree                                  _nv_rmsym_01348
#define nvHalMpFree_NV04                             _nv_rmsym_01349
#define nvHalMpFree_NV10                             _nv_rmsym_01350
#define nvHalRmServiceIntr                           _nv_rmsym_01351
#define nvHalTetrisTileWrite_NV04                    _nv_rmsym_01352
#define nvHalTetrisTile_NV04                         _nv_rmsym_01353
#define nvHalVideoAlloc                              _nv_rmsym_01354
#define nvHalVideoAlloc_NV04                         _nv_rmsym_01355
#define nvHalVideoAlloc_NV10                         _nv_rmsym_01356
#define nvHalVideoControl                            _nv_rmsym_01357
#define nvHalVideoControl_NV04                       _nv_rmsym_01358
#define nvHalVideoControl_NV10                       _nv_rmsym_01359
#define nvHalVideoFree                               _nv_rmsym_01360
#define nvHalVideoFree_NV04                          _nv_rmsym_01361
#define nvHalVideoFree_NV10                          _nv_rmsym_01362
#define nvHalVideoGetExceptionData                   _nv_rmsym_01363
#define nvHalVideoGetExceptionData_NV04              _nv_rmsym_01364
#define nvHalVideoGetExceptionData_NV10              _nv_rmsym_01365
#define nvHalVideoMethod                             _nv_rmsym_01366
#define nvHalVideoMethod_NV04                        _nv_rmsym_01367
#define nvHalVideoMethod_NV10                        _nv_rmsym_01368
#define nvHalVideoService                            _nv_rmsym_01369
#define nvHalVideoService_NV04                       _nv_rmsym_01370
#define nvHalVideoService_NV10                       _nv_rmsym_01371
#define nvInfoSelector                               _nv_rmsym_01372
#define nvNoEngineDescriptor                         _nv_rmsym_01373


#define osAllocDmaListElement                        _nv_rmsym_01381
#define osAllocPages                                 _nv_rmsym_01382
#define osDeviceNameToDeviceClass                    _nv_rmsym_01383
#define osDisplayInfo                                _nv_rmsym_01384
#define osError                                      _nv_rmsym_01385
#define osFreeDmaListElement                         _nv_rmsym_01386
#define osFreePages                                  _nv_rmsym_01387
#define osInService                                  _nv_rmsym_01388
#define osIsr                                        _nv_rmsym_01389
#define osLockUserMem                                _nv_rmsym_01390
#define osMapFifo                                    _nv_rmsym_01391
#define osMapFrameBuffer                             _nv_rmsym_01392
#define osMapInstanceMemory                          _nv_rmsym_01393
#define osMapPciMemoryUser                           _nv_rmsym_01394
#define osNotifyAction                               _nv_rmsym_01395
#define osNotifyEvent                                _nv_rmsym_01396
#ifndef LINUX
#define osReadRegistryBinary                         _nv_rmsym_01397
#define osReadRegistryDword                          _nv_rmsym_01398
#endif
#define osSetVideoMode                               _nv_rmsym_01399
#define osStateFbEx                                  _nv_rmsym_01400
#define osUnlockUserMem                              _nv_rmsym_01401
#define osUnmapMemory                                _nv_rmsym_01402
#define osUnmapPciMemoryUser                         _nv_rmsym_01403
#define osVirtualToPhysicalAddr                      _nv_rmsym_01404
#ifndef LINUX
#define osWriteRegistryBinary                        _nv_rmsym_01405
#define osWriteRegistryDword                         _nv_rmsym_01406
#endif
#define pClient                                      _nv_rmsym_01407
#define rmInCallback                                 _nv_rmsym_01408
#define rmInSafeService                              _nv_rmsym_01409
#define rmInService                                  _nv_rmsym_01410
#define stateConfigGet                               _nv_rmsym_01411
#define stateConfigGetEx                             _nv_rmsym_01412
#define stateConfigSet                               _nv_rmsym_01413
#define stateConfigSetEx                             _nv_rmsym_01414
#define stateDac                                     _nv_rmsym_01415
#define stateDma                                     _nv_rmsym_01416
#define stateFb                                      _nv_rmsym_01417
#define stateFifo                                    _nv_rmsym_01418
#define stateGr                                      _nv_rmsym_01419
#define stateMc                                      _nv_rmsym_01420
#define stateMp                                      _nv_rmsym_01421
#define stateNv                                      _nv_rmsym_01422
#define stateSetMode                                 _nv_rmsym_01423
#define stateSetMode_DacClassStyle                   _nv_rmsym_01424
#define stateTmr                                     _nv_rmsym_01425
#define stateVideo                                   _nv_rmsym_01426
#define str1024                                      _nv_rmsym_01427
#define str1152                                      _nv_rmsym_01428
#define str1280                                      _nv_rmsym_01429
#define str1280x960                                  _nv_rmsym_01430
#define str1600                                      _nv_rmsym_01431
#define str1600x900                                  _nv_rmsym_01432
#define str1800                                      _nv_rmsym_01433
#define str1920x1080                                 _nv_rmsym_01434
#define str1920x1200                                 _nv_rmsym_01435
#define str1920x1440                                 _nv_rmsym_01436
#define str2048x1536                                 _nv_rmsym_01437
#define str640                                       _nv_rmsym_01438
#define str800                                       _nv_rmsym_01439
#define strDevNodeDisplayNumber                      _nv_rmsym_01440
#define strDevNodeRM                                 _nv_rmsym_01441
#define strDisableMPC                                _nv_rmsym_01442
#define strDisplayType                               _nv_rmsym_01443
#define strEnable256Burst                            _nv_rmsym_01444
#define strExternalSerialOnPrimary                   _nv_rmsym_01445
#define strFpMode                                    _nv_rmsym_01446
#define strMemoryOverride                            _nv_rmsym_01447
#define strPBUSOverride                              _nv_rmsym_01448
#define strRTLOverride                               _nv_rmsym_01449
#define strTVOutOnPrimary                            _nv_rmsym_01450
#define strTVOutType                                 _nv_rmsym_01451
#define strTVtype                                    _nv_rmsym_01452
#define strTilingOverride                            _nv_rmsym_01453
#define strUnderscanXOverride                        _nv_rmsym_01454
#define strUnderscanYOverride                        _nv_rmsym_01455
#define tetris_tile_table_signature                  _nv_rmsym_01456
#define tmrAlarmNotify                               _nv_rmsym_01457
#define tmrCancelCallback                            _nv_rmsym_01458
#define tmrCreateTimer                               _nv_rmsym_01459
#define tmrDefaultMethods                            _nv_rmsym_01460
#define tmrDelay                                     _nv_rmsym_01461
#define tmrDeleteContextTime                         _nv_rmsym_01462
#define tmrDeleteTimer                               _nv_rmsym_01463
#define tmrGetCurrentTime                            _nv_rmsym_01464
#define tmrMonthDays                                 _nv_rmsym_01465
#define tmrScheduleCallbackAbs                       _nv_rmsym_01466
#define tmrScheduleCallbackRel                       _nv_rmsym_01467
#define tmrService                                   _nv_rmsym_01468
#define tmrStopTransfer                              _nv_rmsym_01469
#define vblankProcessCallbacks                       _nv_rmsym_01470
#define videoAdjustScalarForTV_NV10                  _nv_rmsym_01471
#define videoConvertScaleFactor_NV04                 _nv_rmsym_01472
#define videoConvertScaleFactor_NV10                 _nv_rmsym_01473
#define videoCreateColorKeyObj                       _nv_rmsym_01474
#define videoCreateFromMemoryObj                     _nv_rmsym_01475
#define videoCreateObj                               _nv_rmsym_01476
#define videoCreateOverlayObj                        _nv_rmsym_01477
#define videoCreateScalerObj                         _nv_rmsym_01478
#define videoDestroyColorKeyObj                      _nv_rmsym_01479
#define videoDestroyFromMemoryObj                    _nv_rmsym_01480
#define videoDestroyObj                              _nv_rmsym_01481
#define videoDestroyOverlayObj                       _nv_rmsym_01482
#define videoDestroyScalerObj                        _nv_rmsym_01483
#define videoFromMemService                          _nv_rmsym_01484
#define videoGetExceptionData_NV10                   _nv_rmsym_01485
#define videoHwOwnsBuffer_NV10                       _nv_rmsym_01486
#define videoInit_NV04                               _nv_rmsym_01487
#define videoInit_NV10                               _nv_rmsym_01488
#define videoKickOffOverlay_NV10                     _nv_rmsym_01489
#define videoOverlayService                          _nv_rmsym_01490
#define videoService                                 _nv_rmsym_01491
#define videoService_NV10                            _nv_rmsym_01492
#define videoStopOverlay_NV10                        _nv_rmsym_01493
#define wGpo                                         _nv_rmsym_01494
#define wMaxWaitStates                               _nv_rmsym_01495
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\rmfail.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * header file for resource manager failure injection (testing) support
 */

#ifdef DEBUG_RM_FAILURES

#define RM_FAILURES_MAX 1024  /* or whatever */
int rm_failure[RM_FAILURES_MAX];
int rm_failure_counts[RM_FAILURES_MAX];

// personality flags for the triggers
#define RM_FAILURES_FLAG_BREAK_ON_TRIGGER        0x80000000
#define RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER 0x40000000

// these occupy the bottom half of the word
#define RM_FAILURES_MASK_PERCENT 0x8000
#define RM_FAILURES_MAX_COUNT    0x7fff
#define RM_FAILURES_MASK_COUNT   0x7fff

#define RM_FAILURE_TRIGGER_ENABLED(n) \
          (rm_failure[(n)] != 0)

#define RM_FAILURE_TRIGGERED(n) \
          RmFailureTriggered((n))

#define RM_FAILURE_TRIGGER_DISABLE(n) \
          rm_failure[(n)] = 0

#define RM_FAILURE_TEST(n, trigger) \
    do { \
        if (RM_FAILURE_TRIGGER_ENABLED((n))) { \
             if (RM_FAILURE_TRIGGERED((n))) { \
                trigger;	/* trigger the error */ \
             } \
         } \
    } while (0)
        

#define RM_FAILURE_ENABLE()  RmFailuresEnable()
#define RM_FAILURE_DISABLE() RmFailuresDisable()

int RmFailureTriggered(int n);
void RmFailuresEnable(void);
void RmFailuresDisable(void);
 
// how do the RM_FAILURE routines "printf" ?

#define RM_FAILURE_PRINTF(args)  DbgPrint args

#else	/* ! DEBUG_RM_FAILURES */
#define RM_FAILURE_TEST(n, trigger)
#define RM_FAILURE_ENABLE()
#define RM_FAILURE_DISABLE()

#endif  /* DEBUG_RM_FAILURES */

//
// convenience macros to assign ranges to tests
//

#define RM_FAILURE_OS(n, trig)          RM_FAILURE_TEST( 00+(n), trig)
#define RM_FAILURE_DAC(n, trig)         RM_FAILURE_TEST( 20+(n), trig)
#define RM_FAILURE_BTREE(N, TRIG)       RM_FAILURE_TEST( 40+(N), TRIG)
#define RM_FAILURE_CLASS(N, TRIG)       RM_FAILURE_TEST( 60+(N), TRIG)
#define RM_FAILURE_DEVINIT(N, TRIG)     RM_FAILURE_TEST( 80+(N), TRIG)
#define RM_FAILURE_DMA(N, TRIG)         RM_FAILURE_TEST(100+(N), TRIG)
#define RM_FAILURE_FB(N, TRIG)          RM_FAILURE_TEST(120+(N), TRIG)
#define RM_FAILURE_FIFO(N, TRIG)        RM_FAILURE_TEST(140+(N), TRIG)
#define RM_FAILURE_GR(N, TRIG)          RM_FAILURE_TEST(160+(N), TRIG)
#define RM_FAILURE_HEAP(N, TRIG)        RM_FAILURE_TEST(180+(N), TRIG)
#define RM_FAILURE_MC(N, TRIG)          RM_FAILURE_TEST(200+(N), TRIG)
#define RM_FAILURE_MODULAR(N, TRIG)     RM_FAILURE_TEST(220+(N), TRIG)
#define RM_FAILURE_MP(N, TRIG)          RM_FAILURE_TEST(240+(N), TRIG)
#define RM_FAILURE_NVKERNEL(N, TRIG)    RM_FAILURE_TEST(260+(N), TRIG)
#define RM_FAILURE_STATE(N, TRIG)       RM_FAILURE_TEST(280+(N), TRIG)
#define RM_FAILURE_TMR(N, TRIG)         RM_FAILURE_TEST(300+(N), TRIG)
#define RM_FAILURE_VBLANK(N, TRIG)      RM_FAILURE_TEST(320+(N), TRIG)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvwin32.h ===
#ifndef NVWIN32_INCLUDED
#define NVWIN32_INCLUDED
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for NvChannel typedef */
#endif

/***************************************************************************
 *                   NVIDIA-supplied routines                              *
 ***************************************************************************/

/***** Hardware access *****/

/*
 * NvOpen() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpen(char *);

/*
 * NvOpenDma() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpenDma(char *, int, int, int);

/*
 * NvClose() closes the channel to the chip and attempts to
 * clean up all objects created in that channel.
 */
extern int                  __stdcall NvClose(NvChannel *);

/***** Operating Environment routines *****/
/*
 * NvWait() waits to be "awakened" after requesting notification with
 * the NV_OS_NOTIFY_WILL_SLEEP style.
 * Note that in Windows 3.1 any Windows message will wake up the
 * application.
 */
extern int  __stdcall NvWait(NvChannel *);

/*
 * NvNotifyMsg() specifies a Windows message for NV1 to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_MESSAGE style.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvNotifyMsg(NvChannel *, int, int);

/*
 * NvErrorMsg() specifies a Windows message for NV to send to the
 * application upon detecting an error.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvErrorMsg(NvChannel *, int, int);

/*
 * Although Win32 applications have a flat address space, on the X86 
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
extern int  __stdcall NvGetFlatDataSelector(void);
extern int  __stdcall NvGetFlatCodeSelector(void);

/*
 * NvConfigVersion() returns an NV version number indicating the NV version.
 * The format of this is 0x00010206, where
 *  - 0x0001 is the chip architecture
 *  -   0x02 is the software release
 *  -   0x06 is the minor revision
 */
extern int  __stdcall NvConfigVersion(void);

#define NV_CHIP_ARCH(ver)   ((ver) >> 16)
#define NV_SW_RELEASE(ver)  (((ver) >> 8) & 0xFF)
#define NV_MINOR_REV(ver)   ((ver) & 0xFF)

/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** OS-dependent constants *****/

/* This posts a new architecture event */
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

/* This puts the process to sleep awaiting notification */
#define NV_OS_NOTIFY_WILL_SLEEP	   0x00000003

/* This puts a message in the client's message queue upon notification */
#define NV_OS_NOTIFY_MESSAGE	   0x00000002

/* This posts a Win32 event to the client upon notification */
#define NV_OS_NOTIFY_EVENT  	   0x00000004

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_VM_EVENT  	   0x00000005

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_STATE_CHANGE  0x00000006


/***************************************************************************
 *                     OS Resource Strings                                 *
 ***************************************************************************/

/* Maximum length of an OS string (conservative, actual is about 24) */
#define NV_OS_MAX_NAME_LENGTH      32

/***** OS resource names for sources and sinks of samples *****/

/* for NV_VIDEO_SINK */
#define NV_OS_VIDEO_MONITOR        "CON:"

/* for NV_IMAGE_TO_VIDEO. The HWND window handle should replace %u */
#define NV_OS_CANVAS_WINDOW        "WND%u:"

/* for NV_AUDIO_SINK */
#define NV_OS_LINE_OUT_LEFT        "LIN:\\LEFT"
#define NV_OS_LINE_OUT_RIGHT       "LIN:\\RIGHT"

/* for NV_AUDIO_SOURCE */
#define NV_OS_LINE_IN_LEFT         "LIN:\\LEFT"
#define NV_OS_LINE_IN_RIGHT        "LIN:\\RIGHT"
#define NV_OS_MIC_IN_LEFT          "MIC:\\LEFT"
#define NV_OS_MIC_IN_RIGHT         "MIC:\\RIGHT"


/***** Many devices can provide samples for NV_GAME_PORT_SOURCE *****/

/* Raw potentiometer data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 8 channels (0-7) replaces %d */
/* NOTE: The NV_OS_POT O/S string changed to "POTA%d:". The 2.0 and higher
 * Resource Manager will generate NV_ERROR1_NO_SUCH_OBJECT if there is no 
 * joystick connected. This string means nothing to the 1.20 Resource Manager.
 * For backwards compatibility, use NV_OS_GAME_PORT ("POT%d:"): both the 2.0 
 * and 1.20 Resource Manager will not generate an error if no joystick is
 * connected.
 */
#define NV_OS_POT                      "POTA%d:"
/* XXX Old name preserved for compatibility, use NV_OS_POT */
#define NV_OS_GAME_PORT                "POT%d:"


/* Calibrated joystick data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_JOYSTICK_BUTTONS         "JOY%d:\\BUTTONS"

#define NV_OS_JOYSTICK_BUTTON_TRIGGER  0x0001
#define NV_OS_JOYSTICK_BUTTON_SELECT   0x0002
#define NV_OS_JOYSTICK_BUTTON_A        0x0004
#define NV_OS_JOYSTICK_BUTTON_B        0x0008

#define NV_OS_JOYSTICK_X_AXIS          "JOY%d:\\X_AXIS"
#define NV_OS_JOYSTICK_Y_AXIS          "JOY%d:\\Y_AXIS"


/* Pedal data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_PEDALS                   "PEDALS%d:"


/* Throttle data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_THROTTLE                 "THROTTLE%d:"


/* 8-button game pad data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_PAD_BUTTONS              "PAD%d:"
/* XXX Old name preserved for compatibility, use NV_OS_PAD_BUTTONS */
#define NV_OS_PAD                      "PAD%d:"

#define NV_OS_PAD_BUTTON_START         0x0001
#define NV_OS_PAD_BUTTON_RIGHT         0x0002
#define NV_OS_PAD_BUTTON_LEFT          0x0004
#define NV_OS_PAD_BUTTON_UP            0x0008
#define NV_OS_PAD_BUTTON_DOWN          0x0010
#define NV_OS_PAD_BUTTON_A             0x0020
#define NV_OS_PAD_BUTTON_B             0x0040
#define NV_OS_PAD_BUTTON_C             0x0080
#define NV_OS_PAD_BUTTON_X             0x0100
#define NV_OS_PAD_BUTTON_Y             0x0200
#define NV_OS_PAD_BUTTON_Z             0x0400
#define NV_OS_PAD_BUTTON_TOP_RIGHT     0x0800
#define NV_OS_PAD_BUTTON_TOP_LEFT      0x1000


/* 3-axis yoke data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_YOKE_BUTTONS             "YOKE%d:\\BUTTONS"

#define NV_OS_YOKE_BUTTON_START        0x0001
#define NV_OS_YOKE_BUTTON_RIGHT        0x0002
#define NV_OS_YOKE_BUTTON_LEFT         0x0004
#define NV_OS_YOKE_BUTTON_UP           0x0008
#define NV_OS_YOKE_BUTTON_DOWN         0x0010
#define NV_OS_YOKE_BUTTON_A            0x0020
#define NV_OS_YOKE_BUTTON_B            0x0040
#define NV_OS_YOKE_BUTTON_C            0x0080
#define NV_OS_YOKE_BUTTON_X            0x0100
#define NV_OS_YOKE_BUTTON_Y            0x0200
#define NV_OS_YOKE_BUTTON_Z            0x0400
#define NV_OS_YOKE_BUTTON_TOP_RIGHT    0x0800
#define NV_OS_YOKE_BUTTON_TOP_LEFT     0x1000

#define NV_OS_YOKE_X_AXIS              "YOKE%d:\\X_AXIS"
#define NV_OS_YOKE_Y_AXIS              "YOKE%d:\\Y_AXIS"
#define NV_OS_YOKE_Z_AXIS              "YOKE%d:\\Z_AXIS"

/* 2-axis gun position data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* The HWND window handle should replace %u */
#define NV_OS_GUN_BUTTONS              "GUN%dWND%u:\\BUTTONS"

#define NV_OS_GUN_BUTTON_START         0x0001
#define NV_OS_GUN_BUTTON_TRIGGER	   0x0002

#define NV_OS_GUN_X_POSITION		   "GUN%dWND%u:\\X_POS"
#define NV_OS_GUN_Y_POSITION		   "GUN%dWND%u:\\Y_POS"

/* Value returned if gun is still determing X/Y coordinate */
#define NV_OS_GUN_POSITION_COUNTING    0xFFFE
/* Value returned if gun is off screen or outside canvas) */
#define NV_OS_GUN_POSITION_OFF_SCREEN  0xFFFF

/***** WATCOM special handling *****/
/* WATCOM 10.0 compiler needs special declaration of these functions */
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvOpen "*";
#pragma aux (__stdcall) NvClose "*";
#pragma aux (__stdcall) NvWait "*";
#pragma aux (__stdcall) NvNotifyMsg "*";
#pragma aux (__stdcall) NvErrorMsg "*";
#pragma aux (__stdcall) NvGetFlatDataSelector "*";
#pragma aux (__stdcall) NvGetFlatCodeSelector "*";
#pragma aux (__stdcall) NvVpeExtras "*";
#pragma aux (__stdcall) NvDmaPushOperation "*";
#ifdef VPE_EXTRAS
#pragma aux (__stdcall) NvOverlayExtras "*";
#endif

#ifdef _WIN32  // don't do this for the DOS compile!!
#pragma aux (__stdcall) NvConfigVersion "*";
#endif
#endif /* __WATCOMC__ */

#ifdef __cplusplus
};
#endif
#endif /* NVWIN32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvrmint.h ===
/*
 * nvrmint.h
 *
 * NVidia resource manager API header file for internal builds.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * _DWTYPE is returned from GetVersionEx(&osVer) and it is stored in dwWinType
 * in the __GLNVstate structure.
 */
#define NV_WIN_IS_9X(_DWTYPE) (_DWTYPE == VER_PLATFORM_WIN32_WINDOWS)
#define NV_WIN_IS_NT(_DWTYPE) (_DWTYPE == VER_PLATFORM_WIN32_NT)

typedef HANDLE NVDESCRIPTOR;
#define NV_DEVICE_NAME_LENGTH_MAX 127
#define NVARCH_INVALID_NVDESCRIPTOR 0
#define NVARCH_INVALID_CLIENT_HANDLE 0


/*
 * Control codes
 */
#define NVRM_IOCTL_BASE                 0x10
#define NVRM_IOCTL_NV_ARCH              (NVRM_IOCTL_BASE + 5)

#define NVRM_ARCH_NV01FREE              0
#define NVRM_ARCH_NV01ALLOCROOT         1
#define NVRM_ARCH_NV01ALLOCMEMORY       2
#define NVRM_ARCH_NV01ALLOCCONTEXTDMA   3
#define NVRM_ARCH_NV01ALLOCCHANNELPIO   4
#define NVRM_ARCH_NV01ALLOCOBJECT       5
#define NVRM_ARCH_NV01ALLOCDEVICE       6
#define NVRM_ARCH_NV03ALLOCCHANNELDMA   7
#define NVRM_ARCH_NV03DMAFLOWCONTROL    8
#define NVRM_ARCH_NV01INTERRUPT         9
#define NVRM_ARCH_NV01ALLOCEVENT        10
#define NVRM_ARCH_NV01HEAP              11
#define NVRM_ARCH_NV01CONFIGVERSION     12
#define NVRM_ARCH_NV01CONFIGGET         13
#define NVRM_ARCH_NV01CONFIGSET         14
#define NVRM_ARCH_NV01CONFIGUPDATE      15
#define NVRM_ARCH_RING0CALLBACK         16
#define NVRM_ARCH_NV04CONFIGGETEX       17
#define NVRM_ARCH_NV04CONFIGSETEX       18
#define NVRM_ARCH_NV04I2CACCESS         19
#define NVRM_ARCH_NV01DEBUGCONTROL      20
#define NVRM_ARCH_NV04ALLOC             21
// audio stuff
#define NVRM_ARCH_UNIFIEDFREE           30

/*
 * Win 9x data structure.
 */
typedef struct
{
    ULONG function;
    ULONG pParameters;
} NvIoctlArch, *PNvIoctlArch;

typedef struct
{
    ULONG p0;
    ULONG p1;
    ULONG p2;
    ULONG p3;
    ULONG p4;
    ULONG p5;
    ULONG p6;
} NVWATCHAPI_PARAMETERS;

ULONG   NvAlloc             (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID);
ULONG   NvAllocRoot         (HANDLE, ULONG*);
ULONG   NvAllocDevice       (HANDLE, ULONG, ULONG, ULONG, PUCHAR);
ULONG   NvAllocContextDma   (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG   NvAllocChannelPio   (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG);
ULONG   NvAllocChannelDma   (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*);
ULONG   NvAllocMemory       (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG*);
ULONG   NvAllocObject       (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG   NvFree              (HANDLE, ULONG, ULONG, ULONG);
ULONG   NvDmaFlowControl    (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG   NvAllocEvent        (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
ULONG   NvWatchApiFrontEnd  (ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
//ULONG     NvDmaPushMutexState (HANDLE, DWORD);

/*
 * Internal, platform dependent implementation of API routines
 */

HANDLE NvRmOpenWin9x(VOID);
HANDLE NvRmOpenWinNt(VOID);

VOID NvRmCloseWin9x(HANDLE);
VOID NvRmCloseWinNt(VOID);

ULONG NvRmAllocWin9x(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG NvRmAllocWinNt(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);

ULONG NvRmAllocRootWin9x(ULONG *phClient);
ULONG NvRmAllocRootWinNt(ULONG *phClient);

ULONG NvRmAllocDeviceWin9x(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG NvRmAllocDeviceWinNt(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);

ULONG NvRmAllocContextDmaWin9x(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG NvRmAllocContextDmaWinNt(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);

ULONG NvRmAllocChannelPioWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG NvRmAllocChannelPioWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);

ULONG NvRmAllocChannelDmaWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG NvRmAllocChannelDmaWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);

ULONG NvRmAllocMemoryWin9x(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG NvRmAllocMemoryWinNt(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);

ULONG NvRmAllocObjectWin9x(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG NvRmAllocObjectWinNt(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);

ULONG NvRmFreeWin9x(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG NvRmFreeWinNt(ULONG hClient, ULONG hParent, ULONG hObject);

ULONG Nv3RmGetDmaPushInfoWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG Nv3RmGetDmaPushInfoWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);

ULONG NvRmAllocEventWin9x(ULONG hClient, ULONG hObjectParent, ULONG hObjectNew, ULONG hClass, ULONG index, ULONG data);
ULONG NvRmAllocEventWinNt(ULONG hClient, ULONG hObjectParent, ULONG hObjectNew, ULONG hClass, ULONG index, ULONG data);

ULONG NvRmArchHeapWin9x(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type,
                               ULONG height, ULONG size, ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG NvRmArchHeapWinNt(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type,
                               ULONG height, ULONG size, ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG NvRmConfigGetWin9x(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG NvRmConfigGetWinNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG NvRmConfigSetWin9x(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG NvRmConfigSetWinNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);

ULONG NvRmConfigGetExWin9x(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigGetExWinNt(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigSetExWin9x(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigSetExWinNt(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);

ULONG NvRmInterruptExWin9x(ULONG hClient, ULONG device);
ULONG NvRmInterruptExWinNt(ULONG hClient, ULONG device);

// Unpublished hook for driver to call a ring0 function.
ULONG NvRmRing0CallbackWin9x(ULONG hClient, ULONG device, ULONG procAddr, ULONG param1, ULONG param2);
ULONG NvRmRing0CallbackWinNt(ULONG hClient, ULONG device, ULONG procAddr, ULONG param1, ULONG param2);

ULONG NvRmInterruptWin9x(ULONG, ULONG);
ULONG NvRmInterruptWinNt(ULONG, ULONG);

// Unpublished I2C access routine
ULONG NvRmI2CAccessWin9x(ULONG hClient, ULONG device, VOID *paramStructPtr );
ULONG NvRmI2CAccessWinNt(ULONG hClient, ULONG device, VOID *paramStructPtr );

// Unpublished debug control
ULONG NvRmDebugControlWin9x( ULONG hRoot, ULONG command, VOID *pArgs);
ULONG NvRmDebugControlWinNt( ULONG hRoot, ULONG command, VOID *pArgs);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\client.c ===
/******************************************************************************
*
*   File:  client.c
*
*   Description:
*       This file contains the functions necessary to manage NV Resource
*   Manager client information.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

// TO DO: ClientInstance is a global!!!!  Can we rely on it's being SMP safe??
//        i.e. can two IOCTLs be processing simultaneously?

// This file is chip independent AND OS independent

#include <nvrm.h>
#include <client.h>
#include <nvos.h>
#include <nvarch.h>

//
// Return a "unique" client handle by incrementing our clientHandle variable.
// We cannot let this freely range over all possible values, since it would
// eventually match an already existing handle (looping after 1MB hopefully
// will be enough).
//
static U032 clientHandle = 0xc1d00000;

RM_STATUS CliAddClient(
    U032 *phClient,
    U032 hClass
)
{
    U032 i;

    // verify class is a root object
    switch (hClass)
    {
        case NV01_ROOT:
        case NV01_ROOT_USER:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // register the client
    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if ( ! clientInfo[i].InUse)
        {
            // create a unique client handle
            clientHandle = ((clientHandle + 1) % 0x100000) ? (clientHandle + 1) : 0xc1d00000;
            // mark it busy asap
            clientInfo[i].InUse         = TRUE;

            // initialize the client
            clientInfo[i].Handle           = clientHandle;
            clientInfo[i].Class            = hClass;
            clientInfo[i].ProcID           = i;
            clientInfo[i].ProcContext      = 0;
            clientInfo[i].FifoCount        = 0;
            clientInfo[i].CliDmaList       = NULL;
            clientInfo[i].CliMemoryList    = NULL;
            clientInfo[i].CliEventList     = NULL;
            clientInfo[i].CliHeapOwnerList = NULL;    //added by Chuck Moidel

            // set the client instance and return the client handle
            CliSetClientInstance(i);
            *phClient = clientInfo[i].Handle;

            return RM_OK;
        }
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddClient()

BOOL CliDelClient()
{
    clientInfo[ClientInstance].InUse = FALSE;

    return TRUE;

} // end of CliDelClient()

BOOL CliGetClientHandle(
    U032 *phClient
)
{
    if (clientInfo[ClientInstance].InUse == TRUE)
    {
        *phClient = clientInfo[ClientInstance].Handle;
        return TRUE;
    }

    return FALSE;

} // end of CliGetClientHandle()

BOOL CliGetClientIndex(
    U032 hClient,
    U032 *pIndex
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            *pIndex = i;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetClientIndex()

BOOL CliSetClientContext(
    U032 hClient
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            ClientInstance = i;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetClientContext()

BOOL CliSetClientInstance(
    U032 instance
)
{
    if (instance < NUM_CLIENTS)
    {
        ClientInstance = instance;
        return TRUE;
    }

    return TRUE;

} // end of CliSetClientInstance()

BOOL CliSetClientAppHandle(
    U032  hClient,
    void *appHandle
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            clientInfo[i].AppHandle = appHandle;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetClientAppHandle()

BOOL CliGetClientAppHandle(
    U032   hClient,
    void **appHandle
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            *appHandle = clientInfo[i].AppHandle;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetClientAppHandle()


RM_STATUS CliAddDevice(
    U032 hClient,
    U032 hDevice,
    U032 hClass
)
{
    U032 client, device;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate device
    if (!CliIsUniqueHandle(hDevice, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    if (!CliGetPhysicalDevice(hClass, &device))
    {
        return RM_ERR_BAD_CLASS;
    }

    // make sure we have a device list
    if ( ! clientInfo[ClientInstance].CliDeviceList)
        if ( ! CliMakeDeviceList(ClientInstance, NUM_DEVICES, &clientInfo[ClientInstance].CliDeviceList))
            goto failed;

    // initialize the device
    if ( ! clientInfo[ClientInstance].CliDeviceList[device].InUse)
    {
        clientInfo[ClientInstance].CliDeviceList[device].InUse          = TRUE;
        clientInfo[ClientInstance].CliDeviceList[device].Handle         = hDevice;
        clientInfo[ClientInstance].CliDeviceList[device].Client         = hClient;
        clientInfo[ClientInstance].CliDeviceList[device].Class          = hClass;
        clientInfo[ClientInstance].CliDeviceList[device].DevMemoryList  = NULL;
        clientInfo[ClientInstance].CliDeviceList[device].AppHandle      = NULL;
        clientInfo[ClientInstance].CliDeviceList[device].DevFifoList    = NULL;
        return RM_OK;
    }

 failed:
    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDevice()


BOOL CliDelDevice(
    U032 hDevice
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        // delete the dynamically allocated device fifo list
        if (pDevice->DevFifoList)
        {
            osFreeMem(pDevice->DevFifoList);
            pDevice->DevFifoList = NULL;
        }

        // mark the device as unused
        pDevice->InUse = FALSE;
        return TRUE;
    }

    return FALSE;

} // end of CliDelDevice()


// allocate a single client's device info
BOOL CliMakeDeviceList(
    U032              client_instance,
    U032              num_devices,
    PCLI_DEVICE_INFO *ppDeviceList
)
{
    PCLI_DEVICE_INFO pdevice;
	
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: make new device list\n");

    if (RM_OK != osAllocMem((VOID **)ppDeviceList, sizeof(CLI_DEVICE_INFO) * num_devices))
        return FALSE;

    for (pdevice = *ppDeviceList; pdevice < *ppDeviceList + num_devices; pdevice++)
    {
        pdevice->InUse       = FALSE;
        pdevice->AppID       = client_instance;
        pdevice->AppHandle   = (void *) 0;
        pdevice->DevID       = (U032)(pdevice - *ppDeviceList);
        pdevice->DevFifoList = NULL;
    }

    return TRUE;
}


BOOL CliGetDeviceInfo(
    U032 hDevice,
    PCLI_DEVICE_INFO *ppDeviceInfo
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i;

    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse && deviceList[i].Handle == hDevice)
            {
                *ppDeviceInfo = &deviceList[i];
                return TRUE;
            }
        }
    }

    return FALSE;

} // end of CliGetDeviceInfo()

PCLI_DEVICE_INFO CliGetDeviceList()
{
    return clientInfo[ClientInstance].CliDeviceList;

} // end of CliGetDeviceList()

BOOL CliGetDeviceHandle(
    U032 hFifo,
    U032 *phDevice
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i, j;

    // get the device handle based on one of its fifo handles
    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse && deviceList[i].DevFifoList)
            {
                for (j = 0; j < MAX_FIFOS; j++)
                {
                    if (deviceList[i].DevFifoList[j].InUse &&
                        (deviceList[i].DevFifoList[j].Handle == hFifo))
                    {
                        *phDevice = deviceList[i].Handle;
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}

BOOL CliSetDeviceContext(
    U032 hDevice,
    PHWINFO* ppDev
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        // For NT there is no global DeviceInstance variable.
        U032 deviceInstance;

        if (CliGetPhysicalDevice(pDevice->Class, &deviceInstance))
        {
            *ppDev = NvDBPtr_Table[deviceInstance];
            osEnsureDeviceEnabled((PHWINFO)*ppDev);
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetDeviceContext()

BOOL CliSetDeviceAppHandle(
    U032  hDevice,
    void *appHandle
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        pDevice->AppHandle = appHandle;
        return TRUE;
    }

    return FALSE;

} // end of CliSetDeviceAppHandle()

BOOL CliGetDeviceAppHandle(
    U032   hDevice,
    void **appHandle
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        *appHandle = pDevice->AppHandle;
        return TRUE;
    }

    return FALSE;

} // end of CliSetDeviceAppHandle()


RM_STATUS CliAddDeviceFifo(
    PHWINFO pDev,
    U032 hDevice,
    U032 hFifo,
    U032 hClass,
    U032 hErrorCtx,
    U032 hDataCtx,
    U032 offset,
    U032 flags,
    U032 chID,
    VOID* pChannel
)
{
    PCLI_DEVICE_INFO pDevice;

    // validate device
    if (!CliGetDeviceInfo(hDevice, &pDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate fifo
    if ( ! CliIsUniqueHandle(hFifo, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // make sure we have a fifo list
    // allocate MAX_FIFOS worth because some of the code in here walks the
    //     list without having access to NUM_FIFOS for a particular card.
    //     (NUM_FIFOS is a macro defined in terms of pDev)
    if ( ! pDevice->DevFifoList)
        if ( ! CliMakeDeviceFifoList(ClientInstance,
                                     pDevice->DevID,
                                     MAX_FIFOS,
                                     &pDevice->DevFifoList))
            return RM_ERR_INSUFFICIENT_RESOURCES;

    // add fifo info to the given device's fifo
    if ( ! pDevice->DevFifoList[chID].InUse)
    {
        pDevice->DevFifoList[chID].Handle           = hFifo;
        pDevice->DevFifoList[chID].Device           = hDevice;
        pDevice->DevFifoList[chID].Class            = hClass;
        pDevice->DevFifoList[chID].ErrorDmaContext  = hErrorCtx;
        pDevice->DevFifoList[chID].DataDmaContext   = hDataCtx;
        pDevice->DevFifoList[chID].Selector         = 0;
        pDevice->DevFifoList[chID].Flat             = pChannel;
        pDevice->DevFifoList[chID].FifoPtr          = &pDev->DBfifoTable[chID];
        pDevice->DevFifoList[chID].heventWait       = 0;
        pDevice->DevFifoList[chID].hwndNotify       = 0;
        pDevice->DevFifoList[chID].hwndError        = 0;
        pDevice->DevFifoList[chID].msgNotify        = 0;
        pDevice->DevFifoList[chID].msgError         = 0;
        pDevice->DevFifoList[chID].lpSysCallback    = 0;
        pDevice->DevFifoList[chID].eventNotify      = 0;

        pDevice->DevFifoList[chID].InUse            = TRUE;
        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDeviceFifo()

BOOL CliDelDeviceFifo(
    U032 hDevice,
    U032 hFifo
)
{
    PCLI_FIFO_INFO pFifo;

    if (CliGetDeviceFifoInfo(hDevice, hFifo, &pFifo))
    {
        pFifo->InUse = FALSE;
        return TRUE;
    }

    return FALSE;

} // end of CliDelDeviceFifo()

// allocate a single device's fifo info

BOOL CliMakeDeviceFifoList(
    U032              client_instance,
    U032              device_instance,
    U032              num_fifos,
    PCLI_FIFO_INFO   *ppFifoList
)
{
    PCLI_FIFO_INFO pfifo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: make new fifo list\n");

    if (RM_OK != osAllocMem((VOID **)ppFifoList, sizeof(CLI_FIFO_INFO) * num_fifos))
        return FALSE;

    for (pfifo = *ppFifoList; pfifo < *ppFifoList + num_fifos; pfifo++)
    {
        pfifo->InUse = FALSE;
        pfifo->AppID = client_instance;
        pfifo->AppHandle = (void *) 0;
        pfifo->DevID = device_instance;
        pfifo->ChID = (U032)(pfifo - *ppFifoList);

        pfifo->Selector = 0;
        pfifo->Handle = 0;
        pfifo->Device = 0;
        pfifo->Class = 0;
        pfifo->ErrorDmaContext = 0;
        pfifo->DataDmaContext = 0;
        pfifo->FifoPtr = 0;
        pfifo->Flat = 0;
        pfifo->heventWait = 0;
        pfifo->hwndNotify = 0;
        pfifo->hwndError = 0;
        pfifo->msgNotify = 0;
        pfifo->msgError = 0;
        pfifo->lpSysCallback = 0;
        pfifo->eventNotify = 0;
        pfifo->pDmaObject = 0;
    }

    return TRUE;
}

BOOL CliGetDeviceFifoInfo(
    U032 hDevice,
    U032 hFifo,
    PCLI_FIFO_INFO *ppFifoInfo
)
{
    PCLI_FIFO_INFO fifoList;
    U032 i;

    if (CliGetDeviceFifoList(hDevice, &fifoList) && fifoList)
    {
        for (i = 0; i < MAX_FIFOS; i++)
        {
            if (fifoList[i].InUse && (fifoList[i].Handle == hFifo))
            {
                *ppFifoInfo = &fifoList[i];
                return TRUE;
            }
        }
    }

    return FALSE;

} // end of CliGetDeviceFifoInfo()


// CliGetDeviceFifoList() could return a NULL list on TRUE
BOOL CliGetDeviceFifoList(
    U032 hDevice,
    PCLI_FIFO_INFO *pFifoList
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        *pFifoList = pDevice->DevFifoList;
        return TRUE;
    }

    return FALSE;

} // end of CliGetDeviceFifoList()

RM_STATUS CliAddDeviceMemory(
    U032 hDevice,
    U032 hMemory,
    U032 hClass,
    VOID *address,
    U032 length,
    U032 instance,
    U032 heapOwner,
    U032 version      //see CLI_MEMORY_INFO definition for more info on version  -C.Moidel
)
{
    PCLI_DEVICE_INFO pDevice;
    PCLI_MEMORY_INFO pMemory;

    // validate client
    if (!CliGetDeviceInfo(hDevice, &pDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate device
    if (!CliIsUniqueHandle(hMemory, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_MEMORY_LOCAL_PRIVILEGED:
        case NV01_MEMORY_LOCAL_USER:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    //TODO: Validate HeapOwner based on version     -C.Moidel

    // allocate a new memory info struct and add to the device
    if (RM_SUCCESS(osAllocMem((void **) &pMemory, sizeof(CLI_MEMORY_INFO))))
    {
        // link in the new device memory mapping
        pMemory->Next = pDevice->DevMemoryList;
        pMemory->Prev = NULL;
        pDevice->DevMemoryList = pMemory;
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory;
        }

        // initialize the device
        pMemory->Handle     = hMemory;
        pMemory->Parent     = hDevice;
        pMemory->Class      = hClass;
        pMemory->Address    = address;
        pMemory->Length     = length;
        pMemory->Instance   = instance;
        pMemory->HeapOwner  = heapOwner;
        pMemory->version    = version;
        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDeviceMemory()

BOOL CliDelDeviceMemory(
    U032 hDevice,
    U032 hMemory
)
{
    PCLI_MEMORY_INFO pMemory;
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemory))
    {
        // fixup prev link
        if (pMemory->Prev)
        {
            pMemory->Prev->Next = pMemory->Next;
        }
        else
        {
            // head of list, so modify the list head link
            if (!CliGetDeviceInfo(hDevice, &pDevice))
            {
                return FALSE;
            }
            pDevice->DevMemoryList = pMemory->Next;
        }

        // fixup next link
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory->Prev;
        }

        // free the list element
        osFreeMem(pMemory);

        return TRUE;
    }

    return FALSE;

} // end of CliDelDeviceMemory()

//
// This is currently used only by heapPurge to delete DeviceMemory based
// only on the owner.
//
BOOL CliDelDeviceHeapOwner(
    U032 hDevice,
    U032 heapOwner
)
{
    PCLI_MEMORY_INFO pMemory;
    BOOL retval = FALSE;

    for (pMemory = CliGetDeviceMemoryList(hDevice); pMemory; )
    {
        if (pMemory->HeapOwner == heapOwner)
        {
            U032 hMemory = pMemory->Handle;

            pMemory = pMemory->Next;                // get Next, before we delete it
            CliDelDeviceMemory(hDevice, hMemory);

            retval = TRUE;
        } else
            pMemory = pMemory->Next;
    }

    return retval;

} // end of CliDelDeviceHeapOwner

BOOL CliGetDeviceMemoryInfo(
    U032 hDevice,
    U032 hMemory,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetDeviceMemoryList(hDevice); pMemory; pMemory = pMemory->Next)
    {
        if (pMemory->Handle == hMemory)
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetDeviceMemoryInfo()

PCLI_MEMORY_INFO CliGetDeviceMemoryList(
    U032 hDevice
)
{
    PCLI_DEVICE_INFO pDevice;
    PCLI_MEMORY_INFO memoryList = NULL;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        memoryList = pDevice->DevMemoryList;
    }

    return memoryList;

} // end of CliGetDeviceMemoryList()

RM_STATUS CliAddDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    VOID* base,
    U032 limit,
    PCLI_DMA_INFO *ppDma
)
{
    U032 client;
    PCLI_DMA_INFO pDma;
    U032 access, physicality, locked, coherency;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate handle
    if (!CliIsUniqueHandle(hDma, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_CONTEXT_DMA:
            break;

        default:
            return RM_ERR_BAD_CLASS;
    }

    // validate the flags
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_ACCESS) & DRF_MASK(NVOS03_FLAGS_ACCESS))
    {
        case NVOS03_FLAGS_ACCESS_READ_WRITE:
            access = NV01_CONTEXT_DMA_IN_MEMORY;
            break;

        case NVOS03_FLAGS_ACCESS_READ_ONLY:
            access = NV01_CONTEXT_DMA_FROM_MEMORY;
            break;

        case NVOS03_FLAGS_ACCESS_WRITE_ONLY:
            access = NV01_CONTEXT_DMA_TO_MEMORY;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_PHYSICALITY) & DRF_MASK(NVOS03_FLAGS_PHYSICALITY))
    {
        case NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS:
            physicality = NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS;
            break;

        case NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS:
            physicality = NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_LOCKED) & DRF_MASK(NVOS03_FLAGS_LOCKED))
    {
        case NVOS03_FLAGS_LOCKED_ALWAYS:
            locked = NVOS03_FLAGS_LOCKED_ALWAYS;
            break;

        case NVOS03_FLAGS_LOCKED_IN_TRANSIT:
            locked = NVOS03_FLAGS_LOCKED_IN_TRANSIT;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_COHERENCY) & DRF_MASK(NVOS03_FLAGS_COHERENCY))
    {
        case NVOS03_FLAGS_COHERENCY_UNCACHED:
            coherency = NVOS03_FLAGS_COHERENCY_UNCACHED;
            break;

        case NVOS03_FLAGS_COHERENCY_CACHED:
            coherency = NVOS03_FLAGS_COHERENCY_CACHED;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }

    // allocate a new dmaInfo and add the device to the client
    if (RM_SUCCESS(osAllocMem((void **) &pDma, sizeof(CLI_DMA_INFO))))
    {
        // link in the new DMA
        pDma->Next = clientInfo[ClientInstance].CliDmaList;
        pDma->Prev = NULL;
        clientInfo[ClientInstance].CliDmaList = pDma;
        if (pDma->Next)
        {
            pDma->Next->Prev = pDma;
        }

        // initialize the device
        pDma->Handle        = hDma;
        pDma->Client        = hClient;
        pDma->Class         = hClass;
        pDma->Flags         = flags;
        pDma->Access        = access;
        pDma->Physicality   = physicality;
        pDma->Locked        = locked;
        pDma->Coherency     = coherency;
        pDma->Valid         = FALSE;
        pDma->DescSelector  = selector;
        pDma->DescOffset    = base;
        pDma->DescLimit     = limit;
        pDma->DescAddr      = 0;
        pDma->BufferBase    = 0;
        pDma->BufferSize    = 0;
        pDma->LockHandle    = 0;
        pDma->PteCount      = 0;
        pDma->PteAdjust     = 0;
        pDma->PteLimit      = 0;
        pDma->PteArray      = 0;
        pDma->AddressSpace  = ADDR_UNKNOWN;
        *ppDma = pDma;

        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDma()

BOOL CliDelDma(
    U032 hDma
)
{
    PCLI_DMA_INFO pDma;

    if (CliGetDmaInfo(hDma, &pDma))
    {
        // fixup prev link
        if (pDma->Prev)
        {
            pDma->Prev->Next = pDma->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliDmaList = pDma->Next;
        }

        // fixup the next link
        if (pDma->Next)
        {
            pDma->Next->Prev = pDma->Prev;
        }

        // free the list element
        osFreeMem(pDma);

        return TRUE;
    }

    return FALSE;

} // end of CliDelDma()

BOOL CliGetDmaInfo(
    U032 hDma,
    PCLI_DMA_INFO *ppDmaInfo
)
{
    PCLI_DMA_INFO pDma;

    for (pDma = CliGetDmaList(); pDma; pDma = pDma->Next)
    {
        if (pDma->Handle == hDma)
        {
            *ppDmaInfo = pDma;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetDmaInfo()

PCLI_DMA_INFO CliGetDmaList()
{
    return clientInfo[ClientInstance].CliDmaList;

} // end of CliGetDmaList()

RM_STATUS CliAddMemory(
    PHWINFO pDev,
    U032 hClient,
    U032 hMemory,
    U032 hClass,
    U032 flags,
    VOID* address,
    U032 length,
    VOID* memdata       // private per-alloc data
)
{
    U032 client;
    PCLI_MEMORY_INFO pMemory;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate memory description
    if (!CliIsUniqueHandle(hMemory, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // allocate a new memory description and add the device to the client
    if (RM_SUCCESS(osAllocMem((void **) &pMemory, sizeof(CLI_MEMORY_INFO))))
    {
        // link in the new system memory mapping
        pMemory->Next = clientInfo[ClientInstance].CliMemoryList;
        pMemory->Prev = NULL;
        clientInfo[ClientInstance].CliMemoryList = pMemory;
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory;
        }

        // initialize the memory description
        pMemory->pDev       = pDev;
        pMemory->Handle     = hMemory;
        pMemory->Parent     = hClient;
        pMemory->Class      = hClass;
        pMemory->Address    = address;
        pMemory->Length     = length;
        pMemory->Type       = DRF_VAL(OS02, _FLAGS, _LOCATION, flags);
        pMemory->Physicality = DRF_VAL(OS02, _FLAGS, _PHYSICALITY, flags);
        pMemory->Coherency  = DRF_VAL(OS02, _FLAGS, _COHERENCY, flags);
        pMemory->MemData    = memdata;

        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddMemory()

BOOL CliDelMemory(
    U032 hMemory
)
{
    PCLI_MEMORY_INFO pMemory;

    if (CliGetMemoryInfo(hMemory, &pMemory))
    {
        // fixup prev link
        if (pMemory->Prev)
        {
            pMemory->Prev->Next = pMemory->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliMemoryList = pMemory->Next;
        }

        // fixup the next link
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory->Prev;
        }

        pMemory->MemData = NULL;

        // free the list element
        osFreeMem(pMemory);

        return TRUE;
    }

    return FALSE;

} // end of CliDelMemory()

BOOL CliGetMemoryInfo(
    U032 hMemory,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetMemoryList(); pMemory; pMemory = pMemory->Next)
    {
        if (pMemory->Handle == hMemory)
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetMemoryInfo()


// which memory chunk spans a given linear address?
BOOL CliGetMemoryInfoForLinAddr(
    VOID *address,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetMemoryList(); pMemory; pMemory = pMemory->Next)
    {
        // NOTE: pMemory->length is really length-1
        if ((address >= pMemory->Address) &&
            (address <= (VOID*)((U008*)pMemory->Address + pMemory->Length)))
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetMemoryInfoForLinAddr()


PCLI_MEMORY_INFO CliGetMemoryList()
{
    return clientInfo[ClientInstance].CliMemoryList;

} // end of CliGetMemoryList()

RM_STATUS CliAddEvent(
    U032 hClient,
    U032 hObject,
    U032 hEvent,
    U032 hClass,
    PCLI_EVENT_INFO* ppEventInfo
)
{
    RM_STATUS rmStatus = RM_OK;
    POBJECT pObject;
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER pUser;
    U032 hChannel;

    // validate parent
    if (!CliFindObject(hObject, &pObject, &hChannel))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate handle -- disregard existing event handles
    if (!CliIsUniqueHandle(hEvent, TRUE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_EVENT_KERNEL_CALLBACK:
        case NV01_EVENT_WIN32_EVENT:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // return a pointer to the client event list element
    if (!CliGetEventInfo(hEvent, &pEvent))
    {
        // allocate a new event and add to the client
        rmStatus = osAllocMem((void **) &pEvent, sizeof(CLI_EVENT_INFO));
        if (RM_SUCCESS(rmStatus))
        {
            // link in the new event
            pEvent->Next = clientInfo[ClientInstance].CliEventList;
            pEvent->Prev = NULL;
            clientInfo[ClientInstance].CliEventList = pEvent;
            if (pEvent->Next)
            {
                pEvent->Next->Prev = pEvent;
            }

            // initialize the event
            pEvent->Handle      = hEvent;
            pEvent->Class       = hClass;
            pEvent->UserList    = NULL;
        }
    }
    else
    {
        // validate the user object's uniqueness for non-trivial lists
        for (pUser = pEvent->UserList; pUser; pUser = pUser->Next)
        {
            if (pUser->Handle == hObject)
            {
                return RM_ERR_BAD_OBJECT_HANDLE;
            }
        }
    }

    // add the next user
    if (RM_SUCCESS(rmStatus))
    {
        rmStatus = osAllocMem((void **) &pUser, sizeof(CLI_EVENT_USER));
        if (RM_SUCCESS(rmStatus))
        {
            // link in the new event's user
            pUser->Next = pEvent->UserList;
            pUser->Prev = NULL;
            pEvent->UserList = pUser;
            if (pUser->Next)
            {
                pUser->Next->Prev = pUser;
            }

            // initialize the new user
            pUser->Handle   = hObject;
            pUser->Channel  = hChannel;

            // set the return value
            *ppEventInfo = pEvent;
        }
    }

    return rmStatus;

} // end of CliAddEvent()

BOOL CliDelEvent(
    U032 hEvent
)
{
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER nextUser;

    // remove the event from the client database
    if (CliGetEventInfo(hEvent, &pEvent))
    {
        // free up user list
        nextUser = pEvent->UserList;
        while (pEvent->UserList)
        {
            pEvent->UserList = nextUser->Next;
            osFreeMem(nextUser);
        }

        // fixup next link
        if (pEvent->Prev)
        {
            pEvent->Prev->Next = pEvent->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliEventList = pEvent->Next;
        }

        // fixup the prev link
        if (pEvent->Next)
        {
            pEvent->Next->Prev = pEvent->Prev;
        }

        // free the list element
        osFreeMem(pEvent);

        return TRUE;
    }

    return FALSE;

} // end of CliDelEvent()

BOOL CliDelEventUser
(
    U032 hUser,
    U032 hClass
)
{
    PCLI_EVENT_INFO nextEvent;
    PCLI_EVENT_USER nextUser, pUser;
    U032 hEvent;

    // remove user from all events
    nextEvent = CliGetEventList();
    while (nextEvent)
    {
        nextUser = nextEvent->UserList;
        while (nextUser)
        {
            if (CliGetEventUserHandle(nextUser, hClass) == hUser)
            {
                // fixup next link
                if (nextUser->Prev)
                {
                    nextUser->Prev->Next = nextUser->Next;
                }
                else
                {
                    // head of list, so modify the list head link
                    nextEvent->UserList = nextUser->Next;
                }

                // fixup the prev link
                if (nextUser->Next)
                {
                    nextUser->Next->Prev = nextUser->Prev;
                }

                // free the list element
                pUser = nextUser;
                nextUser = nextUser->Next;
                osFreeMem(pUser);
            }
            else
            {
                nextUser = nextUser->Next;
            }
        }

        // remove the event if user list is empty
        if (nextEvent->UserList == NULL)
        {
            hEvent = nextEvent->Handle;
            nextEvent = nextEvent->Next;
            CliDelEvent(hEvent);
        }
        else
        {
            nextEvent = nextEvent->Next;
        }
    }

    return TRUE;

}

U032 CliGetEventUserHandle
(
    PCLI_EVENT_USER pUser,
    U032 hClass
)
{
    switch (hClass)
    {
        // object
        case NV01_NULL_OBJECT:
            return pUser->Handle;

        // channel
        default:
            return pUser->Channel;
    }

} // end of CliGetEventUserHandle()

BOOL CliGetEventInfo(
    U032 hEvent,
    PCLI_EVENT_INFO* ppEventInfo
)
{
    PCLI_EVENT_INFO pEvent;

    for (pEvent = CliGetEventList(); pEvent; pEvent = pEvent->Next)
    {
        if (pEvent->Handle == hEvent)
        {
            *ppEventInfo = pEvent;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetEventInfo()

PCLI_EVENT_INFO CliGetEventList()
{
    return clientInfo[ClientInstance].CliEventList;

} // end of CliGetEventList()

BOOL CliFindObject(
    U032 hObject,
    POBJECT* ppObject,
    U032* phChannel
)
{
    BOOL found = FALSE;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    U032 device, fifo;
    PHWINFO pDev;

    deviceList = CliGetDeviceList();
    if ( ! deviceList)
        goto done;

    // search thru all channels of all devices for the object
    for (device = 0; device < NUM_DEVICES; device++)
    {
        if (deviceList[device].InUse)
        {
            if (CliSetDeviceContext(deviceList[device].Handle, &pDev))
            {
                if (CliGetDeviceFifoList(deviceList[device].Handle, &fifoList)
                    && fifoList)
                {
                    for (fifo = 0; fifo < NUM_FIFOS; fifo++)
                    {
                        if (fifoList[fifo].InUse)
                        {
                            if (RM_OK == fifoSearchObject(pDev,
                                                          hObject,
                                                          fifoList[fifo].ChID,
                                                          ppObject))
                            {
                                found = TRUE;
                                *phChannel = fifoList[fifo].Handle;
                                goto done;
                            }
                        }
                    }
                }
            }
        }
    }

 done:
    return found;

} // end of CliFindObject()

BOOL CliGetClass(
    U032 hParent,
    U032 hObject,
    U032 *phClass
)
{
    U032 client;
    PCLI_DEVICE_INFO pDevice;
    PCLI_FIFO_INFO pFifo;
    PCLI_MEMORY_INFO pMemory;
    PCLI_DMA_INFO pDma;
    PCLI_EVENT_INFO pEvent;

    // scan all object types

    if (CliGetClientHandle(&client) && client == hObject)
    {
        *phClass = clientInfo[ClientInstance].Class;
    }
    else if (CliGetDeviceInfo(hObject, &pDevice))
    {
        *phClass = pDevice->Class;
    }
    else if (CliGetDeviceFifoInfo(hParent, hObject, &pFifo))
    {
        *phClass = pFifo->Class;
    }
    else if (CliGetDeviceMemoryInfo(hParent, hObject, &pMemory))
    {
        *phClass = pMemory->Class;
    }
    else if (CliGetDmaInfo(hObject, &pDma))
    {
        *phClass = pDma->Class;
    }
    else if (CliGetMemoryInfo(hObject, &pMemory))
    {
        *phClass = pMemory->Class;
    }
    else if (CliGetEventInfo(hObject, &pEvent))
    {
        *phClass = pEvent->Class;
    }
    else
    {
        return FALSE;
    }

    return TRUE;

} // end of CliGetClass()

BOOL CliIsUniqueHandle(U032 hObject, BOOL omitEvents)
{
    U032 i, j;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    PCLI_DMA_INFO nextDma;
    PCLI_MEMORY_INFO nextMemory;
    PCLI_EVENT_INFO nextEvent;
    POBJECT pObject;
    U032 hChannel;

    // handle is unique if it is non-null or does not exist in the client
    if (hObject == NV01_NULL_OBJECT)
        return FALSE;

    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                if (deviceList[i].Handle == hObject)
                    return FALSE;

                if (CliGetDeviceFifoList(deviceList[i].Handle, &fifoList) && fifoList)
                {
                    for (j = 0; j < MAX_FIFOS; j++)
                    {
                        if (fifoList[j].InUse)
                        {
                            if (fifoList[j].Handle == hObject)
                                return FALSE;
                        }
                    }
                }
            }
        }
    }

    for (nextDma = CliGetDmaList(); nextDma; nextDma = nextDma->Next)
    {
        if (nextDma->Handle == hObject)
        {
            return FALSE;
        }
    }
    for (nextMemory = CliGetMemoryList(); nextMemory; nextMemory = nextMemory->Next)
    {
        if (nextMemory->Handle == hObject)
        {
            return FALSE;
        }
    }
    for (nextEvent = CliGetEventList(); nextEvent; nextEvent = nextEvent->Next)
    {
        if (nextEvent->Handle == hObject)
        {
            return FALSE;
        }
    }
    if (CliFindObject(hObject, &pObject, &hChannel))
    {
        return FALSE;
    }

    return TRUE;

} // end of CliIsUniqueHandle()

BOOL CliGetPhysicalDevice(
    U032 logicalDevice,
    U032 *physicalDevice
)
{
    switch (logicalDevice)
    {
        case NV01_DEVICE_0:
            *physicalDevice = 0;
            break;

        case NV01_DEVICE_1:
            *physicalDevice = 1;
            break;

        case NV01_DEVICE_2:
            *physicalDevice = 2;
            break;

        case NV01_DEVICE_3:
            *physicalDevice = 3;
            break;

        case NV01_DEVICE_4:
            *physicalDevice = 4;
            break;

        case NV01_DEVICE_5:
            *physicalDevice = 5;
            break;

        case NV01_DEVICE_6:
            *physicalDevice = 6;
            break;

        case NV01_DEVICE_7:
            *physicalDevice = 7;
            break;

        default:
            return FALSE;
    }

    return TRUE;

} // end of CliGetPhysicalDevice()

// Given a Channel ID return the Client handle
//
// Currently, this is routine is only called at intr time from
// dmaValidateObjectName, so dmaFindContext has the client handle
// to retrieve the correct DmaObject from the global DmaList. The
// DeviceInstance has already been set.
//
RM_STATUS CliGetClientHandleFromChID(
    PHWINFO pDev,
    U032 ChID,
    U032 *phClient
)
{
    U032 i, j, k, physnum;

    PCLI_FIFO_INFO fifoList;

    *phClient = 0;

    for (i = 0; i < NUM_CLIENTS; i++)
    {
        if (!clientInfo[i].InUse)
            continue;

        if (!clientInfo[i].CliDeviceList)
            continue;

        // scan the client's devices
        for (j = 0; j < NUM_DEVICES; j++)
        {
            if (!clientInfo[i].CliDeviceList[j].InUse)
                continue;

            // look for the DeviceInstance in DeviceList
            CliGetPhysicalDevice(clientInfo[i].CliDeviceList[j].Class, &physnum);
            if (physnum != devInstance)
                continue;

            // see if any "inuse" fifos match this channel ID
            fifoList = clientInfo[i].CliDeviceList[j].DevFifoList;
            if ( ! fifoList)
                continue;

            for (k = 0; k < MAX_FIFOS; k++)
            {
                if (fifoList[k].InUse && (fifoList[k].ChID == ChID))
                {
                    // find the one corresponding to largest client id.
                    // this avoids returning a stale client id in case
                    // of a previous client (using this device/channel)
                    // not being properly freed up.
                    if (clientInfo[i].Handle > *phClient)
                        *phClient = clientInfo[i].Handle;
                }
            }
        }
    }

    if (*phClient != 0)
        return RM_OK;

    return RM_ERR_BAD_OBJECT_ERROR;

} // end of CliGetClientHandleFromChID()

//
// Initialize the client database.
//
RM_STATUS initClientInfo(
    VOID
)
{
    RM_STATUS rmStatus;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initClientInfo\n");

    // allocate table
    rmStatus = osAllocMem((VOID **)&clientInfo, sizeof(CLIENTINFO) * NUM_CLIENTS);
    if (!RM_SUCCESS(rmStatus))
        return rmStatus;

    // initialize the client database
    for (i = 0; i < NUM_CLIENTS; i++)
    {
        clientInfo[i].InUse = FALSE;
        clientInfo[i].AppID = i;
        clientInfo[i].AppHandle = (void *) 0;
        clientInfo[i].CliDeviceList = NULL;
        clientInfo[i].CliHeapOwnerList = NULL;         //added by Chuck Moidel
    }

    return RM_OK;
}

//
// Tear down a clientInfo by free'ing all the memory allocated to it.
//
RM_STATUS destroyClientInfo(
    VOID
)
{
    U032 i, d;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: destroyClientInfo\n");

    if ( ! clientInfo)
        return RM_OK;

    for (i = 0; i < NUM_CLIENTS; i++)
    {
        if ( ! clientInfo[i].CliDeviceList)
            continue;

        for (d = 0; d < NUM_DEVICES; d++)
        {
            if ( ! clientInfo[i].CliDeviceList[d].DevFifoList)
                continue;

            osFreeMem(clientInfo[i].CliDeviceList[d].DevFifoList);
            clientInfo[i].CliDeviceList[d].DevFifoList = NULL;
        }
        osFreeMem(clientInfo[i].CliDeviceList);
        clientInfo[i].CliDeviceList = NULL;
    }

    osFreeMem(clientInfo);
    clientInfo = NULL;

    return RM_OK;
}

// end of client.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\cpuid-ppc.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1999 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1999 NVIDIA, Corp.    NVIDIA  design  patents           *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* CPU Information Gather Routines ***********************\
*                                                                           *
* Module: cpuid-ppc.c                                                       *
*   One time initialization code to setup the Processor type                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <nvcm.h>
#include <os.h>

#ifdef MACOS9
#include <MacTypes.h>
#include <NameRegistry.h>

static U032 PPCAttributes_macos9(
    PHWINFO pDev
)
{
    U032 attributes = 0;
    U032 wc_supported;
    RegEntryIter            cookie;
    RegEntryID              entryID;
    OSStatus                err = noErr;
    RegEntryIterationOp     iterOp;
    Boolean                 done;
        
    // write-combining?
    wc_supported = osReadRegistryBoolean(pDev, "Devices:device-tree:pci", "write-combining");

    if (wc_supported)
          attributes |= NV_CPU_FUNC_WRITE_COMBINING;
    
    // XXX hack for P21s that don't have a rom that sets 'write-combining' (1/2001)
    // WC first supported on P21
    if ( ! wc_supported)
    {
        char model_name[32+1];
        U032 len = sizeof(model_name) - 1;
        if (RM_OK == osReadRegistryBinary(pDev, "Devices:device-tree", "model", (unsigned char *) model_name, &len))
        {
            if (0 == strncmp(model_name, "PowerMac3,4", 11))
               attributes |= NV_CPU_FUNC_WRITE_COMBINING;
        }
    }

    // altivec?
    RegistryEntryIDInit(&entryID);

    iterOp = kRegIterDescendants;
    if (noErr == RegistryEntryIterateCreate(&cookie))
    {
       do
       {
           err = RegistryEntrySearch(&cookie, iterOp,
                                     &entryID, &done, "altivec", (char *) 0, 0);
           if ( ! done && (noErr == err))
           {
               attributes |= NV_CPU_FUNC_ALTIVEC;
               RegistryEntryIDDispose(&entryID);
               done = 1;        // can also be set by RegistryEntrySearch
           }

           iterOp = kRegIterContinue;
       } while ( ! done && (err == noErr));
    }
    RegistryEntryIterateDispose(&cookie);   

    return attributes;
}
#endif

#ifdef MACOSX
static U032 PPCAttributes_macosX(
    PHWINFO pDev
)
{
    U032 attributes = 0;

    return attributes;
}
#endif

/*
 * ID the CPU.
 */
VOID RmInitCpuInfo(
    PHWINFO pDev
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    // XXX
    pRmInfo->Processor.Type = NV_CPU_PPC603;
#if defined(MACOS9)
    pRmInfo->Processor.Type |= PPCAttributes_macos9(pDev);
#elif defined(MACOSX)
    pRmInfo->Processor.Type |= PPCAttributes_macosX(pDev);
#endif

    // Calculate the frequency
    pRmInfo->Processor.Clock = osGetCpuFrequency();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\dload.c ===
/*****************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2001 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2001  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* Module: dload.c                                                           *|
|*    These are the OS-specific bits of implementing dynamic loading of      *|
|* driver code.  Be that from file, ROM/BIOS, etc.                           *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* History:                                                                  *|
|*       Ken Adams (kadams)     02/2001 - wrote it based upon investigatory  *|
|*                                        code from Todd Poynter.            *|
|*                                                                           *|
\*****************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <os.h>

#include <dload.h>
#include <nvdload.h>


#define MakePtr(cast, ptr, addValue) (cast)((unsigned)(ptr) + (addValue))

#define BAIL(r,s,p)  {     \
   ret = (r);              \
   DBG_PRINT_STRING(p ,s); \
   DBG_BREAKPOINT();       \
   goto cleanup;           \
}


RM_STATUS initDload(PHWINFO pDev)
{
#if 0
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
	// The assumption is that the RMINFO global will be
	// filled to zero when we start.  When and if we ever
	// need to do anything more than zero'ing out structs
	// add a flag and test for it... or some such thing.
	pRmInfo->Dload.modules    = 0;
	pRmInfo->Dload.modulesSz  = 0; // How many NV_Image pointers we have allocated.
#endif

    return RM_OK;
}


//-----------------------------------------------------------------------------
// DldLoadModule
// 
// Given a pointer to the binary image as it reside(s,d) in BIOS/ROM or a file,
// perform the necessary steps to bring it in, make it executable, etc. and
// then wire it up.  The original image pointer given will not be held 
// so _that_ memory can be freed as necessary by the caller.
//-----------------------------------------------------------------------------

RM_STATUS DldLoadModule(PHWINFO pDev, NvU8 *pImage)
{
	
	PRMINFO     pRmInfo = (PRMINFO) pDev->pRmInfo;
	RM_STATUS   ret     = RM_OK;
	PDLD_MODULE pMod;
	unsigned    int checkSize, modIdx;
	NvU8        *pRawImg = 0;

	
	for ( modIdx = 0; modIdx < pRmInfo->Dload.modulesSz && pRmInfo->Dload.modules[modIdx] ; modIdx++ ) {;;;;}
	
	if ( RM_OK != osAllocMem((VOID**)&pMod, sizeof(DLD_MODULE) ) ) 
		BAIL(RM_ERROR,"NVRM: oom in DldLoadModule\n",DEBUGLEVEL_ERRORS);

	pMod->refCnt = 0;
	pMod->osHook = 0;

	// The set of all loaded images is managed as a dynamic array of pointers.
	// Zero pointers are by definition unused, and we just attempt to realloc
	// and copy the existing contents if the array needs to grow.  Simple simple.
	// XXX Some sort of locking necessary here

	if ( modIdx == pRmInfo->Dload.modulesSz )  {
		unsigned int j;
		void *p;
		
		// Attempt to grow the number of NV_Image pointers we're holding onto
		// by 4, and then copy the existing ones over...

		if ( RM_OK != osAllocMem( &p, sizeof( PDLD_MODULE ) * 4 ) ) 
			BAIL(RM_ERROR,"NVRM: can't grow PDLD_MODULE array\n",DEBUGLEVEL_ERRORS);
		
		((PDLD_MODULE*)p)[pRmInfo->Dload.modulesSz] = pMod;
		
		for ( j = 1; j < 4 ; j++ )  ((PDLD_MODULE*)p)[j] = 0;
		
		for ( j = 0; j < pRmInfo->Dload.modulesSz ; j++ ) {
			((PDLD_MODULE*)p)[j] =  pRmInfo->Dload.modules[j];
		}
		
		if ( pRmInfo->Dload.modules ) 
			osFreeMem( pRmInfo->Dload.modules );

		pRmInfo->Dload.modules = (PDLD_MODULE*)p;
		pRmInfo->Dload.modulesSz += 4;
		
	} 
	else {
		pRmInfo->Dload.modules[modIdx] = pMod;
	}
	
	// Wire up the pMod with the raw image offsets, etc.
	// The OS-layer must copy out anything it needs such that
	// after linking there will not be any references to this
	// raw image.  Again, the caller can free everything about
	// pImage... pMod however will stay 'round.  So the OS-layer
	// linking code can attach anything it needs via that extra
	// pointer at the end.
	
	pMod->header     = (PNV_ImageHeader)       pImage;

        // See if this is a compressed image.  If so, 'inflate' it here.
        
        if ( pMod->header->compressedSize ) {

                
                if ( RM_OK != osAllocMem((VOID **)&pRawImg, pMod->header->imageSize - sizeof(NV_ImageHeader) ) ) {
                        BAIL(RM_ERROR,"NVRM: oom in DldLoadModule\n",DEBUGLEVEL_ERRORS);
                }

                if ( RM_OK != DldInflate((NvU8*)(pMod->header + 1),pRawImg) ) {
                        BAIL(RM_ERROR,"NVRM: error in DldInflate\n",DEBUGLEVEL_ERRORS);
                }

                pMod->secTable   = (PSectionInfoEntry)    (pRawImg);

        }
        else {
                pMod->secTable   = (PSectionInfoEntry)    (pMod->header     + 1);
        }

        // Refer to 'secTable' above for start of image addressing...

        pMod->relocTable = (PRelocationInfoEntry) (pMod->secTable   + pMod->header->nSections);
        pMod->symTable   = (PSymbolTableEntry)    (pMod->relocTable + pMod->header->nRelocs);
        pMod->dataBuffer = (NvU8*)                (pMod->symTable   + pMod->header->nSymbols);
        pMod->codeBuffer = (NvU8*)                ((NvU8*)pMod->dataBuffer + pMod->header->dataSize);
        pMod->bssBuffer  = 0;
        pMod->footer     = (PNV_ImageFooter)      (pMod->codeBuffer + pMod->header->codeSize);


	checkSize = (unsigned int) ((NvU8*) pMod->footer - (NvU8*) pMod->secTable) + sizeof(NV_ImageFooter);


	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.magicNumber = ", pMod->header->magicNumber);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: footer.magicNumber = ", pMod->footer->magicNumber); 
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.imageSize   = ", pMod->header->imageSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.nSections   = ", pMod->header->nSections);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.nRelocs     = ", pMod->header->nRelocs);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.nSymbols    = ", pMod->header->nSymbols);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.dataSize    = ", pMod->header->dataSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.codeSize    = ", pMod->header->codeSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.bssSize     = ", pMod->header->bssSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: checkSize          = ", checkSize);	


	// Reject egregiously wrong images here.

	if ( (pMod->header->magicNumber != NV_DLOAD_HEADER_MAGIC) 
	     || (pMod->footer->magicNumber != NV_DLOAD_FOOTER_MAGIC) 
	     || (pMod->header->imageSize != (checkSize + sizeof(NV_ImageHeader)) ) ) 
		BAIL(RM_ERROR,"NVRM: bad image",DEBUGLEVEL_ERRORS);

	

	// Now ask the OS-layer to make the image executable by putting it
	// into executable pages, wiring up anything gnarly necessary, etc.

	if ( RM_OK != osDldLinkImg((VOID*)pMod) ) 
		BAIL(RM_ERROR,"NVRM: link error",DEBUGLEVEL_ERRORS);

	pMod->refCnt = 1;

#if 0
	// This is a placeholder for something other than just a "plug-in-the-fn-table" link step.
	{
#define NV_DLOAD_QUERY_IMAGE_LAYER

		int layer;
		void ** nvImgIface;
		typedef RM_STATUS (PDLD_MODULEQueryFn*)(int, void*);

		nvImgIface = (void**)osDloadFindImgSymbol(pMod, NV_DLOAD_IMAGE_ENTRY);
		if ( !nvImgIface ) BAIL(RM_ERROR,"NVRM: can't find image entry point table",DEBUGLEVEL_ERRORS);

		pQueryFn = (PDLD_MODULEQueryFn)nvImgIface[0];
		if ( !pQueryFn ) BAIL(RM_ERROR,"NVRM: can't find image query fn",DEBUGLEVEL_ERRORS);

		// Here we go.  Not much we can do now except assume this is going to work...
		ret = pQueryFn(NV_DLOAD_QUERY_IMAGE_LAYER,(void*)&layer);
		if ( ret != RM_OK ) BAIL(RM_ERROR,"NVRM: can't get image layer",DEBUGLEVEL_ERRORS);
		
		switch (layer) {
			case NV_CFGEX_DLOAD_HAL_LAYER:
			break;

			// Some point later we may want to extend this beyond the HAL?
			case NV_CFGEX_DLOAD_RM_LAYER:
			default:
				BAIL(RM_ERROR,"NVRM: bad image layer",DEBUGLEVEL_ERRORS);
		}
		
	}
#endif
    // Try to find the interface table.
    // Spew what we find.  Wire it in.
    {
	    VOID **iface;

	    iface = (VOID *)DldFindMemOffset(pMod,"_halimg"); // Hack name (see e.g. resman/module/nv20/halimg_nv20.c)

	    if ( ! iface ) {
		    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: can't find iface block");
	    } 
	    else {
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM: hal iface block :",iface);
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:   fntable   :",(unsigned*)(iface[0]));
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:   #clasdesc :",(unsigned*)(iface[1]));
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:    clasdesc :",(unsigned*)(iface[2]));
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:    engdesc  :",(unsigned*)(iface[3]));
	    }

	    // Finish the deed.
	    pDev->pHalFuncs = (PHALFUNCS)iface[0];
    }



    cleanup:

        if ( pRawImg ) {

                osFreeMem((void*)pRawImg);

                pRawImg = 0;
        }

	if ( ret != RM_OK ) {

		if ( pMod ) {
		    
			if ( pMod->refCnt ) {
				(void)osDldUnlinkImg((VOID*)pMod);
			}
			
			if ( pRmInfo->Dload.modules[modIdx] == pMod ) 
				pRmInfo->Dload.modules[modIdx] = 0;
			
			osFreeMem(pMod);
		}
		
	}
    
	return ret;
}





// Given a symbol name, find it's address after linking.

NV_UINTPTR_T DldFindMemOffset(PDLD_MODULE pMod, char *symname) 
{
	unsigned i = 0;
	NvU32 nSymbols = pMod->header->nSymbols;

	// find the symbol with this index
	for (i = 0; i < nSymbols; i++)
	{
		if ( !osStringCompare((const char *)pMod->symTable[i].name,symname) ) {
			return DldGetMemOffset(pMod,pMod->symTable[i].symIndex);
		}
	}

	return ~(NV_UINTPTR_T)0;
}


NV_UINTPTR_T DldGetImageOffset(PDLD_MODULE pMod, unsigned symIndex)
{
	return DldGetMemOffset(pMod,symIndex) - (NV_UINTPTR_T)pMod->dataBuffer;
}


NvU16 DldGetSymbolSection(PDLD_MODULE pMod, unsigned symIndex)
{
	NvU16 j, nSections = pMod->header->nSections;
	NvU32 i, nSymbols  = pMod->header->nSymbols;
	
	// find the symbol with this index
	for (i = 0; i < nSymbols; i++)
	{
		if (pMod->symTable[i].symIndex == symIndex)
		{
			// find the section with this section number and return the memOffset
			// printf("searching for %s's memoffset\n",nv_img.symTable[i].name);
			for (j = 0; j < nSections; j++)
			{
				if(pMod->secTable[j].secNumber == pMod->symTable[i].secNumber)
				{
					return j;
				}
			}
		}
	}

	return ~(NvU16)0;
}


NV_UINTPTR_T DldGetSectionMemOffset(PDLD_MODULE pMod, unsigned secNumber)
{
	NvU16 i, nSections = pMod->header->nSections;

	for ( i=0; i < nSections; i++ ) {
		if ( pMod->secTable[i].secNumber == secNumber ) {
			return (unsigned) pMod->secTable[i].memOffset;
		}
	}
	
	return ~(NV_UINTPTR_T)0;
}


NV_UINTPTR_T DldGetMemOffset(PDLD_MODULE pMod, unsigned symIndex)
{
	NvU16 j, nSections = pMod->header->nSections;
	NvU32 i, nSymbols = pMod->header->nSymbols;
	
	// find the symbol with this index
	for (i = 0; i < nSymbols; i++)
	{
		if (pMod->symTable[i].symIndex == symIndex)
		{
			// find the section with this section number and return the memOffset
			for (j = 0; j < nSections; j++)
			{
				if(pMod->secTable[j].secNumber == pMod->symTable[i].secNumber)
				{
					return((NV_UINTPTR_T) pMod->secTable[j].memOffset + pMod->symTable[i].value);
				}
			}
		}
	}
	
	// The image should never have made it this far...
	// Our images are fully self contained and make no
	// external references...

	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Error: getMemOffset(...) symIndex was not found! ", symIndex);
	
	DBG_BREAKPOINT();
	return ~(NV_UINTPTR_T)0;
}


//------------------------------------------------------------------
// void printImgInfo()
//------------------------------------------------------------------
void DldPrintImgInfo(PDLD_MODULE pMod)
{
	DldPrintSectionInfo(pMod);
	DldPrintRelocationInfo(pMod);
	DldPrintSymbolTableInfo(pMod);
}


//------------------------------------------------------------------
// void printSectionInfo(unsigned nSections)
//------------------------------------------------------------------
void DldPrintSectionInfo(PDLD_MODULE pMod)
{
	unsigned int i = 0;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: PRINTING pMod->secTable ----------------------------");
	for (i = 0; i < pMod->header->nSections; i++)
	{
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"secNumber:      ", pMod->secTable[i].secNumber);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"type:           ", pMod->secTable[i].type);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"dataSize:       ", pMod->secTable[i].dataSize);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"numRelocs:      ", pMod->secTable[i].numRelocs);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"memOffset:      ", pMod->secTable[i].memOffset);

	}
}


//------------------------------------------------------------------
// void printRelocationInfo(unsigned nRelocs)
//------------------------------------------------------------------
void DldPrintRelocationInfo(PDLD_MODULE pMod)
{
	unsigned int i = 0;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: PRINTING pMod->relocTable --------------------------");
	for (i = 0; i < pMod->header->nRelocs; i++)
	{
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"address:        ", pMod->relocTable[i].address);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"symIndex:       ", pMod->relocTable[i].symIndex);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"secNumber:      ", pMod->relocTable[i].secNumber);
	}
}


//------------------------------------------------------------------
// void printSymbolTableInfo(unsigned nSymbols)
//------------------------------------------------------------------
void DldPrintSymbolTableInfo(PDLD_MODULE pMod)
{
	unsigned int i = 0;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: PRINTING pMod->symTable ----------------------------");
	for (i = 0; i < pMod->header->nSymbols; i++)
	{
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"symIndex:       ", pMod->symTable[i].symIndex);
		DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"name:           ");
		DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,pMod->symTable[i].name);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"secNumber:      ", pMod->symTable[i].secNumber);

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\miscr0.c ===
/*----------------------------------------------------------------------------*/
/*
 * miscR0.c
 *
 *      misc ring0 functions
 *	
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#define WANTVXDWRAPS 
#include <basedef.h>
#include <vmm.h>
#include <vxdldr.h>
//#include <debug.h>
#include <vxdwraps.h>
#include <vwin32.h>

#include "nvtypes.h"
#include "nvrmr0api.h"
#include "nvrmwin.h"
#include "nvos.h"

/*----------------------------------------------------------------------------*/
/*
 * pragma's to put the code and data into locked memory (XXX not sure if needed)
 */

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

/*----------------------------------------------------------------------------*/
/*
 * globals
 */

typedef DWORD (* LPDWFN)();
    
/*----------------------------------------------------------------------------*/
/*
 * getApiProcR0 - get the API Proc entry point for a given Vxd from Ring0
 */

LPDWFN getApiProcR0(PCHAR nameVxd)
{

    DWORD	    rc;
    PVMMDDB	    pddb;
    PDEVICEINFO	pdevinfo = NULL;
    
    rc = VXDLDR_LoadDevice( &pddb, &pdevinfo, nameVxd, TRUE); /* XXX what does TRUE do? */
                                                              /* XXX what's the return value */
    if ( (pdevinfo == NULL) || (pddb == NULL) ) {
        return ( NULL );
    }
    else {
        return ( (LPDWFN) pddb->DDB_PM_API_Proc );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\dload_inflate.c ===
/* inflate.c -- Not copyrighted 1992 by Mark Adler
   version c10p1, 10 January 1993 */

/* You can do whatever you like with this source file, though I would
   prefer that if you modify it and redistribute it that you include
   comments to that effect with your name and the date.  Thank you.
   [The history has been moved to the file ChangeLog.]
 */

/*
   Inflate deflated (PKZIP's method 8 compressed) data.  The compression
   method searches for as much of the current string of bytes (up to a
   length of 258) in the previous 32K bytes.  If it doesn't find any
   matches (of at least length 3), it codes the next byte.  Otherwise, it
   codes the length of the matched string and its distance backwards from
   the current position.  There is a single Huffman code that codes both
   single bytes (called "literals") and match lengths.  A second Huffman
   code codes the distance information, which follows a length code.  Each
   length or distance code actually represents a base value and a number
   of "extra" (sometimes zero) bits to get to add to the base value.  At
   the end of each deflated block is a special end-of-block (EOB) literal/
   length code.  The decoding process is basically: get a literal/length
   code; if EOB then done; if a literal, emit the decoded byte; if a
   length then get the distance and emit the referred-to bytes from the
   sliding window of previously emitted data.

   There are (currently) three kinds of inflate blocks: stored, fixed, and
   dynamic.  The compressor deals with some chunk of data at a time, and
   decides which method to use on a chunk-by-chunk basis.  A chunk might
   typically be 32K or 64K.  If the chunk is uncompressible, then the
   "stored" method is used.  In this case, the bytes are simply stored as
   is, eight bits per byte, with none of the above coding.  The bytes are
   preceded by a count, since there is no longer an EOB code.

   If the data is compressible, then either the fixed or dynamic methods
   are used.  In the dynamic method, the compressed data is preceded by
   an encoding of the literal/length and distance Huffman codes that are
   to be used to decode this block.  The representation is itself Huffman
   coded, and so is preceded by a description of that code.  These code
   descriptions take up a little space, and so for small blocks, there is
   a predefined set of codes, called the fixed codes.  The fixed method is
   used if the block codes up smaller that way (usually for quite small
   chunks), otherwise the dynamic method is used.  In the latter case, the
   codes are customized to the probabilities in the current block, and so
   can code it much better than the pre-determined fixed codes.
 
   The Huffman codes themselves are decoded using a mutli-level table
   lookup, in order to maximize the speed of decoding plus the speed of
   building the decoding tables.  See the comments below that precede the
   lbits and dbits tuning parameters.
 */


/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarly, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */

//-----------------------------------------------------------------------------
// nVidia modifications are soley around interface cleanup,                  //
// compiler warnings, etc.  Nothing of any consequence.                      //
// This file comes from the gzip dist'n, but is not covered by GPL           //
// due to the statement at the top.                                          //
//-----------------------------------------------------------------------------

#include <nv_ref.h>
#include <nvrm.h>
#include <os.h>

#define NOMEMCPY 1

typedef NvU8   uch;
typedef NvU16 ush;
typedef NvU32  ulg;


//#include <sys/types.h>
//#include <stdlib.h>


/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model).
   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
   means that v is a literal, 16 < e < 32 means that v is a pointer to
   the next table, which codes e - 16 bits, and lastly e == 99 indicates
   an unused code.  If a code with e == 99 is looked up, this implies an
   error in the data. */
struct huft {
  uch e;                /* number of extra bits or operation */
  uch b;                /* number of bits in this code or subcode */
  union {
    ush n;              /* literal, length base, or distance base */
    struct huft *t;     /* pointer to next level of table */
  } v;
};

#define OF(X) X

/* Function prototypes */
static int huft_build OF((unsigned int *, unsigned int, unsigned int , ush *, ush *,
                   struct huft **, int *));
static int huft_free OF((struct huft *));
static int inflate_codes OF((struct huft *, struct huft *, int, int));
static int inflate_stored OF((void));
static int inflate_fixed OF((void));
static int inflate_dynamic OF((void));
static int inflate_block OF((int *));



/* The inflate algorithm uses a sliding 32K byte window on the uncompressed
   stream to find repeated byte strings.  This is implemented here as a
   circular buffer.  The index is updated simply by incrementing and then
   and'ing with 0x7fff (32K-1). */
/* It is left to other modules to supply the 32K area.  It is assumed
   to be usable as if it were declared "uch slide[32768];" or as just
   "uch *slide;" and then malloc'ed in the latter case.  The definition
   must be in unzip.h, included above. */
/* unsigned wp;             current position in slide */
#define WSIZE 0x8000
static NvU8 *inbuf,*outbuf;
static NvU32 inptr,outptr;
static unsigned int wp;
#define slide window
static uch window[WSIZE];
#define flush_output(w) (wp=(w),flush_window())
#define Tracecv(A,B) 
#define Tracevv(X) 



static void flush_window()
{
        if ( wp == 0) return;

        osMemCopy(outbuf+outptr,window,wp);

        outptr += wp;
        wp = 0;
}


/* Tables for deflate from PKZIP's appnote.txt. */
static unsigned int border[] = {    /* Order of the bit length code lengths */
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
static ush cplens[] = {         /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* note: see note #13 above about the 258 in this list. */
static ush cplext[] = {         /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */
static ush cpdist[] = {         /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
static ush cpdext[] = {         /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};



/* Macros for inflate() bit peeking and grabbing.
   The usage is:
   
        NEEDBITS(j)
        x = b & mask_bits[j];
        DUMPBITS(j)

   where NEEDBITS makes sure that b has at least j bits in it, and
   DUMPBITS removes the bits from b.  The macros use the variable k
   for the number of bits in b.  Normally, b and k are register
   variables for speed, and are initialized at the beginning of a
   routine that uses these macros from a global bit buffer and count.

   If we assume that EOB will be the longest code, then we will never
   ask for bits with NEEDBITS that are beyond the end of the stream.
   So, NEEDBITS should not read any more bytes than are needed to
   meet the request.  Then no bytes need to be "returned" to the buffer
   at the end of the last block.

   However, this assumption is not true for fixed blocks--the EOB code
   is 7 bits, but the other literal/length codes can be 8 or 9 bits.
   (The EOB code is shorter than other codes because fixed blocks are
   generally short.  So, while a block always has an EOB, many other
   literal/length codes have a significantly lower probability of
   showing up at all.)  However, by making the first table have a
   lookup of seven bits, the EOB code will be found in that first
   lookup, and so will not require that too many bits be pulled from
   the stream.
 */

static ulg bb;                         /* bit buffer */
static unsigned int bk;                    /* bits in bit buffer */

static ush mask_bits[] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};

#define NEXTBYTE()  inbuf[inptr++]



#define NEEDBITS(n) {while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}
#define DUMPBITS(n) {b>>=(n);k-=(n);}


/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


const int lbits = 9;          /* bits in base literal/length lookup table */
const int dbits = 6;          /* bits in base distance lookup table */


/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
#define BMAX 16         /* maximum bit length of any code (16 for explode) */
#define N_MAX 288       /* maximum number of codes in any set */


static unsigned int hufts;         /* track memory usage */


static int huft_build(b, n, s, d, e, t, m)
unsigned int *b;            /* code lengths in bits (all assumed <= BMAX) */
unsigned int n;             /* number of codes (assumed <= N_MAX) */
unsigned int s;             /* number of simple-valued codes (0..s-1) */
ush *d;                 /* list of base values for non-simple codes */
ush *e;                 /* list of extra bits for non-simple codes */
struct huft **t;        /* result: starting table */
int *m;                 /* maximum lookup bits, returns actual */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return zero on success, one if
   the given code set is incomplete (the tables are still built in this
   case), two if the input is invalid (all zero length codes or an
   oversubscribed set of lengths), and three if not enough memory. */
{
  unsigned int a;                   /* counter for codes of length k */
  unsigned int c[BMAX+1];           /* bit length count table */
  unsigned int f;                   /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  unsigned int i;          /* counter, current code */
  unsigned int j;          /* counter */
  int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  unsigned int *p;         /* pointer into c[], b[], or v[] */
  struct huft *q;      /* points to current table */
  struct huft r;                /* table entry for structure assignment */
  struct huft *u[BMAX];         /* table stack */
  unsigned int v[N_MAX];            /* values in order of bit length */
  int w;               /* bits before this table == (l * h) */
  unsigned int x[BMAX+1];           /* bit offsets, then code stack */
  unsigned int *xp;                 /* pointer into x */
  int y;                        /* number of dummy codes added */
  unsigned int z;                   /* number of entries in current table */


  /* Generate counts for each bit length */
  osMemSet((VOID*)c,0,sizeof(c));

  p = b;  i = n;
  do {
    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? "%c %d\n" : "0x%x %d\n"), 
	    n-i, *p));
    c[*p]++;                    /* assume all entries <= BMAX */
    p++;                      /* Can't combine with above line (Solaris bug) */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (struct huft *)NULL;
    *m = 0;
    return 0;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((unsigned int)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((unsigned int)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return 2;                 /* bad input: more codes than bits */
  if ((y -= c[i]) < 0)
    return 2;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
  q = (struct huft *)NULL;      /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = (z = g - w) > (unsigned int)l ? l : z;  /* upper limit on table size */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          while (++j < z)       /* try smaller tables up to z bits */
          {
            if ((f <<= 1) <= *++xp)
              break;            /* enough codes to use up j bits */
            f -= *xp;           /* else deduct codes from patterns */
          }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate and link in new table */

        osAllocMem((void**)&q,(z + 1)*sizeof(struct huft));

        if (q == (struct huft *)NULL)
        {
          if (h)
            huft_free(u[0]);
          return 3;             /* not enough memory */
        }
        hufts += z + 1;         /* track memory usage */
        *t = q + 1;             /* link to list for huft_free() */
        *(t = &(q->v.t)) = (struct huft *)NULL;
        u[h] = ++q;             /* table starts after link */

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.b = (uch)l;         /* bits to dump before this table */
          r.e = (uch)(16 + j);  /* bits in this table */
          r.v.t = q;            /* pointer to this table */
          j = i >> (w - l);     /* (get around Turbo C bug) */
          u[h-1][j] = r;        /* connect to last table */
        }
      }

      /* set up table entry in r */
      r.b = (uch)(k - w);
      if (p >= v + n)
        r.e = 99;               /* out of values--invalid code */
      else if (*p < s)
      {
        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
        r.v.n = (ush)(*p);             /* simple code is just the value */
	p++;                           /* one compiler does not like *p++ */
      }
      else
      {
        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */
        r.v.n = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
      }
    }
  }


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
}



static int huft_free(t)
struct huft *t;         /* table to free */
/* Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
  struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
  {
    q = (--p)->v.t;
    osFreeMem((char*)p);
    p = q;
  } 
  return 0;
}


static int inflate_codes(tl, td, bl, bd)
struct huft *tl, *td;   /* literal/length and distance decoder tables */
int bl, bd;             /* number of bits decoded by tl[] and td[] */
/* inflate (decompress) the codes in a deflated (compressed) block.
   Return an error code or zero if it all goes ok. */
{
  unsigned int e;  /* table entry flag/number of extra bits */
  unsigned int n, d;        /* length and index for copy */
  unsigned int w;           /* current window position */
  struct huft *t;       /* pointer to table entry */
  unsigned int ml, md;      /* masks for bl and bd bits */
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local copies of globals */
  b = bb;                       /* initialize bit buffer */
  k = bk;
  w = wp;                       /* initialize window position */

  /* inflate the coded data */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
  for (;;)                      /* do until end of block */
  {
    NEEDBITS((unsigned)bl)
    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
      do {
        if (e == 99)
          return 1;
        DUMPBITS(t->b)
        e -= 16;
        NEEDBITS(e)
      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
    DUMPBITS(t->b)
    if (e == 16)                /* then it's a literal */
    {
      slide[w++] = (uch)t->v.n;
      Tracevv((stderr, "%c", slide[w-1]));
      if (w == WSIZE)
      {
        flush_output(w);
        w = 0;
      }
    }
    else                        /* it's an EOB or a length */
    {
      /* exit if end of block */
      if (e == 15)
        break;

      /* get length of block to copy */
      NEEDBITS(e)
      n = t->v.n + ((unsigned)b & mask_bits[e]);
      DUMPBITS(e);

      /* decode distance of block to copy */
      NEEDBITS((unsigned)bd)
      if ((e = (t = td + ((unsigned)b & md))->e) > 16)
        do {
          if (e == 99)
            return 1;
          DUMPBITS(t->b)
          e -= 16;
          NEEDBITS(e)
        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
      DUMPBITS(t->b)
      NEEDBITS(e)
      d = w - t->v.n - ((unsigned)b & mask_bits[e]);
      DUMPBITS(e)
      Tracevv((stderr,"\\[%d,%d]", w-d, n));

      /* do the copy */
      do {
        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);
#if !defined(NOMEMCPY) && !defined(DEBUG)
        if (w - d >= e)         /* (this test assumes unsigned comparison) */
        {
          memcpy(slide + w, slide + d, e);
          w += e;
          d += e;
        }
        else                      /* do it slow to avoid memcpy() overlap */
#endif /* !NOMEMCPY */
          do {
            slide[w++] = slide[d++];
	    Tracevv((stderr, "%c", slide[w-1]));
          } while (--e);
        if (w == WSIZE)
        {
          flush_output(w);
          w = 0;
        }
      } while (n);
    }
  }


  /* restore the globals from the locals */
  wp = w;                       /* restore global window pointer */
  bb = b;                       /* restore global bit buffer */
  bk = k;

  /* done */
  return 0;
}



static int inflate_stored()
/* "decompress" an inflated type 0 (stored) block. */
{
  unsigned int n;           /* number of bytes in block */
  unsigned int w;           /* current window position */
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local copies of globals */
  b = bb;                       /* initialize bit buffer */
  k = bk;
  w = wp;                       /* initialize window position */


  /* go to byte boundary */
  n = k & 7;
  DUMPBITS(n);


  /* get the length and its complement */
  NEEDBITS(16)
  n = ((unsigned int)b & 0xffff);
  DUMPBITS(16)
  NEEDBITS(16)
  if (n != (unsigned int)((~b) & 0xffff))
    return 1;                   /* error in compressed data */
  DUMPBITS(16)


  /* read and output the compressed data */
  while (n--)
  {
    NEEDBITS(8)
    slide[w++] = (uch)b;
    if (w == WSIZE)
    {
      flush_output(w);
      w = 0;
    }
    DUMPBITS(8)
  }


  /* restore the globals from the locals */
  wp = w;                       /* restore global window pointer */
  bb = b;                       /* restore global bit buffer */
  bk = k;
  return 0;
}



static int inflate_fixed()
/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
   either replace this with a custom decoder, or at least precompute the
   Huffman tables. */
{
  int i;                /* temporary variable */
  struct huft *tl;      /* literal/length code table */
  struct huft *td;      /* distance code table */
  int bl;               /* lookup bits for tl */
  int bd;               /* lookup bits for td */
  unsigned int l[288];      /* length list for huft_build */


  /* set up literal table */
  for (i = 0; i < 144; i++)
    l[i] = 8;
  for (; i < 256; i++)
    l[i] = 9;
  for (; i < 280; i++)
    l[i] = 7;
  for (; i < 288; i++)          /* make a complete, but wrong code set */
    l[i] = 8;
  bl = 7;
  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0)
    return i;


  /* set up distance table */
  for (i = 0; i < 30; i++)      /* make an incomplete code set */
    l[i] = 5;
  bd = 5;
  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)
  {
    huft_free(tl);
    return i;
  }


  /* decompress until an end-of-block code */
  if (inflate_codes(tl, td, bl, bd))
    return 1;


  /* free the decoding tables, return */
  huft_free(tl);
  huft_free(td);
  return 0;
}



static int inflate_dynamic()
/* decompress an inflated type 2 (dynamic Huffman codes) block. */
{
  int i;                /* temporary variables */
  unsigned int j;
  unsigned int l;           /* last length */
  unsigned int m;           /* mask for bit lengths table */
  unsigned int n;           /* number of lengths to get */
  struct huft *tl;      /* literal/length code table */
  struct huft *td;      /* distance code table */
  int bl;               /* lookup bits for tl */
  int bd;               /* lookup bits for td */
  unsigned int nb;          /* number of bit length codes */
  unsigned int nl;          /* number of literal/length codes */
  unsigned int nd;          /* number of distance codes */
#ifdef PKZIP_BUG_WORKAROUND
  unsigned int ll[288+32];  /* literal/length and distance code lengths */
#else
  unsigned int ll[286+30];  /* literal/length and distance code lengths */
#endif
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local bit buffer */
  b = bb;
  k = bk;


  /* read in table lengths */
  NEEDBITS(5)
  nl = 257 + ((unsigned int)b & 0x1f);      /* number of literal/length codes */
  DUMPBITS(5)
  NEEDBITS(5)
  nd = 1 + ((unsigned int)b & 0x1f);        /* number of distance codes */
  DUMPBITS(5)
  NEEDBITS(4)
  nb = 4 + ((unsigned int)b & 0xf);         /* number of bit length codes */
  DUMPBITS(4)
#ifdef PKZIP_BUG_WORKAROUND
  if (nl > 288 || nd > 32)
#else
  if (nl > 286 || nd > 30)
#endif
    return 1;                   /* bad lengths */


  /* read in bit-length-code lengths */
  for (j = 0; j < nb; j++)
  {
    NEEDBITS(3)
    ll[border[j]] = (unsigned int)b & 7;
    DUMPBITS(3)
  }
  for (; j < 19; j++)
    ll[border[j]] = 0;


  /* build decoding table for trees--single level, 7 bit lookup */
  bl = 7;
  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
  {
    if (i == 1)
      huft_free(tl);
    return i;                   /* incomplete code set */
  }


  /* read in literal and distance code lengths */
  n = nl + nd;
  m = mask_bits[bl];
  i = l = 0;
  while ((unsigned int)i < n)
  {
    NEEDBITS((unsigned int)bl)
    j = (td = tl + ((unsigned int)b & m))->b;
    DUMPBITS(j)
    j = td->v.n;
    if (j < 16)                 /* length of code in bits (0..15) */
      ll[i++] = l = j;          /* save last length in l */
    else if (j == 16)           /* repeat last length 3 to 6 times */
    {
      NEEDBITS(2)
      j = 3 + ((unsigned int)b & 3);
      DUMPBITS(2)
      if ((unsigned int)i + j > n)
        return 1;
      while (j--)
        ll[i++] = l;
    }
    else if (j == 17)           /* 3 to 10 zero length codes */
    {
      NEEDBITS(3)
      j = 3 + ((unsigned int)b & 7);
      DUMPBITS(3)
      if ((unsigned int)i + j > n)
        return 1;
      while (j--)
        ll[i++] = 0;
      l = 0;
    }
    else                        /* j == 18: 11 to 138 zero length codes */
    {
      NEEDBITS(7)
      j = 11 + ((unsigned int)b & 0x7f);
      DUMPBITS(7)
      if ((unsigned int)i + j > n)
        return 1;
      while (j--)
        ll[i++] = 0;
      l = 0;
    }
  }


  /* free decoding table for trees */
  huft_free(tl);


  /* restore the global bit buffer */
  bb = b;
  bk = k;


  /* build the decoding tables for literal/length and distance codes */
  bl = lbits;
  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
  {
    if (i == 1) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: dload, incomplete literal tree");

      huft_free(tl);
    }
    return i;                   /* incomplete code set */
  }
  bd = dbits;
  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
  {
    if (i == 1) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: dload, incomplete distance tree");

#ifdef PKZIP_BUG_WORKAROUND
      i = 0;
    }
#else
      huft_free(td);
    }
    huft_free(tl);
    return i;                   /* incomplete code set */
#endif
  }


  /* decompress until an end-of-block code */
  if (inflate_codes(tl, td, bl, bd))
    return 1;


  /* free the decoding tables, return */
  huft_free(tl);
  huft_free(td);
  return 0;
}



static int inflate_block(e)
int *e;                 /* last block flag */
/* decompress an inflated block */
{
  unsigned int t;           /* block type */
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local bit buffer */
  b = bb;
  k = bk;


  /* read in last block bit */
  NEEDBITS(1)
  *e = (int)b & 1;
  DUMPBITS(1)


  /* read in block type */
  NEEDBITS(2)
  t = (unsigned int)b & 3;
  DUMPBITS(2)


  /* restore the global bit buffer */
  bb = b;
  bk = k;


  /* inflate that block type */
  if (t == 2)
    return inflate_dynamic();
  if (t == 0)
    return inflate_stored();
  if (t == 1)
    return inflate_fixed();


  /* bad block type */
  return 2;
}


/* nVidia addition: give pointers to input and known-large-enough output buffers. */

RM_STATUS DldInflate(NvU8 *inBuffer, NvU8 *outBuffer)
/* decompress an inflated entry */
{
  int e;                /* last block flag */
  int r;                /* result code */
  unsigned int h;           /* maximum struct huft's malloc'ed */

  inptr  = 0;
  outptr = 0;

  inbuf  = inBuffer;
  outbuf = outBuffer;

  /* initialize window, bit buffer */
  wp = 0;
  bk = 0;
  bb = 0;


  /* decompress until the last block */
  h = 0;
  do {
    hufts = 0;
    if ((r = inflate_block(&e)) != 0)
      return RM_ERROR;
    if (hufts > h)
      h = hufts;
  } while (!e);

  /* Undo too much lookahead. The next read will be byte aligned so we
   * can discard unused bits in the last meaningful byte.
   */
  while (bk >= 8) {
    bk -= 8;
    inptr--;
  }

  /* flush out slide */
  flush_output(wp);


  /* return success */

  return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvapi.c ===
/******************************************************************************
*
*	Module: nvapi.c
*
*   Description:
*       This module is the main entry module into the NV Architecture Driver.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <nvrm.h>
#include <nv32.h>
#include <nv_ref.h>
#include <nvhw.h>
#include <rmfail.h>

#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <event.h>
#include <fifo.h>
#include <fb.h>
#include <gr.h>
#include <heap.h>
#include <tmr.h>
#include <mc.h>
#include <client.h>

#include <os.h>
#include <nvos.h>
#include <nvarch.h>
#include <smp.h>

PCLIENTINFO clientInfo;
U032        ClientInstance;
#ifdef DEBUG
PCLIENTINFO pClient;
U032 clientSize = sizeof(CLIENTINFO);
#endif

// NV4+ passes around an element of this table instead of using a global index
PHWINFO     NvDBPtr_Table[MAX_INSTANCE]={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

RMINFO      NvRmInfo;

// globals used by the OS specific calls
U032        nvInfoSelector      = 0;
U032        clientInfoSelector  = 0;
U032        rmInService;
U032        osInService;
U032        rmInSafeService;
U032        rmInCallback;

// NV RM API functions

/*
NV01_ALLOC_ROOT
    NVOS01_PARAMETERS:
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 status
*/
VOID Nv01AllocRoot(
    NVOS01_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating root...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    class:", ARG(hClass));

    ARG(status) = RmAllocClient(
        &ARG(hObjectNew),
        ARG(hClass)
    );
    if (ARG(status) == NVOS01_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   client:", ARG(hObjectNew));
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...root object allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...root object allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
    }

} // end of Nv01AllocRoot()

/*
NV01_ALLOC_DEVICE
    NVOS06_PARAMETERS:
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvP64 szName
        NvV32 status
*/
VOID Nv01AllocDevice(
    NVOS06_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating device...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   client:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   device:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    class:", ARG(hClass));

    NVRM_TRACE_API('ADEV', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
 
    ARG(status) = RmAllocDevice(
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
#if _WIN32_WINNT >= 0x0400
        (char*)ARG_P064(szName)
#else
        (char*)ARG(szName)
#endif
    );
    if (ARG(status) == NVOS06_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...device allocation complete\n");
        NVRM_TRACE('adev');
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...device allocation *FAILED*\n");
        NVRM_TRACE_ERROR('adev', ARG(status));
    }

} // end of Nv01AllocDevice()

/*
NV01_ALLOC_CONTEXT_DMA
    NVOS03_PARAMETERS:
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 flags
        NvP64 pBase
        NvU64 limit
        NvV32 status
*/
VOID Nv01AllocContextDma(
    NVOS03_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating DMA context...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    client:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   context:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     flags:", ARG(flags));
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:     pBase:", (VOID*)ARG_P064(pBase));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", (U032)ARG_U064(limit));

    NVRM_TRACE_API('ACTX', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
    NVRM_TRACE3(ARG(flags), (U032) ARG_P064(pBase), (U032) ARG_U064(limit));

    ARG(status) = RmAllocContextDma(
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(flags),
        ARG_SELECTOR(pBase),
        (VOID *)ARG_P064(pBase),
        (U032)ARG_U064(limit)
    );
    if (ARG(status) == NVOS03_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...DMA context allocation complete\n");
        NVRM_TRACE('actx');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: ...DMA context allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    client:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:   context:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:     flags:", ARG(flags));
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_USERERRORS , "NVRM:     pBase:", (VOID*)ARG_P064(pBase));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:     limit:", (U032)ARG_U064(limit));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('actx', ARG(status));
    }

} // end of Nv01AllocContextDma()

/*
NV01_ALLOC_CHANNEL_PIO
    NVOS04_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 hObjectError
        NvP64 pChannel
        NvV32 flags
        NvV32 status
*/
VOID Nv01AllocChannelPio(
    NVOS04_PARAMETERS *pArgs
)
{
    VOID *channel;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating PIO channel...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    device:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     error:", ARG(hObjectError));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     flage:", ARG(flags));

    // allocate the PIO channel
    ARG(status) = RmAllocChannelPio(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(hObjectError),
        &channel,
        ARG(flags)
    );
    ARG_P064(pChannel) = (NvP64_VALUE_T)channel;
    if (ARG(status) == NVOS04_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...PIO channel allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...PIO channel allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
    }

} // end of Nv01AllocChannelPio()

/*
NV03_ALLOC_CHANNEL_DMA
    NVOS07_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 hObjectError
        NvV32 hObjectBuffer
        NvU32 offset
        NvP64 pControl
        NvV32 status
*/
VOID Nv03AllocChannelDma(
    NVOS07_PARAMETERS *pArgs
)
{
    VOID *control;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating DMA channel...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      device:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     channel:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:       class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   error ctx:", ARG(hObjectError));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    data ctx:", ARG(hObjectBuffer));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      offset:", ARG(offset));

    // allocate DMA channel
    ARG(status) = RmAllocChannelDma(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(hObjectError),
        ARG(hObjectBuffer),
        ARG(offset),
        &control
    );
    ARG_P064(pControl) = (NvP64_VALUE_T)control;
    if (ARG(status) == NVOS07_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMA channel allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,  "NVRM: ...DMA channel allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      device:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     channel:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:       class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   error ctx:", ARG(hObjectError));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    data ctx:", ARG(hObjectBuffer));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      offset:", ARG(offset));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      status:", ARG(status));
    }

} // end of Nv03AllocChannelDma()

/*
NV01_ALLOC_MEMORY
        NVOS02_PARAMETERS:
        NvV32 hRoot;       
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 flags;
        NvP64 pMemory;
        NvU64 pLimit;
        NvV32 status;
*/
VOID Nv01AllocMemory(
    NVOS02_PARAMETERS *pArgs
)
{
    VOID *memory;
    U032 limit;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating memory...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    parent:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    memory:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     flags:", ARG(flags));
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:   pMemory:", (VOID*)ARG_P064(pMemory));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     limit:", (U032)ARG_U064(pLimit));

    // allocate memory

    memory = (VOID *)ARG_P064(pMemory);
    limit = (U032)ARG_U064(pLimit);

    NVRM_TRACE_API('AMEM', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
    NVRM_TRACE3(ARG(flags), (U032) ARG_P064(pMemory), (U032) ARG_U064(pLimit));

    ARG(status) = RmAllocMemory(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(flags),
        &memory,
        &limit
    );

    ARG_P064(pMemory) = (NvP64_VALUE_T)memory;
    ARG_U064(pLimit) = (NvU64_VALUE_T)limit;

    if (ARG(status) == NVOS02_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...memory allocation complete\n");
        NVRM_TRACE2('amem', (U032) memory);
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,  "NVRM: ...memory allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    parent:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    memory:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     flags:", ARG(flags));
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_USERERRORS ,  "NVRM:   pMemory:", (VOID*)ARG_P064(pMemory));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     limit:", (U032)ARG_U064(pLimit));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('amem', ARG(status));
    }

} // end of Nv01AllocMemory()


/*
NV01_ALLOC_DEVICE
    NVOS05_PARAMETERS
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 status;
*/
VOID Nv01AllocObject(
    NVOS05_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));

    NVRM_TRACE_API('AOBJ', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));

    ARG(status) = RmAllocObject(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass)
    );
    if (ARG(status) == NVOS05_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...object allocation complete\n");
        NVRM_TRACE('aobj');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...object allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   channel:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    object:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('aobj', ARG(status));
    }

} // end of Nv01AllocObject()

/*
NV04_ALLOC
    NVOS21_PARAMETERS;
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvP64 pAllocParms;
        NvV32 status;
*/
VOID Nv04Alloc(
    NVOS21_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));

    NVRM_TRACE_API('ALOC', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
    NVRM_TRACE((U032) ARG_P064(pAllocParms));

    ARG(status) = RmAlloc(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        (VOID *) ARG_P064(pAllocParms)
    );
    if (ARG(status) == NVOS21_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...allocation complete\n");
        NVRM_TRACE('aloc');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   channel:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    object:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('aloc', ARG(status));
    }

} // end of Nv04Alloc()

/*
NV01_ALLOC_EVENT
    NVOS10_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 index;
        NvU64 hEvent;
        NvV32 status;
*/
VOID Nv01AllocEvent(
    NVOS10_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating Event...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   class:",  ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   index:",  ARG(index));
    DBG_PRINT_STRING_VAL64(DEBUGLEVEL_TRACEINFO,  "NVRM:   event:",  ARG(hEvent));

    ARG(status) = RmAllocEvent(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(index),
        ARG(hEvent)
    );
    if (ARG(status) == NVOS10_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...event allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...event allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   channel:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    object:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     index:",  ARG(index));
        DBG_PRINT_STRING_VAL64(DEBUGLEVEL_USERERRORS ,  "NVRM:     event:",  ARG(hEvent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01AllocEvent()

/*
NV01_FREE
    NVOS00_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectOld;
        NvV32 status;
*/
VOID Nv01Free(
    NVOS00_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Freeing object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   parent:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectOld));

    NVRM_TRACE_API('FREE', ARG(hRoot), ARG(hObjectParent), ARG(hObjectOld));

    ARG(status) = RmFree(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectOld)
    );
    if (ARG(status) == NVOS00_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...object free complete\n");
        NVRM_TRACE('free');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...object free *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   parent:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   object:", ARG(hObjectOld));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   status:", ARG(status));
        NVRM_TRACE_ERROR('free', ARG(status));
    }

} // end of Nv01Free()

/*
NV03_DMA_FLOW_CONTROL
    NVOS08_PARAMETERS:
        NvV32 hChannel
        NvV32 flags
        NvU32 put
        NvU32 get
        NvV32 status
*/
VOID Nv03DmaFlowControl(
    NVOS08_PARAMETERS *pArgs
)
{
    // This function is not valid on NV4 and later devices.
    ARG(status) = NVOS08_STATUS_ERROR_BAD_OBJECT_PARENT;
    if (ARG(status) == NVOS08_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMA channel flow control complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...DMA channel flow control *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
    }
} // end of Nv3DmaFlowControl()

/*
NV01_ARCH_HEAP
    NVOS11_PARAMETERS;
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvU32 function;
        NvU32 owner;
        NvU32 type;
        NvU32 depth;
        NvU32 width;
        NvU32 height;
        NvS32 pitch;
        NvU32 offset;
        NvU32 size;
        NvP64 address;
        NvU64 limit;
        NvU32 total;
        NvU32 free;
        NvV32 status;
*/
VOID Nv03ArchHeap(
    NVOS11_PARAMETERS *pArgs
)
{
    VOID *address;
    
	DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Arch Heap...\n");
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hRoot));
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hObjectParent));

    NVRM_TRACE_API('HEAP', ARG(hObjectParent), ARG(function), ARG(owner));
    NVRM_TRACE3(ARG(type), ARG(width), ARG(height));

    ARG(status) = RmArchHeap(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(function),
        ARG(owner),
        ARG(type),
        ARG(depth),
        ARG(width),
        ARG(height),
        &ARG(pitch),
        &ARG(offset),
        &ARG(size),
        &address,
        &ARG(limit),
        &ARG(total),
        &ARG(free)
    );
#if defined(NVRM_64)
    ARG_P064(address) = (NvP64_VALUE_T)address;
#else
    ARG(address) = (NvU32)address;
#endif
    if (ARG(status) == NVOS11_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Arch Heap complete\n");
        NVRM_TRACE2('heap', (U032) address);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Arch Heap *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('heap', ARG(status));
    }
} // end of Nv03ArchHeap()

/*
NV01_CONFIG_VERSION:
    NVOS12_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 version;
        NvV32 status;
*/
VOID Nv01ConfigVersion(
    NVOS12_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Version...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Version:", ARG(version));

    ARG(status) = RmConfigVersion(
        ARG(hClient),
        ARG(hDevice),
        &ARG(version)
    );
    if (ARG(status) == NVOS12_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Version complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Version *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigVersion()

/*
NV01_CONFIG_GET:
    NVOS13_PARAMETERS:
      NvV32 hClient;
      NvV32 hDevice;
      NvV32 index;
      NvV32 value;
      NvV32 status;
*/
VOID Nv01ConfigGet(
    NVOS13_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Get...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Index:", ARG(index));

    // get a specific configuration value
    ARG(status) = RmConfigGet(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
        &ARG(value)
    );
    if (ARG(status) == NVOS13_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Get complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Get *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigGet()

/*
NV01_CONFIG_SET:
    NVOS14_PARAMETERS:
      NvV32 hClient;
      NvV32 hDevice;
      NvV32 index;
      NvV32 oldValue;
      NvV32 newValue;
      NvV32 status;
*/
VOID Nv01ConfigSet(
    NVOS14_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: Setting Configuration...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Value:", ARG(newValue));

    // set a specific configuration value
    ARG(status) = RmConfigSet(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
        &ARG(oldValue),
        ARG(newValue)
    );
    if (ARG(status) == NVOS14_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Set complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Set *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigSet()

/*
NV01_CONFIG_UPDATE:
    NVOS15_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 flags;
        NvV32 status;
*/
VOID Nv01ConfigUpdate(
    NVOS15_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Update...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Flags:", ARG(flags));

    ARG(status) = RmConfigUpdate(
        ARG(hClient),
        ARG(hDevice),
        ARG(flags)
    );
    if (ARG(status) == NVOS15_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Update complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Update *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigUpdate()

/*
NV04_CONFIG_GET_EX:
    NVOS_CONFIG_GET_EX_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 index;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04ConfigGetEx(
    NVOS_CONFIG_GET_EX_PARAMS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: config getEx...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: Parm size:", ARG(paramSize));

    ARG(status) = RmConfigGetEx(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr),
#else
        (VOID*)ARG(paramStructPtr),
#endif
        ARG(paramSize)
    );
    if (ARG(status) == NVOS_CGE_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...config getEx complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...config getEx *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04ConfigGetEx()

/*
NV04_CONFIG_SET_EX:
    NVOS_CONFIG_SET_EX_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 index;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04ConfigSetEx(
    NVOS_CONFIG_SET_EX_PARAMS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: config SetEx...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: Parm size:", ARG(paramSize));

    ARG(status) = RmConfigSetEx(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr),
#else
        (VOID*)ARG(paramStructPtr),
#endif
        ARG(paramSize)
    );
    if (ARG(status) == NVOS_CSE_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...config SetEx complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...config SetEx *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04ConfigSetEx()

/*
NV01_INTERRUPT:
    NVOS09_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 status;
*/

VOID Nv01Interrupt(
    NVOS09_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: interrupt...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));


    // service an interrupt
    ARG(status) = RmInterrupt(
        ARG(hClient),
        ARG(hDevice)
    );
    if (ARG(status) == NVOS09_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...interrupt service complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...interrupt service *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01Interrupt()

#ifdef WIN32
/*
NV04_RING0_CALLBACK:
    NVRM_RING0CALLBACK_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvP64 functionPtr;
        NvU32 param1;
        NvU32 param2;
        NvV32 status;
    typedef NvU32 (*RING0CALLBACKPROC)(NvU32, NvU32);
*/
VOID NvRing0Callback(
    NVRM_RING0CALLBACK_PARAMS *pArgs
)
{
#if _WIN32_WINNT >= 0x0400
    RING0CALLBACKPROC callbackFct = (RING0CALLBACKPROC)ARG_P064(functionPtr);
#else
    RING0CALLBACKPROC callbackFct = ARG(functionPtr);
#endif

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Ring 0 Callback...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG_P064(functionPtr));
#else
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG(functionPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   param1:", ARG(param1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   param2:", ARG(param2));

    ARG(status) = callbackFct(
        ARG(param1),
        ARG(param2)
    );
    if (ARG(status) == NVOS16_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Ring 0 Callback complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Ring 0 Callback *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of NvRing0Callback()
#endif

/*
NV04_I2C_ACCESS
    NVOS_I2C_ACCESS_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04I2CAccess(
    NVOS_I2C_ACCESS_PARAMS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: I2C Access...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(paramSize));

    ARG(status) = RmI2CAccess(
        ARG(hClient),
        ARG(hDevice),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr)
#else
        (VOID*)ARG(paramStructPtr)
#endif
    );
    if (ARG(status) == NVOS_I2C_ACCESS_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...I2C Access complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...I2C Access *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04I2CAccess()

/*
NV04_DIRECT_METHOD_CALL
    NVOS1D_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectOld;
        NvV32 method;
        NvV32 data;
        NvV32 status;
*/
VOID Nv04DirectMethodCall(
    NVOS1D_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Performing Direct Method Call...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectOld));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   method:", ARG(method));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   data:", ARG(data));

    ARG(status) = RmDirectMethodCall(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectOld),
        ARG(method),
        ARG(data)
    );
    if (ARG(status) == NVOS1D_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMC complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...DMC *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04DirectMethodCall()

NvV32 RmAllocClient(
    U032 *phClient,
    U032 hClass
)
{
    RM_STATUS rmStatus = RM_OK;

    // register a new client and return the client handle
    rmStatus = CliAddClient(phClient, hClass);

    return RmArchStatus(rmStatus, NV01_ALLOC_ROOT);

} // end of RmAllocClient

NvV32 RmAllocDevice(
    NvV32 hClient,
    NvV32 hDevice,
    NvV32 hClass,
    char *szName
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_DEVICE);
    }

    // The caller has to either pass a valid device class (NV01_DEVICE_0 through NV01_DEVICE_7)
    // or pass NV03_DEVICE_XX as the hClass and pass the name of the device in szName.
    rmStatus = osDeviceNameToDeviceClass(szName, &hClass);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_BAD_CLASS, NV01_ALLOC_DEVICE);
    }

    // add new device to client and set the device context
    rmStatus = CliAddDevice(hClient, hDevice, hClass);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_DEVICE);
    }

    // register all DMA contexts with the device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        rmStatus = dmaRegisterToDevice(pDev, pDmaInfo, &pDmaObject);
        if (!RM_SUCCESS(rmStatus))
        {
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);

} // end of RmAllocDevice

NvV32 RmAllocContextDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    VOID* base,
    U032 limit
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PCLI_DEVICE_INFO deviceList = 0;
    PCLI_FIFO_INFO fifoList;
    PDMAOBJECT pDmaObject;
    U032 i, j, hDeviceWithFrameBufferCtx = 0;
    PHWINFO pDev;

    // A limit of 0 is not valid.
    if (limit == 0)
    {
        return NVOS03_STATUS_ERROR_BAD_LIMIT;
    }

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
    }

    // add DMA context to client
    rmStatus = CliAddDma(hClient, hDma, hClass, flags, selector, base, limit, &pDmaInfo);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(rmStatus, NV01_ALLOC_CONTEXT_DMA);
    }

    // TO DO: USE FLAGS FOR CREATION??

    // lock down DMA pages -- zero length is not an error for legacy reasons
    if (pDmaInfo->DescLimit != 0)
    {
        // validate DMA buffer address, searching each device's FB
        if ((deviceList = CliGetDeviceList()) == NULL)
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
        }
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
                {
                    RmFreeContextDma(hClient, hDma);
                    return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
                }
                rmStatus = osGetAddressInfo(
                    pDev,
                    0 /* ChId */,
                    pDmaInfo->DescSelector,
                    &pDmaInfo->DescOffset,
                    pDmaInfo->DescLimit,
                    &pDmaInfo->DescAddr,
                    &pDmaInfo->AddressSpace
                    );

                if (!RM_SUCCESS(rmStatus))
                {
                    RmFreeContextDma(hClient, hDma);
                    return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_CONTEXT_DMA);
                }
                if (pDmaInfo->AddressSpace != ADDR_UNKNOWN)
                {
                    // found the buffer -- remember the device, if the context describes a frame buffer
                    hDeviceWithFrameBufferCtx = (pDmaInfo->AddressSpace == ADDR_FBMEM) ? deviceList[i].Handle : 0;
                    break;
                }
            }
        }

        // calculate page table values
        pDmaInfo->BufferSize = pDmaInfo->DescLimit + 1;
        osCalculatePteAdjust(pDev, pDmaInfo->AddressSpace, pDmaInfo->DescAddr, &pDmaInfo->PteAdjust);
        pDmaInfo->PteLimit   = pDmaInfo->DescLimit; // pDmaInfo->PteAdjust + pDmaInfo->BufferSize;
        pDmaInfo->PteCount   = (pDmaInfo->PteLimit + pDmaInfo->PteAdjust + RM_PAGE_SIZE - 1) >> RM_PAGE_SHIFT;
        rmStatus = osAllocMem((VOID **)&(pDmaInfo->PteArray), pDmaInfo->PteCount * 4);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_CONTEXT_DMA);
        }

        // lock DMA buffer
        rmStatus = osLockUserMem(
            pDev,
            INVALID_CHID,
            pDmaInfo->DescSelector,
            pDmaInfo->DescOffset,
            pDmaInfo->DescAddr,
            &pDmaInfo->AddressSpace,
            pDmaInfo->DescLimit,
            pDmaInfo->PteCount,
            pDmaInfo->PteArray,
            &pDmaInfo->BufferBase,
            &pDmaInfo->LockHandle
        );
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_CONTEXT_DMA);
        }
    }

    // register and bind DMA context
    for (i = 0; i < NUM_DEVICES; i++)
    {
        if (deviceList && deviceList[i].InUse)
        {
            // set the device context
            if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
            {
                rmStatus = RM_ERR_BAD_OBJECT_PARENT;
                break;
            }

            // only allow the device with a DMA context in its FB to be registered as such
            if(deviceList[i].Handle == hDeviceWithFrameBufferCtx)
              pDmaInfo->AddressSpace = ADDR_FBMEM;
            
            // register DMA context with the current device
            if (!RM_SUCCESS(rmStatus = dmaRegisterToDevice(pDev, pDmaInfo, &pDmaObject)))
            {
                break;
            }

            // bind DMA context to all FIFOs of the current device
            if (!CliGetDeviceFifoList(deviceList[i].Handle, &fifoList))
            {
                rmStatus = RM_ERR_BAD_OBJECT_PARENT;
                break;
            }
            for (j = 0; j < NUM_FIFOS; j++)
            {
                if (fifoList && fifoList[j].InUse)
                {
                    if (!RM_SUCCESS(rmStatus = dmaBindToChannel(pDev, pDmaObject, j)))
                    {
                        break;
                    }
                }
            }
            if (!RM_SUCCESS(rmStatus))
            {
                break;
            }
        }
    }
    if (!RM_SUCCESS(rmStatus))
    {
        RmFreeContextDma(hClient, hDma);
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_CONTEXT_DMA);

} // end of RmAllocContextDma()

NvV32 RmAllocChannelPio(
    U032 hClient,
    U032 hDevice,
    U032 hPioChannel,
    U032 hClass,
    U032 hErrorContext,
    VOID** ppChannel,
    U032 flags
)
{
    RM_STATUS rmStatus = RM_OK;

    rmStatus = RmAllocChannel(
        hClient,
        hDevice,
        hPioChannel,
        hClass,
        hErrorContext,
        0,          // no DMA context
        0,          // no DMA push initial offset
        ppChannel,
        flags
    );

    return RmArchStatus(rmStatus, NV01_ALLOC_CHANNEL_PIO);

} // end of RmAllocChannelPio()

NvV32 RmAllocChannelDma(
    U032 hClient,
    U032 hDevice,
    U032 hDmaChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    VOID** ppControl
)
{
    RM_STATUS rmStatus = RM_OK;

    rmStatus = RmAllocChannel(
        hClient,
        hDevice,
        hDmaChannel,
        hClass,
        hErrorContext,
        hDataContext,
        offset,
        ppControl,
        0           // no flags
    );

    return RmArchStatus(rmStatus, NV03_ALLOC_CHANNEL_DMA);

} // end of RmAllocChannelDma()

RM_STATUS RmAllocChannel(
    U032 hClient,
    U032 hDevice,
    U032 hChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    VOID** ppChannel,
    U032 flags
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 chID;
    U032 length = CHANNEL_LENGTH;
    PDMAOBJECT pDmaObject;
    PCLI_DMA_INFO pDmaInfo;
    U032 clientClass;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        CliDelDeviceFifo(hDevice, hChannel);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // allocate the channel based on hDataContext
    if (hDataContext == 0)
    {
        // allocate a PIO channel
        rmStatus = fifoAlloc(pDev, hClass, &chID);
    }
    else
    {
        // get context dma object
        if (RM_SUCCESS(rmStatus = dmaFindContext(pDev, hDataContext, hClient, &pDmaObject)))
        {
            // allocate a DMA channel
            rmStatus = fifoAllocDma(pDev, hClass, &chID, pDmaObject);
#if defined(MACOS) && defined(DEBUG)
            // save pushbuffer address
            // *((void **) (0xE0 + (chID * 4)) ) = pDmaObject->DescOffset;
#endif
        }
    }

    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }

    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // map the channel
    switch (hClass)
    {
        // special case the nv3 dma channel
        case NV03_CHANNEL_DMA:
            *ppChannel = NULL;
            break;
        default:
        {
            rmStatus = osMapFifo(pDev, clientClass, chID, ppChannel);
            break;
        }
    }
    if (!RM_SUCCESS(rmStatus))
    {
        fifoFree(pDev, chID);
        //CliDelDeviceFifo(hDevice, hChannel);
        return rmStatus;
    }
    //pFifoInfo->Flat = *ppChannel;

    // add fifo to device fifo list
    rmStatus = CliAddDeviceFifo(
        pDev,
        hDevice,
        hChannel,
        hClass,
        hErrorContext,
        hDataContext,
        offset,
        flags,
        chID,
        *ppChannel
    );
    if (!RM_SUCCESS(rmStatus))
    {
        osUnmapMemory(pDev, clientClass, *ppChannel, length);
        fifoFree(pDev, chID);
        return rmStatus;
    }

    // bind all DMA contexts of the client to the FIFO of the current device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        // When the device was allocated, the dma context was registered to it.
        // Find the dmaObject created at that time.
        rmStatus = dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeChannel(hClient, hDevice, hChannel);
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
        rmStatus = dmaBindToChannel(pDev, pDmaObject, chID);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeChannel(hClient, hDevice, hChannel);
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
    }

    rmStatus = 0;

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM:   logical address:", *ppChannel);

    return rmStatus;

} // end of RmAllocChannel()

NvV32 RmAllocMemory(
    U032 hClient,
    U032 hParent,
    U032 hMemory,
    U032 hClass,
    U032 flags,
    VOID** pAddress,
    U032* pLimit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 trueLength;
    U032 instance = 0;
    BOOL addDeviceMemory = TRUE;
    PHWINFO pDev;
    VOID *pMemData = NULL;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_MEMORY);
    }

    // set the device context
    if (!CliSetDeviceContext(hParent, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_MEMORY);
    }

    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:

            rmStatus = RmAllocSystemMemory(pDev, hClient, pAddress, pLimit, &pMemData, flags);
            if (RM_SUCCESS(rmStatus))
            {
                rmStatus = CliAddMemory(pDev, hClient, hMemory, hClass, flags, *pAddress, *pLimit + 1, pMemData);
                if (!RM_SUCCESS(rmStatus))
                {
                    RmFreeSystemMemoryWithArgs(pDev, pAddress, *pLimit + 1, pMemData, flags);
                }
            }
            break;


        // modified by Chuck Moidel
        case NV01_MEMORY_LOCAL_PRIVILEGED:
            #ifndef NV3
            RM_ASSERT(0);  //NV01_MEMORY_LOCAL_PRIVILEGED should only be used by NV3 and before
            #endif
            /*
            // the length returned is the offset into instance memory, but the
            // true length is registered with the client.
            rmStatus = RmAllocInstanceMemory(pDev, hClient, pAddress, pLimit, &trueLength, &instance);
            if (RM_SUCCESS(rmStatus))
            {
               rmStatus = CliAddDeviceMemory(hParent, hMemory, hClass, *pAddress, trueLength, instance, 0);
               // is this right to return the status of the Free rather than the failure of CliAddDeviceMemory??
               if (!RM_SUCCESS(rmStatus))
               {
                   rmStatus = RmFreeInstanceMemory(pDev, hClient, hParent, hMemory);
               }
            }
            */
            break;

        /*
        ATTENTION!
        RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) do VERY different things.
        For more information see nvarch.h  - added by Charles Moidel
        */

        case NV01_MEMORY_LOCAL_USER: /* please note that this function does not allocate ANY framebuffer memory.
                                        This function only allocates and returns a dumb linear mapping to the entire 
                                        framebuffer.  -C.Moidel
                                     */

            // if the address is non-NULL, only return the length -- don't add as device memory
            addDeviceMemory = !*pAddress;
            rmStatus = RmAllocFrameBufferMapping(pDev, hClient, pAddress, pLimit);
            trueLength = *pLimit;

            // add the device memory info to the client database
            if (RM_SUCCESS(rmStatus) && addDeviceMemory)
            {
                rmStatus = CliAddDeviceMemory(hParent, hMemory, hClass, *pAddress, trueLength, instance, 0, 0);
                if (!RM_SUCCESS(rmStatus))
                {
                    rmStatus = RmFreeFrameBuffer(pDev, hClient, hParent, hMemory);
                }
            }
            break;

        default:
            rmStatus = RM_ERR_BAD_CLASS;
            break;
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_MEMORY);

} // end of RmAllocMemory()

RM_STATUS RmAllocSystemMemory(
    PHWINFO pDev,
    U032    hClient,
    VOID**   pAddress,
    U032*   pLimit,
    VOID**  pMemData,
    U032    flags
)
{
    RM_STATUS rmStatus = RM_OK;
    U032      MemoryType, Contiguous, PageCount;
    U032      Cache = 0;
    U032      clientClass;

    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    //
    // Allocate system memory
    //
    // 4k Page sized allocation?  This is the page size default for arch work.
    // Remember that the given length is actually a limit (size-1)
    //
    if ((*pLimit + 1) & 0xFFF)
    {
        //
        // Not a page request.  Don't support for now.
        //
        rmStatus = NVOS03_STATUS_ERROR_BAD_LIMIT;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Invalid limit: not page aligned\n");
        return rmStatus;
    }
    else
    {
        //
        // Page sized request
        //
        // Convert arch constants into RM constants.
        //
        PageCount = (*pLimit + 1) >> 12;

        if (DRF_VAL(OS02, _FLAGS, _LOCATION, flags) == NVOS02_FLAGS_LOCATION_AGP)
            MemoryType = NV_MEMORY_TYPE_AGP;
        else
            MemoryType = NV_MEMORY_TYPE_SYSTEM;

        if (DRF_VAL(OS02, _FLAGS, _PHYSICALITY, flags) == NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS)
            Contiguous = NV_MEMORY_CONTIGUOUS;
        else
            Contiguous = NV_MEMORY_NONCONTIGUOUS;

        if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_UNCACHED)
            Cache = NV_MEMORY_UNCACHED;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_CACHED)
            Cache = NV_MEMORY_DEFAULT;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE)
            Cache = NV_MEMORY_WRITECOMBINED;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_THROUGH)
            Cache = NV_MEMORY_WRITETHRU;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_PROTECT)
            Cache = NV_MEMORY_WRITEPROTECT;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_BACK)
            Cache = NV_MEMORY_WRITEBACK;

        rmStatus = osAllocPages(pDev,
                                pAddress,
                                PageCount,
                                MemoryType,
                                Contiguous,
                                Cache,
                                clientClass,
                                pMemData);

        if (!RM_SUCCESS(rmStatus))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot allocate pages\n");
            rmStatus = NVOS02_STATUS_ERROR_BAD_FLAGS;
            return rmStatus;
        }
    }

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: after system memory allocation:\n");
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   pMemory:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", *pLimit);

    return rmStatus;

} // end of RmAllocSystemMemory()

RM_STATUS RmAllocInstanceMemory(
    PHWINFO pDev,
    U032 hClient,
    VOID** pAddress,
    U032* pLength,
    U032* pTrueLength,
    U032* pInstance
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 instMemOffset, clientClass;
    // U032 instanceMemoryPciAddress = INSTANCE_MEMORY_BASE;

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // NOTE: never allocate cursor memory for client of type "user"
    // TO DO: this is not generalized -- for NV3 legacy reasons, only a kernel client can alloc inst mem
    // validate the client class
    if (clientClass != NV01_ROOT)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // allocate instance memory for the cursor aligned on 2K boundary
    rmStatus = fbAllocInstMemAlign(pDev, pInstance, *pLength >> 4, 0x800 >> 4);
    if (!RM_SUCCESS(rmStatus))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot allocate instance for cursor\n");
        return rmStatus;
    }
    instMemOffset = *pInstance << 4;

    // map the memory into the client's context
    rmStatus = osMapInstanceMemory(pDev, clientClass, instMemOffset, *pLength, pAddress);
    if (!RM_SUCCESS(rmStatus))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot map instance memory for cursor\n");
        return rmStatus;
    }

    // return the offset from the top of instance memory in pLength, and the true length in pTrueLength
    // TODO: eliminate this when the miniport does not talk to HW
    *pTrueLength = *pLength;
    *pLength = instMemOffset;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM:  after cursor allocation:\n");
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   pMemory:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", *pLength);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:  instance:", *pInstance);

    return rmStatus;

} // end of RmAllocInstanceMemory()

RM_STATUS RmAllocFrameBufferMapping(
    PHWINFO pDev,
    U032 hClient,
    VOID** pAddress,
    U032* pLength
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // map frame buffer into the client's context -- only map if null is passed in as address
    *pLength = pDev->Framebuffer.HalInfo.Limit[0];
    if (*pAddress == NULL)
    {
        rmStatus = osMapFrameBuffer(pDev, clientClass, 0, *pLength, pAddress);
        if (!RM_SUCCESS(rmStatus))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot map frame buffer\n");
            return rmStatus;
        }
    }

    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   address:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    length:", *pLength);

    return rmStatus;

} // end of RmAllocFrameBufferMapping()

NvV32 RmAllocObject(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        //return RmArchStatus(RM_ERR_BAD_CLIENT, NV01_ALLOC_OBJECT);
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_OBJECT);
    }

    // find and set the device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }

    // get the class object
    //nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_VIDEO_COLORMAP;
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }
    if (hClass == NV01_NULL_OBJECT)
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_OBJECT);
    }

    rmStatus = fifoSearchObject(pDev, hClass, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_BAD_CLASS, NV01_ALLOC_OBJECT);
    }

    // create the device given its class object
    //nv->subchannel[BLIT_SUBCHANNEL].nvClass.Create = DD_COLORMAP;
    rmStatus = mthdCreate(pDev, pObject, 0, 0, hObject, NULL);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_INSUFFICIENT_RESOURCES, NV01_ALLOC_OBJECT);
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_OBJECT);

} // end of RmAllocObject()

NvV32 RmAllocEvent
(
    U032 hClient,
    U032 hUser,
    U032 hObject,
    U032 hClass,
    U032 index,
    U064 hEvent
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_EVENT_INFO pEventInfo;
    POBJECT pUser;
    U032 hChannel;

    // set client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;
    }

    // add event to client and parent object
    rmStatus = CliAddEvent(hClient, hUser, hObject, hClass, &pEventInfo);
    if (RM_SUCCESS(rmStatus))
    {
        CliFindObject(hUser, &pUser, &hChannel);
        rmStatus = eventSetObjectEventNotify(pUser, hObject, index, hClass, hEvent);
        if (!RM_SUCCESS(rmStatus))
        {
            CliDelEvent(hObject);
        }
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_EVENT);

} // end of RmAllocEvent()




NvV32 RmAlloc(
    U032 hClient,
    U032 hParent,
    U032 hObject,
    U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS rmStatus = RM_OK;

    //special case for Client Allocation - added by Chuck Moidel
    if (hClass == NV01_ROOT)
    {
        NVOS01_PARAMETERS *pArgs = (NVOS01_PARAMETERS*)pAllocParms;
        ARG(status) = RmAllocClient(&ARG(hObjectNew),ARG(hClass));
        return ARG(status);
    }
    
    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_CLIENT, NV04_ALLOC);
    }

    // allocate the object based on its class
    switch(hClass)
    {
        //case NV01_NULL_OBJECT:
        case NV01_ROOT:  //should be handled above!! -C.Moidel
            RM_ASSERT(hClass);
            return RmArchStatus(RM_ERR_BAD_CLASS, NV04_ALLOC);

        case NV01_MEMORY_SYSTEM:




        //case NV01_MEMORY_LOCAL_PRIVILEGED:  //shouldn't be using this in NV4+   -C.Moidel

        /*
        ATTENTION!
        RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) do VERY different things.
        For more information see nvarch.h  - added by Charles Moidel
        */
        case NV01_MEMORY_LOCAL_USER:      /*This is used to allocate blocks from the Framebuffer Heap!   -C.Moidel */



        case NV04_HEAP_OWNER:             //added by Chuck Moidel


        case NV01_EVENT:
        case NV01_CONTEXT_DMA:
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
        case NV03_CHANNEL_PIO:
        case NV04_CHANNEL_PIO:
        case NV03_CHANNEL_DMA:
        case NV04_CHANNEL_DMA:
            return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV04_ALLOC);

        case NVDE_DEBUGGER:
        case NVDE_REGISTER_DEBUGGER:
        case NVDE_UNREGISTER_DEBUGGER:
        case NVDE_READ_MEMORY:
        case NVDE_WRITE_MEMORY:
        case NVDE_TEST:
        case NVDE_GET_EVENT_INFORMATION:
            rmStatus = RmDebugEx(hClient, hObject, hClass, pAllocParms);
            break;

        default:
            rmStatus = RmAllocObjectEx(hParent, hObject, hClass, pAllocParms);
            break;
    }

    return RmArchStatus(rmStatus, NV04_ALLOC);

} // end of RmAlloc()

RM_STATUS RmAllocObjectEx(
    U032 hChannel,
    U032 hObject,
    U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // set the device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // get the class object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    rmStatus = fifoSearchObject(pDev, hClass, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_BAD_CLASS;
    }

    // create the device given its class object
    rmStatus = mthdCreate(pDev, pObject, 0, 0, hObject, pAllocParms);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    return rmStatus;

} // end of RmAllocObjectEx()

// TO DO: clean up as much as possible despite any errors, for all free routines

NvV32 RmFree(
    U032 hClient,
    U032 hParent,
    U032 hObject
)
{
    U032 client;
    PCLI_DEVICE_INFO pDevice;
    PCLI_FIFO_INFO pFifo;
    PCLI_MEMORY_INFO pMemory;
    PCLI_DMA_INFO pDma;
    PCLI_EVENT_INFO pEvent;
    RM_STATUS rmStatus = RM_OK;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_FREE);
    }

    // scan all object types
    if (CliGetClientHandle(&client) && client == hObject)
    {
        rmStatus = RmFreeClient(hClient);
    }
    else if (CliGetDeviceInfo(hObject, &pDevice))
    {
        rmStatus = RmFreeDevice(hClient, hObject);
    }
    else if (CliGetDeviceFifoInfo(hParent, hObject, &pFifo))
    {
        rmStatus = RmFreeChannel(hClient, hParent, hObject);
    }
    else if (CliGetDeviceMemoryInfo(hParent, hObject, &pMemory))
    {
        rmStatus = RmFreeMemory(hClient, hParent, pMemory->Class, hObject);
    }
    else if (CliGetDmaInfo(hObject, &pDma))
    {
        rmStatus = RmFreeContextDma(hClient, hObject);
    }
    else if (CliGetMemoryInfo(hObject, &pMemory))
    {
        rmStatus = RmFreeMemory(hClient, hParent, pMemory->Class, hObject);
    }
    else if (CliGetEventInfo(hObject, &pEvent))
    {
        rmStatus = RmFreeEvent(hClient, hObject);
    }
    else
    {
        rmStatus = RmFreeObject(hParent, hObject);
    }

    return RmArchStatus(rmStatus, NV01_FREE);

} // end of RmFree()

RM_STATUS RmFreeClient(
    U032 hClient
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo, nextDma;
    PCLI_DEVICE_INFO deviceList;
    PCLI_MEMORY_INFO pMemoryInfo, nextMem;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: client\n");

    // free all of the devices of the client
    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                rmStatus |= RmFreeDevice(hClient, deviceList[i].Handle);
            }
        }
    }
    else
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;

    // free all of the DMA contexts of the client
    nextDma = CliGetDmaList();
    while (nextDma)
    {
        pDmaInfo = nextDma;
        nextDma = nextDma->Next;
        rmStatus |= RmFreeContextDma(hClient, pDmaInfo->Handle);
    }

    // free all client system memory
    nextMem = CliGetMemoryList();
    while (nextMem)
    {
        pMemoryInfo = nextMem;
        nextMem = nextMem->Next;
        rmStatus |= RmFreeSystemMemory(pMemoryInfo->pDev, pMemoryInfo->Handle);
    }

#ifdef LINUX
    RmSwapClientGone(hClient);
#endif

    // free the client
    if (!CliDelClient())
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeClient()

RM_STATUS RmFreeDevice(
    U032 hClient,
    U032 hDevice
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_FIFO_INFO fifoList;
    PCLI_MEMORY_INFO pMemoryInfo;
    PCLI_DMA_INFO pDmaInfo;
    U032 i;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: device\n");

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // if the client was created, but never had any devices successfully
    //   attached, we'll get here.  The client's device structure will have
    //   been created, but pDev will be NULL if the device was later found
    //   to be non-existent
    // Since NUM_FIFOS macro ref's pDev, we stay away
    if (pDev)
    {
        // free all of the FIFOs of the device
        if (CliGetDeviceFifoList(hDevice, &fifoList))
        {
            for (i = 0; i < NUM_FIFOS; i++)
            {
                if (fifoList && fifoList[i].InUse)
                {
                    rmStatus |= RmFreeChannel(hClient, hDevice, fifoList[i].Handle);
                }
            }
        }
    }

    // unregister all DMA contexts with the device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        if (RM_SUCCESS(dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject)))
        {
            rmStatus |= dmaUnregisterFromDevice(pDev, pDmaObject);
        }
    }

    // free all device memory
    while ((pMemoryInfo = CliGetDeviceMemoryList(hDevice)) != NULL)
    {
        rmStatus |= RmFreeMemory(hClient, hDevice, pMemoryInfo->Class, pMemoryInfo->Handle);
    }

    // free the device
    if (!CliDelDevice(hDevice))
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeDevice()

RM_STATUS RmFreeContextDma(
    U032 hClient,
    U032 hDma
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    U032 i, j;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: DMA context\n");

    // unregister and unbind the DMA context
    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
    }
    else
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                // set the current device context
                if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
                {
                    rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
                }

                // get a pointer to the dma object
                else if (RM_SUCCESS(rmStatus |= dmaFindContext(pDev, hDma, hClient, &pDmaObject)))
                {
                    // unbind DMA context from all FIFOs of the current device
                    if (!CliGetDeviceFifoList(deviceList[i].Handle, &fifoList))
                    {
                        rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
                    }
                    else
                    {
                        for (j = 0; j < NUM_FIFOS; j++)
                        {
                            if (fifoList && fifoList[j].InUse)
                            {
                                rmStatus |= dmaUnbindFromChannel(pDev, pDmaObject, j);
                            }
                        }

                        // unregister DMA context with the current device
                        rmStatus |= dmaUnregisterFromDevice(pDev, pDmaObject);
                    }
                }
            }
        }
    }

    // TO DO:  ***** THIS SHOULD HAPPEN HERE, BUT UNTIL IT IS PROVED
    //               IT IS DONE IN DMA DELETE
    /*
    // unlock pages
    if (!CliGetDmaInfo(hDma, &pDmaInfo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }
    rmStatus = osUnlockUserMem(
        INVALID_CHID,
        pDmaInfo->BufferBase,
        pDmaInfo->DescAddr,
        pDmaInfo->AddressSpace,
        pDmaInfo->DescLimit,
        pDmaInfo->PteCount,
        pDmaInfo->LockHandle,
        pDmaInfo->Class == NV_CONTEXT_DMA_TO_MEM ? TRUE : FALSE
    );
    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }
    */

    // delete the DMA context from the client
    if (!CliDelDma(hDma))
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeContextDma()

RM_STATUS RmFreeChannel(
    U032 hClient,
    U032 hDevice,
    U032 hFifo
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PCLI_FIFO_INFO pFifoInfo;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;
    U032 hClass;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: channel\n");

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // unbind all DMA contexts from the FIFO
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        if (!RM_SUCCESS(rmStatus = dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject)))
        {
            return rmStatus;
        }
        if (!CliGetDeviceFifoInfo(hDevice, hFifo, &pFifoInfo))
        {
            return RM_ERR_BAD_OBJECT_HANDLE;
        }
        if (!RM_SUCCESS(rmStatus = dmaUnbindFromChannel(pDev, pDmaObject, pFifoInfo->ChID)))
        {
            return rmStatus;
        }
    }

    // unmap the channel
    if (!CliGetDeviceFifoInfo(hDevice, hFifo, &pFifoInfo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }
    hClass = pFifoInfo->Class;

    // NV03_CHANNEL_DMA wasn't mapped into clients address space
    if (hClass != NV03_CHANNEL_DMA)
    {
        U032 clientClass;

        if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
        {
            return RM_ERR_OPERATING_SYSTEM;
        }
        osUnmapMemory(pDev, clientClass, (VOID *)pFifoInfo->Flat, CHANNEL_LENGTH);
    }

    // free the FIFO
    rmStatus = fifoFree(pDev, pFifoInfo->ChID);
    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }

    // delete the device fifo info
    if (!CliDelDeviceFifo(hDevice, hFifo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // remove any events associated with this channel from the client
    CliDelEventUser(hFifo, hClass);

    return rmStatus;

} // end of RmFreeChannel()


RM_STATUS RmFreeMemory
(
    U032 hClient,
    U032 hDevice,
    U032 hClass,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    switch(hClass)
    {
        case NV01_MEMORY_SYSTEM:

            rmStatus = RmFreeSystemMemory(pDev, hMemory);

            // remove the system memory reference from the client
            if (!CliDelMemory(hMemory))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }
            break;

        case NV01_MEMORY_LOCAL_PRIVILEGED:
        case NV01_MEMORY_LOCAL_USER:

            // set the device context
            if (!CliSetDeviceContext(hDevice, &pDev))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
            }

            // free the device memory
            switch(hClass)
            {
                case NV01_MEMORY_LOCAL_PRIVILEGED:
                    rmStatus |= RmFreeInstanceMemory(pDev, hClient, hDevice, hMemory);
                    break;

                case NV01_MEMORY_LOCAL_USER:
                    rmStatus |= RmFreeFrameBuffer(pDev, hClient, hDevice, hMemory);
                    break;
            }

            // remove the device memory reference from the client
            if (!CliDelDeviceMemory(hDevice, hMemory))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }

            break;
    }

    return rmStatus;

} // end of RmFreeMemory()


RM_STATUS RmFreeSystemMemoryWithArgs
(
    PHWINFO pDev,
	VOID**  pAddress, 
	U032    size,
	VOID*   pMemData,
    U032    flags
)
{
    // version of RmFreeSystemMemory when a memory handle isn't valid
    return (osFreePages(pDev,
                        pAddress,
                        DRF_VAL(OS02, _FLAGS, _LOCATION, flags), 
                        size >> RM_PAGE_SHIFT,
                        pMemData,
                        DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE));

} // end of RmFreeSystemMemoryWithArgs()

RM_STATUS RmFreeSystemMemory
(
    PHWINFO pDev,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_MEMORY_INFO pMemoryInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: system memory\n");

    if (!CliGetMemoryInfo(hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        rmStatus = osFreePages(pDev,
                               &pMemoryInfo->Address,
                               pMemoryInfo->Type,
                               pMemoryInfo->Length >> RM_PAGE_SHIFT,
                               pMemoryInfo->MemData,
                               (pMemoryInfo->Coherency == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE));
    }

    return rmStatus;

} // end of RmFreeSystemMemory()

RM_STATUS RmFreeInstanceMemory(
    PHWINFO pDev,
    U032 hClient,
    U032 hDevice,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;
    PCLI_MEMORY_INFO pMemoryInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: cursor memory\n");

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // free the instance memory
    else if (!CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        // unmap the memory
        osUnmapMemory(pDev, clientClass, pMemoryInfo->Address, pMemoryInfo->Length);

        // deallocate the instance memory held by the cursor
        rmStatus = fbFreeInstMem(pDev, pMemoryInfo->Instance, pMemoryInfo->Length >> 4);
    }

    return rmStatus;

} // end of RmFreeInstanceMemory()

RM_STATUS RmFreeFrameBuffer(
    PHWINFO pDev,
    U032 hClient,
    U032 hDevice,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;
    PCLI_MEMORY_INFO pMemoryInfo;
    U032 memHandle;


    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: frame buffer\n");

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // free the frame buffer
    else if (!CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        // free the video memory based on how it was alloced ... a non-zero
        // HeapOwner indicates it was heapAlloc-ed.

        if (pMemoryInfo->HeapOwner)
        {
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Function: FREE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Owner:", pMemoryInfo->HeapOwner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Offset:", pMemoryInfo->Handle);

            // memHandle is returned, but not needed ... the caller already has
            // the correct handle to pass to CliDelDeviceMemory, since it's
            // traversing the client DB.

            rmStatus = heapFree(
                pDev,
                (PHEAP)pDev->Framebuffer.HeapHandle,
                pMemoryInfo->HeapOwner,
                (U032)((U008*)pMemoryInfo->Address - (U008*)fbAddr),
                &memHandle);
        }
        else
        {
            // unmap the memory
            osUnmapMemory(pDev, clientClass, pMemoryInfo->Address, pMemoryInfo->Length);
        }
    }
    return rmStatus;

} // end of RmFreeFrameBuffer()

RM_STATUS RmFreeObject(
    U032 hChannel,
    U032 hObject
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    OBJECT classObject;
    PHWINFO pDev;

    // check for debugger object
    if (NvRmInfo.Debugger.object)
        if (NvRmInfo.Debugger.object->Name == hObject)
            return NvdeFree(hChannel, hObject);

    // set the corresponding device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // contrive the class object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    classObject.Name = NV01_NULL_OBJECT;
    classObject.ChID = pFifo->ChID;

    // destroy the object
    rmStatus = mthdDestroy(pDev, &classObject, 0, 0, hObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // remove this user object from client events
    CliDelEventUser(hObject, NV01_NULL_OBJECT);

    return rmStatus;

} // end of RmFreeObject()

RM_STATUS RmFreeEvent(
    U032 hClient,
    U032 hEvent
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER nextUser;
    POBJECT pUser;
    U032 hChannel;

    // delete the event from all parent objects and client
    if (CliGetEventInfo(hEvent, &pEvent))
    {
        for (nextUser = pEvent->UserList; nextUser; nextUser = nextUser->Next)
        {
            if (CliFindObject(nextUser->Handle, &pUser, &hChannel))
            {
                eventRemoveObjectEventNotify(pUser, hEvent);
            }
        }
        CliDelEvent(hEvent);
    }
    else
    {
        rmStatus = RM_ERR_BAD_OBJECT;
    }

    return rmStatus;

} // end of RmFreeEvent()

NvV32 RmArchHeap
(
    U032 hRoot,
    U032 hObjectParent,
    U032 function,
    U032 owner,
    U032 type,
    U032 depth,
    U032 width,
    U032 height,
    S032* pPitch,
    U032* pOffset,
    U032* pSize,
    VOID** pAddress,
    U032* pLimit,
    U032* pTotal,
    U032* pFree
)
{
    U032 tempPitch;
    RM_STATUS rmStatus = NVOS11_STATUS_SUCCESS;
    PHWINFO pDev;
    U032 memHandle;
#ifdef DEBUG
    U032 oldFree;
#endif

    // set the client context
    if (!CliSetClientContext(hRoot))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hObjectParent, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    //
    // Heap manager for NV memory.
    //
    if ((owner == 0) || (owner == 0xFFFFFFFF))
    {
        return NVOS11_STATUS_ERROR_INVALID_OWNER;
    }

    //
    // Setup size for DEPTH_WIDTH_HEIGHT or TILED_PITCH_HEIGHT allocs
    //
    if (function == NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT)
    {
        U032 byteWidth;

        // For NV3, scanline alignment is 32 bytes.
        byteWidth = ((width * depth) + 7) >> 3;
        *pSize  = height * ((byteWidth + 31) & ~31);
    }
    else if (function == NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT)
    {
        *pSize  = (height * *pPitch);
        tempPitch = *pPitch;
    }

    switch (function)
    {
        //
        // Alloc mem.
        //
        case NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT:
        case NVOS11_HEAP_ALLOC_SIZE:
            tempPitch = 0;          // pitch is valid only for TILED_PITCH_HEIGHT

        case NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT:
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: ALLOC\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:  ", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner: ", owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Size:  ", *pSize);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Pitch: ", *pPitch);
            rmStatus =
                heapAlloc
                (
                    pDev,
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    owner,
                    pSize,
                    type,
                    height,
                    &tempPitch,
                    pOffset
                );
            if (rmStatus == RM_OK)
            {
                //
                // Set the mapping for the memory.
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Allocated at Offset: ", *pOffset);
                if (tempPitch)
                {
                    // update pitch value
                    *pPitch = tempPitch;
                }
                *pAddress = (U008*)fbAddr + *pOffset;
                *pLimit = *pSize - 1;

                // add the heapAlloc to the Client DB
                rmStatus =
                    CliAddDeviceMemory
                    (
                        hObjectParent,
                        ((PHEAP)pDev->Framebuffer.HeapHandle)->memHandle, // generated handle
                        NV01_MEMORY_LOCAL_USER,
                        *pAddress,
                        *pSize,
                        0x0,
                        owner,
                        0           //version = 0 because the HeapOwner is just an ID without an allocated object behind it - C.Moidel
                    );
                if (rmStatus != RM_OK)
                {
                    // return the failed rmStatus from CliAddMemory not heapFree
                    (VOID)heapFree
                    (
                        pDev,
                        (PHEAP)pDev->Framebuffer.HeapHandle,
                        owner,
                        *pOffset,
                        &memHandle
                    );
                }
            }
            *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
            *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;

            break;

        //
        // Free mem.
        //
        case NVOS11_HEAP_FREE:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: FREE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner:", owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Offset:", *pOffset);

            //
            // OpenGL might try to call heapfree (via an ESCAPE call) before NT
            // ever gets the chance to call RmLoadState (in SetPowerState).
            // So to be safe, make sure the HeapHandle is not null.
            //

            if ( ((PHEAP)pDev->Framebuffer.HeapHandle) != NULL)
            {
                rmStatus =
                    heapFree
                    (
                        pDev,
                        (PHEAP)pDev->Framebuffer.HeapHandle,
                        owner,
                        *pOffset,
                        &memHandle  // return the memory handle used
                    );

                *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
                *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;

                if (!CliDelDeviceMemory(hObjectParent, memHandle))
                {
                    rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
                }
            }

            else
            {
                rmStatus = NVOS11_STATUS_ERROR_INVALID_HEAP;
            }

            break;

        //
        // Purge mem.
        //
        case NVOS11_HEAP_PURGE:

            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: PURGE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner:", owner);
#ifdef DEBUG
            oldFree = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
#endif
            rmStatus = heapPurge(pDev, (PHEAP)pDev->Framebuffer.HeapHandle, owner);
            *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
            *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;
#ifdef DEBUG
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Blocks puged:", *pFree-oldFree);
#endif
/*
#ifdef DEBUG
            if (!(*pFree-oldFree))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    You did a PURGE for NO REASON!\n");
            };
#endif
*/

            if (!CliDelDeviceHeapOwner(hObjectParent, owner))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }

            break;

        //
        // Info.
        //
        case NVOS11_HEAP_INFO:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: INFO\n");
            rmStatus =
                heapInfo
                (
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    pFree,
                    pTotal,
                    pAddress,  // base of heap
                    pOffset,   // base of largest free block
                    pSize      // size of largest free block
                );
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:", *pFree);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:", *pTotal);
                DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     Base:", *pAddress);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  MaxFree:", *pSize);
            }

            break;

        //
        // Info with freed blocks.
        //
        // The offsets passed in are considered freed for calculation purposes, but
        // aren't actually freed. Passing -1 as an offset arg indicates offset doesn't
        // contain a valid arg (use the NVOS11_INVALID_BLOCK_FREE_OFFSET #define).
        //
        case NVOS11_HEAP_INFO_FREE_BLOCKS:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: INFO FREE BLOCKS\n");
            rmStatus = 
                heapInfoFreeBlocks
                (
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    pFree,
                    pTotal,
                    *pOffset,   // offset of block to be considered free
                    *pLimit,    // offset of block to be considered free
                    pSize       // size of resulting largest free block
                );    
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:", *pFree);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:", *pTotal);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  MaxFree:", *pSize);
            }
            
            break;
            
        //
        // Destroy.
        //
        case NVOS11_HEAP_DESTROY:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: DESTROY\n");
            rmStatus = heapDestroy(pDev, (PHEAP)pDev->Framebuffer.HeapHandle, HEAP_DESTROY_EXTERNAL);
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:",
                    ((PHEAP)pDev->Framebuffer.HeapHandle)->free);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:",
                    ((PHEAP)pDev->Framebuffer.HeapHandle)->total);
            }

            break;

        //
        // Invalid.
        //
        default:
            rmStatus = NVOS11_STATUS_ERROR_INVALID_FUNCTION;
            break;
    }

    return rmStatus;

} // end of RmArchHeap

NvV32 RmConfigVersion
(
    U032 hClient,
    U032 hDevice,
    U032* pVersion
)
{
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // call the kernel for help
    //*pVersion = stateConfigVersion(pDev);
    *pVersion = 0x01000000;

    return NVOS12_STATUS_SUCCESS;

} // end of RmConfigVersion

NvV32 RmConfigGet
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    U032* pValue
)
{
    RM_STATUS rmStatus = NVOS13_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS13_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS13_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus = stateConfigGet(pDev, index, pValue);
    if (!RM_SUCCESS(rmStatus))
    {
        rmStatus = NVOS13_STATUS_ERROR_BAD_INDEX;
    }

    return rmStatus;

} // end of RmConfigGet()

NvV32 RmConfigSet
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    U032* pOldValue,
    U032 newValue
)
{
    RM_STATUS rmStatus = NVOS14_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS14_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS14_STATUS_ERROR_BAD_DEVICE;
    }

    // access the kernel state
    rmStatus = stateConfigSet(pDev, index, newValue, pOldValue);
    if (!RM_SUCCESS(rmStatus))
    {
        rmStatus = NVOS14_STATUS_ERROR_BAD_INDEX;
    }

    return rmStatus;

} // end of RmConfigSet()

NvV32 RmConfigUpdate
(
    U032 hClient,
    U032 hDevice,
    U032 flags
)
{
    RM_STATUS rmStatus = NVOS15_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // call the kernel for help
    //stateConfigUpdate(pDev, flags);

    return rmStatus;

} // end of RmConfigUpdate

NvV32 RmConfigGetEx
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    VOID* pParms,
    U032 parmsSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_CGE_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS_CGE_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus =
        stateConfigGetEx
        (
            pDev,
            index,
            pParms,
            parmsSize
        );

    return RmArchStatus(rmStatus, NV04_CONFIG_GET_EX);

} // end of RmConfigGetEx

NvV32 RmConfigSetEx
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    VOID* pParms,
    U032 parmsSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_CSE_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS_CSE_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus =
        stateConfigSetEx
        (
            pDev,
            index,
            pParms,
            parmsSize
        );

    return RmArchStatus(rmStatus, NV04_CONFIG_SET_EX);

} // end of RmConfigSetEx

NvV32 RmInterrupt
(
    U032 hClient,
    U032 hDevice
)
{
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS09_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS09_STATUS_ERROR_BAD_DEVICE;
    }

    // call the os ISR service
    osIsr(pDev);

    return NVOS09_STATUS_SUCCESS;

} // end of RmInterrupt()

RM_STATUS RmAllocDeviceInstance
(
    U032 *pInstance
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 instance, i, instanceSize;

    // allocate the next available device instance
    for (instance = 0; instance < MAX_INSTANCE; instance++)
    {
        if (NvDBPtr_Table[instance] == NULL)
        {
            // allocate and init the device information structure
            instanceSize = sizeof(HWINFO);
            rmStatus = osAllocMem((VOID **)&NvDBPtr_Table[instance], instanceSize);
            if (RM_SUCCESS(rmStatus))
            {
                // clear out the new instance
                for (i = 0; i < instanceSize; i++)
                {
                     ((U008 *)(NvDBPtr_Table[instance]))[i] = 0;
                }
                
                // set the instance self-reference in the device instance
                NvDBPtr_Table[instance]->DBdevInstance = instance;

                // return the instance
                *pInstance = instance;

                // setup the pointer to the global NvRmInfo
                NvDBPtr_Table[instance]->pRmInfo = (VOID_PTR) &NvRmInfo;
            }
            break;
        }
    }
    if (instance == MAX_INSTANCE)
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

}

NvV32 RmArchStatus(RM_STATUS rmStatus, U032 archFct)
{
    switch (archFct)
    {
        case NV01_FREE:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS00_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS00_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS00_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS00_STATUS_ERROR_BAD_OBJECT_OLD;
                case RM_ERR_OBJECT_IN_USE:
                    return NVOS00_STATUS_ERROR_OBJECT_IN_USE;
                case RM_ERR_OBJECT_HAS_CHILDERN:
                    return NVOS00_STATUS_ERROR_OBJECT_HAS_CHILDERN;
                default:
                    return rmStatus;
            }
        
        case NV01_ROOT_USER:
        case NV01_ALLOC_ROOT:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS01_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS01_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS01_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS01_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS01_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_MEMORY:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS02_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS02_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS02_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS02_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_CONTEXT_DMA:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS03_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS03_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS03_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS03_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS03_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_FLAGS:
                    return NVOS03_STATUS_ERROR_BAD_FLAGS;
                case RM_ERR_BAD_BASE:
                    return NVOS03_STATUS_ERROR_BAD_BASE;
                case RM_ERR_BAD_LIMIT:
                    return NVOS03_STATUS_ERROR_BAD_LIMIT;
                case RM_ERR_PROTECTION_FAULT:
                    return NVOS03_STATUS_ERROR_PROTECTION_FAULT;
                case RM_ERR_MULTIPLE_MEMORY_TYPES:
                    return NVOS03_STATUS_ERROR_MULTIPLE_MEMORY_TYPES;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS03_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_CHANNEL_PIO:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS04_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS04_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_OBJECT_ERROR:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR;
                case RM_ERR_BAD_FLAGS:
                    return NVOS04_STATUS_ERROR_BAD_FLAGS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                case RM_ERR_NO_FREE_FIFOS:
                    return NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_OBJECT:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS05_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS05_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS05_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS05_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS05_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV04_ALLOC:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS21_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS21_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_CLIENT:
                    return NVOS21_STATUS_ERROR_BAD_ROOT;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS21_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS21_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_DEVICE:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS06_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS06_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS06_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV03_ALLOC_CHANNEL_DMA:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS07_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS07_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS07_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_OBJECT_ERROR:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_ERROR;
                case RM_ERR_BAD_OBJECT_BUFFER:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_BUFFER;
                case RM_ERR_BAD_OFFSET:
                    return NVOS07_STATUS_ERROR_BAD_OFFSET;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                case RM_ERR_NO_FREE_FIFOS:
                    return NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV04_CONFIG_GET_EX:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS_CGE_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM;
                case CONFIG_GETEX_BAD_INDEX:
                    return NVOS_CGE_STATUS_ERROR_BAD_INDEX;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS_CGE_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                case CONFIG_GETEX_BAD_PARAM:
                    return NVOS_CGE_STATUS_ERROR_BAD_PARAM_STRUCT;
            }

        case NV04_CONFIG_SET_EX:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS_CSE_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM;
                case CONFIG_SETEX_BAD_INDEX:
                    return NVOS_CSE_STATUS_ERROR_BAD_INDEX;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS_CSE_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                case CONFIG_SETEX_BAD_PARAM:
                    return NVOS_CSE_STATUS_ERROR_BAD_PARAM_STRUCT;
            }

        default:
            return rmStatus;
    }

} // end of RmArchStatus()

NvV32 RmI2CAccess
(
    U032  hClient,
    U032  hDevice,
    VOID*  pCtrl
)
{
    RM_STATUS   rmStatus;
    PHWINFO pDev;
    U032        Head = 0;   // TO DO: specify which head
    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    // also checking for NULL pDev.
    if (!CliSetDeviceContext(hDevice, &pDev) || !pDev)
    {
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_DEVICE;
    }
    
    // set head to InitialBootHead
    Head=pDev->Dac.HalInfo.InitialBootHead;
    
    //print out debug data
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"I2C access occuring on head: %d",Head);
 	
    // call the kernel for help
    rmStatus = i2cAccess(pDev, Head, pCtrl);

    return rmStatus;

} // end of RmI2CAccess()

NvV32 RmDirectMethodCall
(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 offset,
    U032 data
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // TO DO: it is necessary to be very restrictive as to which methods can be called -- is there a better test?
    // check for valid methods
    switch (offset)
    {
        case NV046_SET_CONTEXT_DMA_NOTIFIES:
        case NV046_SET_CONTEXT_DMA_LUT(0):
        case NV046_SET_LUT_OFFSET(0):
        case NV046_SET_LUT_FORMAT(0):
        case NV046_SET_CURSOR_POINT:
        case NV046_SET_DAC_IMAGE_SIZE(0):
        case NV046_SET_DAC_HORIZONTAL_BLANK(0):
        case NV046_SET_DAC_HORIZONTAL_SYNC(0):
        case NV046_SET_DAC_VERTICAL_BLANK(0):
        case NV046_SET_DAC_VERTICAL_SYNC(0):
        case NV046_SET_DAC_TOTAL_SIZE(0):
        case NV046_SET_DAC_PIXEL_CLOCK(0):
        case NV046_SET_DAC_FORMAT(0):
            break;

        default:
            return NVOS1D_STATUS_ERROR_BAD_METHOD;
    }

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS1D_STATUS_ERROR_OPERATING_SYSTEM;
    }

    // set the corresponding device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }

    // get the object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }
    rmStatus = fifoSearchObject(pDev, hObject, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_OLD;
    }

    // call the method directly and safely
    rmStatus = classDirectSoftwareMethod(pDev, pObject, offset, data);
    if (!RM_SUCCESS(rmStatus))
    {
        return NVOS1D_STATUS_ERROR_BAD_DATA;
    }

    return NVOS1D_STATUS_SUCCESS;

} // end of RmDirectMethodCall()

/*
 * Control various debugging facilities in the resource manager
 */

VOID Nv01DebugControl(
    NVOS20_PARAMETERS * configParams
)
{
    RM_STATUS rmStatus = NVOS20_STATUS_SUCCESS;

    switch (configParams->command)
    {
        case NVOS20_COMMAND_RM_FAILURE_ENABLE:
            RM_FAILURE_ENABLE();
            break;

        case NVOS20_COMMAND_RM_FAILURE_DISABLE:
            RM_FAILURE_DISABLE();
            break;
    }

    configParams->status = rmStatus;
} // end of RmDebugControl

RM_STATUS RmDebugEx(
	U032 hClient,
    U032 hObject,
	U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS status = RM_OK;

#if !defined(_M_IA64) && !defined(__ia64)
    switch (hClass)
    {
        case NVDE_DEBUGGER:
        {
            status = NvdeAlloc(hObject, pAllocParms);
            break;
        }
        case NVDE_REGISTER_DEBUGGER:
        {
            if (hClient == 0)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;
            if (NvRmInfo.Debugger.Handle != 0)
                return NVDE_STATUS_ERROR_STATE_IN_USE;

            NvRmInfo.Debugger.Handle = hClient;
            break;
        }
        case NVDE_UNREGISTER_DEBUGGER:
        {
            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;
            NvRmInfo.Debugger.Handle = 0;
            break;
        }
        case NVDE_READ_MEMORY:
        {
            NVDE_READ_MEMORY_PARAMETERS *pNvDEParams;
            U008 *in, *out;
            U032 i;

            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;

            //
            // Not bothering with osCopyin/osCopyout here because
            // this code will soon be moved to the DMC interface.
            // 
            // bdw: we need 32-bit xfers to be atomic - please retain
            //      this notion when we port this.
            //
            pNvDEParams = (NVDE_READ_MEMORY_PARAMETERS *)pAllocParms;
            
            in  = (U008 *)(NvU64_VALUE_T)pNvDEParams->Data;     /* XXX change to PTR_SIZE? */
            out = (U008 *)(NvU64_VALUE_T)pNvDEParams->Address;  /* XXX change to PTR_SIZE? */
            i   = pNvDEParams->Size;
            while (i >= 4)
            {
                *(U032*)in = *(U032*)out;
                in  += 4;
                out += 4;
                i   -= 4;
            }
            while (i)
            {
                *in = *out;
                in  += 1;
                out += 1;
                i   -= 1;
            }
            break;
        }
        case NVDE_WRITE_MEMORY:
        {
            NVDE_WRITE_MEMORY_PARAMETERS *pNvDEParams;
            U008 *in, *out;
            U032 i;

            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;

            //
            // Not bothering with osCopyin/osCopyout here because
            // this code will soon be moved to the DMC interface.
            // 
            // bdw: we need 32-bit xfers to be atomic - please retain
            //      this notion when we port this.
            //
            pNvDEParams = (NVDE_WRITE_MEMORY_PARAMETERS *)pAllocParms;
            
            in  = (U008 *)(NvU64_VALUE_T)pNvDEParams->Address;    /* XXX change to PTR_SIZE? */
            out = (U008 *)(NvU64_VALUE_T)pNvDEParams->Data;       /* XXX change to PTR_SIZE? */
            i   = pNvDEParams->Size;
            while (i >= 4)
            {
                *(U032*)in = *(U032*)out;
                in  += 4;
                out += 4;
                i   -= 4;
            }
            while (i)
            {
                *in = *out;
                in  += 1;
                out += 1;
                i   -= 1;
            }
            break;
        }
        case NVDE_TEST:
        {
            NVDE_TEST_PARAMETERS *pNvDEParams = (NVDE_TEST_PARAMETERS *)pAllocParms;
            NVDE_TEST_FUNC        pfn         = (NVDE_TEST_FUNC)pNvDEParams->CallBackAddress;

            (pfn)();

            break;
        }
        case NVDE_GET_EVENT_INFORMATION:
        {
            NVDE_GET_EVENT_INFORMATION_PARAMETERS *pNvDEParams = (NVDE_GET_EVENT_INFORMATION_PARAMETERS*)pAllocParms;
            U032 *s, *d;
            int  i;

            pNvDEParams->Count = ((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBufferCount;
            s = &((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBuffer[0].code;
            d = &pNvDEParams->Event[0][0];
            for (i = 0; i < NVDE_MAX_EVENTS * sizeof(NVDEEVENT) / 4; i++)
            {
                *d = *s;
                s++;
                d++;
            }

            // reset events
            ((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBufferCount = 0;

            break;
        }
    }
#endif

    return status;

} // end of RmDebugEx()

// end of nvapi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\cpuid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* CPU Information Gather Routines ***********************\
*                                                                           *
* Module: CPUID.C                                                           *
*   One time initialization code to setup the Processor type                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <nvcm.h>
#include <os.h>

#define CPU_STD_TSC                 BIT(4)
#define CPU_STD_MMX                 BIT(23)
#define CPU_STD_XMM                 BIT(25)
#define CPU_STD_WNI                 BIT(26)
#define CPU_EXT_3DNOW               BIT(31)

/*
 * Identify chip foundry.
 *      IS_INTEL   = "GenuineIntel"
 *      IS_AMD     = "AuthenticAMD"
 *      IS_WINCHIP = "CentaurHauls"
 *      IS_CYRIX   = "CyrixInstead"
 */
#define IS_INTEL(fndry)     (((fndry).StrID[0]==0x756E6547)&&((fndry).StrID[1]==0x49656E69)&&((fndry).StrID[2]==0x6C65746E))
#define IS_AMD(fndry)       (((fndry).StrID[0]==0x68747541)&&((fndry).StrID[1]==0x69746E65)&&((fndry).StrID[2]==0x444D4163))
#define IS_WINCHIP(fndry)   (((fndry).StrID[0]==0x746E6543)&&((fndry).StrID[1]==0x48727561)&&((fndry).StrID[2]==0x736C7561))
#define IS_CYRIX(fndry)     (((fndry).StrID[0]==0x69727943)&&((fndry).StrID[1]==0x736E4978)&&((fndry).StrID[2]==0x64616574))

/*
 * ID the CPU.
 */
VOID RmInitCpuInfo
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

#if defined(IA64)
    pRmInfo->Processor.Type = NV_CPU_IA64 |
                              NV_CPU_FUNC_MMX |
                              NV_CPU_FUNC_SFENCE |
                              NV_CPU_FUNC_SSE;
    pRmInfo->Processor.Clock = 0;
#else
    int i;
    struct _CPUID
    {
        union
        {
            U008 String[12];
            U032 StrID[3];
        } Foundry;
        U032 pad;
        U032 Family;
        U032 Model;
        U032 Stepping;
        U032 StandardFeatures;
        U032 MemoryFeatures[4];
        U032 ExtendedFeatures;
        U032 ChipFlags;
        U032 MHz;
    } cpuinfo;

#ifdef __GNUC__
    U032 eax, ebx, ecx, edx;
#endif

    
    /*
     * Init structure to default.
     */
    for (i = 0; i < 12; i++)
        cpuinfo.Foundry.String[i] = '\0';
    cpuinfo.pad              = 0;
    cpuinfo.Family           = 0;
    cpuinfo.Model            = 0;
    cpuinfo.Stepping         = 0;
    cpuinfo.StandardFeatures = 0;
    cpuinfo.ExtendedFeatures = 0;
    cpuinfo.ChipFlags        = 0;
    cpuinfo.MHz              = 0;
    
    pRmInfo->Processor.Type = 0;
    pRmInfo->Processor.Clock = 0;
    
#ifdef __GNUC__
    // if nv_cpuid() returns 0, then this cpu does not support cpuid instruction
    // We just worry about this on the first call...
    if ( ! nv_cpuid(0x00000000/*cpuid op*/, &eax, &ebx, &ecx, &edx))
        goto Exit;

    cpuinfo.Foundry.StrID[0] = ebx;
    cpuinfo.Foundry.StrID[1] = edx;
    cpuinfo.Foundry.StrID[2] = ecx;
        
    nv_cpuid(0x00000001/*cpuid op*/, &eax, &ebx, &ecx, &edx);
    cpuinfo.Family = (eax >> 8) & 0xF;
    cpuinfo.Model = (eax >> 4) & 0xF;
    cpuinfo.Stepping = (eax & 0xF);
    cpuinfo.StandardFeatures = edx;

    nv_cpuid(0x00000002/*cpuid op*/, &eax, &ebx, &ecx, &edx);
    cpuinfo.MemoryFeatures[0] = eax;
    cpuinfo.MemoryFeatures[1] = ebx;
    cpuinfo.MemoryFeatures[2] = ecx;
    cpuinfo.MemoryFeatures[3] = edx;

#else        /* ! __GNUC__ */

        /* XXX this code should be converted to use less asm */

    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                      // cpuid inst not supported
        mov     eax, 0
//      cpuid instr
        _emit   0x0F
        _emit   0xA2
        lea     esi, cpuinfo
        mov     [esi], ebx                // cpuinfo.Foundary.StrID[0]
        mov     [esi + 4], edx            // cpuinfo.Foundary.StrID[1]
        mov     [esi + 8], ecx            // cpuinfo.Foundary.StrID[2] 
        push    eax                       // Save max function count for later


        mov     eax, 1
//      cpuid instr
        _emit   0x0F
        _emit   0xA2

        mov     ebx, eax
        shr     ebx, 8
        and     ebx, 0x0F
        mov     [esi + 16], ebx           // cpuinfo.Family

        mov     ebx, eax
        shr     ebx, 4
        and     ebx, 0x0F
        mov     [esi + 20], ebx           // cpuinfo.Model

        mov     ebx, eax
        and     ebx, 0x0F
        mov     [esi + 24], ebx           // cpuinfo.Stepping

        mov     [esi + 28], edx           // cpuinfo.StandardFeatures


        mov     eax, 2
//      cpuid instr
        _emit   0x0F
        _emit   0xA2
        mov     [esi + 32], eax           // cpuinfo.MemoryFeatures
        mov     [esi + 36], ebx
        mov     [esi + 40], ecx
        mov     [esi + 44], edx
        pop     eax                       // Restore max function, but discard
        
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
#endif
    
    if (IS_INTEL(cpuinfo.Foundry))
    {
        if (cpuinfo.Family == 5)
        {
            if (cpuinfo.Model == 4)
                pRmInfo->Processor.Type = NV_CPU_P55;
            else 
                pRmInfo->Processor.Type = NV_CPU_P5;
        }
        if (cpuinfo.Family == 6)
        {
            if (cpuinfo.Model == 1)
                pRmInfo->Processor.Type = NV_CPU_P6;
            else if (cpuinfo.Model == 3)
                pRmInfo->Processor.Type = NV_CPU_P2;
            else if (cpuinfo.Model == 5)
                pRmInfo->Processor.Type = NV_CPU_P2XC;
            else if (cpuinfo.Model == 6)
                pRmInfo->Processor.Type = NV_CPU_CELA;
            else if (cpuinfo.Model == 7)
                pRmInfo->Processor.Type = NV_CPU_P3;
            else if (cpuinfo.Model == 8)
                pRmInfo->Processor.Type = NV_CPU_P3_INTL2;
        }
        if (cpuinfo.Family == 0x0F) {
            if (cpuinfo.Model == 0)
                pRmInfo->Processor.Type = NV_CPU_P4;
        }

            
        if (cpuinfo.StandardFeatures & CPU_STD_MMX)
            pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
        if (cpuinfo.StandardFeatures & CPU_STD_XMM)
        {
            U032 my_cr4;
            
            pRmInfo->Processor.Type |= NV_CPU_FUNC_SFENCE;
#ifdef __GNUC__
            my_cr4 = nv_rdcr4();
#else
            // Before setting the NV_CPU_FUNC_SSE bit, we'll also check
            // that CR4.OSFXSR(bit 9) is set, which means the OS is prepared
            // to switch the additional KATMAI FP state for us.
            
            __asm
            {
                ; save state
                push    eax
                push    ebx
                push    ecx
                push    edx

                // mov     eax,cr4
                _emit   0x0F
                _emit   0x20
                _emit   0xE0

                mov     my_cr4, eax
                
                ; restore state
                pop     edx
                pop     ecx
                pop     ebx
                pop     eax
            }
#endif
            if (my_cr4 & 0x200)
            {
                pRmInfo->Processor.Type |= NV_CPU_FUNC_SSE;

                // supports SSE2 (Willamette NI) instructions
                if (cpuinfo.StandardFeatures & CPU_STD_WNI)
                    pRmInfo->Processor.Type |= NV_CPU_FUNC_SSE2;
            }
        }
    }
    else
    {
#ifdef __GNUC__
        nv_cpuid(0x80000001/*cpuid op*/, &eax, &ebx, &ecx, &edx);
        cpuinfo.ExtendedFeatures = edx;
#else
        // All other non-Intel CPU types will want to get the extended features
        __asm
        {
            ; save state
            push    eax
            push    ebx
            push    ecx
            push    edx
                
            mov     eax, 0x80000001
            // cpuid instr
            _emit   0x0F
            _emit   0xA2
            mov     [esi + 48], edx           // cpuinfo.ExtendedFeatures
        
            ; restore state
            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }
#endif

        if (IS_AMD(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 5)                // K5, K6, K6-2 with 3DNow, K6-3
            {
                if (cpuinfo.Model < 6)
                    pRmInfo->Processor.Type = NV_CPU_K5;
                else if (cpuinfo.Model < 8)
                    pRmInfo->Processor.Type = NV_CPU_K6;
                else if (cpuinfo.Model == 8)
                    pRmInfo->Processor.Type = NV_CPU_K62;
                else if (cpuinfo.Model == 9)
                    pRmInfo->Processor.Type = NV_CPU_K63;
             }
            if (cpuinfo.Family == 6)                // K7
            {
                pRmInfo->Processor.Type = NV_CPU_K7;
#ifdef AMD_K7_SFENCE
                //
                // AMD docs indicate it's supported, but in practice on a KT133, the
                // pushbuf wasn't being flushed properly, so go back to flush by out
                // instruction, until we know different.
                //
                pRmInfo->Processor.Type |= NV_CPU_FUNC_SFENCE;
#endif
            }
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
        else if (IS_WINCHIP(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 5)                // Winchip C6, Winchip2 w/ 3DNow
            {
                if (cpuinfo.Model == 4)
                    pRmInfo->Processor.Type = NV_CPU_C6;
                if (cpuinfo.Model == 8)        
                    pRmInfo->Processor.Type = NV_CPU_C62;
            }
                    
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
        else if (IS_CYRIX(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 4)                // MediaGX
                pRmInfo->Processor.Type = NV_CPU_GX;
            if (cpuinfo.Family == 5)                // Cyrix 6x86 or MediaGX w/ MMX
            {
                if (cpuinfo.Model == 2)
                    pRmInfo->Processor.Type = NV_CPU_M1;
                if (cpuinfo.Model == 4)        
                    pRmInfo->Processor.Type = NV_CPU_MGX;
            }
            if (cpuinfo.Family == 6)                // Cyrix MII
                pRmInfo->Processor.Type = NV_CPU_M2;
        
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
    }
    
    // Calculate the frequency
    if (cpuinfo.StandardFeatures & CPU_STD_TSC)
        pRmInfo->Processor.Clock = osGetCpuFrequency();
Exit:    
    return;
#endif // !defined(IA64)
}

void RmInitBusInfo
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    VOID *handle;
    U016 vendorID, deviceID;
    U032 data32;
    U032 hclk_freq, mclk_freq;

    //
    // Currently the only chipset we need to really concern ourselves with is
    // Crush, so zero out the others for now
    //
    pRmInfo->Processor.HalInfo.FrontSideBusFreq = 0;
    pRmInfo->Processor.HalInfo.SystemMemoryFreq = 0;

    //
    // Determine if this is a Crush system
    //
    handle = osPciInitHandle(0, 0, 0, &vendorID, &deviceID);
    if (!handle)
        return;

    if ((vendorID != 0x10B9) || (deviceID != 0x1631))
    {
        U016 tempvid, tempdid;
        VOID *temphandle;

        //
        // Deal with ALI trickery.  On some systems they changed the chipset
        // devid to 0x1621 (their old chipset).  If this is the case, peer at
        // bus1 dev0 to see if we're there.  If so, assume this is really
        // a 1631
        //
        if ((vendorID == 0x10B9) && (deviceID == 0x1621))
        {
            temphandle = osPciInitHandle(1, 0, 0, &tempvid, &tempdid);
            if (!temphandle)
                return;

            // Is NV out there at Bus1 Dev0?
            if ((tempvid != 0x10DE) || ((tempdid & 0xFFF0) != 0x00A0))
                return;

            // Get the original handle back
            handle = osPciInitHandle(0, 0, 0, &vendorID, &deviceID);
            if (!handle)
                return;
        }
        else
            return;
    }

    data32 = osPciReadDword(handle, 0xF4);    // Clock Freq register

    hclk_freq = (data32 >> 6) & 0x03;   // hclk_freq [7:6]
    mclk_freq = (data32 >> 4) & 0x03;   // mclk_freq [5:4]

    switch (hclk_freq)
    {
        case 2:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 133000000;
            break;

        case 1:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 100000000;
            break;

        case 0:
        default:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 66000000;
            break;
    }

    switch (mclk_freq)
    {
        case 2:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 133000000;
            break;

        case 1:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 100000000;
            break;

        case 0:
        default:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 66000000;
            break;
    }
}

#if defined(DEBUG) && !defined(IA64)
static char *MTRR_Typenames[] = {
    "NVRM:      Type Uncached\n",
    "NVRM:      Type WriteCombined\n",
    "NVRM:      Type Reserved\n",
    "NVRM:      Type Reserved\n",
    "NVRM:      Type WriteThrough\n",
    "NVRM:      Type WriteProtected\n",
    "NVRM:      Type WriteBack\n",
    "NVRM:      Type Reserved\n"
};

//
// This routine is used to make sure the MTRRs are setup the way we think
// they should be. Manually edit the mtrr_done_once variable, if you want
// to see the output post-boot.
//
VOID dbgDumpMTRRs(VOID)
{
    U032 i, numRanges = 0, mtrrAddr;
    U032 BaseHi, BaseLo, MaskHi, MaskLo, Type;
    static U032 mtrr_done_once = 0;
#ifdef __GNUC__
    U032 eax, ebx, ecx, edx;
#endif

     if (mtrr_done_once)
        return;
    mtrr_done_once = 1;

#ifdef __GNUC__
    // if nv_cpuid() returns 0, then this cpu does not support cpuid instruction
    // We just worry about this on the first call...
    if ( ! nv_cpuid(0x00000001/*cpuid op*/, &eax, &ebx, &ecx, &edx))
        return;

    // Is MTRR supported?
    if (0 == (edx & 0x1000))
        return;

    if ( ! nv_rdmsr(254/*address*/, &eax, &edx))
        return;
    if (0 == (eax & 0x400))
        return;
    
    numRanges = eax & 0xFF;

#else

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, 254            // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        test    eax, 0x400          // check that WC as a type is supported (should be 1).
        jz      Exit

        and     eax, 0xFF           // save number of ranges
        mov     numRanges, eax
Exit:    
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
#endif

    // Use a high DEBUGLEVEL for these strings, since this is normally done once.
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Valid MTRRs:\n");

    // Now determine if we find a Write Combined match in the MTRRs
    for (i = 0, mtrrAddr = 512; i < numRanges; i++, mtrrAddr += 2)
    {
#ifdef __GNUC__
        nv_rdmsr(mtrrAddr, &BaseLo, &BaseHi);
        nv_rdmsr(mtrrAddr+1, &MaskLo, &MaskHi);        
#else
        __asm {
            ; save state
            push    eax
            push    ebx
            push    ecx
            push    edx

            mov     ecx, mtrrAddr
            RDMSR

            mov     BaseHi, edx
            mov     BaseLo, eax

            mov     ecx, mtrrAddr
            add     ecx, 1
            RDMSR

            mov     MaskHi, edx
            mov     MaskLo, eax

            ; restore state
            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }
#endif

        if (!(MaskLo & 0x800))
            continue;               // valid bit not set

        Type = BaseLo & 0xFF;      // set the type
        if (Type >= 0x8)
            Type = 0x7;            // reserved, if it's too large

        MaskLo &= ~0xFFF;          // mask off the valid bit
        BaseLo &= ~0xFFF;          // mask off the type bits

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Range ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Base ", BaseLo);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:    Length ", (~(MaskLo & ~0xFFF)) + 1);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, MTRR_Typenames[Type]);
    }
}
#endif // defined(DEBUG) && !defined(IA64)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvAuApi.c ===
/******************************************************************************
*
*   Module: nvauapi.c
*
*   Description:
*       This module is the main entry module into the NV Architecture Audio Driver.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/
#include <nvarm.h>
#include <nv32.h>
#include <nvos.h>
// #include <nvarch.h>

#include <aos.h>
#include <AHal.h>

PHWINFO_COMMON_FIELDS	pNvHWInfo[MAX_AUDIO_INSTANCE]={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

// device instance utilities
PHWINFO_COMMON_FIELDS
RmGetAudioDeviceInstance(U032 uRef)
{
    U032 uCount;
    AUDIO_REF aRef;
    
    aRef.uValue = uRef;
    
    for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
    {
        if ((pNvHWInfo[uCount]) && 
            (pNvHWInfo[uCount]->uDevType == aRef.field.type) &&
            (pNvHWInfo[uCount]->uRevisionID == aRef.field.revID))
        {
            // found a device
            return pNvHWInfo[uCount];
        }
    }

    aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: RmGetAudioDeviceInstance - instance not found\n");
    return NULL;
}


PHWINFO_COMMON_FIELDS
RmAllocAudioDeviceInstance(U032 uType, U008 uRevId)
{
    AUDIO_REF aRef;
    PHWINFO_COMMON_FIELDS pDev;
    
    aRef.field.type = uType;
    aRef.field.revID = uRevId;
    // client id-- don't care
    
    pDev = RmGetAudioDeviceInstance(aRef.uValue);
    
    if (!pDev)
    {
        U032 uCount;
        RM_STATUS rmStatus;
        
        for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
        {
            // find a free index
            if (pNvHWInfo[uCount] == NULL)
                break;
        }
        
        if (uCount == MAX_AUDIO_INSTANCE)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmAllocAudioDeviceInstance - MAX_INSTANCE exceeded\n");
            return NULL;
        }
        
        // allocate a new one
        rmStatus = aosAllocateMem(sizeof(HWINFO_COMMON_FIELDS), 
                                    ALIGN_DONT_CARE,
                                    (VOID **)&pNvHWInfo[uCount], 
                                    NULL);
        
        if (rmStatus != RM_OK)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmAllocAudioDeviceInstance - mem alloc fails\n");
            return NULL;
        }
        
        pDev = pNvHWInfo[uCount];
        
        // fill the structure up
        pDev->uDevType = uType;
        pDev->uRevisionID = uRevId;
        pDev->uInstanceCounter = 0;
        pDev->pHalContext = NULL;
    }
    
    // increment the instance counter
    pDev->uInstanceCounter++;

    return pDev;
}

VOID
RmFreeAudioDeviceInstance(PHWINFO_COMMON_FIELDS pDev)
{
    // look for the pDev in the array
    U032 uCount;
    
    // check the ref count..
    if (pDev->uInstanceCounter > 1)
    {
        pDev->uInstanceCounter--;
        return;
    }
    
    for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
    {
        if (pNvHWInfo[uCount] == pDev)
            break;
    }
    
    if (uCount == MAX_AUDIO_INSTANCE)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmFreeAudioDeviceInstance - instance could not be located\n");
        return;
    }
    
    pNvHWInfo[uCount] = NULL;
    aosFreeMem(pDev);
}

RM_STATUS 
RmAllocAudioMemory(VOID *pParam)
{
    AUDIO_ALLOC_MEMORY	*pAllocParam = (AUDIO_ALLOC_MEMORY *) pParam;
    
    return aosAllocateMem(pAllocParam->uSize,
                        pAllocParam->uAlignMask,
                        (VOID **)&(pAllocParam->pLinearAddress),
                        NULL);
}

RM_STATUS 
RmFreeAudioMemory(VOID *pParam)
{
    AUDIO_FREE_MEMORY *pFreeParam = (AUDIO_FREE_MEMORY *) pParam;
    
    aosFreeMem((VOID *)pFreeParam->pLinearAddress);
    
    return RM_OK;
}

// utility stuff
NvV32 
RmArchStatus(RM_STATUS rmStatus, U032 uArchFunc)
{
    // todo
    return (NvV32) rmStatus;
}

// exported to the calls
NvV32 
NvAuAlloc(U032 hClass, VOID* pAllocParms)
{
    PHWINFO_COMMON_FIELDS   pDev;
    RM_STATUS               rmStatus = RM_ERROR;
    
    switch(hClass)
    {
    case NV01_MEMORY_AUDIO:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_MEMORY_AUDIO ... start\n");
        rmStatus = RmAllocAudioMemory(pAllocParms);
        break;
        
    case NV01_DEVICE_AUDIO:
        {
            AUDIO_INIT_DEVICE *pParam = (AUDIO_INIT_DEVICE *)pAllocParms;
            U008 uClientID = 0;
            AUDIO_REF aRef;
            MCP1_CLIENT_INFO clientInfo;
            
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_DEVICE_AUDIO ... start\n");

            if (!pParam)
            {
                aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuAlloc - bad param list\n");
                rmStatus = RM_ERR_BAD_OBJECT_BUFFER;
                break;
            }
            
            // allocate a device reference
            // note (WDM specific) - NVMM is not initialized at this point
            // but mem allocation is fine, since it does not ask for physically
            // contiguous memory
            pDev = RmAllocAudioDeviceInstance(hClass, (U008) pParam->uRevisionID);
            
            while(pDev)
            {
                // if it's the first instance then init the device etc
                if (pDev->uInstanceCounter == 1)
                {
                    rmStatus = RmInitAudioDevice((VOID *)pParam->pResList,
                                                (VOID *)pParam->pDevObj,
                                                pDev);
                    
                    if (rmStatus == RM_OK)
                    {
                        rmStatus = InitAudioHal(pParam->uRevisionID, pDev);

                        if (rmStatus == RM_OK)
                            rmStatus = AllocDevice(pDev);
                    }
                }

                break;
            };
            
            if (rmStatus != RM_OK)
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: NvAuAlloc - NV01_DEVICE_AUDIO - 1 of the calls failed\n");
                break; 
            }
            
            clientInfo.pFn = pParam->pISRFn;
            clientInfo.Mask.uValue = pParam->IntrMask.uValue;
            clientInfo.pContext = (VOID *)pParam->pServiceContext;
            
            // everything done.. now add the client
            rmStatus = DeviceAddClient(pDev, &clientInfo, &uClientID);
            
            // form a context to be returned
            aRef.field.type = hClass;
            aRef.field.revID = pParam->uRevisionID;
            aRef.field.client = uClientID;
            
            pParam->uDeviceRef = aRef.uValue;
            break;
        }
        
    case NV01_CONTEXT_DMA_AUDIO:
        {
            // get the pDev
            APU_AP_ALLOC_CONTEXT_DMA *pParams = (APU_AP_ALLOC_CONTEXT_DMA *)pAllocParms;

            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_CONTEXT_DMA_AUDIO ... start\n");

            pDev = RmGetAudioDeviceInstance(pParams->uDeviceRef);
            if (!pDev)
                rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
            else
                rmStatus = AllocContextDma((PHWINFO_COMMON_FIELDS)pDev, pAllocParms);
            
            break;
        }
        
        // audio object calls
    case NV1B_AUDIO_OBJECT:
        {
            APU_OBJECT *pParams = (APU_OBJECT *)pAllocParms;

            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV1B_AUDIO_OBJECT ... start\n");

            pDev = RmGetAudioDeviceInstance(pParams->uDeviceRef);
            if (!pDev)
                rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
            else
                rmStatus = AllocObject((PHWINFO_COMMON_FIELDS)pDev, pAllocParms);
            
            break;
        }
        
    default:
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuAlloc - bad handle\n");
        rmStatus = RM_ERR_BAD_CLASS;
        break;
    }
    
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc ... end\n");
    return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
}


NvV32
NvAuFree
(
	U032 hClient,
    U032 hClass,
    U032 uDeviceRef,
    VOID *pParam
)
{
    RM_STATUS rmStatus;

    // find the pDev
    PHWINFO_COMMON_FIELDS pDev = RmGetAudioDeviceInstance(uDeviceRef);

    if (!pDev)
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    else
    {
        switch(hClass)
        {
        case NV01_DEVICE_AUDIO:
        case NV01_DEVICE_EXTERNAL_CODEC:
            {

                // remove client
                AUDIO_REF aRef;
                aRef.uValue = uDeviceRef;

                aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE start\n");
                
                DeviceRemoveClient(pDev, (U008) aRef.field.client);
                
                // check if this is the last instance
                if (pDev->uInstanceCounter == 1)
                {
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE freeing device object...\n");
                    rmStatus = FreeDevice(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE freeing HAL...\n");
                    DestroyAudioHal(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE shutting down device...\n");
                    RmShutdownAudioDevice(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE removing instance...\n");
                    RmFreeAudioDeviceInstance(pDev);
                }
            }
            break;
            
        case NV01_CONTEXT_DMA_AUDIO:
        case NV01_CONTEXT_DMA_EXTERNAL_CODEC:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ...  NV01_CONTEXT_DMA start\n");
            rmStatus = FreeContextDma(pDev, pParam);
            break;

        case NV01_EXTERNAL_CODEC_OBJECT:
        case NV1B_AUDIO_OBJECT:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... one of the audio objects..  start\n");
            rmStatus = FreeObject(pDev, pParam);
            break;
            
        case NV01_MEMORY_AUDIO:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_MEMORY_AUDIO start\n");
            rmStatus = RmFreeAudioMemory(pParam);
            break;
            
        default:
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuFree ... Bad class handle\n");
            rmStatus = RM_ERR_BAD_OBJECT_PARENT;
            break;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... end\n");

    return RmArchStatus(rmStatus, NV01_FREE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvdebug.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************* Common Debug Print Defines *****************************\
*                                                                           *
* Module: NVDEBUG.C                                                         *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>

#if defined(DEBUG) || defined(__DJGPP__) || defined(_XBOX)

VOID nvDbg_Printf(
    int     module,
    int     debuglevel,
    const char *printf_format,
    ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(module, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID global_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_GLOBAL, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID arch_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_ARCH, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID os_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_OS, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID dac_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_DAC, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID fifo_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_FIFO, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID gr_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_GR, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID heap_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_HEAP, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID video_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_VIDEO, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID mp_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_MP, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID dacClass_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_DACCLASS, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID videoClass_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_VIDEOCLASS, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID power_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_POWER, debuglevel, printf_format, arglist);
    va_end(arglist);
}


//======================================================================================
//
// nvDbgSprintf()
//
//======================================================================================
int nvDbgSprintf(U008 *dest, const U008 *fmt, va_list args)
{
    int ch, fieldwidth, precision, flags;
    int usedefaultprecision;
    S032 s32val;
    U032 u32val;

#if 0
    F064 f64val = 0.0;
#endif // 0 

    U008 *f, *d, *specptr;
    U008 *strpval;
    void *pval;

    if (dest == 0) // was nil
        return(0);  // If we don't have a destination, we didn't do any characters

    f = (U008 *)fmt;
    d = (U008 *)dest;

    while ((ch = *f++) != 0) {
        if (ch != '%') {
            *d++ = (U008)ch;
            continue;
        }
        specptr = f - 1;    // Save a pointer to the '%' specifier, in case of syntax errors
        ch = *f++;

        flags = DONTTERMINATE;  // Don't terminate substrings -- we'll null-terminate when we're all done
        // Check for left-alignment
        if (ch == '-') {
            flags |= LEFTALIGN_F;
            ch = *f++;
        }
        // Check for using a plus sign for non-negative numbers
        if (ch == '+') {
            flags |= PLUSSIGN_F;
            ch = *f++;
        }
        // Check for using a space character (sign place-holder) for non-negative numbers
        if (ch == ' ') {
            flags |= SPACESIGN_F;
            ch = *f++;
        }
        // Check for leading zero fill
        if (ch == '0') {
            flags |= ZEROFILL_F;
            // Don't bump the character pointer in case '0' was the only digit
        }
        // Collect the field width specifier
        fieldwidth = 0; // Default field width
        while (ch >= '0' && ch <= '9') {
            fieldwidth = fieldwidth * 10 + ch - '0';
            ch = *f++;
        }
        usedefaultprecision = TRUE; // In case a precision wasn't specified
        // Check for a precision specifier
        if (ch == '.') {    // We have a precision specifier, skip the '.'
            ch = *f++;
            precision = 0;  // Start with 0
            while (ch >= '0' && ch <= '9') {
                precision = precision * 10 + ch - '0';
                ch = *f++;
            }
            usedefaultprecision = FALSE;
        }

        // Perform the conversion operation
        switch (ch) {
        case 'c':   // Copy an ASCII character
            u32val = va_arg(args, int);
            *d++ = (U008) u32val;
            break;
        case 'u':   // Copy a formatted, unsigned decimal number
            flags |= UNSIGNED_F;
        case 'd':   // Copy a formatted, signed decimal number
            s32val = va_arg(args, int);
            // Format the number, increment the dest pointer by the characters copied
            d += nvDbg_int32todecfmtstr(s32val, d, fieldwidth, flags);
            break;
        case 'x':   // Copy a formatted, lower-case hexadecimal number
            flags |= LOWERCASE_F;
        case 'X':   // Copy a formatted, upper-case hexadecimal number
            u32val = va_arg(args, int);
            // Format the number, increment the dest pointer by the characters copied
            d += nvDbg_uint32tohexfmtstr(u32val, d, fieldwidth, flags);
            break;
        case 'p':   // Copy a formatted pointer value
            pval = va_arg(args, void *);
#if !defined(_M_IA64) && !defined(__ia64)
            // Fix me for 64 bit...

            d += nvDbg_uint32tohexfmtstr((U032)pval, d, fieldwidth, flags);
#endif
            break;
#if 0
        case 'f':   // Copy a formatted floating point number
            f64val = va_arg(args, F064);
            if (usedefaultprecision)
                precision = 6;
            // Format the number, increment the dest pointer by the characters copied
            d += nvDbg_float64todecfmtstr(f64val, d, fieldwidth, precision, flags);
            break;
#endif // 0
        case 's':   // Copy a formatted string
            strpval = va_arg(args, U008 *);
            d += nvDbg_strtofmtstr(strpval, d, fieldwidth, flags);
            break;
        case '%':   // Copy a formatted '%' sign
            d += nvDbg_strtofmtstr((U008 *)"%", d, fieldwidth, flags);
            break;
        case 0:     // Gracefully handle premature end-of-string
            f--;    // Back up, now f points to the null character again
        default:    // Unexpected conversion operator, so just echo to the destination
            while (specptr < f)
                *d++ = *specptr++;
            if (ch == 0)
                goto stringdone;
            break;
        }
    }

stringdone:
    *d = 0; // Null-terminate the string
    return((int)(d - (U008 *)dest));   // Return the number of characters we transferred
}


enum {  // Padding option definitions
    PRESPACE_O = 1,
    PREZERO_O = 2,
    POSTSPACE_O = 4
};


#define NUMBUFSIZE  16  // Should be enough for 32-bit integers in decimal or hex

//======================================================================================
//
// nvDbg_int32todecfmtstr()
//
//  This takes a 32-bit integer value and converts it to a formatted decimal string,
//  using options (field width and flags) like those provided by sprintf().  The 32-bit
//  number is assumed to be signed unless the UNSIGNED_F flag is set.  Look at the code
//  for dbugsprintf() above to see which formatting options are implemented.
//
//======================================================================================
int nvDbg_int32todecfmtstr(S032 s32val, U008 *dest, int fieldwidth, int flags)
{
    int i, digitcount, destcount;
    int sign, signchar;
    int fillcount;
    int pad_options;
    U032 u32val, quotient, remainder;
    U008 *intdigp;
    U008 nbuf[NUMBUFSIZE];

    // Process the sign-related options
    if (flags & UNSIGNED_F) {   // Unsigned conversion
        sign = 0;   // No sign character
    } else {    // We're doing a signed conversion
        sign = 1;   // Assume we'll have a sign character
        if (s32val < 0) {
            signchar = '-';
            s32val = -s32val;   // Make the number positive now so we can 'digitize' it
        } else {    // s32val >= 0
            if (flags & PLUSSIGN_F)
                signchar = '+';
            else if (flags & SPACESIGN_F)
                signchar = ' ';
            else
                sign = 0;   // No sign character
        }
    }
    u32val = s32val;    // Do unsigned math from here on out

    // Convert the number into ASCII decimal digits in our local buffer, counting them
    intdigp = &nbuf[NUMBUFSIZE];    // Point past the last character in the buffer
    digitcount = 0; // Nothing written to our local buffer yet
    do {
        quotient = u32val / 10;
        remainder = u32val - quotient * 10;
        *--intdigp =  (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
        digitcount++;
        u32val = quotient;
    } while (u32val > 0);

    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    fillcount = fieldwidth - (sign + digitcount);   // Account for the sign, if used
    if (fillcount > 0) {    // We need to do left or right padding
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F)
                pad_options = PREZERO_O;
            else
                pad_options = PRESPACE_O;
        }
    }

    destcount = 0;  // Nothing written out to the destination yet

    // Copy any leading spaces
    if (pad_options & PRESPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    // Copy the sign character, if any
    if (sign) {
        *dest++ = (U008)signchar;
        destcount++;
    }
    // Copy any leading zeros
    if (pad_options & PREZERO_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = '0';
        destcount += fillcount;
    }
    // Copy the decimal digits from our local buffer
    for (i = 0; i < digitcount; i++)
        *dest++ = *intdigp++;
    destcount += digitcount;

    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *dest = 0;
    return(destcount);  // Return the character count, not including the null
}

//======================================================================================
//
// nvDbg_uint32tohexfmtstr()
//
//  This takes a 32-bit unsigned integer value and converts it to a formatted hexadecimal
//  string, using options (field width and flags) like those provided by sprintf().  Look
//  at the code for dbugsprintf() above to see which formatting options are implemented.
//
//======================================================================================
int nvDbg_uint32tohexfmtstr(U032 u32val,  U008 *dest, int fieldwidth, int flags)
{
    int i, digitcount, destcount;
    int c, hexadjust;
    int fillcount;
    U008 fillchar;
    int pad_options;
    U032 quotient;
    U008 *intdigp;
    U008 nbuf[NUMBUFSIZE];

    hexadjust = 'A' - '9' - 1;
    if (flags & LOWERCASE_F)
        hexadjust += 'a' - 'A';

    // Convert the number into ASCII hex digits in our local buffer, counting them
    intdigp = &nbuf[NUMBUFSIZE];    // Point past the last character in the buffer
    digitcount = 0; // Nothing written to our local buffer yet
    do {
        quotient = u32val / 16;
        c = u32val % 16 + '0';
        if (c > '9')    /* A-F */
            c += hexadjust;
        *--intdigp = (U008)c; // Put the digit into the next lower buffer slot
        digitcount++;
        u32val /= 16;
    } while (u32val > 0);

    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    fillcount = fieldwidth - digitcount;    // No sign to worry about
    if (fillcount > 0) {    // We need to do left or right padding
        fillchar = ' ';     // Most common fill character is the space
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F) {
                pad_options = PREZERO_O;
                fillchar = '0';
            } else {
                pad_options = PRESPACE_O;
            }
        }
    }

    destcount = 0;  // Nothing written out to the destination yet

    // Copy any leading zeros or spaces
    if (pad_options & (PREZERO_O | PRESPACE_O)) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = fillchar;
        destcount += fillcount;
    }
    // Copy the hex digits from our local buffer
    for (i = 0; i < digitcount; i++)
        *dest++ = *intdigp++;
    destcount += digitcount;

    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = fillchar;
        destcount += fillcount;
    }
    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *dest = 0;
    return(destcount);  // Return the character count, not including the null
}


#if 0

//======================================================================================
//
// nvDbg_float64todecfmtstr()
//
//  This takes a 64-bit floating-point value and converts it to a formatted decimal
//  string, using options (field width, precision, and flags) like those provided by
//  sprintf().  Look at the code for dbugsprintf() above to see which formatting options
//  are implemented.
//
//======================================================================================
int nvDbg_float64todecfmtstr(F064 f64val, U008 *dest, int fieldwidth, int precision, int flags)
{
    int i, firstcount, destcount;
    int sign, signchar, decpt;
    int fillcount;
    int pad_options;
    int reducecount, loopdigits, digitsleft;
    U032 u32val, quotient, remainder;
    F064 f64mant9 = 0.0, f64mant9factor = 0.0, fone = 0.0, ften = 0.0, fbillion = 0.0, powerof10 = 0.0;
    U008 *digp;
    U008 nbuf[NUMBUFSIZE];  // This only needs to hold the first 9 digits of the integer part

    // Process the sign-related options
    sign = 1;   // Assume at first we'll have a sign character
    if (f64val < 0.0) {
        signchar = '-';
        f64val = -f64val;   // Make the number positive now so we can 'digitize' it
    } else {    // f64val >= 0.0
        if (flags & PLUSSIGN_F)
            signchar = '+';
        else if (flags & SPACESIGN_F)
            signchar = ' ';
        else
            sign = 0;   // No sign character
    }

    // Round the number to N decimal places.  We add 0.5 x 10^(-N), which is
    //  equivalent to adding 1 / (2*10^N).  We'll use this latter formula.
    fone = 1.0;     // Keep the compiler from always loading these constants from memory
    ften = 10.0;
    powerof10 = fone;   // 10 ^ 0
    for (i = 0; i < precision; i++)
        powerof10 *= ften;  // Build 10 ^ N
    f64val += fone / (2.0 * powerof10);
    // f64val now contains the properly rounded number

    f64mant9 = f64val;  // Start hunting for the mantissa's 9 uppermost decimal digits
    fbillion = 1e9;     // Keep it in a register
    f64mant9factor = fone;
    // Reduce the mantissa to less than 1 billion, so it will fit in a 32-bit integer
    for (reducecount = 0; f64mant9 >= fbillion; reducecount++) {
        f64mant9 /= fbillion;
        f64mant9factor *= fbillion;
    }

    // Process the highest 32-bits of the mantissa so we can count those digits first

    f64mant9 = f64val / f64mant9factor; // Grab highest 9 integer decimal digits
    u32val = (U032) f64mant9;   // Drop any fraction
    f64mant9 = u32val;  // Now we have a float with only an integer part
    f64val -= f64mant9 * f64mant9factor;    // Subtract out the previous high digits
    f64mant9factor /= fbillion;     // Adjust our division factor

    // Convert the binary into ASCII decimal digits in our local buffer, counting them
    digp = &nbuf[NUMBUFSIZE];   // Point past the last char. of these 9 digits
    firstcount = 0; // No digits of the first 32-bit integer part yet
    do {
        quotient = u32val / 10;
        remainder = u32val - quotient * 10;
        *--digp = (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
        firstcount++;
        u32val = quotient;
    } while (u32val > 0);

    // Figure out whether we'll have a decimal point
    decpt = (precision > 0);    // Don't use a decimal point if no fractional part

    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    // We have the information we need to calculate how many output characters we'll have
    fillcount = fieldwidth - (sign + firstcount + (reducecount * 9) + decpt + precision);
    if (fillcount > 0) {    // We need to do left or right padding
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F)
                pad_options = PREZERO_O;
            else
                pad_options = PRESPACE_O;
        }
    }

    destcount = 0;  // Nothing written out to the destination yet

    // Copy any leading spaces
    if (pad_options & PRESPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    // Copy the sign character, if any
    if (sign) {
        *dest++ = signchar;
        destcount++;
    }
    // Copy any leading zeros
    if (pad_options & PREZERO_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = '0';
        destcount += fillcount;
    }
    // Copy the highest chunk of integer digits from the local buffer
    for (i = 0; i < firstcount; i++)
        *dest++ = *digp++;
    destcount += firstcount;

    // Now we need to convert the remaining integer digits, if any
    for (i = 0; i < reducecount; i++) {
        f64mant9 = f64val / f64mant9factor; // Grab 9 more decimal digits
        u32val = (U032) f64mant9;       // Drop any fraction
        f64mant9 = u32val;      // Now we have a float with only an integer part
        f64val -= f64mant9 * f64mant9factor;    // Subtract out the previous high digits
        f64mant9factor /= fbillion;         // Adjust our division factor
        // Convert the integer part into ASCII decimal digits, directly to the destination
        dest += 9;              // Point past the last char. of this 9-digit chunk
        digp = dest;
        for (loopdigits = 0; loopdigits < 9; loopdigits++) {
            quotient = u32val / 10;
            remainder = u32val - quotient * 10;
            *--digp = (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
            u32val = quotient;
        }
        destcount += 9;
    }
    // f64val has only the fractional part now

    if (!decpt)
        goto checktrailing; // Skip the laborious fraction-processing part

    // Copy the decimal point
    *dest++ = '.';
    destcount++;

    // Similar to how we handled the integer part processing, we'll process up to
    //  9 digits at a time, by multiplying the fraction by a power of 10,
    //  converting to an integer, and converting digits to the destination.

    digitsleft = precision;
    do {
        loopdigits = digitsleft;
        if (loopdigits > 9)
            loopdigits = 9;
        powerof10 = fone;   // 10 ^ 0
        for (i = 0; i < loopdigits; i++)
            powerof10 *= ften;  // Build 10 ^ N
        f64val *= powerof10;    // Push some fractional digits into the integer part
        u32val = (U032) f64val; // Conversion truncates any remaining fraction
        f64val -= u32val;   // Remove the integer part, leave remaining fraction digits
        digp = dest + loopdigits;   // Point past the last char. of this chunk
        for (i = 0; i < loopdigits; i++) {
            quotient = u32val / 10;
            remainder = u32val - quotient * 10;
            *--digp = (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
            u32val = quotient;
        }
        dest += loopdigits;
        destcount += loopdigits;
        digitsleft -= loopdigits;
    } while (digitsleft > 0);

checktrailing:
    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *dest = 0;
    return(destcount);  // Return the character count, not including the null
}

#endif // 0

//======================================================================================
//
// nvDbg_strtofmtstr()
//
//  This takes a source C string and converts it to a formatted output C string,
//  using options (field width and flags) like those provided by sprintf().  Look at
//  the code for dbugsprintf() above to see which formatting options are implemented.
//
//======================================================================================
int nvDbg_strtofmtstr(U008 *src, U008 *dest, int fieldwidth, int flags)
{
    int i, srclen;
    int fillcount;
    U008 fillchar;
    int pad_options;
    U008 *s, *d;

    // For padding calculations, we need to know the source string length
    for (s = src, srclen = 0; *s != 0; s++)
        srclen++;
    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    fillcount = fieldwidth - srclen;

    if (fillcount > 0) {    // We need to do left or right padding
        fillchar = ' ';     // Most common fill character is the space
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F) {
                pad_options = PREZERO_O;
                fillchar = '0';
            } else {
                pad_options = PRESPACE_O;
            }
        }
    }

    s = src;
    d = dest;

    // Copy any leading zeros or spaces
    if (pad_options & (PREZERO_O | PRESPACE_O)) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *d++ = fillchar;
    }
    // Copy the characters from the source string
    for (i = 0; i < srclen; i++)
        *d++ = *s++;

    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *d++ = fillchar;
    }

    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *d = 0;
    return((int)(d - dest));   // Return the character count, not including the null
}

#endif // #if defined(DEBUG) || defined(__DJGPP__) || defined(_XBOX)


//********************************************************************************
//
//  NVRM_TRACE support
//    low-overhead runtime state capture
//    to enable, define USE_NVRM_TRACE (retail or debug builds)
//
//********************************************************************************

#ifdef USE_NVRM_TRACE

// the number of trace words in the ring buffer.
// a trace event can be 1 or more words
#define NVRM_TRACE_ENTRIES (8192)
// a typedef for the trace table.  Add a pad to simplify 
// bounds checking
typedef U032 NVRM_TRACE_t[NVRM_TRACE_ENTRIES + 16];

U032 NVRM_tracing = 0;    // enabled or not?
// a type'd ptr to the table.  This may make it easier for your debugger
//   to dump out the table (definitely helps on the mac)
NVRM_TRACE_t *NVRM_TRACE_GTRACE;
// actual table pointer
U032 *NVRM_TRACE_table;
// current index into the table
U032 NVRM_TRACE_idx;

#define NVRM_TRACE_BUMP(inc) { NVRM_TRACE_idx += (inc); \
                               if (NVRM_TRACE_idx >= NVRM_TRACE_ENTRIES) NVRM_TRACE_idx = 0; \
                               NVRM_TRACE_table[NVRM_TRACE_idx] = '****'; \
                             }

U032 NVRM_TRACE_INIT()
{
// allocate the table
// depending on when you call NVRM_TRACE_INIT, might not be able to
// use osAllocMem()
#ifdef MACOS9
    { extern void *PoolAllocateResident(ULONG, int);
      NVRM_TRACE_table = PoolAllocateResident(sizeof(NVRM_TRACE_t), 1/* clear */);
    }
#endif

    NVRM_TRACE_GTRACE = (void *) NVRM_TRACE_table;

#if defined(MACOS9) && defined(DEBUG) 
    // find the table
    *(U032 *) 0xf8 = (U032) NVRM_TRACE_table;
#endif

    if (NVRM_TRACE_table)
        NVRM_tracing = 1;
    return NVRM_tracing;
}

U032 NVRM_TRACE_DISABLE(void)
{
    U032 previous = NVRM_tracing;
    NVRM_tracing = 0;
    return previous;
}

void NVRM_TRACE_ENABLE(void)
{
    NVRM_tracing = 1;
}

void NVRM_TRACE(U032 value)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;

    NVRM_TRACE_table[NVRM_TRACE_idx] = value;
    NVRM_TRACE_BUMP(1);
}

void NVRM_TRACE1(U032 value)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;

    NVRM_TRACE_table[NVRM_TRACE_idx] = value;
    NVRM_TRACE_BUMP(1);
}

void NVRM_TRACE2(U032 value1, U032 value2)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_BUMP(2);
}

void NVRM_TRACE3(U032 value1, U032 value2, U032 value3)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_table[NVRM_TRACE_idx+2] = value3;
    NVRM_TRACE_BUMP(3);
}

void NVRM_TRACE4(U032 value1, U032 value2, U032 value3, U032 value4)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_table[NVRM_TRACE_idx+2] = value3;
    NVRM_TRACE_table[NVRM_TRACE_idx+3] = value4;
    NVRM_TRACE_BUMP(4);
}

void NVRM_TRACE5(U032 value1, U032 value2, U032 value3, U032 value4, U032 value5)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_table[NVRM_TRACE_idx+2] = value3;
    NVRM_TRACE_table[NVRM_TRACE_idx+3] = value4;
    NVRM_TRACE_table[NVRM_TRACE_idx+4] = value5;
    NVRM_TRACE_BUMP(5);
}

U032 NVRM_TRACE_REG_RD32(PHWINFO pDev, U032 offset)
{
    U032 value = ACTUAL_REG_RD32(offset);
    NVRM_TRACE3('RD32', offset, value);
    return value;
}

void NVRM_TRACE_REG_WR32(PHWINFO pDev, U032 offset, U032 value)
{
    ACTUAL_REG_WR32(offset, value);
    NVRM_TRACE3('WR32', offset, value);
}

#endif  // USE_NVRM_TRACE

#undef NVRM_TRACE_DUMP
void NVRM_TRACE_DUMP(void)
{
#ifdef USE_NVRM_TRACE    // make an empty one so dump can be called from oslog.c retail
    int i;
    static int dumping = 0;
    
    // No table?
    if ( ! NVRM_TRACE_table) return;
    
    // don't nest while dumping this
    if (dumping) return;
    dumping = 1;
    
    NVRM_TRACE_DISABLE();

    for (i=0; i <= NVRM_TRACE_ENTRIES; i += 8)
    {
        DBG_PRINTF((DEBUGLEVEL_ERRORS, "%x %x %x %x %x %x %x %x\n", 
                    NVRM_TRACE_table[i+0],
                    NVRM_TRACE_table[i+1],
                    NVRM_TRACE_table[i+2], 
                    NVRM_TRACE_table[i+3],
                    NVRM_TRACE_table[i+4],
                    NVRM_TRACE_table[i+5],
                    NVRM_TRACE_table[i+6],
                    NVRM_TRACE_table[i+7]));
    }
    dumping = 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvagp.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* AGP Chipset Routines **********************************\
*                                                                           *
* Module: NVAGP.C                                                           *
*   One time initialization code to update the AGP chipset and              *
*   our own AGP related values (includes workarounds and registry           *
*   overrides.                                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nvReg.h>
#include <nvrm.h>
#include <nvhw.h>
#include <os.h>
#include <nvos.h>
#include <nvagp.h>

#ifdef LINUX 
#include <os-interface.h>
#include <asm/system.h>
#define INTERRUPT_SETUP    unsigned long flags;
#else
#define INTERRUPT_SETUP
#endif

#define BYTES_MAPPED_PER_PAGE   ((RM_PAGE_SIZE >> 2) * RM_PAGE_SIZE)

extern char strDevNodeRM[];

// see how many "devices" are connected to us.
// This is important under Linux, since multiple X Servers can
// be run at once. We don't want the second X Server to reinitialize
// everything when it starts up, or the first X Server to exit
// teardown AGP on the remaining X Server.
static int agp_ref_count = 0;

// XXX get rid of this quick!!
#ifdef LINUX
#define RM_REGISTRY_AGP_BASE_PATH 0
#endif

/* define which chipsets should be compiled in. 
 * This allows controlled adding and testing of new chipsets without 
 * causing problems for people not expecting them.
 */
#define SUPPORT_INTEL_AGP     1
#define SUPPORT_VIA_AGP       1
#define SUPPORT_AMD_AGP       1
#define SUPPORT_RCC_AGP       1
#define SUPPORT_MICRON_AGP    1

enum {
      CS_UNKNOWN = 0
#ifdef SUPPORT_INTEL_AGP
    , CS_INTEL_440LX,
      CS_INTEL_440BX,
      CS_INTEL_440GX,
      CS_INTEL_815,       // solano
      CS_INTEL_820,       // camino
      CS_INTEL_840,       // carmel
      CS_INTEL_845,       // brookdale
      CS_INTEL_850,       // tehama
      CS_INTEL_860,       // colusa
      CS_INTEL_COMPAT     // compatibility
#endif
#ifdef SUPPORT_AMD_AGP
    , CS_AMD_751,         // irongate
      CS_AMD_761,         // igd4
      CS_AMD_762          // igd4 mp
#endif
#ifdef SUPPORT_VIA_AGP
    , CS_VIA_8371,        // w/ intel cpu
      CS_VIA_82C694X,     // w/ amd slot A
      CS_VIA_KT133        // w/ amd socket A
#endif
#ifdef SUPPORT_RCC_AGP
    , CS_RCC_6585HE       // cnb20he
#endif
#ifdef SUPPORT_MICRON_AGP
    , CS_MICRON_SAMDDR,   // samurai
      CS_MICRON_SCIDDR    // scimitar
#endif
};

/* moved agp mapping info here from pDev.
 * this primarily allows two things:
 *   - a second X Server run on another VT can share AGP with the
 *         initial X Server by using this info.
 *   - if X crashes and leaves AGP setup, the restarting X Server
 *         can use this info, as if it was just a second X Server.
 * In the long run, the variables in pDev should be changed to point
 * to this structure here, but we're too close to a release under
 * multiple platforms to change that much code.
 * For now, we'll just have to deal with keeping info synchronized.
 */

typedef struct {
    unsigned int initialized;
    unsigned int fw_capable;
    unsigned int sba_capable;
    VOID (*enable_mappings)(PHWINFO pDev, VOID *handle, U032 physaddr);
    VOID (*flush_mappings)(PHWINFO pDev, VOID *handle);
    U032 (*get_aper_size)(PHWINFO pDev, VOID *handle);
    U032 (*get_aper_base)(PHWINFO pDev, VOID *handle);
    U032 (*get_gart_size)(PHWINFO pDev, VOID *handle);
    U032 (*earlyinit)(PHWINFO pDev, VOID *handle);
    VOID (*fixup_gart)(PHWINFO pDev, VOID *handle, U032 physaddr);
    VOID (*apply_updates)(PHWINFO pDev, VOID *handle, U016 deviceID);
    VOID (*disable_chipset)(PHWINFO pDev, VOID *handle);
    VOID (*saverestore_chipset)(PHWINFO pDev, VOID *handle, U032 state);
} agp_chipset_funcs;

/* noop error functions to avoid NULL pointer dereferences */
static VOID agp_noop1(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID agp_noop2(PHWINFO pDev, VOID *handle);
static U032 agp_noop3(PHWINFO pDev, VOID *handle);
static VOID agp_noop4(PHWINFO pDev, VOID *handle, U016 deviceID);

/* Chipset Explanation:
 *
 * In theory, it should be easy (sw-wise) to add multiple AGP chipsets per 
 * system. chipset_funcs[] is a static array of all chipsets in a system, 
 * but is only accessed in the code via the chipset ptr. To initialize to 
 * a different chipset, call the AGP_SELECT_DEVICE() macro, to select a 
 * new bus/slot combination. currently, this uses the bus as an offset to 
 * choose which chipset to use. Although this may be a bad assumption, the 
 * only place it is made is right here, and so is a simple, isolated change.
 */

#define AGP_MAX_CHIPSETS 1
static agp_chipset_funcs chipset_funcs[AGP_MAX_CHIPSETS] = 
    { 
        { 
            0, 0, 0, 
            agp_noop1, agp_noop2, agp_noop3, agp_noop3, agp_noop3, agp_noop3, 
            agp_noop1, agp_noop4, agp_noop2
        }
    };

static agp_chipset_funcs *agp_current = NULL;

#define AGP_SELECT_DEVICE(handle, venid, devid)                      \
    agp_current = &chipset_funcs[0];                                 \
    NvSetBusDeviceFunc(pDev);                                        \
    handle = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,               \
                             AgpInfo(pDev).NBAddr.device,            \
                             AgpInfo(pDev).NBAddr.func,              \
                             venid, devid);


static VOID 
agp_noop1(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop1\n");
}

static VOID 
agp_noop2(PHWINFO pDev, VOID *handle)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop2\n");
}

static U032
agp_noop3(PHWINFO pDev, VOID *handle)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop3\n");
    return 0;
}

static VOID 
agp_noop4(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop4\n");
}


#ifdef SUPPORT_AMD_AGP

BOOL 
AMD_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_AMD_751:
        case CS_AMD_761:
        case CS_AMD_762:
            return TRUE;
    }
    return FALSE;
}

U032
AMD_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x7006:
            return CS_AMD_751;
        case 0x700E:
            return CS_AMD_761;
        case 0x700C:
            return CS_AMD_762;
    }
    return 0;
}

static VOID AMD_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID AMD_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 AMD_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 AMD_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 AMD_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 AMD_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID AMD_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID AMD_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID AMD_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID AMD_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
AMD_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = AMD_EnableMappings;
    funcs->flush_mappings      = AMD_FlushMappings;
    funcs->get_aper_size       = AMD_GetAperSize;
    funcs->get_aper_base       = AMD_GetAperBase;
    funcs->get_gart_size       = AMD_GetGartSize;
    funcs->earlyinit           = AMD_EarlyInit;
    funcs->fixup_gart          = AMD_FixupGart;
    funcs->apply_updates       = AMD_ApplyChipsetUpdates;
    funcs->disable_chipset     = AMD_DisableChipset;
    funcs->saverestore_chipset = AMD_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 1;
    funcs->sba_capable = 0;
}


static VOID
AMD_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_AMD_751:
        case CS_AMD_761:
        case CS_AMD_762:
            // enable GART directory cache  
            osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

            // enable GART table cache and errors
            ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] |= 0x5;

            // base of GART
            ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = physaddr;
            break;
        default:
            break;
    }

}

static VOID
AMD_FlushMappings(PHWINFO pDev, VOID *handle)
{
    // We could invalidate the individual entries, but for starters, just
    // invalidate the whole cache of entries. 
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x3] |= 0x1;
}

static U032
AMD_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize = osPciReadWord(handle, AMD_APER_SIZE); // aperture size
    switch ( (apsize & 0xE) >> 1 )   /* mask and shift bits 1-3 */
    {
        case 0x00:
            apsize = (  32 * 1024 * 1024);
        break;
        case 0x01:
            apsize = (  64 * 1024 * 1024);
        break;
        case 0x02:
            apsize = ( 128 * 1024 * 1024);
        break;
        case 0x03:
            apsize = ( 256 * 1024 * 1024);
        break;
        case 0x04:
            apsize = ( 512 * 1024 * 1024);
        break;
        case 0x05:
            apsize = (1024 * 1024 * 1024);
        break;
        case 0x06:
            apsize = (2024 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciAndWord(handle, AMD_APER_SIZE, ~(0xe) /* apsize */);
    }
#endif

    return apsize;
}

static U032
AMD_GetAperBase(PHWINFO pDev, VOID *handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
AMD_GetGartSize(PHWINFO pDev, VOID *handle)
{
    unsigned int gart_size;
    gart_size = ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE - 1) / RM_PAGE_SIZE) * 4;
    gart_size += RM_PAGE_SIZE;     // this is for the 1st-level lookup
    return gart_size;
}

static U032 
AMD_EarlyInit(PHWINFO pDev, VOID *handle)
{
    if ((AgpInfo(pDev).AGPChipset == CS_AMD_751) || 
        (AgpInfo(pDev).AGPChipset == CS_AMD_761) ||
        (AgpInfo(pDev).AGPChipset == CS_AMD_762))
    {
        // AMD 751/761/762 has its AGP related regs memory-mapped via BAR1
        unsigned int physaddr = (osPciReadDword(handle, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);

        AgpInfo(pDev).AGPChipsetMapping = (VOID_PTR) 
            osMapKernelSpace(physaddr, RM_PAGE_SIZE, MAP_UNCACHED);
        if (AgpInfo(pDev).AGPChipsetMapping == (VOID_PTR)NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, 
                    "NVRM: *** Failed to map AMD's AGP chipset registers\n");
            return 0;
        }
    }
    return 1;
}

static VOID
AMD_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    U032 i, *baseptr, tableptr;

    //
    // For AMD 751/761/762, convert the first allocated GART page into the first
    // level GART lookup ... where each GART directory entry is just the subsequent
    // 4k pages. We can derive the following entries, because we know the pages
    // are contiguous.
    //

    baseptr  = (U032 *)((U008 *)AgpInfo(pDev).AGPGartBase + 
        (AgpInfo(pDev).AGPPhysStart >> 20));
    tableptr = physaddr + RM_PAGE_SIZE;    // GART directory entries start on the 2nd page

    for (i = 0; i < ((AgpInfo(pDev).AGPLimit + 1) / BYTES_MAPPED_PER_PAGE); i++)
    {
        *baseptr = (tableptr | 0x1);

        tableptr += RM_PAGE_SIZE;   // next phys GART table address
        baseptr++;                  // next GART directory entry
    }
        
    //
    // Move the AGPGartBase past the first level GART page to where the GART
    // tables really begin (this makes nvagp_LoadGARTEntries() common).
    //
    (U008 *)AgpInfo(pDev).AGPGartBase += RM_PAGE_SIZE;
}

static VOID
AMD_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 agp_command;

    if (deviceID != 0x7006)
        return;    // workarounds below are AMD751 (Irongate) specific

    // disable SBA on Irongate with NV5 (some faster NV5's are failing in the lab).
    if (IsNV5(pDev))
    {
        // clear chipset's SBA enable bit
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON));
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        // clear our SBA enable bit
        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _OFF);
    }

    // Due to an AMD power glitch bug, drop down to 1x on NV10/NV15
    if (IsNV10orBetter(pDev))
    {
        //
        // Compaq (and possibly others) have a modified NV10 which allows 2x to work.
        // This rework is not SW visable, so we detect it by a registry key.
        //
        if (IsNV10(pDev))
        {
            U032 data32;
            RM_STATUS status;

            // 
            // Compaq has a modified NV10 which allows 2x to work. This rework is not
            // SW visible, so we detect it by a registry key. If set, there's nothing
            // to do.
            //
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableIrongate2x", &data32);
            if (status == RM_OK)
                return;

            //
            // This yields little perf difference, but Gateway has requested an option
            // to turn back on SBA when dropping to 1x mode. This requires setting the
            // strap first, since NV10 is normally not strapped for SBA.
            //
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableIrongateSBA", &data32);
            if (status == RM_OK)
            {
                // set the overwrite bit and change our SBA strapping
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA,   _ENABLED);

                // set chipset's SBA enable bit
                agp_command  = osPciReadDword(handle, AGP_COMMAND);
                agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
                osPciWriteDword(handle, AGP_COMMAND, agp_command);

                // set our SBA enable bit
                FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
            }
        }

        // set AGP 1x mode
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~0xF;    // clear the old AGP rate
        agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _1X);
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _1X);
    }
}

static VOID
AMD_DisableChipset(PHWINFO pDev, VOID *handle)
{
    // paranoia
    if (!AgpInfo(pDev).AGPChipsetMapping)
        return;

    // enable GART directory cache
    // nv_printf("disabling GART directory cache\n");
    // osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

    // enable GART table cache and errors
    ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] &= ~(0x5);

    // base of GART
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = 0x0;

    // unmap AMD AGP registers
    osUnmapKernelSpace((void *) AgpInfo(pDev).AGPChipsetMapping, RM_PAGE_SIZE);
}

static VOID
AMD_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}

#endif

#ifdef SUPPORT_INTEL_AGP
BOOL 
Intel_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_INTEL_440LX:
        case CS_INTEL_440BX:
        case CS_INTEL_440GX:
        case CS_INTEL_815:
        case CS_INTEL_820:
        case CS_INTEL_840:
        case CS_INTEL_845:
        case CS_INTEL_850:
        case CS_INTEL_860:
        case CS_INTEL_COMPAT:
            return TRUE;
    }
    return FALSE;
}

U032
Intel_GetChipset(PHWINFO pDev, U032 device)
{
    RM_STATUS status;
    U032 data32;

    switch(device)
    {
        case 0x7180:
            return CS_INTEL_440LX;
        case 0x7190:
            return CS_INTEL_440BX;
        case 0x71A0:
            return CS_INTEL_440GX;
        case 0x1130:
            return CS_INTEL_815;
        case 0x2500:          // dell poblano
            return CS_INTEL_820;
        case 0x2501:
            return CS_INTEL_820;
        case 0x1A20:
            return CS_INTEL_840;
        case 0x1A21:
            return CS_INTEL_840;
        case 0x1A22:
            return CS_INTEL_840;
        case 0x1A30:
            return CS_INTEL_845;
        case 0x2530:
            return CS_INTEL_850;
        case 0x2531:
            return CS_INTEL_860;
    }

    //
    // For this undetected chipset, check if the registry key is on to run it
    // in "compatibility mode". This allows Intel customers with new chipsets
    // to see if it'll work with our existing Intel support.
    //
    status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, "UseIntelCompat", &data32);
    if ((status == RM_OK) && data32)
        return CS_INTEL_COMPAT;

    return 0;
}

static VOID Intel_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Intel_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 Intel_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 Intel_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 Intel_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 Intel_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID Intel_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Intel_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID Intel_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID Intel_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
Intel_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = Intel_EnableMappings;
    funcs->flush_mappings      = Intel_FlushMappings;
    funcs->get_aper_size       = Intel_GetAperSize;
    funcs->get_aper_base       = Intel_GetAperBase;
    funcs->get_gart_size       = Intel_GetGartSize;
    funcs->earlyinit           = Intel_EarlyInit;
    funcs->fixup_gart          = Intel_FixupGart;
    funcs->apply_updates       = Intel_ApplyChipsetUpdates;
    funcs->disable_chipset     = Intel_DisableChipset;
    funcs->saverestore_chipset = Intel_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->sba_capable = 0;

    /* SOLANO, CAMINO, CARMEL, TEHAMA and COLUSA are fast-write capable */
    if (chipset == CS_INTEL_820
        || chipset == CS_INTEL_840
        || chipset == CS_INTEL_850
#ifdef SOLANO_FW
        || chipset == CS_INTEL_815
#endif
        || chipset == CS_INTEL_860)
       funcs->fw_capable = 1;
    else
       funcs->fw_capable = 0;
}

static VOID
Intel_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_INTEL_440LX:
        case CS_INTEL_440BX:
        case CS_INTEL_440GX:
            osPciWriteWord(handle, INTEL_ERRSTS, 0x07);
        /* FALLTHROUGH */
        case CS_INTEL_815:
        case CS_INTEL_820:
        case CS_INTEL_840:
        case CS_INTEL_845:
        case CS_INTEL_850:
        case CS_INTEL_860:
        case CS_INTEL_COMPAT:
            osPciWriteDword(handle, INTEL_GART_BASE, physaddr); // base of GART
            osPciOrDword(handle, INTEL_GART_CONTROL, 0x80);  // enable GTLB
            osPciOrDword(handle, INTEL_CHIPSET_CONFIG, 0x200);  // enable global access
        default:
            break;
    }
}

static VOID
Intel_FlushMappings(PHWINFO pDev, VOID *handle)
{
    // Invalidate the GTLB
    if (!handle) return;
    osPciAndDword(handle, INTEL_GART_CONTROL, ~(0x80));
    osPciOrDword(handle, INTEL_GART_CONTROL, 0x80);
}


static U032
Intel_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize;
    apsize = osPciReadWord(handle, INTEL_APER_SIZE); // aperture size
    switch (apsize)
    {
        case 0x3f:
            apsize = (4 * 1024 * 1024);
        break;
        case 0x3e:
            apsize = (8 * 1024 * 1024);
        break;
        case 0x3c:
            apsize = (16 * 1024 * 1024);
        break;
        case 0x38:
            apsize = (32 * 1024 * 1024);
        break;
        case 0x30:
            apsize = (64 * 1024 * 1024);
        break;
        case 0x20:
            apsize = (128 * 1024 * 1024);
        break;
        case 0x00:
            apsize = (256 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, INTEL_APER_SIZE, 0x38 /* apsize */);
    }

    return apsize;
}

static U032
Intel_GetAperBase(PHWINFO pDev, VOID *handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
Intel_GetGartSize(PHWINFO pDev, VOID *handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Intel_EarlyInit(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Intel_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Intel_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 agp_status, agp_command;
    U032 data;
    INTERRUPT_SETUP

    // Some special Intel chipset handling
    switch (deviceID)
    {
        case 0x2500:    // Camino
        case 0x2501:
            // expose the FW capability on Camino
            osPciOrDword(handle, INTEL_GART_CONTROL, 0x2);
            break;
        case 0x7190:    // BX/ZX

            if (IsNV15(pDev) || IsNV11(pDev))
                FLD_WR_DRF_DEF(_PBUS, _DEBUG_2, _AGP_VREF, _ENABLED);

            //
            // Temporary workaround for Toshiba's motherboard that didn't
            // connect external vref.
            //
            if (IsNV11(pDev) &&
                (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Mobile", &data) == RM_OK)) {
                if (data == 2) {        // equate for Toshiba
                    FLD_WR_DRF_DEF(_PBUS, _DEBUG_2, _AGP_VREF, _DISABLED);
                }
            }

            break;
        default:
            break;
    }

    //
    // Check for chipset overrides to AGP Multi-Transaction Timer or the
    // Low Priority Transaction Timer for the supported Intel chipsets.
    //
    switch (deviceID)
    {
        case 0x2500:    // Camino
        case 0x2501:
        case 0x1A20:    // Carmel
        case 0x1A21:
        case 0x1A22:
        case 0x1130:    // Solano
        case 0x2530:    // Tehama
        case 0x2531:    // Colusa
        {
            U032 amtt, lptt;
            if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                       "IntelAMTT", &amtt) == RM_OK) {
                if (amtt != ~0) {    // value of 0xFFFFFFFF disables the override
                    if (amtt & 0x7) {
                        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Intel AMTT not multiple of 8 clocks\n");
                    } else {
                        osPciWriteByte(handle, INTEL_MULTI_TRANS_TIMER, (U008)amtt);
                    }
                }
            }
            if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                       "IntelLPTT", &lptt) == RM_OK) {
                if (lptt != ~0) {    // value of 0xFFFFFFFF disables the override
                    if (lptt & 0x7) {
                        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Intel LPTT not multiple of 8 clocks\n");
                    } else {
                        osPciWriteByte(handle, INTEL_LOW_PRI_TRANS_TIMER, (U008)lptt);
                    }
                }
            }
            break;
        }
        default:
            break;
    }

#ifdef LINUX
    {
        unsigned int support_fw;
        if ( (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, 
                                     "EnableAGPFW", &support_fw) != RM_OK) ||
             (support_fw == 0))
        {
            return;
        }
    }
#endif

    // First, check if this chipset is FW capable
    if (!agp_current->fw_capable)
        return;

    // Also, check if we're FW capable
    if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;

    // Finally, check if this chipset is strapped for fastwrites.
    agp_status = osPciReadDword(handle, AGP_STATUS);
#ifdef SOLANO_FW
    // Solano lies about no FW support (so, ignore their strapping)
    if (((agp_status & 0x10) == 0) &&
        (Intel_GetChipset(pDev, deviceID) != CS_INTEL_815))
        return;
#else
    // AGP fastwrites aren't supported on this chipset
    if ((agp_status & 0x10) == 0)
        return;
#endif

    osDisableHardwareInterrupts(pDev);

    // enable AGP fastwrites for both us and the chipset
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);

    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    osEnableHardwareInterrupts(pDev);
}

static VOID
Intel_DisableChipset(PHWINFO pDev, VOID *handle)
{
    unsigned int agp_command;
    INTERRUPT_SETUP

    agp_command  = osPciReadDword(handle, AGP_COMMAND);

    /* if fast-writes aren't enabled, exit */
    if ( !(agp_command & 0x10) ) return;

    agp_command &= ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON));

    osDisableHardwareInterrupts(pDev);

    // disable AGP fastwrites for both us and the chipset
    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _OFF);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    osEnableHardwareInterrupts(pDev);
}

static VOID
Intel_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}
#endif

#ifdef SUPPORT_VIA_AGP

/* XXX hack alert!! */
static unsigned int via_base = 0;

BOOL 
Via_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) {
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            return TRUE;
    }
    return FALSE;
}

U032
Via_GetChipset(PHWINFO pDev, U032 device)
{
    // The spec for the 8371 chipset claims it has a device ID
    // of 0x691, but the version we looked at returned 0x391.
    // This also happens to be the device ID for the 82C694X
    // chipset, so we'll be OK regardless.
    switch(device)
    {
        case 0x0691:
            return CS_VIA_8371;
        case 0x0391:
            return CS_VIA_82C694X;
        case 0x0305:
            return CS_VIA_KT133;
    }
    return 0;
}

static VOID Via_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Via_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 Via_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 Via_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 Via_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 Via_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID Via_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Via_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID Via_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID Via_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
Via_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = Via_EnableMappings;
    funcs->flush_mappings      = Via_FlushMappings;
    funcs->get_aper_size       = Via_GetAperSize;
    funcs->get_aper_base       = Via_GetAperBase;
    funcs->get_gart_size       = Via_GetGartSize;
    funcs->earlyinit           = Via_EarlyInit;
    funcs->fixup_gart          = Via_FixupGart;
    funcs->apply_updates       = Via_ApplyChipsetUpdates;
    funcs->disable_chipset     = Via_DisableChipset;
    funcs->saverestore_chipset = Via_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 0;
    funcs->sba_capable = 0;
}

static VOID
Via_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    { 
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            // enable global access 
            osPciOrDword(handle, VIA_GART_BASE, physaddr | 0x2);
            // enable GA address translation
            osPciOrDword(handle, VIA_GART_CONTROL, 0xf);
            break;
        default:
            break;
    }
}

static VOID
Via_FlushMappings(PHWINFO pDev, VOID *handle)
{
    if (!handle) return;
    osPciOrDword(handle, VIA_GART_CONTROL, 0x80);       // enable TLB flush
    osPciAndDword(handle, VIA_GART_CONTROL, ~(0x80));   // disable TLB flush
}


/* XXX 
 * I'm unsure if there is a BIOS-default size here, the docs seem
 * to indicate it defaults to 0, so we'll see
 */
static U032
Via_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize = 0;
    apsize = osPciReadDword(handle, VIA_APER_SIZE);

    switch (apsize)
    {
        case 0xff:
            apsize =   1 * 1024 * 1024; /*   1 Meg */
            break;
        case 0xfe:
            apsize =   2 * 1024 * 1024; /*   2 Meg */
            break;
        case 0xfc:
            apsize =   4 * 1024 * 1024; /*   4 Meg */
            break;
        case 0xf8:
            apsize =   8 * 1024 * 1024; /*   8 Meg */
            break;
        case 0xf0:
            apsize =  16 * 1024 * 1024; /*  16 Meg */
            break;
        case 0xe0:
            apsize =  32 * 1024 * 1024; /*  32 Meg */
            break;
        case 0xc0:
            apsize =  64 * 1024 * 1024; /*  64 Meg */
            break;
        case 0x80:
            apsize = 128 * 1024 * 1024; /* 128 Meg */
            break;
        case 0x00:
            apsize = 256 * 1024 * 1024; /* 256 Meg */
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** VIA bad apsize!\n");
        apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, VIA_APER_SIZE, 0xe0 /* apsize */);
    }
#endif

    return apsize;
}

static U032
Via_GetAperBase(PHWINFO pDev, VOID *handle)
{
    if (!via_base)
        via_base = osPciReadDword(handle, PCI_BASE_ADDRESS_0);
    return via_base;
}

static U032
Via_GetGartSize(PHWINFO pDev, VOID *handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Via_EarlyInit(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Via_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Via_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 agp_status, agp_command, gart_control;
    INTERRUPT_SETUP

    //
    // First, determine the real ID of the chipset.
    //
    // Via, in some cases, has been using the Apollo 694x device ID with
    // the KX133 and KT133, and since we're not treating them the same
    // anymore, we need to get the real ID.
    //
    if (deviceID == 0x691)
    {
        U008 backdoor1;

        // disable the Back-Door Device ID Enable bit
        backdoor1  = osPciReadByte(handle, 0xFC);
        osPciWriteByte(handle, 0xFC, (U008)(backdoor1 & ~0x1));

        // reread the deviceID
        deviceID = (U016)(osPciReadDword(handle, 0x0) >> 16);

        // restore the Back-Door control byte
        osPciWriteByte(handle, 0xFC, backdoor1);
    }

    // return, if it's not a 694x, KX133 or KT133
    if ((deviceID != 0x691) && (deviceID != 0x391) && (deviceID != 0x305))
        return;

    //
    // Workaround for a Via chipset driver in WinME that forgot to reenable
    // this bit on the way back from hibernation. This is fixed in the latest
    // Via chipset driver, but just to be safe, leave it in for now.
    //
    gart_control = osPciReadDword(handle, 0x80);
    gart_control |= 0x2;
    osPciWriteDword(handle, 0x80, gart_control);

    if (IsNV10orBetter(pDev))
    {
        //
        // Set Via's AGP Read Synchronization bit which fixes a coherency
        // problem on their chipset (applies to NV10 and later chips).
        //
        osPciOrByte(handle, VIA_AGP_CONTROL /* 0xAC */, 0x40);
    }

    // 
    // If AGP FW's are already enabled (as part of normal chipset driver
    // configuration) avoid trying to change the AGP rate, since this can
    // cause a hang.
    //
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE) ==
        NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON)
        return;

    //
    // Only the Apollo Pro133 (Via694x) should be dropped down from 4x to 2x
    //
    if (deviceID == 0x691)
    {
        // check if we're currently in AGP 4x mode
        agp_command = osPciReadDword(handle, AGP_COMMAND);
        if (DRF_VAL(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, agp_command) == NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_4X)
        {
            U032 data32;
            RM_STATUS status;

            // check if there's a registry override to stay at AGP 4x
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, "EnableVia4x", &data32);
            if ( (status != RM_OK) || (data32 == 0) )
            {
                U008 agp_misc;

                // no override, so we'll go to AGP 2x mode
                agp_command &= ~0xF;    // clear the old AGP rate
                agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _2X);
                osPciWriteDword(handle, AGP_COMMAND, agp_command);

                FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _2X);

                // 
                // In addition to changing AGPCMD, also change AGPSTATUS to disable 4x
                // in case there's another module that tries to put us back in that mode.
                //
                agp_misc  = osPciReadByte(handle, 0xAE);
                agp_misc &= 0xFB;    // clear 4x enable
                osPciWriteByte(handle, 0xAE, agp_misc);

                // clear our 4x enable
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_4X,    _DISABLED);
            }
        }
    }

#ifdef LINUX
    {
        unsigned int support_fw;
        if ( (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, 
                                     "EnableAGPFW", &support_fw) != RM_OK) ||
             (support_fw == 0))
        {
            return;
        }
    }
#endif

    // check if we're FW capable
    if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;

    // check if Via is strapped for FW
    agp_status = osPciReadDword(handle, AGP_STATUS /* 0xA4 */);
    if (DRF_VAL(_PBUS, _PCI_NV_18, _AGP_STATUS_FW, agp_status) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;
    
    osDisableHardwareInterrupts(pDev);

    // enable AGP fastwrites for both us and the chipset
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);

    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);
    
    osEnableHardwareInterrupts(pDev);
}

static VOID
Via_DisableChipset(PHWINFO pDev, VOID *handle)
{
    switch (AgpInfo(pDev).AGPChipset)    
    { 
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            // enable global access 
            osPciWriteDword(handle, VIA_GART_BASE, 0x0);
            // enable GA address translation
            // osPciAndDword(handle, VIA_GART_CONTROL, ~(0xf));
            // restore aperture size
            // XXX hack, need to translate this mapping from stored value!!
            osPciWriteWord(handle, VIA_APER_SIZE, 0xe0 /* apsize */);
            break;
        default:
            break;
    }
}

static VOID
Via_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}
#endif

#ifdef SUPPORT_RCC_AGP

BOOL 
RCC_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_RCC_6585HE:
            return TRUE;
    }
    return FALSE;
}

U032
RCC_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x0005:
        case 0x0009:
            return CS_RCC_6585HE;
    }
    return 0;
}

static VOID RCC_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID RCC_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 RCC_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 RCC_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 RCC_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 RCC_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID RCC_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID RCC_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID RCC_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID RCC_FlushPostedWriteBuffer(PHWINFO pDev);
static VOID RCC_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
RCC_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = RCC_EnableMappings;
    funcs->flush_mappings      = RCC_FlushMappings;
    funcs->get_aper_size       = RCC_GetAperSize;
    funcs->get_aper_base       = RCC_GetAperBase;
    funcs->get_gart_size       = RCC_GetGartSize;
    funcs->earlyinit           = RCC_EarlyInit;
    funcs->fixup_gart          = RCC_FixupGart;
    funcs->apply_updates       = RCC_ApplyChipsetUpdates;
    funcs->disable_chipset     = RCC_DisableChipset;
    funcs->saverestore_chipset = RCC_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 0;
    funcs->sba_capable = 0;
}

static VOID
RCC_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    volatile U032 *ccr;    // cache control register

    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_RCC_6585HE:

            // enable GART cache and error reporting 
            ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] |= 0x9;
            
            // invalidate the caches before we start (and poll until it's done)
            ccr = &((U032 *)AgpInfo(pDev).AGPChipsetMapping)[0x3];
            *ccr |= 0x1;
            while ((*ccr & 0x1) != 0)
                ;

            // set the base of GART
            ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = physaddr;

            // set the global AGP enable bit
            osPciOrByte(handle, RCC_APER_SIZE, 0x1);
            break;

        default:
            break;
    }
}

static VOID
RCC_FlushMappings(PHWINFO pDev, VOID *handle)
{
    volatile U008 *ccr;    // cache control register

    //
    // We could invalidate individual entries, but for starters, just
    // invalidate the whole cache (and poll until it's done).
    //
    ccr = &((U008 *)AgpInfo(pDev).AGPChipsetMapping)[0xC];
    *ccr |= 0x1;
    while ((*ccr & 0x1) != 0)
        ;
}

static U032
RCC_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize = osPciReadWord(handle, RCC_APER_SIZE); // aperture size
    switch ( (apsize & 0xE) >> 1 )   /* mask and shift bits 1-3 */
    {
        case 0x00:
            apsize = (  32 * 1024 * 1024);
        break;
        case 0x01:
            apsize = (  64 * 1024 * 1024);
        break;
        case 0x02:
            apsize = ( 128 * 1024 * 1024);
        break;
        case 0x03:
            apsize = ( 256 * 1024 * 1024);
        break;
        case 0x04:
            apsize = ( 512 * 1024 * 1024);
        break;
        case 0x05:
            apsize = (1024 * 1024 * 1024);
        break;
        case 0x06:
            apsize = (2024 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciAndWord(handle, RCC_APER_SIZE, ~(0xe) /* apsize */);
    }
#endif

    return apsize;
}

static U032
RCC_GetAperBase(PHWINFO pDev, VOID *handle)
{
    VOID *handle_func0;
    U016 vendorID, deviceID;

    //
    // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
    // space, so we have to temporarily generate a func 0 handle.
    //
    handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                   AgpInfo(pDev).NBAddr.device,
                                   0x0,            // func 0
                                   &vendorID, &deviceID);

    return osPciReadDword(handle_func0, PCI_BASE_ADDRESS_0);
}

static U032
RCC_GetGartSize(PHWINFO pDev, VOID *handle)
{
    unsigned int gart_size;
    gart_size = ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE - 1) / RM_PAGE_SIZE) * 4;
    gart_size += RM_PAGE_SIZE;     // this is for the 1st-level lookup
    return gart_size;
}

static U032 
RCC_EarlyInit(PHWINFO pDev, VOID *handle)
{
    VOID *handle_func0;
    U032 physaddr;
    U016 vendorID, deviceID;

    if (AgpInfo(pDev).AGPChipset != CS_RCC_6585HE)
        return 1;

    //
    // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
    // space, so we have to temporarily generate a func 0 handle.
    //
    handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                   AgpInfo(pDev).NBAddr.device,
                                   0x0,            // func 0
                                   &vendorID, &deviceID);

    // The RCC chipset registers, like AMD are mapped at BAR1.
    physaddr = (osPciReadDword(handle_func0, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);
    AgpInfo(pDev).AGPChipsetMapping = (VOID_PTR)osMapKernelSpace(physaddr,
                                                                 RM_PAGE_SIZE,
                                                                 MAP_UNCACHED);
    if (AgpInfo(pDev).AGPChipsetMapping == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, 
        "NVRM: *** Failed to map RCC 6585HE's AGP chipset registers\n");
        return 0;
    }

    //
    // For RCC2.2, we need to enable the IO-instruction-at-PUT-update
    // war in the ogl driver to remedy a write buffer flush problem.
    //
    // Assuming Processor.Type has already gone thru RmInitCpuInfo.
    //
    // Bridge Revision Register is at offset 0x8.
    //
    if (osPciReadByte(handle_func0, 0x8) == 0x22)
    {
        PRMINFO pRmInfo = (PRMINFO)pDev->pRmInfo;

        pRmInfo->Processor.Type |= NV_CPU_FUNC_PUT_NEEDS_IO;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RCC2.2 workaround enabled\n");
    }

    return 1;
}

static VOID
RCC_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    U032 i, *baseptr, tableptr;

    //
    // Convert the first allocated GART page into the first level GART lookup,
    // where each GART directory entry is just the subsequent 4k page.
    // We can derive the following entries, because we know the pages are
    // contiguous.
    //
    baseptr  = (U032 *)AgpInfo(pDev).AGPGartBase;
    tableptr = physaddr + RM_PAGE_SIZE;    // GART directory entries start on the 2nd page

    for (i = 0; i < ((AgpInfo(pDev).AGPLimit + 1) / BYTES_MAPPED_PER_PAGE); i++)
    {
        *baseptr = tableptr;

        tableptr += RM_PAGE_SIZE;   // next phys GART table address
        baseptr++;                  // next GART directory entry
    }
        
    //
    // Move the AGPGartBase past the first level GART page to where the GART
    // tables really begin (this makes nvagp_LoadGARTEntries() common).
    //
    (U008 *)AgpInfo(pDev).AGPGartBase += RM_PAGE_SIZE;
}

static VOID
RCC_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 data32, agp_command;
    RM_STATUS status;

    //
    // SGI has requested enabling sidebanding on the RCC chipset
    // the installer will install an sgi/rcc/sba flag to enable sba,
    // but we need to recognize we're on an actual rcc chipset before
    // enabling sba. if we're here, we're on an actual rcc chipset, 
    // so check for the key and enable things...
    //
    status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableRccSBA", &data32);
    if ( (status == RM_OK) && (data32 == 1) )
    {
        // set the overwrite bit and change our SBA strapping
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA,   _ENABLED);

        // set chipset's SBA enable bit
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        // set our SBA enable bit
        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
    }

    return;
}

static VOID
RCC_DisableChipset(PHWINFO pDev, VOID *handle)
{

    // paranoia
    if (!AgpInfo(pDev).AGPChipsetMapping)
        return;

    // enable GART directory cache
    // nv_printf("disabling GART directory cache\n");
    // osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

    // enable GART table cache and errors
    ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] &= ~(0x9);

    // base of GART
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = 0x0;

    // unmap RCC AGP registers
    osUnmapKernelSpace((void *) AgpInfo(pDev).AGPChipsetMapping, RM_PAGE_SIZE);
}

static VOID
RCC_FlushPostedWriteBuffer(PHWINFO pDev)
{
    volatile U008 *pwbcr;    // posted writebuffer control register

    // flush the write buffer and wait until it's completed
    pwbcr = &((U008 *)AgpInfo(pDev).AGPChipsetMapping)[0x14];
    *pwbcr |= 0x1;
    while ((*pwbcr & 0x1) != 0)
        ;
}

static VOID
RCC_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    U032 * AGPChipsetMapping;

    AGPChipsetMapping = (U032 *)AgpInfo(pDev).AGPChipsetMapping;
    if (!AGPChipsetMapping)
    {
        VOID *handle_func0;
        U032 physaddr;
        U016 vendorID, deviceID;

        //
        // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
        // space, so we have to temporarily generate a func 0 handle.
        //
        handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                       AgpInfo(pDev).NBAddr.device,
                                       0x0,            // func 0
                                       &vendorID, &deviceID);

        // The RCC chipset registers, like AMD are mapped at BAR1.
        physaddr = (osPciReadDword(handle_func0, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);
        AGPChipsetMapping = (U032 *)osMapKernelSpace(physaddr, RM_PAGE_SIZE, MAP_UNCACHED);
    }
    if (AGPChipsetMapping)
    {
        switch (state)
        {
            case MC_POWER_LEVEL_0: // Restore (i.e. power on)
                //
                // Restore chipset registers saved off earlier.
                // NOTE: Only if the chipset AGP GART Table address register is zero
                //       AND our saved version is non-zero
                // 
                if ((!AGPChipsetMapping[0x1])
                 && (AgpInfo(pDev).AGPRegisterSave[1]))
                {
                    AGPChipsetMapping[0x0] = AgpInfo(pDev).AGPRegisterSave[0];
                    AGPChipsetMapping[0x1] = AgpInfo(pDev).AGPRegisterSave[1];
                    AGPChipsetMapping[0x2] = AgpInfo(pDev).AGPRegisterSave[2];
                    AGPChipsetMapping[0x3] = AgpInfo(pDev).AGPRegisterSave[3];
                    AGPChipsetMapping[0x4] = AgpInfo(pDev).AGPRegisterSave[4];
                    AGPChipsetMapping[0x5] = AgpInfo(pDev).AGPRegisterSave[5];
                    AGPChipsetMapping[0x6] = AgpInfo(pDev).AGPRegisterSave[6];
                    AGPChipsetMapping[0x7] = AgpInfo(pDev).AGPRegisterSave[7];
                    AGPChipsetMapping[0x8] = AgpInfo(pDev).AGPRegisterSave[8];
                    AGPChipsetMapping[0x9] = AgpInfo(pDev).AGPRegisterSave[9];
                }
                break;
            case MC_POWER_LEVEL_7: // Save (i.e. hibernate)
                //
                // Save off the AGP Config registers for possible restore later.
                //
                AgpInfo(pDev).AGPRegisterSave[0] = AGPChipsetMapping[0x0];
                AgpInfo(pDev).AGPRegisterSave[1] = AGPChipsetMapping[0x1];
                AgpInfo(pDev).AGPRegisterSave[2] = AGPChipsetMapping[0x2];
                AgpInfo(pDev).AGPRegisterSave[3] = AGPChipsetMapping[0x3];
                AgpInfo(pDev).AGPRegisterSave[4] = AGPChipsetMapping[0x4];
                AgpInfo(pDev).AGPRegisterSave[5] = AGPChipsetMapping[0x5];
                AgpInfo(pDev).AGPRegisterSave[6] = AGPChipsetMapping[0x6];
                AgpInfo(pDev).AGPRegisterSave[7] = AGPChipsetMapping[0x7];
                AgpInfo(pDev).AGPRegisterSave[8] = AGPChipsetMapping[0x8];
                AgpInfo(pDev).AGPRegisterSave[9] = AGPChipsetMapping[0x9];
                break;
        }
        //
        // unmap RCC AGP registers only if the mapping was done in this routine.
        //
        if (!AgpInfo(pDev).AGPChipsetMapping)
            osUnmapKernelSpace((void *)AGPChipsetMapping, RM_PAGE_SIZE);
    }
}
#endif

#ifdef SUPPORT_MICRON_AGP
BOOL 
Micron_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_MICRON_SAMDDR:
        case CS_MICRON_SCIDDR:
            return TRUE;
    }
    return FALSE;
}

U032
Micron_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x3120:
            return CS_MICRON_SAMDDR;
        case 0x3200:
            return CS_MICRON_SCIDDR;
    }

    return 0;
}

static VOID Micron_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Micron_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 Micron_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 Micron_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 Micron_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 Micron_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID Micron_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Micron_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID Micron_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID Micron_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
Micron_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = Micron_EnableMappings;
    funcs->flush_mappings      = Micron_FlushMappings;
    funcs->get_aper_size       = Micron_GetAperSize;
    funcs->get_aper_base       = Micron_GetAperBase;
    funcs->get_gart_size       = Micron_GetGartSize;
    funcs->earlyinit           = Micron_EarlyInit;
    funcs->fixup_gart          = Micron_FixupGart;
    funcs->apply_updates       = Micron_ApplyChipsetUpdates;
    funcs->disable_chipset     = Micron_DisableChipset;
    funcs->saverestore_chipset = Micron_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->sba_capable = 0;
}

static VOID
Micron_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_MICRON_SAMDDR:
        case CS_MICRON_SCIDDR:
            osPciWriteDword(handle, INTEL_GART_BASE, physaddr); // base of GART
            osPciOrDword(handle,    INTEL_GART_CONTROL, 0x80);  // enable GTLB
            osPciOrDword(handle,    INTEL_CHIPSET_CONFIG, 0x08);  // enable global access
        default:
            break;
    }
}

static VOID
Micron_FlushMappings(PHWINFO pDev, VOID *handle)
{
    // Invalidate the GTLB
    if (!handle)
        return;
    osPciAndDword(handle, INTEL_GART_CONTROL, ~(0x80));
    osPciOrDword(handle,  INTEL_GART_CONTROL, 0x80);
}


static U032
Micron_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize;
    apsize = osPciReadWord(handle, INTEL_APER_SIZE); // aperture size
    switch (apsize)
    {
        case 0x3f:
            apsize = (4 * 1024 * 1024);
        break;
        case 0x3e:
            apsize = (8 * 1024 * 1024);
        break;
        case 0x3c:
            apsize = (16 * 1024 * 1024);
        break;
        case 0x38:
            apsize = (32 * 1024 * 1024);
        break;
        case 0x30:
            apsize = (64 * 1024 * 1024);
        break;
        case 0x20:
            apsize = (128 * 1024 * 1024);
        break;
        case 0x00:
            apsize = (256 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, INTEL_APER_SIZE, 0x38 /* apsize */);
    }
    return apsize;
}

static U032
Micron_GetAperBase(PHWINFO pDev, VOID *handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
Micron_GetGartSize(PHWINFO pDev, VOID *handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Micron_EarlyInit(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Micron_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Micron_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    /* nothing to do... */
}

static VOID
Micron_DisableChipset(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
}

static VOID
Micron_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}
#endif


// END OF CHIPSET-SPECIFIC CODE
// the rest of this file is generic AGP support

//
// Determine which chipset we're using (from available options)
// and initialize chipset-specific functions
//
RM_STATUS
NvInitChipset(PHWINFO pDev, VOID **handle, U032 *chipset)
{
    U016 vendor_id, device_id;

    AGP_SELECT_DEVICE(*handle, &vendor_id, &device_id);
    if (!*handle) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to get PCI handle\n");
        return RM_ERR_OPERATING_SYSTEM;
    }

#ifdef SUPPORT_INTEL_AGP
    // Check Intel ...
    if (vendor_id == PCI_VENDOR_ID_INTEL)
    {
        *chipset = Intel_GetChipset(pDev, device_id);
        Intel_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_AMD_AGP
    // Check AMD ...
    if (vendor_id == PCI_VENDOR_ID_AMD)
    {
        *chipset = AMD_GetChipset(pDev, device_id);
        AMD_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_VIA_AGP
    // Check Via ...
    if (vendor_id == PCI_VENDOR_ID_VIA)
    {
        *chipset = Via_GetChipset(pDev, device_id);
        Via_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_RCC_AGP
    // Check RCC/ServerWorks ...
    if (vendor_id == PCI_VENDOR_ID_RCC)
    {
        *chipset = RCC_GetChipset(pDev, device_id);
        RCC_SetupFuncs(*chipset, agp_current);
    }
#endif
#ifdef SUPPORT_MICRON_AGP
    // Check Micron ...
    if ((vendor_id == PCI_VENDOR_ID_MICRON_1) ||
        (vendor_id == PCI_VENDOR_ID_MICRON_2))
    {
        *chipset = Micron_GetChipset(pDev, device_id);
        Micron_SetupFuncs(*chipset, agp_current);
    }
#endif

    //
    // Set the AGP Cap offset.
    // By offsetting to get to the chipset's AGP_STATUS/AGP_COMMAND, more common
    // code is used, since accessing these registers is now chipset independent.
    // 
    NvSetCapIDOffset(pDev, *handle, &AgpInfo(pDev).AGPCapPtr);
    return RM_OK;
}


//
// If the AGP chipset is 2.0 compliant, we'll set the AGP rate in a
// chipset independent way.
// 
// This is called at boot time from NvUpdateAGPConfig based on a
// registry key, but could also be called in response to a ConfigSet
// called after boot up.
//
RM_STATUS
NvSetAGPRate(PHWINFO pDev, VOID *handle, U032 *agprate)
{
    U032 agp_status, agp_command; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    // 
    // If AGP FW's are already enabled, avoid trying to change the
    // AGP rate, since this can cause a hang.
    //
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE) ==
        NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON)
        return RM_ERROR;

    //
    // Compare the rate with what the chipset and NV can do
    //
    agp_status = osPciReadDword(handle, AGP_STATUS);
    *agprate &= agp_status;
    *agprate &= REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_RATE);

    /* we now have a mask of acceptable agp rates, but this may 
     * be more than just one rate. Choose the highest rate of
     * the available, and set the chipsets to that rate
     */
    if (*agprate & 0x4) *agprate = 0x4;
    else 
    if (*agprate & 0x2) *agprate = 0x2;
    else 
    if (*agprate & 0x1) *agprate = 0x1;

    if (*agprate)
    {
       // Looks to be a valid rate for the chipset and NV, set it.
        agp_command = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~0xF;    // clear the current rate
        agp_command |= *agprate;
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, *agprate);
    }

    return RM_OK;
}

RM_STATUS
NvSetAGPFastwrites(PHWINFO pDev, VOID *handle, U032 agpfw)
{
    U032 agp_status, agp_command; 
    INTERRUPT_SETUP

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    //
    // Compare the fastwrite bit with what the chipset and NV can do
    //
    agp_status = osPciReadDword(handle, AGP_STATUS);
    agpfw &= (agp_status >> 0x4);
    agpfw &= REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW);

    agp_command = osPciReadDword(handle, AGP_COMMAND);
    agp_command &= ~0x10;    // clear the current fw bit
    agp_command |= (agpfw << 0x4);

    osDisableHardwareInterrupts(pDev);

    osPciWriteDword(handle, AGP_COMMAND, agp_command);
    FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, agpfw);

    osEnableHardwareInterrupts(pDev);

    return RM_OK;
}

RM_STATUS
NvSetAGPSideBand(PHWINFO pDev, VOID *handle, U032 agpsba)
{
    U032 agp_status, agp_command; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    agp_status = osPciReadDword(handle, AGP_STATUS);
    agpsba &= (agp_status >> 0x9);

    //
    // If we're turning on SBA (and the chipset supports it), make sure it's
    // also in our AGP_STATUS before we enable ourselves.
    //
    if (agpsba &&
        (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA) == NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE)) {
        U032 strapbits;

        // Write the STRAP_AGP_SBA enable bit
        strapbits  = REG_RD32(NV_PEXTDEV_BOOT_0);
        strapbits &= ~(DRF_MASK(NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA) <<
                       DRF_SHIFT(NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA));
        strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA, _ENABLED);
        REG_WR32(NV_PEXTDEV_BOOT_0, (strapbits |
                                     DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED)));

        // Read it back to make sure the write's completed
        strapbits = (volatile U032)REG_RD32(NV_PEXTDEV_BOOT_0);

        // If AGP_STATUS still indicates SBA isn't supported, then it's not
        if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA) == NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NvSetAGPSideBand: SBA isn't supported\n");
            return RM_ERROR;
        }
    }

    // mask and set the chipsets SBA bit
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command &= ~(DRF_MASK(NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE) <<
                     DRF_SHIFT(NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE));
    agp_command |= DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, agpsba);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    // set our SBA enable bit
    FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, agpsba);

    return RM_OK;
}

//
// Determine if any updates are needed to the AGP rate or state of AGP fastwrites.
//
VOID
NvUpdateAGPConfig(PHWINFO pDev)
{
    VOID *handle;
    U032 agprate, agpfw, agpfwstrap, agpsba;
    U016 vendorID, deviceID;

    // return if AGP is not enabled
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE) == NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF)
        return;

    AGP_SELECT_DEVICE(handle, &vendorID, &deviceID);
    if (!handle)
        return;

    /* this may be our first entry point under 9x/w2k, so
     * if we're not initialized, call NvInitChipset(), which
     * will only detect the chipset and set up our data structures.
     */
    if (!agp_current->initialized) 
    {
        U032 dummy;
        NvInitChipset(pDev, &handle, &dummy);
    }

    //
    // Before applying the chipset updates, look for a registry key that changes
    // the strap bits. This impacts what apply_updates will do and any registry
    // overrides (but, doesn't affect normal boot time AGP configuration).
    // 
    if (IsNV10orBetter(pDev) &&
        (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                           "EnableAGPFWStrap", &agpfwstrap) == RM_OK)) {
        U032 strapbits;
        strapbits  = REG_RD32(NV_PEXTDEV_BOOT_0);
        strapbits &= ~(DRF_MASK(NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR) <<
                       DRF_SHIFT(NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR));
        if (agpfwstrap)
            strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_FASTWR, _ENABLED);
        else
            strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_FASTWR, _DISABLED);

        // OR-in the _STRAP_OVERWRITE_ENABLED bit before writing
        REG_WR32(NV_PEXTDEV_BOOT_0, (strapbits |
                                     DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED)));
    }

    agp_current->apply_updates(pDev, handle, deviceID);

    // 
    // After applying any chipset updates and/or workarounds, see if there's an
    // AGP command overrides in the registry. We've seen where the Via chipset
    // driver later resets the AGP rate, so this key may not work there.
    //

    // set the AGP transfer rate
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                               "ReqAGPRate",  &agprate) == RM_OK) {
        NvSetAGPRate(pDev, handle, &agprate);
    }

    // set/clear the AGP sideband addressing bit
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                "EnableAGPSBA", &agpsba) == RM_OK) {
        NvSetAGPSideBand(pDev, handle, agpsba);
    }

    if (IsNV11orBetter(pDev)) {
        U032 agpfw_adis;

        // allows switching between fullspeed FW's and NV10-style compat mode
        if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                   "DisableAGPFWDisconnect", &agpfw_adis) == RM_OK)
            FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _AGPFW_ADIS, agpfw_adis);
    }

    // Never allow NV11's to ever enable FW, independent of what the board strapping says,
    // but do allow overrides for testing purposes (see next)
    //
    // Hmmm, not working.  Need to debug.  For some reason this killed overlays
    //
    //if (IsNV11(pDev))
    //    NvSetAGPFastwrites(pDev, handle, 0);

    // set/clear the AGP fastwrite bit
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                "EnableAGPFW", &agpfw) == RM_OK) {
        NvSetAGPFastwrites(pDev, handle, agpfw);
    }

    //Check for Crush 11 north bridge
    if( (vendorID==0x10de) && ((deviceID==0x1a4) || (deviceID==0x1a5) || (deviceID==0x1a6)) )
    {
        U032    dwAGPCommand;

        //++This is only necessary through rev A.  Rev B should fix the caps.

        dwAGPCommand = REG_RD32(NV_PBUS_PCI_NV_19);
        dwAGPCommand &= ~DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_RQ_DEPTH, DRF_MASK(NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH)); 
        dwAGPCommand |= DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_RQ_DEPTH, 0x0f);
        REG_WR32(NV_PBUS_PCI_NV_19, dwAGPCommand );
    }
}


//
// Return the AGP base/limit from the chipset. This function assumes
// the aperture base and size can be determined from PCI BAR0 in config
// space.
//
RM_STATUS
NvGetAGPBaseLimit(PHWINFO pDev, U032 *base, U032 *limit)
{
    U032 aper0, apoffset, mask;
    U032 size;
    VOID *handle;

#ifdef _WIN64
    //
    // XXX This code is specific to the 460GX chipset that's used with
    // Itanium with WIN64.
    //
    U016 vendorID, deviceID;
    U032 aper1, apsize;

    AGP_SELECT_DEVICE(handle, &vendorID, &deviceID);

    if ((vendorID != 0x8086) || ((deviceID != 0x84EA) && (deviceID != 0x84E2))) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: didn't find expected 460GX vendor/device ID's\n");
        return RM_ERROR;
    }

    //
    // read APSIZE holds the size (limit + 1) and bit 3 determine which
    // PCI offset holds the Aperture base.
    //
    apsize = osPciReadByte(handle, 0xA2);
    switch (apsize & 0x7) {
    case 0x1:   // 256 Mb
    case 0x2:   // 1 Gb
        break;
    case 0x4:   // 32GB
    default :
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: too big an Aperture size\n");
        break;
    }
    
    if (apsize & 0x8)
        apoffset = 0x98; // use BAPBASE, which are bits 0x98->0x9F
    else
        apoffset = 0x10; // use APBASE, which are bits 0x10->0x17

    aper0 = osPciReadDword(handle, apoffset);
    if ((aper0 & 0x6) == 0x4)
        aper1 = osPciReadDword(handle, apoffset + 0x4);
    else
        aper1 = 0x0;

    // 
    // If the upper 32bit's of the aperture are set, we're in trouble.
    // Because we're a 32bit device, this better be 0's, since we won't
    // be able to generate the proper address.
    //
    if (aper1) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Aperture base above 4GB\n");
        return RM_ERROR;
    }

#else
    U016 vendorID, deviceID;

    AGP_SELECT_DEVICE(handle, &vendorID, &deviceID);
    if (!handle)
        return RM_ERROR;

    apoffset = PCI_BASE_ADDRESS_0;

    //
    // We need to special case the RCC chipset for 2 reasons.
    //
    // The first is though we found the AGP cap id in func 1, the Aperture
    // base is in func 0. Also, with win2k, we're seeing a problem where
    // writing -1 and reading back the mask hangs, so we're going to read
    // the size from the RCC specific register.
    //
    if (vendorID == PCI_VENDOR_ID_RCC)
    {
        U032 size;

        // Set the limit based on a chipset register (size in bits 3:1).
        size = (osPciReadByte(handle, RCC_APER_SIZE) >> 1) & 0x7;
        *limit = (0x2000000 << size) - 1;

        // Need to move this back to func 0 (where the aperture base is)
        handle = osPciInitHandle(0x0, 0x0, 0x0, &vendorID, &deviceID);
        *base = osPciReadDword(handle, apoffset) & 0xFFFFF000;

        return RM_OK;
    }

    // read BAR0 to get the base
    aper0 = osPciReadDword(handle, apoffset);

#endif

    *base = aper0 & 0xFFFFF000;

    // write -1 and then read BAR0 to get the size mask
    osPciWriteDword(handle, apoffset, 0xFFFFFFFF);
    mask = osPciReadDword(handle, apoffset);
    *limit = (mask & 0xFFFFF000) ^ 0xFFFFFFFF;

    // restore original aperture value
    osPciWriteDword(handle, apoffset, aper0);

    // limit should be a power of 2 (i.e. size has one bit set)
    size = *limit + 1;    
    if ((size & (size - 1)) != 0)
        return RM_ERROR;

    return RM_OK;
}


VOID
NvEnableAGP(PHWINFO pDev)
{
    VOID *handle;
    unsigned short dummy;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle) return;

    /* set AGP_ENABLE bit */
    osPciOrWord(handle, AGP_COMMAND, 0x100);
}

VOID
NvDisableAGP(PHWINFO pDev)
{
    VOID *handle;
    unsigned short dummy;
    INTERRUPT_SETUP
        
    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle) return;

    /* clear AGP_ENABLE bit */
    osPciWriteWord(handle, AGP_COMMAND, 0x0);

    osDisableHardwareInterrupts(pDev);

    /* for some reason, I have to write this multiple times for it
     * to catch, at least under linux
     */
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);

    osEnableHardwareInterrupts(pDev);
}

VOID
NvSaveRestoreAGPChipset(PHWINFO pDev, U032 state)
{
    VOID *handle;
    unsigned short dummy;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return;

    if (agp_current->saverestore_chipset)
        agp_current->saverestore_chipset(pDev, handle, state);

    return;
}

/*
 * Basic AGP config/turn-on. 
 * Let chipset-specific code deal with workarounds in update.
 * Fast-write "stuff" is there.
 */
VOID
NvSetupAGPConfig(PHWINFO pDev)
{
    unsigned int do_sba, rq_depth, chipset_rq_depth;
    U016 wVendorID, wDeviceID;
    U032 agprate;
    VOID *handle;
    INTERRUPT_SETUP

    AGP_SELECT_DEVICE(handle, &wVendorID, &wDeviceID);
    if (!handle) return;

    //
    // At init time, an AGP rate has not been established, so max it out.
    // If this needs to be downgraded, it'll be done in the apply_updates
    // routine.
    //
    agprate = 0x7;
    if (RM_OK != NvSetAGPRate(pDev, handle, &agprate))
        return;

    /* setup AGP state */
    // Can we do side-band addressing (we assume the chipset can do SBA)??
    do_sba = REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA);
    do_sba &= agp_current->sba_capable;
    if (do_sba) {
        osPciOrWord(handle,  AGP_COMMAND, 0x0200);
    } else {
        osPciAndWord(handle, AGP_COMMAND, ~0x0200);    // make sure it's off
    }

    //
    // Determine the maximum AGP request depth, our value must be less
    // than or equal to the maximum the chipset can handle.
    //
    rq_depth         = REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_RQ);
    chipset_rq_depth = osPciReadDword(handle, AGP_STATUS) >> 24;
    if (chipset_rq_depth < rq_depth)
        rq_depth = chipset_rq_depth;

    osDisableHardwareInterrupts(pDev);

    REG_WR32(NV_PBUS_PCI_NV_19, DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_RQ_DEPTH, rq_depth) |
                                DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, 0x1)    |
                                DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, agprate) |
                                ((do_sba) ? DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON) : 0) |
                                0);

    osEnableHardwareInterrupts(pDev);

    osFlushCpuCache(pDev);
}

RM_STATUS 
nvagp_AllocAGPBitmap
(
    PHWINFO pDev,
    U032   Size,    // in pages
    U032  *Offset
)
{
    U008 *GARTBitmap = (U008 *)AgpInfo(pDev).AGPGartBitmap;
    U032 agp_pages = (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE;
    U032 i, j;

    osEnterCriticalCode(pDev);
    for (i = 0; i < agp_pages; i++)
    {
        if (!GARTBitmap[i >> 3])
        {
            i += 7;
        }
        else if (GARTBitmap[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++i >= agp_pages) || (++j >= Size))
                    break;
            }
            while (GARTBitmap[i >> 3] & BIT(i & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Offset = i - j;
                while (j--)
                {
                    //
                    // Mark AGP memory as allocated.
                    //
                    i--;
                    GARTBitmap[i >> 3] &= ~BIT(i & 7);
                }
                osExitCriticalCode(pDev);
                return (RM_OK);
            }
        }
    }
    osExitCriticalCode(pDev);

    return (RM_ERR_NO_FREE_MEM);
}


VOID 
nvagp_FreeAGPBitmap
(
    PHWINFO pDev,
    U032 Offset,
    U032 PageCount
)
{
    U008 *GARTBitmap = (U008 *)AgpInfo(pDev).AGPGartBitmap;

    osEnterCriticalCode(pDev);
    while (PageCount--)
    {
        //
        // Mark AGP memory as free.
        //
        GARTBitmap[Offset >> 3] |= BIT(Offset & 7);
        Offset++;
    }
    osExitCriticalCode(pDev);
}

RM_STATUS
nvagp_InsertGARTEntries
(
    PHWINFO pDev,
    U032 Index,
    U032 PageCount,
    U032 Data

)
{
    U032 *GARTEntry = ((U032 *)AgpInfo(pDev).AGPGartBase) + Index;
    U032 dummyEntry;
    U032 i;

    osEnterCriticalCode(pDev);
    // load the GART with the specified value, repeating as necessary
    for (i = 0; i < PageCount; i++)
    {
        GARTEntry[i] = Data;
        // need this readback on RCC to guarantee this is flushed
        dummyEntry = GARTEntry[i];
        if (dummyEntry != Data)
            DBG_BREAKPOINT();
    }
    osExitCriticalCode(pDev);

    return RM_OK;
}

RM_STATUS
nvagp_FlushGARTEntries
(
    PHWINFO pDev
)
{
    U016 dummy;
    VOID *handle;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return RM_ERROR;

    osEnterCriticalCode(pDev);

#ifdef SUPPORT_RCC_AGP
    // Make sure to flush the posted write buffer
    if (RCC_IsChipset(pDev))
        RCC_FlushPostedWriteBuffer(pDev);
#endif
    osFlushCpuCache(pDev);

    agp_current->flush_mappings(pDev, handle);

    osExitCriticalCode(pDev);

    return RM_OK;
}

//
// This include is needed to remap the following routines to
// their MP-safe equivalents for nt4:
//
//  nvagp_AllocAGPBitmap
//  nvagp_FreeAGPBitmap
//  nvagp_InsertGARTEntries
//  nvagp_FlushGARTEntries
//  
// This works only because these routines are defined above.
//
#include <smp.h>

static RM_STATUS 
nvagp_LoadGARTEntries
(
    PHWINFO pDev,
    VOID *pAddress,
    U032 PageCount,
    U032 Index
)
{
    U032 i;
    VOID *ucptr;    // uncached ptr
    U032 pagePhysicalAddr;
    RM_STATUS status;

    for (i = 0; i < PageCount; i++)
    {
        status = osGetAGPPhysAddr( pDev, (VOID *) pAddress, i, &pagePhysicalAddr);
        if (status != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL physical address for DMA page\n");
            return RM_ERR_NO_FREE_MEM;
        }

        // As part of loading the GART entry, create a temporary uncached mapping
        // to clean each page (must do this page by page, since the memory won't
        // be contiguous) and then free the mapping.
        //
        // It seems we can't be certain, the cache is clean w.r.t. this page, so
        // by zeroing it uncached, we hopefully force everything out preventing
        // any later writebacks to corrupt our data.

        ucptr = osMapKernelSpace(pagePhysicalAddr, RM_PAGE_SIZE, MAP_UNCACHED);
        if (ucptr == NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to create uncached mapping\n");
            return RM_ERR_NO_FREE_MEM;
        }

        // clean the page
        osMemSet(ucptr, 0, RM_PAGE_SIZE);
        *(U032 *)ucptr = 0x0;

        // free the mapping
        osUnmapKernelSpace(ucptr, RM_PAGE_SIZE);

#ifdef SUPPORT_MICRON_AGP
        if (Micron_IsChipset(pDev))
            nvagp_InsertGARTEntries(pDev, Index+i, 1, (pagePhysicalAddr >> RM_PAGE_SHIFT) | 0x80000000);
        else 
#endif
            nvagp_InsertGARTEntries(pDev, Index+i, 1, (pagePhysicalAddr & ~RM_PAGE_MASK) | 1);
    }

    nvagp_FlushGARTEntries(pDev);

    return RM_OK;
}

static RM_STATUS 
nvagp_MapAGPAperture
(
    PHWINFO pDev,
    U032 clientClass,
    U032 index,
    U032 pagecount,
    VOID **pMdl,
    VOID **pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            pMdl = NULL;           // no MDL needed for this mapping
            *pAddress = osMapIOSpace(AgpInfo(pDev).AGPPhysStart +
                                     (index << RM_PAGE_SHIFT) +
                                     (((int)(NV_UINTPTR_T)*pAddress) & RM_PAGE_MASK),
                                     pagecount << RM_PAGE_SHIFT,
                                     pMdl, MAP_KERNEL | MAP_WRITECOMBINE);
            if (*pAddress == (VOID *)NULL)
                rmStatus = RM_ERROR;
            else
                osMemSet(*pAddress, 0, pagecount << RM_PAGE_SHIFT);
            break;

        case NV01_ROOT_USER:
            // create the user mapping to these pages
            *pMdl = *pAddress;  // linux will use this, but NT will ignore it
            *pAddress = osMapIOSpace(AgpInfo(pDev).AGPPhysStart +
                                     (index << RM_PAGE_SHIFT) +
                                     (((int)(NV_UINTPTR_T)*pAddress) & RM_PAGE_MASK),
                                     pagecount << RM_PAGE_SHIFT,
                                     pMdl, MAP_USER | MAP_WRITECOMBINE);
            if (*pAddress == (VOID *)NULL)
                rmStatus = RM_ERROR;
            else
                osMemSet(*pAddress, 0, pagecount << RM_PAGE_SHIFT);
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
            break;
    }

    return rmStatus;
}

static VOID 
nvagp_UnmapAGPAperture
(
    PHWINFO pDev,
    VOID *pAddress,
    U032 Index,
    PAGP_MEM_INFO pMemInfo
)
{
    //
    // Clear out GART entries for this allocation.
    //
    nvagp_InsertGARTEntries(pDev, Index, pMemInfo->PageCount, 0);

    nvagp_FlushGARTEntries(pDev);

    //
    // If we're passed a non-NULL MDL, this means a user mapping was
    // created and needs to be cleaned up
    //
    if (pMemInfo->pMdl)
    {
        // free the user mapping
        osUnmapIOSpace(pAddress, pMemInfo->PageCount << RM_PAGE_SHIFT,
                       pMemInfo->pMdl, MAP_USER);
        pMemInfo->pMdl = NULL;
    }
    else
    {
        osUnmapIOSpace(pAddress, pMemInfo->PageCount << RM_PAGE_SHIFT,
                       pMemInfo->pMdl, MAP_KERNEL);
    }
}

RM_STATUS NvAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   PageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    U032          Index;
    PAGP_MEM_INFO pMemInfo;
    U032          rmStatus = RM_ERROR;

    if (!pDev) {
        return RM_ERR_NO_FREE_MEM;  // AGP not initialized, PCI card?
    }

    if (!AgpInfo(pDev).AGPLinearStart) {
        return RM_ERR_NO_FREE_MEM;  // true for PCI cards
    }

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(AGP_MEM_INFO));
    if (rmStatus != RM_OK)
    {
        return rmStatus;
    }

    // Alloc the pages for the caller.
    //
    // Don't use osAllocMem, since it'll write a DEBUG pattern to the buffer
    // via a cached mapping. Just use the underlying NT routine ... using the
    // non-paged pool guarantees nothing needs to be done in osLockUserMem.
 
    rmStatus = osAllocPool(pAddress, PageCount << RM_PAGE_SHIFT);
    if (rmStatus != RM_OK)
    {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    pMemInfo->SysAddr   = *pAddress;      // keep the original system addr
    pMemInfo->PageCount = PageCount;

    // Alloc from the GART bitmap for the number of pages we'll need.
    rmStatus = nvagp_AllocAGPBitmap(pDev, PageCount, &Index);
    if (rmStatus != RM_OK)
    {
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

    pMemInfo->Offset = Index;

    // Load up the GART entries with the physical addresses
    rmStatus = nvagp_LoadGARTEntries(pDev, *pAddress, PageCount, Index);
    if (rmStatus != RM_OK)
    {
        nvagp_FreeAGPBitmap(pDev, Index, PageCount);
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

    *pMemData = (VOID *)pMemInfo;

    return RM_OK;
}


RM_STATUS NvMapAGPPages
(
    PHWINFO pDev,
    VOID  **pAddress,
    U032    ClientClass,
    VOID   *pMemData
)
{
    PAGP_MEM_INFO pMemInfo = (PAGP_MEM_INFO) pMemData;
    U032          rmStatus = RM_ERROR;

    // Finally, setup a user/kernel mapping within the Aperture
    rmStatus = nvagp_MapAGPAperture(pDev,
                                    ClientClass,
                                    pMemInfo->Offset,
                                    pMemInfo->PageCount,
                                   &pMemInfo->pMdl,
                                    pAddress);
   if (rmStatus != RM_OK)
   {
        nvagp_FreeAGPBitmap(pDev, pMemInfo->Offset, pMemInfo->PageCount);
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

#ifdef _WIN64
   DBG_PRINT_STRING_VAL64(DEBUGLEVEL_TRACEINFO, "NVRM: alloc user addr    ", *(U064*)pAddress);
#else
   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: alloc user addr    ", *(U032*)pAddress);
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: mapped to agp addr ", (U032)AgpInfo(pDev).AGPPhysStart + (pMemInfo->Offset << RM_PAGE_SHIFT));

    return RM_OK;
}

//
// osFreeAGPPages - Free a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//  *pMemData  - pointer to private per-alloc data
//
RM_STATUS NvFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    PAGP_MEM_INFO pMemInfo = (PAGP_MEM_INFO)pMemData;

    if (!pDev)
        return RM_ERROR;        // this would be a misguided free

    if (!AgpInfo(pDev).AGPLinearStart)
        return RM_ERROR;        // this would be a misguided free

    nvagp_FreeAGPBitmap(pDev, pMemInfo->Offset, pMemInfo->PageCount);

    // reset the GART entries, free the mapping and flush the GTLB
    nvagp_UnmapAGPAperture(pDev, *pAddress, pMemInfo->Offset, pMemInfo);

    // free the original system pages
    osFreePool(pMemInfo->SysAddr);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}


//
// Here's our attempt to configure AGP on our own for NT4.
//
// First, we'll attempt to recognize the chipset to determine if we know how to
// program it. Next, we'll create a bitmap that's used to alloc/free slots from
// the GART.
//
BOOL RmInitAGP
(
    PHWINFO pDev
)
{
    U032 i, status;
    U032 physaddr, apsize, apbase;
    VOID *handle;
    U032 chipset = CS_UNKNOWN;
    U008 *pBitmap;
    U032 gart_size, gart_bitmap_size;

    // verify we're an AGP graphics card
    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) != NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
    {
        if (!agp_ref_count)
        {
            AgpInfo(pDev).AGPLinearStart = 0;
            AgpInfo(pDev).AGPLimit = 0;
        }
        return FALSE;
    }

    // don't initialize AGP if it's already setup
    // moved after the AGP card check so we know we should be
    // safe for the agp_restore_mappings() if needed.
    if (agp_ref_count) 
    {
        agp_ref_count++;
        return 0;
    }

    NvInitChipset(pDev, &handle, &chipset);

    if (chipset == CS_UNKNOWN)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unrecongnized AGP chipset\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPChipset = chipset;

    /* if AGP is already turned on, turn it off while we configure it */
#ifdef SUPPORT_RCC_AGP
    /* this disable scrubs the RCC bios settings, so skip it */
    if (!RCC_IsChipset(pDev))
#endif
    NvDisableAGP(pDev);

    if (!agp_current->earlyinit(pDev, handle))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** AGP early init failed\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    // get aperture info
    apsize = agp_current->get_aper_size(pDev, handle);
    apbase = agp_current->get_aper_base(pDev, handle);

    if (!apsize || !apbase)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot find Aperture Base or Size\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    apbase &= ~RM_PAGE_MASK;

    if (osSetMemRange(apbase, apsize, MEM_WRITECOMBINE) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot set Aperture to Write Combined\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPPhysStart = apbase;
        
    // Map a single page for drivers wanting to setup a context DMA for the
    // whole AGP aperture.  The type of mapping really doesn't matter.
    AgpInfo(pDev).AGPLinearStart = 
        (VOID_PTR) osMapKernelSpace(AgpInfo(pDev).AGPPhysStart, RM_PAGE_SIZE, MAP_UNCACHED);
    if (AgpInfo(pDev).AGPLinearStart == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot map the AGP Aperture\n");
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPLimit = apsize - 1;

    //
    // Allocate space for the GART.
    //
    // This memory needs to be contiguous, 4K (RM_PAGE_SIZE) aligned and locked
    // down for the page tables. My best guess at what to use is __dma_get_pages()
    // for this. If on AMD, we'll add another page for their first level table.
    //
    gart_size = agp_current->get_gart_size(pDev, handle);

    /* this is num_pages / 8 bits for bitmasks */
    gart_bitmap_size = (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / (8 * RM_PAGE_SIZE); /* don't want the lookup here */

    AgpInfo(pDev).AGPGartContigAlloc = (VOID_PTR) osAllocContigPages(gart_size);
    if (AgpInfo(pDev).AGPGartContigAlloc == (VOID_PTR) NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to allocate GART\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    // Get the physical addr to be loaded into the chipset
    physaddr = osGetKernPhysAddr( (void *) AgpInfo(pDev).AGPGartContigAlloc); 
    physaddr = ((physaddr + (RM_PAGE_SIZE - 1)) & ~RM_PAGE_MASK); // if it's not page aligned

    // Mark these pages uncached, so we can freely update the GART
    AgpInfo(pDev).AGPGartBase = (VOID_PTR) osMapKernelSpace(physaddr, gart_size, MAP_UNCACHED);

    if (AgpInfo(pDev).AGPGartBase == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to create uncached mapping for the GART\n");
        osFreeContigPages( (void *) AgpInfo(pDev).AGPGartContigAlloc);
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    osMemSet((void *)AgpInfo(pDev).AGPGartBase, 0, gart_size); /* Clear the ram out, no junk to the user */
    osFlushCpuCache(pDev);

    // allow chipset-specific modifications to gart structuring (amd...)
    agp_current->fixup_gart(pDev, handle, physaddr);

    //
    // Allocate the GART bitmap, which we'll use to manage AGP allocations.
    // Each bit in the bitmap represents a 4K mapping.
    //
    status = osAllocMem((VOID **)&AgpInfo(pDev).AGPGartBitmap, gart_bitmap_size);

    if (status != RM_OK) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to allocate GART bitmap\n");
        /* osUnmapIoSpace((VOID *)AgpInfo(pDev).AGPGartBase, gart_size); */
        osFreeContigPages( (void *) AgpInfo(pDev).AGPGartContigAlloc);
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    pBitmap = (char *)AgpInfo(pDev).AGPGartBitmap;
    for (i = 0; i < gart_bitmap_size; i++)
        pBitmap[i] = 0xFF;


    //
    // Program up the rest of the chipset.
    //
    agp_current->enable_mappings(pDev, handle, physaddr);

    /* setup chipset-specific features */
    NvSetupAGPConfig(pDev);

    /* enable chipset-specific overrides */
    NvUpdateAGPConfig(pDev);

    /* now that everything's configured, turn it on */
#ifdef SUPPORT_RCC_AGP
    /* see call to NvDisableAGP above */
    if (!RCC_IsChipset(pDev))
#endif
    NvEnableAGP(pDev);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AGP Phys Base:      ", 
        AgpInfo(pDev).AGPPhysStart);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP Linear Base:    ", 
        (VOID *)AgpInfo(pDev).AGPLinearStart);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP GART Base:      ", 
        (VOID *)AgpInfo(pDev).AGPGartBase);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP GART Bitmap:    ", 
        (VOID *)AgpInfo(pDev).AGPGartBitmap);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: # of GART Mappings: ", 
        (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE);

    // looks all good, count this as a "connected device"
    agp_ref_count++;

    return 0;

} // end of RmInitAGP()



BOOL RmTeardownAGP
(
    PHWINFO pDev
)
{
    unsigned short dummy;
    VOID *handle;
    U032 gart_size;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return 0;

    agp_ref_count--;

    // Don't tear down AGP if someone is still using it
    // (like a second X Server)
    if (agp_ref_count != 0) 
        return 0;

    gart_size = agp_current->get_gart_size(pDev, handle);
    agp_current->disable_chipset(pDev, handle);
    NvDisableAGP(pDev);

    if (AgpInfo(pDev).AGPLinearStart) 
        osUnmapKernelSpace( (void *) AgpInfo(pDev).AGPLinearStart, 
            RM_PAGE_SIZE);
    AgpInfo(pDev).AGPLinearStart = 0;

    if (AgpInfo(pDev).AGPGartBase) 
    {
        osUnmapKernelSpace((void *) AgpInfo(pDev).AGPGartBase, gart_size);
        osFreeContigPages( (void *) AgpInfo(pDev).AGPGartContigAlloc);
    }
    AgpInfo(pDev).AGPGartBase = 0;

    return 0;
}


//
// Return the Bus, Device, Func numbers of the Northbridge.
//
// We determine this by looking for the another AGP device that's not us
// and is a bridge device (so, we hopefully avoid an integrated graphics
// device). We should check for a host bridge device where the subclass
// is PCI_SUBCLASS_BR_HOST, but this doesn't work on the RCC chipset.
//
BOOL
NvSetBusDeviceFunc
(
    PHWINFO pDev
)
{
    PRMINFO pRmInfo = (PRMINFO)pDev->pRmInfo;
    VOID *handle;
    U008 bus, device, func;
    U032 cap_offset;
    U016 vendorID, deviceID;
    RM_STATUS status;

    // return it, if we've got it already
    if (pRmInfo->AGP.NBAddr.valid)
        return TRUE;

    // we're checking all the device/funcs for the first 5 buses
    for (bus = 0; bus < 5; bus++)
    {
        for (device = 0; device < PCI_MAX_DEVICES; device++)
        {
            for (func = 0; func < PCI_MAX_FUNCTION; func++)
            {
                // read at bus, device, func
                handle = osPciInitHandle(bus, device, func, &vendorID, &deviceID);
                if (!handle)
                    break;

                if (vendorID == PCI_INVALID_VENDORID)
                    break;           // skip to the next device

                if (REG_RD32(NV_PBUS_PCI_NV_0) == (U032)(deviceID << 16 | vendorID))
                    break;           // skip over ourselves

                if (osPciReadByte(handle, 0xB) != PCI_CLASS_BRIDGE_DEV)
                    break;           // not a bridge device

                // look for the AGP Capability ID
                status = NvSetCapIDOffset(pDev, handle, &cap_offset);
                if (status == RM_OK)
                {
                    // Found it
                    AgpInfo(pDev).NBAddr.bus    = bus;
                    AgpInfo(pDev).NBAddr.device = device;
                    AgpInfo(pDev).NBAddr.func   = func;
                    AgpInfo(pDev).NBAddr.valid  = 0x1;
                    return TRUE;
                }

                if ((osPciReadByte(handle, 0xE) & PCI_MULTIFUNCTION) == 0)
                    break;        // no need to cycle through functions
            }
        }
    }

    // This is bad, we didn't find the NB device (assume bus0/device0/func0)
    AgpInfo(pDev).NBAddr.bus    = 0x0;
    AgpInfo(pDev).NBAddr.device = 0x0;
    AgpInfo(pDev).NBAddr.func   = 0x0;
    AgpInfo(pDev).NBAddr.valid  = 0x1;
    DBG_BREAKPOINT();

    return FALSE;
}

RM_STATUS
NvSetCapIDOffset
(
    PHWINFO pDev, 
    VOID *handle,
    U032 *cap_offset
)
{
    U008 cap_next; 
    U032 agp_caps; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    if ((osPciReadDword(handle, 0x4) & 0x00100000) == 0)
        return RM_ERROR;    // chipset doesn't support capability ptrs

    // find the PCI offset for the AGP Cap ID
    cap_next = osPciReadByte(handle, PCI_CAPABILITY_LIST);
    while (cap_next)
    {
        agp_caps = osPciReadDword(handle, cap_next);
        if ((agp_caps & 0xFF) == 0x2)
            break;      // found the AGP Cap ID
        cap_next = (U008)((agp_caps >> 8) & 0xFF);            
    }

    if (cap_next == 0)
        return RM_ERROR;    // didn't find the AGP capid

    *cap_offset = cap_next;
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvrmapi.c ===
/*
 * nvRmApi.c
 *
 * NVidia resource manager API.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */
#pragma warning(disable : 4101 4035)

/*
 * Function defined in the scope of this file.
 */
static DWORD GetWindowsType(void);

/*
 ********************************************************************************
 * The following functions are the external, exported API to the resource manager.
 ********************************************************************************
/*
 * NvRmOpen - open connection to resource manager
 */
HANDLE __stdcall NvRmOpen
(
    VOID
)
{
}

/*
 * NvRmClose - close connection with resource manager
 */
void __stdcall NvRmClose
(
    VOID
)
{
}

/*
 * NvAlloc - allocate any arbitrary object
 */
ULONG __stdcall NvRmAlloc
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocWin9x(hClient, hParent, hObject, hClass, pAllocParms));
    else
        return(NvRmAllocWinNt(hClient, hParent, hObject, hClass, pAllocParms));
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG __stdcall NvRmAllocRoot
(
    ULONG *phClient
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocRootWin9x(phClient));
    else
        return(NvRmAllocRootWinNt(phClient));
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG __stdcall NvRmAllocDevice
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocDeviceWin9x(hClient, hDevice, hClass, szName));
    else
        return(NvRmAllocDeviceWinNt(hClient, hDevice, hClass, szName));
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG __stdcall NvRmAllocContextDma
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocContextDmaWin9x(hClient, hDma, hClass, flags, base, limit));
    else
        return(NvRmAllocContextDmaWinNt(hClient, hDma, hClass, flags, base, limit));
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG __stdcall NvRmAllocChannelPio
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocChannelPioWin9x(hClient, hDevice, hChannel, hClass, hErrorCtx, ppChannel, flags));
    else
        return(NvRmAllocChannelPioWinNt(hClient, hDevice, hChannel, hClass, hErrorCtx, ppChannel, flags));
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG __stdcall NvRmAllocChannelDma
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocChannelDmaWin9x(hClient, hDevice, hChannel, hClass, hErrorCtx, hDataCtx, offset, ppChannel));
    else
        return(NvRmAllocChannelDmaWinNt(hClient, hDevice, hChannel, hClass, hErrorCtx, hDataCtx, offset, ppChannel));
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG __stdcall NvRmAllocMemory
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocMemoryWin9x(hClient, hParent, hMemory, hClass, flags, ppAddress, pLimit));
    else
        return(NvRmAllocMemoryWinNt(hClient, hParent, hMemory, hClass, flags, ppAddress, pLimit));
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG __stdcall NvRmAllocObject
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocObjectWin9x(hClient, hChannel, hObject, hClass));
    else
        return(NvRmAllocObjectWinNt(hClient, hChannel, hObject, hClass));
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG __stdcall NvRmFree
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmFreeWin9x(hClient, hParent, hObject));
    else
        return(NvRmFreeWinNt(hClient, hParent, hObject));
}

/*
 * NV3GetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG __stdcall Nv3RmGetDmaPushInfo
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hDmaContext,
    ULONG retArray
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(Nv3RmGetDmaPushInfoWin9x(hClient, hDevice, hChannel, hDmaContext, retArray));
    else
        return(Nv3RmGetDmaPushInfoWinNt(hClient, hDevice, hChannel, hDmaContext, retArray));
}

ULONG __stdcall NvRmAllocEvent
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocEventWin9x(hClient, hObjectParent, hObjectNew, hClass, index, data));
    else
        return(NvRmAllocEventWinNt(hClient, hObjectParent, hObjectNew, hClass, index, data));
}


ULONG __stdcall NvRmArchHeap
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmArchHeapWin9x(hClient, hParent, function, owner, type,
                                   height, size, pitch, offset, address, limit, free, total));
    else
        return(NvRmArchHeapWinNt(hClient, hParent, function, owner, type,
                                   height, size, pitch, offset, address, limit, free, total));
}

ULONG  __stdcall NvRmConfigVersion
(
    ULONG hClient,
    ULONG hDevice,
    ULONG *pVersion
)
{
    return NVOS12_STATUS_SUCCESS;
}

ULONG  __stdcall NvRmConfigGet
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigGetWin9x(hClient, hDevice, index, pValue));
    else
        return(NvRmConfigGetWinNt(hClient, hDevice, index, pValue));
}

ULONG  __stdcall NvRmConfigSet
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigSetWin9x(hClient, hDevice, index, newValue, pOldValue));
    else
        return(NvRmConfigSetWinNt(hClient, hDevice, index, newValue, pOldValue));
}

ULONG  __stdcall NvRmConfigUpdate
(
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    return NVOS15_STATUS_SUCCESS;
}

ULONG  __stdcall NvRmConfigGetEx
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID  *paramStructPtr,
    ULONG paramSize
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigGetExWin9x(hClient, hDevice, index, paramStructPtr, paramSize));
    else
        return(NvRmConfigGetExWinNt(hClient, hDevice, index, paramStructPtr, paramSize));
}

ULONG  __stdcall NvRmConfigSetEx
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID  *paramStructPtr,
    ULONG paramSize
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigSetExWin9x(hClient, hDevice, index, paramStructPtr, paramSize));
    else
        return(NvRmConfigSetExWinNt(hClient, hDevice, index, paramStructPtr, paramSize));
}

ULONG  __stdcall NvRmInterrupt
(
    ULONG hClient,
    ULONG hDevice
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmInterruptWin9x(hClient, hDevice));
    else
        return(NvRmInterruptWinNt(hClient, hDevice));
}

ULONG  __stdcall NvRmRing0Callback
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmRing0CallbackWin9x(hClient, hDevice, procAddr, param1, param2));
    else
        return(NvRmRing0CallbackWinNt(hClient, hDevice, procAddr, param1, param2));
}

ULONG  __stdcall NvRmI2CAccess
(
    ULONG hClient,
    ULONG hDevice,
    VOID  *paramStructPtr
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmI2CAccessWin9x(hClient, hDevice, paramStructPtr ));
    else
        return(NvRmI2CAccessWinNt(hClient, hDevice, paramStructPtr ));
}

ULONG  __stdcall NvRmDebugControl
(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return NvRmDebugControlWin9x(hRoot, command, pArgs);
    else
        return NvRmDebugControlWinNt(hRoot, command, pArgs);
}

/*
 * GetWindowsType - Use Win32 to get windows type (9x or NT)
 */
static DWORD
GetWindowsType
(
    void
)
{
    OSVERSIONINFO osVer; /* for GetVersionEx() */

    /*
     * Get Windows type: 9x or NT
     */
    memset(&osVer, 0, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);
    (void)GetVersionEx(&osVer);
    return(osVer.dwPlatformId);
}

// end of nvRmApi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvRmApiNt.c ===
/*
 * nvRmtApiNt.c
 *
 * NVidia resource manager API implementation for Windows NT.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */
#pragma warning(disable : 4101 4035)

/*
 * NvRmOpen - open connection to resource manager
 */

HANDLE NvRmOpenWinNt
(
    VOID
)
{
    HDC   hDC;
    int   ret;
    DWORD in, out;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return (HANDLE)-1;
    }

    in  = (DWORD)0;
    ret = ExtEscape(hDC,
                    NV_ESC_RM_OPEN,
                    sizeof(DWORD), (LPCSTR)&in,
                    sizeof(DWORD), (LPSTR)&out);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return (HANDLE)-1;
    }

    ReleaseDC(0, hDC);
    return (out == (DWORD)INVALID_HANDLE_VALUE) ? (HANDLE)-1 : (HANDLE) 0;
}

/*
 * NvRmClose - close connection with resource manager
 */
VOID NvRmCloseWinNt
(
    VOID
)
{
    HDC   hDC;
    int   ret;
    DWORD in, out;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return;
    }

    in  = (DWORD)0;
    ret = ExtEscape(hDC,
                    NV_ESC_RM_CLOSE,
                    sizeof(DWORD), (LPCSTR)&in,
                    sizeof(DWORD), (LPSTR)&out);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return;
    }

    ReleaseDC(0, hDC);
    return;
}

/*
 * NvRmAlloc - allocate arbitrary objects
 */
ULONG NvRmAllocWinNt
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    HDC   hDC;
    int   ret;
    NVOS21_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot                 = (NvV32)hClient;
    inParms.hObjectParent         = (NvV32)hParent;
    inParms.hObjectNew            = (NvV32)hObject;
    inParms.hClass                = (NvV32)hClass;
    inParms.pAllocParms           = (NvP64)pAllocParms;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS21_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC,
                    sizeof(NVOS21_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS21_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS21_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRootWinNt
(
    ULONG *phClient
)
{
    HDC   hDC;
    int   ret;
    NVOS01_PARAMETERS inParms, outParms;

    *phClient = 0;

    inParms.hClass = NV01_ROOT;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS01_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_ROOT,
                    sizeof(NVOS01_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS01_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS01_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *phClient = (ULONG)outParms.hObjectNew;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDeviceWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    HDC   hDC;
    int   ret;
    NVOS06_PARAMETERS inParms, outParms;

    inParms.hObjectParent   = (NvV32)hClient;
    inParms.hObjectNew      = (NvV32)hDevice;
    inParms.hClass          = (NvV32)hClass;
    inParms.szName          = (NvV32)szName;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS06_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_DEVICE,
                    sizeof(NVOS06_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS06_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS06_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDmaWinNt
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    HDC   hDC;
    int   ret;
    NVOS03_PARAMETERS inParms, outParms;

    inParms.hObjectParent   = (NvV32)hClient;
    inParms.hObjectNew      = (NvV32)hDma;
    inParms.hClass          = (NvV32)hClass;
    inParms.flags           = (NvV32)flags;
    inParms.pBase           = (NvP64)base;
    inParms.limit           = (NvU64)limit;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS03_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CONTEXT_DMA,
                    sizeof(NVOS03_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS03_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS03_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPioWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    HDC   hDC;
    int   ret;
    NVOS04_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hDevice;
    inParms.hObjectNew      = (NvV32)hChannel;
    inParms.hClass          = (NvV32)hClass;
    inParms.hObjectError    = (NvV32)hErrorCtx;
    inParms.flags           = (NvV32)flags;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS04_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CHANNEL_PIO,
                    sizeof(NVOS04_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS04_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS04_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *ppChannel = (PVOID)outParms.pChannel;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDmaWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    HDC   hDC;
    int   ret;
    NVOS07_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hDevice;
    inParms.hObjectNew      = (NvV32)hChannel;
    inParms.hClass          = (NvV32)hClass;
    inParms.hObjectError    = (NvV32)hErrorCtx;
    inParms.hObjectBuffer   = (NvV32)hDataCtx;
    inParms.offset          = (NvV32)offset;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS07_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CHANNEL_DMA,
                    sizeof(NVOS07_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS07_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS07_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *ppChannel = (PVOID)outParms.pControl;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemoryWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    HDC   hDC;
    int   ret;
    NVOS02_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot               = (NvV32)hClient;
    inParms.hObjectParent       = (NvV32)hParent;
    inParms.hObjectNew          = (NvV32)hMemory;
    inParms.hClass              = (NvV32)hClass;
    inParms.flags               = (NvV32)flags;
    inParms.pMemory             = (NvP64)*ppAddress;
    inParms.pLimit              = (NvU64)*pLimit;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS02_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_MEMORY,
                    sizeof(NVOS02_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS02_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS02_STATUS_ERROR_OPERATING_SYSTEM);
    }

    // retrieve output parameters
    *ppAddress = (PVOID)outParms.pMemory;
    *pLimit    = (ULONG)outParms.pLimit;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG NvRmAllocObjectWinNt
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    HDC   hDC;
    int   ret;
    NVOS05_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hChannel;
    inParms.hObjectNew      = (NvV32)hObject;
    inParms.hClass          = (NvV32)hClass;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS05_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_OBJECT,
                    sizeof(NVOS05_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS05_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS05_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFreeWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    HDC   hDC;
    int   ret;
    NVOS00_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hParent;
    inParms.hObjectOld      = (NvV32)hObject;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS00_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_FREE,
                    sizeof(NVOS00_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS00_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS00_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return(outParms.status);
}

/*
 * NVGetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG Nv3RmGetDmaPushInfoWinNt
(
    ULONG hClient,  // this is client NOT channel
    ULONG hDevice,  // this is device NOT flags
    ULONG hChannel, // this is channel NOT put
    ULONG hDmaContext, // this is the DMA context for the push buffer
    ULONG retArray
)
{
    HDC   hDC;
    int   ret;
    ULONG inParms[5], outParms[5];

    inParms[0] = (NvV32)hClient;
    inParms[1] = (NvV32)hDevice;
    inParms[2] = (NvV32)hChannel;
    inParms[3] = (NvV32)retArray;
    inParms[4] = (NvV32)hDmaContext;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS08_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_DMA_PUSH_INFO,
                    sizeof(inParms), (LPCSTR)&inParms,
                    sizeof(outParms), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS08_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return(outParms[4]);
}

ULONG NvRmAllocEventWinNt
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    // This is not supported yet.
    return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;
}

ULONG NvRmArchHeapWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    HDC   hDC;
    int   ret;
    NVOS11_PARAMETERS inParms, outParms;

    inParms.hRoot         = (NvV32)hClient;
    inParms.hObjectParent = (NvV32)hParent;
    inParms.function      = (NvU32)function;
    inParms.owner         = (NvU32)owner;
    inParms.type          = (NvU32)type;
    inParms.pitch         = (NvS32)((pitch) ? *pitch : 0x0);
    inParms.height        = (NvU32)height;
    inParms.size          = (NvU32)size;
    inParms.offset        = (NvU32)*offset;


    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ARCH_HEAP,
                    sizeof(NVOS11_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS11_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES);
    }

    if (pitch)
        *pitch   = (ULONG)outParms.pitch;
    *offset  = (ULONG)outParms.offset;
    *address = (ULONG)outParms.address;
    *limit   = (ULONG)outParms.limit;
    *free    = (ULONG)outParms.free;
    *total   = (ULONG)outParms.total;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigGetWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    HDC   hDC;
    int   ret;
    NVOS13_PARAMETERS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS13_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_GET,
                    sizeof(NVOS13_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS13_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS13_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *pValue = (ULONG)outParms.value;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigSetWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    HDC   hDC;
    int   ret;
    NVOS14_PARAMETERS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.newValue        = (NvV32)newValue;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS14_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_SET,
                    sizeof(NVOS14_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS14_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS14_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *pOldValue = (ULONG)outParms.oldValue;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigGetExWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    HDC   hDC;
    int   ret;
    NVOS_CONFIG_GET_EX_PARAMS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.paramStructPtr  = (NvV32)paramStructPtr;
    inParms.paramSize       = (NvU32)paramSize;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_GET_EX,
                    sizeof(NVOS_CONFIG_GET_EX_PARAMS), (LPCSTR)&inParms,
                    sizeof(NVOS_CONFIG_GET_EX_PARAMS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigSetExWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    HDC   hDC;
    int   ret;
    NVOS_CONFIG_SET_EX_PARAMS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.paramStructPtr  = (NvV32)paramStructPtr;
    inParms.paramSize       = (NvU32)paramSize;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_SET_EX,
                    sizeof(NVOS_CONFIG_SET_EX_PARAMS), (LPCSTR)&inParms,
                    sizeof(NVOS_CONFIG_SET_EX_PARAMS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmInterruptWinNt
(
    ULONG hClient,
    ULONG hDevice
)
{
    return NVOS09_STATUS_SUCCESS;
}

ULONG NvRmRing0CallbackWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    return NVOS09_STATUS_SUCCESS;
}

ULONG NvRmI2CAccessWinNt
(
    ULONG hClient,
    ULONG hDevice,
    VOID *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS inParams,outParams;
    HDC   hDC;
    int   ret;

    inParams.hClient         = (NvV32)hClient;
    inParams.hDevice         = (NvV32)hDevice;
    inParams.paramStructPtr  = (NvV32)paramStructPtr;
    inParams.paramSize       = (NvV32)sizeof(NVRM_I2C_ACCESS_CONTROL);
    inParams.status          = (NvV32)0;

    hDC = GetDC(0);
    if (hDC == NULL) {
       return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_I2C_ACCESS,
                    sizeof(NVOS_I2C_ACCESS_PARAMS), (LPSTR)&inParams,
                    sizeof(NVOS_I2C_ACCESS_PARAMS), (LPSTR)&outParams);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    }
    ReleaseDC(0, hDC);

    return (ULONG)outParams.status;
    
}

ULONG NvRmDebugControlWinNt(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    NVOS20_PARAMETERS inParms, outParms;
    HDC   hDC;
    int   ret;

    inParms.hRoot = hRoot;
    inParms.command = command;
    inParms.pArgs = (NvP64) pArgs;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_DEBUG_CONTROL,
                    sizeof(NVOS20_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS20_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;
    }
    ReleaseDC(0, hDC);

    return outParms.status;
}

// end of nvRmApiNt.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvRmApi9x.c ===
/*
 * nvRmApi9x.c
 *
 * NVidia resource manager API for Windows 9x.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */

#pragma warning(disable : 4101 4035)


/*
 * Global variables local to the scope of this file.
 */
/*
 * Although Win32 applications have a flat address space, on the X86
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
int GetFlatDataSelector(void)
{
    DWORD Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*
 * NvRmOpen - open connection to resource manager
 */
HANDLE NvRmOpenWin9x
(
    VOID
)
{
}

/*
 * NvRmClose - close connection with resource manager
 */
VOID NvRmCloseWin9x
(
	HANDLE IOCTL_hDevice
)
{
}

/*
 * NvRmAlloc - allocate arbitrary objects
 */
ULONG NvRmAllocWin9x
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot                 = (NvV32)hClient;
    parms.hObjectParent         = (NvV32)hParent;
    parms.hObjectNew            = (NvV32)hObject;
    parms.hClass                = (NvV32)hClass;
    parms.pAllocParms.selector  = GetFlatDataSelector();
    parms.pAllocParms.offset    = (NvU32)pAllocParms;

    t_arch.function    = (DWORD)NVRM_ARCH_NV04ALLOC;
    t_arch.pParameters = (DWORD)&parms;
	NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRootWin9x
(
    ULONG *phClient
)
{
    NVOS01_PARAMETERS parms;
    NvIoctlArch       t_arch;
	HANDLE            IOCTL_hDevice;

    parms.hClass = NV01_ROOT;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01ALLOCROOT;
    t_arch.pParameters  = (DWORD)&parms;

    NvIoControl(t_arch.function,(VOID *) &parms);

    *phClient = (ULONG)parms.hObjectNew;

    return (ULONG)parms.status;
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDeviceWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    NVOS06_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hObjectParent = hClient;
    parms.hObjectNew    = hDevice;
    parms.hClass        = hClass;
    parms.szName        = (NvV32)szName;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01ALLOCDEVICE;
    t_arch.pParameters  = (DWORD)&parms;
    
    NvIoControl(t_arch.function,(VOID *) &parms);

    return((DWORD)parms.status);
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDmaWin9x
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    NVOS03_PARAMETERS parms;
    NvIoctlArch t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hObjectParent  = hClient;
    parms.hObjectNew     = hDma;
    parms.hClass         = hClass;
    parms.flags          = flags;
    parms.pBase.selector = GetFlatDataSelector();
    parms.pBase.offset   = (DWORD)base;
    parms.limit.low      = limit;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCCONTEXTDMA;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPioWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    NVOS04_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.flags         = flags;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCCHANNELPIO;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *ppChannel = (PVOID)parms.pChannel.offset;

    return((DWORD) parms.status);
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDmaWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    NVOS07_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = (NvV32)hClient;
    parms.hObjectParent = (NvV32)hDevice;
    parms.hObjectNew    = (NvV32)hChannel;
    parms.hClass        = (NvV32)hClass;
    parms.hObjectError  = (NvV32)hErrorCtx;
    parms.hObjectBuffer = (NvV32)hDataCtx;
    parms.offset        = (NvV32)offset;

    t_arch.function    = (DWORD)NVRM_ARCH_NV03ALLOCCHANNELDMA;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *ppChannel = (PVOID)parms.pControl.offset;

    return((DWORD)parms.status);
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemoryWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    NVOS02_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hMemory;
    parms.hClass            = (NvV32)hClass;
    parms.flags             = (NvV32)flags;
    parms.pMemory.selector  = GetFlatDataSelector();
    parms.pMemory.offset    = (NvU32)*ppAddress;
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = (NvU32)*pLimit;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCMEMORY;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    // retrieve output parameters
    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit    = (ULONG)parms.pLimit.low;

    return (ULONG)parms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG NvRmAllocObjectWin9x
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCOBJECT;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFreeWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    NVOS00_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.hObjectOld    = hObject;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01FREE;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);
}

/*
 * NVGetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG Nv3RmGetDmaPushInfoWin9x
(
    ULONG hClient,  // this is client NOT channel
    ULONG hDevice,  // this is device NOT flags
    ULONG hChannel, // this is channel NOT put
    ULONG hDmaContext, // this is the DMA context for the push buffer
    ULONG retArray
)
{
    ULONG       parms[5];
    NvIoctlArch t_arch;
    HANDLE            IOCTL_hDevice;

    parms[0] = (NvV32)hClient;
    parms[1] = (NvV32)hDevice;
    parms[2] = (NvV32)hChannel;
    parms[3] = (NvV32)retArray;
    parms[4] = (NvV32)hDmaContext;

    t_arch.function    = (DWORD)NVRM_ARCH_NV03DMAFLOWCONTROL;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return(parms[4]);
}

ULONG NvRmAllocEventWin9x
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    NVOS10_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hObjectParent;
    parms.hObjectNew    = hObjectNew;
    parms.hClass        = hClass;
    parms.index         = index;
    parms.hEvent.low    = data;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCEVENT;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);

}

ULONG NvRmArchHeapWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    NVOS11_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.function      = function;
    parms.owner         = owner;
    parms.type          = type;
    parms.pitch         = (pitch) ? *pitch : 0x0;
    parms.height        = height;
    parms.size          = size;
    parms.offset        = *offset;
    t_arch.function    = (DWORD)NVRM_ARCH_NV01HEAP;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    if (pitch)
        *pitch   = parms.pitch;
    *offset  = parms.offset;
    *address = parms.address;
    *limit   = parms.limit;
    *total   = parms.total;
    *free    = parms.free;
    return((DWORD)parms.status);

}

ULONG NvRmConfigGetWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    NVOS13_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.index         = (NvV32)index;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01CONFIGGET;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *pValue = (ULONG)parms.value;

    return (ULONG)parms.status;
}

ULONG NvRmConfigSetWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    NVOS14_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.index         = (NvV32)index;
    parms.newValue      = (NvV32)newValue;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01CONFIGSET;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *pOldValue = (ULONG)parms.oldValue;

    return (ULONG)parms.status;
}

ULONG NvRmConfigGetExWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_GET_EX_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.index           = (NvV32)index;
    parms.paramStructPtr  = (NvV32)paramStructPtr;
    parms.paramSize       = (NvU32)paramSize;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04CONFIGGETEX;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmConfigSetExWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_SET_EX_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.index           = (NvV32)index;
    parms.paramStructPtr  = (NvV32)paramStructPtr;
    parms.paramSize       = (NvU32)paramSize;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04CONFIGSETEX;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmInterruptWin9x
(
    ULONG hClient,
    ULONG hDevice
)
{
    NVOS09_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01INTERRUPT;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmRing0CallbackWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    NVRM_RING0CALLBACK_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE                    IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.functionPtr   = (RING0CALLBACKPROC)procAddr;
    parms.param1        = (NvU32)param1;
    parms.param2        = (NvU32)param2;

    t_arch.function     = (DWORD)NVRM_ARCH_RING0CALLBACK;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmI2CAccessWin9x
(
    ULONG hClient,
    ULONG hDevice,
    VOID *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS    parms;
    NvIoctlArch               t_arch;
    HANDLE                    IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.paramStructPtr  = (NvV32)paramStructPtr;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04I2CACCESS;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmDebugControlWin9x
(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    NVOS20_PARAMETERS         parms;
    NvIoctlArch               t_arch;

    parms.hRoot = hRoot;
    parms.command = command;
    parms.pArgs.selector = GetFlatDataSelector();
    parms.pArgs.offset = (DWORD) pArgs;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01DEBUGCONTROL;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);

    return (ULONG)parms.status;
}

// end of nvRmApi9x.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvrmr0api.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvRmR0Api.c
 *
 *  Routines to interact with the resource manager VxD's API services.
 *  
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

// #define WANTVXDWRAPS 
#include <basedef.h>
#include <vmm.h>
#include <vmmreg.h>
#include <vxdldr.h>
//#include <debug.h>
//#include <vxdwraps.h>
#include <vwin32.h>

#include "nvtypes.h"
#include "nvrmr0api.h"
#include "nvrmwin.h"
#include "nvos.h"
#include "files.h"
#include "nvmisc.h"
#include "nvReg.h"

/*----------------------------------------------------------------------------*/
/*
 * pragma's to put the code and data into locked memory (XXX not sure if needed)
 */

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

/*----------------------------------------------------------------------------*/
/*
 * globals
 */

typedef DWORD (* LPDWFN)();
static LPDWFN apiEntry = NULL;
LPDWFN getApiProcR0(char*);

static char strDevNodeRM[128] = NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY;
static char strRmCoreName[] = STR_RM_CORE_NAME;

static CHAR VxdName[32];
#ifdef NV3_HW
static CHAR defaultVxd[] = VXDLDR_NV3_RESMAN_VXD_NAME;
#else
static CHAR defaultVxd[] = VXDLDR_NVX_RESMAN_VXD_NAME;
#endif

#define DEFAULT_DEVICE 0
    
/*----------------------------------------------------------------------------*/
/*
 * nvGetResManAPIEntry - get the API entry point for the resource manager VxD
 */

static PVOID nvGetResManAPIEntry()
{
    ULONG*      pdevinfo = NULL;
    ULONG       size = 32;
    ULONG       hkSW;
    ULONG       cbType;
    ULONG       pos;
    ULONG       status;
    
#ifdef NV3_HW

    //
    // For NV3, don't check registry for RM Core VxD's name. Use the default name.
    //

    // (do string manipulation directly so we don't have to link in the standard str functions)
    pos = 0;
    while ( defaultVxd[pos] ) {
      VxdName[pos] = defaultVxd[pos];
      pos++;
    }
    VxdName[pos] = '\0';

#else

    //
    // For NV4 and up, attempt to get the RM Core VxD's name from the registdry
    //
    status = VMM_RegOpenKey(HKEY_LOCAL_MACHINE, strDevNodeRM, (PVMMHKEY)&hkSW);

    if ( (status == 0) && hkSW ) {
        cbType = REG_BINARY;
        status = VMM_RegQueryValueEx(hkSW, strRmCoreName, NULL, &cbType, &(VxdName[0]), &size);
        VMM_RegCloseKey(hkSW);
    }

    // status = 1; // force use of default VxD name

    if ( status != 0 ) {
        // no registry entry so use default VxD name
        // (do string manipulation directly so we don't have to link in the standard str functions)
        pos = 0;
        while ( defaultVxd[pos] ) {
          VxdName[pos] = defaultVxd[pos];
          pos++;
        }
        VxdName[pos] = '\0';
    }

#endif

    apiEntry = getApiProcR0(VxdName);
    if ( apiEntry == NULL ) {
        // try again with default Vxd name
        apiEntry = getApiProcR0(defaultVxd);
    }

    return(apiEntry);
}

/*----------------------------------------------------------------------------*/
/*
 * callRmAPI - call Resman VxD's API entry point
 */

ULONG callRmAPI(ULONG service, ULONG function, PVOID params)
{

    CLIENT_STRUCT cs;
    CLIENT_STRUCT * pcs = &cs;
    RMUSRAPI_STRUCT rm_struct;
    
    rm_struct.function = service;
    rm_struct.device = DEFAULT_DEVICE;
    cs.CRS.Client_EAX = (ULONG) &rm_struct;
    //cs.CRS.Client_EAX = service;
    

    cs.CRS.Client_EDX = function;
    cs.CRS.Client_EBX = (ULONG)params;
    
    _asm push ebp
    _asm mov  ebp, pcs      ; point ebp to client reg struct 
    
    (*apiEntry)();
    _asm pop  ebp
    
    /* return EAX since resman seems to return most of the "good" stuff there */
    return(cs.CRS.Client_EAX);
}

/*----------------------------------------------------------------------------*/
/*
 * callRmArchAPI - call Resman VxD's API entry point and use the "architecture" 
 *         service
 */

VOID callRmArchAPI(ULONG function, PVOID params)
{

    CLIENT_STRUCT cs;
    CLIENT_STRUCT * pcs = &cs;
    RMUSRAPI_STRUCT rm_struct;
    
    rm_struct.function = NVRM_API_ARCHITECTURE_32;
    rm_struct.device = DEFAULT_DEVICE;
    cs.CRS.Client_EAX = (ULONG) &rm_struct;
    //cs.CRS.Client_EAX = NVRM_API_ARCHITECTURE_32;

    cs.CRS.Client_EDX = function;
    cs.CRS.Client_EBX = (ULONG)params;
    
    _asm push ebp
    _asm mov  ebp, pcs      ; point ebp to client reg struct 
    
    (*apiEntry)();
    _asm pop  ebp
    
    return;
}

/*----------------------------------------------------------------------------*/
/*
 * __GetFlatDataSelector - duplicate of NvGetFlatDataSelector()
 *
 */

static int __GetFlatDataSelector()
{
    DWORD   Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocRoot - allocate root of device tree
 */

ULONG __stdcall NvRmR0AllocRoot (
    ULONG *phClient)
{

    NVOS01_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hClass = NV01_ROOT;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCROOT, (PVOID)(&parms));

    *phClient = (ULONG)parms.hObjectNew;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocDevice - allocate a device
 */

ULONG __stdcall NvRmR0AllocDevice (
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName )
{

    NVOS06_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hObjectParent = hClient;
    parms.hObjectNew    = hDevice;
    parms.hClass        = hClass;
    parms.szName        = (NvV32)szName;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCDEVICE, (PVOID)(&parms));

    return(parms.status);

}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocChannelPio - allocate a PIO channel
 */

ULONG __stdcall NvRmR0AllocChannelPio (
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags )
{

    NVOS04_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.flags         = flags;
  
    callRmArchAPI(NVRM_ARCH_NV01ALLOCCHANNELPIO, (PVOID)(&parms));

    *ppChannel = (PVOID)parms.pChannel.offset;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocChannelDMA - allocate a DMA channel
 */

ULONG __stdcall NvRmR0AllocChannelDma(
    ULONG hClient, 
    ULONG hDevice, 
    ULONG hChannel, 
    ULONG hClass, 
    ULONG hErrorCtx, 
    ULONG hDataCtx, 
    ULONG offset, 
    PVOID *ppChannel)
{

    NVOS07_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.hObjectBuffer = hDataCtx;
    parms.offset        = offset;

    callRmArchAPI(NVRM_ARCH_NV03ALLOCCHANNELDMA, (PVOID)(&parms));

    *ppChannel = (PVOID)parms.pControl.offset;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocContextDma - get a context DMA
 */

ULONG __stdcall NvRmR0AllocContextDma(
    ULONG hClient, 
    ULONG hDma, 
    ULONG hClass, 
    ULONG flags, 
    PVOID base, 
    ULONG limit)
{

    NVOS03_PARAMETERS   parms;

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */

    parms.hObjectParent  = hClient;
    parms.hObjectNew     = hDma;
    parms.hClass         = hClass;
    parms.flags          = flags;
    parms.pBase.selector = __GetFlatDataSelector();
    parms.pBase.offset   = (DWORD)base;
    parms.limit.low      = limit;
  
    callRmArchAPI(NVRM_ARCH_NV01ALLOCCONTEXTDMA, (PVOID)(&parms));

    return(parms.status);

}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocMemory - Allocate a chunk of memory using the RM
 */

ULONG __stdcall NvRmR0AllocMemory
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hMemory, 
    ULONG hClass, 
    ULONG flags, 
    PVOID *ppAddress, 
    ULONG *pLimit
)
{
    
    NVOS02_PARAMETERS parms;

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */

    parms.hRoot             = hClient;
    parms.hObjectParent     = hParent;
    parms.hObjectNew        = hMemory;
    parms.hClass            = hClass;
    parms.flags             = flags;
    parms.pMemory.selector  = __GetFlatDataSelector();
    parms.pMemory.offset    = (NvU32)(*ppAddress);
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = *pLimit;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCMEMORY, (PVOID)(&parms));

    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit    = (ULONG)parms.pLimit.low;

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocObject - Allocate a "thing" allocated using RM
 */


ULONG __stdcall NvRmR0AllocObject
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */
    parms.hRoot             = hClient;
    parms.hObjectParent     = hChannel;
    parms.hObjectNew        = hObject;
    parms.hClass            = hClass;
    
    callRmArchAPI(NVRM_ARCH_NV01ALLOCOBJECT, (PVOID)(&parms));

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0Alloc - allocate arbitrary objects
 */

ULONG __stdcall NvRmR0Alloc
(
    ULONG hClient, 
    ULONG hChannel,
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;

    // set input parameters
    parms.hRoot                 = hClient;
    parms.hObjectParent         = hChannel;
    parms.hObjectNew            = hObject;
    parms.hClass                = hClass;
    parms.pAllocParms.selector  = __GetFlatDataSelector();
    parms.pAllocParms.offset    = (NvU32)pAllocParms;

    callRmArchAPI(NVRM_ARCH_NV04ALLOC, (PVOID)(&parms));

    return parms.status;
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0Free - free a "thing" allocated using RM
 */

ULONG __stdcall NvRmR0Free (
    ULONG   hClient,
    ULONG   hParent,
    ULONG   hObject)
{

    NVOS00_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters for the root
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.hObjectOld    = hObject;

    callRmArchAPI(NVRM_ARCH_NV01FREE, (PVOID)(&parms));

    return(parms.status);

}

/*
 * NvRmR0Interrupt - force interrupt handling.
 */

ULONG __stdcall NvRmR0Interrupt (
    ULONG   hClient,
    ULONG   hDevice)
{

    NVOS09_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters.
     */

    parms.hClient  = hClient;
    parms.hDevice  = hDevice;

    callRmArchAPI(NVRM_ARCH_NV01INTERRUPT, (PVOID)(&parms));

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocEvent - Allocate an NV Event
 */


ULONG __stdcall NvRmR0AllocEvent
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    PVOID data
)
{
    NVOS10_PARAMETERS parms;

    parms.hRoot         = hClient;
    parms.hObjectParent = hObjectParent;
    parms.hObjectNew    = hObjectNew;
    parms.hClass        = hClass;
    parms.index         = index;
    parms.hEvent.low    = (ULONG)data;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCEVENT, (PVOID)(&parms));

    return(parms.status);
}

#ifndef NV3_HW

ULONG  __stdcall NvRmR0I2CAccess
(
    ULONG hClient, 
    ULONG hDevice, 
    VOID  *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS    parms;

    parms.hClient = hClient;
    parms.hDevice = hDevice;
    parms.paramStructPtr = (ULONG)paramStructPtr;

    callRmArchAPI(NVRM_ARCH_I2C_ACCESS, (PVOID)(&parms));

    return(parms.status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\sgroup.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************************************************************
*
*   File: sgroup.c
*
*   Description:
*       This file contains the core implementation of the SWAP GROUP and
*   SWAP BARRIER extensions for SGI.
*
******************************************************************************/

#include <nvrm.h>
#include <os.h>
#include <nvos.h>
#include <nvhw.h>

#define SWAP_MAX_CHANNELS    32
#define SWAP_MAX_GROUPS       5
#define SWAP_INVALID_CHANNEL -1
#define SWAP_INVALID_DEVICE  -1

#define SWAP_MASK(chid)                  (1<<(chid))
#define SWAP_MASK_ADD_CHANNEL(sg,chid)    \
                              ((sg)->channel_mask |= SWAP_MASK(chid))
#define SWAP_MASK_REMOVE_CHANNEL(sg,chid) \
    ((sg)->channel_mask &= ~SWAP_MASK(chid));\
    ((sg)->ready_mask  &= ~SWAP_MASK(chid))
#define SWAP_MASK_CHANNEL_READY(sg,chid)  ((sg)->ready_mask |= SWAP_MASK(chid))
#define SWAP_MASK_SWAP_READY(sg)         ((sg)->ready_mask == (sg)->channel_mask)

static VOID RmSwapCallback(VOID *);
RM_STATUS RmSwapAddGroup(PHWINFO, U032, U032, U032, U032);
RM_STATUS RmSwapAddBarrier(PHWINFO, U032, U032);
RM_STATUS RmSwapRemoveGroup(PHWINFO, U032, U032, U032, U032);
RM_STATUS RmSwapRemoveBarrier(PHWINFO, U032);


/*******
 * Helper Functions
 *******/

static U032
GetChID(
    U032 hClient,
    U032 hDevice,
    U032 hChannel
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i, j;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: looking for chid:"); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       client 0x%x", hClient); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       channel 0x%x", hChannel);


    if (CliSetClientContext(hClient) == FALSE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no client, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no device, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    for (i = 0; i < NUM_DEVICES; i++)
    {       
        if (deviceList[i].InUse && (deviceList[i].Handle == hDevice) && deviceList[i].DevFifoList)
        {
            for (j = 0; j < MAX_FIFOS; j++)
            {
                if (deviceList[i].DevFifoList[j].Handle == hChannel)
                {
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, 
                        "NVRM: returning ", deviceList[i].DevFifoList[j].ChID);
                    return deviceList[i].DevFifoList[j].ChID;
                }
            }
        }
    }
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no chid, returning -1\n");
    return (U032) SWAP_INVALID_CHANNEL;
}

static U032
GetDevID(PHWINFO pDev)
{
    U032 i;

    for (i = 0; i < MAX_INSTANCE; i++)
        if (pDev == NvDBPtr_Table[i])
            return i;

    return SWAP_INVALID_DEVICE;
}

static PHWINFO
GetPDev(U032 DevID)
{
    if (DevID >= MAX_INSTANCE)
        return NULL;
    return NvDBPtr_Table[DevID];
}

static U032
GetClientDevID(U032 hClient, U032 hDevice)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i;

    if (CliSetClientContext(hClient) == FALSE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no client, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no device, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    for (i = 0; i < NUM_DEVICES; i++)
    {       
        if (deviceList[i].InUse && (deviceList[i].Handle == hDevice))
            return deviceList[i].DevID;
    }

    return SWAP_INVALID_DEVICE; 
}

static U032
GetErrorDmaContext(
    U032 hClient,
    U032 hDevice,
    U032 hChannel
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i, j;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: looking for chid:"); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       client 0x%x", hClient); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       channel 0x%x", hChannel);


    if (CliSetClientContext(hClient) == FALSE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no client, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no device, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    for (i = 0; i < NUM_DEVICES; i++)
    {       
        if (deviceList[i].InUse && (deviceList[i].Handle == hDevice) && deviceList[i].DevFifoList)
        {
            for (j = 0; j < MAX_FIFOS; j++)
            {
                if (deviceList[i].DevFifoList[j].Handle == hChannel)
                {
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, 
                        "NVRM: returning ", deviceList[i].DevFifoList[j].ErrorDmaContext);
                    return deviceList[i].DevFifoList[j].ErrorDmaContext;
                }
            }
        }
    }
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no chid, returning -1\n");
    return (U032) SWAP_INVALID_CHANNEL;
}


/*
 * All swap clients are sorted by device.
 * A database of devices is shared among swap groups. A swap group has a 
 * linked list of device pointers that point to the devices in that group.
 *
 * Since a device can have channels in multiple swap groups, the device
 * pointer contains masks specificing which channels belong to that 
 * particular swap group.
 *
 * A channel can only belong to one swap group at a time, so the group id
 * of the bound group is stored in the channel structure.
 *
 */

struct swap_channel_entry_t {
    U032 valid;
    U032 GroupID;
    U032 hClient;
    U032 hErrorDma;   /* to write notifier */
    PDMAOBJECT pDma;
    U032 Put;
};

struct swap_device_entry_t {
    void *pDev;
    struct swap_channel_entry_t channels[SWAP_MAX_CHANNELS];
};

struct dev_ptr_t {
    U032 DevID;
    struct swap_device_entry_t *dev;
    U032 num_channels;
    U032 channel_mask;              /* mask of channels in this group */
    U032 ready_mask;                /* mask of channels ready to swap */
    struct dev_ptr_t *next;
};

struct swap_group_entry_t {
    U032 valid;
    U032 GroupID;
    U032 BarrierID;
    struct dev_ptr_t *devices;
};

// databases
static struct swap_group_entry_t swap_group_db[SWAP_MAX_GROUPS] = {};

// array of pointers to active devices..
static struct swap_device_entry_t *swap_device_db[MAX_INSTANCE] = {};


/********
 * Swap Database Functions
 ********/

static int
dbChannelValidClient(U032 hClient, U032 DevID, U032 ChID)
{
    if (swap_device_db[DevID] == NULL)
        return 0;

    if (swap_device_db[DevID]->channels[ChID].valid &&
        swap_device_db[DevID]->channels[ChID].hClient == hClient)
    {
        return 1;
    }
    return 0;
}

static struct swap_channel_entry_t *
dbChannelFind(U032 DevID, U032 ChID)
{
    // make sure the device is valid
    if (swap_device_db[DevID] == NULL)
        return NULL;

    // make sure the channel was allocated
    if (!swap_device_db[DevID]->channels[ChID].valid)
    {
        return NULL;
    }

    // return the channel
    return (&swap_device_db[DevID]->channels[ChID]);
}

static struct swap_channel_entry_t *
dbChannelAlloc(U032 DevID, U032 ChID)
{
    // we allocate devices as needed to save space..
    if (swap_device_db[DevID] == NULL)
    {
        if (RM_OK != osAllocMem( (void **) &swap_device_db[DevID], 
            sizeof(struct swap_device_entry_t)))
        {
            return NULL;
        }

        // zero the structure out
        osMemSet(swap_device_db[DevID], 0, 
            sizeof(struct swap_device_entry_t));

        // set the device number
        swap_device_db[DevID]->pDev = GetPDev(DevID);
    }

    // make sure this channel isn't already allocated
    if (swap_device_db[DevID]->channels[ChID].valid)
    {
        return NULL;
    }

    // return the channel
    return (&swap_device_db[DevID]->channels[ChID]);
}
    

static VOID
dbChannelFree(U032 DevID, U032 ChID)
{
    // make sure the device is valid
    if (swap_device_db[DevID] == NULL)
        return;

    // make sure the channel was allocated
    if (!swap_device_db[DevID]->channels[ChID].valid)
        return;

    osMemSet(&(swap_device_db[DevID]->channels[ChID]), 0, 
        sizeof(struct swap_channel_entry_t));
}

static struct swap_group_entry_t *
dbGroupFind(U032 GroupID)
{
    U032 i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        if (swap_group_db[i].valid && 
            swap_group_db[i].GroupID == GroupID)
            return (&swap_group_db[i]);
    }
    return NULL;
}

static struct swap_group_entry_t *
dbGroupAlloc(U032 GroupID)
{
    U032 i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        if (!swap_group_db[i].valid)
            return (&swap_group_db[i]);
    }
    return NULL;
}
    

static VOID
dbGroupFree(U032 GroupID)
{
    U032 i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        if (swap_group_db[i].valid && 
            swap_group_db[i].GroupID == GroupID)
        {
            osMemSet(&swap_group_db[i], 0, 
                sizeof(struct swap_group_entry_t));
        }
    }
    return;
}


static struct swap_group_entry_t *
dbGroupFindBarrier(U032 BarrierID)
{
    int i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        // use pDev to make sure the group is valid.. can BarrierID be '0'?
        if (swap_group_db[i].valid && swap_group_db[i].BarrierID == BarrierID)
        {
            return &swap_group_db[i];
        }
    }
    return NULL;
}

/********
 * Swap Group Member Functions
 ********/

static VOID sgRemoveBarrier(struct swap_group_entry_t *sg);

static struct dev_ptr_t *
sgAllocDevPtr(struct swap_group_entry_t *sg, U032 DevID)
{
    struct dev_ptr_t *tmp, *newdev;

    if (RM_OK != osAllocMem( (void **) &newdev, sizeof(struct dev_ptr_t)))
        return NULL;

    // zero the new structure out
    osMemSet(newdev, 0, sizeof(struct dev_ptr_t));

    if ( (sg->devices == NULL) || (sg->devices[0].DevID > DevID))
    {
        // new head device
        newdev->next = sg->devices;
        sg->devices = newdev;
    } else {
        // look for either the end of the list or a larger devID
        tmp = sg->devices;
        while ( (tmp) && (tmp->next) && (tmp->next->DevID > DevID))
            tmp = tmp->next;

        newdev->next = tmp->next;
        tmp->next = newdev;
    }

    newdev->dev          = swap_device_db[DevID];
    newdev->DevID        = DevID;
    newdev->channel_mask = 0;
    newdev->ready_mask   = 0;
    newdev->num_channels = 0;

    return newdev;
}

static void
sgFreeDevPtr(struct swap_group_entry_t *sg, U032 DevID)
{
    struct dev_ptr_t *tmp, *prev;

    if (sg->devices == NULL)
        return;

    prev = tmp = sg->devices;
    while (tmp && tmp->DevID != DevID)
    {
        prev = tmp;
        tmp = tmp->next;
    }

    if (prev == tmp)
        sg->devices = tmp->next;
    else
        prev->next = tmp->next;

    osFreeMem(tmp);

    return;
}

static struct dev_ptr_t *
sgFindDevPtr(struct swap_group_entry_t *sg, U032 DevID)
{
    struct dev_ptr_t *tmp = sg->devices;

    while ( (tmp) && (tmp->DevID != DevID) )
        tmp = tmp->next;

    return tmp;
}

static VOID
sgInit(struct swap_group_entry_t *sg, PHWINFO pDev, U032 GroupID)
{
    sg->GroupID = GroupID;
    sg->BarrierID    = 0;
    sg->devices      = NULL;
    sg->valid = 1;
}

static RM_STATUS
sgAddChannel(struct swap_group_entry_t *sg, U032 DevID, U032 ChID)
{
    struct dev_ptr_t *devptr;

    nv_printf("Adding channel %d:%d to group %d\n", 
        DevID, ChID, sg->GroupID);

    devptr = sgFindDevPtr(sg, DevID);
    if (devptr == NULL)
    {
        devptr = sgAllocDevPtr(sg, DevID);
        if (devptr == NULL)
            return RM_ERROR;
    }

    if (!devptr->dev->channels[ChID].valid)
    {
        return RM_ERROR;
    }

    SWAP_MASK_ADD_CHANNEL(devptr, ChID);
    devptr->num_channels++;

    return RM_OK;
}

static VOID
sgSwapIfReady(struct swap_group_entry_t *sg)
{
    struct dev_ptr_t *tmp;

    // nothing to swap
    if (sg->devices == NULL)
    {
        return;
    }


    // if any device isn't ready, bail out
    tmp = sg->devices;
    while (tmp)
    {
        if (!SWAP_MASK_SWAP_READY(tmp))
        {
            return;
        }
        tmp = tmp->next;
    }

    // if this is part of a barrier, call the barrier function
    // to handle things, otherwise call the swap function to 
    // write everything
    if (sg->BarrierID)
        osSwapBarrier(sg->BarrierID, RmSwapCallback, (VOID*) sg);
    else
        RmSwapCallback((VOID*) sg);
}

static RM_STATUS
sgRemoveChannel(struct swap_group_entry_t *sg, U032 DevID, U032 ChID)
{
    struct dev_ptr_t *devptr;

    nv_printf("Removing channel %d:%d from group %d\n", 
        DevID, ChID, sg->GroupID);

    devptr = sgFindDevPtr(sg, DevID);
    if (devptr == NULL)
    {
        return RM_ERROR;
    }

    // remove channel from masks, and see if we're ready to swap now
    SWAP_MASK_REMOVE_CHANNEL(devptr, ChID);
    devptr->num_channels--;

    if (devptr->num_channels <= 0)
        sgFreeDevPtr(sg, DevID);

    if (sg->devices == 0)
    {
        if (sg->BarrierID)
            sgRemoveBarrier(sg);
        dbGroupFree(sg->GroupID);
        return RM_OK;
    }

    sgSwapIfReady(sg);

    return RM_OK;
}

static VOID
sgChannelReady(struct swap_group_entry_t *sg, U032 DevID, U032 ChID)
{
    struct dev_ptr_t *tmp;

    nv_printf("marking channel %d:%d as ready\n", DevID, ChID);

    if ((tmp = sgFindDevPtr(sg, DevID)) == NULL)
        return;

    SWAP_MASK_CHANNEL_READY(tmp, ChID);
    sgSwapIfReady(sg);
}

static VOID
sgAddBarrier(struct swap_group_entry_t *sg, U032 BarrierID)
{
    sg->BarrierID = BarrierID;
    osInitSwapBarrier(BarrierID);
}

static VOID
sgRemoveBarrier(struct swap_group_entry_t *sg)
{
    osRemoveSwapBarrier(sg->BarrierID);
    sg->BarrierID = 0;
}

/********
 * Swap Channel Member Functions
 ********/

static VOID
scInit(struct swap_channel_entry_t *sc, 
       U032 hClient, 
       U032 hDevice, 
       U032 hChannel, 
       U032 GroupID
)
{
    sc->hClient   = hClient;
    sc->Put       = 0;
    sc->valid     = 1;
    sc->GroupID   = GroupID;
    sc->hErrorDma = GetErrorDmaContext(hClient, hDevice, hChannel);
    sc->pDma      = NULL;
}

static VOID
scPrepareForSwap(struct swap_channel_entry_t *sc, PHWINFO pDev, U032 Put)
{
    sc->Put = Put;

    // the dma object may not be valid when we init the channel,
    // but probably is now. Let's track it down to make the swap
    // itself go faster
    dmaFindContext(pDev, sc->hErrorDma, sc->hClient, &sc->pDma);
}


/********
 * Exported RmSwap Functions
 ********/

RM_STATUS
RmSwapInit(
    PHWINFO pDev
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "initializing swap extension\n");
    /* anything else needed? */
    osMemSet(swap_group_db, 0x0, sizeof(struct swap_group_entry_t) * 
        SWAP_MAX_GROUPS);
    osMemSet(swap_device_db, 0x0, sizeof(struct swap_device_entry_t *) * 
        MAX_INSTANCE);

    return RM_OK;
}

/* let 'er rip! */
static VOID
RmSwapCallback(
    VOID *data
)
{
    struct swap_group_entry_t *sg = (struct swap_group_entry_t *) data;
    struct dev_ptr_t *devtmp;
    U032 i, ChID;


    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"RmSwapCallback: 0x%x", data);

    if ((devtmp = sg->devices) == 0)
        return;

#if 0
    // XXX do I even need this??
    /* first, make sure the Pusher can't context switch on us */
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) ==
        NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
        ;
#endif

    while (devtmp)
    {
        PHWINFO pDev = devtmp->dev->pDev;
        U032 DevID = GetDevID(pDev);

        ChID = 0;
        for (i = 0; i < devtmp->num_channels; i++)
        {
            struct swap_channel_entry_t *sc;

            // find the next ChID in the channel mask
            while (!(devtmp->channel_mask & (1<<ChID)))
                ChID++;

            // assume all channels exist for now
            sc = dbChannelFind(DevID, ChID);

            /* write through our mapping to the user's dma put */
            REG_WR32(NV_USER_DMA_PUT(ChID, 0), sc->Put);

            // assume dma object is good, the app will hang otherwise
            notifyFillNotifier(pDev, sc->pDma, 0, 0, RM_OK);

            // increment past the current channel
            ChID++;
        }
        devtmp->ready_mask = 0;
        devtmp = devtmp->next;
    }

#if 0
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "RmSwapCallback: done with swap callback\n");
}


RM_STATUS
RmSwapClient(
    PHWINFO pDev,
    U032    ChID,
    U032    Put
)
{
    struct swap_channel_entry_t *sc = NULL;
    struct swap_group_entry_t  *sg = NULL;
    U032 DevID;

    nv_printf("SwapClient\n");

    if ((DevID = GetDevID(pDev)) == SWAP_INVALID_DEVICE)
    {
        return RM_ERROR;
    }

    sc = dbChannelFind(DevID, ChID);
    if (sc == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, 
            "Attempting to swap non-registered client\n");
        return RM_ERROR;
    }

    sg = dbGroupFind(sc->GroupID);
    if (sg == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,
            "Attempting to swap non-registered group\n");
        return RM_ERROR;
    }

    sc->Put = Put;
    scPrepareForSwap(sc, pDev, Put);

    /* indicate we're ready to go */
    sgChannelReady(sg, DevID, ChID);

    sgSwapIfReady(sg);

    return RM_OK;
}

RM_STATUS
RmSwapAddGroup(
    PHWINFO pDev,
    U032    hClient,
    U032    hDevice,
    U032    hChannel,
    U032    GroupID
)
{
    struct swap_channel_entry_t *sc = NULL;
    struct swap_group_entry_t *sg = NULL;
    U032 ChID, DevID;


    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: SwapAddGroup");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: client 0x%x", hClient);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: channel 0x%x", hChannel);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: group 0x%x", GroupID);

    sg = dbGroupFind(GroupID);

    if (sg == NULL)
    {
        sg = dbGroupAlloc(GroupID);
        if (sg == NULL)
            return RM_ERROR /* SYS RESOURCES */;

        sgInit(sg, pDev, GroupID);
    }

    ChID = GetChID(hClient, hDevice, hChannel);
    if (ChID == SWAP_INVALID_CHANNEL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Couldn't find ChID");
        return RM_ERROR /* INVALID CLIENT? */;
    }

    DevID = GetClientDevID(hClient, hDevice);
    if (DevID == SWAP_INVALID_DEVICE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Couldn't find DevID");
        return RM_ERROR /* INVALID DEVICE? */;
    }

    nv_printf("AddGroup: add channel %d:%d to group %d\n", DevID, ChID, GroupID);

    sc = dbChannelAlloc(DevID, ChID);
    if (sc == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Channel already allocated?");
        return RM_ERROR /* INVALID CLIENT? */;
    }

    /* store client data */
    scInit(sc, hClient, hDevice, hChannel, GroupID);

    /* store group data */
    sgAddChannel(sg, DevID, ChID);

    return RM_OK;
}


RM_STATUS
RmSwapAddBarrier(
    PHWINFO pDev,
    U032    GroupID,
    U032    BarrierID
)
{
    struct swap_group_entry_t *sg = NULL;

    sg = dbGroupFind(GroupID);

    if (sg == NULL)
    {
        return RM_ERROR /* BAD_GROUP */;
    }

    sgAddBarrier(sg, BarrierID);

    return RM_OK;
}


RM_STATUS
RmSwapRemoveGroup(
    PHWINFO pDev,
    U032    hClient,
    U032    hDevice,
    U032    hChannel,
    U032    GroupID
)
{
    struct swap_group_entry_t *sg = NULL;
    U032 ChID, DevID;

    sg = dbGroupFind(GroupID);
    if (sg == NULL)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
            "RemoveSwapGroup: invalid group id 0x%x", GroupID);
        return RM_ERROR /* BAD_GROUP */;
    }

    ChID = GetChID(hClient, hDevice, hChannel);
    if (ChID == SWAP_INVALID_CHANNEL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, 
            "RemoveSwapGroup: invalid group or channel");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
            "    client : 0x%x", hClient);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
            "    channel: 0x%x", hChannel);
        return RM_ERROR /* BAD_GROUP */;
    }

    DevID = GetClientDevID(hClient, hDevice);
    if (ChID == SWAP_INVALID_DEVICE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Couldn't find DevID");
        return RM_ERROR /* INVALID DEVICE? */;
    }

    sgRemoveChannel(sg, DevID, ChID);

    dbChannelFree(DevID, ChID);

    return RM_OK;
}

RM_STATUS
RmSwapRemoveBarrier(
    PHWINFO pDev,
    U032    BarrierID
)
{
    struct swap_group_entry_t *sg = NULL;

    sg = dbGroupFindBarrier(BarrierID);

    if (sg == NULL)
    {
        return RM_ERROR /* BAD_GROUP */;
    }

    sgRemoveBarrier(sg);

    return RM_OK;
}


RM_STATUS
RmSwapExt(
    PHWINFO pDev,
    U032    hClient,
    U032    hDevice,
    U032    hChannel,
    U032    flags,
    U032    group_id,
    U032    barrier_id
)
{
    RM_STATUS rmStatus = RM_ERROR;

    if (DRF_VAL(OS2A, _FLAGS, _SWAP, flags) == NVOS2A_FLAGS_SWAP_GROUP)
    {
        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_ADD)
                rmStatus = RmSwapAddGroup(pDev, hClient, hDevice, hChannel, group_id);
        else

        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_REMOVE)
                rmStatus = RmSwapRemoveGroup(pDev, hClient, hDevice, hChannel, group_id);
    } else

    if (DRF_VAL(OS2A, _FLAGS, _SWAP, flags) == NVOS2A_FLAGS_SWAP_BARRIER)
    {
        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_ADD)
                rmStatus = RmSwapAddBarrier(pDev, group_id, barrier_id);

        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_REMOVE)
                rmStatus = RmSwapRemoveBarrier(pDev, barrier_id);
    } else
    /* unknown swap extension */
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: unknown Swap Extension\n");

    return rmStatus;
}

RM_STATUS
RmSwapClientGone(
    U032    hClient
)
{
    U032 DevID, ChID;

    for (DevID = 0; DevID < MAX_INSTANCE; DevID++)
    {
        for (ChID = 0; ChID < SWAP_MAX_CHANNELS; ChID++)
        {
            if (dbChannelValidClient(hClient, DevID, ChID))
            {
                struct swap_channel_entry_t *sc;
                struct swap_group_entry_t *sg;

                sc = dbChannelFind(DevID, ChID);
                if (sc == NULL)
                    return RM_ERROR;

                sg = dbGroupFind(sc->GroupID);
                if (sg == NULL)
                    return RM_ERROR;

                sgRemoveChannel(sg, DevID, ChID);

                dbChannelFree(DevID, ChID);
            }
        }
    }
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll16\nvarch16.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVARCH.C                                                          *
*         This is the 16bit DLL interface to the RM for the new architecture*
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito (jvito)    03/04/98 - wrote it.                            *
\***************************************************************************/
#include <windows.h>
#include "nv_ref.h"
#include "nvrm.h"
#include "nvrmwin.h"
#include "nvcm.h"
#include <class.h>
#include <vblank.h>
#include <gr.h>
#include <vga.h>
#include "nvsys.h"

extern  void CallRM_DeviceSetup(LPRMPARAMS lprmParams);

#define NVRM_DLL16_NV01FREE            NVRM_ARCH_NV01FREE            
#define NVRM_DLL16_NV01ALLOCROOT       NVRM_ARCH_NV01ALLOCROOT       
#define NVRM_DLL16_NV01ALLOCMEMORY     NVRM_ARCH_NV01ALLOCMEMORY     
#define NVRM_DLL16_NV01ALLOCCONTEXTDMA NVRM_ARCH_NV01ALLOCCONTEXTDMA 
#define NVRM_DLL16_NV01ALLOCCHANNELPIO NVRM_ARCH_NV01ALLOCCHANNELPIO 
#define NVRM_DLL16_NV01ALLOCOBJECT     NVRM_ARCH_NV01ALLOCOBJECT     
#define NVRM_DLL16_NV01ALLOCDEVICE     NVRM_ARCH_NV01ALLOCDEVICE     
#define NVRM_DLL16_NV03ALLOCCHANNELDMA NVRM_ARCH_NV03ALLOCCHANNELDMA 
#define NVRM_DLL16_NV03DMAFLOWCONTROL  NVRM_ARCH_NV03DMAFLOWCONTROL  
#define NVRM_DLL16_NV01INTERRUPT       NVRM_ARCH_NV01INTERRUPT       
#define NVRM_DLL16_NV01ALLOCEVENT      NVRM_ARCH_NV01ALLOCEVENT      
#define NVRM_DLL16_NVI2CACCESS         NVRM_ARCH_I2C_ACCESS      
#define NVRM_DLL16_NV04CONFIGGETEX     NVRM_ARCH_CONFIG_GET_EX       
#define NVRM_DLL16_NV04CONFIGSETEX     NVRM_ARCH_CONFIG_SET_EX       
#define NVRM_DLL16_NV04ALLOC           NVRM_ARCH_NV04ALLOC

#define NVRM_ARCHITECTURE_API          NVRM_API_ARCHITECTURE_16
#define NVOPEN_STATUS_SUCCESS          0
#define NVCLOSE_STATUS_SUCCESS         0

extern U032 FAR * lp16bitProcessDS;

VOID FAR PASCAL NvIoControl
(
  U032 Function,
  VOID FAR *pParameters
)
{
  WORD seg_,off_;
  DWORD seg_base,parameters_flat_offset;
  RMPARAMS rmParams;

  _asm push es
  _asm push di

  _asm les  di,pParameters
  _asm mov  seg_,es
  _asm mov  off_,di

  _asm pop  di
  _asm pop  es

  seg_base = GetSelectorBase((UINT) seg_);
  parameters_flat_offset = seg_base+((DWORD) off_);

  //
  // Call the resource manager and have all of the work done over there.
  // If needed this can send a pointer to an interface structure instead. I think we will run out of registers
  // otherwise. 
  rmParams.RegEAX = NVRM_ARCHITECTURE_API;
  rmParams.RegEBX = parameters_flat_offset;
  rmParams.RegEDX = Function;
  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
  rmParams.RegES  = 0;
  CallRM_DeviceSetup(&rmParams);
}   


VOID FAR PASCAL Arch_NvOpen(U032 *status)                   
{
  *status = NVOPEN_STATUS_SUCCESS;
}

VOID FAR PASCAL Arch_NvClose(U032 *status)                  
{
  *status = NVCLOSE_STATUS_SUCCESS;
}

VOID FAR PASCAL Arch_Nv01Free(VOID FAR *pParameters)            
{
  NvIoControl(NVRM_DLL16_NV01FREE,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocRoot(VOID FAR *pParameters)       
{
  NvIoControl(NVRM_DLL16_NV01ALLOCROOT,pParameters);
}

VOID FAR PASCAL Arch_Nv04Alloc(VOID FAR *pParameters)       
{
  NvIoControl(NVRM_DLL16_NV04ALLOC,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocMemory(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV01ALLOCMEMORY,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocContextDma(VOID FAR *pParameters) 
{
  NvIoControl(NVRM_DLL16_NV01ALLOCCONTEXTDMA,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocChannelPio(VOID FAR *pParameters) 
{
  NvIoControl(NVRM_DLL16_NV01ALLOCCHANNELPIO,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocObject(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV01ALLOCOBJECT,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocDevice(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV01ALLOCDEVICE,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocChannelDma(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV03ALLOCCHANNELDMA,pParameters);
}
VOID FAR PASCAL Arch_Nv03DmaFlowControl(VOID FAR *pParameters)
{
  NvIoControl(NVRM_DLL16_NV03DMAFLOWCONTROL,pParameters);
}
VOID FAR PASCAL Arch_Nv01Interrupt(VOID FAR *pParameters)       
{
  NvIoControl(NVRM_DLL16_NV01INTERRUPT,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocEvent(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NV01ALLOCEVENT,pParameters);
}

VOID FAR PASCAL Arch_NvI2CAccess(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NVI2CACCESS,pParameters);
}

VOID FAR PASCAL Arch_Nv04ConfigGetEx(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NV04CONFIGGETEX,pParameters);
}

VOID FAR PASCAL Arch_Nv04ConfigSetEx(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NV04CONFIGSETEX,pParameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvRmApiUnix.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1999 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvRmApiUnix.c
 *
 *   based on NT/Win9x version of nvRmApi.c
 *
 * NVidia resource manager API.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * This file is linked into programs that talk to the Resource Manager.
 * It does the 'trampoline' as necessary to get to into resman proper.
 */

#if !defined(XFree86LOADER)
#include <sys/mman.h>

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <unistd.h>
#include <stdio.h>
#include <errno.h>

#include <string.h>
#include <stdlib.h>             /* malloc */
#else
# include <xf86_ansic.h>
# include <asm/ioctl.h>
# ifndef off_t
#  define off_t       xf86size_t
# endif
#endif /* XFree86LOADER */

#include <stdint.h>

#include <nv.h>

#include <nvos.h>
#include <nvrm.h>
#include <nv32.h>

#include <nvrmint.h>
#include <nvEscDef.h>
#include <nvmisc.h>
#include <nvcm.h>

typedef struct nv_allocated_mmap_s {
    void *address;
    int   length;
    unsigned int handle;
    struct nv_allocated_mmap_s *next;
} nv_allocated_mmap_t;

/*
 * track the memory mappings visible by the *current application*
 * so that we can just do pointer arithmetic to get valid mappings
 * instead of having the kernel do it.
 *
 * There is one of these per open device in *this application.
 */

typedef struct
{

    ULONG  client;
    ULONG  device_id;
    int    fd;
    int    agpfd;

    ULONG  reg_phys_base;
    ULONG  reg_length;           // size in bytes

    ULONG  fb_phys_base;
    void  *fb;
    ULONG  fb_length;            // size in bytes

    nv_allocated_mmap_t *mmap_list;    // mmap'd memory to free

    char   path[128];            // pathname for device

	int    agp_enabled;          // indicates AGP is enabled one way or another
    
} nv_mapping_t;

nv_mapping_t  nv_mappings[NV_MAX_DEVICES];

nv_ioctl_card_info_t nv_cards[NV_MAX_DEVICES];


/*
 * file descriptor for the NV control device so we can talk to the
 *   driver before picking a board
 */

int ctl_fd = -1;


/*
 * Initialize the mappings and open the control device
 */
static int init_api_layer(void)
{
    nv_mapping_t *nm;
    char *path = "/dev/nvidiactl";
    int rc;
    
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
    {
        (void) memset(nm, 0, sizeof(nv_mapping_t));
        nm->fd = -1;
    }

    ctl_fd = open(path, O_RDWR);
    if (ctl_fd < 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not open control device %s (%s)\n",
                path,
                strerror(errno));
#endif
        return 0;
    }

    // pull in the card info from the driver
    rc = ioctl(ctl_fd, NV_IOCTL_CARD_INFO, (void *) nv_cards);
    if (rc < 0)
    {
#ifdef DEBUG
        fprintf(stderr, "NV: could not get NV card info (%s)\n",
                strerror(errno));
#endif
        return 0;
    }

    return 1;
}             

/*
 * remember a memory range so that it can be freed when we free the client
 */

static nv_allocated_mmap_t *remember_mmap_memory(
    nv_mapping_t *nm,
    void    *address,
    int      length,
    unsigned int handle
)
{
    nv_allocated_mmap_t *mm;

    mm = malloc(sizeof(nv_allocated_mmap_t));
    if (mm == (void *) 0)
        return (void *) 0;

    mm->address = address;
    mm->length = length;
    mm->next = nm->mmap_list;
    mm->handle = handle;
    nm->mmap_list = mm;        
    
    return mm;
}

static void *mmap_memory(
    nv_mapping_t *nm,
    int           length,
    off_t         offset,
    unsigned int  handle
)
{
    void *ptr;

    ptr = mmap((void *) 0, length, PROT_WRITE | PROT_READ,
               MAP_SHARED, nm->fd, offset);
    if (ptr != MAP_FAILED)
        return remember_mmap_memory(nm, ptr, length, handle);

    return (void *) 0;
}

static void munmap_memory(
    nv_allocated_mmap_t *mm
)
{
    if (mm->address)
    {
        munmap(mm->address, mm->length);
        mm->address = 0;
        mm->length = ~0;
    }
}

static nv_allocated_mmap_t *find_mmap_by_handle(
    nv_mapping_t *nm,
    unsigned int handle
)
{
    nv_allocated_mmap_t *tmp = nm->mmap_list;

    while (tmp)
    {
        if (tmp->handle == handle)
             break;
        tmp = tmp->next;
    }
    return tmp;
}

static void free_all_mmap_memory(
    nv_mapping_t *nm
)
{
    nv_allocated_mmap_t *mm;
    nv_allocated_mmap_t *next;

    for (mm = nm->mmap_list; mm; )
    {
        (void) munmap_memory(mm);
        next = mm->next;
        free(mm);
        mm = next;
    }    
}
   
static nv_mapping_t *find_mapping(
    ULONG client,
    ULONG device_id
)
{
    nv_mapping_t *nm;
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
        if (nm->client == client)
            if ((device_id == 0) || (nm->device_id == device_id))
                return nm;
    return (nv_mapping_t *) 0;
}

static nv_mapping_t *find_empty_mapping(void)
{
    nv_mapping_t *nm;
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
        if (nm->client == 0)
            return nm;
    return (nv_mapping_t *) 0;
}

static void clear_old_mapping(nv_mapping_t *nm)
{
    if (!nm) return;

    free_all_mmap_memory(nm);
    (void) memset(nm, 0, sizeof(nv_mapping_t));
}

static int fixup_fb_address(
    nv_mapping_t *nm,
    void        **ppAddress,
    ULONG         offset,
    ULONG         length
)
{
    offset -= nm->fb_phys_base;
    if ((offset + length) > nm->fb_length)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: bad offset/length into frame buffer: 0x%lx 0x%lx\n", 
                offset, length);
#endif
        return 1;
    }
    *ppAddress = nm->fb + offset;
    return 0;
}

static int fixup_reg_address(
    nv_mapping_t *nm,
    void        **ppAddress,
    off_t         offset,
    ULONG         length
)
{
    nv_allocated_mmap_t *mm;

    if ((offset + length) > nm->reg_length)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: bad offset/length into register area: 0x%lx 0x%lx\n", 
                offset, length);
#endif
        return 1;
    }

    mm = mmap_memory(nm, length, NV_MMAP_REG_OFFSET + offset, 0x0);
    if (mm == (void *) 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not map register space on %s at 0x%lx for 0x%lx "
                "bytes (%s)\n",
                nm->path,
                offset,
                length,
                strerror(errno));
#endif
        return 1;
    }

    *ppAddress = mm->address;

    return 0;
}
    
static int open_actual_device(
    nv_mapping_t *nm,
    char         *pathname,
    int           device_number
)
{
    /* build up the path name */
    if (pathname)
        strcpy(nm->path, pathname);
    else
    {
        strcpy(nm->path, "/dev/nvidia#");
        nm->path[strlen(nm->path) - 1] = '0' + device_number;
    }
    
    nm->fd = open(nm->path, O_RDWR);
    if (nm->fd < 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not open device %s (%s)\n",
                nm->path,
                strerror(errno));
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    return 0;
}

static int close_actual_device(
    nv_mapping_t *nm
)
{
    (void) close(nm->fd);
    return 0;
}

static int map_actual_device(
    nv_mapping_t *nm
)
{
    nv_allocated_mmap_t *mm;
    nv_ioctl_memory_vtop_t vtop;
    int ret;

    nm->reg_length = 16 * 1024 * 1024;

    // XXX should map size, not hardwired
    nm->fb_length = 64 * 1024 * 1024;
    mm = mmap_memory(nm, nm->fb_length, NV_MMAP_FB_OFFSET, 0x0);
    if (mm == (void *) 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not map frame buffer on %s (%s)\n",
                nm->path,
                strerror(errno));
        fprintf(stderr,
                "    hint: this may be due to ulimit limiting the amount of virtual memory available to XFree86. Please check your start-up scripts for something like 'ulimit -v <number>' and either boost this value or remove the line.");
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    nm->fb = mm->address;
    nm->reg_phys_base = 0;

    /* what is physical address of fb? */
    nm->fb_phys_base = 0;
    vtop.buffer = nm->fb;
    vtop.byte_length = 1;	/* will be rounded up to 1 page */
    vtop.physical_addresses = (unsigned int *) &nm->fb_phys_base;
    ret = ioctl(nm->fd, NV_IOCTL_MEMORY_VTOP, (void *) &vtop);
    if ((ret < 0) || (nm->fb_phys_base == 0))
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not get physical address of frame buffer on %s "
                "(%s)\n",
                nm->path,
                strerror(errno));
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    return 0;
}
    
static inline int doEscape(
    int fd,
    int cmd,
    void * parms)
{
    return (ioctl(fd, _IOWR(NV_IOCTL_MAGIC, cmd, sizeof(void *)), parms) >= 0) ? 1 : -1;
}


/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRoot(
    ULONG *phClient
)
{
    int   ret;
    NVOS01_PARAMETERS Parms;
    static int firstcall = 1;

    if (firstcall)
        if ( ! init_api_layer())
            return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;
    firstcall = 0;

    *phClient = 0;

    Parms.hClass = NV01_ROOT;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_ROOT, (void *) &Parms);
    if (ret <= 0)
        return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;

    *phClient = (ULONG)Parms.hObjectNew;

    return Parms.status;
}


/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDevice(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    int   ret;
    NVOS06_PARAMETERS Parms;
    nv_mapping_t *nm;
    char saved_file_name[128];
    char *str;

    strcpy(saved_file_name, "");
    str = saved_file_name;

    if (hClass == NV03_DEVICE_XX)
    {
        nv_ioctl_card_info_t *ci;
	nv_ioctl_primary_card_t pc;
        int bus, slot;
        char *p;
        int i;
	int primary_head = 0;
	int rc;

        strcpy(saved_file_name, (char *) szName);

	// first check if the first character is a "*".
	// If it is, then that's X telling us this is a
	// primary head.
	if (str[0] == '*') {
	    primary_head = 1;
	    str++;
	}

        // check to see if the bus:slot device name requested
        // the X server uses this to request a particular card
        // We convert it here into /dev/nvidia0 form, since the
        // the bus:slot style is not exported to /dev
        if (strchr(str, ':'))
        {
            bus = strtol(str, &p, 0);
            slot = strtol(p+1, (char **) 0, 0);

            for (i=0, ci = nv_cards; i<NV_MAX_DEVICES; i++, ci++)
            {
                if ((ci->flags & NV_IOCTL_CARD_INFO_FLAG_PRESENT) &&
                    (ci->bus == bus) &&
                    (ci->slot == slot))
                {
                    hClass = NV01_DEVICE_0 + i;

		    /* let kernel knw if this is primary */
		    if (primary_head) {
                        pc.index = i;
			rc = ioctl(ctl_fd, NV_IOCTL_PRIMARY_CARD, (void *) &pc);
			if (rc < 0) {
#ifdef DEBUG
			    fprintf(stderr, "NV: could not set primary card "
                                    "(%s)\n", strerror(errno));
#endif
			    return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
			}
		    }
                    break;
                }
            }
        }
    }

    Parms.hObjectParent   = (NvV32) hClient;
    Parms.hObjectNew      = (NvV32) hDevice;
    Parms.hClass          = (NvV32) hClass;
    Parms.szName          = (NvP64) ((uintptr_t)szName); // assume 64-bit compliance in linux

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_DEVICE, (void *) &Parms);
    if (ret <= 0)
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status == NVOS06_STATUS_SUCCESS)
    {
        int devnum = -1;
        char *pathname = 0;


        /*
         * save the client handle in the mapping structure
         */

        nm = find_empty_mapping();
        if (nm == 0)
            return NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES;

        nm->client    = hClient;
        nm->device_id = hDevice;

        /*
         * figure out the device name.
         * API allows it to be specified numerically or by string based
         *  on hClass
         */

        if (hClass == NV03_DEVICE_XX)
            pathname = str;
        else
        {
            devnum = hClass - NV01_DEVICE_0;
            if (devnum < 0 || devnum > 8)    // XXX does resman have #define for num devices?
                return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
        }

        if ((Parms.status = open_actual_device(nm, pathname, devnum)))
            goto done;

        if ((Parms.status = map_actual_device(nm)))
            goto done;
    }

 done:
    return Parms.status;
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDma(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    int   ret;
    NVOS03_PARAMETERS Parms;

    memset(&Parms, 0, sizeof(NVOS03_PARAMETERS));
    Parms.hObjectParent      = (NvV32) hClient;
    Parms.hObjectNew         = (NvV32) hDma;
    Parms.hClass             = (NvV32) hClass;
    Parms.flags              = (NvV32) flags;
    Parms.pBase              = (NvP64) ((uintptr_t)base);
    Parms.limit              = (NvU64) limit;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_CONTEXT_DMA, (void *) &Parms);
    if (ret <= 0)
        return NVOS03_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPio(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  hChannel,
    ULONG  hClass,
    ULONG  hErrorCtx,
    PVOID *ppChannel,
    ULONG  flags
)
{
    int   ret;
    NVOS04_PARAMETERS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS04_STATUS_ERROR_BAD_CLASS;

    memset(&Parms, 0, sizeof(NVOS04_PARAMETERS));
    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hDevice;
    Parms.hObjectNew      = (NvV32) hChannel;
    Parms.hClass          = (NvV32) hClass;
    Parms.hObjectError    = (NvV32) hErrorCtx;
    Parms.flags           = (NvV32) flags;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_CHANNEL_PIO, (void *) &Parms);
    if (ret <= 0)
        return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status != RM_OK)
        return Parms.status;

    // convert the offset returned into a virtual ptr for this app
    if (0 == fixup_reg_address(nm, ppChannel, (off_t) Parms.pChannel, CHANNEL_LENGTH))
        return Parms.status;

    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDma(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  hChannel,
    ULONG  hClass,
    ULONG  hErrorCtx,
    ULONG  hDataCtx,
    ULONG  offset,
    PVOID *ppChannel
)
{
    int   ret;
    NVOS07_PARAMETERS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS07_STATUS_ERROR_BAD_CLASS;

    memset(&Parms, 0, sizeof(NVOS07_PARAMETERS));
    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hDevice;
    Parms.hObjectNew      = (NvV32) hChannel;
    Parms.hClass          = (NvV32) hClass;
    Parms.hObjectError    = (NvV32) hErrorCtx;
    Parms.hObjectBuffer   = (NvV32) hDataCtx;
    Parms.offset          = (NvV32) offset;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_CHANNEL_DMA, (void *) &Parms);
    if (ret <= 0)
        return NVOS07_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status != RM_OK)
        return Parms.status;

    // convert the offset returned into a virtual ptr for this app
    if (0 == fixup_reg_address(nm, ppChannel, (off_t) Parms.pControl, CHANNEL_LENGTH))
        return Parms.status;

    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemory(
    ULONG  hClient,
    ULONG  hParent,
    ULONG  hMemory,
    ULONG  hClass,
    ULONG  flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    int   ret;
    int   status;
    ULONG byte_count = 0;
    nv_mapping_t *nm;
    nv_allocated_mmap_t *mm = (void *) 0;
    NVOS02_PARAMETERS Parms;

#if defined(IA64)
    /* we're only playing with the lower 32 bits of pLimit, which is 64 bits.
     * make sure we zero out the high 32 bits, in case the user passes us an
     * uninitialized memory location.
     */
    {
        U032 *ptr = (U032 *) pLimit;
        ptr[1] = 0x0;
    }
#endif

    // set input parameters
    memset(&Parms, 0, sizeof(NVOS02_PARAMETERS));
    Parms.hRoot                = (NvV32) hClient;
    Parms.hObjectParent        = (NvV32) hParent;
    Parms.hObjectNew           = (NvV32) hMemory;
    Parms.hClass               = (NvV32) hClass;
    Parms.flags                = (NvV32) flags;
    Parms.pMemory              = (NvP64) ((uintptr_t)*ppAddress);
    Parms.pLimit               = (NvU64) *pLimit;

    nm = find_mapping(hClient, hParent);
    if (nm == 0)
        return NVOS02_STATUS_ERROR_BAD_CLASS;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_MEMORY, (void *) &Parms);
    if (ret <= 0)
    {
        status = NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
        goto failed;
    }

    if (Parms.status != RM_OK)
    {
        status = Parms.status;
        goto failed;
    }

    /*
     * On Unix, the only approved way to map memory into user
     *   space is via mmap(2).
     * So here in the glue layer, we actually allocate the memory, and
     *   sneak the pointer into resman to validate and hook into its
     *   data structures.
     */

    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:
        {
            /* if we're AGP, we'll allocate and map from kernel land..
             * otherwise the kernel complaints about pre-existing PTEs
             */
            off_t offset = NV_MMAP_ALLOCATION_OFFSET;

            if (DRF_VAL(OS02, _FLAGS, _LOCATION, flags) == NVOS02_FLAGS_LOCATION_AGP) {
                offset = NV_MMAP_AGP_OFFSET;
            }
            byte_count = *pLimit + 1;

            mm = mmap_memory(nm, byte_count, offset, hMemory);
            if (mm == (void *) 0)
            {
                status = NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
                goto failed;
            }

            break;
        }
        default:
    }

    *pLimit = (NvU64) Parms.pLimit;
        
    switch (hClass)
    {
        /*
         * Frame buffer memory
         *
         * A little different from NV01_MEMORY_SYSTEM, since we don't know where
         * in fbmem we're going to get our memory until afterwards.
         *
         * So the resman just returns an offset to us and we patch it up
         * afterwards.
         */

        case NV01_MEMORY_LOCAL_USER:
        {
            if (fixup_fb_address(nm,
                                 (void **) ppAddress,
                                 (off_t) Parms.pMemory,
                                 *pLimit + 1))
            {
                status = NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                goto failed;
            }
            break;
        }

        // return the pointer in our own space
        case NV01_MEMORY_SYSTEM:
			*ppAddress = mm->address;
            break;

        default:
            *ppAddress = (PVOID)((uintptr_t)Parms.pMemory);
            break;
    }

    return Parms.status;

 failed:
    if (mm && mm->address)
        munmap_memory(mm);

    return status;
}

/* 
 * NvAlloc - allocate any arbitrary object
 */
ULONG NvRmAlloc(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject,
    ULONG hClass,
    PVOID pAllocParms
)
{
    int   ret;
    NVOS21_PARAMETERS Parms;

    // set input parameters
    memset(&Parms, 0, sizeof(NVOS21_PARAMETERS));
    Parms.hRoot                       = (NvV32)hClient;
    Parms.hObjectParent               = (NvV32)hParent;
    Parms.hObjectNew                  = (NvV32)hObject;
    Parms.hClass                      = (NvV32)hClass;
    Parms.pAllocParms                 = (NvP64)((uintptr_t)pAllocParms);

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC, (void *)&Parms);

    if (ret <= 0)
        return NVOS21_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */

ULONG NvRmAllocObject(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    int   ret;
    NVOS05_PARAMETERS Parms;

    // set input parameters
    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hChannel;
    Parms.hObjectNew      = (NvV32) hObject;
    Parms.hClass          = (NvV32) hClass;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_OBJECT, (void *) &Parms);
    if (ret <= 0)
        return NVOS05_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFree(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    int   ret;
    NVOS00_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hParent;
    Parms.hObjectOld      = (NvV32) hObject;

    /* if this is mmapped memory, be sure to munmap it */
    /* not a failure if no nm */
    nm = find_mapping(hClient, hParent);
    if (nm)
    {
        nv_allocated_mmap_t *mm = (void *) 0;
        if ((mm = find_mmap_by_handle(nm, hObject)))
        {
            munmap_memory(mm);
        }
    }

    ret = doEscape(ctl_fd, NV_ESC_RM_FREE, (void *) &Parms);
    if (ret <= 0)
        return NVOS00_STATUS_ERROR_OPERATING_SYSTEM;

    /*
     * if we're freeing up the entire client, then we also need to
     * free the memory and close the device allocated in the glue layer here.
     */

    if ((Parms.status == NVOS00_STATUS_SUCCESS) && (hParent == NV01_NULL_OBJECT))
    {
        nv_mapping_t *nm;
		int i;

        // for each device on this client
        for (nm = &nv_mappings[0], i = 0; i < NV_MAX_DEVICES; nm++, i++)
        {
            if (nm->client == hClient)
            {
                /* free_all_mmap_memory(nm); */
                close_actual_device(nm);
                clear_old_mapping(nm);
            }
        }
    }

    return Parms.status;
}

ULONG NvRmAllocEvent(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    int ret;
    NVOS10_PARAMETERS Parms;

    memset(&Parms, 0, sizeof(NVOS10_PARAMETERS));
    Parms.hRoot               = hClient;
    Parms.hObjectParent       = hObjectParent;
    Parms.hObjectNew          = hObjectNew;
    Parms.hClass              = hClass;
    Parms.index               = index;
    Parms.hEvent              = (NvU64) data;

    // we don't really know which device is doing this call, so just use control fd
    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_EVENT, (void *) &Parms);
    if (ret <= 0)
        return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmArchHeap(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    int   ret;
    NVOS11_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hRoot         = (NvV32) hClient;
    Parms.hObjectParent = (NvV32) hParent;
    Parms.function      = (NvU32) function;
    Parms.owner         = (NvU32) owner;
    Parms.type          = (NvU32) type;
    Parms.pitch         = (NvS32) (pitch ? *pitch : 0);
    Parms.height        = (NvU32) height;
    Parms.size          = (NvU32) size;
    Parms.offset        = (NvU32) *offset;

    nm = find_mapping(hClient, hParent);
    if (nm == 0)
        return NVOS11_STATUS_ERROR_INVALID_OWNER;

    ret = doEscape(nm->fd, NV_ESC_RM_ARCH_HEAP, (void *) &Parms);
    if (ret <= 0)
        return NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;
    if (Parms.status != RM_OK)
        return Parms.status;

    if (pitch)
        *pitch = (ULONG) Parms.pitch;
    *offset  = (ULONG) Parms.offset;
    *address = (ULONG) Parms.address;
    *limit   = (ULONG) Parms.limit;
    *free    = (ULONG) Parms.free;
    *total   = (ULONG) Parms.total;

    //
    // fixup address and limit on successful allocate calls
    //
    if (Parms.status == NVOS11_STATUS_SUCCESS)
    {
        switch (function)
        {
            case NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT:
            case NVOS11_HEAP_ALLOC_SIZE:
            case NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT:
            {
                if (fixup_fb_address(nm,
                                     (void **) address,
                                     *offset + nm->fb_phys_base,
                                     size))
                    return NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;

                break;
            }
        }
    }

    return Parms.status;
}

ULONG NvRmConfigGet(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  index,
    ULONG *pValue
)
{
    int   ret;
    NVOS13_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = (NvV32) hClient;
    Parms.hDevice         = (NvV32) hDevice;
    Parms.index           = (NvV32) index;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS13_STATUS_ERROR_BAD_CLIENT;

    // we handle some of these in here
    switch (Parms.index)
    {
        case  NV_CFG_DEVICE_HANDLE:
            *pValue = nm->fd;
            Parms.status = NVOS13_STATUS_SUCCESS;
            break;

        default:
            ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_GET, (void *) &Parms);
            if (ret <= 0)
                return NVOS13_STATUS_ERROR_OPERATING_SYSTEM;
            *pValue = Parms.value;
    }

    return Parms.status;
}


ULONG NvRmConfigSet(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  index,
    ULONG  newValue,
    ULONG *pOldValue
)
{
    int   ret;
    NVOS14_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = (NvV32) hClient;
    Parms.hDevice         = (NvV32) hDevice;
    Parms.index           = (NvV32) index;
    Parms.newValue        = (NvV32) newValue;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS14_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_SET, (void *) &Parms);
    if (ret <= 0)
        return NVOS14_STATUS_ERROR_OPERATING_SYSTEM;

    *pOldValue = (ULONG) Parms.oldValue;

    return Parms.status;
}

ULONG NvRmConfigGetEx(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    int   ret;
    NVOS_CONFIG_GET_EX_PARAMS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT;

    Parms.hClient         = hClient;
    Parms.hDevice         = hDevice;
    Parms.index           = index;
    Parms.paramStructPtr  = (NvP64) ((uintptr_t)paramStructPtr);
    Parms.paramSize       = paramSize;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_GET_EX, (void *) &Parms);
    if (ret <= 0)
        return NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmConfigSetEx(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    int   ret;
    NVOS_CONFIG_SET_EX_PARAMS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = hClient;
    Parms.hDevice         = hDevice;
    Parms.index           = index;
    Parms.paramStructPtr  = (NvP64) ((uintptr_t)paramStructPtr);
    Parms.paramSize       = paramSize;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_CSE_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_SET_EX, (void *) &Parms);
    if (ret <= 0)
        return NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

#if 0
ULONG NvRmClipSlam(
    ULONG    hClient,
    ULONG    hChannel,
    ULONG    clips[],        /* {x0,y0,x1,y1}, {x0,y0,x1,y1}, ... */
    ULONG    nClips,
    ULONG    inclusive
)
{
    int  ret;
    XXX_NVOS_I2C_ACCESS_PARAMS  Parms;
    nv_mapping_t *nm;

    Parms.hClient   = hClient;
    Parms.hDevice   = hDevice;
    Parms.clipList  = clipList;
    memcpy(Parms.nClips, clips, min(8, nClips) * 4 * 4);
    Parms.inclusive = inclusive;

    nm = find_mapping(hClient);
    if (nm == 0)
        return XXX_NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CLIPLIST_SLAM, (void *) &Parms);
    if (ret <= 0)
        return XXX_NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    
    return Parms.status;
}

implementation in resman

if not nv10 or better
    return error;

if count too large return error;

wait for IDLE???
set inclusive bit as appropriate in GLOBALSTATE0
for each
   convert to screen space coords of -2048, 2047
   stuff them all

#endif

ULONG  NvRmI2CAccess(
    ULONG hClient,
    ULONG hDevice,
    VOID  *paramStructPtr
)
{
    int  ret;
    NVOS_I2C_ACCESS_PARAMS  Parms;
    nv_mapping_t *nm;

    Parms.hClient        = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.paramStructPtr = (NvP64) ((uintptr_t)paramStructPtr);

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_I2C_ACCESS, (void *) &Parms);
    if (ret <= 0)
        return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    
    return Parms.status;
}

ULONG  NvRmPowerManagement(
    ULONG hClient,
    ULONG hDevice,
    ULONG head,
    ULONG command, 
    VOID *paramStructPtr
)
{
    int  ret;
    NVOS22_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hRoot          = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.command        = (NvV32) command;
    Parms.head           = (NvV32) head;
    Parms.params         = (NvP64) ((uintptr_t)paramStructPtr);

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS22_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_POWER_MANAGEMENT, (void *) &Parms);
    if (ret <= 0)
        return NVOS22_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmDebugControl(NVOS20_PARAMETERS *parms)
{
    int   ret;
    NVOS20_PARAMETERS Parms;

    ret = doEscape(ctl_fd, NV_ESC_RM_DEBUG_CONTROL, (void *) &Parms);
    if (ret <= 0)
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG  NvRmAGPInit(
    ULONG hClient,
    ULONG hDevice,
    ULONG agp_config
)
{
    int  ret = 0;
    nv_mapping_t *nm;
    NVOS_AGP_PARAMS  Parms;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_AGP_STATUS_ERROR_BAD_CLIENT;

    Parms.hDevice = (NvV32) hDevice;
    Parms.config  = (NvV32) agp_config;

    ret = doEscape(nm->fd, NV_ESC_RM_AGP_INIT, (void *) &Parms);
    if (ret <= 0)
        return NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status == RM_OK)
        nm->agp_enabled = 1;

    return Parms.status;
}

ULONG  NvRmAGPTeardown(
    ULONG hClient,
    ULONG hDevice
)
{
    int  ret = 0;
    nv_mapping_t *nm;
    NVOS_AGP_PARAMS  Parms;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_AGP_STATUS_ERROR_BAD_CLIENT;

    // AGP may not be enabled, which is no error
    if (!nm->agp_enabled) 
        return RM_OK;

    Parms.hDevice = (NvV32) hDevice;

    ret = doEscape(nm->fd, NV_ESC_RM_AGP_TEARDOWN, (void *) &Parms);
    if (ret <= 0)
        return NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG NvRmIoFlush(VOID)
{
    int   ret;
    NVOS20_PARAMETERS Parms;

    ret = doEscape(ctl_fd, NV_ESC_RM_IO_FLUSH, (void *) &Parms);
    if (ret <= 0)
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG NvRmConfigVersion(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG *pVersion
)
{
    return NVOS12_STATUS_SUCCESS;
}

ULONG NvRmConfigUpdate(
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    return NVOS15_STATUS_SUCCESS;
}

ULONG NvWatchApiFrontEnd(
    ULONG p0,
    ULONG p1,
    ULONG p2,
    ULONG p3,
    ULONG p4,
    ULONG p5,
    ULONG p6
)
{
    NVWATCHAPI_PARAMETERS Parms;

    Parms.p0 = p0;
    Parms.p1 = p1;
    Parms.p2 = p2;
    Parms.p3 = p3;
    Parms.p4 = p4;
    Parms.p5 = p5;
    Parms.p6 = p6;
    return doEscape(ctl_fd, NV_ESC_RM_NVWATCH, (void *) &Parms);
}


/*
 * NvRmInitSwapBarrier
 */
ULONG NvRmInitSwapBarrier(
    ULONG hClient
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.hClient        = (NvV32) hClient;
    Parms.flags          = (NvV32) (NVOS2A_FLAGS_SWAP_BARRIER | 
                                    NVOS2A_FLAGS_ACTION_INIT);

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmAddSwapGroupClient - register us as a swap group client
 */
ULONG NvRmAddSwapGroup(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG id 
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.hClient        = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.hChannel       = (NvV32) hChannel;
    Parms.group_id       = (NvV32) id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _GROUP)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _ADD));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmRemoveSwapGroup - unregister us as a swap group client
 */
ULONG NvRmRemoveSwapGroup(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG id
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.hClient        = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.hChannel       = (NvV32) hChannel;
    Parms.group_id       = (NvV32) id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _GROUP)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _REMOVE));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmAddSwapBarrier - register us as a swap barrier client
 */
ULONG NvRmAddSwapBarrier(
    ULONG group_id,
    ULONG barrier_id
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.group_id       = (NvV32) group_id;
    Parms.barrier_id     = (NvV32) barrier_id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _BARRIER)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _ADD));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmRemoveSwapBarrier - unregister us as a swap barrier client
 */
ULONG NvRmRemoveSwapBarrier(
    ULONG barrier_id
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.barrier_id     = (NvV32) barrier_id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _BARRIER)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _REMOVE));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


// end of nvRmApi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\rmfail.c ===
/*
 * TODO
 *    what about multiboard stuff?
 *     win2k puts RM_FAILURE in per-device registery area
 *    win9x: need printf
 */

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * Usage:
 *
 *    Add RM_FAILURE tests and triggers as desired
 *    #include <rmfail.h> in any file w/ RM_FAILURE
 * 
 *    Compile with -DDEBUG_RM_FAILURES
 *        Otherwise all RM_FAILURE macro's will vanish
 *
 *    use rmfail.pl in tools/scripts to set RM_FAILURES registry
 *
 *       rmfail.pl set '127 128:18 129:37% 113:50% 200-300:10%'
 *
 *    Optionally set RM_FAILURES_SEED to seed the random number generator.
 *    Otherwise it will be seeded w/ the current time.
 *
 *    Any RM_FAILURE's encountered before RM_FAILURE_ENABLE() will
 *    harmlessly do nothing.
 *    At startup, RmFailuresEnable() will parse the RM_FAILURES string
 *    and produce debug output indicating tests being probed.
 *
 */

#if !defined(__GNUC__) && !defined(MACOS) && !defined(_XBOX)
#include <ntddk.h>       /* XXX just for DbgPrint; delete this if/when switch to another printf */
#endif
#include <nvrm.h>
#include <client.h>
#include <nvos.h>
#include <nvarch.h>

#include <rmfail.h>

#ifdef DEBUG_RM_FAILURES

/* our libc routines.  Since we can't get at libc from the driver we have
 * them incorporated in this file.  These are all from CYGNUS' newlib
 */
// we can't use ctype.h from within resman...
#undef isspace
#define isspace(c) (((c) == ' ') || ((c) == '\011') || ((c) == '\012'))
#undef isdigit
#define isdigit(c) (((c) >= '0') && ((c) <= '9'))
#undef isalpha
#define isalpha(c) ((((c) >= 'a') && ((c) <= 'z')) || (((c) >= 'A') && ((c) <= 'Z')))
#undef isupper
#define isupper(c) (((c) >= 'A') && ((c) <= 'Z'))

long nv_strtol(const char *nptr, char **endptr, int base);
#define RAND_MAX 0x7fffffff
void nv_srand(unsigned int seed);
int nv_rand(void);

static void rm_failure_clear(void)
{        
    (void) memset(rm_failure, 0, sizeof(rm_failure));
    (void) memset(rm_failure_counts, 0, sizeof(rm_failure_counts));
}

static void freakout(char *s)
{
    RM_FAILURE_PRINTF(("RM_FAILURE: init failed: %s\n", s));
    rm_failure_clear();
}

#endif // DEBUG_RM_FAILURES

int RmFailureTriggered(
    int n
)
{
    int rc = 0;
#ifdef DEBUG_RM_FAILURES
    int rint;
    int percent;
    int trigger_count;

    trigger_count = ++rm_failure_counts[n];

    if (rm_failure[n] & RM_FAILURES_MASK_PERCENT)
    {
        percent = rm_failure[n] & RM_FAILURES_MASK_COUNT;
        rint = 1 + (nv_rand() % 100);
        if (rint <= percent)
            rc = 1;
    }
    else
        rc = trigger_count >= rm_failure[n];

    if (rc)
    {
        RM_FAILURE_PRINTF(("RM_FAILURE: triggering %d\n", n));

        if (rm_failure[n] & RM_FAILURES_FLAG_BREAK_ON_TRIGGER)
        {
            osDbgBreakPoint();
        }
        
        // disable the trigger after it fires?
        if (rm_failure[n] & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER)
        {
            // we aren't disabling, just set count to 0
            if ( ! (rm_failure[n] & RM_FAILURES_MASK_PERCENT))
                rm_failure_counts[n] = 0;
        }
        else
        {
            RM_FAILURE_TRIGGER_DISABLE(n);
        }
    }
#endif  // DEBUG_RM_FAILURES

    return rc;
}


void RmFailuresEnable(void)
{
/*
    parse input of environment variables or registry or config file
        or all 3! into rm_failure[]

    comma or space separated list of

       t[-T][:n[%]] 

    where 't' is test number, 'n' is integer and '%' indicates
    'n' is a percent likelihood of failure
    T is used to specify a range

    Example:

        set RM_FAILURES=127b 128:18 129:37% 113:50% 200-300:10%
        
        test 127 will fail on first pass and enter debugger (checked build)
        test 128 will fail on 18th pass
        test 129 has a 37% chance of failing on every pass
        test 113 has a 50% chance of failing
        test range 200-300 to 10% failing each
*/

#ifdef DEBUG_RM_FAILURES
#define MY_MAX_STR 1024
    char s[MY_MAX_STR], sr[32];
    char *p;
    unsigned int seed;
    int len;
    RM_STATUS rm_status;
    extern char strDevNodeRM[];
    
    // init all to disabled
    rm_failure_clear();
    
    (void) memset(s, 0, sizeof(s));
    len = sizeof(s) - 1;	// for NULL term
    rm_status = osReadRegistryString(strDevNodeRM, "RM_FAILURES", s, &len);
    if (rm_status != RM_OK)
        goto done;

    RM_FAILURE_PRINTF(("RM_FAILURE: %s\n", s));
    
    // init random #
    len = 0; // XXX GetEnvironmentVariable("RM_FAILURES_SEED", sr, sizeof(sr));
    if (len > 0)
        seed = (unsigned int) nv_strtol(sr, (void *) 0, 0);
    else
    {
        // use current time in seconds as seed
        // not exactly defensible for Numerical Methods, but...
#ifdef UNIX
        U032 sec, usec;
        osGetCurrentTime(&sec, &usec);
#else
        U032 year, month, day, hour, min, sec, msec;
        osGetCurrentTime(&year, &month, &day, &hour, &min, &sec, &msec);
        if (year > 1970) year -= 1970;
        month += year * 12;
        day += month * 30;
        hour += day * 24;
        min += hour * 60;
        sec += min * 60;
#endif
        seed = (unsigned int) sec;
    }
    nv_srand(seed);

    RM_FAILURE_PRINTF(("RM_FAILURE: rand seed is %d\n", seed));

    // parse the string
    p = s;
    while (*p)
    {
        int t1, t2, n, percent;
        char *newp;
        int flags = 0;

        newp = p;
        t1 = nv_strtol(p, &newp, 0);
        if (newp == p)   // did not advance; garbage in str. bail out
            break;
        p = newp;

        n = 1;
        percent = 0;
        if ((t1 < 0) || (t1 >= RM_FAILURES_MAX))
            freakout("invalid test number");

        // test range specified?
        t2 = t1;
        if (*p == '-')
        {
            p++;
            newp = p;
            t2 = nv_strtol(p, &newp, 0);
            if (newp == p) // advance?
                break;
            p = newp;

            if ((t2 < 0) || (t2 >= RM_FAILURES_MAX) || (t1 > t2))
            {
                freakout("invalid test range");
                goto failed;
            }
        }

        // check for break and dont disable flags
        while (*p == 'b' || *p == 'd')
        {
            if (*p == 'b')
                flags |= RM_FAILURES_FLAG_BREAK_ON_TRIGGER;
            else if (*p == 'd')
                flags |= RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER;
            p++;
        }
        
        // how quick does the failure fire?
        if (*p == ':')
        {
            p++;
            n = nv_strtol(p, &p, 0);            
            if (n > RM_FAILURES_MAX_COUNT)
            {
                freakout("invalid count");
                goto failed;
            }
            if (*p == '%')
            {
                p++;
                percent = n;
                if ((percent > 100) || (percent < 1))
                {
                    freakout("invalid percent");
                    goto failed;
                }
            }
        }
        
        // record the failure instructions in rm_failure[]
        if (t2 != t1)
        {
            int t;

            for (t = t1; t <= t2; t++)
                if (percent)
                    rm_failure[t] = RM_FAILURES_MASK_PERCENT | percent | flags;
                else
                    rm_failure[t] = n | flags;

            RM_FAILURE_PRINTF(("RM_FAILURE: set range %d-%d to %d%s%s%s\n",
                               t1, t2,
                               percent ? percent : n,
                               percent ? "%" : "",
                               flags & RM_FAILURES_FLAG_BREAK_ON_TRIGGER ?
                                 " (break)" : "",
                               flags & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER ?
                              "(dont disable)" : ""
                              ));
        }
        else
        {            
            if (percent)
                rm_failure[t1] = RM_FAILURES_MASK_PERCENT | percent | flags;
            else
                rm_failure[t1] = n | flags;

            RM_FAILURE_PRINTF(("RM_FAILURE: set %3d to %d%s%s%s\n",
                               t1,
                               percent ? percent : n,
                               percent ? "%" : "",
                               flags & RM_FAILURES_FLAG_BREAK_ON_TRIGGER ?
                                 " (break)" : "",
                               flags & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER ?
                              "(dont disable)" : ""
                              ));
        }

        while (*p && (*p == ' '))
            p++;
        if (*p == ',') p++;
    }

 done:
    return;
 failed:
    return;
#endif
}

//
// Disable all RM_FAILURE triggers by zapping them
// To re-enable you must use RmFailuresEnable() which will
// re-read the registry RM_FAILURES value.
//
void RmFailuresDisable(void)
{
#ifdef DEBUG_RM_FAILURES
    RM_FAILURE_PRINTF(("RM_FAILURE: disabled\n"));
    rm_failure_clear();
#endif
}

#ifdef DEBUG_RM_FAILURES
/* Utility routines only below this point */

/*
 * Convert a string to a long integer.
 * From 
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 *
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define LONG_MAX  2147483647L
#define LONG_MIN	(- LONG_MAX - 1L)

long nv_strtol(
    const char *nptr,
    char **endptr,
    int base
)
{
	register const char *s = nptr;
	register unsigned long acc;
	register int c;
	register unsigned long cutoff;
	register int neg = 0, any, cutlim;

	/*
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
	} while (isspace(c));
	if (c == '-') {
		neg = 1;
		c = *s++;
	} else if (c == '+')
		c = *s++;
	if ((base == 0 || base == 16) &&
	    c == '0' && (*s == 'x' || *s == 'X')) {
		c = s[1];
		s += 2;
		base = 16;
	}
	if (base == 0)
		base = c == '0' ? 8 : 10;

	/*
	 * Compute the cutoff value between legal numbers and illegal
	 * numbers.  That is the largest legal value, divided by the
	 * base.  An input number that is greater than this value, if
	 * followed by a legal input character, is too big.  One that
	 * is equal to this value may be valid or not; the limit
	 * between valid and invalid numbers is then based on the last
	 * digit.  For instance, if the range for longs is
	 * [-2147483648..2147483647] and the input base is 10,
	 * cutoff will be set to 214748364 and cutlim to either
	 * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
	 * a value > 214748364, or equal but the next digit is > 7 (or 8),
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
		if (isdigit(c))
			c -= '0';
		else if (isalpha(c))
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		else
			break;
		if (c >= base)
			break;
		if (any < 0 || acc > cutoff || acc == cutoff && c > cutlim)
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
		}
	}
	if (any < 0) {
		acc = neg ? LONG_MIN : LONG_MAX;
	} else if (neg)
		acc = -(long)acc;
	if (endptr != 0)
		*endptr = (char *) (any ? s - 1 : nptr);
	return (acc);
}
static unsigned int next = 1;

void nv_srand(unsigned int seed)
{
        next = seed;
}

int nv_rand(void)
{
        return ((next = next * 1103515245 + 12345) & RAND_MAX);
}


#endif  // DEBUG_RM_FAILURES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll32\nvarch32.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVARCH.C                                                          *
*         This is the 32bit DLL interface to the RM for the new architecture*
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito (jvito)    03/04/98 - wrote it.                            *
\***************************************************************************/
#include <windows.h>
#include <nvwin32.h>
#include <nvrmwin.h>

//#include "nv_ref.h"
//#include "nvrm.h"
//#include "nvrmwin.h"
//#include "nvcm.h"
//#include <class.h>
//#include <vblank.h>
//#include <gr.h>
//#include <vga.h>
//#include "nvsys.h"

typedef struct _def_rmParams FAR *LPRMPARAMS;
//extern  VOID PASCAL CallRM(LPRMPARAMS);

#define NVRM_DLL32_NV01FREE            NVRM_ARCH_NV01FREE			 
#define NVRM_DLL32_NV01ALLOCROOT       NVRM_ARCH_NV01ALLOCROOT       
#define NVRM_DLL32_NV01ALLOCMEMORY	   NVRM_ARCH_NV01ALLOCMEMORY	 
#define NVRM_DLL32_NV01ALLOCCONTEXTDMA NVRM_ARCH_NV01ALLOCCONTEXTDMA 
#define NVRM_DLL32_NV01ALLOCCHANNELPIO NVRM_ARCH_NV01ALLOCCHANNELPIO 
#define NVRM_DLL32_NV01ALLOCOBJECT	   NVRM_ARCH_NV01ALLOCOBJECT	 
#define NVRM_DLL32_NV01ALLOCDEVICE	   NVRM_ARCH_NV01ALLOCDEVICE	 
#define NVRM_DLL32_NV03ALLOCCHANNELDMA NVRM_ARCH_NV03ALLOCCHANNELDMA 
#define NVRM_DLL32_NV03DMAFLOWCONTROL  NVRM_ARCH_NV03DMAFLOWCONTROL  
#define NVRM_DLL32_NV01INTERRUPT       NVRM_ARCH_NV01INTERRUPT       
#define NVRM_DLL32_NV01ALLOCEVENT	   NVRM_ARCH_NV01ALLOCEVENT		 

#define NVRM_ARCHITECTURE_API          NVRM_API_ARCHITECTURE_32
#define NVOPEN_STATUS_SUCCESS 		   0
#define NVCLOSE_STATUS_SUCCESS		   0

DWORD PASCAL NvSysDispatch(LPRMPARAMS, DWORD);

VOID __stdcall NvIoControl
(
  U032 Function,
  VOID *pParameters
)
{
    RMPARAMS NvParams;

    NvParams.RegEAX = NVRM_ARCHITECTURE_API;
    NvParams.RegEDX = (DWORD)Function;
    NvParams.RegEBX = (DWORD)pParameters;
    NvParams.RegEDI = 1;				  // The device context will be assigned in the RM.
    NvParams.RegES  = 0;
    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov NvParams.RegDS, eax
    _asm mov ax, cs
    _asm mov NvParams.RegCS, eax
    NvSysDispatch(&NvParams, 0);
}	


VOID Arch_NvOpen(U032 *status)                   
{
  *status = NVOPEN_STATUS_SUCCESS;
}

VOID Arch_NvClose(U032 *status)                  
{
  *status = NVCLOSE_STATUS_SUCCESS;
}

VOID Arch_Nv01Free(VOID *pParameters)            
{
  NvIoControl(NVRM_DLL32_NV01FREE,pParameters);
}

VOID Arch_Nv01AllocRoot(VOID *pParameters)       
{
  NvIoControl(NVRM_DLL32_NV01ALLOCROOT,pParameters);
}

VOID Arch_Nv01AllocDevice(VOID *pParameters)     
{
  NvIoControl(NVRM_DLL32_NV01ALLOCDEVICE,pParameters);
}

VOID Arch_Nv01AllocContextDma(VOID *pParameters) 
{
  NvIoControl(NVRM_DLL32_NV01ALLOCCONTEXTDMA,pParameters);
}

VOID Arch_Nv01AllocChannelPio(VOID *pParameters) 
{
  NvIoControl(NVRM_DLL32_NV01ALLOCCHANNELPIO,pParameters);
}

VOID Arch_Nv01AllocObject(VOID *pParameters)     
{
  NvIoControl(NVRM_DLL32_NV01ALLOCOBJECT,pParameters);
}

VOID Arch_Nv01AllocMemory(VOID *pParameters)     
{
  NvIoControl(NVRM_DLL32_NV01ALLOCMEMORY,pParameters);
}

VOID Arch_Nv01Interrupt(VOID *pParameters)       
{
  NvIoControl(NVRM_DLL32_NV01INTERRUPT,pParameters);
}

VOID Arch_Nv01AllocEvent(VOID *pParameters)      
{
  NvIoControl(NVRM_DLL32_NV01ALLOCEVENT,pParameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll16\NVSYS.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVSYS.C                                                           *
*   This is the Windows half of the Resource Manager.  System clients call  *
*   the Resource Manager through these APIS.  The VxD calls into this       *
*   to post a message to the Windows Resource Manager EXE.                  *
*                                                                           *
\***************************************************************************/

//
// Windows main include file
//
#include <windows.h>
//
// USER.275 function to redraw screen.
//
VOID FAR PASCAL RepaintScreen(VOID);
//
// Windows Resource Manager System includes.
//
#include "nv_ref.h"
#include "nvrm.h"
#include "nvrmwin.h"
#include "nvsys.h"
#include "nvcm.h"
#include "nvos.h"

#include <class.h>
#include <vblank.h>
#include <gr.h>
#include <vga.h>

#define DLL_PROCESS_ATTACH  1
#define DLL_PROCESS_DETACH  0

//
// Global cursor control defines
//
#define COLOR_OFFSET    32*sizeof(DWORD)    // offset of XOR mask from start of buffer (= size of and mask)
// white & black filtering
#define WHITE (0xffff)
#define BLACK (0x8000)
#define DRK_BLEND 10    // off-black
#define MED_DRK 14      // a little lighter, for black followed by white
#define LT_BLEND 3      // off-white
#define MED_LT 8        // a little darker, for white followed by black
// formatted filtered white & black
#define MED_WHITE (0x8000 | ((31-MED_LT) << 10) | ((31-MED_LT) << 5) | (31-MED_LT))
#define MED_BLACK (0x8000 | ((31-MED_DRK) << 10) | ((31-MED_DRK) << 5) | (31-MED_DRK))
#define LT_GRAY (0x8000 | ((31-LT_BLEND) << 10) | ((31-LT_BLEND) << 5) | (31-LT_BLEND))
#define DK_GRAY (0x8000 | (DRK_BLEND << 10) | (DRK_BLEND << 5) | DRK_BLEND)

#define IsNvCfgAgp(x) (x>=NV_CFG_AGP_FULLSPEED_FW&&x<=NV_CFG_AGP_LOAD_DUMMY_PAGES)
//---------------------------------------------------------------------------
//
//  Typedefs.
//
//---------------------------------------------------------------------------

typedef struct _def_hw_info      FAR * LPHWINFO;
typedef struct _def_client_info  FAR * LPCLIENTINFO;

//---------------------------------------------------------------------------
//
//  Prototypes.
//
//---------------------------------------------------------------------------

INT   FAR PASCAL LibMain(HINSTANCE, WORD, WORD, LPSTR);
INT   FAR PASCAL _WEP(BOOL);
BOOL  FAR PASCAL THK_ThunkConnect16(LPSTR, LPSTR, WORD, DWORD);
BOOL  FAR PASCAL DllEntryPoint(DWORD, WORD, WORD, WORD, DWORD, WORD);
VOID  FAR PASCAL NvSysIpcCallback(DWORD, DWORD, DWORD);
VOID  FAR PASCAL NvSysNotifyCallback(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
typedef void (_far __cdecl *CAPTUREPROC)(DWORD);
VOID  FAR PASCAL __loadds NvCaptureFrameCallback(DWORD,DWORD);
DWORD FAR PASCAL NvSysDispatch(LPRMPARAMS, DWORD);
VOID  PASCAL CallRM(LPRMPARAMS);
void  CallRM_DeviceSetup(LPRMPARAMS);
BOOL  PASCAL ValidateScreenRect(RMPARAMS FAR *);
BOOL  PASCAL NvThunkNotifyEvent(DWORD, DWORD);
BOOL  PASCAL NvThunkNotifyMsg(DWORD, HWND, WORD);
BOOL  PASCAL NvThunkErrorMsg(DWORD, HWND, WORD);
BOOL  PASCAL NvThunkAllocPages(DWORD, LPDWORD, LPDWORD);
BOOL  PASCAL NvThunkFreePages(DWORD);

DWORD PASCAL REG_RD32(DWORD);
DWORD PASCAL REG_WR32(DWORD, DWORD);
BYTE  PASCAL REG_RD08(DWORD);
DWORD PASCAL REG_WR08(DWORD, DWORD);
VOID  PASCAL NvSysHideEmulatedCursor(WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPDWORD);

DWORD PASCAL NvThunkNvArch(DWORD,DWORD,DWORD);

//---------------------------------------------------------------------------
//
//  Data.
//
//---------------------------------------------------------------------------
// Documentation says name should be blank-padded.

char    NVstring[9] = "NVCORE  ";

// Had trouble matching NVRM until I used 0-padded name. Windows bug if name is 4 chars?

//
// Enable flag.
//
BOOL Enabled = FALSE;
//
// Pointer to Resource Manager API routine.
//
DWORD ResManAPI;
//
// Pointers to shared Resource Manager structures.
//
LPCLIENTINFO  lpClientInfo;
U032 FAR * lp16bitProcessDS;
U032     dll16_ClientInstance=0;


LPHWINFO  dll16_NvInfoPtrTable[MAX_INSTANCE];
U032      FAR *lpNvInfoSelectors;

#undef NUM_FIFOS
#define NUM_FIFOS               dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.Count

//
// Because we are in 16 bit code, we can't just have a selector that describes the entire
// NV register space easily. So we have an array of selectors that point to each major portion
// of the register space. Also, to handle multimon, we need one such array of selectors for each
// NV device.
//
struct {
    WORD  devSelector[NV_DEV_MAX+1]; // Device Selector table.
} devSelectorTable[MAX_INSTANCE];

U008  VblankDummy = NULL;   // dummy vblank status 

//
// Instance of the Windows Resource Manager task.
//
HINSTANCE hInstNvSysEXE;
HANDLE    hTaskNvSysEXE;
//
// Instance of this DLL.
//
HINSTANCE hInstNvSysDLL;
//
// Bit reversal table for cursor glyph.
//
BYTE BitReversal[] =
{
    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
    0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
    0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
    0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
    0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
    0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
    0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
    0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
    0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
    0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
    0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
    0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
    0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
    0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
    0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

//
// Translate  4 bpp into 555
//
U016 color4bpp[] =
{
    0,
    0x4000,
    0x200,
    0x4200,
    0x10,
    0x4010,
    0x210,
    0x6318,
    0x4210,
    0x7c00,
    0x3e0,
    0x7fe0,
    0x1f,
    0x7c1f,
    0x3ff,
    0x7fff
//    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
};


//---------------------------------------------------------------------------
//
//  In-line assembly routines.
//
//---------------------------------------------------------------------------

//
//  Get the call gate for calling into the resource manager
//  Now that the RM is a dynamic vxd, it has the undefined device ID and must be located by name
//
VOID GetCallGate(VOID)
{
    __asm {
    mov  bx, 0
    mov  ax, 01684h
    mov  di, ds
    mov  es, di
    lea  di, NVstring
    int  02Fh
    mov  WORD PTR ResManAPI, di
    mov  WORD PTR ResManAPI + 2, es
    }
}

VOID Breakpoint(VOID)
{
    __asm int    3
}

U016 GetSelector(U032 addrLin, U032 limit)
{
    U016    regAX,sel;

    __asm   {
	mov	ax,ds
	mov	regAX,ax
    }
    sel = AllocSelector(regAX);
    SetSelectorBase(sel,addrLin);
    SetSelectorLimit(sel,limit);
    return sel;
}

U032 FAR PASCAL NvSysDriverConnect(U032 osDevHandle, U032 osDeviceName)
{
  RMPARAMS rmParams;
  U032     rmDeviceHandle;

  rmParams.RegEAX = NVRM_API_DRIVER_CONNECT;
  rmParams.RegEBX = osDevHandle;
  rmParams.RegECX = osDeviceName;
  rmParams.RegES  = 0;
  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
  CallRM_DeviceSetup(&rmParams);
  rmDeviceHandle = (U032) rmParams.RegEAX;
  if(rmDeviceHandle != 0)
  {
	  rmParams.RegEAX = NVRM_API_MULTIDEVICE_MAP_RM_INFO;
	  rmParams.RegES  = 0;
	  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
	  CallRM_DeviceSetup(&rmParams);
	  lpNvInfoSelectors = (U032 FAR *) (rmParams.RegEAX << 16);
	  {
		int temp_count;
		for(temp_count=0;temp_count<MAX_INSTANCE;temp_count++)
		  dll16_NvInfoPtrTable[temp_count] = (LPHWINFO) (lpNvInfoSelectors[temp_count] << 16);
	  } 
  }
  
  return rmDeviceHandle;
}

VOID FAR PASCAL NvSysDriverDisConnect(U032 DeviceHandle)
{

  RMPARAMS rmParams;

  rmParams.RegEAX = NVRM_API_DRIVER_DISCONNECT;
  rmParams.RegEBX = DeviceHandle;               // is this parameter even used?
  rmParams.RegES  = 0;
  rmParams.RegESI = DeviceHandle-1;
  CallRM_DeviceSetup(&rmParams);
}

//---------------------------------------------------------------------------
//
//  System routines.
//
//---------------------------------------------------------------------------
//
// Win95 Dll entrypoint.
//
BOOL FAR PASCAL DllEntryPoint
(
    DWORD dwReason,
    WORD  hInstance,
    WORD  wDS,
    WORD  wHeapSize,
    DWORD dwReserved1,
    WORD  dwReserved2
)
{
    static INT AttachCount = 0;

    if (!(THK_ThunkConnect16("NV3SYS.DLL","NV3API.DLL",hInstance,dwReason)))
        return (FALSE);
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ++AttachCount;
            break;
        case DLL_PROCESS_DETACH:
            --AttachCount;
            break;
    }
    return (TRUE);
}
//
// DLL entrypoint.
//
INT FAR PASCAL LibMain
(
    HINSTANCE hInstance,
    WORD      wDataSeg,
    WORD      cbHeapSize,
    LPSTR     lpszCmdLine
)
{
    INT      i, j;
    RMPARAMS rmParams;
    
    if (Enabled)
        return (1);
    hInstNvSysDLL = hInstance;
    hInstNvSysEXE = 0;
    //
    // Get Resource Manager call gate.
    //
    GetCallGate();
    if (ResManAPI == 0)
    {
        return (FALSE);
    }
    //
    // Check version number.
    //
    
    rmParams.RegEAX = NVRM_API_GET_VERSION;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    if (rmParams.RegEAX != NVRM_VERSION)
    {
        return (FALSE);
    }
    //
    // Install Resource Manager callbacks.
    //
    rmParams.RegEAX = NVRM_API_NOTIFY_CALLBACK;
    rmParams.RegECX = ((DWORD)&NvSysNotifyCallback) & 0xFFFF;
    rmParams.RegEDX = ((DWORD)&NvSysNotifyCallback) >> 16;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    rmParams.RegEAX = NVRM_API_IPC_CALLBACK;
    rmParams.RegECX = ((DWORD)&NvSysIpcCallback) & 0xFFFF;
    rmParams.RegEDX = ((DWORD)&NvSysIpcCallback) >> 16;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);

    //
    // Install mediaport callback mechanism (Canopus)
    //
	rmParams.RegEAX = NVRM_API_VPE_MISC; // main function
	rmParams.RegEBX = IMAGE_INSTALL_16CALLBACK; // subfunction
	rmParams.RegECX = ((DWORD)&NvCaptureFrameCallback) & 0xFFFF;
	rmParams.RegEDX = ((DWORD)&NvCaptureFrameCallback) >> 16;
	rmParams.RegES  = 0;
	rmParams.RegESI = DEFAULT_DEVICEHANDLE;
	CallRM_DeviceSetup(&rmParams);

    rmParams.RegEAX = NVRM_API_MULTIDEVICE_MAP_RM_INFO;
    rmParams.RegEBX = 0x69;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    lpNvInfoSelectors = (U032 FAR *) (rmParams.RegEAX   << 16);
    {
      int temp_count;
      for(temp_count=0;temp_count<MAX_INSTANCE;temp_count++)
        dll16_NvInfoPtrTable[temp_count] = (LPHWINFO) (lpNvInfoSelectors[temp_count] << 16);
    }    
    
    lpClientInfo  = (LPCLIENTINFO)(rmParams.RegECX << 16);
    lp16bitProcessDS = (U032 FAR *) (rmParams.RegEDI << 16);

    // clear the selector array.
    for(i = 0; i < MAX_INSTANCE; i++)
        for (j = 0; j < NV_DEV_MAX+1; j++)
            devSelectorTable[i].devSelector[j] = 0;

    Enabled = TRUE;
    return (1);
}
//
// DLL exitpoint.
//
INT FAR PASCAL _WEP
(
    BOOL bSysExit
)
{
    RMPARAMS rmParams;

    if (Enabled)
    {
        //
        // Tell Resource Manager not to call back to this DLL anymore.
        //
        rmParams.RegEAX = NVRM_API_UNLOAD_DLL;
        rmParams.RegES  = 0;
        rmParams.RegESI = DEFAULT_DEVICEHANDLE;
        CallRM_DeviceSetup(&rmParams);
    }
    return (1);
}

//
// Capturing Frame callback from mediaport
//
VOID FAR PASCAL __loadds NvCaptureFrameCallback(DWORD DeviceHandle, DWORD dwBufferOffset)
{
// Take care in MultiMonitor environments, the DeviceHandle passed here may NOT necessarily be
// used as an index to the dll_16NvInfoPtrTable !! Check this in the RM VXD
	if (dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback)
		((CAPTUREPROC /*__far*/)(dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback))( dwBufferOffset);
}


//
// VxD Resource Manager callback to Windows DLL.
//
VOID FAR PASCAL NvSysIpcCallback
(
    DWORD Msg,
    DWORD wParam,
    DWORD lParam
)
{
    ;
    /*
    if (hInstNvSysEXE)
        PostAppMessage(hTaskNvSysEXE,
                       (WORD)Msg,
                       (WORD)wParam,
                       lParam);
    */                       
}

VOID FAR PASCAL NvSysNotifyCallback
(
    DWORD ChID,
    DWORD Object,
    DWORD Offset,
    DWORD Data,
    DWORD Status,
    DWORD Action
)
{
}
//
// Nv thunk dispatcher for 32 bit applications.
//
DWORD FAR PASCAL NvSysDispatch
(
    LPRMPARAMS lpParams,
    DWORD      Function
)
{

//  lpParams->RegEDI holds the DeviceHandle from the 32bit DLL Caller.

    switch (Function)
    {
        //
        // Call Resource Manager.
        //
		case 0:
			lpParams->RegESI = lpParams->RegEDI-1;
            CallRM_DeviceSetup(lpParams);
            break;
        case NV_FUNCTION_NVALLOCPAGES:
            NvThunkAllocPages(GetSelectorBase((UINT)lpParams->RegDS),
                                             &(lpParams->RegEAX),
                                             &(lpParams->RegEDX));
            break;
        case NV_FUNCTION_NVFREEPAGES:
            NvThunkFreePages(lpParams->RegEAX);
            break;
        //
        // Map some routines that aren't available under Win32s.
        //
        case NV_FUNCTION_GETSELECTORBASE:
            lpParams->RegEAX = GetSelectorBase((UINT)lpParams->RegEAX);
            break;
        case NV_FUNCTION_GETCURRENTTASK:
            lpParams->RegEAX = GetCurrentTask();
            break;
        //
        // Configuration Manager APIs for 32 bit apps.
        //
        case NV_FUNCTION_NVCONFIGVERSION:
            lpParams->RegEAX = NvConfigVersion(lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVCONFIGGET:
            lpParams->RegEAX = NvConfigGet(lpParams->RegEAX,lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVCONFIGSET:
            lpParams->RegEAX = NvConfigSet(lpParams->RegEAX, lpParams->RegEBX,lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVCONFIGUPDATE:
            lpParams->RegEAX = NvConfigUpdate(lpParams->RegEAX,lpParams->RegEDI);
            break;
        //
        // Pointer to certain hardware.
        //
        case NV_FUNCTION_NVSYSGETHWPTRS:
            NvSysGetHardwarePointers(&(lpParams->RegEAX),
                                     &(lpParams->RegEBX),
                                     &(lpParams->RegECX),
                                     &(lpParams->RegEDX),
                                     lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVDEVICEBASEGET:
            lpParams->RegEAX = NvDeviceBaseGet(lpParams->RegEAX,lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVDEVICELIMITGET:
            lpParams->RegEAX = NvDeviceLimitGet(lpParams->RegEAX,lpParams->RegEDI);
            break;
        case NVRM_API_ARCHITECTURE_32:
            // EAX-Function EBX-parameters DS-Client Data Selector
            lpParams->RegEAX = NvThunkNvArch(GetSelectorBase((UINT)lpParams->RegDS),lpParams->RegEAX,lpParams->RegEBX);
            break;
    }

    return (0);
}

//---------------------------------------------------------------------------
//
//  Nv display driver entrypoints.
//
//---------------------------------------------------------------------------

VOID FAR PASCAL NvSysMoveCursor
(
    INT    xPos,
    INT    yPos,
    U032   DeviceHandle
)
{

    xPos &= 0xfff;  // bits used on NV3
    yPos &= 0xfff;
    
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosX   = xPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosY   = yPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_POS;

}

// This is the new interface to update the cursor image. 
// All we have to do is program the offset, width/height and colorformat.
// We don't have to worry about the converting glyphs etc.
// This is the way a cursor image is defined in NV{04 | 10}_VIDEO_LUT_CURSOR_DAC class.
// Because the cursor manipulation needs to happen independent of what other rendering
// that is going on, the class interface can not be used to update the cursor image and position.
//
// Flags.<0> : if 1, indicates that the rest of the cursor image parameters are valid and they should be
//           :       programmed into the hardware.
//           : if 0, the cursor image values are not valid.
// Flags.<1> : If 1, Flags.<2> indicates how the cursor's enable disable state should be changed.
//           : If 0, don't change the enable/disable state of the cursor.
// Flags.<2> : If 1, enable the cursor.
//           : If 0, disable the cursor.
VOID FAR PASCAL NvSysSetCursorImage
(
    U032  Flags,
    U032  Offset,
    U032  Width,
    U032  Height,
    U032  ColorFormat,
    U032  DeviceHandle
)
{
    // this is the new way of setting cursor image. The cursorType should not be used in this scheme.
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorType = DAC_CURSOR_TYPE_NEW;

    if (Flags & 0x00000001)
    {
        // Offset is assumed to be an offset from the start of the Frame buffer.
        // Make sure The Address Space Indicator for the cursor says it is in the Frame buffer
        // (instead of Instance Memory).

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth  = Width;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight = Height;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorOffset = Offset;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorColorFormat = ColorFormat;

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW;
    } // program the cursor image values.

    if (Flags & 0x00000002)
    {
        if (Flags & 0x00000004)
        {
            // Enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_ENABLE;

            // Make sure there is no pending request to disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_DISABLE;
        }
        else
        {
            // disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_DISABLE;

            // Make sure there is no pending request to enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_ENABLE;
        }
    } // enable or disable the cursor.
}


VOID FAR PASCAL NvSysMoveCursorMulti
(
    INT    xPos,
    INT    yPos,
    U032   DeviceHandle,
    U032   Head
)
{

    xPos &= 0xfff;  // bits used on NV3
    yPos &= 0xfff;
    
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorPosX   = xPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorPosY   = yPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_POS;

}

// This is the new interface to update the cursor image. 
// All we have to do is program the offset, width/height and colorformat.
// We don't have to worry about the converting glyphs etc.
// This is the way a cursor image is defined in NV{04 | 10}_VIDEO_LUT_CURSOR_DAC class.
// Because the cursor manipulation needs to happen independent of what other rendering
// that is going on, the class interface can not be used to update the cursor image and position.
//
// Flags.<0> : if 1, indicates that the rest of the cursor image parameters are valid and they should be
//           :       programmed into the hardware.
//           : if 0, the cursor image values are not valid.
// Flags.<1> : If 1, Flags.<2> indicates how the cursor's enable disable state should be changed.
//           : If 0, don't change the enable/disable state of the cursor.
// Flags.<2> : If 1, enable the cursor.
//           : If 0, disable the cursor.
VOID FAR PASCAL NvSysSetCursorImageMulti
(
    U032  Flags,
    U032  Offset,
    U032  Width,
    U032  Height,
    U032  ColorFormat,
    U032  DeviceHandle,
    U032  Head
)
{
    // this is the new way of setting cursor image. The cursorType should not be used in this scheme.
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorType = DAC_CURSOR_TYPE_NEW;

    if (Flags & 0x00000001)
    {
        // Offset is assumed to be an offset from the start of the Frame buffer.
        // Make sure The Address Space Indicator for the cursor says it is in the Frame buffer
        // (instead of Instance Memory).

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorWidth  = Width;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorHeight = Height;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorOffset = Offset;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorColorFormat = ColorFormat;

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW;
    } // program the cursor image values.

    if (Flags & 0x00000002)
    {
        if (Flags & 0x00000004)
        {
            // Enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_ENABLE;

            // Make sure there is no pending request to disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_DISABLE;
        }
        else
        {
            // disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_DISABLE;

            // Make sure there is no pending request to enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_ENABLE;
        }
    } // enable or disable the cursor.
}


VOID FAR PASCAL NvSysUpdateImageOffsetFormat
(
    U032   offset,
    U032   format,
    U032   chID,
    U032   objectHandle,
    U032   DeviceHandle,
    U032   Head
)
{
    //
    // Note: we don't need the object handle, since the current mode setting
    // pVidLutCurDac object is stashed away in the Dac.CrtcInfo struct already.
    //
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ImageOffset   = offset;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ImageFormat   = format;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ChID          = chID;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ObjectHandle  = objectHandle;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
}


BOOL FAR PASCAL NvSysSetCursor
(
    LPBYTE lpGlyph,
    INT    Width,
    INT    Height,
    U032   DeviceHandle
)
{
    INT i;
    
    //
    // Save width and height.
    //
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth  = Width;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight = Height;
    if (dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth > 32)
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth = 32;
    if (dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight > 32)
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight = 32;
    //
    // Make glyph transparent.
    //
    for (i = 0; i < 32 * sizeof(DWORD); i++)
    {
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[1][i] = 0xFF;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[0][i] = 0x00;
    }
    if (lpGlyph && (Height > 0))
    {
        for (i = 0; i < (INT)(Height * sizeof(DWORD)); i++)
        {
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[1][i] = BitReversal[lpGlyph[i]];
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[0][i] = BitReversal[lpGlyph[i + Height * sizeof(DWORD)]];
        }
    }
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorType = DAC_CURSOR_TWO_COLOR_XOR;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE | UPDATE_HWINFO_DAC_CURSOR_POS;
    //
    // False means this isn't emulated.
    //
    
    return (FALSE);
}

DWORD FAR PASCAL NvSysGetScreenInfo
(
    U032    DeviceHandle
)
{
    DWORD returnvalue;

    returnvalue =
        (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth << 16) |
        dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth;

    return (returnvalue);
}
DWORD FAR PASCAL NvSysGetRamInfo
(
    U032    DeviceHandle
)
{
    DWORD returnvalue;

    returnvalue = (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSizeMb << 16) | dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamType;

    return (returnvalue);
}
DWORD FAR PASCAL NvSysGetBufferInfo
(
    U032    DeviceHandle
)
{
    DWORD returnvalue;

    returnvalue = (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Count << 16) | dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth;

    returnvalue = 0xdeadbeef;

    return (returnvalue);
}
VOID FAR PASCAL NvSysClearScreen
(
    U032    DeviceHandle
)
{
    RMPARAMS rmParams;

    //
    // Clear visible screen.
    //
    rmParams.RegEAX = NVRM_API_CLEAR_SCREEN;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

}
VOID FAR PASCAL NvSysDisplayModeHook
(
    DWORD   HookProc,
    U032    DeviceHandle
)
{
    RMPARAMS rmParams;

    //
    // Hook display mode changes.
    //
    rmParams.RegEAX = NVRM_API_MODE_HOOK;
    rmParams.RegEBX = HookProc;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

}
VOID FAR PASCAL NvSysGetHardwarePointers
(
    DWORD FAR *pNv1,
    DWORD FAR *pAlternate,
    DWORD FAR *pFramebuffer,
    DWORD FAR *pTimer,
    U032      DeviceHandle
)
{
    RMPARAMS rmParams;

    //
    // Get all the hardware pointers.
    //
    rmParams.RegEAX = NVRM_API_GET_NV_ADDRESS;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (pNv1)         *pNv1         = rmParams.RegEAX;
    if (pAlternate)   *pAlternate   = rmParams.RegEAX + 0x00618000;
    if (pTimer)       *pTimer       = rmParams.RegEAX + 0x00101400;
    rmParams.RegEAX = NVRM_API_GET_FB_ADDRESS;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (pFramebuffer) *pFramebuffer = rmParams.RegEAX;

}
VOID FAR PASCAL NvSysGetCursorEmulatePosPointers
(
    DWORD FAR *pX,
    DWORD FAR *pY,
    U032      DeviceHandle
)
{
#ifdef SW_CURSOR
    //
    // Return pointers to current emulated cursor position.
    //    
    if (pX) *pX = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CursorSaveUnderPosX;
    if (pY) *pY = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CursorSaveUnderPosY;
#else
    if (pX) *pX = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosX;
    if (pY) *pY = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosY;
#endif // SW_CURSOR
    
}
DWORD FAR PASCAL NvSysGetCurrentBufferFlatPointer
(
    U032      DeviceHandle
)
{
    DWORD returnvalue;

    //
    // Return pointer to current buffer value.  This is the physical front buffer, only use
    // for direct frambeffer access.
    //
    returnvalue = (DWORD)GetSelectorBase((UINT)(((DWORD)dll16_NvInfoPtrTable[DeviceHandle-1] >> 16) + (DWORD)&(dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Current) - (DWORD)dll16_NvInfoPtrTable[DeviceHandle-1]));

    return(returnvalue);
}
                               
//---------------------------------------------------------------------------
//
//  Nv system client entrypoints.
//
//---------------------------------------------------------------------------

BOOL FAR PASCAL NvSysAllocPages
(
    LPVOID FAR *Addr,
    LPDWORD     Handle,
    DWORD       Size,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_ALLOC_PAGES;
    rmParams.RegECX = Size;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    *Addr   = (LPVOID)(rmParams.RegEDX);
    *Handle = rmParams.RegEAX;

    return (rmParams.RegEAX ? FALSE : TRUE);
}
BOOL FAR PASCAL NvSysFreePages
(
    DWORD       Handle,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_FREE_PAGES;
    rmParams.RegECX = Handle;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

    return (rmParams.RegEAX ? FALSE : TRUE);
}
BOOL FAR PASCAL NvSysLockPages
(
    WORD        Selector,
    DWORD       Offset,
    DWORD       Size,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_LOCK_PAGES;
    rmParams.RegEBX = Selector;
    rmParams.RegECX = Offset;
    rmParams.RegEDX = Size;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

    return (rmParams.RegEAX);
}
BOOL FAR PASCAL NvSysUnlockPages
(
    WORD        Selector,
    DWORD       Offset,
    DWORD       Size,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_UNLOCK_PAGES;
    rmParams.RegEBX = Selector;
    rmParams.RegECX = Offset;
    rmParams.RegEDX = Size;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

    return (rmParams.RegEAX);
}
//---------------------------------------------------------------------------
//
//  Thunked entrypoints from Win32 API DLL.
//
//---------------------------------------------------------------------------
BOOL PASCAL NvThunkAllocPages
(
    DWORD   FlatBase,
    LPDWORD AddrSize,
    LPDWORD Handle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_ALLOC_PAGES;
    rmParams.RegECX = *AddrSize;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    *AddrSize = rmParams.RegEDX - FlatBase;
    *Handle   = rmParams.RegEAX;
    return (rmParams.RegEAX ? FALSE : TRUE);
}
BOOL PASCAL NvThunkFreePages
(
    DWORD Handle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_FREE_PAGES;
    rmParams.RegECX = Handle;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    return (rmParams.RegEAX ? FALSE : TRUE);
}

DWORD PASCAL NvThunkNvArch
(
    DWORD pParameters_base,
    DWORD pParameters,
    DWORD Function
)
{
  DWORD    pParameters_flat_offset;
  RMPARAMS rmParams;

  pParameters_flat_offset = (DWORD) ((DWORD) pParameters_base + (DWORD) pParameters);

  rmParams.RegEAX = NVRM_API_ARCHITECTURE_32;
  rmParams.RegES  = 0;
  rmParams.RegEBX = Function;
  rmParams.RegECX = pParameters_flat_offset;
  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
  CallRM_DeviceSetup(&rmParams);
  return (rmParams.RegEAX);
}

//---------------------------------------------------------------------------
//
//  Internal routines.
//
//---------------------------------------------------------------------------

// return raster position on nv4/nv10
DWORD PASCAL NvGetRasterPosition
(
    U032        DeviceHandle
)
{
    DWORD        pPCRTC_RASTER;

    pPCRTC_RASTER = ((DWORD)NvDeviceSelectorGet(NV_DEV_PCRTC, DeviceHandle) << 16)
                        | ((DWORD)NV_PCRTC_RASTER - (DWORD)NV_PCRTC_INTR_0);
    return (REG_RD32(pPCRTC_RASTER) & 0x7FF);
}

//---------------------------------------------------------------------------
//
// Configuration API.
//
//---------------------------------------------------------------------------

DWORD FAR PASCAL NvConfigVersion
(
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;
    CHAR       Title[256];
    CHAR       Message[512];

    rmParams.RegEAX = NVRM_API_GET_VERSION;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (rmParams.RegEAX != NVRM_VERSION)
    {
        LoadString(hInstNvSysDLL, NVSYS_STR_RM_ERROR, Title, 256);
        LoadString(hInstNvSysDLL, NVSYS_STR_VERSION_ERROR, Message, 512);
        MessageBox(0, Message, Title, MB_OK);
    }

    return (rmParams.RegEAX);
}
DWORD FAR PASCAL NvConfigGet
(
    DWORD       Index,
    U032        DeviceHandle
)
{
    RMINFO FAR *pRmInfo;
    U016	RmInfoSel = 0;
    U032	pv;

    DWORD        Value;
    U008         lock;
    DWORD        pPRMCIO_INDEX;
    DWORD        pPRMCIO_DATA;
    RMPARAMS     rmParams;

    Value = 0;

    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to view
    //
    if ((Index & 0xF00) == NV_CFG_CRTC)
    {
        //
        // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
        //
        pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
        pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));

        //
        // Make sure the extended CRTC registers are enabled
        //
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

        //
        // Get the register value.
        //
        REG_WR08(pPRMCIO_INDEX, Index & 0xFF);              // 3D4
        Value = REG_RD08(pPRMCIO_DATA);                     // 3D5
        
        //
        // Restore the lock
        //
        if (lock == 0)
        {        
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
        }

        return (Value);
    }

    if(IsNvCfgAgp(Index))
    {
	pv = (U032)(dll16_NvInfoPtrTable[DeviceHandle-1]->pRmInfo);
	RmInfoSel = GetSelector(pv,sizeof(RMINFO));
	pRmInfo = (RMINFO FAR*)(((U032)RmInfoSel) << 16); 
    }
    
    switch (Index)
    {
        //
        // These values actually look at hardware, not NvInfo.
        //
        case NV_CFG_VBLANK_STATUS:

        // do the scanline method

            //
            // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
            //
            pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            //
            // Make sure the extended CRTC registers are enabled
            //
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

            // Check whether in power saving mode. Return dummy status if so, or else direct draw will hang
            // waiting for vlank to change.
            REG_WR08(pPRMCIO_INDEX, NV_CIO_CRE_RPC1_INDEX);   // 3D4 = scanline hi byte
            Value = 0xC0 & REG_RD08(pPRMCIO_DATA);            // 3D5 bits 7&6 are hsync & vsync inactive
            if (Value)                                        // in power saving mode if either is set
                Value = (VblankDummy ^= 1);                   // just toggle, so we are sure to get both states
            else
            {
                Value = NvGetRasterPosition(DeviceHandle);
                if (Value == 0) // make sure we don't have false count. NV3 seems to have glitch during display period.
                {
                    Value = NvGetRasterPosition(DeviceHandle);
                }
                if (Value == 0)
                    Value = 1;
                else
                    Value = 0;            
            } // if in power saving mode            
            //
            // Restore the lock
            //
            if (lock == 0)
            {        
                REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
                REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
            }
            break;
        case NV_CFG_GE_STATUS:
            {
                DWORD pGEStatus;
                pGEStatus = ((DWORD)NvDeviceSelectorGet(NV_DEV_PGRAPH,DeviceHandle) << 16)
                          | ((DWORD)NV_PGRAPH_STATUS - (DWORD)DEVICE_BASE(NV_PGRAPH));
                Value = REG_RD32(pGEStatus);
            }
            break;
        case NV_CFG_CURRENT_SCANLINE:
            //
            // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
            //
            pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            //
            // Make sure the extended CRTC registers are enabled
            //
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

            //
            // Get the scanline value.
            //
            Value = NvGetRasterPosition(DeviceHandle);
            if (Value == 0) // make sure we don't have false 0 count
            {
                Value = NvGetRasterPosition(DeviceHandle);
            }
            
            //
            // Restore the lock
            //
            if (lock == 0)
            {        
                REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
                REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
            }
            break;
        //
        // Fields in NvInfo.
        //
        case NV_CFG_MANUFACTURER:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Manufacturer;
            break;
        case NV_CFG_ARCHITECTURE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Architecture;
            break;
        case NV_CFG_REVISION:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.MaskRevision;
            break;
        case NV_CFG_BIOS_REVISION:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.BiosRevision;
            break;
        case NV_CFG_BUS_TYPE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.Bus;
            break;
        case NV_CFG_CRYSTAL_FREQ:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.CrystalFreq;
            break;
        case NV_CFG_ADDRESS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.PhysAddr;
            break;
        case NV_CFG_IRQ:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.IntLine;
            break;
        case NV_CFG_IO_NEEDED:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.doIOToFlushCache;
            break;
        case NV_CFG_PCI_ID:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.PCIDeviceID;
            break;
        case NV_CFG_PCI_SUB_ID:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.PCISubDeviceID;
            break;
        case NV_CFG_GRAPHICS_CAPS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Graphics.Capabilities;
            break;
        case NV_CFG_INSTANCE_TOTAL:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.HalInfo.TotalInstSize;
            break;
        case NV_CFG_INSTANCE_SIZE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.FreeInstSize;
            break;
        case NV_CFG_FIFO_COUNT:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.Count;
            break;
        case NV_CFG_FIFO_USE_COUNT:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.AllocateCount;
            break;
        case NV_CFG_RAM_SIZE_MB:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSizeMb;
            break;
        case NV_CFG_RAM_SIZE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSize;
            break;
        case NV_CFG_RAM_TYPE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamType;
            break;
        case NV_CFG_AGP_PHYS_BASE:
			Value = pRmInfo->AGP.AGPPhysStart;
            break;
        case NV_CFG_AGP_LINEAR_BASE:
			Value = pRmInfo->AGP.AGPLinearStart;
            break;
        case NV_CFG_AGP_LIMIT:
			Value = pRmInfo->AGP.AGPLimit;
            break;
        case NV_CFG_AGP_HEAP_FREE:
            Value = pRmInfo->AGP.AGPHeapFree;
            break;
        case NV_CFG_AGP_FW_ENABLE:
            Value = pRmInfo->AGP.AGPFWEnable;
            break;
        case NV_CFG_AGP_FULLSPEED_FW:
            Value = pRmInfo->AGP.AGPFullSpeedFW;
            break;
        case NV_CFG_SCREEN_WIDTH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth;
            break;
        case NV_CFG_SCREEN_HEIGHT:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth;
            break;
        case NV_CFG_PIXEL_DEPTH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth;
            break;
        case NV_CFG_PRIMARY_SURFACE_PITCH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.DisplayPitch;
            break;
        case NV_CFG_SCREEN_MAX_WIDTH:
            {
                // This value depends on the display type.
                // We really should read the EDID of the display device to get the max.
                // For now hard code the values.
                switch (GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0))
                {
                    case MONITOR_TYPE_VGA:
                        Value = 2048;
                        break;
                    case MONITOR_TYPE_NTSC:
                        Value = 640;
                        break;
                    case MONITOR_TYPE_PAL:
                        Value = 800;
                        break;
                    case MONITOR_TYPE_FLAT_PANEL:
                        Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.fpHMax;
                        break;
                    default:
                        Value = 0;
                        break;
                } // switch on MonitorType
            }
            break;
        case NV_CFG_SCREEN_MAX_HEIGHT:
            {
                // This value depends on the display type.
                // We really should read the EDID of the display device to get the max.
                // For now hard code the values.
                switch (GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0))
                {
                    case MONITOR_TYPE_VGA:
                        Value = 1536;
                        break;
                    case MONITOR_TYPE_NTSC:
                        Value = 480;
                        break;
                    case MONITOR_TYPE_PAL:
                        Value = 600;
                        break;
                    case MONITOR_TYPE_FLAT_PANEL:
                        Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.fpVMax;
                        break;
                    default:
                        Value = 0;
                        break;
                } // switch on MonitorType
            }
            break;
        case NV_CFG_VIDEO_ENCODER_TYPE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.EncoderType;
            break;
        case NV_CFG_VIDEO_ENCODER_ID:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.EncoderID;
            break;
		case NV_CFG_BIOS_DEFAULT_TV_TYPE:
			// Build selectors to access CRTC
	        pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
    	    pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
			// Unlock ext CRTC
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4 <-1f
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5 <-57

            REG_WR08(pPRMCIO_INDEX, NV_CIO_CRE_SCRATCH0__INDEX);// 3D4 <-2B
            Value = REG_RD08(pPRMCIO_DATA) & 0x7;               // 3D5 get BIOS values (defined in nvcm.h)
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4 <-1f
            REG_WR08(pPRMCIO_DATA, lock);  						// 3D5 <-former value
			break;
        case NV_CFG_VIDEO_DISPLAY_TYPE:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_DISPLAY_TYPE;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
            break;
        case NV_CFG_VIDEO_MONITOR_TYPE:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_MONITOR_TYPE;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
//            Value = GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0);
            break;
        case NV_CFG_VIDEO_OVERLAY_ALLOWED:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayAllowed;
            break;
        case NV_CFG_VIDEO_DOWNSCALE_RATIO_768:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayMaxDownscale_768;
            break;
        case NV_CFG_VIDEO_DOWNSCALE_RATIO_1280:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayMaxDownscale_1280;
            break;
        case NV_CFG_VIDEO_DOWNSCALE_RATIO_1920:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayMaxDownscale_1920;
            break;
        case NV_CFG_VIDEO_REFRESH_RATE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RefreshRate;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y;
            break;
        case NV_CFG_VBLANK_TOGGLE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle;
            break;
        case NV_CFG_VBLANK_COUNTER:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankCounter;
            break;
        case NV_CFG_PRAM_CURRENT_SIZE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.HalInfo.CurrentSize;
            break;
        case NV_CFG_DAC_INPUT_WIDTH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.InputWidth;
            break;
        case NV_CFG_DAC_PIXEL_CLOCK:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk;
            break;
        case NV_CFG_DAC_MEMORY_CLOCK:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MClk;
            break;
        case NV_CFG_DAC_GRAPHICS_CLOCK:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NVClk;
            break;
        case NV_CFG_DAC_VPLL_M:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllM;
            break;
        case NV_CFG_DAC_VPLL_N:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllN;
            break;
        case NV_CFG_DAC_VPLL_O:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllO;
            break;
        case NV_CFG_DAC_VPLL_P:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllP;
            break;
        case NV_CFG_DAC_MPLL_M:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllM;
            break;
        case NV_CFG_DAC_MPLL_N:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllN;
            break;
        case NV_CFG_DAC_MPLL_O:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllO;
            break;
        case NV_CFG_DAC_MPLL_P:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllP;
            break;
        case NV_CFG_DAC_PCLK_LIMIT_8BPP:
            Value = GETCRTCHALINFO(dll16_NvInfoPtrTable[DeviceHandle-1], 0, PCLKLimit8bpp);
            break;            
        case NV_CFG_DAC_PCLK_LIMIT_16BPP:
            Value = GETCRTCHALINFO(dll16_NvInfoPtrTable[DeviceHandle-1], 0, PCLKLimit16bpp);
            break;            
        case NV_CFG_DAC_PCLK_LIMIT_32BPP:
            Value = GETCRTCHALINFO(dll16_NvInfoPtrTable[DeviceHandle-1], 0, PCLKLimit32bpp);
            break;            
        case NV_CFG_MAPPING_BUSDEVICEFUNC:
            rmParams.RegEAX = NVRM_API_GET_DEVICE_TYPE;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = (dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.nvBusDeviceFunc << 8) | rmParams.RegEAX;
            break;
        case NV_CFG_FLAT_PANEL_CONNECT_16:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_FP_CONNECT_STATUS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
            break;
        case NV_CFG_FLAT_PANEL_CONFIG_16:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_FP_CONFIG;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
            break;
        case NV_CFG_NUMBER_OF_HEADS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NumCrtcs;
            break;
        case NV_CFG_INITIAL_BOOT_HEAD:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.InitialBootHead;
            break;
        case NV_CFG_DEVICE_HANDLE:
            {
                PWIN9XHWINFO    pOsHwInfo = (PWIN9XHWINFO) dll16_NvInfoPtrTable[DeviceHandle-1]->pOsHwInfo;
                Value = pOsHwInfo->osDeviceHandle;
            }
            break;
#ifdef RM_STATS
        case NV_STAT_INTERVAL_NSEC_LO:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateLo;
            break;
        case NV_STAT_INTERVAL_NSEC_HI:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateHi;
            break;
        case NV_STAT_FIFO_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FifoExceptionCount;
            break;
        case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FramebufferExceptionCount;
            break;
        case NV_STAT_GRAPHICS_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.GraphicsExceptionCount;
            break;
        case NV_STAT_TIMER_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TimerExceptionCount;
            break;
        case NV_STAT_CHIP_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TotalExceptionCount;
            break;
        case NV_STAT_MEM_ALLOCATED:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemAlloced;
            break;
        case NV_STAT_MEM_LOCKED:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemLocked;
            break;
        case NV_STAT_EXEC_NSEC_LO:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeLo;
            break;
        case NV_STAT_EXEC_NSEC_HI:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeHi;
            break;
        case NV_STAT_INT_NSEC_LO:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeLo;
            break;
        case NV_STAT_INT_NSEC_HI:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeHi;
            break;
#endif
        case NV_CFG_GET_ALL_DEVICES:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.DevicesBitMap;
            break;
        case NV_CFG_GET_BOOT_DEVICES:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.BootDevicesBitMap;
            break;
    }

    if(RmInfoSel)
	FreeSelector(RmInfoSel);

    return (Value);
}
DWORD FAR PASCAL NvConfigSet
(
    DWORD       Index,
    DWORD       NewValue,
    U032        DeviceHandle
)
{
    RMINFO FAR *pRmInfo;
    U016 RmInfoSel = 0;
    U032 pv;

    DWORD OldValue, Value;
    U008  lock;
    DWORD pPRMCIO_INDEX;
    DWORD pPRMCIO_DATA;
    RMPARAMS     rmParams;
    NV_CFG_STEREO_PARAMS FAR *pStereoParams;

    OldValue = 0;

    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to update
    //
    if ((Index & 0xF00) == NV_CFG_CRTC)
    {
        //
        // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
        //
        pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                  | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
        pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                  | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
    
        //
        // Make sure the extended CRTC registers are enabled
        //
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

        //
        // Set the register value.
        //
        REG_WR08(pPRMCIO_INDEX, Index & 0xFF);
        OldValue = REG_RD08(pPRMCIO_DATA);
        REG_WR08(pPRMCIO_DATA, NewValue & 0xFF);
        
        //
        // Restore the lock
        //
        if (lock == 0)
        {        
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
        }

        return (OldValue);
    }

    if(IsNvCfgAgp(Index))
    {
	pv = (U032)(dll16_NvInfoPtrTable[DeviceHandle-1]->pRmInfo);
	RmInfoSel = GetSelector(pv,sizeof(RMINFO));
	pRmInfo = (RMINFO FAR*)(((U032)RmInfoSel) << 16); 
    }
    
    switch (Index)
    {
        //
        // Theses values actually look at hardware, not NvInfo.
        //
        case NV_CFG_VBLANK_STATUS:
            //
            //  Set OldValue = current value. No idea if this is used.
            //
            //
            // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
            //
            pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));

            //
            // Make sure the extended CRTC registers are enabled
            //
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

            //
            // Get the scanline value.
            //
            Value = NvGetRasterPosition(DeviceHandle);
            // return boolean for (scanline == 0)
            if (Value == 0)
                OldValue = 1;
            else
                OldValue = 0;            
            //
            // Restore the lock
            //
            if (lock == 0)
            {        
                REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
                REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
            }
            
            break;
        case NV_CFG_GE_STATUS:
            {
                DWORD pGEStatus;
                pGEStatus = ((DWORD)NvDeviceSelectorGet(NV_DEV_PGRAPH,DeviceHandle) << 16)
                          | ((DWORD)NV_PGRAPH_STATUS - (DWORD)DEVICE_BASE(NV_PGRAPH));
                OldValue = REG_RD32(pGEStatus);
            }
            break;
        //
        // Fields in NvInfo.
        //
        case NV_CFG_MANUFACTURER:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Manufacturer;
            break;
        case NV_CFG_ARCHITECTURE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Architecture;
            break;
        case NV_CFG_REVISION:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Revision;
            break;
        case NV_CFG_BIOS_REVISION:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.BiosRevision;
            break;
        case NV_CFG_IMPLEMENTATION:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Implementation;
            break;
        case NV_CFG_BUS_TYPE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.Bus;
            break;
        case NV_CFG_ADDRESS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.PhysAddr;
            break;
        case NV_CFG_IRQ:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.IntLine;
            break;
        case NV_CFG_INSTANCE_SIZE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.FreeInstSize;
            break;
        case NV_CFG_FIFO_COUNT:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.Count;
            break;
        case NV_CFG_FIFO_USE_COUNT:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.AllocateCount;
            break;
        case NV_CFG_RAM_SIZE_MB:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSizeMb;
            break;
        case NV_CFG_RAM_SIZE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSize;
            break;
        case NV_CFG_RAM_TYPE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamType;
            break;
        case NV_CFG_AGP_PHYS_BASE:
            OldValue = pRmInfo->AGP.AGPPhysStart;
            pRmInfo->AGP.AGPPhysStart = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_AGP_LINEAR_BASE:
            OldValue = pRmInfo->AGP.AGPLinearStart;
            pRmInfo->AGP.AGPLinearStart = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_AGP_LIMIT:
            OldValue = pRmInfo->AGP.AGPLimit;
            pRmInfo->AGP.AGPLimit = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;

        case NV_CFG_AGP_LOAD_DUMMY_PAGES:
            rmParams.RegEAX = NVRM_AGP_LOAD_DUMMY_PAGES;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;

        case NV_CFG_SCREEN_WIDTH:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_SCREEN_HEIGHT:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_PIXEL_DEPTH:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_VIDEO_DISPLAY_TYPE:
            OldValue = GETDISPLAYTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0);
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_SET_DISPLAY_TYPE;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_VIDEO_MONITOR_TYPE:
            OldValue = GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0);
            SETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0, NewValue);
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags  |= UPDATE_HWINFO_DISPLAY_PARAMS;
            break;
        case NV_CFG_VIDEO_REFRESH_RATE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RefreshRate;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RefreshRate     = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HorizFrontPorch = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HorizSyncWidth  = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HorizBackPorch  = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.VertFrontPorch  = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.VertSyncWidth   = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.VertBackPorch   = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk            = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_DISPLAY_PARAMS;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;       // kick a mode switch
            //
            // fb will reset the pixel clock, so we need to reload the VPLL
            //
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_VPLL;
            //
            // Allow Canopus to set the refresh rate and pull the
            // resolution from the registry (but not the refresh rate)
            // in only one mode set.  Yuck.  But until I can export all
            // modeset code...
            //
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_REFRESH_PARAMS;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x = NewValue;
            // Recalculate the scale factor
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_x = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth << 20;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_x /= dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y = NewValue;
            // Recalculate the scale factor
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_y = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth << 20;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_y /= dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y;
            break;
        case NV_CFG_VBLANK_TOGGLE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle = NewValue;
            if (dll16_NvInfoPtrTable[DeviceHandle-1]->Vga.Enabled)
                dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle = 0;
            break;
        case NV_CFG_VBLANK_COUNTER:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankCounter;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankCounter = NewValue;
            break;
        case NV_CFG_PRAM_CURRENT_SIZE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.HalInfo.CurrentSize;
            break;
        case NV_CFG_DAC_INPUT_WIDTH:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.InputWidth;
            break;
        case NV_CFG_DAC_PIXEL_CLOCK:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_VPLL;
            //
            // set DISPLAY flag as this parameter may be stored in EEPROM
            //
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_DISPLAY_PARAMS;
            break;
        case NV_CFG_DAC_MEMORY_CLOCK:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MClk;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MClk = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_MPLL;
            break;
        case NV_CFG_DAC_GRAPHICS_CLOCK:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NVClk;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NVClk = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_NVPLL;
            break;
        case NV_CFG_DAC_VPLL_M:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllM;
            break;
        case NV_CFG_DAC_VPLL_N:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllN;
            break;
        case NV_CFG_DAC_VPLL_O:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllO;
            break;
        case NV_CFG_DAC_VPLL_P:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllP;
            break;
        case NV_CFG_DAC_MPLL_M:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllM;
            break;
        case NV_CFG_DAC_MPLL_N:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllN;
            break;
        case NV_CFG_DAC_MPLL_O:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllO;
            break;
        case NV_CFG_DAC_MPLL_P:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllP;
            break;
        case NV_CFG_REGISTRY_STRING:
            rmParams.RegEAX = NVRM_REGISTRY_SET_STRING;
            rmParams.RegEBX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_FRAMECAPTURE_CALLBACK:			// Callback for the VFW capture driver
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback;
            dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback = NewValue;
            break;
        case NV_CFG_FLAT_PANEL_CONFIG_16:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_FP_CONFIG;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            OldValue = rmParams.RegEAX;
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_SET_FP_CONFIG;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_DISPLAY_CHANGE_CONFIG:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_CHANGE_CONFIG;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_DISPLAY_CHANGE_START:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_CHANGE_START;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_DISPLAY_CHANGE_END:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_CHANGE_END;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP:
            rmParams.RegEAX = NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP;
//            rmParams.RegEBX = NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_STEREO_CONFIG:
            pStereoParams = (NV_CFG_STEREO_PARAMS FAR *)NewValue;
            if (pStereoParams->Flags == STEREOCFG_EXIT_ADJACENT)
            {
                dll16_NvInfoPtrTable[DeviceHandle-1]->StereoFlags &= ~STEREO_ADJACENT_EYES;
            } else
            {
                if (pStereoParams->Flags == STEREOCFG_ENTER_ADJACENT)
                {
                    dll16_NvInfoPtrTable[DeviceHandle-1]->StereoFlags |= STEREO_ADJACENT_EYES;
                } 
            }        
            OldValue = (DWORD)dll16_NvInfoPtrTable[DeviceHandle-1]->pStereoParams;
            break;

#ifdef RM_STATS
        case NV_STAT_INTERVAL_NSEC_LO:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateLo;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateLo = NewValue;
            break;
        case NV_STAT_INTERVAL_NSEC_HI:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateHi;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateHi = NewValue;
            break;
        case NV_STAT_FIFO_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FifoExceptionCount;
            break;
        case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FramebufferExceptionCount;
            break;
        case NV_STAT_GRAPHICS_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.GraphicsExceptionCount;
            break;
        case NV_STAT_TIMER_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TimerExceptionCount;
            break;
        case NV_STAT_CHIP_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TotalExceptionCount;
            break;
        case NV_STAT_MEM_ALLOCATED:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemAlloced;
            break;
        case NV_STAT_MEM_LOCKED:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemLocked;
            break;
        case NV_STAT_EXEC_NSEC_LO:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeLo;
            break;
        case NV_STAT_EXEC_NSEC_HI:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeHi;
            break;
        case NV_STAT_INT_NSEC_LO:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeLo;
            break;
        case NV_STAT_INT_NSEC_HI:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeHi;
            break;
#endif
    }

    if(RmInfoSel)
	FreeSelector(RmInfoSel);

    return (OldValue);
}
DWORD FAR PASCAL NvConfigUpdate
(
    DWORD       UpdateFlag,
    U032        DeviceHandle
)
{
    RMPARAMS rmParams;
    WORD     RepaintFlag;

    if (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_PARAMS)
        RepaintFlag = TRUE;
    else
        RepaintFlag = FALSE;
    rmParams.RegEAX = NVRM_API_UPDATE_CONFIGURATION;
    rmParams.RegEBX = UpdateFlag;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (RepaintFlag)
    {
        //
        // Update selectors to framebuffer.
        //
        if (devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0])
        {
            rmParams.RegEAX = NVRM_API_MAP_SELECTOR;
            rmParams.RegEBX = NvDeviceBaseGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegECX = NvDeviceLimitGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegEDX = devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0];
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
        }
        RepaintScreen();
    }
    
    return (rmParams.RegEAX);
}
DWORD FAR PASCAL NvConfigVga
(
    DWORD       Mode,
    U032        DeviceHandle
)
{
    RMPARAMS rmParams;

    dll16_NvInfoPtrTable[DeviceHandle-1]->Vga.GlobalEnable = Mode;
    rmParams.RegEAX = NVRM_API_CONFIG_VGA;
    rmParams.RegEBX = Mode;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (!Mode)
    {
        //
        // Update selectors to framebuffer.
        //
        if (devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0])
        {
            rmParams.RegEAX = NVRM_API_MAP_SELECTOR;
            rmParams.RegEBX = NvDeviceBaseGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegECX = NvDeviceLimitGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegEDX = devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0];
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
        }
    }

    return (rmParams.RegEAX);
}

//---------------------------------------------------------------------------
//
// Device API.
//
//---------------------------------------------------------------------------

DWORD FAR PASCAL NvDeviceBaseGet
(
    DWORD       Index,
    DWORD       DeviceHandle
)
{
    DWORD    DeviceOffset;
    RMPARAMS rmParams;

    switch (Index)
    {
        case NV_DEV_BASE:
            DeviceOffset = DEVICE_BASE(NV_SPACE);
            break;
        case NV_DEV_BUFFER_0:
            DeviceOffset = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.Start[0];
            rmParams.RegEAX = NVRM_API_GET_FB_ADDRESS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            
            return (rmParams.RegEAX + DeviceOffset);
            break;
        case NV_DEV_AGP:
            rmParams.RegEAX = NVRM_API_GET_AGP_ADDRESS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);

            return (rmParams.RegEAX);
            break;
        case NV_DEV_GAMMA:
            rmParams.RegEAX = NVRM_API_GET_GAMMA_ADDRESS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);

            return (rmParams.RegEAX);
            break;
        case NV_DEV_TIMER:
            DeviceOffset = NV_PTIMER_TIME_0;
            break;
        case NV_DEV_PFB:
            DeviceOffset = DEVICE_BASE(NV_PFB);
            break;
        case NV_DEV_PGRAPH:
            DeviceOffset = DEVICE_BASE(NV_PGRAPH);
            break;
        case NV_DEV_PRMCIO:
            DeviceOffset = DEVICE_BASE(NV_PRMCIO);
            break;
        case NV_DEV_PRMVIO:
            DeviceOffset = DEVICE_BASE(NV_PRMVIO);
            break;
        case NV_DEV_PRAMDAC:
            DeviceOffset = DEVICE_BASE(NV_PRAMDAC);
            break;
        case NV_DEV_PCRTC:
            // there's no limit:base define for NV_PCRTC, so use ...
            DeviceOffset = NV_PCRTC_INTR_0;
            break;
        default:

        return (0);
    }
    //
    // Get base pointer to the hardware.
    //
    rmParams.RegEAX = NVRM_API_GET_NV_ADDRESS;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    //
    // Return pointer to desired device.
    //
    
    return (rmParams.RegEAX + DeviceOffset);
}
DWORD FAR PASCAL NvDeviceLimitGet
(
    DWORD       Index,
    DWORD       DeviceHandle
)
{
    DWORD      DeviceLimit;

    switch (Index)
    {
        case NV_DEV_BASE:
            DeviceLimit = (1?NV_SPACE) - DEVICE_BASE(NV_SPACE);
            break;
        case NV_DEV_BUFFER_0:
            DeviceLimit = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.Limit[0];
            break;
        case NV_DEV_TIMER:
            DeviceLimit = 7;
            break;
        case NV_DEV_GAMMA:
            DeviceLimit = 0x400;
            break;
        case NV_DEV_PFB:
            DeviceLimit = 0x0FFF;
            break;
        case NV_DEV_PGRAPH:
            DeviceLimit = 0x0FFF;
            break;
        case NV_DEV_PRMCIO:
            DeviceLimit = 0x0FFF;
            break;
        case NV_DEV_PRMVIO:
            DeviceLimit = 0x7FFF;
            break;
        case NV_DEV_PRAMDAC:
            DeviceLimit = DEVICE_EXTENT(NV_PRAMDAC) - DEVICE_BASE(NV_PRAMDAC);
            break;
        case NV_DEV_PCRTC:
            // there's no limit:base define for NV_PCRTC, so use ...
            DeviceLimit = ((NV_PCRTC_RASTER+4) - NV_PCRTC_INTR_0);
            break;
        default:
     
            return (0);
    }
    //
    // Return limit of desired device.
    //

    return (DeviceLimit);
}
WORD FAR PASCAL NvDeviceSelectorGet
(
    DWORD       Index,
    U032        DeviceHandle
)
{
    DWORD      DeviceBase;
    DWORD      DeviceLimit;
    RMPARAMS   rmParams;

    if (Index > NV_DEV_MAX)
    {    
        return (0);
    }        
    if (devSelectorTable[DeviceHandle-1].devSelector[Index])
    {    
        return (devSelectorTable[DeviceHandle-1].devSelector[Index]);
    }        
    DeviceBase  = NvDeviceBaseGet(Index,DeviceHandle);
    DeviceLimit = NvDeviceLimitGet(Index,DeviceHandle);
    //
    // Get selector for requested device.
    //
    rmParams.RegEAX = NVRM_API_MAP_SELECTOR;
    rmParams.RegEBX = DeviceBase;
    rmParams.RegECX = DeviceLimit;
    rmParams.RegEDX = 0;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    devSelectorTable[DeviceHandle-1].devSelector[Index] = (WORD) rmParams.RegEAX;
    
    return (devSelectorTable[DeviceHandle-1].devSelector[Index]);
}

void FAR PASCAL __loadds NvSysRegisterDisplayDriver(RMPARAMS FAR *prmParams)
{
    prmParams->RegEAX = NVRM_API_REGISTER_DISPLAY_DRIVER;
    prmParams->RegESI = 0;
    prmParams->RegES = 0;
    CallRM_DeviceSetup(prmParams);
}

void CallRM_DeviceSetup(LPRMPARAMS lprmParams)
{
    RMUSRAPI_STRUCT rmusrcall;
    WORD seg_,off_;
    DWORD seg_base,rmusrcall_flat_offset;
    
    rmusrcall.function = lprmParams->RegEAX;
    rmusrcall.device = lprmParams->RegESI;

    _asm push di
    _asm lea  di,rmusrcall
    _asm mov  off_,di
    _asm pop  di

	_asm mov  seg_,ss

    seg_base = GetSelectorBase((UINT) seg_);
    rmusrcall_flat_offset = seg_base+((DWORD) off_);
    lprmParams->RegEAX = rmusrcall_flat_offset;

    CallRM(lprmParams);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll16\NVRM16.ASM ===
; 
;  (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
; 
.386

_DATA           SEGMENT WORD PUBLIC USE16 'DATA'

EXTERN  _ResManAPI : DWORD

_DATA           ENDS
        
_TEXT           SEGMENT WORD PUBLIC USE16 'CODE'

        ASSUME  ds:_DATA
;
; Call the resource manager.
; It is called as:
;
;       VOID FAR PASCAL CallRM((LPNVPARAMS)lpParams);
;
lpParams        EQU     [bp + 6]
RegEAX          EQU     0
RegEBX          EQU     4
RegECX          EQU     8
RegEDX          EQU     12
RegEDI          EQU     16
RegESI          EQU     20
RegES           EQU     24
RegDS           EQU     28
RegCS           EQU     32

public  CALLRM
CALLRM          PROC NEAR
        push    bp
        mov     bp, sp
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    edi
        push    esi
        push    es
        les     si,  DWORD PTR lpParams
        mov     eax, DWORD PTR es:[si + RegEAX]
        push    eax
        mov     ebx, DWORD PTR es:[si + RegEBX]
        mov     ecx, DWORD PTR es:[si + RegECX]
        mov     edx, DWORD PTR es:[si + RegEDX]
        mov     edi, DWORD PTR es:[si + RegEDI]
        mov     ax,   WORD PTR es:[si + RegES]
        mov     esi, DWORD PTR es:[si + RegESI]
        mov     es, ax
        pop     eax
        call    DWORD PTR _ResManAPI
        push    eax
        push    esi
        mov     ax, es
        les     si, DWORD PTR lpParams
        mov     WORD PTR es:[si + RegES], ax
        pop     eax
        mov     DWORD PTR es:[si + RegESI], eax
        pop     eax
        mov     DWORD PTR es:[si + RegEAX], eax
        mov     DWORD PTR es:[si + RegEBX], ebx
        mov     DWORD PTR es:[si + RegECX], ecx
        mov     DWORD PTR es:[si + RegEDX], edx
        mov     DWORD PTR es:[si + RegEDI], edi
        pop     es
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        leave
        retf	4
CALLRM          ENDP
;
; Read and write 32 bit registers.
; Called as:
;
;       VOID  FAR PASCAL REG_WR32(FAR DWORD *Address, DWORD Data);
;       DWORD FAR PASCAL REG_RD32(FAR DWORD *Address);
;
RdAddress       EQU     [bp + 6]
WrAddress       EQU     [bp + 10]
WrData          EQU     [bp + 6]

public  REG_WR32
REG_WR32        PROC NEAR
        push    bp
        mov     bp, sp
        push    eax
        push    si
        push    es
        les     si,  DWORD PTR WrAddress
        mov     eax, WrData
        mov     DWORD PTR es:[si], eax
        pop     es
        pop     si
        pop     eax
        leave
        retf	8
REG_WR32        ENDP
public  REG_RD32
REG_RD32        PROC NEAR
        push    bp
        mov     bp, sp
        push    ecx
        push    si
        push    es
        les     si,  DWORD PTR RdAddress
        mov     ecx, DWORD PTR es:[si]
        mov     ax, cx
        shr     ecx, 16
        mov     dx, cx
        pop     es
        pop     si
        pop     ecx
        leave
        retf	4
REG_RD32        ENDP
;
; Read and write 32 bit registers.
; Called as:
;
;       VOID  FAR PASCAL REG_WR32(FAR DWORD *Address, DWORD Data);
;       DWORD FAR PASCAL REG_RD32(FAR DWORD *Address);
;
RdAddress       EQU     [bp + 6]
WrAddress       EQU     [bp + 10]
WrData          EQU     [bp + 6]

public  REG_WR08
REG_WR08        PROC NEAR
        push    bp
        mov     bp, sp
        push    eax
        push    si
        push    es
        les     si,  DWORD PTR WrAddress
        mov     al, WrData
        mov     BYTE PTR es:[si], al
        pop     es
        pop     si
        pop     eax
        leave
        retf	8
REG_WR08        ENDP
public  REG_RD08
REG_RD08        PROC NEAR
        push    bp
        mov     bp, sp
        push    ecx
        push    si
        push    es
        les     si,  DWORD PTR RdAddress
        mov     al, BYTE PTR es:[si]
        pop     es
        pop     si
        pop     ecx
        leave
        retf	4
REG_RD08        ENDP
;
; Hide the emulated cursor in the framebuffer.
;
; Called as:
;
;        NvSysHideEmulatedCursor(WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, DWORD FAR *);
;
xGlyphPos       EQU     [bp + 24]
yGlyphPos       EQU     [bp + 22]
cxGlyphWidth    EQU     [bp + 20]
cyGlyphHeight   EQU     [bp + 18]
cxScreenWidth   EQU     [bp + 16]
cyScreenHeight  EQU     [bp + 14]
cScreenDepth    EQU     [bp + 12]
selScreen       EQU     [bp + 10]
lpSaveUnder     EQU     [bp + 6]
public NvSysHideEmulatedCursor
NvSysHideEmulatedCursor PROC NEAR
        push    bp
        mov     bp, sp
        push    ds
        push    es
        push    esi
        push    edi
        push    edx
        push    ecx
        push    ebx
        mov     es, selScreen
        xor     esi, esi
        lds     si, lpSaveUnder
;
; Bound horizontal parameters to visible screen.
;
        mov     ax, xGlyphPos
        or      ax, ax
        jge     @f
        add     ax, cxGlyphWidth
        jl      HideCursorExit
        mov     cxGlyphWidth, ax
        xor     ax, ax
        mov     xGlyphPos, ax
@@:     mov     dx, cxScreenWidth
        cmp     ax, dx
        jge     HideCursorExit
        mov     cx, cxGlyphWidth
        or      cx, cx
        jz      HideCursorExit
        add     cx, ax
        cmp     cx, dx
        jl      @f
        sub     dx, ax
        mov     cxGlyphWidth, dx
@@: 
;
; Bound vertical parameters to visible screen.
;
        mov     ax, yGlyphPos
        or      ax, ax
        jge     @f
        add     ax, cyGlyphHeight
        jl      HideCursorExit
        mov     cyGlyphHeight, ax
        xor     ax, ax
        mov     yGlyphPos, ax
@@:     mov     dx, cyScreenHeight
        cmp     ax, dx
        jge     HideCursorExit
        mov     cx, cyGlyphHeight
        or      cx, cx
        jz      HideCursorExit
        add     cx, ax
        cmp     cx, dx
        jl      @f
        sub     dx, ax
        mov     cyGlyphHeight, dx
@@:
;
; Convert pixel depth into shift count.
;
        mov     cx, cScreenDepth
        shr     cx, 4
;
; Calc starting pixel position.
;
        xor     edi, edi
        xor     edx, edx
        mov     di, yGlyphPos
        mov     dx, cxScreenWidth
        imul    edi, edx
        xor     ebx, ebx
        mov     bx, xGlyphPos
        add     edi, ebx
        mov     bx, dx
        mov     dx, cxGlyphWidth
        add     edx, edi
        shl     edi, cl
        shl     edx, cl
        sub     edx, edi
        shl     ebx, cl
        mov     ax, di
        and     di, 0FFFCh
        and     ax, 03h
        add     ax, dx
        add     ax, 03h
        xor     edx, edx
        mov     dx, ax
        shr     ax, 2
        and     dl, 0FCh
        mov     cxGlyphWidth, ax
        sub     ebx, edx
        neg     edx
        add     edx, 128
;
; Loop through rows of pixel data.
;
        cld
        xor     ecx, ecx
RestoreRow:
        mov     cx, cxGlyphWidth
    rep movsd   es:[edi], [esi]
        add     edi, ebx
        add     esi, edx
        dec     WORD PTR cyGlyphHeight
        jnz     RestoreRow
;
; All done.
;        
HideCursorExit:        
        pop     ebx
        pop     ecx
        pop     edx
        pop     edi
        pop     esi
        pop     es
        pop     ds
        leave
        retf	20
NvSysHideEmulatedCursor ENDP

_TEXT           ENDS
;                END     LIBENTRY
                END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\DCIMAN.H ===
/****************************************************************************

 DCIMAN.H

 Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

#ifndef DCI_HAS_STUPID_H_FILE


extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight, 
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf, 
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

#ifdef WIN32
/****************************************************************************
 helper functions to call DCIMAN16.DLL
 ***************************************************************************/
extern void WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);


#else

extern int WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

/****************************************************************************
 helper macros to call DCI callbacks
 ***************************************************************************/
__inline void DCIDestroy(LPDCISURFACEINFO pdci)
{
	if( pdci->DestroySurface != NULL ) {
		pdci->DestroySurface(pdci);
	}
}

__inline void DCIEndAccess(LPDCISURFACEINFO pdci)
{
	if( pdci->EndAccess != NULL ) {
		pdci->EndAccess(pdci);
	}
}

__inline DCIRVAL DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy)
{
    RECT rc;

	if( pdci->BeginAccess != NULL ) {
		rc.left=x;
		rc.top=y;
		rc.right = rc.left+dx;
		rc.bottom = rc.top+dy;
		return pdci->BeginAccess(pdci, &rc);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCIDraw(LPDCIOFFSCREEN pdci)
{
	if( pdci->Draw != NULL ) {
		return pdci->Draw(pdci);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd)
{
	if( pdci->SetClipList != NULL ) {
		return pdci->SetClipList(pdci, prd);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src)
{
	if( pdci->SetDestination != NULL ) {
		return pdci->SetDestination(pdci, dst, src);
	} else {
		return DCI_OK;
	}
}
#endif
#endif // DCI_HAS_STUPID_H_FILE

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\ENVIRON.H ===
#ifndef _ENVIRON_H_
#define _ENVIRON_H_
/*************************** OS Specific Module ****************************\
*                                                                           *
* Module: ENVIRON.H                                                         *
*       WATCOM and Windows specific defines and pragmas.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)     1/06/95 - copied from nvrm.h.          *
*                                                                           *
\***************************************************************************/

#endif // _ENVIRON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll32\nvapi32.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVAPI.C                                                           *
*   This is the Windows half of the Resource Manager.  System clients call  *
*   the Resource Manager through these APIS.  The VxD calls into this       *
*   to post a message to the Windows Resource Manager EXE.                  *
*                                                                           *
\***************************************************************************/

#include <windows.h>
//
// NvClient API to Resource Manager.
//
#include <nvwin32.h>
#include <nvrmwin.h>
#include <nv_ref.h>
//#include <nvcm.h>

//
// pragmas
//
#pragma warning(disable : 4035)

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------
#define NV_CFG_VBLANK_STATUS        500
#define NV_CFG_GE_STATUS            501
#define NV_CFG_CURRENT_SCANLINE     502
#define NUM_CLIENTS                 16
#define NUM_FIFOS                   32

// need these defines for the inline assembly
#define RegEDI	16
#define RegDS	28
#define RegCS	32

//---------------------------------------------------------------------------
//
//  Typedefs.
//
//---------------------------------------------------------------------------
typedef struct _def_rmParams FAR *LPRMPARAMS;

//---------------------------------------------------------------------------
//
//  Prototypes.
//
//---------------------------------------------------------------------------

//
// Prototype of dispatch routine.
//
DWORD FAR PASCAL _Nv32Dispatch(LPRMPARAMS, DWORD);
BOOL _stdcall THK_ThunkConnect32(LPSTR, LPSTR, HINSTANCE, DWORD);
DWORD PASCAL NvSysDispatch(LPRMPARAMS, DWORD);

//---------------------------------------------------------------------------
//
//  Data.
//
//---------------------------------------------------------------------------
DWORD dll32_DeviceInstance=0;
// Linear address of the chip
DWORD *pNv = NULL;

//---------------------------------------------------------------------------
//
//  Nv non-client entrypoints.
//
//---------------------------------------------------------------------------

//
// DLL initialization and termination routine.
//
BOOL APIENTRY DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    LPSTR  lpszCmdLine
)
{
    static INT AttachCount = 0;

    if (!(THK_ThunkConnect32("NVARCH16.DLL", "NVARCH32.DLL", hInstance, dwReason)))
        return (FALSE);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ++AttachCount;
            break;
        case DLL_PROCESS_DETACH:
            //_Nv32Dispatch(&NvParams, 3);  // Don't detach since OGL is actually multiple links
            --AttachCount;
            break;
    }
    return (TRUE);
}
//
// Dispatcher to Resource Manager.
//
DWORD PASCAL _Nv32Dispatch
(
    LPRMPARAMS lpParams,
    DWORD      Function
)
{
    //
    // Copy the flat selectors to the parameter list for the 16 bit
    // dispatcher to use.
    //
    _asm mov edi, lpParams
    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov [edi].RegDS, eax
    _asm mov ax, cs
    _asm mov [edi].RegCS, eax
    _asm mov eax, dll32_DeviceInstance
    _asm mov [edi].RegEDI, eax 
    NvSysDispatch(lpParams, Function);
}

//---------------------------------------------------------------------------
//
//  Nv client entrypoints.
//
//---------------------------------------------------------------------------
int __stdcall Nv32SetDeviceInstance(DWORD DeviceHandle)
{
  dll32_DeviceInstance = DeviceHandle;
  return(0);
}

int __stdcall NvGetFlatDataSelector
(
    void
)
{
    DWORD Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}
int __stdcall NvGetFlatCodeSelector
(
    void
)
{
    DWORD Selector;

    _asm xor eax, eax
    _asm mov ax, cs
    _asm mov Selector, eax
    return (Selector);
}

//---------------------------------------------------------------------------
//
//  Nv configuration manager entrypoints.
//
//---------------------------------------------------------------------------

int __stdcall NvConfigVersion
(
    void
)
{
    RMPARAMS NvParams;

    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGVERSION);
    return (NvParams.RegEAX);
}
int __stdcall NvConfigGet
(
    DWORD Index,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    //
    // If this is a different device than the last call, flush
    // the chip pointer
    //
    if (DeviceHandle != dll32_DeviceInstance)
        pNv = NULL;
        
    Nv32SetDeviceInstance(DeviceHandle);

    //
    // Watch for indices that we want to handle right here in 32bit.  Thunking down
    // to the 16bit DLL takes too long for some DCT flipping tests that are very
    // timing sensitive.
    //
    switch (Index)
    {
        case NV_CFG_VBLANK_STATUS:
            if (pNv == NULL)
            {
                //
                // Get a pointer to this chip
                //
				NvParams.RegESI = DeviceHandle-1;
                _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSGETHWPTRS);
                pNv = (DWORD *)NvParams.RegEAX;
            }
            //
            // Grab the VBLANK status bit
            //
            NvParams.RegEAX = (((U032)*(pNv + (NV_PCRTC_RASTER/4))) & 0x00010000) >> 16;
                    
            break;
            
        case NV_CFG_CURRENT_SCANLINE:
            if (pNv == NULL)
            {
                //
                // Get a pointer to this chip
                //
				NvParams.RegESI = DeviceHandle-1;
                _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSGETHWPTRS);
                pNv = (DWORD *)NvParams.RegEAX;
            }
            //
            // Grab the current scanline value
            //
            NvParams.RegEAX = ((U032)*(pNv + (NV_PCRTC_RASTER/4))) & 0x7FF;
            break;
            
        default:
    
            NvParams.RegEAX = Index;
			NvParams.RegESI = DeviceHandle-1;
            _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGGET);
            break;
    }
            
    return (NvParams.RegEAX);
}
int __stdcall NvConfigSet
(
    DWORD Index,
    DWORD Value,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;
    
    Nv32SetDeviceInstance(DeviceHandle);

    NvParams.RegEAX = Index;
    NvParams.RegEBX = Value;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGSET);
    return (NvParams.RegEAX);
}
int __stdcall NvConfigUpdate
(
    DWORD Flag,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    Nv32SetDeviceInstance(DeviceHandle);

    NvParams.RegEAX = Flag;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGUPDATE);
    return (NvParams.RegEAX);
}

//---------------------------------------------------------------------------
//
//  Nv device manager entrypoints.
//
//---------------------------------------------------------------------------

int __stdcall NvGetHardwarePointers
(
    DWORD *pNv1,
    DWORD *pAlternate,
    DWORD *pFramebuffer,
    DWORD *pTimer
)
{
    RMPARAMS NvParams;
    
    //
    // Get all the hardware pointers.
    //
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSGETHWPTRS);
    if (pNv1)         *pNv1         = NvParams.RegEAX;
    if (pAlternate)   *pAlternate   = NvParams.RegEBX;
    if (pFramebuffer) *pFramebuffer = NvParams.RegECX;
    if (pTimer)       *pTimer       = NvParams.RegEDX;
}
int __stdcall NvDeviceBaseGet
(
    DWORD Index,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    Nv32SetDeviceInstance(DeviceHandle);

    NvParams.RegEAX = Index;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVDEVICEBASEGET);
    return (NvParams.RegEAX);
}
int __stdcall NvDeviceLimitGet
(
    DWORD Index,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    Nv32SetDeviceInstance(DeviceHandle);
    
    NvParams.RegEAX = Index;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVDEVICELIMITGET);
    return (NvParams.RegEAX);
}
int __stdcall NvDeviceSelectorGet
(
    DWORD Index
)
{
    RMPARAMS NvParams;

    NvParams.RegEAX = Index;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVDEVICESELECTORGET);
    return (NvParams.RegEAX);
}

//---------------------------------------------------------------------------
//
//  Nv system DLL entrypoints.
//
//---------------------------------------------------------------------------

void __stdcall NvSysShowHideCursor
(
    int HideShow
)
{
    RMPARAMS NvParams;

    NvParams.RegEAX = HideShow;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSSHOWHIDECRSR);
}

int __stdcall NvDmaPushOperation
(
    U032  flags,
    VOID  *pDmaPushInfo,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;
    
    Nv32SetDeviceInstance(DeviceHandle);

	NvParams.RegESI = DeviceHandle-1;
    NvParams.RegEAX = NVRM_API_DMAPUSH_OPERATION;
    NvParams.RegEBX = flags;
    NvParams.RegECX = (U032) pDmaPushInfo;
    NvParams.RegES  = NvGetFlatDataSelector();

    _Nv32Dispatch(&NvParams, 0);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\STDDEF.H ===
/*
 *  stddef.h	Standard definitions
 *
 *  Copyright by WATCOM International Corp. 1988-1994.  All rights reserved.
 */
#ifndef _STDDEF_H_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#ifndef _SIZE_T_DEFINED_
#define _SIZE_T_DEFINED_
 typedef unsigned size_t;
#endif

#ifndef _WCHAR_T_DEFINED_
#define _WCHAR_T_DEFINED_
#ifdef __cplusplus
typedef long char wchar_t;
#else
typedef unsigned short wchar_t;
#endif
#endif

#ifndef NULL
 #if defined(__SMALL__) || defined(__MEDIUM__) || defined(__386__)
  #define NULL   0
 #else
  #define NULL   0L
 #endif
#endif

#ifndef _PTRDIFF_T_DEFINED_
#define _PTRDIFF_T_DEFINED_
 #if defined(__HUGE__)
  typedef long	ptrdiff_t;
 #else
  typedef int	ptrdiff_t;
 #endif
#endif

#ifdef __cplusplus
#define offsetof __offsetof
#else
#define offsetof(typ,id) (size_t)&(((typ*)0)->id)
#endif
#if !defined(NO_EXT_KEYS) /* extensions enabled */
#ifdef __386__
 extern int *__threadid(void);	/* pointer to thread id */
 #define _threadid (__threadid())
#else
 extern int __far *_threadid;			/* pointer to thread id */
#endif
#endif
#define _STDDEF_H_INCLUDED
#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\DCIDDI.H ===
/*******************************************************************
 *
 *	FILE:		dciddi.h
 *	
 *	DESCRIPTION:	definitions for MS/Intel-defined DCI interface
 *
 *	Copyright (C) 1994 Intel/Microsoft Corporation.  All Rights Reserved.
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */                                                               
#define DCICOMMAND			3075
#define DCI_VERSION			0x0100

#define DCICREATEPRIMARYSURFACE		1 
#define DCICREATEOFFSCREENSURFACE       2 
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4 
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                              	0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4    

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN			    -17
#define DCI_ERR_YALIGN			    -18
#define DCI_ERR_XYALIGN			    -19
#define DCI_ERR_WIDTHALIGN		    -20
#define DCI_ERR_HEIGHTALIGN		    -21
											 
/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16				
#define DCI_STATUS_WASSTILLDRAWING         32


/* DCI Capability Flags */
#define DCI_SURFACE_TYPE			0x0000000F
#define DCI_PRIMARY                 		0x00000000
#define DCI_OFFSCREEN               		0x00000001
#define DCI_OVERLAY                 		0x00000002

#define DCI_VISIBLE                 		0x00000010
#define DCI_CHROMAKEY               		0x00000020
#define DCI_1632_ACCESS             		0x00000040
#define DCI_DWORDSIZE               		0x00000080
#define DCI_DWORDALIGN              		0x00000100
#define DCI_WRITEONLY               		0x00000200
#define DCI_ASYNC                   		0x00000400

#define DCI_CAN_STRETCHX            		0x00001000
#define DCI_CAN_STRETCHY            		0x00002000
#define DCI_CAN_STRETCHXY           		(DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN           		0x00004000
#define DCI_CAN_STRETCHYN           		0x00008000
#define DCI_CAN_STRETCHXYN          		(DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

#ifndef DCI_HAS_STUPID_H_FILE

/**************************************************************************
 *	input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the 
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
	DWORD	dwCommand;
	DWORD	dwParam1;
	DWORD 	dwParam2;
	DWORD	dwVersion;
	DWORD	dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for 
 * the DCICREATE... calls.  The fields that are actually relevant differ for 
 * each of the three calls.  Details are in the DCI Spec chapter providing 
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
	DCICMD	cmd;							/* common header structure */
	DWORD   dwCompression;          		/* format of surface to be created                      */
	DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
	DWORD   dwWidth;                        /* height of the surface to be created          */
	DWORD   dwHeight;                       /* width of input surfaces                                      */
	DWORD	dwDCICaps;						/* capabilities of surface wanted */
	DWORD	dwBitCount;					/* bit depth of format to be created */
	LPVOID  lpSurface;                      /* pointer to an associated surface             */      
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;
		

/*
 * This structure is used by a DCI client to provide input parameters for the 
 * DCIEnumSurface call.
 */
typedef struct _DCIENUMINPUT {
	DCICMD	cmd;							/* common header structure */
	RECT    rSrc;                           /* source rect. for stretch  */
	RECT    rDst;                           /* dest. rect. for stretch       */
	void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
	LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;

/**************************************************************************
 *	surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary 
 * surface, and as a member of the larger structures returned by the 
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
	DWORD   dwSize;                 	/* size of structure                                            */
	DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
	DWORD   dwCompression;          	/* format of surface to be created                      */
	DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

	DWORD   dwWidth;                    /* width of surface                                             */
	DWORD   dwHeight;                   /* height of surface                                            */
	LONG    lStride;                    /* distance in bytes betw. one pixel            */
										/* and the pixel directly below it                      */
	DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
	DWORD   dwOffSurface;               /* offset of surface pointer                            */
	WORD    wSelSurface;                /* selector of surface pointer                          */
	WORD    wReserved;					

	DWORD   dwReserved1;                /* reserved for provider */
	DWORD   dwReserved2;                /* reserved for DCIMAN */     
	DWORD   dwReserved3;                /* reserved for future */     
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
	void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */      
	void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;

/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;
								   
/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

	DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

	DCISURFACEINFO  dciInfo;                                                /* surface info                  */
	DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
	DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */                    

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')                                             
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#endif // DCI_HAS_STUPID_H_FILE

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\W32SUT.H ===
/***
*w32sut.h -
*
*       Copyright (c) 1987-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file declares the constants, structures, and functions
*       used for accessing and using the Universal Thunk mechanism.
*
*       This file should be compiled either with constants W32SUT_16 or
*       W32SUT_32 defined.
*
****/

/* Check that one of the 2 constants is defined  */
#ifdef W32SUT_16
#ifdef W32SUT_32
#error W32SUT_16 and W32SUT_32 cannot be defined simultaneously
#endif
#endif

#ifndef W32SUT_16
#ifndef W32SUT_32
#error  Either W32SUT_16 or W32SUT_32 should be defined
#endif
#endif


/****      Prototypes for 32 bit DLL   ***********/
#ifdef W32SUT_32

typedef DWORD  ( WINAPI * UT32PROC)( LPVOID lpBuff,
                                     DWORD  dwUserDefined,
                                     LPVOID *lpTranslationList
                                   );

BOOL    WINAPI UTRegister( HANDLE     hModule,
                           LPCSTR     lpsz16BitDLL,
                           LPCSTR     lpszInitName,
                           LPCSTR     lpszProcName,
                           UT32PROC * ppfn32Thunk,
                           FARPROC    pfnUT32Callback,
                           LPVOID     lpBuff
                         );


VOID    WINAPI UTUnRegister(HANDLE hModule);

#endif


/****      Prototypes for 16 bit DLL   ***********/
#ifdef W32SUT_16

typedef DWORD (FAR PASCAL  * UT16CBPROC)( LPVOID lpBuff,
                                          DWORD  dwUserDefined,
                                          LPVOID FAR *lpTranslationList
                                        );


LPVOID  WINAPI  UTLinearToSelectorOffset(LPBYTE lpByte);
LPVOID  WINAPI  UTSelectorOffsetToLinear(LPBYTE lpByte);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\VER.H ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\WINDOWS.H ===
/****************************************************************************
 *
 *  WINDOWS.H - 
 *	
 *	Include file for Windows 3.0 applications
 *
 *  Copyright by WATCOM International Corp. 1988-1994.  All rights reserved.
 *
 ****************************************************************************/

#ifdef _WINDOWS_16_
#include <win16.h>
#else
#include <_win386.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\WIN16.H ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID		    void

#define FAR                 __far
#define NEAR		    __near
#define PASCAL		    __pascal
#define CDECL		    __cdecl

#define WINAPI              __far __pascal
#define CALLBACK            __far __pascal

/****** Simple types & common helper macros *********************************/

typedef int		    BOOL;
#define FALSE		    0
#define TRUE		    1

typedef unsigned char	    BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int	    UINT;

#ifdef STRICT
typedef signed long	    LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)	((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)	((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL		    0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;


typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*	    PBYTE;
typedef BYTE FAR*	    LPBYTE;

typedef int NEAR*	    PINT;
typedef int FAR*	    LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*	    PLONG;
typedef long FAR*	    LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE* 	    PHANDLE;
typedef HANDLE NEAR*	    SPHANDLE;
typedef HANDLE FAR*	    LPHANDLE;

typedef HANDLE		    HGLOBAL;
typedef HANDLE		    HLOCAL;

typedef HANDLE		    GLOBALHANDLE;
typedef HANDLE		    LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE	0x0001
#define WF_CPU286	0x0002
#define WF_CPU386	0x0004
#define WF_CPU486	0x0008
#define WF_STANDARD	0x0010
#define WF_WIN286	0x0010
#define WF_ENHANCED	0x0020
#define WF_WIN386	0x0020
#define WF_CPU086	0x0040
#define WF_CPU186	0x0080
#define WF_LARGEFRAME	0x0100
#define WF_SMALLFRAME	0x0200
#define WF_80x87	0x0400
#define WF_PAGING	0x0800
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

#define ERR_SIZE_MASK		0x3000
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069


/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR __cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)


HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define	WEP_SYSTEM_EXIT	1
#define	WEP_FREE_DLL	0

/****** Task Management *****************************************************/

#endif	/* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);


/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND		    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR		    (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND		    (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		    (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND	    (LMEM_MOVEABLE)
#define NONZEROLPTR	    (LMEM_FIXED)


#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ 	    0x0000
#define OF_WRITE	    0x0001
#define OF_READWRITE	    0x0002
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	    0x0100
#define OF_DELETE	    0x0200
#define OF_VERIFY	    0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH	    0x0400	/* Used without OF_REOPEN */
#define OF_CANCEL	    0x0800
#define OF_CREATE	    0x1000
#define OF_PROMPT	    0x2000
#define OF_EXIST	    0x4000
#define OF_REOPEN	    0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ	    0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long	WINAPI _hread(HFILE, void _huge*, long);
long	WINAPI _hwrite(HFILE, const void _huge*, long);
#endif	/* WINVER >= 0x030a */


#endif	/* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE	    (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection errors */
#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)	    GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR	    MAKEINTRESOURCE(1)
#define RT_BITMAP	    MAKEINTRESOURCE(2)
#define RT_ICON 	    MAKEINTRESOURCE(3)
#define RT_MENU 	    MAKEINTRESOURCE(4)
#define RT_DIALOG	    MAKEINTRESOURCE(5)
#define RT_STRING	    MAKEINTRESOURCE(6)
#define RT_FONTDIR	    MAKEINTRESOURCE(7)
#define RT_FONT 	    MAKEINTRESOURCE(8)
#define RT_ACCELERATOR	    MAKEINTRESOURCE(9)
#define RT_RCDATA	    MAKEINTRESOURCE(10)

#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON	    MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE	    32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI	    32737
#define OBM_DNARROWI	    32736
#define OBM_RGARROWI	    32735
#define OBM_LFARROWI	    32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL	    32512
#define OCR_IBEAM	    32513
#define OCR_WAIT	    32514
#define OCR_CROSS	    32515
#define OCR_UP		    32516
#define OCR_SIZE	    32640
#define OCR_ICON	    32641
#define OCR_SIZENWSE	    32642
#define OCR_SIZENESW	    32643
#define OCR_SIZEWE	    32644
#define OCR_SIZENS	    32645
#define OCR_SIZEALL	    32646
#define OCR_ICOCUR	    32647

#define OIC_SAMPLE	    32512
#define OIC_HAND	    32513
#define OIC_QUES	    32514
#define OIC_BANG	    32515
#define OIC_NOTE	    32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE	    0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);


#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif	/* WINVER >= 0x030a */
#endif	/* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif	/* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef	NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif	/* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)	    (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY	DCB_ACCUMULATE
#define DCB_SET 	(DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);


/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR		   0
#define COLOR_BACKGROUND	   1
#define COLOR_ACTIVECAPTION	   2
#define COLOR_INACTIVECAPTION	   3
#define COLOR_MENU		   4
#define COLOR_WINDOW		   5
#define COLOR_WINDOWFRAME	   6
#define COLOR_MENUTEXT		   7
#define COLOR_WINDOWTEXT	   8
#define COLOR_CAPTIONTEXT  	   9
#define COLOR_ACTIVEBORDER	  10
#define COLOR_INACTIVEBORDER	  11
#define COLOR_APPWORKSPACE	  12
#define COLOR_HIGHLIGHT		  13
#define COLOR_HIGHLIGHTTEXT	  14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT		  18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN 	    1
#define OBJ_BRUSH	    2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID	    0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL 	    5
#define PS_INSIDEFRAME 	    6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4
#define	BS_DIBPATTERN	    5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH	    PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif	/* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR		    0
#define NULLREGION	    1
#define SIMPLEREGION	    2
#define COMPLEXREGION	    3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND 	    1
#define RGN_OR		    2
#define RGN_XOR 	    3
#define RGN_DIFF	    4
#define RGN_COPY	    5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED	0x01	/* palette index used for animation */
#define PC_EXPLICIT	0x02	/* palette index is explicit to device */
#define	PC_NOCOLLAPSE	0x04	/* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define	SYSPAL_STATIC	1
#define	SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);


/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);


/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED	0x0001
#define ETO_OPAQUE	0x0002
#define ETO_CLIPPED	0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP		    0x0000
#define DT_LEFT 	    0x0000
#define DT_CENTER	    0x0001
#define DT_RIGHT	    0x0002
#define DT_VCENTER	    0x0004
#define DT_BOTTOM	    0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE	    0x0020
#define DT_EXPANDTABS	    0x0040
#define DT_TABSTOP	    0x0080
#define DT_NOCLIP	    0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT	    0x0400
#define DT_NOPREFIX	    0x0800
#define DT_INTERNAL	    0x1000

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP		     0x0000
#define TA_UPDATECP		     0x0001
#define TA_LEFT 		     0x0000
#define TA_RIGHT		     0x0002
#define TA_CENTER		     0x0006
#define TA_TOP			     0x0000
#define TA_BOTTOM		     0x0008
#define TA_BASELINE		     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE	    32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE	    0
#define FW_THIN 	    100
#define FW_EXTRALIGHT	    200
#define FW_LIGHT	    300
#define FW_NORMAL	    400
#define FW_MEDIUM	    500
#define FW_SEMIBOLD	    600
#define FW_BOLD 	    700
#define FW_EXTRABOLD	    800
#define FW_HEAVY	    900

#define FW_ULTRALIGHT	    FW_EXTRALIGHT
#define FW_REGULAR	    FW_NORMAL
#define FW_DEMIBOLD	    FW_SEMIBOLD
#define FW_ULTRABOLD	    FW_EXTRABOLD
#define FW_BLACK	    FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET	    0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET	    2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET	    255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS		4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK		0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES		0x10
#define CLIP_TT_ALWAYS		0x20
#define CLIP_EMBEDDED		0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT	    10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT	    12
#define SYSTEM_FONT	    13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING	     0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE	    0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif	/* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR	    0x02
#define TMPF_DEVICE	    0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE	    0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR	0x00000040L
#define NTM_BOLD	0x00000020L
#define NTM_ITALIC	0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL	WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE	0x0001
#define TT_ENABLED	0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD	     bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE	     bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;


HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif	/* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif	/* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0410
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F

#define	META_CHORD		     0x0830
#define	META_SETMAPPERFLAGS	     0x0231
#define	META_EXTTEXTOUT		     0x0a32
#define	META_SETDIBTODEV	     0x0d33
#define	META_SELECTPALETTE	     0x0234
#define	META_REALIZEPALETTE	     0x0035
#define	META_ANIMATEPALETTE	     0x0436
#define	META_SETPALENTRIES	     0x0037
#define	META_POLYPOLYGON	     0x0538
#define	META_RESIZEPALETTE	     0x0139

#define	META_DIBBITBLT		     0x0940
#define	META_DIBSTRETCHBLT	     0x0b41
#define	META_DIBCREATEPATTERNBRUSH   0x0142
#define	META_STRETCHDIB		     0x0f43

#define META_EXTFLOODFILL	     0x0548

#define META_RESETDC		     0x014C
#define META_STARTDOC		     0x014D
#define META_STARTPAGE		     0x004F
#define META_ENDPAGE		     0x0050
#define META_ABORTDOC		     0x0052
#define META_ENDDOC		     0x005E

#define	META_DELETEOBJECT	     0x01f0

#define	META_CREATEPALETTE	     0x00f7
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED		     0x4000
#define SP_ERROR		     (-1)
#define SP_APPABORT		     (-2)
#define SP_USERABORT		     (-3)
#define SP_OUTOFDISK		     (-4)
#define SP_OUTOFMEMORY		     (-5)

#define PR_JOBSTATUS		     0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS	    0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETABORTPROC		     9
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define MOUSETRAILS		     39

#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;	    /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	     0
#define SM_CYSCREEN	     1
#define SM_CXVSCROLL	     2
#define SM_CYHSCROLL	     3
#define SM_CYCAPTION	     4
#define SM_CXBORDER	     5
#define SM_CYBORDER	     6
#define SM_CXDLGFRAME	     7
#define SM_CYDLGFRAME	     8
#define SM_CYVTHUMB	     9
#define SM_CXHTHUMB	     10
#define SM_CXICON	     11
#define SM_CYICON	     12
#define SM_CXCURSOR	     13
#define SM_CYCURSOR	     14
#define SM_CYMENU	     15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL	     20
#define SM_CXHSCROLL	     21
#define SM_DEBUG	     22
#define SM_SWAPBUTTON	     23
#define SM_RESERVED1	     24
#define SM_RESERVED2	     25
#define SM_RESERVED3	     26
#define SM_RESERVED4	     27
#define SM_CXMIN	     28
#define SM_CYMIN	     29
#define SM_CXSIZE	     30
#define SM_CYSIZE	     31
#define SM_CXFRAME	     32
#define SM_CYFRAME	     33
#define SM_CXMINTRACK	     34
#define SM_CYMINTRACK	     35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_CMETRICS	     43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE	    0x001E

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP		    1
#define SPI_SETBEEP		    2
#define SPI_GETMOUSE		    3
#define SPI_SETMOUSE		    4
#define SPI_GETBORDER		    5
#define SPI_SETBORDER		    6
#define SPI_GETKEYBOARDSPEED	    10
#define SPI_SETKEYBOARDSPEED	    11
#define SPI_LANGDRIVER		    12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY	    18
#define SPI_SETGRIDGRANULARITY	    19
#define SPI_SETDESKWALLPAPER	    20
#define SPI_SETDESKPATTERN	    21
#define SPI_GETKEYBOARDDELAY	    22
#define SPI_SETKEYBOARDDELAY	    23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP	    25
#define SPI_SETICONTITLEWRAP	    26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH	    29
#define SPI_SETDOUBLECLKHEIGHT	    30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME	    32
#define SPI_SETMOUSEBUTTONSWAP	    33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE	    0x0001
#define SPIF_SENDWININICHANGE	    0x0002

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL		    0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER		    0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND	hwnd;
    UINT        message;
    WPARAM	wParam;
    LPARAM	lParam;
    DWORD       time;
    POINT	pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE	0x0000
#define PM_REMOVE	0x0001
#define PM_NOYIELD	0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY		0x0001
#define QS_MOUSEMOVE	0x0002
#define QS_MOUSEBUTTON	0x0004
#define QS_MOUSE	(QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE	0x0008
#define QS_TIMER	0x0010
#define QS_PAINT	0x0020
#define QS_SENDMESSAGE	0x0040

#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST	((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE	    3

#define WH_CALLWNDPROC	    4

#define WH_MSGFILTER	    (-1)
#define WH_SYSMSGFILTER	    6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX		 0
#define MSGF_MENU		 2
#define MSGF_MOVE		 3
#define MSGF_SIZE		 4
#define MSGF_SCROLLBAR		 5
#define MSGF_NEXTWINDOW 	 6
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST	    0x0380
#define WM_PENWINLAST	    0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F


#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER	    0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION	    0x0016

#define WM_QUIT		    0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR	    0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC	lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE	hInstance;
    HICON	hIcon;
    HCURSOR	hCursor;
    HBRUSH	hbrBackground;
    LPCSTR	lpszMenuName;
    LPCSTR	lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW	    0x0001
#define CS_HREDRAW	    0x0002

#define CS_OWNDC	    0x0020
#define CS_CLASSDC	    0x0040
#define CS_PARENTDC	    0x0080

#define CS_SAVEBITS	    0x0800

#define CS_DBLCLKS	    0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE	    0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT	    0x0100

#define CS_GLOBALCLASS	    0x4000
#endif	/* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME	    (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR	    (-12)
#define GCW_HICON	    (-14)
#define GCW_HMODULE	    (-16)
#define GCW_CBWNDEXTRA	    (-18)
#define GCW_CBCLSEXTRA	    (-20)
#define GCL_WNDPROC	    (-24)
#define GCW_STYLE	    (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif	/* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED	    0x00000000L
#define WS_POPUP	    0x80000000L
#define WS_CHILD	    0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE	    0x10000000L
#define WS_DISABLED	    0x08000000L

/* Main window states */
#define WS_MINIMIZE	    0x20000000L
#define WS_MAXIMIZE	    0x01000000L

/* Main window styles */
#define WS_CAPTION	    0x00C00000L     /* WS_BORDER | WS_DLGFRAME	*/
#define WS_BORDER	    0x00800000L
#define WS_DLGFRAME	    0x00400000L
#define WS_VSCROLL	    0x00200000L
#define WS_HSCROLL	    0x00100000L
#define WS_SYSMENU	    0x00080000L
#define WS_THICKFRAME	    0x00040000L
#define WS_MINIMIZEBOX	    0x00020000L
#define WS_MAXIMIZEBOX	    0x00010000L

/* Control window styles */
#define WS_GROUP	    0x00020000L
#define WS_TABSTOP	    0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW	    (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	    (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST	     0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED	    WS_OVERLAPPED
#define WS_ICONIC	    WS_MINIMIZE
#define WS_SIZEBOX	    WS_THICKFRAME
#define WS_TILEDWINDOW	    WS_OVERLAPPEDWINDOW


#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE	    0x0001
#define WM_NCCREATE	    0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY	    0x0002
#define WM_NCDESTROY	    0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);


#ifndef NOSHOWWINDOW

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW	    0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW	    0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM	    SW_OTHERRESTORED
#endif	/* NOSHOWWINDOW */

#define WM_SETREDRAW	    0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE	    0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT	    0x000C
#define WM_GETTEXT	    0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	    (-4)
#define GWW_HINSTANCE	    (-6)
#define GWW_HWNDPARENT	    (-8)
#define GWW_ID		    (-12)
#define GWL_STYLE	    (-16)
#define GWL_EXSTYLE	    (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT	    ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE	    0x0001
#define SWP_NOMOVE	    0x0002
#define SWP_NOZORDER	    0x0004
#define SWP_NOREDRAW	    0x0008
#define SWP_NOACTIVATE	    0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW	    0x0040
#define SWP_HIDEWINDOW	    0x0080
#define SWP_NOCOPYBITS	    0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME	    SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM	    ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE		    0x0003
#define WM_SIZE		    0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED	    0
#define SIZE_MINIMIZED	    1
#define SIZE_MAXIMIZED	    2
#define SIZE_MAXSHOW	    3
#define SIZE_MAXHIDE	    4

/* Obsolete constant names */
#define SIZENORMAL	    SIZE_RESTORED
#define SIZEICONIC	    SIZE_MINIMIZED
#define SIZEFULLSCREEN	    SIZE_MAXIMIZED
#define SIZEZOOMSHOW	    SIZE_MAXSHOW
#define SIZEZOOMHIDE	    SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN	    0x0013
#define WM_CLOSE	    0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024


BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER	4
#define GW_CHILD	5


/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW	    0x00000001L
#define DCX_CACHE	    0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP	    0x00000020L

#define DCX_EXCLUDERGN	    0x00000040L
#define DCX_INTERSECTRGN    0x00000080L


#define DCX_LOCKWINDOWUPDATE 0x00000400L


#define DCX_USESTYLE	    0x00010000L

#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT	    0x000F
#define WM_ERASEBKGND	    0x0014
#define WM_ICONERASEBKGND   0x0027

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC 	hdc;
    BOOL	fErase;
    RECT	rcPaint;
    BOOL	fRestore;
    BOOL	fIncUpdate;
    BYTE	rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE		0x0001
#define RDW_INTERNALPAINT	0x0002
#define RDW_ERASE		0x0004

#define RDW_VALIDATE		0x0008
#define RDW_NOINTERNALPAINT	0x0010
#define RDW_NOERASE		0x0020

#define RDW_NOCHILDREN		0x0040
#define RDW_ALLCHILDREN 	0x0080

#define RDW_UPDATENOW		0x0100
#define RDW_ERASENOW		0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004


#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT	    0x0085

#define WM_NCCALCSIZE	    0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP	    0x0010
#define WVR_ALIGNLEFT	    0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT	    0x0080
#define WVR_HREDRAW	    0x0100
#define WVR_VREDRAW	    0x0200
#define WVR_REDRAW	    (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS	    0x0400


/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT	   rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST	    0x0084

/* WM_NCHITTEST return codes */
#define HTERROR 	    (-2)
#define HTTRANSPARENT	    (-1)
#define HTNOWHERE	    0
#define HTCLIENT	    1
#define HTCAPTION	    2
#define HTSYSMENU	    3
#define HTSIZE		    4
#define HTMENU		    5
#define HTHSCROLL	    6
#define HTVSCROLL	    7
#define HTMINBUTTON	    8
#define HTMAXBUTTON	    9
#define HTLEFT		    10
#define HTRIGHT 	    11
#define HTTOP		    12
#define HTTOPLEFT	    13
#define HTTOPRIGHT	    14
#define HTBOTTOM	    15
#define HTBOTTOMLEFT	    16
#define HTBOTTOMRIGHT	    17
#define HTBORDER	    18
#define HTGROWBOX	    HTSIZE
#define HTREDUCE	    HTMINBUTTON
#define HTZOOM		    HTMAXBUTTON

/****** Drag-and-drop support ***********************************************/

#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES	    0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE	    0
#define WA_ACTIVE	    1
#define WA_CLICKACTIVE	    2

#define WM_ACTIVATE	    0x0006
#define WM_ACTIVATEAPP	    0x001C
#define WM_NCACTIVATE	    0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101

#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103

#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105

#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107


/* Keyboard message range */
#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED	    0x0100
#define KF_DLGMODE	    0x0800
#define KF_MENUMODE	    0x1000
#define KF_ALTDOWN	    0x2000
#define KF_REPEAT	    0x4000
#define KF_UP		    0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON	    0x01
#define VK_RBUTTON	    0x02
#define VK_CANCEL	    0x03
#define VK_MBUTTON          0x04
#define VK_BACK 	    0x08
#define VK_TAB		    0x09
#define VK_CLEAR	    0x0C
#define VK_RETURN	    0x0D
#define VK_SHIFT	    0x10
#define VK_CONTROL	    0x11
#define VK_MENU 	    0x12
#define VK_PAUSE	    0x13
#define VK_CAPITAL	    0x14
#define VK_ESCAPE	    0x1B
#define VK_SPACE	    0x20
#define VK_PRIOR	    0x21
#define VK_NEXT 	    0x22
#define VK_END		    0x23
#define VK_HOME 	    0x24
#define VK_LEFT 	    0x25
#define VK_UP		    0x26
#define VK_RIGHT	    0x27
#define VK_DOWN 	    0x28
#define VK_SELECT	    0x29
#define VK_PRINT	    0x2A
#define VK_EXECUTE	    0x2B
#define VK_SNAPSHOT	    0x2C
#define VK_INSERT	    0x2D
#define VK_DELETE	    0x2E
#define VK_HELP 	    0x2F
#define VK_NUMPAD0	    0x60
#define VK_NUMPAD1	    0x61
#define VK_NUMPAD2	    0x62
#define VK_NUMPAD3	    0x63
#define VK_NUMPAD4	    0x64
#define VK_NUMPAD5	    0x65
#define VK_NUMPAD6	    0x66
#define VK_NUMPAD7	    0x67
#define VK_NUMPAD8	    0x68
#define VK_NUMPAD9	    0x69
#define VK_MULTIPLY	    0x6A
#define VK_ADD		    0x6B
#define VK_SEPARATOR	    0x6C
#define VK_SUBTRACT	    0x6D
#define VK_DECIMAL	    0x6E
#define VK_DIVIDE	    0x6F
#define VK_F1		    0x70
#define VK_F2		    0x71
#define VK_F3		    0x72
#define VK_F4		    0x73
#define VK_F5		    0x74
#define VK_F6		    0x75
#define VK_F7		    0x76
#define VK_F8		    0x77
#define VK_F9		    0x78
#define VK_F10		    0x79
#define VK_F11		    0x7A
#define VK_F12		    0x7B
#define VK_F13		    0x7C
#define VK_F14		    0x7D
#define VK_F15		    0x7E
#define VK_F16		    0x7F
#define VK_F17		    0x80
#define VK_F18		    0x81
#define VK_F19		    0x82
#define VK_F20		    0x83
#define VK_F21		    0x84
#define VK_F22		    0x85
#define VK_F23		    0x86
#define VK_F24		    0x87
#define VK_NUMLOCK	    0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD	    2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE	    0x0200
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON	    0x0001
#define MK_RBUTTON	    0x0002
#define MK_SHIFT	    0x0004
#define MK_CONTROL	    0x0008
#define MK_MBUTTON	    0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE	    0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP	    0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP	    0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP	    0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE	    7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif	/* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE	    0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER	    0x0113

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT	    0x0000
#define MF_CHANGE	    0x0080
#define MF_APPEND	    0x0100
#define MF_DELETE	    0x0200
#define MF_REMOVE	    0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND	    0x0000
#define MF_BYPOSITION	    0x0400

#define MF_SEPARATOR	    0x0800

#define MF_ENABLED	    0x0000
#define MF_GRAYED	    0x0001
#define MF_DISABLED	    0x0002

#define MF_UNCHECKED	    0x0000
#define MF_CHECKED	    0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING	    0x0000
#define MF_BITMAP	    0x0004
#define MF_OWNERDRAW	    0x0100

#define MF_POPUP	    0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK	    0x0040

#define MF_UNHILITE	    0x0000
#define MF_HILITE	    0x0080

#define MF_SYSMENU	    0x2000
#define MF_HELP 	    0x4000
#define MF_MOUSESELECT	    0x8000


#define MF_END		    0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT	    0x011F
#define WM_MENUCHAR	    0x0120

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND	    0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP	    0
#define SB_LINELEFT	    0
#define SB_LINEDOWN	    1
#define SB_LINERIGHT	    1
#define SB_PAGEUP	    2
#define SB_PAGELEFT	    2
#define SB_PAGEDOWN	    3
#define SB_PAGERIGHT	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_LEFT 	    6
#define SB_BOTTOM	    7
#define SB_RIGHT	    7
#define SB_ENDSCROLL	    8

/* Scroll bar selection constants */
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT 	     1
#define CF_BITMAP	     2
#define CF_METAFILEPICT      3
#define CF_SYLK 	     4
#define CF_DIF		     5
#define CF_TIFF 	     6
#define CF_OEMTEXT	     7
#define CF_DIB		     8
#define CF_PALETTE	     9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW	    MAKEINTRESOURCE(32512)
#define IDC_IBEAM	    MAKEINTRESOURCE(32513)
#define IDC_WAIT	    MAKEINTRESOURCE(32514)
#define IDC_CROSS	    MAKEINTRESOURCE(32515)
#define IDC_UPARROW	    MAKEINTRESOURCE(32516)
#define IDC_SIZE	    MAKEINTRESOURCE(32640)
#define IDC_ICON	    MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	    MAKEINTRESOURCE(32644)
#define IDC_SIZENS	    MAKEINTRESOURCE(32645)

#define WM_SETCURSOR	    0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND	    MAKEINTRESOURCE(32513)
#define IDI_QUESTION	    MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	    MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005
#define MB_TYPEMASK	    0x000F

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK	    0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200
#define MB_DEFMASK	    0x0F00

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000



#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND	0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_TASKLIST	0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM 	SC_MAXIMIZE


#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE	    0x0220
#define WM_MDIDESTROY	    0x0221
#define WM_MDIACTIVATE	    0x0222
#define WM_MDIRESTORE	    0x0223
#define WM_MDINEXT	    0x0224
#define WM_MDIMAXIMIZE	    0x0225
#define WM_MDITILE	    0x0226
#define WM_MDICASCADE	    0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU	    0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL	0x0000
#define MDITILE_HORIZONTAL	0x0001
#define MDITILE_SKIPDISABLED	0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG	(MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA	30

/* Dialog styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID	    (WM_USER+0)
#define DM_SETDEFID	    (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID	    0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG	    0x0110
#define WM_NEXTDLGCTL	    0x0028

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE	    0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT	0
#define DWL_DLGPROC	4
#define DWL_USER	8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE	    0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR	    0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT	    1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN	    3
#define CTLCOLOR_DLG	    4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6

#define WM_SETFONT          0x0030
#define WM_GETFONT	    0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK		    1
#define IDCANCEL	    2
#define IDABORT 	    3
#define IDRETRY 	    4
#define IDIGNORE	    5
#define IDYES		    6
#define IDNO		    7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU	1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

/* Owner draw actions */
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT	0x0002
#define ODA_FOCUS	0x0004

/* Owner draw state */
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS	0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND	hwndItem;
    HDC		hDC;
    RECT	rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM	    0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND	hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT 	    0x00000000L
#define SS_CENTER	    0x00000001L
#define SS_RIGHT	    0x00000002L
#define SS_ICON 	    0x00000003L
#define SS_BLACKRECT	    0x00000004L
#define SS_GRAYRECT	    0x00000005L
#define SS_WHITERECT	    0x00000006L
#define SS_BLACKFRAME	    0x00000007L
#define SS_GRAYFRAME	    0x00000008L
#define SS_WHITEFRAME	    0x00000009L
#define SS_SIMPLE	    0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON	    (WM_USER+0)
#define STM_GETICON	    (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON	    0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX	    0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON	    0x00000004L
#define BS_3STATE	    0x00000005L
#define BS_AUTO3STATE	    0x00000006L
#define BS_GROUPBOX	    0x00000007L
#define BS_USERBUTTON	    0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW	    0x0000000BL
#define BS_LEFTTEXT	    0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK	    (WM_USER+0)
#define BM_SETCHECK	    (WM_USER+1)
#define BM_GETSTATE	    (WM_USER+2)
#define BM_SETSTATE	    (WM_USER+3)
#define BM_SETSTYLE	    (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED	    0
#define BN_PAINT	    1
#define BN_HILITE	    2
#define BN_UNHILITE	    3
#define BN_DISABLE	    4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT 	    0x00000000L
#define ES_CENTER	    0x00000001L
#define ES_RIGHT	    0x00000002L
#define ES_MULTILINE	    0x00000004L
#define ES_UPPERCASE	    0x00000008L
#define ES_LOWERCASE	    0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL	    0x00000040L
#define ES_AUTOHSCROLL	    0x00000080L
#define ES_NOHIDESEL	    0x00000100L
#define ES_OEMCONVERT	    0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY	    0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL	        (WM_USER+0)
#define EM_SETSEL	        (WM_USER+1)
#define EM_GETRECT	        (WM_USER+2)
#define EM_SETRECT	        (WM_USER+3)
#define EM_SETRECTNP	        (WM_USER+4)
#define EM_LINESCROLL	        (WM_USER+6)
#define EM_GETMODIFY	        (WM_USER+8)
#define EM_SETMODIFY	        (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX	        (WM_USER+11)
#define EM_SETHANDLE	        (WM_USER+12)
#define EM_GETHANDLE	        (WM_USER+13)
#define EM_LINELENGTH	        (WM_USER+17)
#define EM_REPLACESEL	        (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE	        (WM_USER+20)
#define EM_LIMITTEXT	        (WM_USER+21)
#define EM_CANUNDO	        (WM_USER+22)
#define EM_UNDO 	        (WM_USER+23)
#define EM_FMTLINES	        (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS	        (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE	(WM_USER+30)
#define EM_SETREADONLY	        (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT		   0
#define WB_RIGHT	   1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	      0x0001L
#define LBS_SORT	      0x0002L
#define LBS_NOREDRAW	      0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD	      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	       (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL	       (WM_USER+6)
#define LB_SETCURSEL	       (WM_USER+7)
#define LB_GETSEL	       (WM_USER+8)
#define LB_GETCURSEL	       (WM_USER+9)
#define LB_GETTEXT	       (WM_USER+10)
#define LB_GETTEXTLEN	       (WM_USER+11)
#define LB_GETCOUNT	       (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR		       (WM_USER+14)
#define LB_GETTOPINDEX	       (WM_USER+15)
#define LB_FINDSTRING	       (WM_USER+16)
#define LB_GETSELCOUNT	       (WM_USER+17)
#define LB_GETSELITEMS	       (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX	       (WM_USER+24)
#define LB_GETITEMRECT	       (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE	    (-2)
#define LBN_SELCHANGE	    1
#define LBN_DBLCLK	    2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F

/* Listbox message return values */
#define LB_OKAY 	    0
#define LB_ERR		    (-1)
#define LB_ERRSPACE	    (-2)

#define LB_CTLCODE	    0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */


/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY	    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE	    0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL	         (WM_USER+0)
#define CB_LIMITTEXT	         (WM_USER+1)
#define CB_SETEDITSEL	         (WM_USER+2)
#define CB_ADDSTRING	         (WM_USER+3)
#define CB_DELETESTRING	         (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT	         (WM_USER+6)
#define CB_GETCURSEL	         (WM_USER+7)
#define CB_GETLBTEXT	         (WM_USER+8)
#define CB_GETLBTEXTLEN	         (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT	         (WM_USER+11)
#define CB_FINDSTRING	         (WM_USER+12)
#define CB_SELECTSTRING	         (WM_USER+13)
#define CB_SETCURSEL	         (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE	    (-1)
#define CBN_SELCHANGE	    1
#define CBN_DBLCLK	    2
#define CBN_SETFOCUS	    3
#define CBN_KILLFOCUS	    4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY 	    0
#define CB_ERR		    (-1)
#define CB_ERRSPACE	    (-2)

#endif	/* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */


/* Standard hook code */
#define HC_ACTION	    0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN	    (-3)
#define HC_LPLPFNNEXT	    (-2)
#define HC_LPFNNEXT	    (-1)

#endif	/* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT		    5

#define HCBT_MOVESIZE	    0
#define HCBT_MINMAX	    1
#define HCBT_QS 	    2
#define HCBT_CREATEWND	    3
#define HCBT_DESTROYWND	    4
#define HCBT_ACTIVATE	    5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND	    8
#define HCBT_SETFOCUS	    9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif	/* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE	    8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT	    1
#define HC_SKIP 	    2
#define HC_NOREMOVE	    3
#define HC_NOREM	    HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF	    5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif	/* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG	    9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE	hModuleHook;
    LPARAM	reserved;
    LPARAM	lParam;
    WPARAM	wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY	    0
#define S_THRESHOLD	    1
#define S_ALLTHRESHOLD	    2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY	    0
#define ODDPARITY	    1
#define EVENPARITY	    2
#define MARKPARITY	    3
#define SPACEPARITY	    4

#define ONESTOPBIT	    0
#define ONE5STOPBITS	    1
#define TWOSTOPBITS	    2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE	    EV_RingTe

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110	     0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY		0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int	FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD		0x0001
#define DRV_ENABLE		0x0002
#define DRV_OPEN		0x0003
#define DRV_CLOSE		0x0004
#define DRV_DISABLE		0x0005
#define DRV_FREE		0x0006
#define DRV_CONFIGURE		0x0007
#define DRV_QUERYCONFIGURE	0x0008
#define DRV_INSTALL		0x0009
#define DRV_REMOVE		0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER		0x000F

#define DRV_RESERVED		0x0800
#define DRV_USER		0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL		0x0000
#define DRVCNF_OK		0x0001
#define DRVCNF_RESTART		0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY	0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE		0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\TOOLHELP.H ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\_WIN386.H ===
/*
 *  Copyright by WATCOM International Corp. 1988-1994.  All rights reserved.

   Special include for 32-bit Windows 3.x

 */
#ifndef ___WIN386_INCLUDED__
#define ___WIN386_INCLUDED__
#ifdef __cplusplus
extern "C" {
#endif

#ifndef RC_INVOKED
#include <stddef.h>
#endif

#ifdef __WINDOWS_386__
#ifndef NOAUTOPROCS
typedef void __far *REALFARPROC;
#endif
#define int short
#define __huge
#define __far
#define __export

#define NOMINMAX
#include <win16.h>
#ifndef NOCOVERSENDS
#define SendMessage _Cover_SendMessage
#define SendDlgItemMessage _Cover_SendDlgItemMessage
#endif
#ifndef NOCOVERRC
#define RegisterClass _Cover_RegisterClass
#endif
#ifndef NOAUTOPROCS
#define CreateDialog 			_Cover_CreateDialog
#define CreateDialogIndirect 		_Cover_CreateDialogIndirect
#define CreateDialogParam 		_Cover_CreateDialogParam
#define CreateDialogIndirectParam 	_Cover_CreateDialogIndirectParam
#define DialogBox 			_Cover_DialogBox
#define DialogBoxIndirect 		_Cover_DialogBoxIndirect
#define DialogBoxParam 			_Cover_DialogBoxParam
#define DialogBoxIndirectParam 		_Cover_DialogBoxIndirectParam
#define EnumChildWindows 		_Cover_EnumChildWindows
#define EnumFonts 			_Cover_EnumFonts
#define EnumFontFamilies		_Cover_EnumFontFamilies
#define EnumMetaFile 			_Cover_EnumMetaFile
#define EnumObjects 			_Cover_EnumObjects
#define EnumProps 			_Cover_EnumProps
#define EnumTaskWindows 		_Cover_EnumTaskWindows
#define EnumWindows 			_Cover_EnumWindows
#define Escape	 			_Cover_Escape
#define FreeProcInstance 		_Cover_FreeProcInstance
#define GetClassLong 			_Cover_GetClassLong
#define GetWindowLong 			_Cover_GetWindowLong
#define GlobalNotify 			_Cover_GlobalNotify
#define GrayString 			_Cover_GrayString
#define LineDDA 			_Cover_LineDDA
#define MakeProcInstance 		_Cover_MakeProcInstance
#define SetClassLong 			_Cover_SetClassLong
#define SetResourceHandler 		_Cover_SetResourceHandler
#define SetTimer 			_Cover_SetTimer
#define SetWindowsHook 			_Cover_SetWindowsHook
#define SetWindowsHookEx		_Cover_SetWindowsHookEx
#define SetWindowLong 			_Cover_SetWindowLong
#endif
#else
#include <win16.h>
#endif
#define API WINAPI

#ifndef NOKERNEL
FARPROC API _16MakeProcInstance(FARPROC, HANDLE);
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
FARPROC API _Cover_MakeProcInstance(REALFARPROC, HANDLE);
#endif
void	API _16FreeProcInstance(FARPROC);
void	API _Cover_FreeProcInstance(FARPROC);
void    API _16GetCodeInfo(FARPROC lpProc, LPVOID lpSegInfo);
HANDLE  API _16GetModuleHandle(LPSTR);
int     API _16GetModuleFileName(HANDLE, LPSTR, int);
int     API _16GetInstanceData(HANDLE, NPSTR, int);
FARPROC API _16GetProcAddress(HANDLE, LPSTR);
HANDLE  API _16LoadLibrary(LPSTR);
HANDLE  API _16LoadModule(LPSTR, LPVOID);
WORD    API _16WinExec(LPSTR, WORD);
void    API _16OutputDebugString(LPSTR);
#ifndef NOOPENFILE
int  API _16OpenFile(LPSTR, LPOFSTRUCT, WORD);
int  API _16GetTempFileName(BYTE, LPSTR, WORD, LPSTR);
#endif /* NOOPENFILE */
HANDLE API _16FindResource(HANDLE, LPSTR, LPSTR);
FARPROC API _16SetResourceHandler(HANDLE, LPSTR, FARPROC);
FARPROC API _Cover_SetResourceHandler(HANDLE, LPSTR, FARPROC);
#ifndef NOATOM
ATOM   API _16AddAtom(LPSTR);
ATOM   API _16FindAtom(LPSTR);
WORD   API _16GetAtomName(ATOM, LPSTR, int);
ATOM   API _16GlobalAddAtom(LPSTR);
ATOM   API _16GlobalFindAtom(LPSTR);
WORD   API _16GlobalGetAtomName(ATOM, LPSTR, int);
#endif /* NOATOM */
WORD API _16GetProfileInt(LPSTR, LPSTR, int);
int  API _16GetProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int);
BOOL API _16WriteProfileString(LPSTR, LPSTR, LPSTR);
WORD API _16GetPrivateProfileInt(LPSTR, LPSTR, int, LPSTR);
int  API _16GetPrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int, LPSTR);
BOOL API _16WritePrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR);
WORD API _16GetWindowsDirectory(LPSTR,WORD);
WORD API _16GetSystemDirectory(LPSTR,WORD);
int   API _16AnsiToOem(LPSTR, LPSTR);
BOOL  API _16OemToAnsi(LPSTR, LPSTR);
void  API _16AnsiToOemBuff(LPSTR, LPSTR, int);
void  API _16OemToAnsiBuff(LPSTR, LPSTR, int);
LPSTR API _16AnsiUpper(LPSTR);
WORD  API _16AnsiUpperBuff(LPSTR, WORD);
LPSTR API _16AnsiLower(LPSTR);
WORD  API _16AnsiLowerBuff(LPSTR, WORD);
LPSTR API _16AnsiNext(LPSTR);
LPSTR API _16AnsiPrev(LPSTR, LPSTR);
#ifndef NOKEYBOARDINFO
int   API _16GetKeyNameText(LONG, LPSTR, int);
int   API _16ToAscii(WORD wVirtKey, WORD wScanCode, LPSTR lpKeyState, LPVOID lpChar, WORD wFlags);
#endif /* NOKEYBOARDINFO */
#ifndef NOMEMMGR
VOID API _16GlobalNotify(FARPROC);
VOID API _Cover_GlobalNotify(FARPROC);
#endif /* NOMEMMGR */

#endif /* NOKERNEL */

#ifndef NOGDI
#ifndef NODRAWTEXT
int  API _16DrawText(HDC, LPSTR, int, LPRECT, WORD);
#endif /* NODRAWTEXT */
HDC   API _16CreateDC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   API _16CreateIC(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL API _16ExtTextOut(HDC, int, int, WORD, LPRECT, LPSTR, WORD, LPINT);
BOOL API _16Polyline(HDC, LPPOINT, int);
BOOL API _16Polygon(HDC, LPPOINT, int);
BOOL API _16PolyPolygon(HDC, LPPOINT, LPINT, int);
BOOL  API _16TextOut(HDC, int, int, LPSTR, int);
LONG  API _16TabbedTextOut(HDC, int, int, LPSTR, int, int, LPINT, int);
BOOL  API _16GetCharWidth(HDC, WORD, WORD, LPINT);
void  API _16LineDDA(int, int, int, int, FARPROC, LPARAM);
void  API _Cover_LineDDA(int, int, int, int, FARPROC, LPARAM);
HPEN API _16CreatePenIndirect( LPLOGPEN );
HBRUSH API _16CreateBrushIndirect( LPLOGBRUSH );
HBITMAP API _16CreateBitmap(int, int, UINT, UINT, LPSTR);
HBITMAP API _16CreateBitmapIndirect( LPBITMAP );
HBITMAP API _16CreateDIBitmap(HDC, LPBITMAPINFOHEADER, DWORD, LPSTR, LPBITMAPINFO, UINT);
LONG  API _16SetBitmapBits(HBITMAP, DWORD, LPSTR);
LONG  API _16GetBitmapBits(HBITMAP, LONG, LPSTR);
HFONT API _16CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPSTR);
HFONT API _16CreateFontIndirect( LPLOGFONT );
HRGN API _16CreateRectRgnIndirect(LPRECT);
HRGN API _16CreateEllipticRgnIndirect(LPRECT);
HRGN API _16CreatePolygonRgn(LPPOINT, int, int);
HRGN API _16CreatePolyPolygonRgn(LPPOINT, LPINT, int, int);
int    API _16GetObject(HANDLE, int, LPSTR);
int  API _16GetClipBox(HDC, LPRECT);
int  API _16GetRgnBox(HRGN, LPRECT);
DWORD API _16GetTextExtent(HDC, LPSTR, int);
DWORD API _16GetTabbedTextExtent(HDC, LPSTR, int, int, LPINT);
HANDLE API _16GetMetaFile(LPSTR);
HANDLE API _16CopyMetaFile(HANDLE, LPSTR);
#ifndef NOMETAFILE
void API _16PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, WORD);
BOOL API _16EnumMetaFile(HDC, LOCALHANDLE, FARPROC, LPSTR );
BOOL API _Cover_EnumMetaFile(HDC, LOCALHANDLE, FARPROC, LPSTR );
#endif
int API _16Escape(HDC, int, int, LPSTR, LPSTR);
int API _Cover_Escape(HDC, int, int, LPSTR, LPSTR);
int API _16EnumFonts(HDC, LPSTR, FARPROC, LPSTR);
int API _Cover_EnumFonts(HDC, LPSTR, FARPROC, LPSTR);
int API _Cover_EnumFontFamilies(HDC, LPSTR, FARPROC, LPSTR);
int API _16EnumObjects(HDC, int, FARPROC, LPSTR);
int API _Cover_EnumObjects(HDC, int, FARPROC, LPSTR);
int API _16GetTextFace(HDC, int, LPSTR);
#ifndef NOTEXTMETRIC
BOOL API _16GetTextMetrics(HDC, LPTEXTMETRIC );
#endif /* NOTEXTMETRIC */
int API _16SetEnvironment(LPSTR, LPSTR, WORD);
int API _16GetEnvironment(LPSTR, LPSTR, WORD);
BOOL API _16DPtoLP(HDC, LPPOINT, int);
BOOL API _16LPtoDP(HDC, LPPOINT, int);
HANDLE API _16CreateMetaFile(LPSTR);
int API _16SetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int API _16GetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int API _16SetDIBitsToDevice(HDC,WORD,WORD,WORD,WORD,
					WORD,WORD,WORD,WORD,
					LPSTR,LPBITMAPINFO,WORD);
int API _16StretchDIBits(HDC, WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPSTR, LPBITMAPINFO, WORD, DWORD);
HPALETTE API _16CreatePalette (LPLOGPALETTE);
void API _16AnimatePalette(HPALETTE, WORD, WORD, LPPALETTEENTRY);
WORD API _16SetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD API _16GetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD API _16GetSystemPaletteEntries(HDC,WORD,WORD,LPPALETTEENTRY);
#endif /* NOGDI */

#ifndef NOUSER
/*
 * replace windows fns with c library ones
 */
#ifdef __WINDOWS_386__
#undef wsprintf
#undef wvsprintf
#define wsprintf sprintf
#define wvsprintf vsprintf
#ifndef NOLSTRING
#undef lstrcmp
#undef lstrcmpi
#undef lstrcpy
#undef lstrcat
#undef lstrlen
#define lstrcmp strcmp
#define lstrcmpi strcmpi
#define lstrcpy strcpy
#define lstrcat strcat
#define lstrlen strlen
#endif /* NOLSTRING */
#endif
#ifndef NOWINMESSAGES
WORD API _16RegisterWindowMessage(LPSTR);
#endif /* NOWINMESSAGES */
#ifndef NOMSG
BOOL API _16TranslateMessage(LPMSG);
LONG API _16DispatchMessage(LPMSG);
#endif /* NOMSG */
LONG  API _Cover_SendMessage(HWND, WORD, WORD, LONG);
BOOL  API _Cover_RegisterClass(LPWNDCLASS);
BOOL  API _16UnregisterClass(LPSTR, HANDLE);
BOOL  API _16GetClassInfo(HANDLE, LPSTR, LPWNDCLASS);
HWND  API _16CreateWindow(LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);
HWND  API _16CreateWindowEx(DWORD, LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);
#ifndef NOCTLMGR
HWND API _Cover_CreateDialog(HANDLE, LPSTR, HWND, FARPROC);
HWND API _Cover_CreateDialogIndirect(HANDLE, LPSTR, HWND, FARPROC);
HWND API _Cover_CreateDialogParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND API _Cover_CreateDialogIndirectParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND API _16CreateDialog(HANDLE, LPSTR, HWND, FARPROC);
HWND API _16CreateDialogIndirect(HANDLE, LPSTR, HWND, FARPROC);
HWND API _16CreateDialogParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND API _16CreateDialogIndirectParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  API _Cover_DialogBox(HANDLE, LPSTR, HWND, FARPROC);
int  API _Cover_DialogBoxParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  API _Cover_DialogBoxIndirect(HANDLE, HANDLE, HWND, FARPROC);
int  API _Cover_DialogBoxIndirectParam(HANDLE, HANDLE, HWND, FARPROC, LONG);
int  API _16DialogBox(HANDLE, LPSTR, HWND, FARPROC);
int  API _16DialogBoxParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  API _16DialogBoxIndirect(HANDLE, HANDLE, HWND, FARPROC);
int  API _16DialogBoxIndirectParam(HANDLE, HANDLE, HWND, FARPROC, LONG);
LONG API _Cover_SendDlgItemMessage(HWND, int, WORD, WORD, LONG);
WORD API _16GetDlgItemInt(HWND, int, BOOL *, BOOL);
void API _16SetDlgItemText(HWND, int, LPSTR);
int  API _16GetDlgItemText(HWND, int, LPSTR, int);
#endif /* NOCTLMSG */
#ifndef NOMSG
BOOL API _16CallMsgFilter(LPMSG, int);
#endif /* NOMSG */
#ifndef NOCLIPBOARD
WORD   API _16RegisterClipboardFormat(LPSTR);
int    API _16GetClipboardFormatName(WORD, LPSTR, int);
int    API _16GetPriorityClipboardFormat(WORD  *, int);
#endif /* NOCLIPBOARD */
void API _16GetKeyboardState(BYTE *);
void API _16SetKeyboardState(BYTE *);
WORD API _16SetTimer(HWND, int, WORD, FARPROC);
WORD API _Cover_SetTimer(HWND, int, WORD, FARPROC);
HANDLE API _16LoadAccelerators(HANDLE, LPSTR);
#ifndef NOMSG
int  API _16TranslateAccelerator(HWND, HANDLE, LPMSG);
#endif /* NOMSG */
#ifndef NOMENUS
HMENU API _16LoadMenu(HANDLE, LPSTR);
HMENU API _16LoadMenuIndirect(LPSTR);
BOOL  API _16ChangeMenu(HMENU, WORD, LPSTR, WORD, WORD);
int   API _16GetMenuString(HMENU, WORD, LPSTR, int, WORD);
BOOL  API _16TrackPopupMenu(HMENU, WORD, int, int, int, HWND, LPRECT);
#endif /* NOMENUS */
BOOL API _16GrayString(HDC, HBRUSH, FARPROC, DWORD, int, int, int, int, int);
BOOL API _Cover_GrayString(HDC, HBRUSH, FARPROC, DWORD, int, int, int, int, int);
void API _16EndPaint(HWND, LPPAINTSTRUCT);
BOOL API _16GetUpdateRect(HWND, LPRECT, BOOL);
void API _16InvalidateRect(HWND, LPRECT, BOOL);
void API _16ValidateRect(HWND, LPRECT);
void API _16ScrollWindow(HWND, int, int, LPRECT, LPRECT);
BOOL API _16ScrollDC(HDC, int, int, LPRECT, LPRECT, HRGN, LPRECT);
#ifndef NOSCROLL
void API _16GetScrollRange(HWND, int, LPINT, LPINT);
#endif /* NOSCROLL */
BOOL   API _16SetProp(HWND, LPSTR, HANDLE);
HANDLE API _16GetProp(HWND, LPSTR);
HANDLE API _16RemoveProp(HWND, LPSTR);
void   API _16SetWindowText(HWND, LPSTR);
int    API _16GetWindowText(HWND, LPSTR, int);
int    API _16EnumProps(HWND, FARPROC);
int    API _Cover_EnumProps(HWND, FARPROC);
void API _16GetClientRect(HWND, LPRECT);
void API _16GetWindowRect(HWND, LPRECT);
void API _16AdjustWindowRect(LPRECT, LONG, BOOL);
void API _16AdjustWindowRectEx(LPRECT, LONG, BOOL, DWORD);
#ifndef NOMB
int  API _16MessageBox(HWND, LPSTR, LPSTR, WORD);
#endif /* NOMB */
void    API _16GetCursorPos(LPPOINT);
void    API _16ClipCursor(LPRECT);
void API _16GetCaretPos(LPPOINT);
void API _16ClientToScreen(HWND, LPPOINT);
void API _16ScreenToClient(HWND, LPPOINT);
#ifndef NOCOLOR
void  API _16SetSysColors(int, LPINT, LONG *);
#endif /* NOCOLOR */
void API _16DrawFocusRect(HDC, LPRECT);
int  API _16FillRect(HDC, LPRECT, HBRUSH);
int  API _16FrameRect(HDC, LPRECT, HBRUSH);
void API _16InvertRect(HDC, LPRECT);
void API _16SetRect(LPRECT, int, int, int, int);
void API _16SetRectEmpty(LPRECT);
int  API _16CopyRect(LPRECT, LPRECT);
void API _16InflateRect(LPRECT, int, int);
int  API _16IntersectRect(LPRECT, LPRECT, LPRECT);
int  API _16UnionRect(LPRECT, LPRECT, LPRECT);
void API _16OffsetRect(LPRECT, int, int);
BOOL API _16IsRectEmpty(LPRECT);
BOOL API _16EqualRect(LPRECT, LPRECT);
BOOL API _16PtInRect(LPRECT, POINT);
BOOL API _16RectVisible(HDC, LPRECT);
BOOL API _16RectInRegion(HRGN, LPRECT);
#ifndef NOWINOFFSETS
LONG API _16SetWindowLong(HWND, int, LONG);
LONG API _16SetClassLong(HWND, int, LONG);
LONG API _Cover_GetWindowLong(HWND, int);
LONG API _Cover_SetWindowLong(HWND, int, LONG);
LONG API _Cover_GetClassLong(HWND, int);
LONG API _Cover_SetClassLong(HWND, int, LONG);
#endif /* NOWINOFFSETS */
HWND   API _16FindWindow(LPSTR, LPSTR);
BOOL   API _16EnumWindows(FARPROC, LONG);
BOOL   API _Cover_EnumWindows(FARPROC, LONG);
BOOL   API _16EnumTaskWindows(HANDLE, FARPROC, LONG);
BOOL   API _Cover_EnumTaskWindows(HANDLE, FARPROC, LONG);
BOOL   API _16EnumChildWindows(HWND, FARPROC, LONG);
BOOL   API _Cover_EnumChildWindows(HWND, FARPROC, LONG);
int    API _16GetClassName(HWND, LPSTR, int);
#ifndef NOWH
FARPROC API _16SetWindowsHook(int, FARPROC);
FARPROC API _Cover_SetWindowsHook(int, FARPROC);
BOOL	API _16UnhookWindowsHook(int, FARPROC);
#if (WINVER >= 0x030a)
HHOOK   API _Cover_SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
#endif  /* WINVER >= 0x030a */
#endif
HBITMAP API _16LoadBitmap(HANDLE, LPSTR);
HCURSOR API _16LoadCursor(HANDLE, LPSTR);
HCURSOR API _16CreateCursor(HANDLE, int, int, int, int, LPSTR, LPSTR);
HICON API _16LoadIcon(HANDLE, LPSTR);
HICON API _16CreateIcon(HANDLE, int, int, BYTE, BYTE, LPSTR, LPSTR);
int  API _16LoadString(HANDLE, WORD, LPSTR, int);
int  API _16AddFontResource(LPSTR);
BOOL API _16RemoveFontResource(LPSTR);

#ifndef NOCTLMGR
#ifndef NOMSG
BOOL API _16IsDialogMessage(HWND, LPMSG);
#endif /* NOMSG */
void API _16MapDialogRect(HWND, LPRECT);
int  API _16DlgDirList(HWND, LPSTR, int, int, WORD);
BOOL API _16DlgDirSelect(HWND, LPSTR, int);
int  API _16DlgDirListComboBox(HWND, LPSTR, int, int, WORD);
BOOL API _16DlgDirSelectComboBox(HWND, LPSTR, int);
#endif /* NOCTLMGR */
#ifdef USECOMM
int  API _16OpenComm(LPSTR, WORD, WORD);
int  API _16SetCommState(DCB *);
int  API _16GetCommState(int, DCB *);
int  API _16ReadComm(int, LPSTR, int);
int  API _16WriteComm(int, LPSTR, int);
int  API _16GetCommError(int, COMSTAT *);
int  API _16BuildCommDCB(LPSTR, DCB *);
#endif /* USECOMM */
#ifndef NOMDI
#ifndef NOMSG
BOOL API _16TranslateMDISysAccel(HWND,LPMSG);
#endif /* NOMSG */
#endif /* NOMDI */

#ifndef NOLFILEIO
WORD API _16_lread( int, LPSTR, int );
WORD API _16_lwrite( int, LPSTR, int );
#endif
#endif /* NOUSER */
#ifndef NOHELP
BOOL API _16WinHelp(HWND hwndMain, LPSTR lpszHelp, WORD usCommand, DWORD ulData);
#endif /* NOHELP */

#ifdef INCLUDE_DRIVINIT_H
#include <drivinit.h>
#endif
#ifdef INCLUDE_PRINT_H
#include <print.h>
#endif
#ifdef INCLUDE_DDE_H
#define unsigned unsigned short
#include <dde.h>
#undef unsigned
#endif
#ifdef INCLUDE_CUSTCNTL_H
#include <custcntl.h>
#endif
#ifdef INCLUDE_COMMDLG_H
#include <commdlg.h>
BOOL WINAPI _16ChooseColor(LPCHOOSECOLOR);
BOOL WINAPI _16ChooseFont(LPCHOOSEFONT);
HWND WINAPI _16FindText(LPFINDREPLACE);
int WINAPI _16GetFileTitle(LPCSTR, LPSTR, UINT);
BOOL WINAPI _16GetOpenFileName(LPOPENFILENAME);
BOOL WINAPI _16GetSaveFileName(LPOPENFILENAME);
BOOL WINAPI _16PrintDlg(LPPRINTDLG);
HWND WINAPI _16ReplaceText(LPFINDREPLACE);
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define ChooseColor _CoverChooseColor
#define ChooseFont _CoverChooseFont
#define FindText _CoverFindText
#define GetOpenFileName _CoverGetOpenFileName
#define GetSaveFileName _CoverGetSaveFileName
#define PrintDlg _CoverPrintDlg
#define ReplaceText _CoverReplaceText
BOOL WINAPI _CoverChooseColor(LPCHOOSECOLOR);
BOOL WINAPI _CoverChooseFont(LPCHOOSEFONT);
HWND WINAPI _CoverFindText(LPFINDREPLACE);
BOOL WINAPI _CoverGetOpenFileName(LPOPENFILENAME);
BOOL WINAPI _CoverGetSaveFileName(LPOPENFILENAME);
BOOL WINAPI _CoverPrintDlg(LPPRINTDLG);
HWND WINAPI _CoverReplaceText(LPFINDREPLACE);
#endif

#endif
#ifdef INCLUDE_OLE_H
#include <ole.h>
OLESTATUS   WINAPI  _16OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  _16OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  _16OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLECLIPFORMAT  WINAPI  _16OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  _16OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  _16OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  _16OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  _16OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  _16OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  _16OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  _16OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleQueryOutOfDate(LPOLEOBJECT);
void FAR*   WINAPI  _16OleQueryProtocol(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  _16OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI _16OleQueryReleaseMethod(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  _16OleQueryType(LPOLEOBJECT, LONG FAR*);
OLESTATUS   WINAPI  _16OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  _16OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  _16OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  _16OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  _16OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  _16OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  _16OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  _16OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  _16OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
OLESTATUS   WINAPI  _16OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  _16OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  _16OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  _16OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  _16OleRevokeObject(LPOLECLIENT);
OLESTATUS   WINAPI  _16OleUnblockServer(LHSERVER, BOOL FAR*);
#endif
#ifdef INCLUDE_DDEML_H
#include <ddeml.h>
HCONVLIST EXPENTRY _16DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
        HCONVLIST hConvList, PCONVCONTEXT pCC);
HCONV EXPENTRY _16DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
        PCONVCONTEXT pCC);
WORD EXPENTRY _16DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);
HDDEDATA EXPENTRY _16DdeClientTransaction(LPBYTE pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, WORD wFmt, WORD wType, DWORD dwTimeout,
        LPDWORD pdwResult);
HDDEDATA EXPENTRY _16DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb,
        DWORD cbOff, HSZ hszItem, WORD wFmt, WORD afCmd);
HDDEDATA EXPENTRY _16DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);
DWORD EXPENTRY _16DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff);
LPBYTE EXPENTRY _16DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);
HSZ  EXPENTRY _16DdeCreateStringHandle(DWORD idInst, LPSTR psz, int iCodePage);
DWORD EXPENTRY _16DdeQueryString(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
UINT  EXPENTRY _16DdeInitialize(LPDWORD idInst, PFNCALLBACK pfnCallback,
				DWORD afCmd, DWORD ulRes);
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define DdeInitialize _Cover_DdeInitialize
UINT  EXPENTRY _Cover_DdeInitialize(LPDWORD idInst, PFNCALLBACK pfnCallback,
				DWORD afCmd, DWORD ulRes);
#endif
#endif
#ifdef INCLUDE_SHELLAPI_H
#include <shellapi.h>
#endif
#ifdef INCLUDE_VER_H
#include <ver.h>
#endif
#ifdef INCLUDE_LZEXPAND_H
#include <lzexpand.h>
#endif
#ifdef INCLUDE_STRESS_H
#include <stress.h>
#endif
#ifdef INCLUDE_PENWIN_H
#include <penwin.h>
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define Recognize _Cover_Recognize
#define RecognizeData _Cover_RecognizeData
#define TrainInk _Cover_TrainInk
#define ProcessWriting _Cover_ProcessWriting
#define CorrectWriting _Cover_CorrectWriting
#define DictionarySearch _Cover_DictionarySearch
#define SetPenHook _Cover_SetPenHook
#define EnumSymbols _Cover_EnumSymbols
REC WINAPI _Cover_Recognize( LPRC lprc );
REC WINAPI _Cover_RecognizeData( LPRC lprc, HPENDATA hpd );
BOOL WINAPI _Cover_TrainInk(LPRC lprc, HPENDATA hpd, LPSYV lpsvy );
REC WINAPI _Cover_ProcessWriting( HWND hwnd, LPRC lprc );
BOOL WINAPI _Cover_CorrectWriting( HWND hwnd, LPSTR lpstr, UINT cb, LPRC lprc, DWORD dw1, DWORD dw2 );
BOOL WINAPI _Cover_DictionarySearch( LPRC lprc, LPSYE lpsye, int i1, LPSYV lpsyv, int i2 );
BOOL WINAPI _Cover_SetPenHook(HKP hkpop, LPFNRAWHOOK lpfn );
UINT WINAPI _Cover_EnumSymbols(LPSYG, WORD, ENUMPROC, LPVOID);
#endif
#endif
#ifdef INCLUDE_PENWOEM_H
#include <penwoem.h>
#endif
#ifdef INCLUDE_MMSYSTEM_H
#include <mmsystem.h>
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define mmioInstallIOProc _Cover_mmioInstallIOProc
#define mciSetYieldProc _Cover_mciSetYieldProc
LPMMIOPROC WINAPI _Cover_mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
BOOL WINAPI _Cover_mciSetYieldProc(UINT uDeviceID, YIELDPROC fpYieldProc, DWORD dwYieldData);
#endif
UINT WINAPI _16waveOutPrepareHeader(HWAVEOUT hWaveOut,DWORD,UINT uSize);
UINT WINAPI _16waveOutUnprepareHeader(HWAVEOUT hWaveOut,DWORD,UINT uSize);
UINT WINAPI _16waveOutWrite(HWAVEOUT hWaveOut, DWORD,UINT uSize);
#endif

#ifdef INCLUDE_TOOLHELP_H
#include <toolhelp.h>
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
BOOL WINAPI _Cover_NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
#define NotifyRegister _Cover_NotifyRegister
#endif
#endif

#ifdef __WINDOWS_386__

/*
 * re-define the pseudo-pointers
 */
#undef MAKEINTRESOURCE
#define MAKEINTRESOURCE(i)  (LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i)))
#undef MAKEINTATOM
#define MAKEINTATOM(i)	(LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i)))

#undef int
#undef __far
#undef __huge
#undef FAR
#define FAR far

/*
 * types
 */
typedef unsigned int PROCPTR;
typedef void * CALLBACKPTR;
typedef void * HINDIR;

/*
 * prototypes for special WIN386 library functions
 */
#define GETPROC_CALLBACK 0
#define GETPROC_SETTIMER 0
#define GETPROC_ABORTPROC 1
#define GETPROC_ENUMFONTS 2
#define GETPROC_ENUMMETAFILE 3
#define GETPROC_ENUMOBJECTS 4
#define GETPROC_ENUMPROPS_FIXED_DS 5
#define GETPROC_GRAYSTRING 5
#define GETPROC_ENUMPROPS_MOVEABLE_DS 6
#define GETPROC_ENUMTASKWINDOWS 7
#define GETPROC_ENUMWINDOWS 7
#define GETPROC_ENUMCHILDWINDOWS 7
#define GETPROC_TOOLHELP_NOTIFY 7
#define GETPROC_GLOBALNOTIFY 8
#define GETPROC_LINEDDA 9
#define GETPROC_SETWINDOWSHOOK 9
#define GETPROC_SETRESOURCEHANDLER 10
#define GETPROC_DDEMLCALLBACK 11
#define GETPROC_PENWIN_RCYIELDPROC 12
#define GETPROC_PENWIN_LPDF 13
#define GETPROC_PENWIN_LPFNRAWHOOK 14
#define GETPROC_PENWIN_ENUMPROC 15
#define GETPROC_MMSYSTEM_MMIOPROC 16
#define GETPROC_MMSYSTEM_YIELDPROC 17
#define GETPROC_USERDEFINED_1 101
#define GETPROC_USERDEFINED_2 102
#define GETPROC_USERDEFINED_3 103
#define GETPROC_USERDEFINED_4 104
#define GETPROC_USERDEFINED_5 105
#define GETPROC_USERDEFINED_6 106
#define GETPROC_USERDEFINED_7 107
#define GETPROC_USERDEFINED_8 108
#define GETPROC_USERDEFINED_9 109
#define GETPROC_USERDEFINED_10 110
#define GETPROC_USERDEFINED_11 111
#define GETPROC_USERDEFINED_12 112
#define GETPROC_USERDEFINED_13 113
#define GETPROC_USERDEFINED_14 114
#define GETPROC_USERDEFINED_15 115
#define GETPROC_USERDEFINED_16 116
#define GETPROC_USERDEFINED_17 117
#define GETPROC_USERDEFINED_18 118
#define GETPROC_USERDEFINED_19 119
#define GETPROC_USERDEFINED_20 120
#define GETPROC_USERDEFINED_21 121
#define GETPROC_USERDEFINED_22 122
#define GETPROC_USERDEFINED_23 123
#define GETPROC_USERDEFINED_24 124
#define GETPROC_USERDEFINED_25 125
#define GETPROC_USERDEFINED_26 126
#define GETPROC_USERDEFINED_27 127
#define GETPROC_USERDEFINED_28 128
#define GETPROC_USERDEFINED_29 129
#define GETPROC_USERDEFINED_30 130
#define GETPROC_USERDEFINED_31 131
#define GETPROC_USERDEFINED_32 132

#define GCB_DWORD		4
#define GCB_WORD		2
#define GCB_ENDLIST		-1
#define GCB_CDECL		-2

extern CALLBACKPTR GetProc16( PROCPTR, long );
extern void ReleaseProc16( CALLBACKPTR );
extern void ReleaseCallbackRoutine( CALLBACKPTR cbp );
CALLBACKPTR GetCallbackRoutine( PROCPTR fn, ... );
void ReleaseCallbackRoutine( CALLBACKPTR cbp );

extern void far *MK_LOCAL32( void * );
extern void far *MK_FP32( void * );
extern DWORD MK_FP16( void far * );

#pragma aux MK_LOCAL32 "*_" parm [eax] value [eax dx];
#pragma aux MK_FP32 = 0x8B 0xD0 0xC1 0xEA 0x10 0x25 0xFF 0xFF 0x00 0x00 \
   parm [eax] value [eax dx];
#pragma aux  MK_FP16 = 0xC1 0xE2 0x10 0x66 0x8B 0xD0 \
   parm [eax dx] value [edx];

extern DWORD _Call16( FARPROC lpFunc, char *fmt, ... );
/*
;  _Call16 performs the same function as "GetIndirectFunctionHandle,
;  InvokeIndirectFunctionHandle, FreeIndirectFunctionHandle" but is
;  much easier to use.
;  Fmt specifiers for _Call16:
;	c - call 'cdecl' func as opposed to 'pascal' func (must be first char)
;	b - unsigned byte
;	w - 16-bit word
;	d - 32-bit dword
;	f - double precision floating-point
;	p - 32-bit flat pointer (converted to 16:16 pointer)
*/
extern DWORD InvokeIndirectFunction( HINDIR handle, ... );
extern HINDIR GetIndirectFunctionHandle( FARPROC proc, ... );
extern void  FreeIndirectFunctionHandle( HINDIR );
#define INDIR_DWORD     ((int) 4)
#define INDIR_WORD      ((int) 2)
#define INDIR_CHAR      ((int) 2)
#define INDIR_PTR       ((int) -1)
#define INDIR_ENDLIST   ((int) -2)
#define INDIR_CDECL	((int) -3)

extern int DefineDLLEntry( int, void *, ... );
#define DLL_DWORD	((int) 4)
#define DLL_PTR		((int) 4)
#define DLL_WORD	((int) 2)
#define DLL_CHAR	((int) 2)
#define DLL_ENDLIST	((int) -1)

extern int DefineUserProc16( int, PROCPTR, ... );
#define UDP16_DWORD	((int) 4)
#define UDP16_PTR	((int) 4)
#define UDP16_WORD	((int) 2)
#define UDP16_CHAR	((int) 2)
#define UDP16_ENDLIST	((int) -1)
#define UDP16_CDECL	((int) -2)

#define DWORD_TO_PTR(i)  ((LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i))))
#define PASS_WORD_AS_POINTER(i)  ((LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i))))

extern DWORD AllocAlias16( void * );
extern void FreeAlias16( DWORD );
extern DWORD AllocHugeAlias16( void *, DWORD );
extern void FreeHugeAlias16( DWORD, DWORD );
void *MapAliasToFlat( DWORD alias );

extern WORD __A000;
#pragma aux __A000 "_*";
extern WORD __B000;
#pragma aux __B000 "_*";
extern WORD __B800;
#pragma aux __B800 "_*";
extern WORD __C000;
#pragma aux __C000 "_*";
extern WORD __D000;
#pragma aux __D000 "_*";
extern WORD __E000;
#pragma aux __E000 "_*";
extern WORD __F000;
#pragma aux __F000 "_*";
extern WORD LocalPtr;
#pragma aux LocalPtr "_*";

#pragma library (WIN386);

#else
typedef void __far * PROCPTR;
typedef void __far * CALLBACKPTR;
typedef void * HINDIR;

#define PASS_WORD_AS_POINTER(i) ((LPSTR)(WORD)(i))
#define AllocAlias16(a) ((DWORD)(LPSTR)(a))
#define FreeAlias16(a)
#define AllocHugeAlias16(a,b) ((DWORD)(LPSTR)(a))
#define FreeHugeAlias16(a,b)
#define MK_LOCAL32(a) ((void far *) a)
#define MK_FP32(a) (a)
#define MK_FP16(a) (a)
#define GetProc16(a,b) (a)
#define ReleaseProc16(a)

#ifndef NOKERNEL
#define _16MakeProcInstance MakeProcInstance
#define _16FreeProcInstance FreeProcInstance
#define _16GetCodeInfo GetCodeInfo
#define _16GetModuleHandle GetModuleHandle
#define _16GetModuleFileName GetModuleFileName
#define _16GetInstanceData GetInstanceData
#define _16GetProcAddress GetProcAddress
#define _16LoadLibrary LoadLibrary
#define _16LoadModule LoadModule
#define _16WinExec WinExec
#define _16OutputDebugString OutputDebugString
#ifndef NOOPENFILE
#define _16OpenFile OpenFile
#define _16GetTempFileName GetTempFileName
#endif /* NOOPENFILE */
#define _16FindResource FindResource
#define _16SetResourceHandler SetResourceHandler
#ifndef NOATOM
#define _16AddAtom AddAtom
#define _16FindAtom FindAtom
#define _16GetAtomName GetAtomName
#define _16GlobalAddAtom GlobalAddAtom
#define _16GlobalFindAtom GlobalFindAtom
#define _16GlobalGetAtomName GlobalGetAtomName
#endif /* NOATOM */
#define _16GetProfileInt GetProfileInt
#define _16GetProfileString GetProfileString
#define _16WriteProfileString WriteProfileString
#define _16GetPrivateProfileInt GetPrivateProfileInt
#define _16GetPrivateProfileString GetPrivateProfileString
#define _16WritePrivateProfileString WritePrivateProfileString
#define _16GetWindowsDirectory GetWindowsDirectory
#define _16GetSystemDirectory GetSystemDirectory
#define _16AnsiToOem AnsiToOem
#define _16OemToAnsi OemToAnsi
#define _16AnsiToOemBuff AnsiToOemBuff
#define _16OemToAnsiBuff OemToAnsiBuff
#define _16AnsiUpper AnsiUpper
#define _16AnsiUpperBuff AnsiUpperBuff
#define _16AnsiLower AnsiLower
#define _16AnsiLowerBuff AnsiLowerBuff
#define _16AnsiNext AnsiNext
#define _16AnsiPrev AnsiPrev
#ifndef NOKEYBOARDINFO
#define _16GetKeyNameText GetKeyNameText
#define _16ToAscii ToAscii
#endif /* NOKEYBOARDINFO */
#ifndef NOMEMMGR
#define _16GlobalNotify GlobalNotify
#endif /* NOMEMMGR */
#endif /* NOKERNEL */

#ifndef NOGDI
#ifndef NODRAWTEXT
#define _16DrawText DrawText
#endif /* NODRAWTEXT */
#define _16CreateDC CreateDC
#define _16CreateIC CreateIC
#define _16ExtTextOut ExtTextOut
#define _16Polyline Polyline
#define _16Polygon Polygon
#define _16PolyPolygon PolyPolygon
#define _16TextOut TextOut
#define _16TabbedTextOut TabbedTextOut
#define _16GetCharWidth GetCharWidth
#define _16LineDDA LineDDA
#define _16CreatePenIndirect CreatePenIndirect
#define _16CreateBrushIndirect CreateBrushIndirect
#define _16CreateBitmap CreateBitmap
#define _16CreateBitmapIndirect CreateBitmapIndirect
#define _16SetBitmapBits SetBitmapBits
#define _16GetBitmapBits GetBitmapBits
#define _16CreateFont CreateFont
#define _16CreateFontIndirect CreateFontIndirect
#define _16CreateRectRgnIndirect CreateRectRgnIndirect
#define _16CreateEllipticRgnIndirect CreateEllipticRgnIndirect
#define _16CreatePolygonRgn CreatePolygonRgn
#define _16CreatePolyPolygonRgn CreatePolyPolygonRgn
#define _16GetObject GetObject
#define _16GetClipBox GetClipBox
#define _16GetRgnBox GetRgnBox
#define _16GetTextExtent GetTextExtent
#define _16GetTabbedTextExtent GetTabbedTextExtent
#define _16GetMetaFile GetMetaFile
#define _16CopyMetaFile CopyMetaFile
#ifndef NOMETAFILE
#define _16PlayMetaFileRecord PlayMetaFileRecord
#define _16EnumMetaFile EnumMetaFile
#endif
#define _16Escape Escape
#define _16EnumFonts EnumFonts
#define _16EnumObjects EnumObjects
#define _16GetTextFace GetTextFace
#ifndef NOTEXTMETRIC
#define _16GetTextMetrics GetTextMetrics
#endif /* NOTEXTMETRIC */
#define _16SetEnvironment SetEnvironment
#define _16GetEnvironment GetEnvironment
#define _16DPtoLP DPtoLP
#define _16LPtoDP LPtoDP
#define _16CreateMetaFile CreateMetaFile
#define _16SetDIBits SetDIBits
#define _16GetDIBits GetDIBits
#define _16SetDIBitsToDevice SetDIBitsToDevice
#define _16StretchDIBits StretchDIBits
#define _16CreatePalette  CreatePalette 
#define _16AnimatePalette AnimatePalette
#define _16SetPaletteEntries SetPaletteEntries
#define _16GetPaletteEntries GetPaletteEntries
#define _16GetSystemPaletteEntries GetSystemPaletteEntries
#endif /* NOGDI */

#ifndef NOUSER
#ifndef NOWINMESSAGES
#define _16RegisterWindowMessage RegisterWindowMessage
#endif /* NOWINMESSAGES */
#ifndef NOMSG
#define _16TranslateMessage TranslateMessage
#define _16DispatchMessage DispatchMessage
#endif /* NOMSG */
#define _16UnregisterClass UnregisterClass
#define _16GetClassInfo GetClassInfo
#define _16CreateWindow CreateWindow
#define _16CreateWindowEx CreateWindowEx
#ifndef NOCTLMGR
#define _16CreateDialog CreateDialog
#define _16CreateDialogIndirect CreateDialogIndirect
#define _16CreateDialogParam CreateDialogParam
#define _16CreateDialogIndirectParam CreateDialogIndirectParam
#define _16DialogBox DialogBox
#define _16DialogBoxParam DialogBoxParam
#define _16DialogBoxIndirect DialogBoxIndirect
#define _16DialogBoxIndirectParam DialogBoxIndirectParam
#define _16GetDlgItemInt GetDlgItemInt
#define _16SetDlgItemText SetDlgItemText
#define _16GetDlgItemText GetDlgItemText
#endif /* NOCTLMSG */
#ifndef NOMSG
#define _16CallMsgFilter CallMsgFilter
#endif /* NOMSG */
#ifndef NOCLIPBOARD
#define _16RegisterClipboardFormat RegisterClipboardFormat
#define _16GetClipboardFormatName GetClipboardFormatName
#define _16GetPriorityClipboardFormat GetPriorityClipboardFormat
#endif /* NOCLIPBOARD */
#define _16GetKeyboardState GetKeyboardState
#define _16SetKeyboardState SetKeyboardState
#define _16LoadAccelerators LoadAccelerators
#define _16SetTimer SetTimer
#ifndef NOMSG
#define _16TranslateAccelerator TranslateAccelerator
#endif /* NOMSG */
#ifndef NOMENUS
#define _16LoadMenu LoadMenu
#define _16LoadMenuIndirect LoadMenuIndirect
#define _16ChangeMenu ChangeMenu
#define _16GetMenuString GetMenuString
#define _16TrackPopupMenu TrackPopupMenu
#endif /* NOMENUS */
#define _16GrayString GrayString
#define _16EndPaint EndPaint
#define _16GetUpdateRect GetUpdateRect
#define _16InvalidateRect InvalidateRect
#define _16ValidateRect ValidateRect
#define _16ScrollWindow ScrollWindow
#define _16ScrollDC ScrollDC
#ifndef NOSCROLL
#define _16GetScrollRange GetScrollRange
#endif /* NOSCROLL */
#define _16SetProp SetProp
#define _16GetProp GetProp
#define _16RemoveProp RemoveProp
#define _16SetWindowText SetWindowText
#define _16GetWindowText GetWindowText
#define _16GetClientRect GetClientRect
#define _16EnumProps EnumProps
#define _16GetWindowRect GetWindowRect
#define _16AdjustWindowRect AdjustWindowRect
#define _16AdjustWindowRectEx AdjustWindowRectEx
#ifndef NOMB
#define _16MessageBox MessageBox
#endif /* NOMB */
#define _16GetCursorPos GetCursorPos
#define _16ClipCursor ClipCursor
#define _16GetCaretPos GetCaretPos
#define _16ClientToScreen ClientToScreen
#define _16ScreenToClient ScreenToClient
#ifndef NOCOLOR
#define _16SetSysColors SetSysColors
#endif /* NOCOLOR */
#define _16DrawFocusRect DrawFocusRect
#define _16FillRect FillRect
#define _16FrameRect FrameRect
#define _16InvertRect InvertRect
#define _16SetRect SetRect
#define _16SetRectEmpty SetRectEmpty
#define _16CopyRect CopyRect
#define _16InflateRect InflateRect
#define _16IntersectRect IntersectRect
#define _16UnionRect UnionRect
#define _16OffsetRect OffsetRect
#define _16IsRectEmpty IsRectEmpty
#define _16EqualRect EqualRect
#define _16PtInRect PtInRect
#define _16RectVisible RectVisible
#define _16RectInRegion RectInRegion
#define _16EnumChildWindows EnumChildWindows
#define _16FindWindow FindWindow
#define _16EnumWindows EnumWindows
#define _16EnumTaskWindows EnumTaskWindows
#define _16GetClassName GetClassName
#ifndef NOWH
#define _16SetWindowsHook SetWindowsHook
#define _16UnhookWindowsHook UnhookWindowsHook
#endif
#define _16LoadBitmap LoadBitmap
#define _16LoadCursor LoadCursor
#define _16CreateCursor CreateCursor
#define _16LoadIcon LoadIcon
#define _16CreateIcon CreateIcon
#define _16LoadString LoadString
#define _16AddFontResource AddFontResource
#define _16RemoveFontResource RemoveFontResource

#ifndef NOCTLMGR
#ifndef NOMSG
#define _16IsDialogMessage IsDialogMessage
#endif /* NOMSG */
#define _16MapDialogRect MapDialogRect
#define _16DlgDirList DlgDirList
#define _16DlgDirSelect DlgDirSelect
#define _16DlgDirListComboBox DlgDirListComboBox
#define _16DlgDirSelectComboBox DlgDirSelectComboBox
#endif /* NOCTLMGR */
#ifdef USECOMM
#define _16OpenComm OpenComm
#define _16SetCommState SetCommState
#define _16GetCommState GetCommState
#define _16ReadComm ReadComm
#define _16WriteComm WriteComm
#define _16GetCommError GetCommError
#define _16BuildCommDCB BuildCommDCB
#endif /* USECOMM */
#ifndef NOMDI
#ifndef NOMSG
#define _16TranslateMDISysAccel TranslateMDISysAccel
#endif /* NOMSG */
#endif /* NOMDI */

#ifndef NOLFILEIO
#define _16_lread _lread
#define _16_lwrite _lwrite
#endif
#endif /* NOUSER */
#ifndef NOHELP
#define _16WinHelp WinHelp
#endif /* NOHELP */

#ifdef INCLUDE_COMMDLG_H
#define _16ChooseColor ChooseColor
#define _16ChooseFont ChooseFont
#define _16FindText FindText
#define _16GetFileTitle GetFileTitle
#define _16GetOpenFileName GetOpenFileName
#define _16GetSaveFileName GetSaveFileName
#define _16PrintDlg PrintDlg
#define _16ReplaceText ReplaceText
#endif
#ifdef INCLUDE_DDEML_H
#define _16DdeConnectList DdeConnectList
#define _16DdeConnect DdeConnect
#define _16DdeQueryConvInfo DdeQueryConvInfo
#define _16DdeClientTransaction DdeClientTransaction
#define _16DdeCreateDataHandle DdeCreateDataHandle
#define _16DdeAddData DdeAddData
#define _16DdeGetData DdeGetData
#define _16DdeAccessData DdeAccessData
#define _16DdeCreateStringHandle DdeCreateStringHandle
#define _16DdeQueryString DdeQueryString
#define _16DdeInitialize DdeInitialize
#endif
#ifdef INCLUDE_PENWIN_H
#endif
#endif

#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\CDERR.H ===
/*****************************************************************************\
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1995, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CDERR
#define _INC_CDERR

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif  /* !_INC_CDERR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\ENVIRON.H ===
#ifndef _ENVIRON_H_
#define _ENVIRON_H_
/*************************** OS Specific Module ****************************\
*                                                                           *
* Module: ENVIRON.H                                                         *
*       WATCOM and Windows specific defines and pragmas.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)     1/06/95 - copied from nvrm.h.          *
*                                                                           *
\***************************************************************************/

#endif // _ENVIRON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\COMMDLG.H ===
/************************************************************************
*                                                                       *
*   commdlg.h -- This module defines the 32-Bit Common Dialog APIs      *
*                                                                       *
*   Copyright (c) 1992-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#include <pshpack1.h>         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#if(WINVER >= 0x0400)
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else   /* __cplusplus */
#define SNDMSG SendMessage
#endif  /* __cplusplus */
#endif /* WINVER >= 0x0400 */

typedef UINT (APIENTRY *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagOFNA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} OPENFILENAMEA, *LPOPENFILENAMEA;
typedef struct tagOFNW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} OPENFILENAMEW, *LPOPENFILENAMEW;
#ifdef UNICODE
typedef OPENFILENAMEW OPENFILENAME;
typedef LPOPENFILENAMEW LPOPENFILENAME;
#else
typedef OPENFILENAMEA OPENFILENAME;
typedef LPOPENFILENAMEA LPOPENFILENAME;
#endif // UNICODE

BOOL  APIENTRY     GetOpenFileNameA(LPOPENFILENAMEA);
BOOL  APIENTRY     GetOpenFileNameW(LPOPENFILENAMEW);
#ifdef UNICODE
#define GetOpenFileName  GetOpenFileNameW
#else
#define GetOpenFileName  GetOpenFileNameA
#endif // !UNICODE
BOOL  APIENTRY     GetSaveFileNameA(LPOPENFILENAMEA);
BOOL  APIENTRY     GetSaveFileNameW(LPOPENFILENAMEW);
#ifdef UNICODE
#define GetSaveFileName  GetSaveFileNameW
#else
#define GetSaveFileName  GetSaveFileNameA
#endif // !UNICODE
short APIENTRY     GetFileTitleA(LPCSTR, LPSTR, WORD);
short APIENTRY     GetFileTitleW(LPCWSTR, LPWSTR, WORD);
#ifdef UNICODE
#define GetFileTitle  GetFileTitleW
#else
#define GetFileTitle  GetFileTitleA
#endif // !UNICODE

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_NOLONGNAMES              0x00040000     // force no long names for 4.x modules
#if(WINVER >= 0x0400)
#define OFN_EXPLORER                 0x00080000     // new look commdlg
#define OFN_NODEREFERENCELINKS       0x00100000
#define OFN_LONGNAMES                0x00200000     // force long names for 3.x modules
#endif /* WINVER >= 0x0400 */

// Return values for the registered message sent to the hook function
// when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
// filename to be accepted, OFN_SHARENOWARN rejects the name but puts
// up no warning (returned when the app has already put up a warning
// message), and OFN_SHAREWARN puts up the default warning message
// for sharing violations.
//
// Note:  Undefined return values map to OFN_SHAREWARN, but are
//        reserved for future use.

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef UINT (APIENTRY *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#if(WINVER >= 0x0400)
// Structure used for all OpenFileName notifications
typedef struct _OFNOTIFYA
{
        NMHDR           hdr;
        LPOPENFILENAMEA lpOFN;
        LPSTR           pszFile;        // May be NULL
} OFNOTIFYA, FAR *LPOFNOTIFYA;
// Structure used for all OpenFileName notifications
typedef struct _OFNOTIFYW
{
        NMHDR           hdr;
        LPOPENFILENAMEW lpOFN;
        LPWSTR          pszFile;        // May be NULL
} OFNOTIFYW, FAR *LPOFNOTIFYW;
#ifdef UNICODE
typedef OFNOTIFYW OFNOTIFY;
typedef LPOFNOTIFYW LPOFNOTIFY;
#else
typedef OFNOTIFYA OFNOTIFY;
typedef LPOFNOTIFYA LPOFNOTIFY;
#endif // UNICODE

#define CDN_FIRST   (0U-601U)
#define CDN_LAST    (0U-699U)

// Notifications when Open or Save dialog status changes
#define CDN_INITDONE            (CDN_FIRST - 0x0000)
#define CDN_SELCHANGE           (CDN_FIRST - 0x0001)
#define CDN_FOLDERCHANGE        (CDN_FIRST - 0x0002)
#define CDN_SHAREVIOLATION      (CDN_FIRST - 0x0003)
#define CDN_HELP                (CDN_FIRST - 0x0004)
#define CDN_FILEOK              (CDN_FIRST - 0x0005)
#define CDN_TYPECHANGE          (CDN_FIRST - 0x0006)

#define CDM_FIRST       (WM_USER + 100)
#define CDM_LAST        (WM_USER + 200)

// Messages to query information from the Open or Save dialogs

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETSPEC             (CDM_FIRST + 0x0000)
#define CommDlg_OpenSave_GetSpecA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetSpecW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecW
#else
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFILEPATH         (CDM_FIRST + 0x0001)
#define CommDlg_OpenSave_GetFilePathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFilePathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathW
#else
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFOLDERPATH       (CDM_FIRST + 0x0002)
#define CommDlg_OpenSave_GetFolderPathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFolderPathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathW
#else
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathA
#endif // !UNICODE

// lParam = pointer to ITEMIDLIST buffer that gets filled in
// wParam = size of the ITEMIDLIST buffer
// return = < 0 if error; length of buffer needed
#define CDM_GETFOLDERIDLIST     (CDM_FIRST + 0x0003)
#define CommDlg_OpenSave_GetFolderIDList(_hdlg, _pidl, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERIDLIST, (WPARAM)_cbmax, (LPARAM)(LPVOID)_pidl)

// lParam = pointer to a string
// wParam = ID of control to change
// return = not used
#define CDM_SETCONTROLTEXT      (CDM_FIRST + 0x0004)
#define CommDlg_OpenSave_SetControlText(_hdlg, _id, _text) \
        (void)SNDMSG(_hdlg, CDM_SETCONTROLTEXT, (WPARAM)_id, (LPARAM)(LPSTR)_text)

// lParam = not used
// wParam = ID of control to change
// return = not used
#define CDM_HIDECONTROL         (CDM_FIRST + 0x0005)
#define CommDlg_OpenSave_HideControl(_hdlg, _id) \
        (void)SNDMSG(_hdlg, CDM_HIDECONTROL, (WPARAM)_id, 0)

// lParam = pointer to default extension (no dot)
// wParam = not used
// return = not used
#define CDM_SETDEFEXT           (CDM_FIRST + 0x0006)
#define CommDlg_OpenSave_SetDefExt(_hdlg, _pszext) \
        (void)SNDMSG(_hdlg, CDM_SETDEFEXT, 0, (LPARAM)(LPSTR)_pszext)
#endif /* WINVER >= 0x0400 */

typedef struct tagCHOOSECOLORA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} CHOOSECOLORA, *LPCHOOSECOLORA;
typedef struct tagCHOOSECOLORW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} CHOOSECOLORW, *LPCHOOSECOLORW;
#ifdef UNICODE
typedef CHOOSECOLORW CHOOSECOLOR;
typedef LPCHOOSECOLORW LPCHOOSECOLOR;
#else
typedef CHOOSECOLORA CHOOSECOLOR;
typedef LPCHOOSECOLORA LPCHOOSECOLOR;
#endif // UNICODE

BOOL  APIENTRY ChooseColorA(LPCHOOSECOLORA);
BOOL  APIENTRY ChooseColorW(LPCHOOSECOLORW);
#ifdef UNICODE
#define ChooseColor  ChooseColorW
#else
#define ChooseColor  ChooseColorA
#endif // !UNICODE

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040
#if(WINVER >= 0x0400)
#define CC_SOLIDCOLOR            0x00000080
#define CC_ANYCOLOR              0x00000100
#endif /* WINVER >= 0x0400 */

typedef UINT (APIENTRY *LPFRHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagFINDREPLACEA {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPSTR        lpstrFindWhat;      // ptr. to search string
   LPSTR        lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCSTR       lpTemplateName;     // custom template name
} FINDREPLACEA, *LPFINDREPLACEA;
typedef struct tagFINDREPLACEW {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPWSTR       lpstrFindWhat;      // ptr. to search string
   LPWSTR       lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCWSTR      lpTemplateName;     // custom template name
} FINDREPLACEW, *LPFINDREPLACEW;
#ifdef UNICODE
typedef FINDREPLACEW FINDREPLACE;
typedef LPFINDREPLACEW LPFINDREPLACE;
#else
typedef FINDREPLACEA FINDREPLACE;
typedef LPFINDREPLACEA LPFINDREPLACE;
#endif // UNICODE

#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#define FR_FINDNEXT                     0x00000008
#define FR_REPLACE                      0x00000010
#define FR_REPLACEALL                   0x00000020
#define FR_DIALOGTERM                   0x00000040
#define FR_SHOWHELP                     0x00000080
#define FR_ENABLEHOOK                   0x00000100
#define FR_ENABLETEMPLATE               0x00000200
#define FR_NOUPDOWN                     0x00000400
#define FR_NOMATCHCASE                  0x00000800
#define FR_NOWHOLEWORD                  0x00001000
#define FR_ENABLETEMPLATEHANDLE         0x00002000
#define FR_HIDEUPDOWN                   0x00004000
#define FR_HIDEMATCHCASE                0x00008000
#define FR_HIDEWHOLEWORD                0x00010000

HWND  APIENTRY    FindTextA(LPFINDREPLACEA);
HWND  APIENTRY    FindTextW(LPFINDREPLACEW);
#ifdef UNICODE
#define FindText  FindTextW
#else
#define FindText  FindTextA
#endif // !UNICODE
HWND  APIENTRY    ReplaceTextA(LPFINDREPLACEA);
HWND  APIENTRY    ReplaceTextW(LPFINDREPLACEW);
#ifdef UNICODE
#define ReplaceText  ReplaceTextW
#else
#define ReplaceText  ReplaceTextA
#endif // !UNICODE

typedef UINT (APIENTRY *LPCFHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSEFONTA {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTA      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCSTR          lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPSTR           lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTA, *LPCHOOSEFONTA;
typedef struct tagCHOOSEFONTW {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTW      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCWSTR         lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPWSTR          lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTW, *LPCHOOSEFONTW;
#ifdef UNICODE
typedef CHOOSEFONTW CHOOSEFONT;
typedef LPCHOOSEFONTW LPCHOOSEFONT;
#else
typedef CHOOSEFONTA CHOOSEFONT;
typedef LPCHOOSEFONTA LPCHOOSEFONT;
#endif // UNICODE

BOOL APIENTRY ChooseFontA(LPCHOOSEFONTA);
BOOL APIENTRY ChooseFontW(LPCHOOSEFONTW);
#ifdef UNICODE
#define ChooseFont  ChooseFontW
#else
#define ChooseFont  ChooseFontA
#endif // !UNICODE

#define CF_SCREENFONTS             0x00000001
#define CF_PRINTERFONTS            0x00000002
#define CF_BOTH                    (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                0x00000004L
#define CF_ENABLEHOOK              0x00000008L
#define CF_ENABLETEMPLATE          0x00000010L
#define CF_ENABLETEMPLATEHANDLE    0x00000020L
#define CF_INITTOLOGFONTSTRUCT     0x00000040L
#define CF_USESTYLE                0x00000080L
#define CF_EFFECTS                 0x00000100L
#define CF_APPLY                   0x00000200L
#define CF_ANSIONLY                0x00000400L
#if(WINVER >= 0x0400)
#define CF_SCRIPTSONLY             CF_ANSIONLY
#endif /* WINVER >= 0x0400 */
#define CF_NOVECTORFONTS           0x00000800L
#define CF_NOOEMFONTS              CF_NOVECTORFONTS
#define CF_NOSIMULATIONS           0x00001000L
#define CF_LIMITSIZE               0x00002000L
#define CF_FIXEDPITCHONLY          0x00004000L
#define CF_WYSIWYG                 0x00008000L // must also have CF_SCREENFONTS & CF_PRINTERFONTS
#define CF_FORCEFONTEXIST          0x00010000L
#define CF_SCALABLEONLY            0x00020000L
#define CF_TTONLY                  0x00040000L
#define CF_NOFACESEL               0x00080000L
#define CF_NOSTYLESEL              0x00100000L
#define CF_NOSIZESEL               0x00200000L
#if(WINVER >= 0x0400)
#define CF_SELECTSCRIPT            0x00400000L
#define CF_NOSCRIPTSEL             0x00800000L
#define CF_NOVERTFONTS             0x01000000L
#endif /* WINVER >= 0x0400 */

// these are extra nFontType bits that are added to what is returned to the
// EnumFonts callback routine

#define SIMULATED_FONTTYPE    0x8000
#define PRINTER_FONTTYPE      0x4000
#define SCREEN_FONTTYPE       0x2000
#define BOLD_FONTTYPE         0x0100
#define ITALIC_FONTTYPE       0x0200
#define REGULAR_FONTTYPE      0x0400

#define WM_CHOOSEFONT_GETLOGFONT      (WM_USER + 1)
#define WM_CHOOSEFONT_SETLOGFONT      (WM_USER + 101)
#define WM_CHOOSEFONT_SETFLAGS        (WM_USER + 102)

// strings used to obtain unique window message for communication
// between dialog and caller

#define LBSELCHSTRINGA  "commdlg_LBSelChangedNotify"
#define SHAREVISTRINGA  "commdlg_ShareViolation"
#define FILEOKSTRINGA   "commdlg_FileNameOK"
#define COLOROKSTRINGA  "commdlg_ColorOK"
#define SETRGBSTRINGA   "commdlg_SetRGBColor"
#define HELPMSGSTRINGA  "commdlg_help"
#define FINDMSGSTRINGA  "commdlg_FindReplace"

#define LBSELCHSTRINGW  L"commdlg_LBSelChangedNotify"
#define SHAREVISTRINGW  L"commdlg_ShareViolation"
#define FILEOKSTRINGW   L"commdlg_FileNameOK"
#define COLOROKSTRINGW  L"commdlg_ColorOK"
#define SETRGBSTRINGW   L"commdlg_SetRGBColor"
#define HELPMSGSTRINGW  L"commdlg_help"
#define FINDMSGSTRINGW  L"commdlg_FindReplace"

#ifdef UNICODE
#define LBSELCHSTRING  LBSELCHSTRINGW
#define SHAREVISTRING  SHAREVISTRINGW
#define FILEOKSTRING   FILEOKSTRINGW
#define COLOROKSTRING  COLOROKSTRINGW
#define SETRGBSTRING   SETRGBSTRINGW
#define HELPMSGSTRING  HELPMSGSTRINGW
#define FINDMSGSTRING  FINDMSGSTRINGW
#else
#define LBSELCHSTRING  LBSELCHSTRINGA
#define SHAREVISTRING  SHAREVISTRINGA
#define FILEOKSTRING   FILEOKSTRINGA
#define COLOROKSTRING  COLOROKSTRINGA
#define SETRGBSTRING   SETRGBSTRINGA
#define HELPMSGSTRING  HELPMSGSTRINGA
#define FINDMSGSTRING  FINDMSGSTRINGA
#endif

// HIWORD values for lParam of commdlg_LBSelChangeNotify message
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef UINT (APIENTRY *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (APIENTRY *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagPDA {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCSTR           lpPrintTemplateName;
   LPCSTR           lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGA, *LPPRINTDLGA;
typedef struct tagPDW {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCWSTR          lpPrintTemplateName;
   LPCWSTR          lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGW, *LPPRINTDLGW;
#ifdef UNICODE
typedef PRINTDLGW PRINTDLG;
typedef LPPRINTDLGW LPPRINTDLG;
#else
typedef PRINTDLGA PRINTDLG;
typedef LPPRINTDLGA LPPRINTDLG;
#endif // UNICODE

BOOL  APIENTRY     PrintDlgA(LPPRINTDLGA);
BOOL  APIENTRY     PrintDlgW(LPPRINTDLGW);
#ifdef UNICODE
#define PrintDlg  PrintDlgW
#else
#define PrintDlg  PrintDlgA
#endif // !UNICODE

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_USEDEVMODECOPIESANDCOLLATE 0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000
#define PD_NONETWORKBUTTON           0x00200000

typedef struct tagDEVNAMES {
   WORD wDriverOffset;
   WORD wDeviceOffset;
   WORD wOutputOffset;
   WORD wDefault;
} DEVNAMES;

typedef DEVNAMES * LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD APIENTRY     CommDlgExtendedError(VOID);

#if(WINVER >= 0x0400)
#define WM_PSD_PAGESETUPDLG     (WM_USER  )
#define WM_PSD_FULLPAGERECT     (WM_USER+1)
#define WM_PSD_MINMARGINRECT    (WM_USER+2)
#define WM_PSD_MARGINRECT       (WM_USER+3)
#define WM_PSD_GREEKTEXTRECT    (WM_USER+4)
#define WM_PSD_ENVSTAMPRECT     (WM_USER+5)
#define WM_PSD_YAFULLPAGERECT   (WM_USER+6)

typedef UINT (APIENTRY* LPPAGEPAINTHOOK)( HWND, UINT, WPARAM, LPARAM );
typedef UINT (APIENTRY* LPPAGESETUPHOOK)( HWND, UINT, WPARAM, LPARAM );

typedef struct tagPSDA
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCSTR          lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGA, * LPPAGESETUPDLGA;
typedef struct tagPSDW
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCWSTR         lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGW, * LPPAGESETUPDLGW;
#ifdef UNICODE
typedef PAGESETUPDLGW PAGESETUPDLG;
typedef LPPAGESETUPDLGW LPPAGESETUPDLG;
#else
typedef PAGESETUPDLGA PAGESETUPDLG;
typedef LPPAGESETUPDLGA LPPAGESETUPDLG;
#endif // UNICODE

BOOL APIENTRY PageSetupDlgA( LPPAGESETUPDLGA );
BOOL APIENTRY PageSetupDlgW( LPPAGESETUPDLGW );
#ifdef UNICODE
#define PageSetupDlg  PageSetupDlgW
#else
#define PageSetupDlg  PageSetupDlgA
#endif // !UNICODE

#define PSD_DEFAULTMINMARGINS             0x00000000 // default (printer's)
#define PSD_INWININIINTLMEASURE           0x00000000 // 1st of 4 possible

#define PSD_MINMARGINS                    0x00000001 // use caller's
#define PSD_MARGINS                       0x00000002 // use caller's
#define PSD_INTHOUSANDTHSOFINCHES         0x00000004 // 2nd of 4 possible
#define PSD_INHUNDREDTHSOFMILLIMETERS     0x00000008 // 3rd of 4 possible
#define PSD_DISABLEMARGINS                0x00000010
#define PSD_DISABLEPRINTER                0x00000020
#define PSD_NOWARNING                     0x00000080 // must be same as PD_*
#define PSD_DISABLEORIENTATION            0x00000100
#define PSD_RETURNDEFAULT                 0x00000400 // must be same as PD_*
#define PSD_DISABLEPAPER                  0x00000200
#define PSD_SHOWHELP                      0x00000800 // must be same as PD_*
#define PSD_ENABLEPAGESETUPHOOK           0x00002000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATE       0x00008000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE 0x00020000 // must be same as PD_*
#define PSD_ENABLEPAGEPAINTHOOK           0x00040000
#define PSD_DISABLEPAGEPAINTING           0x00080000
#endif /* WINVER >= 0x0400 */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>
#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\CTYPE.H ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#ifndef _INC_CTYPE
#define _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * These declarations allow the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */
#ifndef _CTYPE_DISABLE_MACROS

#ifdef	_NTSDK

/* Definitions and declarations compatible with the NT SDK */

#ifdef	_DLL

extern unsigned short * _ctype;
#define _pctype     (*_pctype_dll)
extern unsigned short **_pctype_dll;
#define _pwctype    (*_pwctype_dll)
extern unsigned short **_pwctype_dll;

#else	/* _DLL */


extern unsigned short _ctype[];
extern unsigned short *_pctype;
extern wctype_t *_pwctype;

#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* Current declarations */

_CRTIMP extern unsigned short _ctype[];

#if	defined(_DLL) && defined(_M_IX86)

#define _pctype     (*__p__pctype())
_CRTIMP unsigned short ** __cdecl __p__pctype(void);

#define _pwctype    (*__p__pwctype())
_CRTIMP wctype_t ** __cdecl ___p__pwctype(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern unsigned short *_pctype;
_CRTIMP extern wctype_t *_pwctype;

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* _CTYPE_DISABLE_MACROS */

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

#define _LEADBYTE	0x8000			/* multibyte leadbyte */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	/* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);

_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS


/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX

#ifdef	_NTSDK

/* definition compatible with NT SDK */
#ifdef	_DLL
#define __mb_cur_max	(*__mb_cur_max_dll)
#define MB_CUR_MAX	(*__mb_cur_max_dll)
extern	unsigned short *__mb_cur_max_dll;
#else	/* ndef _DLL */
#define MB_CUR_MAX __mb_cur_max
extern	unsigned short __mb_cur_max;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current definition */
#if	defined(_DLL) && defined(_M_IX86)
#define MB_CUR_MAX (*__p___mb_cur_max())
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#else	/* !(defined(_DLL) && defined(_M_IX86)) */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* MB_CUR_MAX */

#define isalpha(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : _pctype[_c] & _ALPHA)
#define isupper(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : _pctype[_c] & _UPPER)
#define islower(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : _pctype[_c] & _LOWER)
#define isdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : _pctype[_c] & _DIGIT)
#define isxdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : _pctype[_c] & _HEX)
#define isspace(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : _pctype[_c] & _SPACE)
#define ispunct(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : _pctype[_c] & _PUNCT)
#define isalnum(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : _pctype[_c] & (_ALPHA|_DIGIT))
#define isprint(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))
#define isgraph(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_PUNCT|_ALPHA|_DIGIT))
#define iscntrl(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : _pctype[_c] & _CONTROL)


#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )

#define __isascii(_c)	( (unsigned)(_c) < 0x80 )
#define __toascii(_c)	( (_c) & 0x7f )

#define iswalpha(_c)	( iswctype(_c,_ALPHA) )
#define iswupper(_c)	( iswctype(_c,_UPPER) )
#define iswlower(_c)	( iswctype(_c,_LOWER) )
#define iswdigit(_c)	( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)	( iswctype(_c,_HEX) )
#define iswspace(_c)	( iswctype(_c,_SPACE) )
#define iswpunct(_c)	( iswctype(_c,_PUNCT) )
#define iswalnum(_c)	( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)	( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)	( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)	( iswctype(_c,_CONTROL) )
#define iswascii(_c)	( (unsigned)(_c) < 0x80 )


#define isleadbyte(_c)	(_pctype[(unsigned char)(_c)] & _LEADBYTE)


/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)	(isalnum(_c) || ((_c) == '_'))

#endif /* _CTYPE_DISABLE_MACROS */

#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym

#else	/* ndef _NTSDK */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym
#endif

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif


#endif	/* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DDE.H ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
* Copyright (c) 1993-1995, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/
#ifndef _DDEHEADER_INCLUDED_
#define _DDEHEADER_INCLUDED_

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)

/*----------------------------------------------------------------------------
|       DDEACK structure
|
|	Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short bAppReturnCode:8,
                 reserved:6,
                 fBusy:1,
		 fAck:1;
} DDEACK;


/*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|	WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short reserved:14,
                 fDeferUpd:1,
		 fAckReq:1;
	short     cfFormat;
} DDEADVISE;


/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:12,
                 fResponse:1,
                 fRelease:1,
                 reserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 Value[1];
} DDEDATA;


/*----------------------------------------------------------------------------
|	DDEPOKE structure
|
|	WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:13,  /* Earlier versions of DDE.H incorrectly */
                             /* 12 unused bits.                       */
		 fRelease:1,
		 fReserved:2;
	short    cfFormat;
	BYTE	 Value[1];  /* This member was named rgb[1] in previous */
                            /* versions of DDE.H                        */

} DDEPOKE;

/*----------------------------------------------------------------------------
The following typedef's were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.

Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
not correctly define the bit positions.
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
		 fAckReq:1;
	short	 cfFormat;
} DDELN;

typedef struct {
	unsigned short unused:12,
                 fAck:1,
                 fRelease:1,
                 fReserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 rgb[1];
} DDEUP;


/*
 * DDE SECURITY
 */

BOOL
WINAPI
DdeSetQualityOfService(
    HWND hwndClient,
    CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    PSECURITY_QUALITY_OF_SERVICE pqosPrev);

BOOL
WINAPI
ImpersonateDdeClientWindow(
    HWND hWndClient,
    HWND hWndServer);

/*
 * DDE message packing APIs
 */
LONG APIENTRY PackDDElParam(UINT msg, UINT uiLo, UINT uiHi);
BOOL APIENTRY UnpackDDElParam(UINT msg, LONG lParam, PUINT puiLo, PUINT puiHi);
BOOL APIENTRY FreeDDElParam(UINT msg, LONG lParam);
LONG APIENTRY ReuseDDElParam(LONG lParam, UINT msgIn, UINT msgOut, UINT uiLo, UINT uiHi);

#ifdef __cplusplus
}
#endif

#endif // _DDEHEADER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DLGS.H ===
/*---------------------------------------------------------------------------*/
/* Dlgs.h : UI dialog header                                                 */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1990-1995                            */
/*---------------------------------------------------------------------------*/

#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_

/*----Constants--------------------------------------------------------------*/
#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#if (WINVER >= 0x30a)
#define PAGESETUPDLGORD  1546
#endif /* WINVER >= 0x30a)



/*----Types------------------------------------------------------------------*/
typedef struct tagCRGB
    {
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
    }
CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DRIVINIT.H ===
// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DDEML.H ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/

/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1993-95, Microsoft Corp.  All rights reserved.  *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEMLH
#define _INC_DDEMLH

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/******** public types ********/

DECLARE_HANDLE(HCONVLIST);
DECLARE_HANDLE(HCONV);
DECLARE_HANDLE(HSZ);
DECLARE_HANDLE(HDDEDATA);
#define EXPENTRY        CALLBACK

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT {
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
    SECURITY_QUALITY_OF_SERVICE qos;  /* client side's quality of service */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;


/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO {
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* window handle for this conversation */
    HWND    hwndPartner;   /* partner window handle for this conversation */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED            0x0001
#define     ST_ADVISE               0x0002
#define     ST_ISLOCAL              0x0004
#define     ST_BLOCKED              0x0008
#define     ST_CLIENT               0x0010
#define     ST_TERMINATED           0x0020
#define     ST_INLIST               0x0040
#define     ST_BLOCKNEXT            0x0080
#define     ST_ISSELF               0x0100


/* DDE constants for wStatus field */

#define DDE_FACK                0x8000
#define DDE_FBUSY               0x4000
#define DDE_FDEFERUPD           0x4000
#define DDE_FACKREQ             0x8000
#define DDE_FRELEASE            0x2000
#define DDE_FREQUESTED          0x1000
#define DDE_FAPPSTATUS          0x00ff
#define DDE_FNOTPROCESSED       0x0000

#define DDE_FACKRESERVED        (~(DDE_FACK | DDE_FBUSY | DDE_FAPPSTATUS))
#define DDE_FADVRESERVED        (~(DDE_FACKREQ | DDE_FDEFERUPD))
#define DDE_FDATRESERVED        (~(DDE_FACKREQ | DDE_FRELEASE | DDE_FREQUESTED))
#define DDE_FPOKRESERVED        (~(DDE_FRELEASE))

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */
#define CP_WINUNICODE   1200

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           0xFFFFFFFF

/***** Transaction ID constants *****/

#define     QID_SYNC                0xFFFFFFFF

/****** public strings used in DDE ******/

#ifdef UNICODE
#define SZDDESYS_TOPIC         L"System"
#define SZDDESYS_ITEM_TOPICS   L"Topics"
#define SZDDESYS_ITEM_SYSITEMS L"SysItems"
#define SZDDESYS_ITEM_RTNMSG   L"ReturnMessage"
#define SZDDESYS_ITEM_STATUS   L"Status"
#define SZDDESYS_ITEM_FORMATS  L"Formats"
#define SZDDESYS_ITEM_HELP     L"Help"
#define SZDDE_ITEM_ITEMLIST    L"TopicItemList"
#else
#define SZDDESYS_TOPIC         "System"
#define SZDDESYS_ITEM_TOPICS   "Topics"
#define SZDDESYS_ITEM_SYSITEMS "SysItems"
#define SZDDESYS_ITEM_RTNMSG   "ReturnMessage"
#define SZDDESYS_ITEM_STATUS   "Status"
#define SZDDESYS_ITEM_FORMATS  "Formats"
#define SZDDESYS_ITEM_HELP     "Help"
#define SZDDE_ITEM_ITEMLIST    "TopicItemList"
#endif


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef HDDEDATA (CALLBACK *PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);

#define     CBR_BLOCK           ((HDDEDATA)0xffffffffL)

/* DLL registration functions */

UINT WINAPI DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
UINT WINAPI DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
#ifdef UNICODE
#define DdeInitialize  DdeInitializeW
#else
#define DdeInitialize  DdeInitializeA
#endif // !UNICODE

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL



BOOL WINAPI DdeUninitialize(DWORD idInst);

/*
 * conversation enumeration functions
 */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
        HCONVLIST hConvList, PCONVCONTEXT pCC);
HCONV WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL WINAPI DdeDisconnectList(HCONVLIST hConvList);

/*
 * conversation control functions
 */

HCONV WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
        PCONVCONTEXT pCC);
BOOL WINAPI DdeDisconnect(HCONV hConv);
HCONV WINAPI DdeReconnect(HCONV hConv);
UINT WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);
BOOL WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);
BOOL WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/*
 * app server interface functions
 */

BOOL WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);
BOOL WINAPI DdeImpersonateClient(HCONV hConv);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2


HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/*
 * app client interface functions
 */

HDDEDATA WINAPI DdeClientTransaction(LPBYTE pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, LPDWORD pdwResult);

/*
 *data transfer functions
 */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb,
        DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);
DWORD WINAPI DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff);
LPBYTE WINAPI DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);
BOOL WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001


UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ  WINAPI DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage);
HSZ  WINAPI DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
#ifdef UNICODE
#define DdeCreateStringHandle  DdeCreateStringHandleW
#else
#define DdeCreateStringHandle  DdeCreateStringHandleA
#endif // !UNICODE
DWORD WINAPI DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
DWORD WINAPI DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);
#ifdef UNICODE
#define DdeQueryString  DdeQueryStringW
#else
#define DdeQueryString  DdeQueryStringA
#endif // !UNICODE
BOOL WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/*
 * DDEML public debugging header file info
 */

typedef struct tagDDEML_MSG_HOOK_DATA {    // new for NT
    UINT uiLo;      // unpacked lo and hi parts of lParam
    UINT uiHi;
    DWORD cbData;   // amount of data in message, if any. May be > than 32 bytes.
    DWORD Data[8];  // data peeking by DDESPY is limited to 32 bytes.
} DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;


typedef struct tagMONMSGSTRUCT {
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
    DDEML_MSG_HOOK_DATA dmhd;       // new for NT
} MONMSGSTRUCT, *PMONMSGSTRUCT;

typedef struct tagMONCBSTRUCT {
    UINT   cb;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
    CONVCONTEXT cc;                 // new for NT for XTYP_CONNECT callbacks
    DWORD  cbData;                  // new for NT for data peeking
    DWORD  Data[8];                 // new for NT for data peeking
} MONCBSTRUCT, *PMONCBSTRUCT;

typedef struct tagMONHSZSTRUCTA {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    CHAR    str[1];
} MONHSZSTRUCTA, *PMONHSZSTRUCTA;
typedef struct tagMONHSZSTRUCTW {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WCHAR   str[1];
} MONHSZSTRUCTW, *PMONHSZSTRUCTW;
#ifdef UNICODE
typedef MONHSZSTRUCTW MONHSZSTRUCT;
typedef PMONHSZSTRUCTW PMONHSZSTRUCT;
#else
typedef MONHSZSTRUCTA MONHSZSTRUCT;
typedef PMONHSZSTRUCTA PMONHSZSTRUCT;
#endif // UNICODE

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4

typedef struct tagMONERRSTRUCT {
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;

typedef struct tagMONLINKSTRUCT {
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT {
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;        // Globally unique value != apps local hConv
    HCONV   hConvServer;        // Globally unique value != apps local hConv
} MONCONVSTRUCT, PMONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\EXCPT.H ===
/***
*excpt.h - defines exception values, types and routines
*
*	Copyright (c) 1990-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the definitions and prototypes for the compiler-
*	dependent intrinsics, support functions and keywords which implement
*	the structured exception handling extensions.
*
****/

#ifndef _INC_EXCPT
#define _INC_EXCPT

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef	_M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
	struct _EXCEPTION_RECORD *ExceptionRecord,
	void * EstablisherFrame,
	struct _CONTEXT *ContextRecord,
	void * DispatcherContext
	);

#elif	defined(_M_MRX000) || defined(_M_ALPHA)

/*
 * Declarations to keep MIPS and ALPHA compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


EXCEPTION_DISPOSITION __C_specific_handler (
	struct _EXCEPTION_RECORD *ExceptionRecord,
	void *EstablisherFrame,
	struct _CONTEXT *ContextRecord,
	struct _DISPATCHER_CONTEXT *DispatcherContext
	);

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef	_MSC_VER

#if	defined(_NTSDK) && !defined(__cplusplus)
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#endif	/* _NTSDK */
#define GetExceptionCode		_exception_code
#define exception_code			_exception_code
#define GetExceptionInformation 	(struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info			(struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination		_abnormal_termination
#define abnormal_termination		_abnormal_termination

unsigned long __cdecl _exception_code(void);
void *	      __cdecl _exception_info(void);
int	      __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER	 1
#define EXCEPTION_CONTINUE_SEARCH	 0
#define EXCEPTION_CONTINUE_EXECUTION	-1



#ifdef __cplusplus
}
#endif

#endif	/* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\IMM.H ===
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1995  Microsoft Corporation                */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_        // defined if IMM.H has been included

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINUSER_
#define VK_PROCESSKEY 0x0E5
#endif

typedef DWORD     HIMC;
typedef DWORD     HIMCC;

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;

typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;

typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE

// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(HWND);

UINT WINAPI ImmGetDescriptionA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(HKL, DWORD);

BOOL WINAPI ImmIsIME(HKL);

BOOL WINAPI ImmSimulateHotKey(HWND, DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(HIMC);
HIMC WINAPI ImmGetContext(HWND);
BOOL WINAPI ImmReleaseContext(HWND, HIMC);
HIMC WINAPI ImmAssociateContext(HWND, HIMC);

LONG  WINAPI ImmGetCompositionStringA(HIMC, DWORD, LPVOID, DWORD);
LONG  WINAPI ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
BOOL  WINAPI ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount);
DWORD WINAPI ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
DWORD WINAPI ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR, DWORD dwBufLen);
DWORD WINAPI ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL WINAPI ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL WINAPI ImmGetOpenStatus(HIMC);
BOOL WINAPI ImmSetOpenStatus(HIMC, BOOL);

BOOL WINAPI ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE

#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE
BOOL    WINAPI ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL    WINAPI ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT WINAPI ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListA(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
DWORD   WINAPI ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

BOOL WINAPI ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE

UINT WINAPI ImmGetVirtualKey(HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
BOOL WINAPI ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
BOOL WINAPI ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
UINT WINAPI ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#ifndef _WINUSER_ 
// the IME related messages
#define WM_CONVERTREQUESTEX             0x0108
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286

#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291

// wParam for WM_IME_CONTROL                 
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022

#endif /* !_WINUSER_ */

// wParam for WM_IME_CONTROL to the soft keyboard
// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F

// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202

// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// bits of fdwInit of INPUTCONTEXT
// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000

// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002

// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002

// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004

// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF

// ID for dwIndex of ImmGetProperty
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_SCREEN                      0x0004
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400

#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008

// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

#ifndef _WINUSER_
// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E
#endif

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)

// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3

// dialog mode of ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF
#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\CGUID.H ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cguid.h
//
//--------------------------------------------------------------------------

#ifndef __CGUID_H__
#define __CGUID_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const IID GUID_NULL;
extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;

//********************************************
//
// CD Forms CLSIDs
//
//********************************************

//
// Form Kernel objects
//
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;

//
// Control objects
//
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;

//
// Property Pages
//
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;

extern const CLSID CLSID_CStdPropertyFrame;

extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;

extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;

extern const CLSID CLSID_IdentityUnmarshal;
extern const CLSID CLSID_InProcFreeMarshaler;

extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;

//
// Enumerations
//
extern const GUID GUID_TRISTATE;

#ifdef __cplusplus
}
#endif


#endif // __CGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\LZEXPAND.H ===
/*
** lzdos.h - Public interface to LZEXP?.LIB.
*/

#ifndef _LZEXPAND_
#define _LZEXPAND_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Error Return Codes
*/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of acceptable range*/
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */


/*
** Prototypes
*/

INT
APIENTRY
LZStart(
	VOID
	);

VOID
APIENTRY
LZDone(
	VOID
	);

LONG
APIENTRY
CopyLZFile(
	INT,
	INT
	);

LONG
APIENTRY
LZCopy(
	INT,
	INT
	);

INT
APIENTRY
LZInit(
	INT
	);

INT
APIENTRY
GetExpandedNameA(
	LPSTR,
	LPSTR
	);
INT
APIENTRY
GetExpandedNameW(
	LPWSTR,
	LPWSTR
	);
#ifdef UNICODE
#define GetExpandedName  GetExpandedNameW
#else
#define GetExpandedName  GetExpandedNameA
#endif // !UNICODE

INT
APIENTRY
LZOpenFileA(
	LPSTR,
	LPOFSTRUCT,
	WORD
	);
INT
APIENTRY
LZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	);
#ifdef UNICODE
#define LZOpenFile  LZOpenFileW
#else
#define LZOpenFile  LZOpenFileA
#endif // !UNICODE

LONG
APIENTRY
LZSeek(
	INT,
	LONG,
	INT
	);

INT
APIENTRY
LZRead(
	INT,
	LPSTR,
	INT
	);

VOID
APIENTRY
LZClose(
	INT
	);

#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\MCX.H ===
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _MCX_H_
#define _MCX_H_

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in seconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // seconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap
    
    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING  0x00000040  // Supports wait for bong "$"
#define DIALOPTION_QUIET    0x00000080  // Supports wait for quiet "@"
#define DIALOPTION_DIALTONE 0x00000100  // Supports wait for dial tone "W"

// SpeakerVolume for MODEMDEVCAPS
#define MDMVOLFLAG_LOW      0x00000001
#define MDMVOLFLAG_MEDIUM   0x00000002 
#define MDMVOLFLAG_HIGH     0x00000004 

// SpeakerVolume for MODEMSETTINGS
#define MDMVOL_LOW          0x00000000
#define MDMVOL_MEDIUM       0x00000001 
#define MDMVOL_HIGH         0x00000002

// SpeakerMode for MODEMDEVCAPS
#define MDMSPKRFLAG_OFF         0x00000001 
#define MDMSPKRFLAG_DIAL        0x00000002 
#define MDMSPKRFLAG_ON          0x00000004 
#define MDMSPKRFLAG_CALLSETUP   0x00000008

// SpeakerMode for MODEMSETTINGS
#define MDMSPKR_OFF         0x00000000 
#define MDMSPKR_DIAL        0x00000001 
#define MDMSPKR_ON          0x00000002 
#define MDMSPKR_CALLSETUP   0x00000003 
 
// Modem Options
#define MDM_COMPRESSION      0x00000001
#define MDM_ERROR_CONTROL    0x00000002
#define MDM_FORCED_EC        0x00000004
#define MDM_CELLULAR         0x00000008
#define MDM_FLOWCONTROL_HARD 0x00000010
#define MDM_FLOWCONTROL_SOFT 0x00000020
#define MDM_CCITT_OVERRIDE   0x00000040
#define MDM_SPEED_ADJUST     0x00000080
#define MDM_TONE_DIAL        0x00000100
#define MDM_BLIND_DIAL       0x00000200
#define MDM_V23_OVERRIDE     0x00000400

#endif /* _MCX_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\NB30.H ===
//*++
//
// Copyright (c) 1991-1995  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
//--*/

#ifndef NCB_INCLUDED
#define NCB_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[NCBNAMSZ];
    UCHAR   remote_name[NCBNAMSZ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state

#define LISTEN_OUTSTANDING      0x01
#define CALL_PENDING            0x02
#define SESSION_ESTABLISHED     0x03
#define HANGUP_PENDING          0x04
#define HANGUP_COMPLETE         0x05
#define SESSION_ABORTED         0x06

/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[]
    UCHAR   lana[MAX_LANA+1];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id

#define ALL_TRANSPORTS  "M\0\0\0"
#define MS_NBF          "MNBF"


/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

#define NCBCALL         0x10            /* NCB CALL                           */
#define NCBLISTEN       0x11            /* NCB LISTEN                         */
#define NCBHANGUP       0x12            /* NCB HANG UP                        */
#define NCBSEND         0x14            /* NCB SEND                           */
#define NCBRECV         0x15            /* NCB RECEIVE                        */
#define NCBRECVANY      0x16            /* NCB RECEIVE ANY                    */
#define NCBCHAINSEND    0x17            /* NCB CHAIN SEND                     */
#define NCBDGSEND       0x20            /* NCB SEND DATAGRAM                  */
#define NCBDGRECV       0x21            /* NCB RECEIVE DATAGRAM               */
#define NCBDGSENDBC     0x22            /* NCB SEND BROADCAST DATAGRAM        */
#define NCBDGRECVBC     0x23            /* NCB RECEIVE BROADCAST DATAGRAM     */
#define NCBADDNAME      0x30            /* NCB ADD NAME                       */
#define NCBDELNAME      0x31            /* NCB DELETE NAME                    */
#define NCBRESET        0x32            /* NCB RESET                          */
#define NCBASTAT        0x33            /* NCB ADAPTER STATUS                 */
#define NCBSSTAT        0x34            /* NCB SESSION STATUS                 */
#define NCBCANCEL       0x35            /* NCB CANCEL                         */
#define NCBADDGRNAME    0x36            /* NCB ADD GROUP NAME                 */
#define NCBENUM         0x37            /* NCB ENUMERATE LANA NUMBERS         */
#define NCBUNLINK       0x70            /* NCB UNLINK                         */
#define NCBSENDNA       0x71            /* NCB SEND NO ACK                    */
#define NCBCHAINSENDNA  0x72            /* NCB CHAIN SEND NO ACK              */
#define NCBLANSTALERT   0x73            /* NCB LAN STATUS ALERT               */
#define NCBACTION       0x77            /* NCB ACTION                         */
#define NCBFINDNAME     0x78            /* NCB FIND NAME                      */
#define NCBTRACE        0x79            /* NCB TRACE                          */


#define ASYNCH          0x80            /* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

#define NRC_GOODRET     0x00    /* good return                                */
                                /* also returned when ASYNCH request accepted */
#define NRC_BUFLEN      0x01    /* illegal buffer length                      */
#define NRC_ILLCMD      0x03    /* illegal command                            */
#define NRC_CMDTMO      0x05    /* command timed out                          */
#define NRC_INCOMP      0x06    /* message incomplete, issue another command  */
#define NRC_BADDR       0x07    /* illegal buffer address                     */
#define NRC_SNUMOUT     0x08    /* session number out of range                */
#define NRC_NORES       0x09    /* no resource available                      */
#define NRC_SCLOSED     0x0a    /* session closed                             */
#define NRC_CMDCAN      0x0b    /* command cancelled                          */
#define NRC_DUPNAME     0x0d    /* duplicate name                             */
#define NRC_NAMTFUL     0x0e    /* name table full                            */
#define NRC_ACTSES      0x0f    /* no deletions, name has active sessions     */
#define NRC_LOCTFUL     0x11    /* local session table full                   */
#define NRC_REMTFUL     0x12    /* remote session table full                  */
#define NRC_ILLNN       0x13    /* illegal name number                        */
#define NRC_NOCALL      0x14    /* no callname                                */
#define NRC_NOWILD      0x15    /* cannot put * in NCB_NAME                   */
#define NRC_INUSE       0x16    /* name in use on remote adapter              */
#define NRC_NAMERR      0x17    /* name deleted                               */
#define NRC_SABORT      0x18    /* session ended abnormally                   */
#define NRC_NAMCONF     0x19    /* name conflict detected                     */
#define NRC_IFBUSY      0x21    /* interface busy, IRET before retrying       */
#define NRC_TOOMANY     0x22    /* too many commands outstanding, retry later */
#define NRC_BRIDGE      0x23    /* ncb_lana_num field invalid                 */
#define NRC_CANOCCR     0x24    /* command completed while cancel occurring   */
#define NRC_CANCEL      0x26    /* command not valid to cancel                */
#define NRC_DUPENV      0x30    /* name defined by anther local process       */
#define NRC_ENVNOTDEF   0x34    /* environment undefined. RESET required      */
#define NRC_OSRESNOTAV  0x35    /* required OS resources exhausted            */
#define NRC_MAXAPPS     0x36    /* max number of applications exceeded        */
#define NRC_NOSAPS      0x37    /* no saps available for netbios              */
#define NRC_NORESOURCES 0x38    /* requested resources are not available      */
#define NRC_INVADDRESS  0x39    /* invalid ncb address or length > segment    */
#define NRC_INVDDID     0x3B    /* invalid NCB DDID                           */
#define NRC_LOCKFAIL    0x3C    /* lock of user area failed                   */
#define NRC_OPENERR     0x3f    /* NETBIOS not loaded                         */
#define NRC_SYSTEM      0x40    /* system error                               */

#define NRC_PENDING     0xff    /* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
APIENTRY
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/

#define NCB_POST void CALLBACK

#ifdef __cplusplus
}
#endif

#endif /* NCB_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\MMSYSTEM.H ===
/*==========================================================================
 *
 *  mmsystem.h -- Include file for Multimedia API's
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *--------------------------------------------------------------------------
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================
 */

#ifndef _INC_MMSYSTEM
#define _INC_MMSYSTEM   /* #defined if mmsystem.h has been included */

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef _WIN32
#ifndef _WINMM_
#define	WINMMAPI	DECLSPEC_IMPORT
#else
#define	WINMMAPI
#endif
#define _loadds
#define _huge
#else
#define	WINMMAPI
#endif

#ifdef _WIN32_VXD

#define NEAR
#define FAR

#define DECLARE_HANDLE(x) typedef WORD x
#define WINAPI

typedef DWORD LPSTR;
typedef DWORD LPVOID;
typedef DWORD LPCSTR;
typedef DWORD LPCWSTR;
typedef DWORD LRESULT;
typedef DWORD LPARAM;
typedef DWORD WPARAM;

typedef short WCHAR;

#endif

/****************************************************************************

		    General constants and data types

****************************************************************************/

/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   256    /* max error text length (including NULL) */
#define MAX_JOYSTICKOEMVXDNAME 260 /* max oem vxd name length (including NULL) */

/*
 *  Microsoft Manufacturer and Product ID's (these have been moved to
 *  MMREG.H for Windows 4.00 and above).
 */
#if (WINVER <= 0x030A)
#ifndef MM_MICROSOFT
#define MM_MICROSOFT            1   /* Microsoft Corporation */
#endif

#ifndef MM_MIDI_MAPPER
#define MM_MIDI_MAPPER          1   /* MIDI Mapper */
#define MM_WAVE_MAPPER          2   /* Wave Mapper */
#define MM_SNDBLST_MIDIOUT      3   /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4   /* Sound Blaster MIDI input port */
#define MM_SNDBLST_SYNTH        5   /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6   /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7   /* Sound Blaster waveform input */
#define MM_ADLIB                9   /* Ad Lib-compatible synthesizer */
#define MM_MPU401_MIDIOUT      10   /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN       11   /* MPU401-compatible MIDI input port */
#define MM_PC_JOYSTICK         12   /* Joystick adapter */
#endif
#endif

/* general data types */

#ifdef _WIN32
typedef UINT        MMVERSION;  /* major (high byte), minor (low byte) */
#else
typedef UINT        VERSION;    /* major (high byte), minor (low byte) */
#endif
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
				/* call as if(err=xxxx(...)) Error(err); else */
#define _MMRESULT_

typedef UINT FAR   *LPUINT;

/* MMTIME data structure */
typedef struct mmtime_tag
{
    UINT            wType;      /* indicates the contents of the union */
    union
    {
	DWORD       ms;         /* milliseconds */
	DWORD       sample;     /* samples */
	DWORD       cb;         /* byte count */
	DWORD       ticks;      /* ticks in MIDI stream */

	/* SMPTE */
	struct
	{
	    BYTE    hour;       /* hours */
	    BYTE    min;        /* minutes */
	    BYTE    sec;        /* seconds */
	    BYTE    frame;      /* frames  */
	    BYTE    fps;        /* frames per second */
	    BYTE    dummy;      /* pad */
#ifdef _WIN32
	    BYTE    pad[2];
#endif
	} smpte;

	/* MIDI */
	struct
	{
	    DWORD songptrpos;   /* song pointer position */
	} midi;
    } u;
} MMTIME, *PMMTIME, NEAR *NPMMTIME, FAR *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */
#define TIME_TICKS      0x0020  /* Ticks within MIDI stream */

/*
 *
 *
 */
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
		((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
		((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))

/****************************************************************************

		    Multimedia Extensions Window Messages

****************************************************************************/

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9

/* these are also in msvideo.h */
#ifndef MM_DRVM_OPEN
 #define MM_DRVM_OPEN       0x3D0           /* installable drivers */
 #define MM_DRVM_CLOSE      0x3D1
 #define MM_DRVM_DATA       0x3D2
 #define MM_DRVM_ERROR      0x3D3
#endif

/* these are used by msacm.h */
#define MM_STREAM_OPEN	    0x3D4
#define MM_STREAM_CLOSE	    0x3D5
#define MM_STREAM_DONE	    0x3D6
#define MM_STREAM_ERROR	    0x3D7

#if(WINVER >= 0x0400)
#define MM_MOM_POSITIONCB   0x3CA           /* Callback for MEVT_POSITIONCB */

#ifndef MM_MCISIGNAL
 #define MM_MCISIGNAL        0x3CB
#endif

#define MM_MIM_MOREDATA      0x3CC          /* MIM_DONE w/ pending events */

#endif /* WINVER >= 0x0400 */
#define MM_MIXM_LINE_CHANGE     0x3D0       /* mixer line change notify */
#define MM_MIXM_CONTROL_CHANGE  0x3D1       /* mixer control change notify */

/****************************************************************************

		String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256
#define MIXERR_BASE            1024

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

			General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_HANDLEBUSY   (MMSYSERR_BASE + 12) /* handle being used */
						   /* simultaneously on another */
						   /* thread (eg callback) */
#define MMSYSERR_INVALIDALIAS (MMSYSERR_BASE + 13) /* specified alias not found */
#define MMSYSERR_BADDB        (MMSYSERR_BASE + 14) /* bad registry database */
#define MMSYSERR_KEYNOTFOUND  (MMSYSERR_BASE + 15) /* registry key not found */
#define MMSYSERR_READERROR    (MMSYSERR_BASE + 16) /* registry read error */
#define MMSYSERR_WRITEERROR   (MMSYSERR_BASE + 17) /* registry write error */
#define MMSYSERR_DELETEERROR  (MMSYSERR_BASE + 18) /* registry delete error */
#define MMSYSERR_VALNOTFOUND  (MMSYSERR_BASE + 19) /* registry value not found */
#define MMSYSERR_NODRIVERCB   (MMSYSERR_BASE + 20) /* driver does not call DriverCallback */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 20) /* last error in range */

#if (WINVER < 0x030a) || defined(_WIN32)
DECLARE_HANDLE(HDRVR);
#endif /* ifdef WINVER < 0x030a */

#ifndef MMNODRV

/****************************************************************************

			Installable driver support

****************************************************************************/

#ifdef _WIN32
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;

#else
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;
#endif

#if (WINVER < 0x030a) || defined(_WIN32)

#ifndef DRV_LOAD

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_POWER               0x000F
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
#ifdef _WIN32
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#else
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#endif

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* installable driver function prototypes */
#ifdef _WIN32
 #ifndef _WIN32_VXD

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

WINMMAPI LRESULT   WINAPI CloseDriver(HDRVR hDriver, LONG lParam1, LONG lParam2);
WINMMAPI HDRVR     WINAPI OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LONG lParam2);
WINMMAPI LRESULT   WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LONG lParam1, LONG lParam2);
WINMMAPI HMODULE   WINAPI DrvGetModuleHandle(HDRVR hDriver);
WINMMAPI HMODULE   WINAPI GetDriverModuleHandle(HDRVR hDriver);
WINMMAPI LRESULT   WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
 #endif /* ifndef _WIN32_VXD */
#else
LRESULT   WINAPI DrvClose(HDRVR hdrvr, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hdrvr);
LRESULT   WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
#define DefDriverProc DrvDefDriverProc
#endif /* ifdef _WIN32 */
#endif /* DRV_LOAD */
#endif /* ifdef (WINVER < 0x030a) || defined(_WIN32) */

#if (WINVER >= 0x030a)
/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif /* ifdef WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */

/****************************************************************************

			  Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */
#ifdef _WIN32
#define CALLBACK_THREAD     (CALLBACK_TASK)/* thread ID replaces 16 bit task */
#define CALLBACK_EVENT      0x00050000l    /* dwCallback is an EVENT Handle */
#endif

#ifndef _WIN32_VXD 

typedef void (CALLBACK DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef DRVCALLBACK FAR *LPDRVCALLBACK;
#ifdef _WIN32
typedef DRVCALLBACK     *PDRVCALLBACK;
#endif

#endif   /* ifndef _WIN32_VXD */ 

#ifndef MMNOMMSYSTEM
#ifndef _WIN32_VXD
/****************************************************************************

		    General MMSYSTEM support

****************************************************************************/

#if (WINVER <= 0x030A)
WINMMAPI UINT WINAPI mmsystemGetVersion(void);
#endif
#ifdef _WIN32
#define OutputDebugStr  OutputDebugString
#else
void WINAPI OutputDebugStr(LPCSTR);
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMMSYSTEM */

#ifndef MMNOSOUND
#ifndef _WIN32_VXD
/****************************************************************************

			    Sound support

****************************************************************************/

#ifdef _WIN32

WINMMAPI BOOL WINAPI sndPlaySoundA(LPCSTR pszSound, UINT fuSound);
WINMMAPI BOOL WINAPI sndPlaySoundW(LPCWSTR pszSound, UINT fuSound);
#ifdef UNICODE
#define sndPlaySound  sndPlaySoundW
#else
#define sndPlaySound  sndPlaySoundA
#endif // !UNICODE

#else
BOOL WINAPI sndPlaySound(LPCSTR pszSound, UINT fuSound);
#endif

/*
 *  flag values for fuSound and fdwSound arguments on [snd]PlaySound
 */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* silence (!default) if sound not found */
#define SND_MEMORY          0x0004  /* pszSound points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */

#define SND_NOWAIT	0x00002000L /* don't wait if the driver is busy */
#define SND_ALIAS       0x00010000L /* name is a registry alias */
#define SND_ALIAS_ID	0x00110000L /* alias is a predefined ID */
#define SND_FILENAME    0x00020000L /* name is file name */
#define SND_RESOURCE    0x00040004L /* name is resource name or atom */
#if(WINVER >= 0x0400)
#define SND_PURGE           0x0040  /* purge non-static events for task */
#define SND_APPLICATION     0x0080  /* look for application specific association */
#endif /* WINVER >= 0x0400 */

#define SND_ALIAS_START	0           /* alias base */

#ifdef _WIN32
#define	sndAlias(ch0, ch1)	(SND_ALIAS_START + (DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8))

#define SND_ALIAS_SYSTEMASTERISK        sndAlias('S', '*')
#define SND_ALIAS_SYSTEMQUESTION        sndAlias('S', '?')
#define SND_ALIAS_SYSTEMHAND            sndAlias('S', 'H')
#define SND_ALIAS_SYSTEMEXIT            sndAlias('S', 'E')
#define SND_ALIAS_SYSTEMSTART           sndAlias('S', 'S')
#define SND_ALIAS_SYSTEMWELCOME         sndAlias('S', 'W')
#define SND_ALIAS_SYSTEMEXCLAMATION     sndAlias('S', '!')
#define SND_ALIAS_SYSTEMDEFAULT         sndAlias('S', 'D')

WINMMAPI BOOL WINAPI PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
WINMMAPI BOOL WINAPI PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
#ifdef UNICODE
#define PlaySound  PlaySoundW
#else
#define PlaySound  PlaySoundA
#endif // !UNICODE

#else
BOOL WINAPI PlaySound(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOSOUND */

#ifndef MMNOWAVE
/****************************************************************************

			Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
#ifndef _WIN32_VXD
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;
#endif

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     ((UINT)-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY         0x0001
#define  WAVE_ALLOWSYNC            0x0002
#if(WINVER >= 0x0400)
#define  WAVE_MAPPED               0x0004
#endif /* WINVER >= 0x0400 */

/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag FAR *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR, *PWAVEHDR, NEAR *NPWAVEHDR, FAR *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */

/* waveform output device capabilities structure */
#ifdef _WIN32

typedef struct tagWAVEOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSA, *PWAVEOUTCAPSA, *NPWAVEOUTCAPSA, *LPWAVEOUTCAPSA;
typedef struct tagWAVEOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSW, *PWAVEOUTCAPSW, *NPWAVEOUTCAPSW, *LPWAVEOUTCAPSW;
#ifdef UNICODE
typedef WAVEOUTCAPSW WAVEOUTCAPS;
typedef PWAVEOUTCAPSW PWAVEOUTCAPS;
typedef NPWAVEOUTCAPSW NPWAVEOUTCAPS;
typedef LPWAVEOUTCAPSW LPWAVEOUTCAPS;
#else
typedef WAVEOUTCAPSA WAVEOUTCAPS;
typedef PWAVEOUTCAPSA PWAVEOUTCAPS;
typedef NPWAVEOUTCAPSA NPWAVEOUTCAPS;
typedef LPWAVEOUTCAPSA LPWAVEOUTCAPS;
#endif // UNICODE

#else
typedef struct waveoutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS, *PWAVEOUTCAPS, NEAR *NPWAVEOUTCAPS, FAR *LPWAVEOUTCAPS;
#endif

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010
#define WAVECAPS_SAMPLEACCURATE 0x0020
#define WAVECAPS_DIRECTSOUND    0x0040

/* waveform input device capabilities structure */
#ifdef _WIN32

typedef struct tagWAVEINCAPSA {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSA, *PWAVEINCAPSA, *NPWAVEINCAPSA, *LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSW, *PWAVEINCAPSW, *NPWAVEINCAPSW, *LPWAVEINCAPSW;
#ifdef UNICODE
typedef WAVEINCAPSW WAVEINCAPS;
typedef PWAVEINCAPSW PWAVEINCAPS;
typedef NPWAVEINCAPSW NPWAVEINCAPS;
typedef LPWAVEINCAPSW LPWAVEINCAPS;
#else
typedef WAVEINCAPSA WAVEINCAPS;
typedef PWAVEINCAPSA PWAVEINCAPS;
typedef NPWAVEINCAPSA NPWAVEINCAPS;
typedef LPWAVEINCAPSA LPWAVEINCAPS;
#endif // UNICODE

#else
typedef struct waveincaps_tag {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPS, *PWAVEINCAPS, NEAR *NPWAVEINCAPS, FAR *LPWAVEINCAPS;
#endif

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/* OLD general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT, *PWAVEFORMAT, NEAR *NPWAVEFORMAT, FAR *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT, *PPCMWAVEFORMAT, NEAR *NPPCMWAVEFORMAT, FAR *LPPCMWAVEFORMAT;

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_

/*
 *  extended waveform format structure used for all non-PCM formats. this
 *  structure is common to all non-PCM formats.
 */
typedef struct tWAVEFORMATEX
{
    WORD        wFormatTag;         /* format type */
    WORD        nChannels;          /* number of channels (i.e. mono, stereo...) */
    DWORD       nSamplesPerSec;     /* sample rate */
    DWORD       nAvgBytesPerSec;    /* for buffer estimation */
    WORD        nBlockAlign;        /* block size of data */
    WORD        wBitsPerSample;     /* number of bits per sample of mono data */
    WORD        cbSize;             /* the count in bytes of the size of */
				    /* extra information (after cbSize) */
} WAVEFORMATEX, *PWAVEFORMATEX, NEAR *NPWAVEFORMATEX, FAR *LPWAVEFORMATEX;
typedef const WAVEFORMATEX FAR *LPCWAVEFORMATEX;

#endif /* _WAVEFORMATEX_ */

#ifndef _WIN32_VXD
/* waveform audio function prototypes */
WINMMAPI UINT WINAPI waveOutGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveOutGetDevCapsA(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
WINMMAPI MMRESULT WINAPI waveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);
#ifdef UNICODE
#define waveOutGetDevCaps  waveOutGetDevCapsW
#else
#define waveOutGetDevCaps  waveOutGetDevCapsA
#endif // !UNICODE

#else
WINMMAPI MMRESULT WINAPI waveOutGetDevCaps(UINT uDeviceID, LPWAVEOUTCAPS pwoc, UINT cbwoc);
#endif

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI waveOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(UINT uId, DWORD dwVolume);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveOutGetErrorText  waveOutGetErrorTextW
#else
#define waveOutGetErrorText  waveOutGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI waveOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI waveOutClose(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutPause(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutRestart(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutReset(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutBreakLoop(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch);
WINMMAPI MMRESULT WINAPI waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch);
WINMMAPI MMRESULT WINAPI waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate);
WINMMAPI MMRESULT WINAPI waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate);
WINMMAPI MMRESULT WINAPI waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI waveInGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveInGetDevCapsA(UINT uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);
WINMMAPI MMRESULT WINAPI waveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic);
#ifdef UNICODE
#define waveInGetDevCaps  waveInGetDevCapsW
#else
#define waveInGetDevCaps  waveInGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI waveInGetDevCaps(UINT uDeviceID, LPWAVEINCAPS pwic, UINT cbwic);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveInGetErrorText  waveInGetErrorTextW
#else
#define waveInGetErrorText  waveInGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI waveInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI waveInOpen(LPHWAVEIN phwi, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI waveInClose(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInStart(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInStop(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInReset(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveInGetID(HWAVEIN hwi, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOWAVE */

#ifndef MMNOMIDI
/****************************************************************************

			    MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no configured instruments */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid MIF */
#define MIDIERR_BADOPENMODE   (MIDIERR_BASE + 6)   /* operation unsupported w/ open mode */
#define MIDIERR_DONT_CONTINUE (MIDIERR_BASE + 7)   /* thru device 'eating' a message */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 7)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
DECLARE_HANDLE(HMIDISTRM);
#ifndef _WIN32_VXD
typedef HMIDI FAR *LPHMIDI;
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef HMIDISTRM FAR *LPHMIDISTRM;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;
#endif  /* ifndef _WIN32_VXD */

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

#if(WINVER >= 0x0400)
#define MIM_MOREDATA      MM_MIM_MOREDATA
#define MOM_POSITIONCB    MM_MOM_POSITIONCB
#endif /* WINVER >= 0x0400 */

/* device ID for MIDI mapper */
#define MIDIMAPPER     ((UINT)-1)
#define MIDI_MAPPER    ((UINT)-1)

#if(WINVER >= 0x0400)
/* flags for dwFlags parm of midiInOpen() */
#define MIDI_IO_STATUS      0x00000020L
#endif /* WINVER >= 0x0400 */

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */
#define MIDI_CACHE_ALL      1
#define MIDI_CACHE_BESTFIT  2
#define MIDI_CACHE_QUERY    3
#define MIDI_UNCACHE        4

/* MIDI output device capabilities structure */
#ifdef _WIN32

typedef struct tagMIDIOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSA, *PMIDIOUTCAPSA, *NPMIDIOUTCAPSA, *LPMIDIOUTCAPSA;
typedef struct tagMIDIOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSW, *PMIDIOUTCAPSW, *NPMIDIOUTCAPSW, *LPMIDIOUTCAPSW;
#ifdef UNICODE
typedef MIDIOUTCAPSW MIDIOUTCAPS;
typedef PMIDIOUTCAPSW PMIDIOUTCAPS;
typedef NPMIDIOUTCAPSW NPMIDIOUTCAPS;
typedef LPMIDIOUTCAPSW LPMIDIOUTCAPS;
#else
typedef MIDIOUTCAPSA MIDIOUTCAPS;
typedef PMIDIOUTCAPSA PMIDIOUTCAPS;
typedef NPMIDIOUTCAPSA NPMIDIOUTCAPS;
typedef LPMIDIOUTCAPSA LPMIDIOUTCAPS;
#endif // UNICODE

#else
typedef struct midioutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS, *PMIDIOUTCAPS, NEAR *NPMIDIOUTCAPS, FAR *LPMIDIOUTCAPS;
#endif

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004
#if(WINVER >= 0x0400)
#define MIDICAPS_STREAM          0x0008  /* driver supports midiStreamOut directly */
#endif /* WINVER >= 0x0400 */

/* MIDI input device capabilities structure */
#ifdef _WIN32

typedef struct tagMIDIINCAPSA {
    WORD        wMid;                   /* manufacturer ID */
    WORD        wPid;                   /* product ID */
    MMVERSION   vDriverVersion;         /* version of the driver */
    CHAR        szPname[MAXPNAMELEN];   /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSA, *PMIDIINCAPSA, *NPMIDIINCAPSA, *LPMIDIINCAPSA;
typedef struct tagMIDIINCAPSW {
    WORD        wMid;                   /* manufacturer ID */
    WORD        wPid;                   /* product ID */
    MMVERSION   vDriverVersion;         /* version of the driver */
    WCHAR       szPname[MAXPNAMELEN];   /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSW, *PMIDIINCAPSW, *NPMIDIINCAPSW, *LPMIDIINCAPSW;
#ifdef UNICODE
typedef MIDIINCAPSW MIDIINCAPS;
typedef PMIDIINCAPSW PMIDIINCAPS;
typedef NPMIDIINCAPSW NPMIDIINCAPS;
typedef LPMIDIINCAPSW LPMIDIINCAPS;
#else
typedef MIDIINCAPSA MIDIINCAPS;
typedef PMIDIINCAPSA PMIDIINCAPS;
typedef NPMIDIINCAPSA NPMIDIINCAPS;
typedef LPMIDIINCAPSA LPMIDIINCAPS;
#endif // UNICODE

#else
typedef struct midiincaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPS, *PMIDIINCAPS, NEAR *NPMIDIINCAPS, FAR *LPMIDIINCAPS;
#endif

/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag FAR *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
#if (WINVER >= 0x0400)
    DWORD       dwOffset;             /* Callback offset into buffer */
    DWORD       dwReserved[8];        /* Reserved for MMSYSTEM */
#endif
} MIDIHDR, *PMIDIHDR, NEAR *NPMIDIHDR, FAR *LPMIDIHDR;

#if(WINVER >= 0x0400)
typedef struct midievent_tag
{
    DWORD       dwDeltaTime;          /* Ticks since last event */
    DWORD       dwStreamID;           /* Reserved; must be zero */
    DWORD       dwEvent;              /* Event type and parameters */
    DWORD       dwParms[1];           /* Parameters if this is a long event */
} MIDIEVENT;

typedef struct midistrmbuffver_tag
{
    DWORD       dwVersion;                  /* Stream buffer format version */
    DWORD       dwMid;                      /* Manufacturer ID as defined in MMREG.H */
    DWORD       dwOEMVersion;               /* Manufacturer version for custom ext */
} MIDISTRMBUFFVER;
#endif /* WINVER >= 0x0400 */

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */
#define MHDR_ISSTRM     0x00000008       /* Buffer is stream buffer */

#if(WINVER >= 0x0400)
/* */
/* Type codes which go in the high byte of the event DWORD of a stream buffer */
/* */
/* Type codes 00-7F contain parameters within the low 24 bits */
/* Type codes 80-FF contain a length of their parameter in the low 24 */
/* bits, followed by their parameter data in the buffer. The event */
/* DWORD contains the exact byte length; the parm data itself must be */
/* padded to be an even multiple of 4 bytes long. */
/* */

#define MEVT_F_SHORT        0x00000000L
#define MEVT_F_LONG         0x80000000L
#define MEVT_F_CALLBACK     0x40000000L

#define MEVT_EVENTTYPE(x)   ((BYTE)(((x)>>24)&0xFF))
#define MEVT_EVENTPARM(x)   ((DWORD)((x)&0x00FFFFFFL))

#define MEVT_SHORTMSG       ((BYTE)0x00)    /* parm = shortmsg for midiOutShortMsg */
#define MEVT_TEMPO          ((BYTE)0x01)    /* parm = new tempo in microsec/qn     */
#define MEVT_NOP            ((BYTE)0x02)    /* parm = unused; does nothing         */

/* 0x04-0x7F reserved */

#define MEVT_LONGMSG        ((BYTE)0x80)    /* parm = bytes to send verbatim       */
#define MEVT_COMMENT        ((BYTE)0x82)    /* parm = comment data                 */
#define MEVT_VERSION        ((BYTE)0x84)    /* parm = MIDISTRMBUFFVER struct       */

/* 0x81-0xFF reserved */

#define MIDISTRM_ERROR      (-2)

/* */
/* Structures and defines for midiStreamProperty */
/* */
#define MIDIPROP_SET        0x80000000L
#define MIDIPROP_GET        0x40000000L

/* These are intentionally both non-zero so the app cannot accidentally */
/* leave the operation off and happen to appear to work due to default */
/* action. */

#define MIDIPROP_TIMEDIV    0x00000001L
#define MIDIPROP_TEMPO      0x00000002L

typedef struct midiproptimediv_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeDiv;
} MIDIPROPTIMEDIV, FAR *LPMIDIPROPTIMEDIV;

typedef struct midiproptempo_tag
{
    DWORD       cbStruct;
    DWORD       dwTempo;
} MIDIPROPTEMPO, FAR *LPMIDIPROPTEMPO;

#endif /* WINVER >= 0x0400 */

#ifndef _WIN32_VXD

/* MIDI function prototypes */
WINMMAPI UINT WINAPI midiOutGetNumDevs(void);
#if(WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiStreamClose(HMIDISTRM hms);

WINMMAPI MMRESULT WINAPI midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty);
WINMMAPI MMRESULT WINAPI midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt);

WINMMAPI MMRESULT WINAPI midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiStreamPause(HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamRestart(HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamStop(HMIDISTRM hms);

#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);
WINMMAPI MMRESULT WINAPI midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);
#endif
#endif /* WINVER >= 0x0400 */

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiOutGetDevCapsA(UINT uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);
WINMMAPI MMRESULT WINAPI midiOutGetDevCapsW(UINT uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc);
#ifdef UNICODE
#define midiOutGetDevCaps  midiOutGetDevCapsW
#else
#define midiOutGetDevCaps  midiOutGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI midiOutGetDevCaps(UINT uDeviceID, LPMIDIOUTCAPS pmoc, UINT cbmoc);
#endif

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI midiOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(UINT uId, DWORD dwVolume);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiOutGetErrorText  midiOutGetErrorTextW
#else
#define midiOutGetErrorText  midiOutGetErrorTextA
#endif // !UNICODE

#else
WINMMAPI MMRESULT WINAPI midiOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiOutClose(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg);
WINMMAPI MMRESULT WINAPI midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutReset(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI midiInGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiInGetDevCapsA(UINT uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic);
WINMMAPI MMRESULT WINAPI midiInGetDevCapsW(UINT uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic);
#ifdef UNICODE
#define midiInGetDevCaps  midiInGetDevCapsW
#else
#define midiInGetDevCaps  midiInGetDevCapsA
#endif // !UNICODE
WINMMAPI MMRESULT WINAPI midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiInGetErrorText  midiInGetErrorTextW
#else
#define midiInGetErrorText  midiInGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI midiInGetDevCaps(UINT uDeviceID, LPMIDIINCAPS pmic, UINT cbmic);
WINMMAPI MMRESULT WINAPI midiInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI midiInOpen(LPHMIDIIN phmi, UINT uDeviceID,
	DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiInClose(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInStart(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInStop(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInReset(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInGetID(HMIDIIN hmi, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOMIDI */

#ifndef MMNOAUX
/****************************************************************************

			Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     ((UINT)-1)

/* Auxiliary audio device capabilities structure */
#ifdef _WIN32

typedef struct tagAUXCAPSA {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    CHAR        szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    WORD        wReserved1;          /* padding */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSA, *PAUXCAPSA, *NPAUXCAPSA, *LPAUXCAPSA;
typedef struct tagAUXCAPSW {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    WCHAR       szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    WORD        wReserved1;          /* padding */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSW, *PAUXCAPSW, *NPAUXCAPSW, *LPAUXCAPSW;
#ifdef UNICODE
typedef AUXCAPSW AUXCAPS;
typedef PAUXCAPSW PAUXCAPS;
typedef NPAUXCAPSW NPAUXCAPS;
typedef LPAUXCAPSW LPAUXCAPS;
#else
typedef AUXCAPSA AUXCAPS;
typedef PAUXCAPSA PAUXCAPS;
typedef NPAUXCAPSA NPAUXCAPS;
typedef LPAUXCAPSA LPAUXCAPS;
#endif // UNICODE

#else
typedef struct auxcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS, *PAUXCAPS, NEAR *NPAUXCAPS, FAR *LPAUXCAPS;
#endif

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

#ifndef _WIN32_VXD

/* auxiliary audio function prototypes */
WINMMAPI UINT WINAPI auxGetNumDevs(void);
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI auxGetDevCapsA(UINT uDeviceID, LPAUXCAPSA pac, UINT cbac);
WINMMAPI MMRESULT WINAPI auxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac);
#ifdef UNICODE
#define auxGetDevCaps  auxGetDevCapsW
#else
#define auxGetDevCaps  auxGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI auxGetDevCaps(UINT uDeviceID, LPAUXCAPS pac, UINT cbac);
#endif
WINMMAPI MMRESULT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
WINMMAPI MMRESULT WINAPI auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOAUX */

#ifndef MMNOMIXER
#ifndef _WIN32_VXD
/****************************************************************************

			    Mixer Support

****************************************************************************/

DECLARE_HANDLE(HMIXEROBJ);
typedef HMIXEROBJ FAR *LPHMIXEROBJ;

DECLARE_HANDLE(HMIXER);
typedef HMIXER     FAR *LPHMIXER;

#define MIXER_SHORT_NAME_CHARS   16
#define MIXER_LONG_NAME_CHARS    64

/* */
/*  MMRESULT error return values specific to the mixer API */
/* */
/* */
#define MIXERR_INVALLINE            (MIXERR_BASE + 0)
#define MIXERR_INVALCONTROL         (MIXERR_BASE + 1)
#define MIXERR_INVALVALUE           (MIXERR_BASE + 2)
#define MIXERR_LASTERROR            (MIXERR_BASE + 2)

#define MIXER_OBJECTF_HANDLE    0x80000000L
#define MIXER_OBJECTF_MIXER     0x00000000L
#define MIXER_OBJECTF_HMIXER    (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIXER)
#define MIXER_OBJECTF_WAVEOUT   0x10000000L
#define MIXER_OBJECTF_HWAVEOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEOUT)
#define MIXER_OBJECTF_WAVEIN    0x20000000L
#define MIXER_OBJECTF_HWAVEIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEIN)
#define MIXER_OBJECTF_MIDIOUT   0x30000000L
#define MIXER_OBJECTF_HMIDIOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIOUT)
#define MIXER_OBJECTF_MIDIIN    0x40000000L
#define MIXER_OBJECTF_HMIDIIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIIN)
#define MIXER_OBJECTF_AUX       0x50000000L

WINMMAPI UINT WINAPI mixerGetNumDevs(void);

#ifdef _WIN32

typedef struct tagMIXERCAPSA {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    MMVERSION       vDriverVersion;         /* version of the driver */
    CHAR            szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPSA, *PMIXERCAPSA, *LPMIXERCAPSA;
typedef struct tagMIXERCAPSW {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    MMVERSION       vDriverVersion;         /* version of the driver */
    WCHAR           szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPSW, *PMIXERCAPSW, *LPMIXERCAPSW;
#ifdef UNICODE
typedef MIXERCAPSW MIXERCAPS;
typedef PMIXERCAPSW PMIXERCAPS;
typedef LPMIXERCAPSW LPMIXERCAPS;
#else
typedef MIXERCAPSA MIXERCAPS;
typedef PMIXERCAPSA PMIXERCAPS;
typedef LPMIXERCAPSA LPMIXERCAPS;
#endif // UNICODE

#else
typedef struct tMIXERCAPS {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    VERSION         vDriverVersion;         /* version of the driver */
    char            szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPS, *PMIXERCAPS, FAR *LPMIXERCAPS;
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetDevCapsA(UINT uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps);
WINMMAPI MMRESULT WINAPI mixerGetDevCapsW(UINT uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps);
#ifdef UNICODE
#define mixerGetDevCaps  mixerGetDevCapsW
#else
#define mixerGetDevCaps  mixerGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetDevCaps(UINT uMxId, LPMIXERCAPS pmxcaps, UINT cbmxcaps);
#endif

WINMMAPI MMRESULT WINAPI mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI mixerClose(HMIXER hmx);

WINMMAPI DWORD WINAPI mixerMessage(HMIXER hmx, UINT uMsg, DWORD dwParam1, DWORD dwParam2);

#ifdef _WIN32

typedef struct tagMIXERLINEA {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	MMVERSION vDriverVersion;       /*      " */
	CHAR    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEA, *PMIXERLINEA, *LPMIXERLINEA;
typedef struct tagMIXERLINEW {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    WCHAR       szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR       szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	MMVERSION vDriverVersion;       /*      " */
	WCHAR   szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEW, *PMIXERLINEW, *LPMIXERLINEW;
#ifdef UNICODE
typedef MIXERLINEW MIXERLINE;
typedef PMIXERLINEW PMIXERLINE;
typedef LPMIXERLINEW LPMIXERLINE;
#else
typedef MIXERLINEA MIXERLINE;
typedef PMIXERLINEA PMIXERLINE;
typedef LPMIXERLINEA LPMIXERLINE;
#endif // UNICODE

#else
typedef struct tMIXERLINE {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    char        szShortName[MIXER_SHORT_NAME_CHARS];
    char        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	VERSION vDriverVersion;         /*      " */
	char    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINE, *PMIXERLINE, FAR *LPMIXERLINE;
#endif

/* */
/*  MIXERLINE.fdwLine */
/* */
/* */
#define MIXERLINE_LINEF_ACTIVE              0x00000001L
#define MIXERLINE_LINEF_DISCONNECTED        0x00008000L
#define MIXERLINE_LINEF_SOURCE              0x80000000L

/* */
/*  MIXERLINE.dwComponentType */
/* */
/*  component types for destinations and sources */
/* */
/* */
#define MIXERLINE_COMPONENTTYPE_DST_FIRST       0x00000000L
#define MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_DST_DIGITAL     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_DST_LINE        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_DST_MONITOR     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    (MIXERLINE_COMPONENTTYPE_DST_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  (MIXERLINE_COMPONENTTYPE_DST_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_DST_WAVEIN      (MIXERLINE_COMPONENTTYPE_DST_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_DST_VOICEIN     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_DST_LAST        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)

#define MIXERLINE_COMPONENTTYPE_SRC_FIRST       0x00001000L
#define MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_SRC_LINE        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 9)
#define MIXERLINE_COMPONENTTYPE_SRC_ANALOG      (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)
#define MIXERLINE_COMPONENTTYPE_SRC_LAST        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)

/* */
/*  MIXERLINE.Target.dwType */
/* */
/* */
#define MIXERLINE_TARGETTYPE_UNDEFINED      0
#define MIXERLINE_TARGETTYPE_WAVEOUT        1
#define MIXERLINE_TARGETTYPE_WAVEIN         2
#define MIXERLINE_TARGETTYPE_MIDIOUT        3
#define MIXERLINE_TARGETTYPE_MIDIIN         4
#define MIXERLINE_TARGETTYPE_AUX            5

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo);
WINMMAPI MMRESULT WINAPI mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo);
#ifdef UNICODE
#define mixerGetLineInfo  mixerGetLineInfoW
#else
#define mixerGetLineInfo  mixerGetLineInfoA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetLineInfo(HMIXEROBJ hmxobj, LPMIXERLINE pmxl, DWORD fdwInfo);
#endif

#define MIXER_GETLINEINFOF_DESTINATION      0x00000000L
#define MIXER_GETLINEINFOF_SOURCE           0x00000001L
#define MIXER_GETLINEINFOF_LINEID           0x00000002L
#define MIXER_GETLINEINFOF_COMPONENTTYPE    0x00000003L
#define MIXER_GETLINEINFOF_TARGETTYPE       0x00000004L

#define MIXER_GETLINEINFOF_QUERYMASK        0x0000000FL

WINMMAPI MMRESULT WINAPI mixerGetID(HMIXEROBJ hmxobj, UINT FAR *puMxId, DWORD fdwId);

/* */
/*  MIXERCONTROL */
/* */
/* */
#ifdef _WIN32

typedef struct tagMIXERCONTROLA {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    CHAR            szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROLA, *PMIXERCONTROLA, *LPMIXERCONTROLA;
typedef struct tagMIXERCONTROLW {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    WCHAR           szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROLW, *PMIXERCONTROLW, *LPMIXERCONTROLW;
#ifdef UNICODE
typedef MIXERCONTROLW MIXERCONTROL;
typedef PMIXERCONTROLW PMIXERCONTROL;
typedef LPMIXERCONTROLW LPMIXERCONTROL;
#else
typedef MIXERCONTROLA MIXERCONTROL;
typedef PMIXERCONTROLA PMIXERCONTROL;
typedef LPMIXERCONTROLA LPMIXERCONTROL;
#endif // UNICODE

#else
typedef struct tMIXERCONTROL {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    char            szShortName[MIXER_SHORT_NAME_CHARS];
    char            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROL, *PMIXERCONTROL, FAR *LPMIXERCONTROL;
#endif

/* */
/*  MIXERCONTROL.fdwControl */
/* */
/* */
#define MIXERCONTROL_CONTROLF_UNIFORM   0x00000001L
#define MIXERCONTROL_CONTROLF_MULTIPLE  0x00000002L
#define MIXERCONTROL_CONTROLF_DISABLED  0x80000000L

/* */
/*  MIXERCONTROL_CONTROLTYPE_xxx building block defines */
/* */
/* */
#define MIXERCONTROL_CT_CLASS_MASK          0xF0000000L
#define MIXERCONTROL_CT_CLASS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_CLASS_METER         0x10000000L
#define MIXERCONTROL_CT_CLASS_SWITCH        0x20000000L
#define MIXERCONTROL_CT_CLASS_NUMBER        0x30000000L
#define MIXERCONTROL_CT_CLASS_SLIDER        0x40000000L
#define MIXERCONTROL_CT_CLASS_FADER         0x50000000L
#define MIXERCONTROL_CT_CLASS_TIME          0x60000000L
#define MIXERCONTROL_CT_CLASS_LIST          0x70000000L

#define MIXERCONTROL_CT_SUBCLASS_MASK       0x0F000000L

#define MIXERCONTROL_CT_SC_SWITCH_BOOLEAN   0x00000000L
#define MIXERCONTROL_CT_SC_SWITCH_BUTTON    0x01000000L

#define MIXERCONTROL_CT_SC_METER_POLLED     0x00000000L

#define MIXERCONTROL_CT_SC_TIME_MICROSECS   0x00000000L
#define MIXERCONTROL_CT_SC_TIME_MILLISECS   0x01000000L

#define MIXERCONTROL_CT_SC_LIST_SINGLE      0x00000000L
#define MIXERCONTROL_CT_SC_LIST_MULTIPLE    0x01000000L

#define MIXERCONTROL_CT_UNITS_MASK          0x00FF0000L
#define MIXERCONTROL_CT_UNITS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_UNITS_BOOLEAN       0x00010000L
#define MIXERCONTROL_CT_UNITS_SIGNED        0x00020000L
#define MIXERCONTROL_CT_UNITS_UNSIGNED      0x00030000L
#define MIXERCONTROL_CT_UNITS_DECIBELS      0x00040000L /* in 10ths */
#define MIXERCONTROL_CT_UNITS_PERCENT       0x00050000L /* in 10ths */

/* */
/*  Commonly used control types for specifying MIXERCONTROL.dwControlType */
/* */

#define MIXERCONTROL_CONTROLTYPE_CUSTOM         (MIXERCONTROL_CT_CLASS_CUSTOM | MIXERCONTROL_CT_UNITS_CUSTOM)
#define MIXERCONTROL_CONTROLTYPE_BOOLEANMETER   (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_SIGNEDMETER    (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PEAKMETER      (MIXERCONTROL_CONTROLTYPE_SIGNEDMETER + 1)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER  (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_BOOLEAN        (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BOOLEAN | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_ONOFF          (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 1)
#define MIXERCONTROL_CONTROLTYPE_MUTE           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 2)
#define MIXERCONTROL_CONTROLTYPE_MONO           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 3)
#define MIXERCONTROL_CONTROLTYPE_LOUDNESS       (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 4)
#define MIXERCONTROL_CONTROLTYPE_STEREOENH      (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 5)
#define MIXERCONTROL_CONTROLTYPE_BUTTON         (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BUTTON | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_DECIBELS       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_DECIBELS)
#define MIXERCONTROL_CONTROLTYPE_SIGNED         (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNED       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_PERCENT        (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_PERCENT)
#define MIXERCONTROL_CONTROLTYPE_SLIDER         (MIXERCONTROL_CT_CLASS_SLIDER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PAN            (MIXERCONTROL_CONTROLTYPE_SLIDER + 1)
#define MIXERCONTROL_CONTROLTYPE_QSOUNDPAN      (MIXERCONTROL_CONTROLTYPE_SLIDER + 2)
#define MIXERCONTROL_CONTROLTYPE_FADER          (MIXERCONTROL_CT_CLASS_FADER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_VOLUME         (MIXERCONTROL_CONTROLTYPE_FADER + 1)
#define MIXERCONTROL_CONTROLTYPE_BASS           (MIXERCONTROL_CONTROLTYPE_FADER + 2)
#define MIXERCONTROL_CONTROLTYPE_TREBLE         (MIXERCONTROL_CONTROLTYPE_FADER + 3)
#define MIXERCONTROL_CONTROLTYPE_EQUALIZER      (MIXERCONTROL_CONTROLTYPE_FADER + 4)
#define MIXERCONTROL_CONTROLTYPE_SINGLESELECT   (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_SINGLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MUX            (MIXERCONTROL_CONTROLTYPE_SINGLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_MULTIPLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MIXER          (MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MICROTIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MICROSECS | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_MILLITIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MILLISECS | MIXERCONTROL_CT_UNITS_UNSIGNED)

/* */
/*  MIXERLINECONTROLS */
/* */
#ifdef _WIN32

typedef struct tagMIXERLINECONTROLSA {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROLA pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSA, *PMIXERLINECONTROLSA, *LPMIXERLINECONTROLSA;
typedef struct tagMIXERLINECONTROLSW {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROLW pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSW, *PMIXERLINECONTROLSW, *LPMIXERLINECONTROLSW;
#ifdef UNICODE
typedef MIXERLINECONTROLSW MIXERLINECONTROLS;
typedef PMIXERLINECONTROLSW PMIXERLINECONTROLS;
typedef LPMIXERLINECONTROLSW LPMIXERLINECONTROLS;
#else
typedef MIXERLINECONTROLSA MIXERLINECONTROLS;
typedef PMIXERLINECONTROLSA PMIXERLINECONTROLS;
typedef LPMIXERLINECONTROLSA LPMIXERLINECONTROLS;
#endif // UNICODE

#else
typedef struct tMIXERLINECONTROLS {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROL  pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLS, *PMIXERLINECONTROLS, FAR *LPMIXERLINECONTROLS;
#endif

/* */
/* */
/* */
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls);
WINMMAPI MMRESULT WINAPI mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls);
#ifdef UNICODE
#define mixerGetLineControls  mixerGetLineControlsW
#else
#define mixerGetLineControls  mixerGetLineControlsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetLineControls(HMIXEROBJ hmxobj, LPMIXERLINECONTROLS pmxlc, DWORD fdwControls);
#endif

#define MIXER_GETLINECONTROLSF_ALL          0x00000000L
#define MIXER_GETLINECONTROLSF_ONEBYID      0x00000001L
#define MIXER_GETLINECONTROLSF_ONEBYTYPE    0x00000002L

#define MIXER_GETLINECONTROLSF_QUERYMASK    0x0000000FL

typedef struct tMIXERCONTROLDETAILS {
    DWORD           cbStruct;       /* size in bytes of MIXERCONTROLDETAILS */
    DWORD           dwControlID;    /* control id to get/set details on */
    DWORD           cChannels;      /* number of channels in paDetails array */
    union {
	HWND        hwndOwner;      /* for MIXER_SETCONTROLDETAILSF_CUSTOM */
	DWORD       cMultipleItems; /* if _MULTIPLE, the number of items per channel */
    };
    DWORD           cbDetails;      /* size of _one_ details_XX struct */
    LPVOID          paDetails;      /* pointer to array of details_XX structs */
} MIXERCONTROLDETAILS, *PMIXERCONTROLDETAILS, FAR *LPMIXERCONTROLDETAILS;

/* */
/*  MIXER_GETCONTROLDETAILSF_LISTTEXT */
/* */
/* */
#ifdef _WIN32

typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
    DWORD           dwParam1;
    DWORD           dwParam2;
    CHAR            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTA, *PMIXERCONTROLDETAILS_LISTTEXTA, *LPMIXERCONTROLDETAILS_LISTTEXTA;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
    DWORD           dwParam1;
    DWORD           dwParam2;
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTW, *PMIXERCONTROLDETAILS_LISTTEXTW, *LPMIXERCONTROLDETAILS_LISTTEXTW;
#ifdef UNICODE
typedef MIXERCONTROLDETAILS_LISTTEXTW MIXERCONTROLDETAILS_LISTTEXT;
typedef PMIXERCONTROLDETAILS_LISTTEXTW PMIXERCONTROLDETAILS_LISTTEXT;
typedef LPMIXERCONTROLDETAILS_LISTTEXTW LPMIXERCONTROLDETAILS_LISTTEXT;
#else
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT;
typedef PMIXERCONTROLDETAILS_LISTTEXTA PMIXERCONTROLDETAILS_LISTTEXT;
typedef LPMIXERCONTROLDETAILS_LISTTEXTA LPMIXERCONTROLDETAILS_LISTTEXT;
#endif // UNICODE

#else
typedef struct tMIXERCONTROLDETAILS_LISTTEXT {
    DWORD           dwParam1;
    DWORD           dwParam2;
    char            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXT, *PMIXERCONTROLDETAILS_LISTTEXT, FAR *LPMIXERCONTROLDETAILS_LISTTEXT;
#endif

/* */
/*  MIXER_GETCONTROLDETAILSF_VALUE */
/* */
/* */
typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
    LONG            fValue;
}       MIXERCONTROLDETAILS_BOOLEAN,
      *PMIXERCONTROLDETAILS_BOOLEAN,
 FAR *LPMIXERCONTROLDETAILS_BOOLEAN;

typedef struct tMIXERCONTROLDETAILS_SIGNED {
    LONG            lValue;
}       MIXERCONTROLDETAILS_SIGNED,
      *PMIXERCONTROLDETAILS_SIGNED,
 FAR *LPMIXERCONTROLDETAILS_SIGNED;

typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
    DWORD           dwValue;
}       MIXERCONTROLDETAILS_UNSIGNED,
      *PMIXERCONTROLDETAILS_UNSIGNED,
 FAR *LPMIXERCONTROLDETAILS_UNSIGNED;

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
WINMMAPI MMRESULT WINAPI mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#ifdef UNICODE
#define mixerGetControlDetails  mixerGetControlDetailsW
#else
#define mixerGetControlDetails  mixerGetControlDetailsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#endif

#define MIXER_GETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_GETCONTROLDETAILSF_LISTTEXT   0x00000001L

#define MIXER_GETCONTROLDETAILSF_QUERYMASK  0x0000000FL

WINMMAPI MMRESULT WINAPI mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

#define MIXER_SETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_SETCONTROLDETAILSF_CUSTOM     0x00000001L

#define MIXER_SETCONTROLDETAILSF_QUERYMASK  0x0000000FL

#endif /* ifndef _WIN32_VXD */
#endif /* ifndef MMNOMIXER */

#ifndef MMNOTIMER
#ifndef _WIN32_VXD
/****************************************************************************

			    Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for fuEvent parameter of timeSetEvent() function */
#define TIME_ONESHOT    0x0000   /* program timer for single event */
#define TIME_PERIODIC   0x0001   /* program for continuous periodic event */

#ifdef _WIN32
#define TIME_CALLBACK_FUNCTION      0x0000  /* callback is function */
#define TIME_CALLBACK_EVENT_SET     0x0010  /* callback is event - use SetEvent */
#define TIME_CALLBACK_EVENT_PULSE   0x0020  /* callback is event - use PulseEvent */
#endif

/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
} TIMECAPS, *PTIMECAPS, NEAR *NPTIMECAPS, FAR *LPTIMECAPS;

/* timer function prototypes */
WINMMAPI MMRESULT WINAPI timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);
WINMMAPI DWORD WINAPI timeGetTime(void);
WINMMAPI MMRESULT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent);
WINMMAPI MMRESULT WINAPI timeKillEvent(UINT uTimerID);
WINMMAPI MMRESULT WINAPI timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);
WINMMAPI MMRESULT WINAPI timeBeginPeriod(UINT uPeriod);
WINMMAPI MMRESULT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOTIMER */

#ifndef MMNOJOY
/****************************************************************************

			    Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* constants used with JOYINFOEX */
#define JOY_BUTTON5         0x00000010l
#define JOY_BUTTON6         0x00000020l
#define JOY_BUTTON7         0x00000040l
#define JOY_BUTTON8         0x00000080l
#define JOY_BUTTON9         0x00000100l
#define JOY_BUTTON10        0x00000200l
#define JOY_BUTTON11        0x00000400l
#define JOY_BUTTON12        0x00000800l
#define JOY_BUTTON13        0x00001000l
#define JOY_BUTTON14        0x00002000l
#define JOY_BUTTON15        0x00004000l
#define JOY_BUTTON16        0x00008000l
#define JOY_BUTTON17        0x00010000l
#define JOY_BUTTON18        0x00020000l
#define JOY_BUTTON19        0x00040000l
#define JOY_BUTTON20        0x00080000l
#define JOY_BUTTON21        0x00100000l
#define JOY_BUTTON22        0x00200000l
#define JOY_BUTTON23        0x00400000l
#define JOY_BUTTON24        0x00800000l
#define JOY_BUTTON25        0x01000000l
#define JOY_BUTTON26        0x02000000l
#define JOY_BUTTON27        0x04000000l
#define JOY_BUTTON28        0x08000000l
#define JOY_BUTTON29        0x10000000l
#define JOY_BUTTON30        0x20000000l
#define JOY_BUTTON31        0x40000000l
#define JOY_BUTTON32        0x80000000l

/* constants used with JOYINFOEX structure */
#define JOY_POVCENTERED		(WORD) -1
#define JOY_POVFORWARD		0
#define JOY_POVRIGHT		9000
#define JOY_POVBACKWARD		18000
#define JOY_POVLEFT		27000

#define JOY_RETURNX		0x00000001l
#define JOY_RETURNY		0x00000002l
#define JOY_RETURNZ		0x00000004l
#define JOY_RETURNR		0x00000008l
#define JOY_RETURNU		0x00000010l	/* axis 5 */
#define JOY_RETURNV		0x00000020l	/* axis 6 */
#define JOY_RETURNPOV		0x00000040l
#define JOY_RETURNBUTTONS	0x00000080l
#define JOY_RETURNRAWDATA	0x00000100l
#define JOY_RETURNPOVCTS	0x00000200l
#define JOY_RETURNCENTERED	0x00000400l
#define JOY_USEDEADZONE		0x00000800l
#define JOY_RETURNALL		(JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
				 JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
				 JOY_RETURNPOV | JOY_RETURNBUTTONS)
#define JOY_CAL_READALWAYS	0x00010000l
#define JOY_CAL_READXYONLY	0x00020000l
#define JOY_CAL_READ3		0x00040000l
#define JOY_CAL_READ4		0x00080000l
#define JOY_CAL_READXONLY	0x00100000l
#define JOY_CAL_READYONLY	0x00200000l
#define JOY_CAL_READ5		0x00400000l
#define JOY_CAL_READ6		0x00800000l
#define JOY_CAL_READZONLY	0x01000000l
#define JOY_CAL_READRONLY	0x02000000l
#define JOY_CAL_READUONLY	0x04000000l
#define JOY_CAL_READVONLY	0x08000000l

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick driver capabilites */
#define JOYCAPS_HASZ		0x0001
#define JOYCAPS_HASR		0x0002
#define JOYCAPS_HASU		0x0004
#define JOYCAPS_HASV		0x0008
#define JOYCAPS_HASPOV		0x0010
#define JOYCAPS_POV4DIR		0x0020
#define JOYCAPS_POVCTS		0x0040

/* joystick device capabilities data structure */
#ifdef _WIN32

typedef struct tagJOYCAPSA {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    CHAR    szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    CHAR    szRegKey[MAXPNAMELEN];/* registry key */
    CHAR    szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSA, *PJOYCAPSA, *NPJOYCAPSA, *LPJOYCAPSA;
typedef struct tagJOYCAPSW {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    WCHAR   szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    WCHAR   szRegKey[MAXPNAMELEN];/* registry key */
    WCHAR   szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSW, *PJOYCAPSW, *NPJOYCAPSW, *LPJOYCAPSW;
#ifdef UNICODE
typedef JOYCAPSW JOYCAPS;
typedef PJOYCAPSW PJOYCAPS;
typedef NPJOYCAPSW NPJOYCAPS;
typedef LPJOYCAPSW LPJOYCAPS;
#else
typedef JOYCAPSA JOYCAPS;
typedef PJOYCAPSA PJOYCAPS;
typedef NPJOYCAPSA NPJOYCAPS;
typedef LPJOYCAPSA LPJOYCAPS;
#endif // UNICODE

#else
typedef struct joycaps_tag {
    WORD wMid;                  /* manufacturer ID */
    WORD wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT wRmin;                 /* minimum r position value */
    UINT wRmax;                 /* maximum r position value */
    UINT wUmin;                 /* minimum u (5th axis) position value */
    UINT wUmax;                 /* maximum u (5th axis) position value */
    UINT wVmin;                 /* minimum v (6th axis) position value */
    UINT wVmax;                 /* maximum v (6th axis) position value */
    UINT wCaps;                 /* joystick capabilites */
    UINT wMaxAxes;	 	/* maximum number of axes supported */
    UINT wNumAxes;	 	/* number of axes in use */
    UINT wMaxButtons;	 	/* maximum number of buttons supported */
    char szRegKey[MAXPNAMELEN]; /* registry key */
    char szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPS, *PJOYCAPS, NEAR *NPJOYCAPS, FAR *LPJOYCAPS;
#endif

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
} JOYINFO, *PJOYINFO, NEAR *NPJOYINFO, FAR *LPJOYINFO;

#if(WINVER >= 0x0400)
typedef struct joyinfoex_tag {
    DWORD dwSize;		 /* size of structure */
    DWORD dwFlags;		 /* flags to indicate what to return */
    DWORD dwXpos;                /* x position */
    DWORD dwYpos;                /* y position */
    DWORD dwZpos;                /* z position */
    DWORD dwRpos;		 /* rudder/4th axis position */
    DWORD dwUpos;		 /* 5th axis position */
    DWORD dwVpos;		 /* 6th axis position */
    DWORD dwButtons;             /* button states */
    DWORD dwButtonNumber;        /* current button number pressed */
    DWORD dwPOV;                 /* point of view state */
    DWORD dwReserved1;		 /* reserved for communication between winmm & driver */
    DWORD dwReserved2;		 /* reserved for future expansion */
} JOYINFOEX, *PJOYINFOEX, NEAR *NPJOYINFOEX, FAR *LPJOYINFOEX;
#endif /* WINVER >= 0x0400 */

#ifndef _WIN32_VXD

/* joystick function prototypes */
WINMMAPI UINT WINAPI joyGetNumDevs(void);
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI joyGetDevCapsA(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc);
WINMMAPI MMRESULT WINAPI joyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc);
#ifdef UNICODE
#define joyGetDevCaps  joyGetDevCapsW
#else
#define joyGetDevCaps  joyGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI joyGetDevCaps(UINT uJoyID, LPJOYCAPS pjc, UINT cbjc);
#endif
WINMMAPI MMRESULT WINAPI joyGetPos(UINT uJoyID, LPJOYINFO pji);

#if(WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI joyGetPosEx(UINT uJoyID, LPJOYINFOEX pji);
#endif /* WINVER >= 0x0400 */

WINMMAPI MMRESULT WINAPI joyGetThreshold(UINT uJoyID, LPUINT puThreshold);
WINMMAPI MMRESULT WINAPI joyReleaseCapture(UINT uJoyID);
WINMMAPI MMRESULT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL fChanged);
WINMMAPI MMRESULT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOJOY */

#ifndef MMNOMMIO
#ifndef _WIN32_VXD
/****************************************************************************

			Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE                256
#define MMIOERR_FILENOTFOUND        (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY         (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN          (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE         (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD          (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE         (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK          (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND        (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND       (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED          (MMIOERR_BASE + 10) /*  */
#define MMIOERR_PATHNOTFOUND        (MMIOERR_BASE + 11) /* path incorrect */
#define MMIOERR_ACCESSDENIED        (MMIOERR_BASE + 12) /* file was protected */
#define MMIOERR_SHARINGVIOLATION    (MMIOERR_BASE + 13) /* file in use */
#define MMIOERR_NETWORKERROR        (MMIOERR_BASE + 14) /* network not responding */
#define MMIOERR_TOOMANYOPENFILES    (MMIOERR_BASE + 15) /* no more file handles  */
#define MMIOERR_INVALIDFILE         (MMIOERR_BASE + 16) /* default error file error */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg,
	    LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
	/* general fields */
	DWORD           dwFlags;        /* general status flags */
	FOURCC          fccIOProc;      /* pointer to I/O procedure */
	LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
	UINT            wErrorRet;      /* place for error to be returned */
	HTASK           htask;          /* alternate local task */

	/* fields maintained by MMIO functions during buffered I/O */
	LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
	HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
	HPSTR           pchNext;        /* pointer to next byte to read/write */
	HPSTR           pchEndRead;     /* pointer to last valid byte to read */
	HPSTR           pchEndWrite;    /* pointer to last byte to write */
	LONG            lBufOffset;     /* disk offset of start of buffer */

	/* fields maintained by I/O procedure */
	LONG            lDiskOffset;    /* disk offset of next read or write */
	DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

	/* other fields maintained by MMIO */
	DWORD           dwReserved1;    /* reserved for MMIO use */
	DWORD           dwReserved2;    /* reserved for MMIO use */
	HMMIO           hmmio;          /* handle to open file */
} MMIOINFO, *PMMIOINFO, NEAR *NPMMIOINFO, FAR *LPMMIOINFO;
typedef const MMIOINFO FAR *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
	FOURCC          ckid;           /* chunk ID */
	DWORD           cksize;         /* chunk size */
	FOURCC          fccType;        /* form type or list type */
	DWORD           dwDataOffset;   /* offset of data portion of chunk */
	DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO, *PMMCKINFO, NEAR *NPMMCKINFO, FAR *LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_UNICODEPROC    0x01000000  /* mmioInstallIOProc: Unicode MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

/* MMIO function prototypes */
#ifdef _WIN32

WINMMAPI FOURCC WINAPI mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);
WINMMAPI FOURCC WINAPI mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);
#ifdef UNICODE
#define mmioStringToFOURCC  mmioStringToFOURCCW
#else
#define mmioStringToFOURCC  mmioStringToFOURCCA
#endif // !UNICODE
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
#ifdef UNICODE
#define mmioInstallIOProc  mmioInstallIOProcW
#else
#define mmioInstallIOProc  mmioInstallIOProcA
#endif // !UNICODE
WINMMAPI HMMIO WINAPI mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
WINMMAPI HMMIO WINAPI mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#ifdef UNICODE
#define mmioOpen  mmioOpenW
#else
#define mmioOpen  mmioOpenA
#endif // !UNICODE
WINMMAPI MMRESULT WINAPI mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
WINMMAPI MMRESULT WINAPI mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
#ifdef UNICODE
#define mmioRename  mmioRenameW
#else
#define mmioRename  mmioRenameA
#endif // !UNICODE
#else
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#if (WINVER >= 0x030a)
MMRESULT WINAPI mmioRename(LPCSTR pszFileName, LPCSTR pszNewFileName, const MMIOINFO FAR* pmmioinfo, DWORD fdwRename);
#endif /* ifdef WINVER >= 0x030a */
#endif

WINMMAPI MMRESULT WINAPI mmioClose(HMMIO hmmio, UINT fuClose);
WINMMAPI LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
WINMMAPI LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
WINMMAPI LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
WINMMAPI MMRESULT WINAPI mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT fuBuffer);
WINMMAPI MMRESULT WINAPI mmioFlush(HMMIO hmmio, UINT fuFlush);
WINMMAPI MMRESULT WINAPI mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
WINMMAPI LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMsg,
    LPARAM lParam1, LPARAM lParam2);
WINMMAPI MMRESULT WINAPI mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki,
    const MMCKINFO FAR* pmmckiParent, UINT fuDescend);
WINMMAPI MMRESULT WINAPI mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
WINMMAPI MMRESULT WINAPI mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMMIO */

#ifndef MMNOMCI
#ifndef _WIN32_VXD
/****************************************************************************

			    MCI support

****************************************************************************/

#ifndef _MCIERROR_              /* MCIERROR is defined in some post 3.1 apps */
#define _MCIERROR_
typedef DWORD   MCIERROR;       /* error return code, 0 means no error */
#endif

#ifndef _MCIDEVICEID_           /* Same with MCIDEVICEID */
#define _MCIDEVICEID_
typedef UINT    MCIDEVICEID;    /* MCI device ID type */
#endif

typedef UINT (CALLBACK *YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);

/* MCI function prototypes */
#ifdef _WIN32

WINMMAPI MCIERROR WINAPI mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
WINMMAPI MCIERROR WINAPI mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
#ifdef UNICODE
#define mciSendCommand  mciSendCommandW
#else
#define mciSendCommand  mciSendCommandA
#endif // !UNICODE
WINMMAPI MCIERROR  WINAPI mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
WINMMAPI MCIERROR  WINAPI mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
#ifdef UNICODE
#define mciSendString  mciSendStringW
#else
#define mciSendString  mciSendStringA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDA(LPCSTR pszDevice);
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDW(LPCWSTR pszDevice);
#ifdef UNICODE
#define mciGetDeviceID  mciGetDeviceIDW
#else
#define mciGetDeviceID  mciGetDeviceIDA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType );
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType );
#ifdef UNICODE
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDW
#else
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDA
#endif // !UNICODE
WINMMAPI BOOL WINAPI mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);
WINMMAPI BOOL WINAPI mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define mciGetErrorString  mciGetErrorStringW
#else
#define mciGetErrorString  mciGetErrorStringA
#endif // !UNICODE

#else
MCIERROR WINAPI mciSendCommand(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
MCIERROR  WINAPI mciSendString(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
MCIDEVICEID WINAPI mciGetDeviceID(LPCSTR pszDevice);
BOOL WINAPI mciGetErrorString(MCIERROR mcierr, LPSTR pszText, UINT cchText);
#endif

WINMMAPI BOOL WINAPI mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
WINMMAPI HTASK WINAPI mciGetCreatorTask(MCIDEVICEID mciId);
WINMMAPI YIELDPROC WINAPI mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
WINMMAPI BOOL WINAPI mciExecute(LPCSTR pszCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

#define MCIERR_NO_IDENTITY              (MCIERR_BASE + 94)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

#define MCI_FIRST                       DRV_MCI_FIRST   /* 0x0800 */
/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (DRV_MCI_FIRST + 0x400)
#define MCI_LAST                        0x0FFF

/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               ((MCIDEVICEID)-1)

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 513 /* (MCI_STRING_OFFSET + 1) */
#define MCI_DEVTYPE_VIDEODISC           514 /* (MCI_STRING_OFFSET + 2) */
#define MCI_DEVTYPE_OVERLAY             515 /* (MCI_STRING_OFFSET + 3) */
#define MCI_DEVTYPE_CD_AUDIO            516 /* (MCI_STRING_OFFSET + 4) */
#define MCI_DEVTYPE_DAT                 517 /* (MCI_STRING_OFFSET + 5) */
#define MCI_DEVTYPE_SCANNER             518 /* (MCI_STRING_OFFSET + 6) */
#define MCI_DEVTYPE_ANIMATION           519 /* (MCI_STRING_OFFSET + 7) */
#define MCI_DEVTYPE_DIGITAL_VIDEO       520 /* (MCI_STRING_OFFSET + 8) */
#define MCI_DEVTYPE_OTHER               521 /* (MCI_STRING_OFFSET + 9) */
#define MCI_DEVTYPE_WAVEFORM_AUDIO      522 /* (MCI_STRING_OFFSET + 10) */
#define MCI_DEVTYPE_SEQUENCER           523 /* (MCI_STRING_OFFSET + 11) */

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

#define MCI_DEVTYPE_FIRST_USER          0x1000
/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
						  ((WORD)(s)<<8)) | \
						 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s) | \
						   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s))<<16)))

/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008

/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L
#define MCI_INFO_MEDIA_UPC              0x00000400L
#define MCI_INFO_MEDIA_IDENTITY         0x00000800L
#define MCI_INFO_NAME                   0x00001000L
#define MCI_INFO_COPYRIGHT              0x00002000L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L

/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS, FAR *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR     lpstrDeviceType;
    LPCSTR     lpstrElementName;
    LPCSTR     lpstrAlias;
} MCI_OPEN_PARMSA, *PMCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR    lpstrDeviceType;
    LPCWSTR    lpstrElementName;
    LPCWSTR    lpstrAlias;
} MCI_OPEN_PARMSW, *PMCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OPEN_PARMSW MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSW PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSW LPMCI_OPEN_PARMS;
#else
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSA PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSA LPMCI_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OPEN_PARMS {
    DWORD       dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
} MCI_OPEN_PARMS, FAR *LPMCI_OPEN_PARMS;
#endif

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS, *PMCI_PLAY_PARMS, FAR *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS, FAR *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS, *PMCI_STATUS_PARMS, FAR * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */
#ifdef _WIN32

typedef struct tagMCI_INFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSA, * LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSW, * LPMCI_INFO_PARMSW;
#ifdef UNICODE
typedef MCI_INFO_PARMSW MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSW LPMCI_INFO_PARMS;
#else
typedef MCI_INFO_PARMSA MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSA LPMCI_INFO_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS, FAR * LPMCI_INFO_PARMS;
#endif

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS, FAR * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */
#ifdef _WIN32

typedef struct tagMCI_SYSINFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSA, *PMCI_SYSINFO_PARMSA, * LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSW, *PMCI_SYSINFO_PARMSW, * LPMCI_SYSINFO_PARMSW;
#ifdef UNICODE
typedef MCI_SYSINFO_PARMSW MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSW PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSW LPMCI_SYSINFO_PARMS;
#else
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSA PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSA LPMCI_SYSINFO_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS, FAR * LPMCI_SYSINFO_PARMS;
#endif

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS, *PMCI_SET_PARMS, FAR *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
#ifdef _WIN32
    int     nVirtKey;
    HWND    hwndBreak;
#else
    short   nVirtKey;
    WORD    wReserved0;             /* padding for Win 16 */
    HWND    hwndBreak;
    WORD    wReserved1;             /* padding for Win 16 */
#endif
} MCI_BREAK_PARMS, *PMCI_BREAK_PARMS, FAR * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_SAVE_PARMSA {
    DWORD    dwCallback;
    LPCSTR    lpfilename;
} MCI_SAVE_PARMSA, *PMCI_SAVE_PARMSA, * LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
    DWORD    dwCallback;
    LPCWSTR   lpfilename;
} MCI_SAVE_PARMSW, *PMCI_SAVE_PARMSW, * LPMCI_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_SAVE_PARMSW MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSW PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSW LPMCI_SAVE_PARMS;
#else
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSA PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSA LPMCI_SAVE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS, FAR * LPMCI_SAVE_PARMS;
#endif

/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_LOAD_PARMSA {
    DWORD    dwCallback;
    LPCSTR      lpfilename;
} MCI_LOAD_PARMSA, *PMCI_LOAD_PARMSA, * LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
    DWORD    dwCallback;
    LPCWSTR     lpfilename;
} MCI_LOAD_PARMSW, *PMCI_LOAD_PARMSW, * LPMCI_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_LOAD_PARMSW MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSW PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSW LPMCI_LOAD_PARMS;
#else
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSA PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSA LPMCI_LOAD_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS, FAR * LPMCI_LOAD_PARMS;
#endif

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS, FAR *LPMCI_RECORD_PARMS;

/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS, FAR *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS, FAR *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */
#ifdef _WIN32

typedef struct tagMCI_VD_ESCAPE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpstrCommand;
} MCI_VD_ESCAPE_PARMSA, *PMCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpstrCommand;
} MCI_VD_ESCAPE_PARMSW, *PMCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW;
#ifdef UNICODE
typedef MCI_VD_ESCAPE_PARMSW MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSW PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSW LPMCI_VD_ESCAPE_PARMS;
#else
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSA PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSA LPMCI_VD_ESCAPE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS, FAR *LPMCI_VD_ESCAPE_PARMS;
#endif

/* MCI extensions for CD audio devices */

/* flags for the dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_CDA_STATUS_TYPE_TRACK       0x00004001L

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK) */
#define MCI_CDA_TRACK_AUDIO             (MCI_CD_OFFSET + 0)
#define MCI_CDA_TRACK_OTHER             (MCI_CD_OFFSET + 1)

/* MCI extensions for waveform audio devices */

#define MCI_WAVE_PCM                    (MCI_WAVE_OFFSET + 0)
#define MCI_WAVE_MAPPER                 (MCI_WAVE_OFFSET + 1)

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_WAVE_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA, *PMCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW, *PMCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_WAVE_OPEN_PARMSW MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSW PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSW LPMCI_WAVE_OPEN_PARMS;
#else
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSA PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSA LPMCI_WAVE_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS, FAR *LPMCI_WAVE_OPEN_PARMS;
#endif

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS, FAR *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
#ifdef _WIN32
    UINT    wInput;
    UINT    wOutput;
#else
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
#endif
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS, FAR * LPMCI_WAVE_SET_PARMS;

/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533
#define     MCI_SEQ_MAPPER              65535

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL
#define MCI_SEQ_STATUS_NAME             0x0000400BL
#define MCI_SEQ_STATUS_COPYRIGHT        0x0000400CL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS, FAR * LPMCI_SEQ_SET_PARMS;

/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSA, *PMCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSW, *PMCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_OPEN_PARMSW MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSW PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSW LPMCI_ANIM_OPEN_PARMS;
#else
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSA PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSA LPMCI_ANIM_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_ANIM_OPEN_PARMS, FAR *LPMCI_ANIM_OPEN_PARMS;
#endif

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS, FAR *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS, FAR *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR     lpstrText;
} MCI_ANIM_WINDOW_PARMSA, *PMCI_ANIM_WINDOW_PARMSA, * LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR    lpstrText;
} MCI_ANIM_WINDOW_PARMSW, *PMCI_ANIM_WINDOW_PARMSW, * LPMCI_ANIM_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_WINDOW_PARMSW MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSW PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSW LPMCI_ANIM_WINDOW_PARMS;
#else
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSA PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSA LPMCI_ANIM_WINDOW_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS, FAR * LPMCI_ANIM_WINDOW_PARMS;
#endif

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS * PMCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS, FAR * LPMCI_ANIM_UPDATE_PARMS;

/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSA, *PMCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSW, *PMCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_OPEN_PARMSW MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSW PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSW LPMCI_OVLY_OPEN_PARMS;
#else
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSA PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSA LPMCI_OVLY_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_OVLY_OPEN_PARMS, FAR *LPMCI_OVLY_OPEN_PARMS;
#endif

/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR      lpstrText;
} MCI_OVLY_WINDOW_PARMSA, *PMCI_OVLY_WINDOW_PARMSA, * LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR     lpstrText;
} MCI_OVLY_WINDOW_PARMSW, *PMCI_OVLY_WINDOW_PARMSW, * LPMCI_OVLY_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_WINDOW_PARMSW MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSW PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSW LPMCI_OVLY_WINDOW_PARMS;
#else
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSA PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSA LPMCI_OVLY_WINDOW_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    UINT    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS, FAR * LPMCI_OVLY_WINDOW_PARMS;
#endif

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS, FAR * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_SAVE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSA, *PMCI_OVLY_SAVE_PARMSA, * LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSW, *PMCI_OVLY_SAVE_PARMSW, * LPMCI_OVLY_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_SAVE_PARMSW MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSW PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSW LPMCI_OVLY_SAVE_PARMS;
#else
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSA PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSA LPMCI_OVLY_SAVE_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS, FAR * LPMCI_OVLY_SAVE_PARMS;
#endif

/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_LOAD_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSA, *PMCI_OVLY_LOAD_PARMSA, * LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSW, *PMCI_OVLY_LOAD_PARMSW, * LPMCI_OVLY_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_LOAD_PARMSW MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSW PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSW LPMCI_OVLY_LOAD_PARMS;
#else
typedef MCI_OVLY_LOAD_PARMSA MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSA PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSA LPMCI_OVLY_LOAD_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS, FAR * LPMCI_OVLY_LOAD_PARMS;
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMCI */

/****************************************************************************

			DISPLAY Driver extensions

****************************************************************************/

#ifndef NEWTRANSPARENT
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef NEWTRANSPARENT */

/****************************************************************************

			DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)

/****************************************************************************

			ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OBJBASE.H ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//----------------------------------------------------------------------------

#include <rpc.h>
#include <rpcndr.h>

#if !defined( _OBJBASE_H_ )
#define _OBJBASE_H_

#include <pshpack8.h>

// Component Object Model defines, and macros

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _WIN32

// Win32 doesn't support __export

#define STDMETHODCALLTYPE       __stdcall
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

#ifdef _OLE32_
#define WINOLEAPI        STDAPI
#define WINOLEAPI_(type) STDAPI_(type)
#else
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif

/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
//#define interface               struct FAR
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface



#else

#define interface               struct

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)




#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif




/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT
#endif  // __cplusplus
#endif  // FARSTRUCT



#ifndef HUGEP
#ifdef _WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP


#include <stdlib.h>

#define LISet32(li, v) ((li).HighPart = (v) < 0 ? -1 : 0, (li).LowPart = (v))

#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))






#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
                                // and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2   // multiple use, but separate control over each
                                // context.
} REGCLS;

// interface marshaling definitions
#define MARSHALINTERFACE_MIN 500 // minimum number of bytes for interface marshl


//
// Common typedefs for paramaters used in Storage API's, gleamed from storage.h
// Also contains Storage error codes, which should be moved into the storage
// idl files.
//


#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT             0x00000000L
#define STGM_TRANSACTED         0x00010000L
#define STGM_SIMPLE             0x08000000L

#define STGM_READ               0x00000000L
#define STGM_WRITE              0x00000001L
#define STGM_READWRITE          0x00000002L

#define STGM_SHARE_DENY_NONE    0x00000040L
#define STGM_SHARE_DENY_READ    0x00000030L
#define STGM_SHARE_DENY_WRITE   0x00000020L
#define STGM_SHARE_EXCLUSIVE    0x00000010L

#define STGM_PRIORITY           0x00040000L
#define STGM_DELETEONRELEASE    0x04000000L
#if (WINVER >= 400)
#define STGM_NOSCRATCH          0x00100000L
#endif /* WINVER */

#define STGM_CREATE             0x00001000L
#define STGM_CONVERT            0x00020000L
#define STGM_FAILIFTHERE        0x00000000L


/* here is where we pull in the MIDL generated headers for the interfaces */
typedef interface    IRpcStubBuffer     IRpcStubBuffer;
typedef interface    IRpcChannelBuffer  IRpcChannelBuffer;

#include <wtypes.h>
#include <unknwn.h>
#include <objidl.h>


// macros to define byte pattern for a GUID.
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including objbase.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in ole2.lib.  The GUIDs in ole2.lib are all defined in the same text
// segment GUID_TEXT.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of objbase.h and then include initguid.h
// after objbase.h followed by one or more of the guid defintion files.

#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name
#else

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // INITGUID

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifdef __cplusplus
inline BOOL IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
#else   //  ! __cplusplus
#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#endif  //  __cplusplus

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

#ifdef __cplusplus

// because GUID is defined elsewhere in WIN32 land, the operator == and !=
// are moved outside the class to global scope.

inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
{
#ifdef _WIN32
    return !memcmp(&guidOne,&guidOther,sizeof(GUID));
#else
    return !_fmemcmp(&guidOne,&guidOther,sizeof(GUID)); }
#endif
}

inline BOOL operator!=(const GUID& guidOne, const GUID& guidOther)
{
    return !(guidOne == guidOther);
}

#endif // __cpluscplus


#ifndef INITGUID
#include <cguid.h>
#endif



/****** STD Object API Prototypes *****************************************/

WINOLEAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

WINOLEAPI  CoInitialize(LPVOID pvReserved);
WINOLEAPI_(void)  CoUninitialize(void);
WINOLEAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
WINOLEAPI_(DWORD) CoGetCurrentProcess(void);
WINOLEAPI  CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy);
WINOLEAPI  CoRevokeMallocSpy(void);
WINOLEAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);

#if DBG == 1
WINOLEAPI_(ULONG) DebugCoGetRpcFault( void );
WINOLEAPI_(void) DebugCoSetRpcFault( ULONG );
#endif

/* register/revoke/get class objects */

WINOLEAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
WINOLEAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
WINOLEAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

WINOLEAPI CoGetMarshalSizeMax(ULONG *pulSize, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
WINOLEAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
WINOLEAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
WINOLEAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
WINOLEAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
WINOLEAPI CoReleaseMarshalData(LPSTREAM pStm);
WINOLEAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
WINOLEAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
WINOLEAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

WINOLEAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);
WINOLEAPI_(BOOL) CoHasStrongExternalConnections(LPUNKNOWN pUnk);

// Apartment model inter-thread interface passing helpers
WINOLEAPI CoMarshalInterThreadInterfaceInStream(REFIID riid, LPUNKNOWN pUnk,
                    LPSTREAM *ppStm);

WINOLEAPI CoGetInterfaceAndReleaseStream(LPSTREAM pStm, REFIID iid,
                    LPVOID FAR* ppv);

WINOLEAPI CoCreateFreeThreadedMarshaler(LPUNKNOWN  punkOuter,
                    LPUNKNOWN *ppunkMarshal);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

WINOLEAPI_(HINSTANCE) CoLoadLibrary(LPOLESTR lpszLibName, BOOL bAutoFree);
WINOLEAPI_(void) CoFreeLibrary(HINSTANCE hInst);
WINOLEAPI_(void) CoFreeAllLibraries(void);
WINOLEAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

WINOLEAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */

WINOLEAPI StringFromCLSID(REFCLSID rclsid, LPOLESTR FAR* lplpsz);
WINOLEAPI CLSIDFromString(LPOLESTR lpsz, LPCLSID pclsid);
WINOLEAPI StringFromIID(REFIID rclsid, LPOLESTR FAR* lplpsz);
WINOLEAPI IIDFromString(LPOLESTR lpsz, LPIID lpiid);
WINOLEAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
WINOLEAPI ProgIDFromCLSID (REFCLSID clsid, LPOLESTR FAR* lplpszProgID);
WINOLEAPI CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid);
WINOLEAPI_(int) StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax);

WINOLEAPI CoCreateGuid(GUID FAR *pguid);

WINOLEAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
WINOLEAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
WINOLEAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


WINOLEAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

WINOLEAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
WINOLEAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at
 * the same time.
 */

#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);
#else
typedef HRESULT (STDAPICALLTYPE * LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);
#endif

#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE * LPFNCANUNLOADNOW)(void);
#endif

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);

STDAPI  DllCanUnloadNow(void);


/****** Default Memory Allocation ******************************************/
WINOLEAPI_(LPVOID) CoTaskMemAlloc(ULONG cb);
WINOLEAPI_(LPVOID) CoTaskMemRealloc(LPVOID pv, ULONG cb);
WINOLEAPI_(void)   CoTaskMemFree(LPVOID pv);

/****** DV APIs ***********************************************************/


WINOLEAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

WINOLEAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
                                        REFIID iid, LPVOID FAR* ppv);




/****** Storage API Prototypes ********************************************/


WINOLEAPI StgCreateDocfile(const OLECHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgOpenStorage(const OLECHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
WINOLEAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgIsStorageFile(const OLECHAR FAR* pwcsName);
WINOLEAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

WINOLEAPI StgSetTimes(OLECHAR const FAR* lpszName,
                   FILETIME const FAR* pctime,
                   FILETIME const FAR* patime,
                   FILETIME const FAR* pmtime);


//
//  Moniker APIs
//

WINOLEAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
WINOLEAPI  MkParseDisplayName(LPBC pbc, LPCOLESTR szUserName,
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
WINOLEAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL dwReserved);
WINOLEAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
WINOLEAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
WINOLEAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
WINOLEAPI  GetClassFile (LPCOLESTR szFilename, CLSID FAR* pclsid);

WINOLEAPI  CreateFileMoniker(LPCOLESTR lpszPathName, LPMONIKER FAR* ppmk);

WINOLEAPI  CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem,
    LPMONIKER FAR* ppmk);
WINOLEAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
WINOLEAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

WINOLEAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#endif     // __OBJBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OAIDL.H ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:38 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __oaidl_h__
#define __oaidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICreateTypeInfo_FWD_DEFINED__
#define __ICreateTypeInfo_FWD_DEFINED__
typedef interface ICreateTypeInfo ICreateTypeInfo;
#endif 	/* __ICreateTypeInfo_FWD_DEFINED__ */


#ifndef __ICreateTypeLib_FWD_DEFINED__
#define __ICreateTypeLib_FWD_DEFINED__
typedef interface ICreateTypeLib ICreateTypeLib;
#endif 	/* __ICreateTypeLib_FWD_DEFINED__ */


#ifndef __IDispatch_FWD_DEFINED__
#define __IDispatch_FWD_DEFINED__
typedef interface IDispatch IDispatch;
#endif 	/* __IDispatch_FWD_DEFINED__ */


#ifndef __IEnumVARIANT_FWD_DEFINED__
#define __IEnumVARIANT_FWD_DEFINED__
typedef interface IEnumVARIANT IEnumVARIANT;
#endif 	/* __IEnumVARIANT_FWD_DEFINED__ */


#ifndef __ITypeComp_FWD_DEFINED__
#define __ITypeComp_FWD_DEFINED__
typedef interface ITypeComp ITypeComp;
#endif 	/* __ITypeComp_FWD_DEFINED__ */


#ifndef __ITypeInfo_FWD_DEFINED__
#define __ITypeInfo_FWD_DEFINED__
typedef interface ITypeInfo ITypeInfo;
#endif 	/* __ITypeInfo_FWD_DEFINED__ */


#ifndef __ITypeLib_FWD_DEFINED__
#define __ITypeLib_FWD_DEFINED__
typedef interface ITypeLib ITypeLib;
#endif 	/* __ITypeLib_FWD_DEFINED__ */


#ifndef __IErrorInfo_FWD_DEFINED__
#define __IErrorInfo_FWD_DEFINED__
typedef interface IErrorInfo IErrorInfo;
#endif 	/* __IErrorInfo_FWD_DEFINED__ */


#ifndef __ICreateErrorInfo_FWD_DEFINED__
#define __ICreateErrorInfo_FWD_DEFINED__
typedef interface ICreateErrorInfo ICreateErrorInfo;
#endif 	/* __ICreateErrorInfo_FWD_DEFINED__ */


#ifndef __ISupportErrorInfo_FWD_DEFINED__
#define __ISupportErrorInfo_FWD_DEFINED__
typedef interface ISupportErrorInfo ISupportErrorInfo;
#endif 	/* __ISupportErrorInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __RemVariant_INTERFACE_DEFINED__
#define __RemVariant_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: RemVariant
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][version] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
/* XBSTR is for internal use only, it is subject to change */
			/* size is 4 */
typedef struct  tagXBSTR
    {
    ULONG cbSize;
    /* [size_is] */ OLECHAR rgBstrData[ 1 ];
    }	XBSTR;

			/* size is 4 */
typedef OLECHAR __RPC_FAR *BSTR;

			/* size is 4 */
typedef BSTR __RPC_FAR *LPBSTR;

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
			/* size is 8 */
typedef struct  tagBLOB
    {
    ULONG cbSize;
    /* [size_is] */ BYTE __RPC_FAR *pBlobData;
    }	BLOB;

			/* size is 4 */
typedef struct tagBLOB __RPC_FAR *LPBLOB;

#endif
#ifndef _tagCLIPDATA_DEFINED
#define _tagCLIPDATA_DEFINED
#define _CLIPDATA_DEFINED
			/* size is 12 */
typedef struct  tagCLIPDATA
    {
    ULONG cbSize;
    long ulClipFmt;
    /* [size_is] */ BYTE __RPC_FAR *pClipData;
    }	CLIPDATA;

#endif
#ifndef _tagSAFEARRAYBOUND_DEFINED
#define _tagSAFEARRAYBOUND_DEFINED
#define _SAFEARRAYBOUND_DEFINED
#define _LPSAFEARRAYBOUND_DEFINED
			/* size is 8 */
typedef struct  tagSAFEARRAYBOUND
    {
    ULONG cElements;
    LONG lLbound;
    }	SAFEARRAYBOUND;

			/* size is 4 */
typedef struct tagSAFEARRAYBOUND __RPC_FAR *LPSAFEARRAYBOUND;

#endif
#ifndef _tagSAFEARRAY_DEFINED
#define _tagSAFEARRAY_DEFINED
#define _SAFEARRAY_DEFINED
#define _LPSAFEARRAY_DEFINED
#if 0
/* the following is what RPC knows how to remote */
			/* size is 16 */
typedef struct  tagSAFEARRAY
    {
    unsigned short cDims;
    unsigned short fFeatures;
    unsigned long cbElements;
    unsigned long cLocks;
    BYTE __RPC_FAR *pvData;
    /* [size_is] */ SAFEARRAYBOUND rgsabound[ 1 ];
    }	SAFEARRAY;

			/* size is 4 */
typedef struct tagSAFEARRAY __RPC_FAR *LPSAFEARRAY;

#else
typedef struct FARSTRUCT tagSAFEARRAY {
    unsigned short cDims;
    unsigned short fFeatures;
#if defined(_WIN32)
    unsigned long cbElements;
    unsigned long cLocks;
#else
    unsigned short cbElements;
    unsigned short cLocks;
    unsigned long handle;               // unused but kept for compatiblity
#endif
    void HUGEP* pvData;
    SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY, FAR* LPSAFEARRAY;
#endif
#endif
			/* size is 2 */
#define	FADF_AUTO	( 0x1 )

			/* size is 2 */
#define	FADF_STATIC	( 0x2 )

			/* size is 2 */
#define	FADF_EMBEDDED	( 0x4 )

			/* size is 2 */
#define	FADF_FIXEDSIZE	( 0x10 )

			/* size is 2 */
#define	FADF_BSTR	( 0x100 )

			/* size is 2 */
#define	FADF_UNKNOWN	( 0x200 )

			/* size is 2 */
#define	FADF_DISPATCH	( 0x400 )

			/* size is 2 */
#define	FADF_VARIANT	( 0x800 )

			/* size is 2 */
#define	FADF_RESERVED	( 0xf0e8 )

			/* size is 8 */
typedef double DATE;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if 0
/* the following isn't the real definition of CY, but it is */
/* what RPC knows how to remote */
			/* size is 8 */
typedef struct  tagCY
    {
    LONGLONG int64;
    }	CY;

#else
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {         
#ifdef _MAC          
        long      Hi;
        long Lo;     
#else                
        unsigned long Lo;
        long      Hi;
#endif               
    };               
    LONGLONG int64;  
} CY;                
#endif
#endif
			/* size is 8 */
typedef CY CURRENCY;

/* 0 == FALSE, -1 == TRUE */
			/* size is 2 */
typedef short VARIANT_BOOL;

#ifndef VARIANT_TRUE
#define VARIANT_TRUE ((VARIANT_BOOL)0xffff)
#endif
#ifndef VARIANT_FALSE
#define VARIANT_FALSE ((VARIANT_BOOL)0)
#endif
#ifndef _VARENUM_DEFINED
#define _VARENUM_DEFINED
/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing                     
 *  VT_NULL             [V]           SQL style Null              
 *  VT_I2               [V][T][P][S]  2 byte signed int           
 *  VT_I4               [V][T][P][S]  4 byte signed int           
 *  VT_R4               [V][T][P][S]  4 byte real                 
 *  VT_R8               [V][T][P][S]  8 byte real                 
 *  VT_CY               [V][T][P][S]  currency                    
 *  VT_DATE             [V][T][P][S]  date                        
 *  VT_BSTR             [V][T][P][S]  OLE Automation string       
 *  VT_DISPATCH         [V][T]   [S]  IDispatch FAR*              
 *  VT_ERROR            [V][T]   [S]  SCODE                       
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0            
 *  VT_VARIANT          [V][T][P][S]  VARIANT FAR*                
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown FAR*               
 *  VT_I1                  [T]        signed char                 
 *  VT_UI1              [V][T]   [S]  unsigned char               
 *  VT_UI2                 [T]        unsigned short              
 *  VT_UI4                 [T]        unsigned short              
 *  VT_I8                  [T][P]     signed 64-bit int           
 *  VT_UI8                 [T]        unsigned 64-bit int         
 *  VT_INT                 [T]        signed machine int          
 *  VT_UINT                [T]        unsigned machine int        
 *  VT_VOID                [T]        C style void                
 *  VT_HRESULT             [T]                                    
 *  VT_PTR                 [T]        pointer type                
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)   
 *  VT_CARRAY              [T]        C style array               
 *  VT_USERDEFINED         [T]        user defined type           
 *  VT_LPSTR               [T][P]     null terminated string      
 *  VT_LPWSTR              [T][P]     wide null terminated string 
 *  VT_FILETIME               [P]     FILETIME                    
 *  VT_BLOB                   [P]     Length prefixed bytes       
 *  VT_STREAM                 [P]     Name of the stream follows  
 *  VT_STORAGE                [P]     Name of the storage follows 
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object   
 *  VT_STORED_OBJECT          [P]     Storage contains an object  
 *  VT_BLOB_OBJECT            [P]     Blob contains an object     
 *  VT_CF                     [P]     Clipboard format            
 *  VT_CLSID                  [P]     A Class ID                  
 *  VT_VECTOR                 [P]     simple counted array        
 *  VT_ARRAY            [V]           SAFEARRAY*                  
 *  VT_BYREF            [V]                                       
 */
			/* size is 2 */

enum VARENUM
    {	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72
    };
#endif
			/* size is 2 */
#define	VT_VECTOR	( 0x1000 )

			/* size is 2 */
#define	VT_ARRAY	( 0x2000 )

			/* size is 2 */
#define	VT_BYREF	( 0x4000 )

			/* size is 2 */
#define	VT_RESERVED	( 0x8000 )

#ifndef _VARTYPE_DEFINED
#define _VARTYPE_DEFINED
			/* size is 2 */
typedef unsigned short VARTYPE;

#endif
			/* size is 0 */
typedef struct tagVARIANT VARIANT;

/* forward declare IDispatch */
typedef interface IDispatch IDispatch;
/* VARIANT STRUCTURE
 *
 *  VARTYPE vt;
 *  unsigned short wReserved1;
 *  unsigned short wReserved2;
 *  unsigned short wReserved3;
 *  union {
 *    unsigned char        VT_UI1               
 *    short                VT_I2                
 *    long                 VT_I4                
 *    float                VT_R4                
 *    double               VT_R8                
 *    VARIANT_BOOL         VT_BOOL              
 *    SCODE                VT_ERROR             
 *    CY                   VT_CY                
 *    DATE                 VT_DATE              
 *    BSTR                 VT_BSTR              
 *    IUnknown FAR*        VT_UNKNOWN           
 *    IDispatch FAR*       VT_DISPATCH          
 *    SAFEARRAY FAR*       VT_ARRAY|*           
 *    short FAR*           VT_BYREF|VT_I2       
 *    long FAR*            VT_BYREF|VT_I4       
 *    float FAR*           VT_BYREF|VT_R4       
 *    double FAR*          VT_BYREF|VT_R8       
 *    VARIANT_BOOL FAR*    VT_BYREF|VT_BOOL     
 *    SCODE FAR*           VT_BYREF|VT_ERROR    
 *    CY FAR*              VT_BYREF|VT_CY       
 *    DATE FAR*            VT_BYREF|VT_DATE     
 *    BSTR FAR*            VT_BYREF|VT_BSTR     
 *    IUnknown FAR* FAR*   VT_BYREF|VT_UNKNOWN  
 *    IDispatch FAR* FAR*  VT_BYREF|VT_DISPATCH 
 *    SAFEARRAY FAR* FAR*  VT_BYREF|VT_ARRAY|*  
 *    VARIANT FAR*         VT_BYREF|VT_VARIANT  
 *    void FAR*            Generic ByRef        
 */
#ifndef _tagVARIANT_DEFINED
#define _tagVARIANT_DEFINED
#if 0
/* the following is what RPC knows how to remote */
			/* size is 16 */
struct  tagVARIANT
    {
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ long lVal;
        /* [case] */ unsigned char bVal;
        /* [case] */ short iVal;
        /* [case] */ float fltVal;
        /* [case] */ double dblVal;
        /* [case] */ VARIANT_BOOL bool;
        /* [case] */ SCODE scode;
        /* [case] */ CY cyVal;
        /* [case] */ DATE date;
        /* [case] */ BSTR bstrVal;
        /* [case] */ IUnknown __RPC_FAR *punkVal;
        /* [case] */ SAFEARRAY __RPC_FAR *parray;
        /* [case] */ unsigned char __RPC_FAR *pbVal;
        /* [case] */ short __RPC_FAR *piVal;
        /* [case] */ long __RPC_FAR *plVal;
        /* [case] */ float __RPC_FAR *pfltVal;
        /* [case] */ double __RPC_FAR *pdblVal;
        /* [case] */ VARIANT_BOOL __RPC_FAR *pbool;
        /* [case] */ SCODE __RPC_FAR *pscode;
        /* [case] */ CY __RPC_FAR *pcyVal;
        /* [case] */ DATE __RPC_FAR *pdate;
        /* [case] */ BSTR __RPC_FAR *pbstrVal;
        /* [case] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkVal;
        /* [case] */ SAFEARRAY __RPC_FAR *__RPC_FAR *pparray;
        /* [case] */ VARIANT __RPC_FAR *pvarVal;
        /* [case] */ long __RPC_FAR *byref;
        }	;
    };
#endif
struct tagVARIANT{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    union
    {
      long          lVal;           /* VT_I4                */
      unsigned char bVal;           /* VT_UI1               */
      short         iVal;           /* VT_I2                */
      float         fltVal;         /* VT_R4                */
      double        dblVal;         /* VT_R8                */
      VARIANT_BOOL  bool;           /* VT_BOOL              */
      SCODE         scode;          /* VT_ERROR             */
      CY            cyVal;          /* VT_CY                */
      DATE          date;           /* VT_DATE              */
      BSTR          bstrVal;        /* VT_BSTR              */
      IUnknown      *punkVal;       /* VT_UNKNOWN           */
      IDispatch     *pdispVal;      /* VT_DISPATCH          */
      SAFEARRAY     *parray;        /* VT_ARRAY|*           */
      unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */
      short         *piVal;         /* VT_BYREF|VT_I2       */
      long          *plVal;         /* VT_BYREF|VT_I4       */
      float         *pfltVal;       /* VT_BYREF|VT_R4       */
      double        *pdblVal;       /* VT_BYREF|VT_R8       */
      VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */
      SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */
      CY            *pcyVal;        /* VT_BYREF|VT_CY       */
      DATE          *pdate;         /* VT_BYREF|VT_DATE     */
      BSTR          *pbstrVal;      /* VT_BYREF|VT_BSTR     */
      IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */
      IDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY     **pparray;      /* VT_BYREF|VT_ARRAY|*  */
      VARIANT       *pvarVal;       /* VT_BYREF|VT_VARIANT  */
      void     * byref;             /* Generic ByRef        */
    }
#if(defined(NONAMELESSUNION))
    u
#endif
     ;
};
#endif
#ifndef _LPVARIANT_DEFINED
#define _LPVARIANT_DEFINED
			/* size is 4 */
typedef struct tagVARIANT __RPC_FAR *LPVARIANT;

#endif
#ifndef _VARIANTARG_DEFINED
#define _VARIANTARG_DEFINED
			/* size is 16 */
typedef struct tagVARIANT VARIANTARG;

#endif
#ifndef _LPVARIANTARG_DEFINED
#define _LPVARIANTARG_DEFINED
			/* size is 4 */
typedef struct tagVARIANT __RPC_FAR *LPVARIANTARG;

#endif
#ifndef _DISPID_DEFINED
#define _DISPID_DEFINED
			/* size is 4 */
typedef LONG DISPID;

#endif
#ifndef _MEMBERID_DEFINED
#define _MEMBERID_DEFINED
			/* size is 4 */
typedef DISPID MEMBERID;

#endif
#ifndef _HREFTYPE_DEFINED
#define _HREFTYPE_DEFINED
			/* size is 4 */
typedef DWORD HREFTYPE;

#endif
			/* size is 4 */
typedef ULONG PROPID;

			/* size is 2 */
typedef /* [transmit] */ 
enum tagTYPEKIND
    {	TKIND_ENUM	= 0,
	TKIND_RECORD	= TKIND_ENUM + 1,
	TKIND_MODULE	= TKIND_RECORD + 1,
	TKIND_INTERFACE	= TKIND_MODULE + 1,
	TKIND_DISPATCH	= TKIND_INTERFACE + 1,
	TKIND_COCLASS	= TKIND_DISPATCH + 1,
	TKIND_ALIAS	= TKIND_COCLASS + 1,
	TKIND_UNION	= TKIND_ALIAS + 1,
	TKIND_MAX	= TKIND_UNION + 1
    }	TYPEKIND;

#define TYPEKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define TYPEKIND_from_xmit(pLong, pEnum) *(pEnum) = (TYPEKIND) *(pLong)
#define TYPEKIND_free_inst(pEnum) 
#define TYPEKIND_free_xmit(pLong) 
#ifndef _tagTYPEDESC_DEFINED
#define _tagTYPEDESC_DEFINED
#define _TYPEDESC_DEFINED
/* VT_PTR - lptdesc, the pointed at type */
/* VT_CARRAY - lpadesc */
/* VT_USERDEFINED - hreftype, used to get the UDT typeinfo */
			/* size is 6 */
typedef struct  tagTYPEDESC
    {
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ struct tagTYPEDESC __RPC_FAR *lptdesc;
        /* [case] */ struct tagARRAYDESC __RPC_FAR *lpadesc;
        /* [case] */ HREFTYPE hreftype;
        }	;
    VARTYPE vt;
    }	TYPEDESC;

#endif
#ifndef _tagARRAYDESC_DEFINED
#define _tagARRAYDESC_DEFINED
#define _ARRAYDESC_DEFINED
#if 0
			/* size is 8 */
typedef struct  tagARRAYDESC
    {
    TYPEDESC tdescElem;
    USHORT cDims;
    /* [size_is] */ SAFEARRAYBOUND rgbounds[ 1 ];
    }	ARRAYDESC;

#else
typedef struct tagARRAYDESC {
    TYPEDESC tdescElem;     /* element type */
    USHORT cDims;       /* dimension count */
    SAFEARRAYBOUND rgbounds[1]; /* variable length array of bounds */
} ARRAYDESC;
#endif
#endif
#ifndef _tagIDLDESC_DEFINED
#define _tagIDLDESC_DEFINED
#define _IDLDESC_DEFINED
#define _LPIDLDESC_DEFINED
#ifdef _WIN32
			/* size is 6 */
typedef struct  tagIDLDESC
    {
    unsigned long dwReserved;
    unsigned short wIDLFlags;
    }	IDLDESC;

			/* size is 4 */
typedef struct tagIDLDESC __RPC_FAR *LPIDLDESC;

#else
typedef struct FARSTRUCT tagIDLDESC {
#if defined(_WIN32)
    unsigned long dwReserved;
#else
    BSTR bstrIDLInfo;           /* reserved, but original name retained for
                                   compatibilty */
#endif
    unsigned short wIDLFlags;   /* IN, OUT, etc */
} IDLDESC, FAR* LPIDLDESC;
#endif
#endif
#ifndef _tagELEMDESC_DEFINED
#define _tagELEMDESC_DEFINED
#define _ELEMDESC_DEFINED
#define _LPELEMDESC_DEFINED
			/* size is 14 */
typedef struct  tagELEMDESC
    {
    TYPEDESC tdesc;
    IDLDESC idldesc;
    }	ELEMDESC;

			/* size is 4 */
typedef struct tagELEMDESC __RPC_FAR *LPELEMDESC;

#endif
#ifndef _tagTYPEATTR_DEFINED
#define _tagTYPEATTR_DEFINED
#define _TYPEATTR_DEFINED
#define _LPTYPEATTR_DEFINED
			/* size is 74 */
typedef struct  tagTYPEATTR
    {
    GUID guid;
    LCID lcid;
    DWORD dwReserved;
    MEMBERID memidConstructor;
    MEMBERID memidDestructor;
    LPOLESTR lpstrSchema;
    ULONG cbSizeInstance;
    TYPEKIND typekind;
    WORD cFuncs;
    WORD cVars;
    WORD cImplTypes;
    WORD cbSizeVft;
    WORD cbAlignment;
    WORD wTypeFlags;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    TYPEDESC tdescAlias;
    IDLDESC idldescType;
    }	TYPEATTR;

			/* size is 4 */
typedef struct tagTYPEATTR __RPC_FAR *LPTYPEATTR;

#endif
			/* size is 16 */
typedef struct  tagDISPPARAMS
    {
    /* [size_is] */ VARIANTARG __RPC_FAR *rgvarg;
    /* [size_is] */ DISPID __RPC_FAR *rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
    }	DISPPARAMS;

			/* size is 24 */
typedef struct  tagRemEXCEPINFO
    {
    WORD wCode;
    WORD wReserved;
    DWORD dwHelpContext;
    DWORD scode;
    DWORD cSource;
    DWORD cDescription;
    DWORD cHelpFile;
    /* [size_is] */ OLECHAR strings[ 1 ];
    }	RemEXCEPINFO;

#if 0
			/* size is 32 */
typedef /* [transmit] */ struct  tagEXCEPINFO
    {
    WORD wCode;
    WORD wReserved;
    BSTR bstrSource;
    BSTR bstrDescription;
    BSTR bstrHelpFile;
    DWORD dwHelpContext;
    /* [unique] */ void __RPC_FAR *pvReserved;
    HRESULT ( __stdcall __RPC_FAR *pfnDeferredFillIn )( 
        struct tagEXCEPINFO __RPC_FAR *__MIDL_0004);
    SCODE scode;
    }	EXCEPINFO;

			/* size is 4 */
typedef /* [transmit] */ struct tagEXCEPINFO __RPC_FAR *LPEXCEPINFO;

#else
typedef struct tagEXCEPINFO {
    WORD wCode;
    WORD wReserved;
    BSTR bstrSource;
    BSTR bstrDescription;
    BSTR bstrHelpFile;
    DWORD dwHelpContext;
    void __RPC_FAR * pvReserved;
    HRESULT (__stdcall __RPC_FAR * pfnDeferredFillIn)(struct tagEXCEPINFO __RPC_FAR *);
    SCODE scode;
}  EXCEPINFO, __RPC_FAR * LPEXCEPINFO;
#endif
			/* size is 2 */
typedef /* [transmit] */ 
enum tagCALLCONV
    {	CC_CDECL	= 1,
	CC_MSCPASCAL	= CC_CDECL + 1,
	CC_PASCAL	= CC_MSCPASCAL,
	CC_MACPASCAL	= CC_PASCAL + 1,
	CC_STDCALL	= CC_MACPASCAL + 1,
	CC_RESERVED	= CC_STDCALL + 1,
	CC_SYSCALL	= CC_RESERVED + 1,
	CC_MPWCDECL	= CC_SYSCALL + 1,
	CC_MPWPASCAL	= CC_MPWCDECL + 1,
	CC_MAX	= CC_MPWPASCAL + 1
    }	CALLCONV;

#define CALLCONV_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define CALLCONV_from_xmit(pLong, pEnum) *(pEnum) = (CALLCONV) *(pLong)
#define CALLCONV_free_inst(pEnum) 
#define CALLCONV_free_xmit(pLong) 
			/* size is 2 */
typedef /* [transmit] */ 
enum tagFUNCKIND
    {	FUNC_VIRTUAL	= 0,
	FUNC_PUREVIRTUAL	= FUNC_VIRTUAL + 1,
	FUNC_NONVIRTUAL	= FUNC_PUREVIRTUAL + 1,
	FUNC_STATIC	= FUNC_NONVIRTUAL + 1,
	FUNC_DISPATCH	= FUNC_STATIC + 1
    }	FUNCKIND;

#define FUNCKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define FUNCKIND_from_xmit(pLong, pEnum) *(pEnum) = (FUNCKIND) *(pLong)
#define FUNCKIND_free_inst(pEnum) 
#define FUNCKIND_free_xmit(pLong) 
			/* size is 2 */
typedef /* [transmit] */ 
enum tagINVOKEKIND
    {	INVOKE_FUNC	= 1,
	INVOKE_PROPERTYGET	= 2,
	INVOKE_PROPERTYPUT	= 4,
	INVOKE_PROPERTYPUTREF	= 8
    }	INVOKEKIND;

#define INVOKEKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define INVOKEKIND_from_xmit(pLong, pEnum) *(pEnum) = (INVOKEKIND) *(pLong)
#define INVOKEKIND_free_inst(pEnum) 
#define INVOKEKIND_free_xmit(pLong) 
			/* size is 44 */
typedef struct  tagFUNCDESC
    {
    MEMBERID memid;
    /* [size_is] */ SCODE __RPC_FAR *lprgscode;
    /* [size_is] */ ELEMDESC __RPC_FAR *lprgelemdescParam;
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    SHORT cParams;
    SHORT cParamsOpt;
    SHORT oVft;
    SHORT cScodes;
    ELEMDESC elemdescFunc;
    WORD wFuncFlags;
    }	FUNCDESC;

			/* size is 4 */
typedef struct tagFUNCDESC __RPC_FAR *LPFUNCDESC;

			/* size is 2 */
typedef /* [transmit] */ 
enum tagVARKIND
    {	VAR_PERINSTANCE	= 0,
	VAR_STATIC	= VAR_PERINSTANCE + 1,
	VAR_CONST	= VAR_STATIC + 1,
	VAR_DISPATCH	= VAR_CONST + 1
    }	VARKIND;

#define VARKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define VARKIND_from_xmit(pLong, pEnum) *(pEnum) = (VARKIND) *(pLong)
#define VARKIND_free_inst(pEnum) 
#define VARKIND_free_xmit(pLong) 
			/* size is 2 */
#define	IMPLTYPEFLAG_FDEFAULT	( 0x1 )

			/* size is 2 */
#define	IMPLTYPEFLAG_FSOURCE	( 0x2 )

			/* size is 2 */
#define	IMPLTYPEFLAG_FRESTRICTED	( 0x4 )

			/* size is 30 */
typedef struct  tagVARDESC
    {
    MEMBERID memid;
    LPOLESTR lpstrSchema;
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ ULONG oInst;
        /* [case] */ VARIANT __RPC_FAR *lpvarValue;
        }	;
    ELEMDESC elemdescVar;
    WORD wVarFlags;
    VARKIND varkind;
    }	VARDESC;

			/* size is 4 */
typedef struct tagVARDESC __RPC_FAR *LPVARDESC;

#ifndef _tagTYPEFLAGS_DEFINED
#define _tagTYPEFLAGS_DEFINED
#define _TYPEFLAGS_DEFINED
			/* size is 2 */
typedef 
enum tagTYPEFLAGS
    {	TYPEFLAG_FAPPOBJECT	= 0x1,
	TYPEFLAG_FCANCREATE	= 0x2,
	TYPEFLAG_FLICENSED	= 0x4,
	TYPEFLAG_FPREDECLID	= 0x8,
	TYPEFLAG_FHIDDEN	= 0x10,
	TYPEFLAG_FCONTROL	= 0x20,
	TYPEFLAG_FDUAL	= 0x40,
	TYPEFLAG_FNONEXTENSIBLE	= 0x80,
	TYPEFLAG_FOLEAUTOMATION	= 0x100,
	TYPEFLAG_FRESTRICTED	= 0x200
    }	TYPEFLAGS;

#endif
#ifndef _tagFUNCFLAGS_DEFINED
#define _tagFUNCFLAGS_DEFINED
#define _FUNCFLAGS_DEFINED
			/* size is 2 */
typedef 
enum tagFUNCFLAGS
    {	FUNCFLAG_FRESTRICTED	= 1,
	FUNCFLAG_FSOURCE	= 0x2,
	FUNCFLAG_FBINDABLE	= 0x4,
	FUNCFLAG_FREQUESTEDIT	= 0x8,
	FUNCFLAG_FDISPLAYBIND	= 0x10,
	FUNCFLAG_FDEFAULTBIND	= 0x20,
	FUNCFLAG_FHIDDEN	= 0x40,
	FUNCFLAG_FUSESGETLASTERROR	= 0x80
    }	FUNCFLAGS;

#endif
#ifndef _tagVARFLAGS_DEFINED
#define _tagVARFLAGS_DEFINED
#define _VARFLAGS_DEFINED
			/* size is 2 */
typedef 
enum tagVARFLAGS
    {	VARFLAG_FREADONLY	= 1,
	VARFLAG_FSOURCE	= 0x2,
	VARFLAG_FBINDABLE	= 0x4,
	VARFLAG_FREQUESTEDIT	= 0x8,
	VARFLAG_FDISPLAYBIND	= 0x10,
	VARFLAG_FDEFAULTBIND	= 0x20,
	VARFLAG_FHIDDEN	= 0x40
    }	VARFLAGS;

#endif


extern RPC_IF_HANDLE RemVariant_v0_1_c_ifspec;
extern RPC_IF_HANDLE RemVariant_v0_1_s_ifspec;
#endif /* __RemVariant_INTERFACE_DEFINED__ */

#ifndef __ICreateTypeInfo_INTERFACE_DEFINED__
#define __ICreateTypeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateTypeInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICreateTypeInfo __RPC_FAR *LPCREATETYPEINFO;


EXTERN_C const IID IID_ICreateTypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateTypeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetGuid( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual HRESULT __stdcall SetTypeFlags( 
            /* [in] */ UINT uTypeFlags) = 0;
        
        virtual HRESULT __stdcall SetDocString( 
            /* [in] */ LPOLESTR lpstrDoc) = 0;
        
        virtual HRESULT __stdcall SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetVersion( 
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum) = 0;
        
        virtual HRESULT __stdcall AddRefTypeInfo( 
            /* [in] */ ITypeInfo __RPC_FAR *ptinfo,
            /* [in] */ HREFTYPE __RPC_FAR *phreftype) = 0;
        
        virtual HRESULT __stdcall AddFuncDesc( 
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc) = 0;
        
        virtual HRESULT __stdcall AddImplType( 
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hreftype) = 0;
        
        virtual HRESULT __stdcall SetImplTypeFlags( 
            /* [in] */ UINT index,
            /* [in] */ INT impltypeflags) = 0;
        
        virtual HRESULT __stdcall SetAlignment( 
            /* [in] */ WORD cbAlignment) = 0;
        
        virtual HRESULT __stdcall SetSchema( 
            /* [in] */ LPOLESTR lpstrSchema) = 0;
        
        virtual HRESULT __stdcall AddVarDesc( 
            /* [in] */ UINT index,
            /* [in] */ VARDESC __RPC_FAR *pvardesc) = 0;
        
        virtual HRESULT __stdcall SetFuncAndParamNames( 
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames) = 0;
        
        virtual HRESULT __stdcall SetVarName( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName) = 0;
        
        virtual HRESULT __stdcall SetTypeDescAlias( 
            /* [in] */ TYPEDESC __RPC_FAR *ptdescAlias) = 0;
        
        virtual HRESULT __stdcall DefineFuncAsDllEntry( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName) = 0;
        
        virtual HRESULT __stdcall SetFuncDocString( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString) = 0;
        
        virtual HRESULT __stdcall SetVarDocString( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString) = 0;
        
        virtual HRESULT __stdcall SetFuncHelpContext( 
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetVarHelpContext( 
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetMops( 
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops) = 0;
        
        virtual HRESULT __stdcall SetTypeIdldesc( 
            /* [in] */ IDLDESC __RPC_FAR *pidldesc) = 0;
        
        virtual HRESULT __stdcall LayOut( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICreateTypeInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICreateTypeInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetGuid )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( __stdcall __RPC_FAR *SetTypeFlags )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT uTypeFlags);
        
        HRESULT ( __stdcall __RPC_FAR *SetDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR lpstrDoc);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetVersion )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( __stdcall __RPC_FAR *AddRefTypeInfo )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ ITypeInfo __RPC_FAR *ptinfo,
            /* [in] */ HREFTYPE __RPC_FAR *phreftype);
        
        HRESULT ( __stdcall __RPC_FAR *AddFuncDesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);
        
        HRESULT ( __stdcall __RPC_FAR *AddImplType )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hreftype);
        
        HRESULT ( __stdcall __RPC_FAR *SetImplTypeFlags )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ INT impltypeflags);
        
        HRESULT ( __stdcall __RPC_FAR *SetAlignment )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ WORD cbAlignment);
        
        HRESULT ( __stdcall __RPC_FAR *SetSchema )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR lpstrSchema);
        
        HRESULT ( __stdcall __RPC_FAR *AddVarDesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ VARDESC __RPC_FAR *pvardesc);
        
        HRESULT ( __stdcall __RPC_FAR *SetFuncAndParamNames )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames);
        
        HRESULT ( __stdcall __RPC_FAR *SetVarName )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( __stdcall __RPC_FAR *SetTypeDescAlias )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ TYPEDESC __RPC_FAR *ptdescAlias);
        
        HRESULT ( __stdcall __RPC_FAR *DefineFuncAsDllEntry )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName);
        
        HRESULT ( __stdcall __RPC_FAR *SetFuncDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( __stdcall __RPC_FAR *SetVarDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( __stdcall __RPC_FAR *SetFuncHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetVarHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetMops )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops);
        
        HRESULT ( __stdcall __RPC_FAR *SetTypeIdldesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ IDLDESC __RPC_FAR *pidldesc);
        
        HRESULT ( __stdcall __RPC_FAR *LayOut )( 
            ICreateTypeInfo __RPC_FAR * This);
        
    } ICreateTypeInfoVtbl;

    interface ICreateTypeInfo
    {
        CONST_VTBL struct ICreateTypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeInfo_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeInfo_SetTypeFlags(This,uTypeFlags)	\
    (This)->lpVtbl -> SetTypeFlags(This,uTypeFlags)

#define ICreateTypeInfo_SetDocString(This,lpstrDoc)	\
    (This)->lpVtbl -> SetDocString(This,lpstrDoc)

#define ICreateTypeInfo_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeInfo_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeInfo_AddRefTypeInfo(This,ptinfo,phreftype)	\
    (This)->lpVtbl -> AddRefTypeInfo(This,ptinfo,phreftype)

#define ICreateTypeInfo_AddFuncDesc(This,index,pfuncdesc)	\
    (This)->lpVtbl -> AddFuncDesc(This,index,pfuncdesc)

#define ICreateTypeInfo_AddImplType(This,index,hreftype)	\
    (This)->lpVtbl -> AddImplType(This,index,hreftype)

#define ICreateTypeInfo_SetImplTypeFlags(This,index,impltypeflags)	\
    (This)->lpVtbl -> SetImplTypeFlags(This,index,impltypeflags)

#define ICreateTypeInfo_SetAlignment(This,cbAlignment)	\
    (This)->lpVtbl -> SetAlignment(This,cbAlignment)

#define ICreateTypeInfo_SetSchema(This,lpstrSchema)	\
    (This)->lpVtbl -> SetSchema(This,lpstrSchema)

#define ICreateTypeInfo_AddVarDesc(This,index,pvardesc)	\
    (This)->lpVtbl -> AddVarDesc(This,index,pvardesc)

#define ICreateTypeInfo_SetFuncAndParamNames(This,index,rgszNames,cNames)	\
    (This)->lpVtbl -> SetFuncAndParamNames(This,index,rgszNames,cNames)

#define ICreateTypeInfo_SetVarName(This,index,szName)	\
    (This)->lpVtbl -> SetVarName(This,index,szName)

#define ICreateTypeInfo_SetTypeDescAlias(This,ptdescAlias)	\
    (This)->lpVtbl -> SetTypeDescAlias(This,ptdescAlias)

#define ICreateTypeInfo_DefineFuncAsDllEntry(This,index,szDllName,szProcName)	\
    (This)->lpVtbl -> DefineFuncAsDllEntry(This,index,szDllName,szProcName)

#define ICreateTypeInfo_SetFuncDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetFuncDocString(This,index,szDocString)

#define ICreateTypeInfo_SetVarDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetVarDocString(This,index,szDocString)

#define ICreateTypeInfo_SetFuncHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetFuncHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo_SetVarHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetVarHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo_SetMops(This,index,bstrMops)	\
    (This)->lpVtbl -> SetMops(This,index,bstrMops)

#define ICreateTypeInfo_SetTypeIdldesc(This,pidldesc)	\
    (This)->lpVtbl -> SetTypeIdldesc(This,pidldesc)

#define ICreateTypeInfo_LayOut(This)	\
    (This)->lpVtbl -> LayOut(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICreateTypeInfo_SetGuid_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB ICreateTypeInfo_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeFlags_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT uTypeFlags);


void __RPC_STUB ICreateTypeInfo_SetTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR lpstrDoc);


void __RPC_STUB ICreateTypeInfo_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVersion_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void __RPC_STUB ICreateTypeInfo_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddRefTypeInfo_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ ITypeInfo __RPC_FAR *ptinfo,
    /* [in] */ HREFTYPE __RPC_FAR *phreftype);


void __RPC_STUB ICreateTypeInfo_AddRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddFuncDesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);


void __RPC_STUB ICreateTypeInfo_AddFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddImplType_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ HREFTYPE hreftype);


void __RPC_STUB ICreateTypeInfo_AddImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetImplTypeFlags_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ INT impltypeflags);


void __RPC_STUB ICreateTypeInfo_SetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetAlignment_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ WORD cbAlignment);


void __RPC_STUB ICreateTypeInfo_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetSchema_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR lpstrSchema);


void __RPC_STUB ICreateTypeInfo_SetSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddVarDesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ VARDESC __RPC_FAR *pvardesc);


void __RPC_STUB ICreateTypeInfo_AddVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncAndParamNames_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames);


void __RPC_STUB ICreateTypeInfo_SetFuncAndParamNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarName_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szName);


void __RPC_STUB ICreateTypeInfo_SetVarName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeDescAlias_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ TYPEDESC __RPC_FAR *ptdescAlias);


void __RPC_STUB ICreateTypeInfo_SetTypeDescAlias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_DefineFuncAsDllEntry_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDllName,
    /* [in] */ LPOLESTR szProcName);


void __RPC_STUB ICreateTypeInfo_DefineFuncAsDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void __RPC_STUB ICreateTypeInfo_SetFuncDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void __RPC_STUB ICreateTypeInfo_SetVarDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetFuncHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetVarHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetMops_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ BSTR bstrMops);


void __RPC_STUB ICreateTypeInfo_SetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeIdldesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ IDLDESC __RPC_FAR *pidldesc);


void __RPC_STUB ICreateTypeInfo_SetTypeIdldesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_LayOut_Proxy( 
    ICreateTypeInfo __RPC_FAR * This);


void __RPC_STUB ICreateTypeInfo_LayOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeInfo_INTERFACE_DEFINED__ */


#ifndef __ICreateTypeLib_INTERFACE_DEFINED__
#define __ICreateTypeLib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateTypeLib
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICreateTypeLib __RPC_FAR *LPCREATETYPELIB;


EXTERN_C const IID IID_ICreateTypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateTypeLib : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateTypeInfo( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *lplpictinfo) = 0;
        
        virtual HRESULT __stdcall SetName( 
            LPOLESTR szName) = 0;
        
        virtual HRESULT __stdcall SetVersion( 
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum) = 0;
        
        virtual HRESULT __stdcall SetGuid( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual HRESULT __stdcall SetDocString( 
            /* [in] */ LPOLESTR szDoc) = 0;
        
        virtual HRESULT __stdcall SetHelpFileName( 
            /* [in] */ LPOLESTR szHelpFileName) = 0;
        
        virtual HRESULT __stdcall SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetLcid( 
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT __stdcall SetLibFlags( 
            /* [in] */ UINT uLibFlags) = 0;
        
        virtual HRESULT __stdcall SaveAllChanges( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeLibVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICreateTypeLib __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICreateTypeLib __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *CreateTypeInfo )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *lplpictinfo);
        
        HRESULT ( __stdcall __RPC_FAR *SetName )( 
            ICreateTypeLib __RPC_FAR * This,
            LPOLESTR szName);
        
        HRESULT ( __stdcall __RPC_FAR *SetVersion )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( __stdcall __RPC_FAR *SetGuid )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( __stdcall __RPC_FAR *SetDocString )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szDoc);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpFileName )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szHelpFileName);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpContext )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetLcid )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( __stdcall __RPC_FAR *SetLibFlags )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ UINT uLibFlags);
        
        HRESULT ( __stdcall __RPC_FAR *SaveAllChanges )( 
            ICreateTypeLib __RPC_FAR * This);
        
    } ICreateTypeLibVtbl;

    interface ICreateTypeLib
    {
        CONST_VTBL struct ICreateTypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeLib_CreateTypeInfo(This,szName,tkind,lplpictinfo)	\
    (This)->lpVtbl -> CreateTypeInfo(This,szName,tkind,lplpictinfo)

#define ICreateTypeLib_SetName(This,szName)	\
    (This)->lpVtbl -> SetName(This,szName)

#define ICreateTypeLib_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeLib_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeLib_SetDocString(This,szDoc)	\
    (This)->lpVtbl -> SetDocString(This,szDoc)

#define ICreateTypeLib_SetHelpFileName(This,szHelpFileName)	\
    (This)->lpVtbl -> SetHelpFileName(This,szHelpFileName)

#define ICreateTypeLib_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeLib_SetLcid(This,lcid)	\
    (This)->lpVtbl -> SetLcid(This,lcid)

#define ICreateTypeLib_SetLibFlags(This,uLibFlags)	\
    (This)->lpVtbl -> SetLibFlags(This,uLibFlags)

#define ICreateTypeLib_SaveAllChanges(This)	\
    (This)->lpVtbl -> SaveAllChanges(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICreateTypeLib_CreateTypeInfo_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ TYPEKIND tkind,
    /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *lplpictinfo);


void __RPC_STUB ICreateTypeLib_CreateTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetName_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    LPOLESTR szName);


void __RPC_STUB ICreateTypeLib_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetVersion_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void __RPC_STUB ICreateTypeLib_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetGuid_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB ICreateTypeLib_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetDocString_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szDoc);


void __RPC_STUB ICreateTypeLib_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetHelpFileName_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szHelpFileName);


void __RPC_STUB ICreateTypeLib_SetHelpFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetHelpContext_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeLib_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetLcid_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LCID lcid);


void __RPC_STUB ICreateTypeLib_SetLcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetLibFlags_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ UINT uLibFlags);


void __RPC_STUB ICreateTypeLib_SetLibFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SaveAllChanges_Proxy( 
    ICreateTypeLib __RPC_FAR * This);


void __RPC_STUB ICreateTypeLib_SaveAllChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeLib_INTERFACE_DEFINED__ */


#ifndef __IDispatch_INTERFACE_DEFINED__
#define __IDispatch_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDispatch
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IDispatch __RPC_FAR *LPDISPATCH;

/* DISPID reserved to indicate an "unknown" name */
/* only reserved for data members (properties); reused as a method dispid below */
			/* size is 4 */
#define	DISPID_UNKNOWN	( -1 )

/* DISPID reserved for the "value" property */
			/* size is 4 */
#define	DISPID_VALUE	( 0 )

/* The following DISPID is reserved to indicate the param
 * that is the right-hand-side (or "put" value) of a PropertyPut
 */
			/* size is 4 */
#define	DISPID_PROPERTYPUT	( -3 )

/* DISPID reserved for the standard "NewEnum" method */
			/* size is 4 */
#define	DISPID_NEWENUM	( -4 )

/* DISPID reserved for the standard "Evaluate" method */
			/* size is 4 */
#define	DISPID_EVALUATE	( -5 )

			/* size is 4 */
#define	DISPID_CONSTRUCTOR	( -6 )

			/* size is 4 */
#define	DISPID_DESTRUCTOR	( -7 )

			/* size is 4 */
#define	DISPID_COLLECT	( -8 )

/* The range -500 through -999 is reserved for Controls */
/* The range 0x80010000 through 0x8001FFFF is reserved for Controls */
/* The remainder of the negative DISPIDs are reserved for future use */

EXTERN_C const IID IID_IDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDispatch : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetTypeInfoCount( 
            /* [out] */ UINT __RPC_FAR *pctinfo) = 0;
        
        virtual HRESULT __stdcall GetTypeInfo( 
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo) = 0;
        
        virtual HRESULT __stdcall GetIDsOfNames( 
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid) = 0;
        
        virtual HRESULT __stdcall Invoke( 
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispatchVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDispatch __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDispatch __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfoCount )( 
            IDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfo )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetIDsOfNames )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( __stdcall __RPC_FAR *Invoke )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
    } IDispatchVtbl;

    interface IDispatch
    {
        CONST_VTBL struct IDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDispatch_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IDispatch_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IDispatch_GetTypeInfoCount_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pctinfo);


void __RPC_STUB IDispatch_GetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_GetTypeInfo_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ UINT itinfo,
    /* [in] */ LCID lcid,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);


void __RPC_STUB IDispatch_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_GetIDsOfNames_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);


void __RPC_STUB IDispatch_GetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_Invoke_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ DISPID dispidMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
    /* [out] */ UINT __RPC_FAR *puArgErr);


void __RPC_STUB IDispatch_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispatch_INTERFACE_DEFINED__ */


#ifndef __IEnumVARIANT_INTERFACE_DEFINED__
#define __IEnumVARIANT_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumVARIANT
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumVARIANT __RPC_FAR *LPENUMVARIANT;


EXTERN_C const IID IID_IEnumVARIANT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumVARIANT : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ unsigned long celt,
            /* [out] */ VARIANT __RPC_FAR *rgvar,
            /* [out] */ unsigned long __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ unsigned long celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumVARIANTVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumVARIANT __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumVARIANT __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ unsigned long celt,
            /* [out] */ VARIANT __RPC_FAR *rgvar,
            /* [out] */ unsigned long __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumVARIANT __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumVARIANTVtbl;

    interface IEnumVARIANT
    {
        CONST_VTBL struct IEnumVARIANTVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumVARIANT_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumVARIANT_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumVARIANT_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumVARIANT_Next(This,celt,rgvar,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgvar,pceltFetched)

#define IEnumVARIANT_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumVARIANT_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumVARIANT_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumVARIANT_Next_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ unsigned long celt,
    /* [out] */ VARIANT __RPC_FAR *rgvar,
    /* [out] */ unsigned long __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumVARIANT_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Skip_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ unsigned long celt);


void __RPC_STUB IEnumVARIANT_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Reset_Proxy( 
    IEnumVARIANT __RPC_FAR * This);


void __RPC_STUB IEnumVARIANT_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Clone_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumVARIANT_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumVARIANT_INTERFACE_DEFINED__ */


#ifndef __ITypeComp_INTERFACE_DEFINED__
#define __ITypeComp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITypeComp
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ITypeComp __RPC_FAR *LPTYPECOMP;

			/* size is 2 */
typedef /* [v1_enum] */ 
enum tagDESCKIND
    {	DESCKIND_NONE	= 0,
	DESCKIND_FUNCDESC	= DESCKIND_NONE + 1,
	DESCKIND_VARDESC	= DESCKIND_FUNCDESC + 1,
	DESCKIND_TYPECOMP	= DESCKIND_VARDESC + 1,
	DESCKIND_IMPLICITAPPOBJ	= DESCKIND_TYPECOMP + 1,
	DESCKIND_MAX	= DESCKIND_IMPLICITAPPOBJ + 1
    }	DESCKIND;

#define DESCKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define DESCKIND_from_xmit(pLong, pEnum) *(pEnum) = (DESCKIND) *(pLong)
#define DESCKIND_free_inst(pEnum) 
#define DESCKIND_free_xmit(pLong) 
			/* size is 4 */
/* [switch_type] */ union tagBINDPTR
    {
    /* [case] */ FUNCDESC __RPC_FAR *lpfuncdesc;
    /* [case] */ VARDESC __RPC_FAR *lpvardesc;
    /* [case][unique] */ ITypeComp __RPC_FAR *lptcomp;
    /* [default] */  /* Empty union arm */ 
    };
			/* size is 4 */
typedef union tagBINDPTR BINDPTR;

			/* size is 4 */
typedef BINDPTR __RPC_FAR *LPBINDPTR;


EXTERN_C const IID IID_ITypeComp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITypeComp : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Bind( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [in] */ WORD fFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ DESCKIND __RPC_FAR *pdesckind,
            /* [switch_is][out] */ BINDPTR __RPC_FAR *pbindptr) = 0;
        
        virtual HRESULT __stdcall BindType( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeCompVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITypeComp __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITypeComp __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Bind )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [in] */ WORD fFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ DESCKIND __RPC_FAR *pdesckind,
            /* [switch_is][out] */ BINDPTR __RPC_FAR *pbindptr);
        
        HRESULT ( __stdcall __RPC_FAR *BindType )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);
        
    } ITypeCompVtbl;

    interface ITypeComp
    {
        CONST_VTBL struct ITypeCompVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeComp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeComp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeComp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeComp_Bind(This,szName,lHashVal,fFlags,pptinfo,pdesckind,pbindptr)	\
    (This)->lpVtbl -> Bind(This,szName,lHashVal,fFlags,pptinfo,pdesckind,pbindptr)

#define ITypeComp_BindType(This,szName,lHashVal,pptinfo,pptcomp)	\
    (This)->lpVtbl -> BindType(This,szName,lHashVal,pptinfo,pptcomp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITypeComp_Bind_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [in] */ WORD fFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
    /* [out] */ DESCKIND __RPC_FAR *pdesckind,
    /* [switch_is][out] */ BINDPTR __RPC_FAR *pbindptr);


void __RPC_STUB ITypeComp_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeComp_BindType_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);


void __RPC_STUB ITypeComp_BindType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeComp_INTERFACE_DEFINED__ */


#ifndef __ITypeInfo_INTERFACE_DEFINED__
#define __ITypeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITypeInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ITypeInfo __RPC_FAR *LPTYPEINFO;


EXTERN_C const IID IID_ITypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITypeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetTypeAttr( 
            /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *pptypeattr) = 0;
        
        virtual HRESULT __stdcall GetTypeComp( 
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp) = 0;
        
        virtual HRESULT __stdcall GetFuncDesc( 
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *pppfuncdesc) = 0;
        
        virtual HRESULT __stdcall GetVarDesc( 
            /* [in] */ UINT index,
            /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppvardesc) = 0;
        
        virtual HRESULT __stdcall GetNames( 
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgbstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT __RPC_FAR *pcNames) = 0;
        
        virtual HRESULT __stdcall GetRefTypeOfImplType( 
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE __RPC_FAR *hpreftype) = 0;
        
        virtual HRESULT __stdcall GetImplTypeFlags( 
            /* [in] */ UINT index,
            /* [out] */ INT __RPC_FAR *pimpltypeflags) = 0;
        
        virtual HRESULT __stdcall GetIDsOfNames( 
            /* [size_is][in] */ OLECHAR __RPC_FAR *__RPC_FAR *rglpszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID __RPC_FAR *rgmemid) = 0;
        
        virtual HRESULT __stdcall Invoke( 
            /* [unique][in] */ void __RPC_FAR *pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr) = 0;
        
        virtual HRESULT __stdcall GetDocumentation( 
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile) = 0;
        
        virtual HRESULT __stdcall GetDllEntry( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ BSTR __RPC_FAR *pbstrDllName,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ WORD __RPC_FAR *pwOrdinal) = 0;
        
        virtual HRESULT __stdcall GetRefTypeInfo( 
            /* [in] */ HREFTYPE hreftype,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo) = 0;
        
        virtual HRESULT __stdcall AddressOfMember( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT __stdcall CreateInstance( 
            /* [in] */ IUnknown __RPC_FAR *puncOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
        virtual HRESULT __stdcall GetMops( 
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrMops) = 0;
        
        virtual HRESULT __stdcall GetContainingTypeLib( 
            /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *pptlib,
            /* [out] */ UINT __RPC_FAR *pindex) = 0;
        
        virtual void __stdcall ReleaseTypeAttr( 
            /* [in] */ TYPEATTR __RPC_FAR *ptypeattr) = 0;
        
        virtual void __stdcall ReleaseFuncDesc( 
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc) = 0;
        
        virtual void __stdcall ReleaseVarDesc( 
            /* [in] */ VARDESC __RPC_FAR *pvardesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITypeInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITypeInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeAttr )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *pptypeattr);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeComp )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);
        
        HRESULT ( __stdcall __RPC_FAR *GetFuncDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *pppfuncdesc);
        
        HRESULT ( __stdcall __RPC_FAR *GetVarDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppvardesc);
        
        HRESULT ( __stdcall __RPC_FAR *GetNames )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgbstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT __RPC_FAR *pcNames);
        
        HRESULT ( __stdcall __RPC_FAR *GetRefTypeOfImplType )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE __RPC_FAR *hpreftype);
        
        HRESULT ( __stdcall __RPC_FAR *GetImplTypeFlags )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ INT __RPC_FAR *pimpltypeflags);
        
        HRESULT ( __stdcall __RPC_FAR *GetIDsOfNames )( 
            ITypeInfo __RPC_FAR * This,
            /* [size_is][in] */ OLECHAR __RPC_FAR *__RPC_FAR *rglpszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID __RPC_FAR *rgmemid);
        
        HRESULT ( __stdcall __RPC_FAR *Invoke )( 
            ITypeInfo __RPC_FAR * This,
            /* [unique][in] */ void __RPC_FAR *pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( __stdcall __RPC_FAR *GetDocumentation )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *GetDllEntry )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ BSTR __RPC_FAR *pbstrDllName,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ WORD __RPC_FAR *pwOrdinal);
        
        HRESULT ( __stdcall __RPC_FAR *GetRefTypeInfo )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ HREFTYPE hreftype,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( __stdcall __RPC_FAR *AddressOfMember )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( __stdcall __RPC_FAR *CreateInstance )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *puncOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        HRESULT ( __stdcall __RPC_FAR *GetMops )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrMops);
        
        HRESULT ( __stdcall __RPC_FAR *GetContainingTypeLib )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *pptlib,
            /* [out] */ UINT __RPC_FAR *pindex);
        
        void ( __stdcall __RPC_FAR *ReleaseTypeAttr )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ TYPEATTR __RPC_FAR *ptypeattr);
        
        void ( __stdcall __RPC_FAR *ReleaseFuncDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);
        
        void ( __stdcall __RPC_FAR *ReleaseVarDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ VARDESC __RPC_FAR *pvardesc);
        
    } ITypeInfoVtbl;

    interface ITypeInfo
    {
        CONST_VTBL struct ITypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeInfo_GetTypeAttr(This,pptypeattr)	\
    (This)->lpVtbl -> GetTypeAttr(This,pptypeattr)

#define ITypeInfo_GetTypeComp(This,pptcomp)	\
    (This)->lpVtbl -> GetTypeComp(This,pptcomp)

#define ITypeInfo_GetFuncDesc(This,index,pppfuncdesc)	\
    (This)->lpVtbl -> GetFuncDesc(This,index,pppfuncdesc)

#define ITypeInfo_GetVarDesc(This,index,ppvardesc)	\
    (This)->lpVtbl -> GetVarDesc(This,index,ppvardesc)

#define ITypeInfo_GetNames(This,memid,rgbstrNames,cMaxNames,pcNames)	\
    (This)->lpVtbl -> GetNames(This,memid,rgbstrNames,cMaxNames,pcNames)

#define ITypeInfo_GetRefTypeOfImplType(This,index,hpreftype)	\
    (This)->lpVtbl -> GetRefTypeOfImplType(This,index,hpreftype)

#define ITypeInfo_GetImplTypeFlags(This,index,pimpltypeflags)	\
    (This)->lpVtbl -> GetImplTypeFlags(This,index,pimpltypeflags)

#define ITypeInfo_GetIDsOfNames(This,rglpszNames,cNames,rgmemid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,rglpszNames,cNames,rgmemid)

#define ITypeInfo_Invoke(This,pvInstance,memid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,pvInstance,memid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)

#define ITypeInfo_GetDocumentation(This,memid,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,memid,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)

#define ITypeInfo_GetDllEntry(This,memid,invkind,pbstrDllName,pbstrName,pwOrdinal)	\
    (This)->lpVtbl -> GetDllEntry(This,memid,invkind,pbstrDllName,pbstrName,pwOrdinal)

#define ITypeInfo_GetRefTypeInfo(This,hreftype,pptinfo)	\
    (This)->lpVtbl -> GetRefTypeInfo(This,hreftype,pptinfo)

#define ITypeInfo_AddressOfMember(This,memid,invkind,ppv)	\
    (This)->lpVtbl -> AddressOfMember(This,memid,invkind,ppv)

#define ITypeInfo_CreateInstance(This,puncOuter,riid,ppvObj)	\
    (This)->lpVtbl -> CreateInstance(This,puncOuter,riid,ppvObj)

#define ITypeInfo_GetMops(This,memid,pbstrMops)	\
    (This)->lpVtbl -> GetMops(This,memid,pbstrMops)

#define ITypeInfo_GetContainingTypeLib(This,pptlib,pindex)	\
    (This)->lpVtbl -> GetContainingTypeLib(This,pptlib,pindex)

#define ITypeInfo_ReleaseTypeAttr(This,ptypeattr)	\
    (This)->lpVtbl -> ReleaseTypeAttr(This,ptypeattr)

#define ITypeInfo_ReleaseFuncDesc(This,pfuncdesc)	\
    (This)->lpVtbl -> ReleaseFuncDesc(This,pfuncdesc)

#define ITypeInfo_ReleaseVarDesc(This,pvardesc)	\
    (This)->lpVtbl -> ReleaseVarDesc(This,pvardesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITypeInfo_GetTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *pptypeattr);


void __RPC_STUB ITypeInfo_GetTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetTypeComp_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);


void __RPC_STUB ITypeInfo_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *pppfuncdesc);


void __RPC_STUB ITypeInfo_GetFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppvardesc);


void __RPC_STUB ITypeInfo_GetVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetNames_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgbstrNames,
    /* [in] */ UINT cMaxNames,
    /* [out] */ UINT __RPC_FAR *pcNames);


void __RPC_STUB ITypeInfo_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetRefTypeOfImplType_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ HREFTYPE __RPC_FAR *hpreftype);


void __RPC_STUB ITypeInfo_GetRefTypeOfImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetImplTypeFlags_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ INT __RPC_FAR *pimpltypeflags);


void __RPC_STUB ITypeInfo_GetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetIDsOfNames_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [size_is][in] */ OLECHAR __RPC_FAR *__RPC_FAR *rglpszNames,
    /* [in] */ UINT cNames,
    /* [size_is][out] */ MEMBERID __RPC_FAR *rgmemid);


void __RPC_STUB ITypeInfo_GetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_Invoke_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [unique][in] */ void __RPC_FAR *pvInstance,
    /* [in] */ MEMBERID memid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdispparams,
    /* [out] */ VARIANT __RPC_FAR *pvarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
    /* [out] */ UINT __RPC_FAR *puArgErr);


void __RPC_STUB ITypeInfo_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetDocumentation_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);


void __RPC_STUB ITypeInfo_GetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetDllEntry_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invkind,
    /* [out] */ BSTR __RPC_FAR *pbstrDllName,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ WORD __RPC_FAR *pwOrdinal);


void __RPC_STUB ITypeInfo_GetDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetRefTypeInfo_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ HREFTYPE hreftype,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);


void __RPC_STUB ITypeInfo_GetRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_AddressOfMember_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invkind,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ITypeInfo_AddressOfMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_CreateInstance_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *puncOuter,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB ITypeInfo_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetMops_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR __RPC_FAR *pbstrMops);


void __RPC_STUB ITypeInfo_GetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetContainingTypeLib_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *pptlib,
    /* [out] */ UINT __RPC_FAR *pindex);


void __RPC_STUB ITypeInfo_GetContainingTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ TYPEATTR __RPC_FAR *ptypeattr);


void __RPC_STUB ITypeInfo_ReleaseTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);


void __RPC_STUB ITypeInfo_ReleaseFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ VARDESC __RPC_FAR *pvardesc);


void __RPC_STUB ITypeInfo_ReleaseVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeInfo_INTERFACE_DEFINED__ */


#ifndef __ITypeLib_INTERFACE_DEFINED__
#define __ITypeLib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITypeLib
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 2 */
typedef /* [transmit] */ 
enum tagSYSKIND
    {	SYS_WIN16	= 0,
	SYS_WIN32	= SYS_WIN16 + 1,
	SYS_MAC	= SYS_WIN32 + 1
    }	SYSKIND;

			/* size is 2 */
typedef /* [transmit] */ 
enum tagLIBFLAGS
    {	LIBFLAG_FRESTRICTED	= 0x1,
	LIBFLAG_FCONTROL	= 0x2,
	LIBFLAG_FHIDDEN	= 0x4
    }	LIBFLAGS;

#define SYSKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define SYSKIND_from_xmit(pLong, pEnum) *(pEnum) = (SYSKIND) *(pLong)
#define SYSKIND_free_inst(pEnum) 
#define SYSKIND_free_xmit(pLong) 
			/* size is 4 */
typedef /* [unique] */ ITypeLib __RPC_FAR *LPTYPELIB;

			/* size is 28 */
typedef struct  tagTLIBATTR
    {
    GUID guid;
    LCID lcid;
    SYSKIND syskind;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    WORD wLibFlags;
    }	TLIBATTR;

			/* size is 4 */
typedef TLIBATTR __RPC_FAR *LPTLIBATTR;


EXTERN_C const IID IID_ITypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITypeLib : public IUnknown
    {
    public:
        virtual UINT __stdcall GetTypeInfoCount( void) = 0;
        
        virtual HRESULT __stdcall GetTypeInfo( 
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppitinfo) = 0;
        
        virtual HRESULT __stdcall GetTypeInfoType( 
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND __RPC_FAR *ptkind) = 0;
        
        virtual HRESULT __stdcall GetTypeInfoOfGuid( 
            /* [in] */ REFGUID guid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo) = 0;
        
        virtual HRESULT __stdcall GetLibAttr( 
            /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *pptlibattr) = 0;
        
        virtual HRESULT __stdcall GetTypeComp( 
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp) = 0;
        
        virtual HRESULT __stdcall GetDocumentation( 
            /* [in] */ INT index,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile) = 0;
        
        virtual HRESULT __stdcall IsName( 
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL __RPC_FAR *pfName) = 0;
        
        virtual HRESULT __stdcall FindName( 
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *rgptinfo,
            /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgmemid,
            /* [out][in] */ USHORT __RPC_FAR *pcFound) = 0;
        
        virtual void __stdcall ReleaseTLibAttr( 
            /* [in] */ TLIBATTR __RPC_FAR *ptlibattr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeLibVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITypeLib __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITypeLib __RPC_FAR * This);
        
        UINT ( __stdcall __RPC_FAR *GetTypeInfoCount )( 
            ITypeLib __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfo )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppitinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfoType )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND __RPC_FAR *ptkind);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfoOfGuid )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetLibAttr )( 
            ITypeLib __RPC_FAR * This,
            /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *pptlibattr);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeComp )( 
            ITypeLib __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);
        
        HRESULT ( __stdcall __RPC_FAR *GetDocumentation )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ INT index,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *IsName )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL __RPC_FAR *pfName);
        
        HRESULT ( __stdcall __RPC_FAR *FindName )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *rgptinfo,
            /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgmemid,
            /* [out][in] */ USHORT __RPC_FAR *pcFound);
        
        void ( __stdcall __RPC_FAR *ReleaseTLibAttr )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ TLIBATTR __RPC_FAR *ptlibattr);
        
    } ITypeLibVtbl;

    interface ITypeLib
    {
        CONST_VTBL struct ITypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeLib_GetTypeInfoCount(This)	\
    (This)->lpVtbl -> GetTypeInfoCount(This)

#define ITypeLib_GetTypeInfo(This,index,ppitinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,index,ppitinfo)

#define ITypeLib_GetTypeInfoType(This,index,ptkind)	\
    (This)->lpVtbl -> GetTypeInfoType(This,index,ptkind)

#define ITypeLib_GetTypeInfoOfGuid(This,guid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfoOfGuid(This,guid,pptinfo)

#define ITypeLib_GetLibAttr(This,pptlibattr)	\
    (This)->lpVtbl -> GetLibAttr(This,pptlibattr)

#define ITypeLib_GetTypeComp(This,pptcomp)	\
    (This)->lpVtbl -> GetTypeComp(This,pptcomp)

#define ITypeLib_GetDocumentation(This,index,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,index,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)

#define ITypeLib_IsName(This,szNameBuf,lHashVal,pfName)	\
    (This)->lpVtbl -> IsName(This,szNameBuf,lHashVal,pfName)

#define ITypeLib_FindName(This,szNameBuf,lHashVal,rgptinfo,rgmemid,pcFound)	\
    (This)->lpVtbl -> FindName(This,szNameBuf,lHashVal,rgptinfo,rgmemid,pcFound)

#define ITypeLib_ReleaseTLibAttr(This,ptlibattr)	\
    (This)->lpVtbl -> ReleaseTLibAttr(This,ptlibattr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



UINT __stdcall ITypeLib_GetTypeInfoCount_Proxy( 
    ITypeLib __RPC_FAR * This);


void __RPC_STUB ITypeLib_GetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfo_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppitinfo);


void __RPC_STUB ITypeLib_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfoType_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ TYPEKIND __RPC_FAR *ptkind);


void __RPC_STUB ITypeLib_GetTypeInfoType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfoOfGuid_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);


void __RPC_STUB ITypeLib_GetTypeInfoOfGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *pptlibattr);


void __RPC_STUB ITypeLib_GetLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeComp_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);


void __RPC_STUB ITypeLib_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetDocumentation_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ INT index,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);


void __RPC_STUB ITypeLib_GetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_IsName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [out] */ BOOL __RPC_FAR *pfName);


void __RPC_STUB ITypeLib_IsName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_FindName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *rgptinfo,
    /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgmemid,
    /* [out][in] */ USHORT __RPC_FAR *pcFound);


void __RPC_STUB ITypeLib_FindName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeLib_ReleaseTLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ TLIBATTR __RPC_FAR *ptlibattr);


void __RPC_STUB ITypeLib_ReleaseTLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeLib_INTERFACE_DEFINED__ */


#ifndef __IErrorInfo_INTERFACE_DEFINED__
#define __IErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IErrorInfo __RPC_FAR *LPERRORINFO;


EXTERN_C const IID IID_IErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetGUID( 
            /* [out] */ GUID __RPC_FAR *pguid) = 0;
        
        virtual HRESULT __stdcall GetSource( 
            /* [out] */ BSTR __RPC_FAR *pbstrSource) = 0;
        
        virtual HRESULT __stdcall GetDescription( 
            /* [out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual HRESULT __stdcall GetHelpFile( 
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile) = 0;
        
        virtual HRESULT __stdcall GetHelpContext( 
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IErrorInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IErrorInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IErrorInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguid);
        
        HRESULT ( __stdcall __RPC_FAR *GetSource )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrSource);
        
        HRESULT ( __stdcall __RPC_FAR *GetDescription )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription);
        
        HRESULT ( __stdcall __RPC_FAR *GetHelpFile )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *GetHelpContext )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext);
        
    } IErrorInfoVtbl;

    interface IErrorInfo
    {
        CONST_VTBL struct IErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IErrorInfo_GetGUID(This,pguid)	\
    (This)->lpVtbl -> GetGUID(This,pguid)

#define IErrorInfo_GetSource(This,pbstrSource)	\
    (This)->lpVtbl -> GetSource(This,pbstrSource)

#define IErrorInfo_GetDescription(This,pbstrDescription)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDescription)

#define IErrorInfo_GetHelpFile(This,pbstrHelpFile)	\
    (This)->lpVtbl -> GetHelpFile(This,pbstrHelpFile)

#define IErrorInfo_GetHelpContext(This,pdwHelpContext)	\
    (This)->lpVtbl -> GetHelpContext(This,pdwHelpContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IErrorInfo_GetGUID_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguid);


void __RPC_STUB IErrorInfo_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetSource_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrSource);


void __RPC_STUB IErrorInfo_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetDescription_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IErrorInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetHelpFile_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);


void __RPC_STUB IErrorInfo_GetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetHelpContext_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext);


void __RPC_STUB IErrorInfo_GetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ICreateErrorInfo_INTERFACE_DEFINED__
#define __ICreateErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICreateErrorInfo __RPC_FAR *LPCREATEERRORINFO;


EXTERN_C const IID IID_ICreateErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetGUID( 
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT __stdcall SetSource( 
            /* [in] */ LPOLESTR szSource) = 0;
        
        virtual HRESULT __stdcall SetDescription( 
            /* [in] */ LPOLESTR szDescription) = 0;
        
        virtual HRESULT __stdcall SetHelpFile( 
            /* [in] */ LPOLESTR szHelpFile) = 0;
        
        virtual HRESULT __stdcall SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateErrorInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICreateErrorInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICreateErrorInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetGUID )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( __stdcall __RPC_FAR *SetSource )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szSource);
        
        HRESULT ( __stdcall __RPC_FAR *SetDescription )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szDescription);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpFile )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpContext )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
    } ICreateErrorInfoVtbl;

    interface ICreateErrorInfo
    {
        CONST_VTBL struct ICreateErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateErrorInfo_SetGUID(This,rguid)	\
    (This)->lpVtbl -> SetGUID(This,rguid)

#define ICreateErrorInfo_SetSource(This,szSource)	\
    (This)->lpVtbl -> SetSource(This,szSource)

#define ICreateErrorInfo_SetDescription(This,szDescription)	\
    (This)->lpVtbl -> SetDescription(This,szDescription)

#define ICreateErrorInfo_SetHelpFile(This,szHelpFile)	\
    (This)->lpVtbl -> SetHelpFile(This,szHelpFile)

#define ICreateErrorInfo_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICreateErrorInfo_SetGUID_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ICreateErrorInfo_SetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetSource_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szSource);


void __RPC_STUB ICreateErrorInfo_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetDescription_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szDescription);


void __RPC_STUB ICreateErrorInfo_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetHelpFile_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szHelpFile);


void __RPC_STUB ICreateErrorInfo_SetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetHelpContext_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateErrorInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ISupportErrorInfo_INTERFACE_DEFINED__
#define __ISupportErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISupportErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ISupportErrorInfo __RPC_FAR *LPSUPPORTERRORINFO;


EXTERN_C const IID IID_ISupportErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISupportErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall InterfaceSupportsErrorInfo( 
            /* [in] */ REFIID riid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupportErrorInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ISupportErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ISupportErrorInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ISupportErrorInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *InterfaceSupportsErrorInfo )( 
            ISupportErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
    } ISupportErrorInfoVtbl;

    interface ISupportErrorInfo
    {
        CONST_VTBL struct ISupportErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupportErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISupportErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISupportErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISupportErrorInfo_InterfaceSupportsErrorInfo(This,riid)	\
    (This)->lpVtbl -> InterfaceSupportsErrorInfo(This,riid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ISupportErrorInfo_InterfaceSupportsErrorInfo_Proxy( 
    ISupportErrorInfo __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB ISupportErrorInfo_InterfaceSupportsErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISupportErrorInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OBJIDL.H ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:32 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objidl_h__
#define __objidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMarshal_FWD_DEFINED__
#define __IMarshal_FWD_DEFINED__
typedef interface IMarshal IMarshal;
#endif 	/* __IMarshal_FWD_DEFINED__ */


#ifndef __IMalloc_FWD_DEFINED__
#define __IMalloc_FWD_DEFINED__
typedef interface IMalloc IMalloc;
#endif 	/* __IMalloc_FWD_DEFINED__ */


#ifndef __IMallocSpy_FWD_DEFINED__
#define __IMallocSpy_FWD_DEFINED__
typedef interface IMallocSpy IMallocSpy;
#endif 	/* __IMallocSpy_FWD_DEFINED__ */


#ifndef __IStdMarshalInfo_FWD_DEFINED__
#define __IStdMarshalInfo_FWD_DEFINED__
typedef interface IStdMarshalInfo IStdMarshalInfo;
#endif 	/* __IStdMarshalInfo_FWD_DEFINED__ */


#ifndef __IExternalConnection_FWD_DEFINED__
#define __IExternalConnection_FWD_DEFINED__
typedef interface IExternalConnection IExternalConnection;
#endif 	/* __IExternalConnection_FWD_DEFINED__ */


#ifndef __IEnumUnknown_FWD_DEFINED__
#define __IEnumUnknown_FWD_DEFINED__
typedef interface IEnumUnknown IEnumUnknown;
#endif 	/* __IEnumUnknown_FWD_DEFINED__ */


#ifndef __IBindCtx_FWD_DEFINED__
#define __IBindCtx_FWD_DEFINED__
typedef interface IBindCtx IBindCtx;
#endif 	/* __IBindCtx_FWD_DEFINED__ */


#ifndef __IEnumMoniker_FWD_DEFINED__
#define __IEnumMoniker_FWD_DEFINED__
typedef interface IEnumMoniker IEnumMoniker;
#endif 	/* __IEnumMoniker_FWD_DEFINED__ */


#ifndef __IRunnableObject_FWD_DEFINED__
#define __IRunnableObject_FWD_DEFINED__
typedef interface IRunnableObject IRunnableObject;
#endif 	/* __IRunnableObject_FWD_DEFINED__ */


#ifndef __IRunningObjectTable_FWD_DEFINED__
#define __IRunningObjectTable_FWD_DEFINED__
typedef interface IRunningObjectTable IRunningObjectTable;
#endif 	/* __IRunningObjectTable_FWD_DEFINED__ */


#ifndef __IPersist_FWD_DEFINED__
#define __IPersist_FWD_DEFINED__
typedef interface IPersist IPersist;
#endif 	/* __IPersist_FWD_DEFINED__ */


#ifndef __IPersistStream_FWD_DEFINED__
#define __IPersistStream_FWD_DEFINED__
typedef interface IPersistStream IPersistStream;
#endif 	/* __IPersistStream_FWD_DEFINED__ */


#ifndef __IMoniker_FWD_DEFINED__
#define __IMoniker_FWD_DEFINED__
typedef interface IMoniker IMoniker;
#endif 	/* __IMoniker_FWD_DEFINED__ */


#ifndef __IROTData_FWD_DEFINED__
#define __IROTData_FWD_DEFINED__
typedef interface IROTData IROTData;
#endif 	/* __IROTData_FWD_DEFINED__ */


#ifndef __IEnumString_FWD_DEFINED__
#define __IEnumString_FWD_DEFINED__
typedef interface IEnumString IEnumString;
#endif 	/* __IEnumString_FWD_DEFINED__ */


#ifndef __IStream_FWD_DEFINED__
#define __IStream_FWD_DEFINED__
typedef interface IStream IStream;
#endif 	/* __IStream_FWD_DEFINED__ */


#ifndef __IEnumSTATSTG_FWD_DEFINED__
#define __IEnumSTATSTG_FWD_DEFINED__
typedef interface IEnumSTATSTG IEnumSTATSTG;
#endif 	/* __IEnumSTATSTG_FWD_DEFINED__ */


#ifndef __IStorage_FWD_DEFINED__
#define __IStorage_FWD_DEFINED__
typedef interface IStorage IStorage;
#endif 	/* __IStorage_FWD_DEFINED__ */


#ifndef __IPersistFile_FWD_DEFINED__
#define __IPersistFile_FWD_DEFINED__
typedef interface IPersistFile IPersistFile;
#endif 	/* __IPersistFile_FWD_DEFINED__ */


#ifndef __IPersistStorage_FWD_DEFINED__
#define __IPersistStorage_FWD_DEFINED__
typedef interface IPersistStorage IPersistStorage;
#endif 	/* __IPersistStorage_FWD_DEFINED__ */


#ifndef __ILockBytes_FWD_DEFINED__
#define __ILockBytes_FWD_DEFINED__
typedef interface ILockBytes ILockBytes;
#endif 	/* __ILockBytes_FWD_DEFINED__ */


#ifndef __IEnumFORMATETC_FWD_DEFINED__
#define __IEnumFORMATETC_FWD_DEFINED__
typedef interface IEnumFORMATETC IEnumFORMATETC;
#endif 	/* __IEnumFORMATETC_FWD_DEFINED__ */


#ifndef __IEnumSTATDATA_FWD_DEFINED__
#define __IEnumSTATDATA_FWD_DEFINED__
typedef interface IEnumSTATDATA IEnumSTATDATA;
#endif 	/* __IEnumSTATDATA_FWD_DEFINED__ */


#ifndef __IRootStorage_FWD_DEFINED__
#define __IRootStorage_FWD_DEFINED__
typedef interface IRootStorage IRootStorage;
#endif 	/* __IRootStorage_FWD_DEFINED__ */


#ifndef __IAdviseSink_FWD_DEFINED__
#define __IAdviseSink_FWD_DEFINED__
typedef interface IAdviseSink IAdviseSink;
#endif 	/* __IAdviseSink_FWD_DEFINED__ */


#ifndef __IAdviseSink2_FWD_DEFINED__
#define __IAdviseSink2_FWD_DEFINED__
typedef interface IAdviseSink2 IAdviseSink2;
#endif 	/* __IAdviseSink2_FWD_DEFINED__ */


#ifndef __IDataObject_FWD_DEFINED__
#define __IDataObject_FWD_DEFINED__
typedef interface IDataObject IDataObject;
#endif 	/* __IDataObject_FWD_DEFINED__ */


#ifndef __IDataAdviseHolder_FWD_DEFINED__
#define __IDataAdviseHolder_FWD_DEFINED__
typedef interface IDataAdviseHolder IDataAdviseHolder;
#endif 	/* __IDataAdviseHolder_FWD_DEFINED__ */


#ifndef __IMessageFilter_FWD_DEFINED__
#define __IMessageFilter_FWD_DEFINED__
typedef interface IMessageFilter IMessageFilter;
#endif 	/* __IMessageFilter_FWD_DEFINED__ */


#ifndef __IRpcChannelBuffer_FWD_DEFINED__
#define __IRpcChannelBuffer_FWD_DEFINED__
typedef interface IRpcChannelBuffer IRpcChannelBuffer;
#endif 	/* __IRpcChannelBuffer_FWD_DEFINED__ */


#ifndef __IRpcProxyBuffer_FWD_DEFINED__
#define __IRpcProxyBuffer_FWD_DEFINED__
typedef interface IRpcProxyBuffer IRpcProxyBuffer;
#endif 	/* __IRpcProxyBuffer_FWD_DEFINED__ */


#ifndef __IRpcStubBuffer_FWD_DEFINED__
#define __IRpcStubBuffer_FWD_DEFINED__
typedef interface IRpcStubBuffer IRpcStubBuffer;
#endif 	/* __IRpcStubBuffer_FWD_DEFINED__ */


#ifndef __IPSFactoryBuffer_FWD_DEFINED__
#define __IPSFactoryBuffer_FWD_DEFINED__
typedef interface IPSFactoryBuffer IPSFactoryBuffer;
#endif 	/* __IPSFactoryBuffer_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMarshal_INTERFACE_DEFINED__
#define __IMarshal_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMarshal
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 4 */
typedef /* [unique] */ IMarshal __RPC_FAR *LPMARSHAL;


EXTERN_C const IID IID_IMarshal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMarshal : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetUnmarshalClass( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID __RPC_FAR *pCid) = 0;
        
        virtual HRESULT __stdcall GetMarshalSizeMax( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize) = 0;
        
        virtual HRESULT __stdcall MarshalInterface( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags) = 0;
        
        virtual HRESULT __stdcall UnmarshalInterface( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT __stdcall ReleaseMarshalData( 
            /* [unique][in] */ IStream __RPC_FAR *pStm) = 0;
        
        virtual HRESULT __stdcall DisconnectObject( 
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMarshal __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMarshal __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetUnmarshalClass )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID __RPC_FAR *pCid);
        
        HRESULT ( __stdcall __RPC_FAR *GetMarshalSizeMax )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize);
        
        HRESULT ( __stdcall __RPC_FAR *MarshalInterface )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        HRESULT ( __stdcall __RPC_FAR *UnmarshalInterface )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( __stdcall __RPC_FAR *ReleaseMarshalData )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        HRESULT ( __stdcall __RPC_FAR *DisconnectObject )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ DWORD dwReserved);
        
    } IMarshalVtbl;

    interface IMarshal
    {
        CONST_VTBL struct IMarshalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshal_GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)	\
    (This)->lpVtbl -> GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)

#define IMarshal_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IMarshal_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#define IMarshal_UnmarshalInterface(This,pStm,riid,ppv)	\
    (This)->lpVtbl -> UnmarshalInterface(This,pStm,riid,ppv)

#define IMarshal_ReleaseMarshalData(This,pStm)	\
    (This)->lpVtbl -> ReleaseMarshalData(This,pStm)

#define IMarshal_DisconnectObject(This,dwReserved)	\
    (This)->lpVtbl -> DisconnectObject(This,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IMarshal_GetUnmarshalClass_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ CLSID __RPC_FAR *pCid);


void __RPC_STUB IMarshal_GetUnmarshalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_GetMarshalSizeMax_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD __RPC_FAR *pSize);


void __RPC_STUB IMarshal_GetMarshalSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_MarshalInterface_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags);


void __RPC_STUB IMarshal_MarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_UnmarshalInterface_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IMarshal_UnmarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_ReleaseMarshalData_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm);


void __RPC_STUB IMarshal_ReleaseMarshalData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_DisconnectObject_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IMarshal_DisconnectObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshal_INTERFACE_DEFINED__ */


#ifndef __IMalloc_INTERFACE_DEFINED__
#define __IMalloc_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMalloc
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IMalloc __RPC_FAR *LPMALLOC;


EXTERN_C const IID IID_IMalloc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMalloc : public IUnknown
    {
    public:
        virtual void __RPC_FAR *__stdcall Alloc( 
            /* [in] */ ULONG cb) = 0;
        
        virtual void __RPC_FAR *__stdcall Realloc( 
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb) = 0;
        
        virtual void __stdcall Free( 
            /* [in] */ void __RPC_FAR *pv) = 0;
        
        virtual ULONG __stdcall GetSize( 
            /* [in] */ void __RPC_FAR *pv) = 0;
        
        virtual int __stdcall DidAlloc( 
            void __RPC_FAR *pv) = 0;
        
        virtual void __stdcall HeapMinimize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMallocVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMalloc __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMalloc __RPC_FAR * This);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *Alloc )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ ULONG cb);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *Realloc )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb);
        
        void ( __stdcall __RPC_FAR *Free )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);
        
        ULONG ( __stdcall __RPC_FAR *GetSize )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);
        
        int ( __stdcall __RPC_FAR *DidAlloc )( 
            IMalloc __RPC_FAR * This,
            void __RPC_FAR *pv);
        
        void ( __stdcall __RPC_FAR *HeapMinimize )( 
            IMalloc __RPC_FAR * This);
        
    } IMallocVtbl;

    interface IMalloc
    {
        CONST_VTBL struct IMallocVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMalloc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMalloc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMalloc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMalloc_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#define IMalloc_Realloc(This,pv,cb)	\
    (This)->lpVtbl -> Realloc(This,pv,cb)

#define IMalloc_Free(This,pv)	\
    (This)->lpVtbl -> Free(This,pv)

#define IMalloc_GetSize(This,pv)	\
    (This)->lpVtbl -> GetSize(This,pv)

#define IMalloc_DidAlloc(This,pv)	\
    (This)->lpVtbl -> DidAlloc(This,pv)

#define IMalloc_HeapMinimize(This)	\
    (This)->lpVtbl -> HeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void __RPC_FAR *__stdcall IMalloc_Alloc_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ ULONG cb);


void __RPC_STUB IMalloc_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMalloc_Realloc_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb);


void __RPC_STUB IMalloc_Realloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMalloc_Free_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv);


void __RPC_STUB IMalloc_Free_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMalloc_GetSize_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv);


void __RPC_STUB IMalloc_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int __stdcall IMalloc_DidAlloc_Proxy( 
    IMalloc __RPC_FAR * This,
    void __RPC_FAR *pv);


void __RPC_STUB IMalloc_DidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMalloc_HeapMinimize_Proxy( 
    IMalloc __RPC_FAR * This);


void __RPC_STUB IMalloc_HeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMalloc_INTERFACE_DEFINED__ */


#ifndef __IMallocSpy_INTERFACE_DEFINED__
#define __IMallocSpy_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMallocSpy
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IMallocSpy __RPC_FAR *LPMALLOCSPY;


EXTERN_C const IID IID_IMallocSpy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMallocSpy : public IUnknown
    {
    public:
        virtual ULONG __stdcall PreAlloc( 
            /* [in] */ ULONG cbRequest) = 0;
        
        virtual void __RPC_FAR *__stdcall PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual) = 0;
        
        virtual void __RPC_FAR *__stdcall PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __stdcall PostFree( 
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual ULONG __stdcall PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *__stdcall PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *__stdcall PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual ULONG __stdcall PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *__stdcall PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual int __stdcall PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual) = 0;
        
        virtual void __stdcall PreHeapMinimize( void) = 0;
        
        virtual void __stdcall PostHeapMinimize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMallocSpyVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMallocSpy __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMallocSpy __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *PreAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ ULONG cbRequest);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PostAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pActual);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PreFree )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        void ( __stdcall __RPC_FAR *PostFree )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( __stdcall __RPC_FAR *PreRealloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PostRealloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PreGetSize )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( __stdcall __RPC_FAR *PostGetSize )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PreDidAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        int ( __stdcall __RPC_FAR *PostDidAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
        void ( __stdcall __RPC_FAR *PreHeapMinimize )( 
            IMallocSpy __RPC_FAR * This);
        
        void ( __stdcall __RPC_FAR *PostHeapMinimize )( 
            IMallocSpy __RPC_FAR * This);
        
    } IMallocSpyVtbl;

    interface IMallocSpy
    {
        CONST_VTBL struct IMallocSpyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMallocSpy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMallocSpy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMallocSpy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMallocSpy_PreAlloc(This,cbRequest)	\
    (This)->lpVtbl -> PreAlloc(This,cbRequest)

#define IMallocSpy_PostAlloc(This,pActual)	\
    (This)->lpVtbl -> PostAlloc(This,pActual)

#define IMallocSpy_PreFree(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreFree(This,pRequest,fSpyed)

#define IMallocSpy_PostFree(This,fSpyed)	\
    (This)->lpVtbl -> PostFree(This,fSpyed)

#define IMallocSpy_PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)	\
    (This)->lpVtbl -> PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)

#define IMallocSpy_PostRealloc(This,pActual,fSpyed)	\
    (This)->lpVtbl -> PostRealloc(This,pActual,fSpyed)

#define IMallocSpy_PreGetSize(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreGetSize(This,pRequest,fSpyed)

#define IMallocSpy_PostGetSize(This,cbActual,fSpyed)	\
    (This)->lpVtbl -> PostGetSize(This,cbActual,fSpyed)

#define IMallocSpy_PreDidAlloc(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreDidAlloc(This,pRequest,fSpyed)

#define IMallocSpy_PostDidAlloc(This,pRequest,fSpyed,fActual)	\
    (This)->lpVtbl -> PostDidAlloc(This,pRequest,fSpyed,fActual)

#define IMallocSpy_PreHeapMinimize(This)	\
    (This)->lpVtbl -> PreHeapMinimize(This)

#define IMallocSpy_PostHeapMinimize(This)	\
    (This)->lpVtbl -> PostHeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG __stdcall IMallocSpy_PreAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ ULONG cbRequest);


void __RPC_STUB IMallocSpy_PreAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PostAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pActual);


void __RPC_STUB IMallocSpy_PostAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PreFree_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PostFree_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMallocSpy_PreRealloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ ULONG cbRequest,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PostRealloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pActual,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PreGetSize_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMallocSpy_PostGetSize_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ ULONG cbActual,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PreDidAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int __stdcall IMallocSpy_PostDidAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed,
    /* [in] */ int fActual);


void __RPC_STUB IMallocSpy_PostDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PreHeapMinimize_Proxy( 
    IMallocSpy __RPC_FAR * This);


void __RPC_STUB IMallocSpy_PreHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PostHeapMinimize_Proxy( 
    IMallocSpy __RPC_FAR * This);


void __RPC_STUB IMallocSpy_PostHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMallocSpy_INTERFACE_DEFINED__ */


#ifndef __IStdMarshalInfo_INTERFACE_DEFINED__
#define __IStdMarshalInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStdMarshalInfo
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IStdMarshalInfo __RPC_FAR *LPSTDMARSHALINFO;


EXTERN_C const IID IID_IStdMarshalInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IStdMarshalInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassForHandler( 
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStdMarshalInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IStdMarshalInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IStdMarshalInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IStdMarshalInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassForHandler )( 
            IStdMarshalInfo __RPC_FAR * This,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid);
        
    } IStdMarshalInfoVtbl;

    interface IStdMarshalInfo
    {
        CONST_VTBL struct IStdMarshalInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStdMarshalInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStdMarshalInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStdMarshalInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStdMarshalInfo_GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)	\
    (This)->lpVtbl -> GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IStdMarshalInfo_GetClassForHandler_Proxy( 
    IStdMarshalInfo __RPC_FAR * This,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [out] */ CLSID __RPC_FAR *pClsid);


void __RPC_STUB IStdMarshalInfo_GetClassForHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStdMarshalInfo_INTERFACE_DEFINED__ */


#ifndef __IExternalConnection_INTERFACE_DEFINED__
#define __IExternalConnection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExternalConnection
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */ IExternalConnection __RPC_FAR *LPEXTERNALCONNECTION;

			/* size is 2 */
typedef 
enum tagEXTCONN
    {	EXTCONN_STRONG	= 0x1,
	EXTCONN_WEAK	= 0x2,
	EXTCONN_CALLABLE	= 0x4
    }	EXTCONN;


EXTERN_C const IID IID_IExternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IExternalConnection : public IUnknown
    {
    public:
        virtual DWORD __stdcall AddConnection( 
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved) = 0;
        
        virtual DWORD __stdcall ReleaseConnection( 
            /* [in] */ DWORD extconn,
            /* [in] */ DW